{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA1Mjc2NTM3", "number": 8777, "reviewThreads": {"totalCount": 26, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNjoxNDoxN1rOE80ANA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxOTo1MjozMVrOE-0Q0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMjAyMDM2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/VeluxBindingConstants.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNjoxNDoxN1rOH5KQiA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxMDo1NToyNFrOH5t4_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTY5ODk1Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static final Set<ThingTypeUID> DISCOVERABLE_THINGS = new HashSet<>(\n          \n          \n            \n                        Arrays.asList(THING_TYPE_VELUX_SCENE, THING_TYPE_VELUX_ACTUATOR, THING_TYPE_VELUX_ROLLERSHUTTER,\n          \n          \n            \n                                THING_TYPE_VELUX_WINDOW, THING_TYPE_VELUX_VSHUTTER, THING_TYPE_BINDING, THING_TYPE_BRIDGE));\n          \n          \n            \n                public static final Set<ThingTypeUID> DISCOVERABLE_THINGS = new HashSet<>(\n          \n          \n            \n                public static final Set<ThingTypeUID> DISCOVERABLE_THINGS = Set.of(THING_TYPE_VELUX_SCENE,\n          \n          \n            \n                        THING_TYPE_VELUX_ACTUATOR, THING_TYPE_VELUX_ROLLERSHUTTER, THING_TYPE_VELUX_WINDOW,\n          \n          \n            \n                        THING_TYPE_VELUX_VSHUTTER, THING_TYPE_BINDING, THING_TYPE_BRIDGE);", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r529698952", "createdAt": "2020-11-24T16:14:17Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/VeluxBindingConstants.java", "diffHunk": "@@ -91,10 +91,15 @@\n     // Definitions of different set of Things\n     public static final Set<ThingTypeUID> SUPPORTED_THINGS_BINDING = new HashSet<>(Arrays.asList(THING_TYPE_BINDING));\n     public static final Set<ThingTypeUID> SUPPORTED_THINGS_BRIDGE = new HashSet<>(Arrays.asList(THING_TYPE_BRIDGE));\n+\n     public static final Set<ThingTypeUID> SUPPORTED_THINGS_ITEMS = new HashSet<>(\n             Arrays.asList(THING_TYPE_VELUX_SCENE, THING_TYPE_VELUX_ACTUATOR, THING_TYPE_VELUX_ROLLERSHUTTER,\n                     THING_TYPE_VELUX_WINDOW, THING_TYPE_VELUX_VSHUTTER));\n \n+    public static final Set<ThingTypeUID> DISCOVERABLE_THINGS = new HashSet<>(\n+            Arrays.asList(THING_TYPE_VELUX_SCENE, THING_TYPE_VELUX_ACTUATOR, THING_TYPE_VELUX_ROLLERSHUTTER,\n+                    THING_TYPE_VELUX_WINDOW, THING_TYPE_VELUX_VSHUTTER, THING_TYPE_BINDING, THING_TYPE_BRIDGE));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68dad575579d134733613144caffad0a127675f4"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDI4Mjc1MA==", "bodyText": "Ok", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r530282750", "createdAt": "2020-11-25T10:55:24Z", "author": {"login": "andrewfg"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/VeluxBindingConstants.java", "diffHunk": "@@ -91,10 +91,15 @@\n     // Definitions of different set of Things\n     public static final Set<ThingTypeUID> SUPPORTED_THINGS_BINDING = new HashSet<>(Arrays.asList(THING_TYPE_BINDING));\n     public static final Set<ThingTypeUID> SUPPORTED_THINGS_BRIDGE = new HashSet<>(Arrays.asList(THING_TYPE_BRIDGE));\n+\n     public static final Set<ThingTypeUID> SUPPORTED_THINGS_ITEMS = new HashSet<>(\n             Arrays.asList(THING_TYPE_VELUX_SCENE, THING_TYPE_VELUX_ACTUATOR, THING_TYPE_VELUX_ROLLERSHUTTER,\n                     THING_TYPE_VELUX_WINDOW, THING_TYPE_VELUX_VSHUTTER));\n \n+    public static final Set<ThingTypeUID> DISCOVERABLE_THINGS = new HashSet<>(\n+            Arrays.asList(THING_TYPE_VELUX_SCENE, THING_TYPE_VELUX_ACTUATOR, THING_TYPE_VELUX_ROLLERSHUTTER,\n+                    THING_TYPE_VELUX_WINDOW, THING_TYPE_VELUX_VSHUTTER, THING_TYPE_BINDING, THING_TYPE_BRIDGE));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTY5ODk1Mg=="}, "originalCommit": {"oid": "68dad575579d134733613144caffad0a127675f4"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMjA0MTM0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/action/VeluxActions.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNjoxNzoxNFrOH5Kdjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxMDo1NjoxM1rOH5t7FA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTcwMjI4Ng==", "bodyText": "The label is integrated into a sentence (When ... then ...) in the rules and should therefore be lowercase. Same for below.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @RuleAction(label = \"Reboot Bridge\", description = \"issues a reboot command to the KLF200 bridge\")\n          \n          \n            \n                @RuleAction(label = \"reboot Bridge\", description = \"issues a reboot command to the KLF200 bridge\")", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r529702286", "createdAt": "2020-11-24T16:17:14Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/action/VeluxActions.java", "diffHunk": "@@ -0,0 +1,119 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.velux.internal.action;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.velux.internal.handler.VeluxBridgeHandler;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.ActionOutput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+import org.openhab.core.thing.binding.ThingActions;\n+import org.openhab.core.thing.binding.ThingActionsScope;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link VeluxActions} implementation of the rule action for rebooting the bridge\n+ *\n+ * @author Andrew Fiddian-Green - Initial contribution\n+ */\n+@ThingActionsScope(name = \"velux\")\n+@NonNullByDefault\n+public class VeluxActions implements ThingActions, IVeluxActions {\n+\n+    private final Logger logger = LoggerFactory.getLogger(VeluxActions.class);\n+\n+    private @Nullable VeluxBridgeHandler bridgeHandler;\n+\n+    @Override\n+    public void setThingHandler(@Nullable ThingHandler handler) {\n+        if (handler instanceof VeluxBridgeHandler) {\n+            this.bridgeHandler = (VeluxBridgeHandler) handler;\n+        }\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return this.bridgeHandler;\n+    }\n+\n+    @Override\n+    @RuleAction(label = \"Reboot Bridge\", description = \"issues a reboot command to the KLF200 bridge\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68dad575579d134733613144caffad0a127675f4"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDI4MzI4NA==", "bodyText": "Ok.", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r530283284", "createdAt": "2020-11-25T10:56:13Z", "author": {"login": "andrewfg"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/action/VeluxActions.java", "diffHunk": "@@ -0,0 +1,119 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.velux.internal.action;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.velux.internal.handler.VeluxBridgeHandler;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.ActionOutput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+import org.openhab.core.thing.binding.ThingActions;\n+import org.openhab.core.thing.binding.ThingActionsScope;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link VeluxActions} implementation of the rule action for rebooting the bridge\n+ *\n+ * @author Andrew Fiddian-Green - Initial contribution\n+ */\n+@ThingActionsScope(name = \"velux\")\n+@NonNullByDefault\n+public class VeluxActions implements ThingActions, IVeluxActions {\n+\n+    private final Logger logger = LoggerFactory.getLogger(VeluxActions.class);\n+\n+    private @Nullable VeluxBridgeHandler bridgeHandler;\n+\n+    @Override\n+    public void setThingHandler(@Nullable ThingHandler handler) {\n+        if (handler instanceof VeluxBridgeHandler) {\n+            this.bridgeHandler = (VeluxBridgeHandler) handler;\n+        }\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return this.bridgeHandler;\n+    }\n+\n+    @Override\n+    @RuleAction(label = \"Reboot Bridge\", description = \"issues a reboot command to the KLF200 bridge\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTcwMjI4Ng=="}, "originalCommit": {"oid": "68dad575579d134733613144caffad0a127675f4"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMjA1NDMwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/action/VeluxActions.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNjoyMDowMFrOH5Kljg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxMTowOTowNFrOH5uasQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTcwNDMzNA==", "bodyText": "You could add required/label/description to the input arguments.", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r529704334", "createdAt": "2020-11-24T16:20:00Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/action/VeluxActions.java", "diffHunk": "@@ -0,0 +1,119 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.velux.internal.action;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.velux.internal.handler.VeluxBridgeHandler;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.ActionOutput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+import org.openhab.core.thing.binding.ThingActions;\n+import org.openhab.core.thing.binding.ThingActionsScope;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link VeluxActions} implementation of the rule action for rebooting the bridge\n+ *\n+ * @author Andrew Fiddian-Green - Initial contribution\n+ */\n+@ThingActionsScope(name = \"velux\")\n+@NonNullByDefault\n+public class VeluxActions implements ThingActions, IVeluxActions {\n+\n+    private final Logger logger = LoggerFactory.getLogger(VeluxActions.class);\n+\n+    private @Nullable VeluxBridgeHandler bridgeHandler;\n+\n+    @Override\n+    public void setThingHandler(@Nullable ThingHandler handler) {\n+        if (handler instanceof VeluxBridgeHandler) {\n+            this.bridgeHandler = (VeluxBridgeHandler) handler;\n+        }\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return this.bridgeHandler;\n+    }\n+\n+    @Override\n+    @RuleAction(label = \"Reboot Bridge\", description = \"issues a reboot command to the KLF200 bridge\")\n+    public @ActionOutput(name = \"executing\", type = \"java.lang.Boolean\") Boolean rebootBridge()\n+            throws IllegalStateException {\n+        logger.trace(\"rebootBridge(): action called\");\n+        VeluxBridgeHandler bridge = bridgeHandler;\n+        if (bridge == null) {\n+            throw new IllegalStateException(\"Bridge instance is null\");\n+        }\n+        return bridge.runReboot();\n+    }\n+\n+    @Override\n+    @RuleAction(label = \"Move Relative\", description = \"issues a relative move command to an actuator\")\n+    public @ActionOutput(name = \"executing\", type = \"java.lang.Boolean\") Boolean moveRelative(\n+            @ActionInput(name = \"nodeId\") String nodeId, @ActionInput(name = \"relativePercent\") String relativePercent)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68dad575579d134733613144caffad0a127675f4"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDI5MTM3Nw==", "bodyText": "Ok.", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r530291377", "createdAt": "2020-11-25T11:09:04Z", "author": {"login": "andrewfg"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/action/VeluxActions.java", "diffHunk": "@@ -0,0 +1,119 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.velux.internal.action;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.velux.internal.handler.VeluxBridgeHandler;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.ActionOutput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+import org.openhab.core.thing.binding.ThingActions;\n+import org.openhab.core.thing.binding.ThingActionsScope;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link VeluxActions} implementation of the rule action for rebooting the bridge\n+ *\n+ * @author Andrew Fiddian-Green - Initial contribution\n+ */\n+@ThingActionsScope(name = \"velux\")\n+@NonNullByDefault\n+public class VeluxActions implements ThingActions, IVeluxActions {\n+\n+    private final Logger logger = LoggerFactory.getLogger(VeluxActions.class);\n+\n+    private @Nullable VeluxBridgeHandler bridgeHandler;\n+\n+    @Override\n+    public void setThingHandler(@Nullable ThingHandler handler) {\n+        if (handler instanceof VeluxBridgeHandler) {\n+            this.bridgeHandler = (VeluxBridgeHandler) handler;\n+        }\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return this.bridgeHandler;\n+    }\n+\n+    @Override\n+    @RuleAction(label = \"Reboot Bridge\", description = \"issues a reboot command to the KLF200 bridge\")\n+    public @ActionOutput(name = \"executing\", type = \"java.lang.Boolean\") Boolean rebootBridge()\n+            throws IllegalStateException {\n+        logger.trace(\"rebootBridge(): action called\");\n+        VeluxBridgeHandler bridge = bridgeHandler;\n+        if (bridge == null) {\n+            throw new IllegalStateException(\"Bridge instance is null\");\n+        }\n+        return bridge.runReboot();\n+    }\n+\n+    @Override\n+    @RuleAction(label = \"Move Relative\", description = \"issues a relative move command to an actuator\")\n+    public @ActionOutput(name = \"executing\", type = \"java.lang.Boolean\") Boolean moveRelative(\n+            @ActionInput(name = \"nodeId\") String nodeId, @ActionInput(name = \"relativePercent\") String relativePercent)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTcwNDMzNA=="}, "originalCommit": {"oid": "68dad575579d134733613144caffad0a127675f4"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMjA4NTc5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/bridge/slip/SlipVeluxBridge.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNjoyNjo0MVrOH5K5JQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxNzoxOTowNVrOH59MAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTcwOTM0OQ==", "bodyText": "Logging to info should be used sparsely e.g. a newly started component or a user file that has been loaded. This could be trace. Same for below.", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r529709349", "createdAt": "2020-11-24T16:26:41Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/bridge/slip/SlipVeluxBridge.java", "diffHunk": "@@ -181,214 +182,244 @@ public long lastSuccessfulCommunication() {\n     }\n \n     /**\n-     * Initializes a client/server communication towards <b>Velux</b> veluxBridge\n-     * based on the Basic I/O interface {@link Connection#io} and parameters\n-     * passed as arguments (see below).\n+     * Initializes a client/server communication towards the Velux Bridge based on the Basic I/O interface\n+     * {@link Connection#io} and parameters passed as arguments (see below).\n      *\n-     * @param communication Structure of interface type {@link SlipBridgeCommunicationProtocol} describing the\n+     * @param communication a structure of interface type {@link SlipBridgeCommunicationProtocol} describing the\n      *            intended communication, that is request and response interactions as well as appropriate URL\n      *            definition.\n-     * @param useAuthentication boolean flag to decide whether to use authenticated communication.\n-     * @return <b>success</b> of type boolean which signals the success of the communication.\n+     * @param useAuthentication a boolean flag to select whether to use authenticated communication.\n+     * @return a boolean which in general signals the success of the communication, but in the\n+     *         special case of receive-only calls, signals if any products were updated during the call\n      */\n     private synchronized boolean bridgeDirectCommunicate(SlipBridgeCommunicationProtocol communication,\n             boolean useAuthentication) {\n-        String host = this.bridgeInstance.veluxBridgeConfiguration().ipAddress;\n-        logger.trace(\"bridgeDirectCommunicate({},{}authenticated) on {} called.\", host, communication.name(),\n+        logger.trace(\"bridgeDirectCommunicate() '{}', {}authenticated\", communication.name(),\n                 useAuthentication ? \"\" : \"un\");\n \n-        assert this.bridgeInstance.veluxBridgeConfiguration().protocol.contentEquals(\"slip\");\n-\n-        long communicationStartInMSecs = System.currentTimeMillis();\n+        // store common parameters as constants for frequent use\n+        final short txCmd = communication.getRequestCommand().toShort();\n+        final byte[] txData = communication.getRequestDataAsArrayOfBytes();\n+        final Command txEnum = Command.get(txCmd);\n+        final String txName = txEnum.toString();\n+        final boolean isSequentialEnforced = this.bridgeInstance.veluxBridgeConfiguration().isSequentialEnforced;\n+        final boolean isProtocolTraceEnabled = this.bridgeInstance.veluxBridgeConfiguration().isProtocolTraceEnabled;\n+        final long expiryTime = System.currentTimeMillis() + COMMUNICATION_TIMEOUT_MSECS;\n \n-        boolean isSequentialEnforced = this.bridgeInstance.veluxBridgeConfiguration().isSequentialEnforced;\n-        boolean isProtocolTraceEnabled = this.bridgeInstance.veluxBridgeConfiguration().isProtocolTraceEnabled;\n+        // logger format string\n+        final String loggerFmt = String.format(\"bridgeDirectCommunicate() [%s] %s => {} {} {}\",\n+                this.bridgeInstance.veluxBridgeConfiguration().ipAddress, txName);\n \n-        // From parameters\n-        short command = communication.getRequestCommand().toShort();\n-        byte[] data = communication.getRequestDataAsArrayOfBytes();\n-        // For further use at different logging statements\n-        String commandString = Command.get(command).toString();\n+        assert this.bridgeInstance.veluxBridgeConfiguration().protocol.contentEquals(\"slip\");\n \n         if (isProtocolTraceEnabled) {\n             Threads.findDeadlocked();\n         }\n \n-        logger.debug(\"bridgeDirectCommunicate({},{}authenticated) on {} initiated by {}.\", host, commandString,\n-                useAuthentication ? \"\" : \"un\", Thread.currentThread());\n-        boolean success = false;\n+        logger.debug(loggerFmt, \"started =>\", Thread.currentThread(), \"\");\n \n-        communication: do {\n-            if (communicationStartInMSecs + COMMUNICATION_TIMEOUT_MSECS < System.currentTimeMillis()) {\n-                logger.warn(\n-                        \"{} bridgeDirectCommunicate({}) on {}: communication handshake failed (unexpected sequence of requests/responses).\",\n-                        VeluxBindingConstants.BINDING_VALUES_SEPARATOR, communication.name(), host);\n-                break;\n-            }\n+        boolean looping = false;\n+        boolean success = false;\n+        boolean sending = false;\n+        boolean rcvonly = false;\n+        byte[] txPacket = emptyPacket;\n \n-            // Special handling\n-            if (Command.get(command) == Command.GW_OPENHAB_CLOSE) {\n-                logger.trace(\"bridgeDirectCommunicate(): special command: shutting down connection.\");\n+        // handling of the requests\n+        switch (txEnum) {\n+            case GW_OPENHAB_CLOSE:\n+                logger.trace(loggerFmt, \"shut down command\", \"=> executing\", \"\");\n                 connection.resetConnection();\n                 success = true;\n-                continue;\n-            }\n+                break;\n \n-            // Normal processing\n-            logger.trace(\"bridgeDirectCommunicate() on {}: working on request {} with {} bytes of data.\", host,\n-                    commandString, data.length);\n-            byte[] sendBytes = emptyPacket;\n-            if (Command.get(command) == Command.GW_OPENHAB_RECEIVEONLY) {\n-                logger.trace(\n-                        \"bridgeDirectCommunicate() on {}: special command: determine whether there is any message waiting.\",\n-                        host);\n-                logger.trace(\"bridgeDirectCommunicate(): check for a waiting message.\");\n-                if (!connection.isMessageAvailable()) {\n-                    logger.trace(\"bridgeDirectCommunicate() on {}: no message waiting, aborting.\", host);\n-                    break communication;\n+            case GW_OPENHAB_RECEIVEONLY:\n+                logger.trace(loggerFmt, \"receive-only mode\", \"=> checking messages\", \"\");\n+                if (!connection.isAlive()) {\n+                    logger.trace(loggerFmt, \"no connection\", \"=> opening\", \"\");\n+                    looping = true;\n+                } else if (connection.isMessageAvailable()) {\n+                    logger.trace(loggerFmt, \"message(s) waiting\", \"=> start reading\", \"\");\n+                    looping = true;\n+                } else {\n+                    logger.trace(loggerFmt, \"no waiting messages\", \"=> done\", \"\");\n                 }\n-                logger.trace(\"bridgeDirectCommunicate() on {}: there is a message waiting.\", host);\n-            } else {\n-                SlipEncoding t = new SlipEncoding(command, data);\n-                if (!t.isValid()) {\n-                    logger.warn(\"bridgeDirectCommunicate() on {}: SlipEncoding() failed, aborting.\", host);\n+                rcvonly = true;\n+                break;\n+\n+            default:\n+                logger.trace(loggerFmt, \"send mode\", \"=> preparing command\", \"\");\n+                SlipEncoding slipEnc = new SlipEncoding(txCmd, txData);\n+                if (!slipEnc.isValid()) {\n+                    logger.debug(loggerFmt, \"slip encoding error\", \"=> aborting\", \"\");\n                     break;\n                 }\n-                logger.trace(\"bridgeDirectCommunicate() on {}: transportEncoding={}.\", host, t.toString());\n-                sendBytes = new SlipRFC1055().encode(t.toMessage());\n+                txPacket = new SlipRFC1055().encode(slipEnc.toMessage());\n+                logger.trace(loggerFmt, \"command ready\", \"=> start sending\", \"\");\n+                looping = sending = true;\n+        }\n+\n+        while (looping) {\n+            // timeout\n+            if (System.currentTimeMillis() > expiryTime) {\n+                logger.warn(loggerFmt, \"process loop time out\", \"=> aborting\", \"=> PLEASE REPORT !!\");\n+                looping = false;\n+                break;\n             }\n-            do {\n-                if (communicationStartInMSecs + COMMUNICATION_TIMEOUT_MSECS < System.currentTimeMillis()) {\n-                    logger.warn(\"bridgeDirectCommunicate() on {}: receive takes too long. Please report to maintainer.\",\n-                            host);\n-                    break communication;\n-                }\n-                byte[] receivedPacket;\n-                try {\n-                    if (sendBytes.length > 0) {\n-                        logger.trace(\"bridgeDirectCommunicate() on {}: sending {} bytes.\", host, sendBytes.length);\n-                        if (isProtocolTraceEnabled) {\n-                            logger.info(\"Sending command {}.\", commandString);\n-                        }\n+\n+            // send command (optionally), and receive response\n+            byte[] rxPacket;\n+            try {\n+                if (sending) {\n+                    if (isProtocolTraceEnabled) {\n+                        logger.info(\"sending command {}\", txName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68dad575579d134733613144caffad0a127675f4"}, "originalPosition": 212}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDI5NjkxMA==", "bodyText": "@fwolter in general I agree with you, but in this case not..\nWhen Guenther (@gs4711 ) originally wrote the binding, he implemented a Configuration Parameter isProtocolTraceEnabled which defaults to false, but which can be enabled by the user to get more detailed insight into the bridge protocol. So all such calls to logger.info are wrapped in the conditional if (isProtocolTraceEnabled).\nI agree with you that if I were writing the binding today, I would not have used a isProtocolTraceEnabled  parameter but rather have used the log:set command. However this is something of long standing in the binding, that I am reluctant to tamper with.", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r530296910", "createdAt": "2020-11-25T11:18:07Z", "author": {"login": "andrewfg"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/bridge/slip/SlipVeluxBridge.java", "diffHunk": "@@ -181,214 +182,244 @@ public long lastSuccessfulCommunication() {\n     }\n \n     /**\n-     * Initializes a client/server communication towards <b>Velux</b> veluxBridge\n-     * based on the Basic I/O interface {@link Connection#io} and parameters\n-     * passed as arguments (see below).\n+     * Initializes a client/server communication towards the Velux Bridge based on the Basic I/O interface\n+     * {@link Connection#io} and parameters passed as arguments (see below).\n      *\n-     * @param communication Structure of interface type {@link SlipBridgeCommunicationProtocol} describing the\n+     * @param communication a structure of interface type {@link SlipBridgeCommunicationProtocol} describing the\n      *            intended communication, that is request and response interactions as well as appropriate URL\n      *            definition.\n-     * @param useAuthentication boolean flag to decide whether to use authenticated communication.\n-     * @return <b>success</b> of type boolean which signals the success of the communication.\n+     * @param useAuthentication a boolean flag to select whether to use authenticated communication.\n+     * @return a boolean which in general signals the success of the communication, but in the\n+     *         special case of receive-only calls, signals if any products were updated during the call\n      */\n     private synchronized boolean bridgeDirectCommunicate(SlipBridgeCommunicationProtocol communication,\n             boolean useAuthentication) {\n-        String host = this.bridgeInstance.veluxBridgeConfiguration().ipAddress;\n-        logger.trace(\"bridgeDirectCommunicate({},{}authenticated) on {} called.\", host, communication.name(),\n+        logger.trace(\"bridgeDirectCommunicate() '{}', {}authenticated\", communication.name(),\n                 useAuthentication ? \"\" : \"un\");\n \n-        assert this.bridgeInstance.veluxBridgeConfiguration().protocol.contentEquals(\"slip\");\n-\n-        long communicationStartInMSecs = System.currentTimeMillis();\n+        // store common parameters as constants for frequent use\n+        final short txCmd = communication.getRequestCommand().toShort();\n+        final byte[] txData = communication.getRequestDataAsArrayOfBytes();\n+        final Command txEnum = Command.get(txCmd);\n+        final String txName = txEnum.toString();\n+        final boolean isSequentialEnforced = this.bridgeInstance.veluxBridgeConfiguration().isSequentialEnforced;\n+        final boolean isProtocolTraceEnabled = this.bridgeInstance.veluxBridgeConfiguration().isProtocolTraceEnabled;\n+        final long expiryTime = System.currentTimeMillis() + COMMUNICATION_TIMEOUT_MSECS;\n \n-        boolean isSequentialEnforced = this.bridgeInstance.veluxBridgeConfiguration().isSequentialEnforced;\n-        boolean isProtocolTraceEnabled = this.bridgeInstance.veluxBridgeConfiguration().isProtocolTraceEnabled;\n+        // logger format string\n+        final String loggerFmt = String.format(\"bridgeDirectCommunicate() [%s] %s => {} {} {}\",\n+                this.bridgeInstance.veluxBridgeConfiguration().ipAddress, txName);\n \n-        // From parameters\n-        short command = communication.getRequestCommand().toShort();\n-        byte[] data = communication.getRequestDataAsArrayOfBytes();\n-        // For further use at different logging statements\n-        String commandString = Command.get(command).toString();\n+        assert this.bridgeInstance.veluxBridgeConfiguration().protocol.contentEquals(\"slip\");\n \n         if (isProtocolTraceEnabled) {\n             Threads.findDeadlocked();\n         }\n \n-        logger.debug(\"bridgeDirectCommunicate({},{}authenticated) on {} initiated by {}.\", host, commandString,\n-                useAuthentication ? \"\" : \"un\", Thread.currentThread());\n-        boolean success = false;\n+        logger.debug(loggerFmt, \"started =>\", Thread.currentThread(), \"\");\n \n-        communication: do {\n-            if (communicationStartInMSecs + COMMUNICATION_TIMEOUT_MSECS < System.currentTimeMillis()) {\n-                logger.warn(\n-                        \"{} bridgeDirectCommunicate({}) on {}: communication handshake failed (unexpected sequence of requests/responses).\",\n-                        VeluxBindingConstants.BINDING_VALUES_SEPARATOR, communication.name(), host);\n-                break;\n-            }\n+        boolean looping = false;\n+        boolean success = false;\n+        boolean sending = false;\n+        boolean rcvonly = false;\n+        byte[] txPacket = emptyPacket;\n \n-            // Special handling\n-            if (Command.get(command) == Command.GW_OPENHAB_CLOSE) {\n-                logger.trace(\"bridgeDirectCommunicate(): special command: shutting down connection.\");\n+        // handling of the requests\n+        switch (txEnum) {\n+            case GW_OPENHAB_CLOSE:\n+                logger.trace(loggerFmt, \"shut down command\", \"=> executing\", \"\");\n                 connection.resetConnection();\n                 success = true;\n-                continue;\n-            }\n+                break;\n \n-            // Normal processing\n-            logger.trace(\"bridgeDirectCommunicate() on {}: working on request {} with {} bytes of data.\", host,\n-                    commandString, data.length);\n-            byte[] sendBytes = emptyPacket;\n-            if (Command.get(command) == Command.GW_OPENHAB_RECEIVEONLY) {\n-                logger.trace(\n-                        \"bridgeDirectCommunicate() on {}: special command: determine whether there is any message waiting.\",\n-                        host);\n-                logger.trace(\"bridgeDirectCommunicate(): check for a waiting message.\");\n-                if (!connection.isMessageAvailable()) {\n-                    logger.trace(\"bridgeDirectCommunicate() on {}: no message waiting, aborting.\", host);\n-                    break communication;\n+            case GW_OPENHAB_RECEIVEONLY:\n+                logger.trace(loggerFmt, \"receive-only mode\", \"=> checking messages\", \"\");\n+                if (!connection.isAlive()) {\n+                    logger.trace(loggerFmt, \"no connection\", \"=> opening\", \"\");\n+                    looping = true;\n+                } else if (connection.isMessageAvailable()) {\n+                    logger.trace(loggerFmt, \"message(s) waiting\", \"=> start reading\", \"\");\n+                    looping = true;\n+                } else {\n+                    logger.trace(loggerFmt, \"no waiting messages\", \"=> done\", \"\");\n                 }\n-                logger.trace(\"bridgeDirectCommunicate() on {}: there is a message waiting.\", host);\n-            } else {\n-                SlipEncoding t = new SlipEncoding(command, data);\n-                if (!t.isValid()) {\n-                    logger.warn(\"bridgeDirectCommunicate() on {}: SlipEncoding() failed, aborting.\", host);\n+                rcvonly = true;\n+                break;\n+\n+            default:\n+                logger.trace(loggerFmt, \"send mode\", \"=> preparing command\", \"\");\n+                SlipEncoding slipEnc = new SlipEncoding(txCmd, txData);\n+                if (!slipEnc.isValid()) {\n+                    logger.debug(loggerFmt, \"slip encoding error\", \"=> aborting\", \"\");\n                     break;\n                 }\n-                logger.trace(\"bridgeDirectCommunicate() on {}: transportEncoding={}.\", host, t.toString());\n-                sendBytes = new SlipRFC1055().encode(t.toMessage());\n+                txPacket = new SlipRFC1055().encode(slipEnc.toMessage());\n+                logger.trace(loggerFmt, \"command ready\", \"=> start sending\", \"\");\n+                looping = sending = true;\n+        }\n+\n+        while (looping) {\n+            // timeout\n+            if (System.currentTimeMillis() > expiryTime) {\n+                logger.warn(loggerFmt, \"process loop time out\", \"=> aborting\", \"=> PLEASE REPORT !!\");\n+                looping = false;\n+                break;\n             }\n-            do {\n-                if (communicationStartInMSecs + COMMUNICATION_TIMEOUT_MSECS < System.currentTimeMillis()) {\n-                    logger.warn(\"bridgeDirectCommunicate() on {}: receive takes too long. Please report to maintainer.\",\n-                            host);\n-                    break communication;\n-                }\n-                byte[] receivedPacket;\n-                try {\n-                    if (sendBytes.length > 0) {\n-                        logger.trace(\"bridgeDirectCommunicate() on {}: sending {} bytes.\", host, sendBytes.length);\n-                        if (isProtocolTraceEnabled) {\n-                            logger.info(\"Sending command {}.\", commandString);\n-                        }\n+\n+            // send command (optionally), and receive response\n+            byte[] rxPacket;\n+            try {\n+                if (sending) {\n+                    if (isProtocolTraceEnabled) {\n+                        logger.info(\"sending command {}\", txName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTcwOTM0OQ=="}, "originalCommit": {"oid": "68dad575579d134733613144caffad0a127675f4"}, "originalPosition": 212}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDUzMzM3Nw==", "bodyText": "Ok", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r530533377", "createdAt": "2020-11-25T17:19:05Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/bridge/slip/SlipVeluxBridge.java", "diffHunk": "@@ -181,214 +182,244 @@ public long lastSuccessfulCommunication() {\n     }\n \n     /**\n-     * Initializes a client/server communication towards <b>Velux</b> veluxBridge\n-     * based on the Basic I/O interface {@link Connection#io} and parameters\n-     * passed as arguments (see below).\n+     * Initializes a client/server communication towards the Velux Bridge based on the Basic I/O interface\n+     * {@link Connection#io} and parameters passed as arguments (see below).\n      *\n-     * @param communication Structure of interface type {@link SlipBridgeCommunicationProtocol} describing the\n+     * @param communication a structure of interface type {@link SlipBridgeCommunicationProtocol} describing the\n      *            intended communication, that is request and response interactions as well as appropriate URL\n      *            definition.\n-     * @param useAuthentication boolean flag to decide whether to use authenticated communication.\n-     * @return <b>success</b> of type boolean which signals the success of the communication.\n+     * @param useAuthentication a boolean flag to select whether to use authenticated communication.\n+     * @return a boolean which in general signals the success of the communication, but in the\n+     *         special case of receive-only calls, signals if any products were updated during the call\n      */\n     private synchronized boolean bridgeDirectCommunicate(SlipBridgeCommunicationProtocol communication,\n             boolean useAuthentication) {\n-        String host = this.bridgeInstance.veluxBridgeConfiguration().ipAddress;\n-        logger.trace(\"bridgeDirectCommunicate({},{}authenticated) on {} called.\", host, communication.name(),\n+        logger.trace(\"bridgeDirectCommunicate() '{}', {}authenticated\", communication.name(),\n                 useAuthentication ? \"\" : \"un\");\n \n-        assert this.bridgeInstance.veluxBridgeConfiguration().protocol.contentEquals(\"slip\");\n-\n-        long communicationStartInMSecs = System.currentTimeMillis();\n+        // store common parameters as constants for frequent use\n+        final short txCmd = communication.getRequestCommand().toShort();\n+        final byte[] txData = communication.getRequestDataAsArrayOfBytes();\n+        final Command txEnum = Command.get(txCmd);\n+        final String txName = txEnum.toString();\n+        final boolean isSequentialEnforced = this.bridgeInstance.veluxBridgeConfiguration().isSequentialEnforced;\n+        final boolean isProtocolTraceEnabled = this.bridgeInstance.veluxBridgeConfiguration().isProtocolTraceEnabled;\n+        final long expiryTime = System.currentTimeMillis() + COMMUNICATION_TIMEOUT_MSECS;\n \n-        boolean isSequentialEnforced = this.bridgeInstance.veluxBridgeConfiguration().isSequentialEnforced;\n-        boolean isProtocolTraceEnabled = this.bridgeInstance.veluxBridgeConfiguration().isProtocolTraceEnabled;\n+        // logger format string\n+        final String loggerFmt = String.format(\"bridgeDirectCommunicate() [%s] %s => {} {} {}\",\n+                this.bridgeInstance.veluxBridgeConfiguration().ipAddress, txName);\n \n-        // From parameters\n-        short command = communication.getRequestCommand().toShort();\n-        byte[] data = communication.getRequestDataAsArrayOfBytes();\n-        // For further use at different logging statements\n-        String commandString = Command.get(command).toString();\n+        assert this.bridgeInstance.veluxBridgeConfiguration().protocol.contentEquals(\"slip\");\n \n         if (isProtocolTraceEnabled) {\n             Threads.findDeadlocked();\n         }\n \n-        logger.debug(\"bridgeDirectCommunicate({},{}authenticated) on {} initiated by {}.\", host, commandString,\n-                useAuthentication ? \"\" : \"un\", Thread.currentThread());\n-        boolean success = false;\n+        logger.debug(loggerFmt, \"started =>\", Thread.currentThread(), \"\");\n \n-        communication: do {\n-            if (communicationStartInMSecs + COMMUNICATION_TIMEOUT_MSECS < System.currentTimeMillis()) {\n-                logger.warn(\n-                        \"{} bridgeDirectCommunicate({}) on {}: communication handshake failed (unexpected sequence of requests/responses).\",\n-                        VeluxBindingConstants.BINDING_VALUES_SEPARATOR, communication.name(), host);\n-                break;\n-            }\n+        boolean looping = false;\n+        boolean success = false;\n+        boolean sending = false;\n+        boolean rcvonly = false;\n+        byte[] txPacket = emptyPacket;\n \n-            // Special handling\n-            if (Command.get(command) == Command.GW_OPENHAB_CLOSE) {\n-                logger.trace(\"bridgeDirectCommunicate(): special command: shutting down connection.\");\n+        // handling of the requests\n+        switch (txEnum) {\n+            case GW_OPENHAB_CLOSE:\n+                logger.trace(loggerFmt, \"shut down command\", \"=> executing\", \"\");\n                 connection.resetConnection();\n                 success = true;\n-                continue;\n-            }\n+                break;\n \n-            // Normal processing\n-            logger.trace(\"bridgeDirectCommunicate() on {}: working on request {} with {} bytes of data.\", host,\n-                    commandString, data.length);\n-            byte[] sendBytes = emptyPacket;\n-            if (Command.get(command) == Command.GW_OPENHAB_RECEIVEONLY) {\n-                logger.trace(\n-                        \"bridgeDirectCommunicate() on {}: special command: determine whether there is any message waiting.\",\n-                        host);\n-                logger.trace(\"bridgeDirectCommunicate(): check for a waiting message.\");\n-                if (!connection.isMessageAvailable()) {\n-                    logger.trace(\"bridgeDirectCommunicate() on {}: no message waiting, aborting.\", host);\n-                    break communication;\n+            case GW_OPENHAB_RECEIVEONLY:\n+                logger.trace(loggerFmt, \"receive-only mode\", \"=> checking messages\", \"\");\n+                if (!connection.isAlive()) {\n+                    logger.trace(loggerFmt, \"no connection\", \"=> opening\", \"\");\n+                    looping = true;\n+                } else if (connection.isMessageAvailable()) {\n+                    logger.trace(loggerFmt, \"message(s) waiting\", \"=> start reading\", \"\");\n+                    looping = true;\n+                } else {\n+                    logger.trace(loggerFmt, \"no waiting messages\", \"=> done\", \"\");\n                 }\n-                logger.trace(\"bridgeDirectCommunicate() on {}: there is a message waiting.\", host);\n-            } else {\n-                SlipEncoding t = new SlipEncoding(command, data);\n-                if (!t.isValid()) {\n-                    logger.warn(\"bridgeDirectCommunicate() on {}: SlipEncoding() failed, aborting.\", host);\n+                rcvonly = true;\n+                break;\n+\n+            default:\n+                logger.trace(loggerFmt, \"send mode\", \"=> preparing command\", \"\");\n+                SlipEncoding slipEnc = new SlipEncoding(txCmd, txData);\n+                if (!slipEnc.isValid()) {\n+                    logger.debug(loggerFmt, \"slip encoding error\", \"=> aborting\", \"\");\n                     break;\n                 }\n-                logger.trace(\"bridgeDirectCommunicate() on {}: transportEncoding={}.\", host, t.toString());\n-                sendBytes = new SlipRFC1055().encode(t.toMessage());\n+                txPacket = new SlipRFC1055().encode(slipEnc.toMessage());\n+                logger.trace(loggerFmt, \"command ready\", \"=> start sending\", \"\");\n+                looping = sending = true;\n+        }\n+\n+        while (looping) {\n+            // timeout\n+            if (System.currentTimeMillis() > expiryTime) {\n+                logger.warn(loggerFmt, \"process loop time out\", \"=> aborting\", \"=> PLEASE REPORT !!\");\n+                looping = false;\n+                break;\n             }\n-            do {\n-                if (communicationStartInMSecs + COMMUNICATION_TIMEOUT_MSECS < System.currentTimeMillis()) {\n-                    logger.warn(\"bridgeDirectCommunicate() on {}: receive takes too long. Please report to maintainer.\",\n-                            host);\n-                    break communication;\n-                }\n-                byte[] receivedPacket;\n-                try {\n-                    if (sendBytes.length > 0) {\n-                        logger.trace(\"bridgeDirectCommunicate() on {}: sending {} bytes.\", host, sendBytes.length);\n-                        if (isProtocolTraceEnabled) {\n-                            logger.info(\"Sending command {}.\", commandString);\n-                        }\n+\n+            // send command (optionally), and receive response\n+            byte[] rxPacket;\n+            try {\n+                if (sending) {\n+                    if (isProtocolTraceEnabled) {\n+                        logger.info(\"sending command {}\", txName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTcwOTM0OQ=="}, "originalCommit": {"oid": "68dad575579d134733613144caffad0a127675f4"}, "originalPosition": 212}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMjA5NDczOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/bridge/slip/SlipVeluxBridge.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNjoyODozOFrOH5K-oA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxMToxODo0OFrOH5ux1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTcxMDc1Mg==", "bodyText": "Can you work on that to remove the TODO?", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r529710752", "createdAt": "2020-11-24T16:28:38Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/bridge/slip/SlipVeluxBridge.java", "diffHunk": "@@ -181,214 +182,244 @@ public long lastSuccessfulCommunication() {\n     }\n \n     /**\n-     * Initializes a client/server communication towards <b>Velux</b> veluxBridge\n-     * based on the Basic I/O interface {@link Connection#io} and parameters\n-     * passed as arguments (see below).\n+     * Initializes a client/server communication towards the Velux Bridge based on the Basic I/O interface\n+     * {@link Connection#io} and parameters passed as arguments (see below).\n      *\n-     * @param communication Structure of interface type {@link SlipBridgeCommunicationProtocol} describing the\n+     * @param communication a structure of interface type {@link SlipBridgeCommunicationProtocol} describing the\n      *            intended communication, that is request and response interactions as well as appropriate URL\n      *            definition.\n-     * @param useAuthentication boolean flag to decide whether to use authenticated communication.\n-     * @return <b>success</b> of type boolean which signals the success of the communication.\n+     * @param useAuthentication a boolean flag to select whether to use authenticated communication.\n+     * @return a boolean which in general signals the success of the communication, but in the\n+     *         special case of receive-only calls, signals if any products were updated during the call\n      */\n     private synchronized boolean bridgeDirectCommunicate(SlipBridgeCommunicationProtocol communication,\n             boolean useAuthentication) {\n-        String host = this.bridgeInstance.veluxBridgeConfiguration().ipAddress;\n-        logger.trace(\"bridgeDirectCommunicate({},{}authenticated) on {} called.\", host, communication.name(),\n+        logger.trace(\"bridgeDirectCommunicate() '{}', {}authenticated\", communication.name(),\n                 useAuthentication ? \"\" : \"un\");\n \n-        assert this.bridgeInstance.veluxBridgeConfiguration().protocol.contentEquals(\"slip\");\n-\n-        long communicationStartInMSecs = System.currentTimeMillis();\n+        // store common parameters as constants for frequent use\n+        final short txCmd = communication.getRequestCommand().toShort();\n+        final byte[] txData = communication.getRequestDataAsArrayOfBytes();\n+        final Command txEnum = Command.get(txCmd);\n+        final String txName = txEnum.toString();\n+        final boolean isSequentialEnforced = this.bridgeInstance.veluxBridgeConfiguration().isSequentialEnforced;\n+        final boolean isProtocolTraceEnabled = this.bridgeInstance.veluxBridgeConfiguration().isProtocolTraceEnabled;\n+        final long expiryTime = System.currentTimeMillis() + COMMUNICATION_TIMEOUT_MSECS;\n \n-        boolean isSequentialEnforced = this.bridgeInstance.veluxBridgeConfiguration().isSequentialEnforced;\n-        boolean isProtocolTraceEnabled = this.bridgeInstance.veluxBridgeConfiguration().isProtocolTraceEnabled;\n+        // logger format string\n+        final String loggerFmt = String.format(\"bridgeDirectCommunicate() [%s] %s => {} {} {}\",\n+                this.bridgeInstance.veluxBridgeConfiguration().ipAddress, txName);\n \n-        // From parameters\n-        short command = communication.getRequestCommand().toShort();\n-        byte[] data = communication.getRequestDataAsArrayOfBytes();\n-        // For further use at different logging statements\n-        String commandString = Command.get(command).toString();\n+        assert this.bridgeInstance.veluxBridgeConfiguration().protocol.contentEquals(\"slip\");\n \n         if (isProtocolTraceEnabled) {\n             Threads.findDeadlocked();\n         }\n \n-        logger.debug(\"bridgeDirectCommunicate({},{}authenticated) on {} initiated by {}.\", host, commandString,\n-                useAuthentication ? \"\" : \"un\", Thread.currentThread());\n-        boolean success = false;\n+        logger.debug(loggerFmt, \"started =>\", Thread.currentThread(), \"\");\n \n-        communication: do {\n-            if (communicationStartInMSecs + COMMUNICATION_TIMEOUT_MSECS < System.currentTimeMillis()) {\n-                logger.warn(\n-                        \"{} bridgeDirectCommunicate({}) on {}: communication handshake failed (unexpected sequence of requests/responses).\",\n-                        VeluxBindingConstants.BINDING_VALUES_SEPARATOR, communication.name(), host);\n-                break;\n-            }\n+        boolean looping = false;\n+        boolean success = false;\n+        boolean sending = false;\n+        boolean rcvonly = false;\n+        byte[] txPacket = emptyPacket;\n \n-            // Special handling\n-            if (Command.get(command) == Command.GW_OPENHAB_CLOSE) {\n-                logger.trace(\"bridgeDirectCommunicate(): special command: shutting down connection.\");\n+        // handling of the requests\n+        switch (txEnum) {\n+            case GW_OPENHAB_CLOSE:\n+                logger.trace(loggerFmt, \"shut down command\", \"=> executing\", \"\");\n                 connection.resetConnection();\n                 success = true;\n-                continue;\n-            }\n+                break;\n \n-            // Normal processing\n-            logger.trace(\"bridgeDirectCommunicate() on {}: working on request {} with {} bytes of data.\", host,\n-                    commandString, data.length);\n-            byte[] sendBytes = emptyPacket;\n-            if (Command.get(command) == Command.GW_OPENHAB_RECEIVEONLY) {\n-                logger.trace(\n-                        \"bridgeDirectCommunicate() on {}: special command: determine whether there is any message waiting.\",\n-                        host);\n-                logger.trace(\"bridgeDirectCommunicate(): check for a waiting message.\");\n-                if (!connection.isMessageAvailable()) {\n-                    logger.trace(\"bridgeDirectCommunicate() on {}: no message waiting, aborting.\", host);\n-                    break communication;\n+            case GW_OPENHAB_RECEIVEONLY:\n+                logger.trace(loggerFmt, \"receive-only mode\", \"=> checking messages\", \"\");\n+                if (!connection.isAlive()) {\n+                    logger.trace(loggerFmt, \"no connection\", \"=> opening\", \"\");\n+                    looping = true;\n+                } else if (connection.isMessageAvailable()) {\n+                    logger.trace(loggerFmt, \"message(s) waiting\", \"=> start reading\", \"\");\n+                    looping = true;\n+                } else {\n+                    logger.trace(loggerFmt, \"no waiting messages\", \"=> done\", \"\");\n                 }\n-                logger.trace(\"bridgeDirectCommunicate() on {}: there is a message waiting.\", host);\n-            } else {\n-                SlipEncoding t = new SlipEncoding(command, data);\n-                if (!t.isValid()) {\n-                    logger.warn(\"bridgeDirectCommunicate() on {}: SlipEncoding() failed, aborting.\", host);\n+                rcvonly = true;\n+                break;\n+\n+            default:\n+                logger.trace(loggerFmt, \"send mode\", \"=> preparing command\", \"\");\n+                SlipEncoding slipEnc = new SlipEncoding(txCmd, txData);\n+                if (!slipEnc.isValid()) {\n+                    logger.debug(loggerFmt, \"slip encoding error\", \"=> aborting\", \"\");\n                     break;\n                 }\n-                logger.trace(\"bridgeDirectCommunicate() on {}: transportEncoding={}.\", host, t.toString());\n-                sendBytes = new SlipRFC1055().encode(t.toMessage());\n+                txPacket = new SlipRFC1055().encode(slipEnc.toMessage());\n+                logger.trace(loggerFmt, \"command ready\", \"=> start sending\", \"\");\n+                looping = sending = true;\n+        }\n+\n+        while (looping) {\n+            // timeout\n+            if (System.currentTimeMillis() > expiryTime) {\n+                logger.warn(loggerFmt, \"process loop time out\", \"=> aborting\", \"=> PLEASE REPORT !!\");\n+                looping = false;\n+                break;\n             }\n-            do {\n-                if (communicationStartInMSecs + COMMUNICATION_TIMEOUT_MSECS < System.currentTimeMillis()) {\n-                    logger.warn(\"bridgeDirectCommunicate() on {}: receive takes too long. Please report to maintainer.\",\n-                            host);\n-                    break communication;\n-                }\n-                byte[] receivedPacket;\n-                try {\n-                    if (sendBytes.length > 0) {\n-                        logger.trace(\"bridgeDirectCommunicate() on {}: sending {} bytes.\", host, sendBytes.length);\n-                        if (isProtocolTraceEnabled) {\n-                            logger.info(\"Sending command {}.\", commandString);\n-                        }\n+\n+            // send command (optionally), and receive response\n+            byte[] rxPacket;\n+            try {\n+                if (sending) {\n+                    if (isProtocolTraceEnabled) {\n+                        logger.info(\"sending command {}\", txName);\n+                    }\n+                    if (logger.isTraceEnabled()) {\n+                        logger.trace(loggerFmt, txName, \"=> sending data =>\", new Packet(txData));\n                     } else {\n-                        logger.trace(\"bridgeDirectCommunicate() on {}: initiating receive-only.\", host);\n+                        logger.debug(loggerFmt, txName, \"=> sending data length =>\", txData.length);\n                     }\n-                    // (Optionally) Send and receive packet.\n-                    receivedPacket = connection.io(this.bridgeInstance, sendBytes);\n-                    // Once being sent, it should never be sent again\n-                    sendBytes = emptyPacket;\n-                } catch (Exception e) {\n-                    logger.warn(\"bridgeDirectCommunicate() on {}: connection.io returns {}\", host, e.getMessage());\n-                    break communication;\n-                }\n-                logger.trace(\"bridgeDirectCommunicate() on {}: received packet {}.\", host,\n-                        new Packet(receivedPacket).toString());\n-                byte[] response;\n-                try {\n-                    response = new SlipRFC1055().decode(receivedPacket);\n-                } catch (ParseException e) {\n-                    logger.warn(\"bridgeDirectCommunicate() on {}: method SlipRFC1055() raised a decoding error: {}.\",\n-                            host, e.getMessage());\n-                    break communication;\n                 }\n-                SlipEncoding tr = new SlipEncoding(response);\n-                if (!tr.isValid()) {\n-                    logger.warn(\"bridgeDirectCommunicate() on {}: method SlipEncoding() raised a decoding error.\",\n-                            host);\n-                    break communication;\n-                }\n-                short responseCommand = tr.getCommand();\n-                byte[] responseData = tr.getData();\n-                logger.debug(\"bridgeDirectCommunicate() on {}: working on response {} with {} bytes of data.\", host,\n-                        Command.get(responseCommand).toString(), responseData.length);\n-                if (isProtocolTraceEnabled) {\n-                    logger.info(\"Received answer {}.\", Command.get(responseCommand).toString());\n+                rxPacket = connection.io(this.bridgeInstance, sending ? txPacket : emptyPacket);\n+                // message sent, don't send it again\n+                sending = false;\n+                if (rxPacket.length == 0) {\n+                    // only log in send mode (in receive-only mode, no response is ok)\n+                    if (!rcvonly) {\n+                        logger.debug(loggerFmt, \"no response\", \"=> aborting\", \"\");\n+                    }\n+                    looping = false;\n+                    break;\n                 }\n-                // Handle some common (unexpected) answers\n-                switch (Command.get(responseCommand)) {\n-                    case GW_NODE_INFORMATION_CHANGED_NTF:\n-                        logger.trace(\"bridgeDirectCommunicate() on {}: received GW_NODE_INFORMATION_CHANGED_NTF.\",\n-                                host);\n-                        logger.trace(\"bridgeDirectCommunicate() on {}: continue with receiving.\", host);\n-                        continue;\n-                    case GW_NODE_STATE_POSITION_CHANGED_NTF:\n-                        logger.trace(\n-                                \"bridgeDirectCommunicate() on {}: received GW_NODE_STATE_POSITION_CHANGED_NTF, special processing of this packet.\",\n-                                host);\n-                        SCgetHouseStatus receiver = new SCgetHouseStatus();\n-                        receiver.setResponse(responseCommand, responseData, isSequentialEnforced);\n-                        if (receiver.isCommunicationSuccessful()) {\n-                            logger.trace(\"bridgeDirectCommunicate() on {}: existingProducts().update() called.\", host);\n-                            bridgeInstance.existingProducts().update(new ProductBridgeIndex(receiver.getNtfNodeID()),\n-                                    receiver.getNtfState(), receiver.getNtfCurrentPosition(), receiver.getNtfTarget());\n-                        }\n-                        logger.trace(\"bridgeDirectCommunicate() on {}: continue with receiving.\", host);\n-                        continue;\n-                    case GW_ERROR_NTF:\n-                        switch (responseData[0]) {\n-                            case 0:\n-                                logger.warn(\n-                                        \"bridgeDirectCommunicate() on {}: received GW_ERROR_NTF on {} (Not further defined error), aborting.\",\n-                                        host, commandString);\n-                                break communication;\n-                            case 1:\n-                                logger.warn(\n-                                        \"bridgeDirectCommunicate() on {}: received GW_ERROR_NTF (Unknown Command or command is not accepted at this state) on {}, aborting.\",\n-                                        host, commandString);\n-                                break communication;\n-                            case 2:\n-                                logger.warn(\n-                                        \"bridgeDirectCommunicate() on {}: received GW_ERROR_NTF (ERROR on Frame Structure) on {}, aborting.\",\n-                                        host, commandString);\n-                                break communication;\n-                            case 7:\n-                                logger.trace(\n-                                        \"bridgeDirectCommunicate() on {}: received GW_ERROR_NTF (Busy. Try again later) on {}, retrying.\",\n-                                        host, commandString);\n-                                sendBytes = emptyPacket;\n-                                continue;\n-                            case 8:\n-                                logger.warn(\n-                                        \"bridgeDirectCommunicate() on {}: received GW_ERROR_NTF (Bad system table index) on {}, aborting.\",\n-                                        host, commandString);\n-                                break communication;\n-                            case 12:\n-                                logger.warn(\n-                                        \"bridgeDirectCommunicate() on {}: received GW_ERROR_NTF (Not authenticated) on {}, aborting.\",\n-                                        host, commandString);\n-                                resetAuthentication();\n-                                break communication;\n-                            default:\n-                                logger.warn(\n-                                        \"bridgeDirectCommunicate() on {}: received GW_ERROR_NTF ({}) on {}, aborting.\",\n-                                        host, responseData[0], commandString);\n-                                break communication;\n-                        }\n-                    case GW_ACTIVATION_LOG_UPDATED_NTF:\n-                        logger.info(\"bridgeDirectCommunicate() on {}: received GW_ACTIVATION_LOG_UPDATED_NTF.\", host);\n-                        logger.trace(\"bridgeDirectCommunicate() on {}: continue with receiving.\", host);\n-                        continue;\n-\n-                    case GW_COMMAND_RUN_STATUS_NTF:\n-                    case GW_COMMAND_REMAINING_TIME_NTF:\n-                    case GW_SESSION_FINISHED_NTF:\n-                        if (!isSequentialEnforced) {\n-                            logger.trace(\n-                                    \"bridgeDirectCommunicate() on {}: response ignored due to activated parallelism, continue with receiving.\",\n-                                    host);\n-                            continue;\n+            } catch (IOException e) {\n+                logger.debug(loggerFmt, \"i/o error =>\", e.getMessage(), \"=> aborting\");\n+                looping = false;\n+                break;\n+            }\n+\n+            // RFC1055 decode response\n+            byte[] rfc1055;\n+            try {\n+                rfc1055 = new SlipRFC1055().decode(rxPacket);\n+            } catch (ParseException e) {\n+                logger.debug(loggerFmt, \"parsing error =>\", e.getMessage(), \"=> aborting\");\n+                looping = false;\n+                break;\n+            }\n+\n+            // SLIP decode response\n+            SlipEncoding slipEnc = new SlipEncoding(rfc1055);\n+            if (!slipEnc.isValid()) {\n+                logger.debug(loggerFmt, \"slip decode error\", \"=> aborting\", \"\");\n+                looping = false;\n+                break;\n+            }\n+\n+            // attributes of the received (rx) response\n+            final short rxCmd = slipEnc.getCommand();\n+            final byte[] rxData = slipEnc.getData();\n+            final Command rxEnum = Command.get(rxCmd);\n+            final String rxName = rxEnum.toString();\n+\n+            // logging\n+            if (logger.isTraceEnabled()) {\n+                logger.trace(loggerFmt, rxName, \"=> received data =>\", new Packet(rxData));\n+            } else {\n+                logger.debug(loggerFmt, rxName, \"=> received data length =>\", rxData.length);\n+            }\n+            if (isProtocolTraceEnabled) {\n+                logger.info(\"received message {} => {}\", rxName, new Packet(rxData));\n+            }\n+\n+            // handling of the responses\n+            switch (rxEnum) {\n+                case GW_ERROR_NTF:\n+                    byte code = rxData[0];\n+                    switch (code) {\n+                        case 7: // busy\n+                            logger.trace(loggerFmt, rxName, getErrorText(code), \"=> retrying\");\n+                            sending = true; // TODO: I am not sure if we should retry sending", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68dad575579d134733613144caffad0a127675f4"}, "originalPosition": 381}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDI5NzMwMw==", "bodyText": "Ok.", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r530297303", "createdAt": "2020-11-25T11:18:48Z", "author": {"login": "andrewfg"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/bridge/slip/SlipVeluxBridge.java", "diffHunk": "@@ -181,214 +182,244 @@ public long lastSuccessfulCommunication() {\n     }\n \n     /**\n-     * Initializes a client/server communication towards <b>Velux</b> veluxBridge\n-     * based on the Basic I/O interface {@link Connection#io} and parameters\n-     * passed as arguments (see below).\n+     * Initializes a client/server communication towards the Velux Bridge based on the Basic I/O interface\n+     * {@link Connection#io} and parameters passed as arguments (see below).\n      *\n-     * @param communication Structure of interface type {@link SlipBridgeCommunicationProtocol} describing the\n+     * @param communication a structure of interface type {@link SlipBridgeCommunicationProtocol} describing the\n      *            intended communication, that is request and response interactions as well as appropriate URL\n      *            definition.\n-     * @param useAuthentication boolean flag to decide whether to use authenticated communication.\n-     * @return <b>success</b> of type boolean which signals the success of the communication.\n+     * @param useAuthentication a boolean flag to select whether to use authenticated communication.\n+     * @return a boolean which in general signals the success of the communication, but in the\n+     *         special case of receive-only calls, signals if any products were updated during the call\n      */\n     private synchronized boolean bridgeDirectCommunicate(SlipBridgeCommunicationProtocol communication,\n             boolean useAuthentication) {\n-        String host = this.bridgeInstance.veluxBridgeConfiguration().ipAddress;\n-        logger.trace(\"bridgeDirectCommunicate({},{}authenticated) on {} called.\", host, communication.name(),\n+        logger.trace(\"bridgeDirectCommunicate() '{}', {}authenticated\", communication.name(),\n                 useAuthentication ? \"\" : \"un\");\n \n-        assert this.bridgeInstance.veluxBridgeConfiguration().protocol.contentEquals(\"slip\");\n-\n-        long communicationStartInMSecs = System.currentTimeMillis();\n+        // store common parameters as constants for frequent use\n+        final short txCmd = communication.getRequestCommand().toShort();\n+        final byte[] txData = communication.getRequestDataAsArrayOfBytes();\n+        final Command txEnum = Command.get(txCmd);\n+        final String txName = txEnum.toString();\n+        final boolean isSequentialEnforced = this.bridgeInstance.veluxBridgeConfiguration().isSequentialEnforced;\n+        final boolean isProtocolTraceEnabled = this.bridgeInstance.veluxBridgeConfiguration().isProtocolTraceEnabled;\n+        final long expiryTime = System.currentTimeMillis() + COMMUNICATION_TIMEOUT_MSECS;\n \n-        boolean isSequentialEnforced = this.bridgeInstance.veluxBridgeConfiguration().isSequentialEnforced;\n-        boolean isProtocolTraceEnabled = this.bridgeInstance.veluxBridgeConfiguration().isProtocolTraceEnabled;\n+        // logger format string\n+        final String loggerFmt = String.format(\"bridgeDirectCommunicate() [%s] %s => {} {} {}\",\n+                this.bridgeInstance.veluxBridgeConfiguration().ipAddress, txName);\n \n-        // From parameters\n-        short command = communication.getRequestCommand().toShort();\n-        byte[] data = communication.getRequestDataAsArrayOfBytes();\n-        // For further use at different logging statements\n-        String commandString = Command.get(command).toString();\n+        assert this.bridgeInstance.veluxBridgeConfiguration().protocol.contentEquals(\"slip\");\n \n         if (isProtocolTraceEnabled) {\n             Threads.findDeadlocked();\n         }\n \n-        logger.debug(\"bridgeDirectCommunicate({},{}authenticated) on {} initiated by {}.\", host, commandString,\n-                useAuthentication ? \"\" : \"un\", Thread.currentThread());\n-        boolean success = false;\n+        logger.debug(loggerFmt, \"started =>\", Thread.currentThread(), \"\");\n \n-        communication: do {\n-            if (communicationStartInMSecs + COMMUNICATION_TIMEOUT_MSECS < System.currentTimeMillis()) {\n-                logger.warn(\n-                        \"{} bridgeDirectCommunicate({}) on {}: communication handshake failed (unexpected sequence of requests/responses).\",\n-                        VeluxBindingConstants.BINDING_VALUES_SEPARATOR, communication.name(), host);\n-                break;\n-            }\n+        boolean looping = false;\n+        boolean success = false;\n+        boolean sending = false;\n+        boolean rcvonly = false;\n+        byte[] txPacket = emptyPacket;\n \n-            // Special handling\n-            if (Command.get(command) == Command.GW_OPENHAB_CLOSE) {\n-                logger.trace(\"bridgeDirectCommunicate(): special command: shutting down connection.\");\n+        // handling of the requests\n+        switch (txEnum) {\n+            case GW_OPENHAB_CLOSE:\n+                logger.trace(loggerFmt, \"shut down command\", \"=> executing\", \"\");\n                 connection.resetConnection();\n                 success = true;\n-                continue;\n-            }\n+                break;\n \n-            // Normal processing\n-            logger.trace(\"bridgeDirectCommunicate() on {}: working on request {} with {} bytes of data.\", host,\n-                    commandString, data.length);\n-            byte[] sendBytes = emptyPacket;\n-            if (Command.get(command) == Command.GW_OPENHAB_RECEIVEONLY) {\n-                logger.trace(\n-                        \"bridgeDirectCommunicate() on {}: special command: determine whether there is any message waiting.\",\n-                        host);\n-                logger.trace(\"bridgeDirectCommunicate(): check for a waiting message.\");\n-                if (!connection.isMessageAvailable()) {\n-                    logger.trace(\"bridgeDirectCommunicate() on {}: no message waiting, aborting.\", host);\n-                    break communication;\n+            case GW_OPENHAB_RECEIVEONLY:\n+                logger.trace(loggerFmt, \"receive-only mode\", \"=> checking messages\", \"\");\n+                if (!connection.isAlive()) {\n+                    logger.trace(loggerFmt, \"no connection\", \"=> opening\", \"\");\n+                    looping = true;\n+                } else if (connection.isMessageAvailable()) {\n+                    logger.trace(loggerFmt, \"message(s) waiting\", \"=> start reading\", \"\");\n+                    looping = true;\n+                } else {\n+                    logger.trace(loggerFmt, \"no waiting messages\", \"=> done\", \"\");\n                 }\n-                logger.trace(\"bridgeDirectCommunicate() on {}: there is a message waiting.\", host);\n-            } else {\n-                SlipEncoding t = new SlipEncoding(command, data);\n-                if (!t.isValid()) {\n-                    logger.warn(\"bridgeDirectCommunicate() on {}: SlipEncoding() failed, aborting.\", host);\n+                rcvonly = true;\n+                break;\n+\n+            default:\n+                logger.trace(loggerFmt, \"send mode\", \"=> preparing command\", \"\");\n+                SlipEncoding slipEnc = new SlipEncoding(txCmd, txData);\n+                if (!slipEnc.isValid()) {\n+                    logger.debug(loggerFmt, \"slip encoding error\", \"=> aborting\", \"\");\n                     break;\n                 }\n-                logger.trace(\"bridgeDirectCommunicate() on {}: transportEncoding={}.\", host, t.toString());\n-                sendBytes = new SlipRFC1055().encode(t.toMessage());\n+                txPacket = new SlipRFC1055().encode(slipEnc.toMessage());\n+                logger.trace(loggerFmt, \"command ready\", \"=> start sending\", \"\");\n+                looping = sending = true;\n+        }\n+\n+        while (looping) {\n+            // timeout\n+            if (System.currentTimeMillis() > expiryTime) {\n+                logger.warn(loggerFmt, \"process loop time out\", \"=> aborting\", \"=> PLEASE REPORT !!\");\n+                looping = false;\n+                break;\n             }\n-            do {\n-                if (communicationStartInMSecs + COMMUNICATION_TIMEOUT_MSECS < System.currentTimeMillis()) {\n-                    logger.warn(\"bridgeDirectCommunicate() on {}: receive takes too long. Please report to maintainer.\",\n-                            host);\n-                    break communication;\n-                }\n-                byte[] receivedPacket;\n-                try {\n-                    if (sendBytes.length > 0) {\n-                        logger.trace(\"bridgeDirectCommunicate() on {}: sending {} bytes.\", host, sendBytes.length);\n-                        if (isProtocolTraceEnabled) {\n-                            logger.info(\"Sending command {}.\", commandString);\n-                        }\n+\n+            // send command (optionally), and receive response\n+            byte[] rxPacket;\n+            try {\n+                if (sending) {\n+                    if (isProtocolTraceEnabled) {\n+                        logger.info(\"sending command {}\", txName);\n+                    }\n+                    if (logger.isTraceEnabled()) {\n+                        logger.trace(loggerFmt, txName, \"=> sending data =>\", new Packet(txData));\n                     } else {\n-                        logger.trace(\"bridgeDirectCommunicate() on {}: initiating receive-only.\", host);\n+                        logger.debug(loggerFmt, txName, \"=> sending data length =>\", txData.length);\n                     }\n-                    // (Optionally) Send and receive packet.\n-                    receivedPacket = connection.io(this.bridgeInstance, sendBytes);\n-                    // Once being sent, it should never be sent again\n-                    sendBytes = emptyPacket;\n-                } catch (Exception e) {\n-                    logger.warn(\"bridgeDirectCommunicate() on {}: connection.io returns {}\", host, e.getMessage());\n-                    break communication;\n-                }\n-                logger.trace(\"bridgeDirectCommunicate() on {}: received packet {}.\", host,\n-                        new Packet(receivedPacket).toString());\n-                byte[] response;\n-                try {\n-                    response = new SlipRFC1055().decode(receivedPacket);\n-                } catch (ParseException e) {\n-                    logger.warn(\"bridgeDirectCommunicate() on {}: method SlipRFC1055() raised a decoding error: {}.\",\n-                            host, e.getMessage());\n-                    break communication;\n                 }\n-                SlipEncoding tr = new SlipEncoding(response);\n-                if (!tr.isValid()) {\n-                    logger.warn(\"bridgeDirectCommunicate() on {}: method SlipEncoding() raised a decoding error.\",\n-                            host);\n-                    break communication;\n-                }\n-                short responseCommand = tr.getCommand();\n-                byte[] responseData = tr.getData();\n-                logger.debug(\"bridgeDirectCommunicate() on {}: working on response {} with {} bytes of data.\", host,\n-                        Command.get(responseCommand).toString(), responseData.length);\n-                if (isProtocolTraceEnabled) {\n-                    logger.info(\"Received answer {}.\", Command.get(responseCommand).toString());\n+                rxPacket = connection.io(this.bridgeInstance, sending ? txPacket : emptyPacket);\n+                // message sent, don't send it again\n+                sending = false;\n+                if (rxPacket.length == 0) {\n+                    // only log in send mode (in receive-only mode, no response is ok)\n+                    if (!rcvonly) {\n+                        logger.debug(loggerFmt, \"no response\", \"=> aborting\", \"\");\n+                    }\n+                    looping = false;\n+                    break;\n                 }\n-                // Handle some common (unexpected) answers\n-                switch (Command.get(responseCommand)) {\n-                    case GW_NODE_INFORMATION_CHANGED_NTF:\n-                        logger.trace(\"bridgeDirectCommunicate() on {}: received GW_NODE_INFORMATION_CHANGED_NTF.\",\n-                                host);\n-                        logger.trace(\"bridgeDirectCommunicate() on {}: continue with receiving.\", host);\n-                        continue;\n-                    case GW_NODE_STATE_POSITION_CHANGED_NTF:\n-                        logger.trace(\n-                                \"bridgeDirectCommunicate() on {}: received GW_NODE_STATE_POSITION_CHANGED_NTF, special processing of this packet.\",\n-                                host);\n-                        SCgetHouseStatus receiver = new SCgetHouseStatus();\n-                        receiver.setResponse(responseCommand, responseData, isSequentialEnforced);\n-                        if (receiver.isCommunicationSuccessful()) {\n-                            logger.trace(\"bridgeDirectCommunicate() on {}: existingProducts().update() called.\", host);\n-                            bridgeInstance.existingProducts().update(new ProductBridgeIndex(receiver.getNtfNodeID()),\n-                                    receiver.getNtfState(), receiver.getNtfCurrentPosition(), receiver.getNtfTarget());\n-                        }\n-                        logger.trace(\"bridgeDirectCommunicate() on {}: continue with receiving.\", host);\n-                        continue;\n-                    case GW_ERROR_NTF:\n-                        switch (responseData[0]) {\n-                            case 0:\n-                                logger.warn(\n-                                        \"bridgeDirectCommunicate() on {}: received GW_ERROR_NTF on {} (Not further defined error), aborting.\",\n-                                        host, commandString);\n-                                break communication;\n-                            case 1:\n-                                logger.warn(\n-                                        \"bridgeDirectCommunicate() on {}: received GW_ERROR_NTF (Unknown Command or command is not accepted at this state) on {}, aborting.\",\n-                                        host, commandString);\n-                                break communication;\n-                            case 2:\n-                                logger.warn(\n-                                        \"bridgeDirectCommunicate() on {}: received GW_ERROR_NTF (ERROR on Frame Structure) on {}, aborting.\",\n-                                        host, commandString);\n-                                break communication;\n-                            case 7:\n-                                logger.trace(\n-                                        \"bridgeDirectCommunicate() on {}: received GW_ERROR_NTF (Busy. Try again later) on {}, retrying.\",\n-                                        host, commandString);\n-                                sendBytes = emptyPacket;\n-                                continue;\n-                            case 8:\n-                                logger.warn(\n-                                        \"bridgeDirectCommunicate() on {}: received GW_ERROR_NTF (Bad system table index) on {}, aborting.\",\n-                                        host, commandString);\n-                                break communication;\n-                            case 12:\n-                                logger.warn(\n-                                        \"bridgeDirectCommunicate() on {}: received GW_ERROR_NTF (Not authenticated) on {}, aborting.\",\n-                                        host, commandString);\n-                                resetAuthentication();\n-                                break communication;\n-                            default:\n-                                logger.warn(\n-                                        \"bridgeDirectCommunicate() on {}: received GW_ERROR_NTF ({}) on {}, aborting.\",\n-                                        host, responseData[0], commandString);\n-                                break communication;\n-                        }\n-                    case GW_ACTIVATION_LOG_UPDATED_NTF:\n-                        logger.info(\"bridgeDirectCommunicate() on {}: received GW_ACTIVATION_LOG_UPDATED_NTF.\", host);\n-                        logger.trace(\"bridgeDirectCommunicate() on {}: continue with receiving.\", host);\n-                        continue;\n-\n-                    case GW_COMMAND_RUN_STATUS_NTF:\n-                    case GW_COMMAND_REMAINING_TIME_NTF:\n-                    case GW_SESSION_FINISHED_NTF:\n-                        if (!isSequentialEnforced) {\n-                            logger.trace(\n-                                    \"bridgeDirectCommunicate() on {}: response ignored due to activated parallelism, continue with receiving.\",\n-                                    host);\n-                            continue;\n+            } catch (IOException e) {\n+                logger.debug(loggerFmt, \"i/o error =>\", e.getMessage(), \"=> aborting\");\n+                looping = false;\n+                break;\n+            }\n+\n+            // RFC1055 decode response\n+            byte[] rfc1055;\n+            try {\n+                rfc1055 = new SlipRFC1055().decode(rxPacket);\n+            } catch (ParseException e) {\n+                logger.debug(loggerFmt, \"parsing error =>\", e.getMessage(), \"=> aborting\");\n+                looping = false;\n+                break;\n+            }\n+\n+            // SLIP decode response\n+            SlipEncoding slipEnc = new SlipEncoding(rfc1055);\n+            if (!slipEnc.isValid()) {\n+                logger.debug(loggerFmt, \"slip decode error\", \"=> aborting\", \"\");\n+                looping = false;\n+                break;\n+            }\n+\n+            // attributes of the received (rx) response\n+            final short rxCmd = slipEnc.getCommand();\n+            final byte[] rxData = slipEnc.getData();\n+            final Command rxEnum = Command.get(rxCmd);\n+            final String rxName = rxEnum.toString();\n+\n+            // logging\n+            if (logger.isTraceEnabled()) {\n+                logger.trace(loggerFmt, rxName, \"=> received data =>\", new Packet(rxData));\n+            } else {\n+                logger.debug(loggerFmt, rxName, \"=> received data length =>\", rxData.length);\n+            }\n+            if (isProtocolTraceEnabled) {\n+                logger.info(\"received message {} => {}\", rxName, new Packet(rxData));\n+            }\n+\n+            // handling of the responses\n+            switch (rxEnum) {\n+                case GW_ERROR_NTF:\n+                    byte code = rxData[0];\n+                    switch (code) {\n+                        case 7: // busy\n+                            logger.trace(loggerFmt, rxName, getErrorText(code), \"=> retrying\");\n+                            sending = true; // TODO: I am not sure if we should retry sending", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTcxMDc1Mg=="}, "originalCommit": {"oid": "68dad575579d134733613144caffad0a127675f4"}, "originalPosition": 381}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMjEzMDM5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/bridge/slip/io/DataInputStreamWithTimeout.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNjozNjoxN1rOH5LUbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxMToyNjoxOFrOH5vDFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTcxNjMzMw==", "bodyText": "When creating a thread, it should be marked as daemon, to let the JVM exit, even if this thread is still running for some reason: Thread.setDaemon(true)\nAlso, please set a thread name according this scheme #8216.", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r529716333", "createdAt": "2020-11-24T16:36:17Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/bridge/slip/io/DataInputStreamWithTimeout.java", "diffHunk": "@@ -12,124 +12,195 @@\n  */\n package org.openhab.binding.velux.internal.bridge.slip.io;\n \n-import java.io.DataInputStream;\n+import java.io.Closeable;\n import java.io.IOException;\n import java.io.InputStream;\n-import java.util.concurrent.Callable;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.Future;\n-import java.util.concurrent.RejectedExecutionException;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.TimeoutException;\n+import java.net.SocketTimeoutException;\n+import java.util.Arrays;\n+import java.util.NoSuchElementException;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n /**\n- * This is an extension of {@link java.io.DataInputStream}, which adds timeouts to receive operation.\n- * <P>\n- * A data input stream lets an application read primitive Java data\n- * types from an underlying input stream in a machine-independent\n- * way. An application uses a data output stream to write data that\n- * can later be read by a data input stream.\n- * <p>\n- * For an in-depth discussion, see:\n- * https://stackoverflow.com/questions/804951/is-it-possible-to-read-from-a-inputstream-with-a-timeout\n+ * This is an wrapper around {@link java.io.InputStream} to support socket receive operations.\n+ *\n+ * It implements a secondary polling thread to asynchronously read bytes from the socket input stream into a buffer. And\n+ * it parses the bytes into SLIP messages, which are placed on a message queue. Callers can access the SLIP messages in\n+ * this queue independently from the polling thread.\n  *\n  * @author Guenther Schreiner - Initial contribution.\n+ * @author Andrew Fiddian-Green - Complete rewrite using asynchronous polling thread.\n  */\n @NonNullByDefault\n-class DataInputStreamWithTimeout extends DataInputStream {\n+class DataInputStreamWithTimeout implements Closeable {\n \n-    /*\n-     * ***************************\n-     * ***** Private Objects *****\n-     */\n+    private static final int QUEUE_SIZE = 512;\n+    private static final int BUFFER_SIZE = 512;\n+    private static final int SLEEP_INTERVAL_MSECS = 50;\n+\n+    // special character that marks the first and last byte of a slip message\n+    private static final byte SLIP_MARK = (byte) 0xc0;\n+\n+    private final Logger logger = LoggerFactory.getLogger(DataInputStreamWithTimeout.class);\n+\n+    private final Queue<byte[]> slipMessageQueue = new ConcurrentLinkedQueue<>();\n+\n+    private InputStream inputStream;\n+\n+    private String pollException = \"\";\n+    private @Nullable Thread pollThread = null;\n \n     /**\n-     * Executor for asynchronous read command\n+     * A runnable that loops to read bytes from {@link InputStream} and builds SLIP packets from them. The respective\n+     * SLIP packets are placed in a {@link ConcurrentLinkedQueue}.\n      */\n-    ExecutorService executor = Executors.newFixedThreadPool(2);\n+    private Runnable pollRunner = () -> {\n+        byte byt;\n+        byte[] buf = new byte[BUFFER_SIZE];\n+        int i = 0;\n+        pollException = \"\";\n+        slipMessageQueue.clear();\n+        while (!Thread.interrupted()) {\n+            try {\n+                buf[i] = byt = (byte) inputStream.read();\n+                if (byt == SLIP_MARK) {\n+                    if (i > 0) {\n+                        // the minimal slip message is 7 bytes [MM PP LL CC CC KK MM]\n+                        if ((i > 5) && (buf[0] == SLIP_MARK)) {\n+                            slipMessageQueue.offer(Arrays.copyOfRange(buf, 0, i + 1));\n+                            if (slipMessageQueue.size() > QUEUE_SIZE) {\n+                                logger.warn(\"pollRunner() => slip message queue overflow => PLEASE REPORT !!\");\n+                                slipMessageQueue.poll();\n+                            }\n+                        }\n+                        i = 0;\n+                        buf[0] = SLIP_MARK;\n+                        continue;\n+                    }\n+                }\n+                if (++i >= BUFFER_SIZE) {\n+                    i = 0;\n+                }\n+            } catch (SocketTimeoutException e) {\n+                // socket read time outs are OK => just keep on polling\n+                continue;\n+            } catch (IOException e) {\n+                // any other exception => stop polling\n+                pollException = e.getMessage();\n+                logger.debug(\"pollRunner() stopping '{}'\", pollException);\n+                break;\n+            }\n+        }\n+        pollThread = null;\n+    };\n \n     /**\n-     * Creates a DataInputStreamWithTimeout that uses the specified\n-     * underlying DataInputStream.\n+     * Check if there was an exception on the polling loop thread and if so, throw it back on the caller thread.\n      *\n-     * @param in the specified input stream\n+     * @throws IOException\n      */\n-    public DataInputStreamWithTimeout(InputStream in) {\n-        super(in);\n+    private void throwIfPollException() throws IOException {\n+        if (!pollException.isEmpty()) {\n+            logger.debug(\"passPollException() polling loop exception {}\", pollException);\n+            throw new IOException(pollException);\n+        }\n     }\n \n     /**\n-     * Reads up to <code>len</code> bytes of data from the contained\n-     * input stream into an array of bytes. An attempt is made to read\n-     * as many as <code>len</code> bytes, but a smaller number may be read,\n-     * possibly zero. The number of bytes actually read is returned as an\n-     * integer.\n+     * Creates a {@link DataInputStreamWithTimeout} as a wrapper around the specified underlying DataInputStream.\n      *\n-     * <p>\n-     * This method blocks until input data is available, end of file is\n-     * detected, or an exception is thrown <B>until</B> the given timeout.\n-     *\n-     * <p>\n-     * If <code>len</code> is zero, then no bytes are read and\n-     * <code>0</code> is returned; otherwise, there is an attempt to read at\n-     * least one byte. If no byte is available because the stream is at end of\n-     * file, the value <code>-1</code> is returned; otherwise, at least one\n-     * byte is read and stored into <code>b</code>.\n-     *\n-     * <p>\n-     * The first byte read is stored into element <code>b[off]</code>, the\n-     * next one into <code>b[off+1]</code>, and so on. The number of bytes read\n-     * is, at most, equal to <code>len</code>. Let <i>k</i> be the number of\n-     * bytes actually read; these bytes will be stored in elements\n-     * <code>b[off]</code> through <code>b[off+</code><i>k</i><code>-1]</code>,\n-     * leaving elements <code>b[off+</code><i>k</i><code>]</code> through\n-     * <code>b[off+len-1]</code> unaffected.\n+     * @param stream the specified input stream\n+     */\n+    public DataInputStreamWithTimeout(InputStream stream) {\n+        inputStream = stream;\n+    }\n+\n+    /**\n+     * Overridden method of {@link Closeable} interface. Stops the polling thread.\n      *\n-     * <p>\n-     * In every case, elements <code>b[0]</code> through\n-     * <code>b[off]</code> and elements <code>b[off+len]</code> through\n-     * <code>b[b.length-1]</code> are unaffected.\n+     * @throws IOException\n+     */\n+    @Override\n+    public void close() throws IOException {\n+        stopPolling();\n+    }\n+\n+    /**\n+     * Reads and removes the next available SLIP message from the queue. If the queue is empty, continue polling\n+     * until either a message is found, or the timeout expires.\n      *\n-     * @param b the buffer into which the data is read.\n-     * @param off the start offset in the destination array <code>b</code>\n-     * @param len the maximum number of bytes read.\n-     * @param timeoutMSecs the maximum duration of this read before throwing a TimeoutException.\n-     * @return the total number of bytes read into the buffer, or\n-     *         <code>-1</code> if there is no more data because the end\n-     *         of the stream has been reached.\n-     * @exception NullPointerException If <code>b</code> is <code>null</code>.\n-     * @exception IndexOutOfBoundsException If <code>off</code> is negative,\n-     *                <code>len</code> is negative, or <code>len</code> is greater than\n-     *                <code>b.length - off</code>\n-     * @exception IOException if the first byte cannot be read for any reason\n-     *                other than end of file, the stream has been closed and the underlying\n-     *                input stream does not support reading after close, or another I/O\n-     *                error occurs. Additionally it will occur when the timeout happens.\n-     * @see java.io.DataInputStream#read\n+     * @param timeoutMSecs the timeout period in milliseconds.\n+     * @return the next SLIP message if there is one on the queue, or any empty byte[] array if not.\n+     * @throws IOException\n      */\n-    public synchronized int read(byte b[], int off, int len, int timeoutMSecs) throws IOException {\n-        // Definition of Method which encapsulates the Read of data\n-        Callable<Integer> readTask = new Callable<Integer>() {\n-            @Override\n-            public Integer call() throws IOException {\n-                return in.read(b, off, len);\n+    public byte[] readSlipMessage(int timeoutMSecs) throws IOException {\n+        startPolling();\n+        int i = (timeoutMSecs / SLEEP_INTERVAL_MSECS) + 1;\n+        while (i-- >= 0) {\n+            try {\n+                byte[] slip = slipMessageQueue.remove();\n+                logger.trace(\"readSlipMessage() => return slip message\");\n+                return slip;\n+            } catch (NoSuchElementException e) {\n+                // queue empty, wait and continue\n             }\n-        };\n-        try {\n-            Future<Integer> future = executor.submit(readTask);\n-            return future.get(timeoutMSecs, TimeUnit.MILLISECONDS);\n-        } catch (RejectedExecutionException e) {\n-            throw new IOException(\"executor failed\", e);\n-        } catch (ExecutionException e) {\n-            throw new IOException(\"execution failed\", e);\n-        } catch (InterruptedException e) {\n-            throw new IOException(\"read interrupted\", e);\n-        } catch (TimeoutException e) {\n-            throw new IOException(\"read timeout\", e);\n+            try {\n+                Thread.sleep(SLEEP_INTERVAL_MSECS);\n+            } catch (InterruptedException e) {\n+                logger.debug(\"readSlipMessage() => thread interrupt\");\n+                throw new IOException(\"Thread Interrupted\");\n+            }\n+            throwIfPollException();\n+        }\n+        logger.debug(\"readSlipMessage() => no slip message after {}mS => time out\", timeoutMSecs);\n+        return new byte[0];\n+    }\n+\n+    /**\n+     * Get the number of incoming messages in the queue\n+     *\n+     * @return the number of incoming messages in the queue\n+     */\n+    public int available() {\n+        int size = slipMessageQueue.size();\n+        logger.trace(\"available() => slip message count {}\", size);\n+        return size;\n+    }\n+\n+    /**\n+     * Clear the queue\n+     */\n+    public void flush() {\n+        logger.trace(\"flush() called\");\n+        slipMessageQueue.clear();\n+    }\n+\n+    /**\n+     * If necessary start the polling thread\n+     */\n+    private void startPolling() {\n+        Thread pollThreadX = this.pollThread;\n+        if (pollThreadX != null) {\n+            logger.trace(\"startPolling()\");\n+            pollThreadX = pollThread = new Thread(pollRunner);\n+            pollThreadX.start();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68dad575579d134733613144caffad0a127675f4"}, "originalPosition": 272}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDMwMTcxOQ==", "bodyText": "Ok", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r530301719", "createdAt": "2020-11-25T11:26:18Z", "author": {"login": "andrewfg"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/bridge/slip/io/DataInputStreamWithTimeout.java", "diffHunk": "@@ -12,124 +12,195 @@\n  */\n package org.openhab.binding.velux.internal.bridge.slip.io;\n \n-import java.io.DataInputStream;\n+import java.io.Closeable;\n import java.io.IOException;\n import java.io.InputStream;\n-import java.util.concurrent.Callable;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.Future;\n-import java.util.concurrent.RejectedExecutionException;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.TimeoutException;\n+import java.net.SocketTimeoutException;\n+import java.util.Arrays;\n+import java.util.NoSuchElementException;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n /**\n- * This is an extension of {@link java.io.DataInputStream}, which adds timeouts to receive operation.\n- * <P>\n- * A data input stream lets an application read primitive Java data\n- * types from an underlying input stream in a machine-independent\n- * way. An application uses a data output stream to write data that\n- * can later be read by a data input stream.\n- * <p>\n- * For an in-depth discussion, see:\n- * https://stackoverflow.com/questions/804951/is-it-possible-to-read-from-a-inputstream-with-a-timeout\n+ * This is an wrapper around {@link java.io.InputStream} to support socket receive operations.\n+ *\n+ * It implements a secondary polling thread to asynchronously read bytes from the socket input stream into a buffer. And\n+ * it parses the bytes into SLIP messages, which are placed on a message queue. Callers can access the SLIP messages in\n+ * this queue independently from the polling thread.\n  *\n  * @author Guenther Schreiner - Initial contribution.\n+ * @author Andrew Fiddian-Green - Complete rewrite using asynchronous polling thread.\n  */\n @NonNullByDefault\n-class DataInputStreamWithTimeout extends DataInputStream {\n+class DataInputStreamWithTimeout implements Closeable {\n \n-    /*\n-     * ***************************\n-     * ***** Private Objects *****\n-     */\n+    private static final int QUEUE_SIZE = 512;\n+    private static final int BUFFER_SIZE = 512;\n+    private static final int SLEEP_INTERVAL_MSECS = 50;\n+\n+    // special character that marks the first and last byte of a slip message\n+    private static final byte SLIP_MARK = (byte) 0xc0;\n+\n+    private final Logger logger = LoggerFactory.getLogger(DataInputStreamWithTimeout.class);\n+\n+    private final Queue<byte[]> slipMessageQueue = new ConcurrentLinkedQueue<>();\n+\n+    private InputStream inputStream;\n+\n+    private String pollException = \"\";\n+    private @Nullable Thread pollThread = null;\n \n     /**\n-     * Executor for asynchronous read command\n+     * A runnable that loops to read bytes from {@link InputStream} and builds SLIP packets from them. The respective\n+     * SLIP packets are placed in a {@link ConcurrentLinkedQueue}.\n      */\n-    ExecutorService executor = Executors.newFixedThreadPool(2);\n+    private Runnable pollRunner = () -> {\n+        byte byt;\n+        byte[] buf = new byte[BUFFER_SIZE];\n+        int i = 0;\n+        pollException = \"\";\n+        slipMessageQueue.clear();\n+        while (!Thread.interrupted()) {\n+            try {\n+                buf[i] = byt = (byte) inputStream.read();\n+                if (byt == SLIP_MARK) {\n+                    if (i > 0) {\n+                        // the minimal slip message is 7 bytes [MM PP LL CC CC KK MM]\n+                        if ((i > 5) && (buf[0] == SLIP_MARK)) {\n+                            slipMessageQueue.offer(Arrays.copyOfRange(buf, 0, i + 1));\n+                            if (slipMessageQueue.size() > QUEUE_SIZE) {\n+                                logger.warn(\"pollRunner() => slip message queue overflow => PLEASE REPORT !!\");\n+                                slipMessageQueue.poll();\n+                            }\n+                        }\n+                        i = 0;\n+                        buf[0] = SLIP_MARK;\n+                        continue;\n+                    }\n+                }\n+                if (++i >= BUFFER_SIZE) {\n+                    i = 0;\n+                }\n+            } catch (SocketTimeoutException e) {\n+                // socket read time outs are OK => just keep on polling\n+                continue;\n+            } catch (IOException e) {\n+                // any other exception => stop polling\n+                pollException = e.getMessage();\n+                logger.debug(\"pollRunner() stopping '{}'\", pollException);\n+                break;\n+            }\n+        }\n+        pollThread = null;\n+    };\n \n     /**\n-     * Creates a DataInputStreamWithTimeout that uses the specified\n-     * underlying DataInputStream.\n+     * Check if there was an exception on the polling loop thread and if so, throw it back on the caller thread.\n      *\n-     * @param in the specified input stream\n+     * @throws IOException\n      */\n-    public DataInputStreamWithTimeout(InputStream in) {\n-        super(in);\n+    private void throwIfPollException() throws IOException {\n+        if (!pollException.isEmpty()) {\n+            logger.debug(\"passPollException() polling loop exception {}\", pollException);\n+            throw new IOException(pollException);\n+        }\n     }\n \n     /**\n-     * Reads up to <code>len</code> bytes of data from the contained\n-     * input stream into an array of bytes. An attempt is made to read\n-     * as many as <code>len</code> bytes, but a smaller number may be read,\n-     * possibly zero. The number of bytes actually read is returned as an\n-     * integer.\n+     * Creates a {@link DataInputStreamWithTimeout} as a wrapper around the specified underlying DataInputStream.\n      *\n-     * <p>\n-     * This method blocks until input data is available, end of file is\n-     * detected, or an exception is thrown <B>until</B> the given timeout.\n-     *\n-     * <p>\n-     * If <code>len</code> is zero, then no bytes are read and\n-     * <code>0</code> is returned; otherwise, there is an attempt to read at\n-     * least one byte. If no byte is available because the stream is at end of\n-     * file, the value <code>-1</code> is returned; otherwise, at least one\n-     * byte is read and stored into <code>b</code>.\n-     *\n-     * <p>\n-     * The first byte read is stored into element <code>b[off]</code>, the\n-     * next one into <code>b[off+1]</code>, and so on. The number of bytes read\n-     * is, at most, equal to <code>len</code>. Let <i>k</i> be the number of\n-     * bytes actually read; these bytes will be stored in elements\n-     * <code>b[off]</code> through <code>b[off+</code><i>k</i><code>-1]</code>,\n-     * leaving elements <code>b[off+</code><i>k</i><code>]</code> through\n-     * <code>b[off+len-1]</code> unaffected.\n+     * @param stream the specified input stream\n+     */\n+    public DataInputStreamWithTimeout(InputStream stream) {\n+        inputStream = stream;\n+    }\n+\n+    /**\n+     * Overridden method of {@link Closeable} interface. Stops the polling thread.\n      *\n-     * <p>\n-     * In every case, elements <code>b[0]</code> through\n-     * <code>b[off]</code> and elements <code>b[off+len]</code> through\n-     * <code>b[b.length-1]</code> are unaffected.\n+     * @throws IOException\n+     */\n+    @Override\n+    public void close() throws IOException {\n+        stopPolling();\n+    }\n+\n+    /**\n+     * Reads and removes the next available SLIP message from the queue. If the queue is empty, continue polling\n+     * until either a message is found, or the timeout expires.\n      *\n-     * @param b the buffer into which the data is read.\n-     * @param off the start offset in the destination array <code>b</code>\n-     * @param len the maximum number of bytes read.\n-     * @param timeoutMSecs the maximum duration of this read before throwing a TimeoutException.\n-     * @return the total number of bytes read into the buffer, or\n-     *         <code>-1</code> if there is no more data because the end\n-     *         of the stream has been reached.\n-     * @exception NullPointerException If <code>b</code> is <code>null</code>.\n-     * @exception IndexOutOfBoundsException If <code>off</code> is negative,\n-     *                <code>len</code> is negative, or <code>len</code> is greater than\n-     *                <code>b.length - off</code>\n-     * @exception IOException if the first byte cannot be read for any reason\n-     *                other than end of file, the stream has been closed and the underlying\n-     *                input stream does not support reading after close, or another I/O\n-     *                error occurs. Additionally it will occur when the timeout happens.\n-     * @see java.io.DataInputStream#read\n+     * @param timeoutMSecs the timeout period in milliseconds.\n+     * @return the next SLIP message if there is one on the queue, or any empty byte[] array if not.\n+     * @throws IOException\n      */\n-    public synchronized int read(byte b[], int off, int len, int timeoutMSecs) throws IOException {\n-        // Definition of Method which encapsulates the Read of data\n-        Callable<Integer> readTask = new Callable<Integer>() {\n-            @Override\n-            public Integer call() throws IOException {\n-                return in.read(b, off, len);\n+    public byte[] readSlipMessage(int timeoutMSecs) throws IOException {\n+        startPolling();\n+        int i = (timeoutMSecs / SLEEP_INTERVAL_MSECS) + 1;\n+        while (i-- >= 0) {\n+            try {\n+                byte[] slip = slipMessageQueue.remove();\n+                logger.trace(\"readSlipMessage() => return slip message\");\n+                return slip;\n+            } catch (NoSuchElementException e) {\n+                // queue empty, wait and continue\n             }\n-        };\n-        try {\n-            Future<Integer> future = executor.submit(readTask);\n-            return future.get(timeoutMSecs, TimeUnit.MILLISECONDS);\n-        } catch (RejectedExecutionException e) {\n-            throw new IOException(\"executor failed\", e);\n-        } catch (ExecutionException e) {\n-            throw new IOException(\"execution failed\", e);\n-        } catch (InterruptedException e) {\n-            throw new IOException(\"read interrupted\", e);\n-        } catch (TimeoutException e) {\n-            throw new IOException(\"read timeout\", e);\n+            try {\n+                Thread.sleep(SLEEP_INTERVAL_MSECS);\n+            } catch (InterruptedException e) {\n+                logger.debug(\"readSlipMessage() => thread interrupt\");\n+                throw new IOException(\"Thread Interrupted\");\n+            }\n+            throwIfPollException();\n+        }\n+        logger.debug(\"readSlipMessage() => no slip message after {}mS => time out\", timeoutMSecs);\n+        return new byte[0];\n+    }\n+\n+    /**\n+     * Get the number of incoming messages in the queue\n+     *\n+     * @return the number of incoming messages in the queue\n+     */\n+    public int available() {\n+        int size = slipMessageQueue.size();\n+        logger.trace(\"available() => slip message count {}\", size);\n+        return size;\n+    }\n+\n+    /**\n+     * Clear the queue\n+     */\n+    public void flush() {\n+        logger.trace(\"flush() called\");\n+        slipMessageQueue.clear();\n+    }\n+\n+    /**\n+     * If necessary start the polling thread\n+     */\n+    private void startPolling() {\n+        Thread pollThreadX = this.pollThread;\n+        if (pollThreadX != null) {\n+            logger.trace(\"startPolling()\");\n+            pollThreadX = pollThread = new Thread(pollRunner);\n+            pollThreadX.start();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTcxNjMzMw=="}, "originalCommit": {"oid": "68dad575579d134733613144caffad0a127675f4"}, "originalPosition": 272}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMjEzODAwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/bridge/slip/io/SSLconnection.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNjozNzo1M1rOH5LY6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxMToyODoyNFrOH5vIEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTcxNzQ4Mg==", "bodyText": "Can this be a constant?", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r529717482", "createdAt": "2020-11-24T16:37:53Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/bridge/slip/io/SSLconnection.java", "diffHunk": "@@ -62,13 +64,11 @@\n      * ***** Private Objects *****\n      */\n \n-    private static final int CONNECTION_BUFFER_SIZE = 4096;\n-\n-    private boolean ready = false;\n     private @Nullable SSLSocket socket;\n     private @Nullable DataOutputStream dOut;\n     private @Nullable DataInputStreamWithTimeout dIn;\n-    private int ioTimeoutMSecs = 60000;\n+    private int ioTimeoutMSecs = 1000;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68dad575579d134733613144caffad0a127675f4"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDMwMjk5NQ==", "bodyText": "No. :)", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r530302995", "createdAt": "2020-11-25T11:28:24Z", "author": {"login": "andrewfg"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/bridge/slip/io/SSLconnection.java", "diffHunk": "@@ -62,13 +64,11 @@\n      * ***** Private Objects *****\n      */\n \n-    private static final int CONNECTION_BUFFER_SIZE = 4096;\n-\n-    private boolean ready = false;\n     private @Nullable SSLSocket socket;\n     private @Nullable DataOutputStream dOut;\n     private @Nullable DataInputStreamWithTimeout dIn;\n-    private int ioTimeoutMSecs = 60000;\n+    private int ioTimeoutMSecs = 1000;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTcxNzQ4Mg=="}, "originalCommit": {"oid": "68dad575579d134733613144caffad0a127675f4"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMjE0MjYwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/bridge/slip/io/SSLconnection.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNjozODo1NVrOH5Lb0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxMTozMjowMFrOH5vQtQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTcxODIyNw==", "bodyText": "See above. Logging to info.", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r529718227", "createdAt": "2020-11-24T16:38:55Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/bridge/slip/io/SSLconnection.java", "diffHunk": "@@ -247,67 +241,39 @@ synchronized boolean available() throws IOException {\n      * Destructor to tear down a connection.\n      *\n      * @throws java.io.IOException in case of a communication I/O failure.\n+     *             But actually eats all exceptions to ensure sure that all shutdown code is executed\n      */\n-    synchronized void close() throws IOException {\n+    @Override\n+    public synchronized void close() throws IOException {\n         logger.debug(\"close() called.\");\n-        ready = false;\n-        logger.info(\"Shutting down Velux bridge connection.\");\n-        // Just for avoidance of Potential null pointer access\n         DataInputStreamWithTimeout dInX = dIn;\n         if (dInX != null) {\n-            dInX.close();\n-            dIn = null;\n+            try {\n+                dInX.close();\n+            } catch (IOException e) {\n+                // eat the exception so the following will always be executed\n+            }\n         }\n-        // Just for avoidance of Potential null pointer access\n         DataOutputStream dOutX = dOut;\n         if (dOutX != null) {\n-            dOutX.close();\n-            dOut = null;\n+            try {\n+                dOutX.close();\n+            } catch (IOException e) {\n+                // eat the exception so the following will always be executed\n+            }\n         }\n-        // Just for avoidance of Potential null pointer access\n         SSLSocket socketX = socket;\n         if (socketX != null) {\n-            socketX.close();\n-            socket = null;\n-        }\n-        logger.trace(\"close() finished.\");\n-    }\n-\n-    /**\n-     * Parameter modification.\n-     *\n-     * @param timeoutMSecs the maximum duration in milliseconds for read operations.\n-     */\n-    void setTimeout(int timeoutMSecs) {\n-        logger.debug(\"setTimeout() set timeout to {} milliseconds.\", timeoutMSecs);\n-        ioTimeoutMSecs = timeoutMSecs;\n-    }\n-\n-    /**\n-     * Method to flush the input buffer.\n-     *\n-     * @throws java.io.IOException in case of a communication I/O failure.\n-     */\n-    private void flushReadBufffer() throws IOException {\n-        logger.trace(\"flushReadBuffer() called.\");\n-        DataInputStreamWithTimeout dInX = dIn;\n-        if (!ready || (dInX == null)) {\n-            throw new IOException();\n-        }\n-        int byteCount = dInX.available();\n-        if (byteCount > 0) {\n-            byte[] byteArray = new byte[byteCount];\n-            dInX.readFully(byteArray);\n-            if (logger.isTraceEnabled()) {\n-                StringBuilder stringBuilder = new StringBuilder();\n-                for (byte currByte : byteArray) {\n-                    stringBuilder.append(String.format(\"%02X \", currByte));\n-                }\n-                logger.trace(\"flushReadBuffer(): discarded {} unexpected bytes in the input buffer: {}\", byteCount,\n-                        stringBuilder.toString());\n-            } else {\n-                logger.warn(\"flushReadBuffer(): discarded {} unexpected bytes in the input buffer\", byteCount);\n+            logger.info(\"Shutting down Velux bridge connection.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68dad575579d134733613144caffad0a127675f4"}, "originalPosition": 291}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDMwNTIwNQ==", "bodyText": "Ok.", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r530305205", "createdAt": "2020-11-25T11:32:00Z", "author": {"login": "andrewfg"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/bridge/slip/io/SSLconnection.java", "diffHunk": "@@ -247,67 +241,39 @@ synchronized boolean available() throws IOException {\n      * Destructor to tear down a connection.\n      *\n      * @throws java.io.IOException in case of a communication I/O failure.\n+     *             But actually eats all exceptions to ensure sure that all shutdown code is executed\n      */\n-    synchronized void close() throws IOException {\n+    @Override\n+    public synchronized void close() throws IOException {\n         logger.debug(\"close() called.\");\n-        ready = false;\n-        logger.info(\"Shutting down Velux bridge connection.\");\n-        // Just for avoidance of Potential null pointer access\n         DataInputStreamWithTimeout dInX = dIn;\n         if (dInX != null) {\n-            dInX.close();\n-            dIn = null;\n+            try {\n+                dInX.close();\n+            } catch (IOException e) {\n+                // eat the exception so the following will always be executed\n+            }\n         }\n-        // Just for avoidance of Potential null pointer access\n         DataOutputStream dOutX = dOut;\n         if (dOutX != null) {\n-            dOutX.close();\n-            dOut = null;\n+            try {\n+                dOutX.close();\n+            } catch (IOException e) {\n+                // eat the exception so the following will always be executed\n+            }\n         }\n-        // Just for avoidance of Potential null pointer access\n         SSLSocket socketX = socket;\n         if (socketX != null) {\n-            socketX.close();\n-            socket = null;\n-        }\n-        logger.trace(\"close() finished.\");\n-    }\n-\n-    /**\n-     * Parameter modification.\n-     *\n-     * @param timeoutMSecs the maximum duration in milliseconds for read operations.\n-     */\n-    void setTimeout(int timeoutMSecs) {\n-        logger.debug(\"setTimeout() set timeout to {} milliseconds.\", timeoutMSecs);\n-        ioTimeoutMSecs = timeoutMSecs;\n-    }\n-\n-    /**\n-     * Method to flush the input buffer.\n-     *\n-     * @throws java.io.IOException in case of a communication I/O failure.\n-     */\n-    private void flushReadBufffer() throws IOException {\n-        logger.trace(\"flushReadBuffer() called.\");\n-        DataInputStreamWithTimeout dInX = dIn;\n-        if (!ready || (dInX == null)) {\n-            throw new IOException();\n-        }\n-        int byteCount = dInX.available();\n-        if (byteCount > 0) {\n-            byte[] byteArray = new byte[byteCount];\n-            dInX.readFully(byteArray);\n-            if (logger.isTraceEnabled()) {\n-                StringBuilder stringBuilder = new StringBuilder();\n-                for (byte currByte : byteArray) {\n-                    stringBuilder.append(String.format(\"%02X \", currByte));\n-                }\n-                logger.trace(\"flushReadBuffer(): discarded {} unexpected bytes in the input buffer: {}\", byteCount,\n-                        stringBuilder.toString());\n-            } else {\n-                logger.warn(\"flushReadBuffer(): discarded {} unexpected bytes in the input buffer\", byteCount);\n+            logger.info(\"Shutting down Velux bridge connection.\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTcxODIyNw=="}, "originalCommit": {"oid": "68dad575579d134733613144caffad0a127675f4"}, "originalPosition": 291}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMjE1NDc5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/discovery/VeluxBridgeFinder.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNjo0MTozMFrOH5LjVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxODo1NzoxM1rOH6AVGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTcyMDE0OQ==", "bodyText": "You don't need to store these if you only want to skip a short. Same for below.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                @SuppressWarnings(\"unused\")\n          \n          \n            \n                                short nsCount = dataStream.readShort();\n          \n          \n            \n                                @SuppressWarnings(\"unused\")\n          \n          \n            \n                                short arCount = dataStream.readShort();\n          \n          \n            \n                                dataStream.readShort(); // nsCount\n          \n          \n            \n                                dataStream.readShort(); // arCount", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r529720149", "createdAt": "2020-11-24T16:41:30Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/discovery/VeluxBridgeFinder.java", "diffHunk": "@@ -0,0 +1,305 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.velux.internal.discovery;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.Closeable;\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.MulticastSocket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashSet;\n+import java.util.Random;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class that uses Multicast DNS (mDNS) to discover Velux Bridges and return their ipv4 addresses\n+ *\n+ * @author Andrew Fiddian-Green - Initial contribution\n+ */\n+@NonNullByDefault\n+public class VeluxBridgeFinder implements Closeable {\n+\n+    private final Logger logger = LoggerFactory.getLogger(VeluxBridgeFinder.class);\n+\n+    // timing constants\n+    private static final int BUFFER_SIZE = 256;\n+    private static final int SLEEP_MSECS = 100;\n+    private static final int WARMUP_MSECS = 10;\n+    private static final int TIMEOUT_MSECS = 5000;\n+    private static final int REPEAT_COUNT = 3;\n+\n+    // dns communication constants\n+    private static final int MDNS_PORT = 5353;\n+    private static final String MDNS_ADDR = \"224.0.0.251\";\n+\n+    // dns flag constants\n+    private static final short FLAGS_QR = (short) 0x8000;\n+    private static final short FLAGS_AA = 0x0400;\n+\n+    // dns message class constants\n+    private static final short CLASS_IN = 0x0001;\n+    private static final short CLASS_MASK = 0x7FFF;\n+\n+    // dns message type constants\n+    private static final short TYPE_PTR = 0x000c;\n+\n+    private static final byte NULL = 0x00;\n+\n+    // Velux bridge identifiers\n+    private static final String KLF_SERVICE_ID = \"_http._tcp.local\";\n+    private static final String KLF_HOST_PREFIX = \"VELUX_KLF_\";\n+\n+    private short randomQueryId;\n+\n+    private Set<String> ipAddresses = new HashSet<>();\n+\n+    private @Nullable Thread listenerThread = null;\n+\n+    /**\n+     * A runnable this listens for incoming UDP responses\n+     */\n+    private Runnable listenerRunnable = () -> {\n+        byte[] rcvBytes = new byte[BUFFER_SIZE];\n+\n+        // create a multicast listener socket\n+        try (MulticastSocket rcvSocket = new MulticastSocket(MDNS_PORT)) {\n+            rcvSocket.setReuseAddress(true);\n+            rcvSocket.joinGroup(InetAddress.getByName(MDNS_ADDR));\n+            rcvSocket.setSoTimeout(TIMEOUT_MSECS);\n+\n+            // loop until stopped\n+            while (!Thread.interrupted()) {\n+                // read next packet\n+                DatagramPacket rcvPacket = new DatagramPacket(rcvBytes, rcvBytes.length);\n+                try {\n+                    rcvSocket.receive(rcvPacket);\n+                    if (isKlfLanResponse(rcvPacket.getData())) {\n+                        ipAddresses.add(rcvPacket.getAddress().getHostAddress());\n+                    }\n+                } catch (IOException e) {\n+                    logger.trace(\"listenerRunnable(): mdns packet receive exception '{}'\", e.getMessage());\n+                    continue;\n+                }\n+            }\n+        } catch (IOException e) {\n+            logger.debug(\"listenerRunnable(): udp socket create exception '{}'\", e.getMessage());\n+        }\n+        listenerThread = null;\n+    };\n+\n+    /**\n+     * Build an mDNS query package to query SERVICE_ID looking for host names\n+     *\n+     * @return a byte array containing the query datagram payload, or an empty array if failed\n+     */\n+    private byte[] buildQuery() {\n+        ByteArrayOutputStream byteStream = new ByteArrayOutputStream(BUFFER_SIZE);\n+        DataOutputStream dataStream = new DataOutputStream(byteStream);\n+        try {\n+            dataStream.writeShort(randomQueryId); // id\n+            dataStream.writeShort(0); // flags\n+            dataStream.writeShort(1); // qdCount\n+            dataStream.writeShort(0); // anCount\n+            dataStream.writeShort(0); // nsCount\n+            dataStream.writeShort(0); // arCount\n+            for (String segString : KLF_SERVICE_ID.split(\"\\\\.\")) {\n+                byte[] segBytes = segString.getBytes(StandardCharsets.UTF_8);\n+                dataStream.writeByte(segBytes.length); // length\n+                dataStream.write(segBytes); // byte string\n+            }\n+            dataStream.writeByte(NULL); // end of name\n+            dataStream.writeShort(TYPE_PTR); // type\n+            dataStream.writeShort(CLASS_IN); // class\n+            return byteStream.toByteArray();\n+        } catch (IOException e) {\n+            // fall through\n+        }\n+        return new byte[0];\n+    }\n+\n+    /**\n+     * Parse an mDNS response package and check if it is from a KLF bridge\n+     *\n+     * @param responsePayload a byte array containing the response datagram payload\n+     * @return true if the response is from a KLF bridge\n+     */\n+    private boolean isKlfLanResponse(byte[] responsePayload) {\n+        DataInputStream dataStream = new DataInputStream(new ByteArrayInputStream(responsePayload));\n+        try {\n+            // check if the package id matches the query\n+            short id = dataStream.readShort();\n+            if (id == randomQueryId) {\n+                short flags = dataStream.readShort();\n+                boolean isResponse = (flags & FLAGS_QR) == FLAGS_QR;\n+                boolean isAuthoritative = (flags & FLAGS_AA) == FLAGS_AA;\n+\n+                // check if it is an authoritative response\n+                if (isResponse && isAuthoritative) {\n+                    short qdCount = dataStream.readShort();\n+                    short anCount = dataStream.readShort();\n+\n+                    @SuppressWarnings(\"unused\")\n+                    short nsCount = dataStream.readShort();\n+                    @SuppressWarnings(\"unused\")\n+                    short arCount = dataStream.readShort();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68dad575579d134733613144caffad0a127675f4"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDMwNzE1Nw==", "bodyText": "Oh yes. Many thanks.", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r530307157", "createdAt": "2020-11-25T11:35:17Z", "author": {"login": "andrewfg"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/discovery/VeluxBridgeFinder.java", "diffHunk": "@@ -0,0 +1,305 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.velux.internal.discovery;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.Closeable;\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.MulticastSocket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashSet;\n+import java.util.Random;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class that uses Multicast DNS (mDNS) to discover Velux Bridges and return their ipv4 addresses\n+ *\n+ * @author Andrew Fiddian-Green - Initial contribution\n+ */\n+@NonNullByDefault\n+public class VeluxBridgeFinder implements Closeable {\n+\n+    private final Logger logger = LoggerFactory.getLogger(VeluxBridgeFinder.class);\n+\n+    // timing constants\n+    private static final int BUFFER_SIZE = 256;\n+    private static final int SLEEP_MSECS = 100;\n+    private static final int WARMUP_MSECS = 10;\n+    private static final int TIMEOUT_MSECS = 5000;\n+    private static final int REPEAT_COUNT = 3;\n+\n+    // dns communication constants\n+    private static final int MDNS_PORT = 5353;\n+    private static final String MDNS_ADDR = \"224.0.0.251\";\n+\n+    // dns flag constants\n+    private static final short FLAGS_QR = (short) 0x8000;\n+    private static final short FLAGS_AA = 0x0400;\n+\n+    // dns message class constants\n+    private static final short CLASS_IN = 0x0001;\n+    private static final short CLASS_MASK = 0x7FFF;\n+\n+    // dns message type constants\n+    private static final short TYPE_PTR = 0x000c;\n+\n+    private static final byte NULL = 0x00;\n+\n+    // Velux bridge identifiers\n+    private static final String KLF_SERVICE_ID = \"_http._tcp.local\";\n+    private static final String KLF_HOST_PREFIX = \"VELUX_KLF_\";\n+\n+    private short randomQueryId;\n+\n+    private Set<String> ipAddresses = new HashSet<>();\n+\n+    private @Nullable Thread listenerThread = null;\n+\n+    /**\n+     * A runnable this listens for incoming UDP responses\n+     */\n+    private Runnable listenerRunnable = () -> {\n+        byte[] rcvBytes = new byte[BUFFER_SIZE];\n+\n+        // create a multicast listener socket\n+        try (MulticastSocket rcvSocket = new MulticastSocket(MDNS_PORT)) {\n+            rcvSocket.setReuseAddress(true);\n+            rcvSocket.joinGroup(InetAddress.getByName(MDNS_ADDR));\n+            rcvSocket.setSoTimeout(TIMEOUT_MSECS);\n+\n+            // loop until stopped\n+            while (!Thread.interrupted()) {\n+                // read next packet\n+                DatagramPacket rcvPacket = new DatagramPacket(rcvBytes, rcvBytes.length);\n+                try {\n+                    rcvSocket.receive(rcvPacket);\n+                    if (isKlfLanResponse(rcvPacket.getData())) {\n+                        ipAddresses.add(rcvPacket.getAddress().getHostAddress());\n+                    }\n+                } catch (IOException e) {\n+                    logger.trace(\"listenerRunnable(): mdns packet receive exception '{}'\", e.getMessage());\n+                    continue;\n+                }\n+            }\n+        } catch (IOException e) {\n+            logger.debug(\"listenerRunnable(): udp socket create exception '{}'\", e.getMessage());\n+        }\n+        listenerThread = null;\n+    };\n+\n+    /**\n+     * Build an mDNS query package to query SERVICE_ID looking for host names\n+     *\n+     * @return a byte array containing the query datagram payload, or an empty array if failed\n+     */\n+    private byte[] buildQuery() {\n+        ByteArrayOutputStream byteStream = new ByteArrayOutputStream(BUFFER_SIZE);\n+        DataOutputStream dataStream = new DataOutputStream(byteStream);\n+        try {\n+            dataStream.writeShort(randomQueryId); // id\n+            dataStream.writeShort(0); // flags\n+            dataStream.writeShort(1); // qdCount\n+            dataStream.writeShort(0); // anCount\n+            dataStream.writeShort(0); // nsCount\n+            dataStream.writeShort(0); // arCount\n+            for (String segString : KLF_SERVICE_ID.split(\"\\\\.\")) {\n+                byte[] segBytes = segString.getBytes(StandardCharsets.UTF_8);\n+                dataStream.writeByte(segBytes.length); // length\n+                dataStream.write(segBytes); // byte string\n+            }\n+            dataStream.writeByte(NULL); // end of name\n+            dataStream.writeShort(TYPE_PTR); // type\n+            dataStream.writeShort(CLASS_IN); // class\n+            return byteStream.toByteArray();\n+        } catch (IOException e) {\n+            // fall through\n+        }\n+        return new byte[0];\n+    }\n+\n+    /**\n+     * Parse an mDNS response package and check if it is from a KLF bridge\n+     *\n+     * @param responsePayload a byte array containing the response datagram payload\n+     * @return true if the response is from a KLF bridge\n+     */\n+    private boolean isKlfLanResponse(byte[] responsePayload) {\n+        DataInputStream dataStream = new DataInputStream(new ByteArrayInputStream(responsePayload));\n+        try {\n+            // check if the package id matches the query\n+            short id = dataStream.readShort();\n+            if (id == randomQueryId) {\n+                short flags = dataStream.readShort();\n+                boolean isResponse = (flags & FLAGS_QR) == FLAGS_QR;\n+                boolean isAuthoritative = (flags & FLAGS_AA) == FLAGS_AA;\n+\n+                // check if it is an authoritative response\n+                if (isResponse && isAuthoritative) {\n+                    short qdCount = dataStream.readShort();\n+                    short anCount = dataStream.readShort();\n+\n+                    @SuppressWarnings(\"unused\")\n+                    short nsCount = dataStream.readShort();\n+                    @SuppressWarnings(\"unused\")\n+                    short arCount = dataStream.readShort();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTcyMDE0OQ=="}, "originalCommit": {"oid": "68dad575579d134733613144caffad0a127675f4"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU4NDg1OA==", "bodyText": "Do you apply the suggestion?", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r530584858", "createdAt": "2020-11-25T18:57:13Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/discovery/VeluxBridgeFinder.java", "diffHunk": "@@ -0,0 +1,305 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.velux.internal.discovery;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.Closeable;\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.MulticastSocket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashSet;\n+import java.util.Random;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class that uses Multicast DNS (mDNS) to discover Velux Bridges and return their ipv4 addresses\n+ *\n+ * @author Andrew Fiddian-Green - Initial contribution\n+ */\n+@NonNullByDefault\n+public class VeluxBridgeFinder implements Closeable {\n+\n+    private final Logger logger = LoggerFactory.getLogger(VeluxBridgeFinder.class);\n+\n+    // timing constants\n+    private static final int BUFFER_SIZE = 256;\n+    private static final int SLEEP_MSECS = 100;\n+    private static final int WARMUP_MSECS = 10;\n+    private static final int TIMEOUT_MSECS = 5000;\n+    private static final int REPEAT_COUNT = 3;\n+\n+    // dns communication constants\n+    private static final int MDNS_PORT = 5353;\n+    private static final String MDNS_ADDR = \"224.0.0.251\";\n+\n+    // dns flag constants\n+    private static final short FLAGS_QR = (short) 0x8000;\n+    private static final short FLAGS_AA = 0x0400;\n+\n+    // dns message class constants\n+    private static final short CLASS_IN = 0x0001;\n+    private static final short CLASS_MASK = 0x7FFF;\n+\n+    // dns message type constants\n+    private static final short TYPE_PTR = 0x000c;\n+\n+    private static final byte NULL = 0x00;\n+\n+    // Velux bridge identifiers\n+    private static final String KLF_SERVICE_ID = \"_http._tcp.local\";\n+    private static final String KLF_HOST_PREFIX = \"VELUX_KLF_\";\n+\n+    private short randomQueryId;\n+\n+    private Set<String> ipAddresses = new HashSet<>();\n+\n+    private @Nullable Thread listenerThread = null;\n+\n+    /**\n+     * A runnable this listens for incoming UDP responses\n+     */\n+    private Runnable listenerRunnable = () -> {\n+        byte[] rcvBytes = new byte[BUFFER_SIZE];\n+\n+        // create a multicast listener socket\n+        try (MulticastSocket rcvSocket = new MulticastSocket(MDNS_PORT)) {\n+            rcvSocket.setReuseAddress(true);\n+            rcvSocket.joinGroup(InetAddress.getByName(MDNS_ADDR));\n+            rcvSocket.setSoTimeout(TIMEOUT_MSECS);\n+\n+            // loop until stopped\n+            while (!Thread.interrupted()) {\n+                // read next packet\n+                DatagramPacket rcvPacket = new DatagramPacket(rcvBytes, rcvBytes.length);\n+                try {\n+                    rcvSocket.receive(rcvPacket);\n+                    if (isKlfLanResponse(rcvPacket.getData())) {\n+                        ipAddresses.add(rcvPacket.getAddress().getHostAddress());\n+                    }\n+                } catch (IOException e) {\n+                    logger.trace(\"listenerRunnable(): mdns packet receive exception '{}'\", e.getMessage());\n+                    continue;\n+                }\n+            }\n+        } catch (IOException e) {\n+            logger.debug(\"listenerRunnable(): udp socket create exception '{}'\", e.getMessage());\n+        }\n+        listenerThread = null;\n+    };\n+\n+    /**\n+     * Build an mDNS query package to query SERVICE_ID looking for host names\n+     *\n+     * @return a byte array containing the query datagram payload, or an empty array if failed\n+     */\n+    private byte[] buildQuery() {\n+        ByteArrayOutputStream byteStream = new ByteArrayOutputStream(BUFFER_SIZE);\n+        DataOutputStream dataStream = new DataOutputStream(byteStream);\n+        try {\n+            dataStream.writeShort(randomQueryId); // id\n+            dataStream.writeShort(0); // flags\n+            dataStream.writeShort(1); // qdCount\n+            dataStream.writeShort(0); // anCount\n+            dataStream.writeShort(0); // nsCount\n+            dataStream.writeShort(0); // arCount\n+            for (String segString : KLF_SERVICE_ID.split(\"\\\\.\")) {\n+                byte[] segBytes = segString.getBytes(StandardCharsets.UTF_8);\n+                dataStream.writeByte(segBytes.length); // length\n+                dataStream.write(segBytes); // byte string\n+            }\n+            dataStream.writeByte(NULL); // end of name\n+            dataStream.writeShort(TYPE_PTR); // type\n+            dataStream.writeShort(CLASS_IN); // class\n+            return byteStream.toByteArray();\n+        } catch (IOException e) {\n+            // fall through\n+        }\n+        return new byte[0];\n+    }\n+\n+    /**\n+     * Parse an mDNS response package and check if it is from a KLF bridge\n+     *\n+     * @param responsePayload a byte array containing the response datagram payload\n+     * @return true if the response is from a KLF bridge\n+     */\n+    private boolean isKlfLanResponse(byte[] responsePayload) {\n+        DataInputStream dataStream = new DataInputStream(new ByteArrayInputStream(responsePayload));\n+        try {\n+            // check if the package id matches the query\n+            short id = dataStream.readShort();\n+            if (id == randomQueryId) {\n+                short flags = dataStream.readShort();\n+                boolean isResponse = (flags & FLAGS_QR) == FLAGS_QR;\n+                boolean isAuthoritative = (flags & FLAGS_AA) == FLAGS_AA;\n+\n+                // check if it is an authoritative response\n+                if (isResponse && isAuthoritative) {\n+                    short qdCount = dataStream.readShort();\n+                    short anCount = dataStream.readShort();\n+\n+                    @SuppressWarnings(\"unused\")\n+                    short nsCount = dataStream.readShort();\n+                    @SuppressWarnings(\"unused\")\n+                    short arCount = dataStream.readShort();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTcyMDE0OQ=="}, "originalCommit": {"oid": "68dad575579d134733613144caffad0a127675f4"}, "originalPosition": 165}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMjE2NDcwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/discovery/VeluxBridgeFinder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNjo0Mzo0NVrOH5LpZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxMTo1MjoxNFrOH5v9jg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTcyMTcwMg==", "bodyText": "Did you take a look at dataStream.readNBytes(len)? Same for below.", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r529721702", "createdAt": "2020-11-24T16:43:45Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/discovery/VeluxBridgeFinder.java", "diffHunk": "@@ -0,0 +1,305 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.velux.internal.discovery;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.Closeable;\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.MulticastSocket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashSet;\n+import java.util.Random;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class that uses Multicast DNS (mDNS) to discover Velux Bridges and return their ipv4 addresses\n+ *\n+ * @author Andrew Fiddian-Green - Initial contribution\n+ */\n+@NonNullByDefault\n+public class VeluxBridgeFinder implements Closeable {\n+\n+    private final Logger logger = LoggerFactory.getLogger(VeluxBridgeFinder.class);\n+\n+    // timing constants\n+    private static final int BUFFER_SIZE = 256;\n+    private static final int SLEEP_MSECS = 100;\n+    private static final int WARMUP_MSECS = 10;\n+    private static final int TIMEOUT_MSECS = 5000;\n+    private static final int REPEAT_COUNT = 3;\n+\n+    // dns communication constants\n+    private static final int MDNS_PORT = 5353;\n+    private static final String MDNS_ADDR = \"224.0.0.251\";\n+\n+    // dns flag constants\n+    private static final short FLAGS_QR = (short) 0x8000;\n+    private static final short FLAGS_AA = 0x0400;\n+\n+    // dns message class constants\n+    private static final short CLASS_IN = 0x0001;\n+    private static final short CLASS_MASK = 0x7FFF;\n+\n+    // dns message type constants\n+    private static final short TYPE_PTR = 0x000c;\n+\n+    private static final byte NULL = 0x00;\n+\n+    // Velux bridge identifiers\n+    private static final String KLF_SERVICE_ID = \"_http._tcp.local\";\n+    private static final String KLF_HOST_PREFIX = \"VELUX_KLF_\";\n+\n+    private short randomQueryId;\n+\n+    private Set<String> ipAddresses = new HashSet<>();\n+\n+    private @Nullable Thread listenerThread = null;\n+\n+    /**\n+     * A runnable this listens for incoming UDP responses\n+     */\n+    private Runnable listenerRunnable = () -> {\n+        byte[] rcvBytes = new byte[BUFFER_SIZE];\n+\n+        // create a multicast listener socket\n+        try (MulticastSocket rcvSocket = new MulticastSocket(MDNS_PORT)) {\n+            rcvSocket.setReuseAddress(true);\n+            rcvSocket.joinGroup(InetAddress.getByName(MDNS_ADDR));\n+            rcvSocket.setSoTimeout(TIMEOUT_MSECS);\n+\n+            // loop until stopped\n+            while (!Thread.interrupted()) {\n+                // read next packet\n+                DatagramPacket rcvPacket = new DatagramPacket(rcvBytes, rcvBytes.length);\n+                try {\n+                    rcvSocket.receive(rcvPacket);\n+                    if (isKlfLanResponse(rcvPacket.getData())) {\n+                        ipAddresses.add(rcvPacket.getAddress().getHostAddress());\n+                    }\n+                } catch (IOException e) {\n+                    logger.trace(\"listenerRunnable(): mdns packet receive exception '{}'\", e.getMessage());\n+                    continue;\n+                }\n+            }\n+        } catch (IOException e) {\n+            logger.debug(\"listenerRunnable(): udp socket create exception '{}'\", e.getMessage());\n+        }\n+        listenerThread = null;\n+    };\n+\n+    /**\n+     * Build an mDNS query package to query SERVICE_ID looking for host names\n+     *\n+     * @return a byte array containing the query datagram payload, or an empty array if failed\n+     */\n+    private byte[] buildQuery() {\n+        ByteArrayOutputStream byteStream = new ByteArrayOutputStream(BUFFER_SIZE);\n+        DataOutputStream dataStream = new DataOutputStream(byteStream);\n+        try {\n+            dataStream.writeShort(randomQueryId); // id\n+            dataStream.writeShort(0); // flags\n+            dataStream.writeShort(1); // qdCount\n+            dataStream.writeShort(0); // anCount\n+            dataStream.writeShort(0); // nsCount\n+            dataStream.writeShort(0); // arCount\n+            for (String segString : KLF_SERVICE_ID.split(\"\\\\.\")) {\n+                byte[] segBytes = segString.getBytes(StandardCharsets.UTF_8);\n+                dataStream.writeByte(segBytes.length); // length\n+                dataStream.write(segBytes); // byte string\n+            }\n+            dataStream.writeByte(NULL); // end of name\n+            dataStream.writeShort(TYPE_PTR); // type\n+            dataStream.writeShort(CLASS_IN); // class\n+            return byteStream.toByteArray();\n+        } catch (IOException e) {\n+            // fall through\n+        }\n+        return new byte[0];\n+    }\n+\n+    /**\n+     * Parse an mDNS response package and check if it is from a KLF bridge\n+     *\n+     * @param responsePayload a byte array containing the response datagram payload\n+     * @return true if the response is from a KLF bridge\n+     */\n+    private boolean isKlfLanResponse(byte[] responsePayload) {\n+        DataInputStream dataStream = new DataInputStream(new ByteArrayInputStream(responsePayload));\n+        try {\n+            // check if the package id matches the query\n+            short id = dataStream.readShort();\n+            if (id == randomQueryId) {\n+                short flags = dataStream.readShort();\n+                boolean isResponse = (flags & FLAGS_QR) == FLAGS_QR;\n+                boolean isAuthoritative = (flags & FLAGS_AA) == FLAGS_AA;\n+\n+                // check if it is an authoritative response\n+                if (isResponse && isAuthoritative) {\n+                    short qdCount = dataStream.readShort();\n+                    short anCount = dataStream.readShort();\n+\n+                    @SuppressWarnings(\"unused\")\n+                    short nsCount = dataStream.readShort();\n+                    @SuppressWarnings(\"unused\")\n+                    short arCount = dataStream.readShort();\n+\n+                    // check it is an answer (and not a query)\n+                    if ((anCount == 0) || (qdCount != 0)) {\n+                        return false;\n+                    }\n+\n+                    // parse the answers\n+                    for (short an = 0; an < anCount; an++) {\n+                        // parse the name\n+                        byte[] str = new byte[BUFFER_SIZE];\n+                        int i = 0;\n+                        int segLength;\n+                        while ((segLength = dataStream.readByte()) > 0) {\n+                            for (int index = 0; index < segLength; index++) {\n+                                str[i] = dataStream.readByte();\n+                                i++;\n+                            }\n+                            str[i] = '.';\n+                            i++;\n+                        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68dad575579d134733613144caffad0a127675f4"}, "originalPosition": 185}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDMxNjY4Ng==", "bodyText": "Hmm, that won't work. The code parses zero delimited DNS name segments and builds a fully qualified dot delimited service/host name from those parts. It does more than a simple readNBytes()..", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r530316686", "createdAt": "2020-11-25T11:52:14Z", "author": {"login": "andrewfg"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/discovery/VeluxBridgeFinder.java", "diffHunk": "@@ -0,0 +1,305 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.velux.internal.discovery;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.Closeable;\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.MulticastSocket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashSet;\n+import java.util.Random;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class that uses Multicast DNS (mDNS) to discover Velux Bridges and return their ipv4 addresses\n+ *\n+ * @author Andrew Fiddian-Green - Initial contribution\n+ */\n+@NonNullByDefault\n+public class VeluxBridgeFinder implements Closeable {\n+\n+    private final Logger logger = LoggerFactory.getLogger(VeluxBridgeFinder.class);\n+\n+    // timing constants\n+    private static final int BUFFER_SIZE = 256;\n+    private static final int SLEEP_MSECS = 100;\n+    private static final int WARMUP_MSECS = 10;\n+    private static final int TIMEOUT_MSECS = 5000;\n+    private static final int REPEAT_COUNT = 3;\n+\n+    // dns communication constants\n+    private static final int MDNS_PORT = 5353;\n+    private static final String MDNS_ADDR = \"224.0.0.251\";\n+\n+    // dns flag constants\n+    private static final short FLAGS_QR = (short) 0x8000;\n+    private static final short FLAGS_AA = 0x0400;\n+\n+    // dns message class constants\n+    private static final short CLASS_IN = 0x0001;\n+    private static final short CLASS_MASK = 0x7FFF;\n+\n+    // dns message type constants\n+    private static final short TYPE_PTR = 0x000c;\n+\n+    private static final byte NULL = 0x00;\n+\n+    // Velux bridge identifiers\n+    private static final String KLF_SERVICE_ID = \"_http._tcp.local\";\n+    private static final String KLF_HOST_PREFIX = \"VELUX_KLF_\";\n+\n+    private short randomQueryId;\n+\n+    private Set<String> ipAddresses = new HashSet<>();\n+\n+    private @Nullable Thread listenerThread = null;\n+\n+    /**\n+     * A runnable this listens for incoming UDP responses\n+     */\n+    private Runnable listenerRunnable = () -> {\n+        byte[] rcvBytes = new byte[BUFFER_SIZE];\n+\n+        // create a multicast listener socket\n+        try (MulticastSocket rcvSocket = new MulticastSocket(MDNS_PORT)) {\n+            rcvSocket.setReuseAddress(true);\n+            rcvSocket.joinGroup(InetAddress.getByName(MDNS_ADDR));\n+            rcvSocket.setSoTimeout(TIMEOUT_MSECS);\n+\n+            // loop until stopped\n+            while (!Thread.interrupted()) {\n+                // read next packet\n+                DatagramPacket rcvPacket = new DatagramPacket(rcvBytes, rcvBytes.length);\n+                try {\n+                    rcvSocket.receive(rcvPacket);\n+                    if (isKlfLanResponse(rcvPacket.getData())) {\n+                        ipAddresses.add(rcvPacket.getAddress().getHostAddress());\n+                    }\n+                } catch (IOException e) {\n+                    logger.trace(\"listenerRunnable(): mdns packet receive exception '{}'\", e.getMessage());\n+                    continue;\n+                }\n+            }\n+        } catch (IOException e) {\n+            logger.debug(\"listenerRunnable(): udp socket create exception '{}'\", e.getMessage());\n+        }\n+        listenerThread = null;\n+    };\n+\n+    /**\n+     * Build an mDNS query package to query SERVICE_ID looking for host names\n+     *\n+     * @return a byte array containing the query datagram payload, or an empty array if failed\n+     */\n+    private byte[] buildQuery() {\n+        ByteArrayOutputStream byteStream = new ByteArrayOutputStream(BUFFER_SIZE);\n+        DataOutputStream dataStream = new DataOutputStream(byteStream);\n+        try {\n+            dataStream.writeShort(randomQueryId); // id\n+            dataStream.writeShort(0); // flags\n+            dataStream.writeShort(1); // qdCount\n+            dataStream.writeShort(0); // anCount\n+            dataStream.writeShort(0); // nsCount\n+            dataStream.writeShort(0); // arCount\n+            for (String segString : KLF_SERVICE_ID.split(\"\\\\.\")) {\n+                byte[] segBytes = segString.getBytes(StandardCharsets.UTF_8);\n+                dataStream.writeByte(segBytes.length); // length\n+                dataStream.write(segBytes); // byte string\n+            }\n+            dataStream.writeByte(NULL); // end of name\n+            dataStream.writeShort(TYPE_PTR); // type\n+            dataStream.writeShort(CLASS_IN); // class\n+            return byteStream.toByteArray();\n+        } catch (IOException e) {\n+            // fall through\n+        }\n+        return new byte[0];\n+    }\n+\n+    /**\n+     * Parse an mDNS response package and check if it is from a KLF bridge\n+     *\n+     * @param responsePayload a byte array containing the response datagram payload\n+     * @return true if the response is from a KLF bridge\n+     */\n+    private boolean isKlfLanResponse(byte[] responsePayload) {\n+        DataInputStream dataStream = new DataInputStream(new ByteArrayInputStream(responsePayload));\n+        try {\n+            // check if the package id matches the query\n+            short id = dataStream.readShort();\n+            if (id == randomQueryId) {\n+                short flags = dataStream.readShort();\n+                boolean isResponse = (flags & FLAGS_QR) == FLAGS_QR;\n+                boolean isAuthoritative = (flags & FLAGS_AA) == FLAGS_AA;\n+\n+                // check if it is an authoritative response\n+                if (isResponse && isAuthoritative) {\n+                    short qdCount = dataStream.readShort();\n+                    short anCount = dataStream.readShort();\n+\n+                    @SuppressWarnings(\"unused\")\n+                    short nsCount = dataStream.readShort();\n+                    @SuppressWarnings(\"unused\")\n+                    short arCount = dataStream.readShort();\n+\n+                    // check it is an answer (and not a query)\n+                    if ((anCount == 0) || (qdCount != 0)) {\n+                        return false;\n+                    }\n+\n+                    // parse the answers\n+                    for (short an = 0; an < anCount; an++) {\n+                        // parse the name\n+                        byte[] str = new byte[BUFFER_SIZE];\n+                        int i = 0;\n+                        int segLength;\n+                        while ((segLength = dataStream.readByte()) > 0) {\n+                            for (int index = 0; index < segLength; index++) {\n+                                str[i] = dataStream.readByte();\n+                                i++;\n+                            }\n+                            str[i] = '.';\n+                            i++;\n+                        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTcyMTcwMg=="}, "originalCommit": {"oid": "68dad575579d134733613144caffad0a127675f4"}, "originalPosition": 185}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMjE5NDA4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/discovery/VeluxBridgeFinder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNjo1MDoxOVrOH5L7rg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxMjoyNDozN1rOH5xDlg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTcyNjM4Mg==", "bodyText": "As this has a finite runtime, you could use the scheduler provided by the discovery service to run the listener.", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r529726382", "createdAt": "2020-11-24T16:50:19Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/discovery/VeluxBridgeFinder.java", "diffHunk": "@@ -0,0 +1,305 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.velux.internal.discovery;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.Closeable;\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.MulticastSocket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashSet;\n+import java.util.Random;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class that uses Multicast DNS (mDNS) to discover Velux Bridges and return their ipv4 addresses\n+ *\n+ * @author Andrew Fiddian-Green - Initial contribution\n+ */\n+@NonNullByDefault\n+public class VeluxBridgeFinder implements Closeable {\n+\n+    private final Logger logger = LoggerFactory.getLogger(VeluxBridgeFinder.class);\n+\n+    // timing constants\n+    private static final int BUFFER_SIZE = 256;\n+    private static final int SLEEP_MSECS = 100;\n+    private static final int WARMUP_MSECS = 10;\n+    private static final int TIMEOUT_MSECS = 5000;\n+    private static final int REPEAT_COUNT = 3;\n+\n+    // dns communication constants\n+    private static final int MDNS_PORT = 5353;\n+    private static final String MDNS_ADDR = \"224.0.0.251\";\n+\n+    // dns flag constants\n+    private static final short FLAGS_QR = (short) 0x8000;\n+    private static final short FLAGS_AA = 0x0400;\n+\n+    // dns message class constants\n+    private static final short CLASS_IN = 0x0001;\n+    private static final short CLASS_MASK = 0x7FFF;\n+\n+    // dns message type constants\n+    private static final short TYPE_PTR = 0x000c;\n+\n+    private static final byte NULL = 0x00;\n+\n+    // Velux bridge identifiers\n+    private static final String KLF_SERVICE_ID = \"_http._tcp.local\";\n+    private static final String KLF_HOST_PREFIX = \"VELUX_KLF_\";\n+\n+    private short randomQueryId;\n+\n+    private Set<String> ipAddresses = new HashSet<>();\n+\n+    private @Nullable Thread listenerThread = null;\n+\n+    /**\n+     * A runnable this listens for incoming UDP responses\n+     */\n+    private Runnable listenerRunnable = () -> {\n+        byte[] rcvBytes = new byte[BUFFER_SIZE];\n+\n+        // create a multicast listener socket\n+        try (MulticastSocket rcvSocket = new MulticastSocket(MDNS_PORT)) {\n+            rcvSocket.setReuseAddress(true);\n+            rcvSocket.joinGroup(InetAddress.getByName(MDNS_ADDR));\n+            rcvSocket.setSoTimeout(TIMEOUT_MSECS);\n+\n+            // loop until stopped\n+            while (!Thread.interrupted()) {\n+                // read next packet\n+                DatagramPacket rcvPacket = new DatagramPacket(rcvBytes, rcvBytes.length);\n+                try {\n+                    rcvSocket.receive(rcvPacket);\n+                    if (isKlfLanResponse(rcvPacket.getData())) {\n+                        ipAddresses.add(rcvPacket.getAddress().getHostAddress());\n+                    }\n+                } catch (IOException e) {\n+                    logger.trace(\"listenerRunnable(): mdns packet receive exception '{}'\", e.getMessage());\n+                    continue;\n+                }\n+            }\n+        } catch (IOException e) {\n+            logger.debug(\"listenerRunnable(): udp socket create exception '{}'\", e.getMessage());\n+        }\n+        listenerThread = null;\n+    };\n+\n+    /**\n+     * Build an mDNS query package to query SERVICE_ID looking for host names\n+     *\n+     * @return a byte array containing the query datagram payload, or an empty array if failed\n+     */\n+    private byte[] buildQuery() {\n+        ByteArrayOutputStream byteStream = new ByteArrayOutputStream(BUFFER_SIZE);\n+        DataOutputStream dataStream = new DataOutputStream(byteStream);\n+        try {\n+            dataStream.writeShort(randomQueryId); // id\n+            dataStream.writeShort(0); // flags\n+            dataStream.writeShort(1); // qdCount\n+            dataStream.writeShort(0); // anCount\n+            dataStream.writeShort(0); // nsCount\n+            dataStream.writeShort(0); // arCount\n+            for (String segString : KLF_SERVICE_ID.split(\"\\\\.\")) {\n+                byte[] segBytes = segString.getBytes(StandardCharsets.UTF_8);\n+                dataStream.writeByte(segBytes.length); // length\n+                dataStream.write(segBytes); // byte string\n+            }\n+            dataStream.writeByte(NULL); // end of name\n+            dataStream.writeShort(TYPE_PTR); // type\n+            dataStream.writeShort(CLASS_IN); // class\n+            return byteStream.toByteArray();\n+        } catch (IOException e) {\n+            // fall through\n+        }\n+        return new byte[0];\n+    }\n+\n+    /**\n+     * Parse an mDNS response package and check if it is from a KLF bridge\n+     *\n+     * @param responsePayload a byte array containing the response datagram payload\n+     * @return true if the response is from a KLF bridge\n+     */\n+    private boolean isKlfLanResponse(byte[] responsePayload) {\n+        DataInputStream dataStream = new DataInputStream(new ByteArrayInputStream(responsePayload));\n+        try {\n+            // check if the package id matches the query\n+            short id = dataStream.readShort();\n+            if (id == randomQueryId) {\n+                short flags = dataStream.readShort();\n+                boolean isResponse = (flags & FLAGS_QR) == FLAGS_QR;\n+                boolean isAuthoritative = (flags & FLAGS_AA) == FLAGS_AA;\n+\n+                // check if it is an authoritative response\n+                if (isResponse && isAuthoritative) {\n+                    short qdCount = dataStream.readShort();\n+                    short anCount = dataStream.readShort();\n+\n+                    @SuppressWarnings(\"unused\")\n+                    short nsCount = dataStream.readShort();\n+                    @SuppressWarnings(\"unused\")\n+                    short arCount = dataStream.readShort();\n+\n+                    // check it is an answer (and not a query)\n+                    if ((anCount == 0) || (qdCount != 0)) {\n+                        return false;\n+                    }\n+\n+                    // parse the answers\n+                    for (short an = 0; an < anCount; an++) {\n+                        // parse the name\n+                        byte[] str = new byte[BUFFER_SIZE];\n+                        int i = 0;\n+                        int segLength;\n+                        while ((segLength = dataStream.readByte()) > 0) {\n+                            for (int index = 0; index < segLength; index++) {\n+                                str[i] = dataStream.readByte();\n+                                i++;\n+                            }\n+                            str[i] = '.';\n+                            i++;\n+                        }\n+                        String name = new String(str, 0, i, StandardCharsets.UTF_8);\n+                        short typ = dataStream.readShort();\n+                        short clazz = (short) (CLASS_MASK & dataStream.readShort());\n+                        if (!(name.startsWith(KLF_SERVICE_ID)) || (typ != TYPE_PTR) || (clazz != CLASS_IN)) {\n+                            return false;\n+                        }\n+\n+                        // if we got here, the name and response type are valid\n+                        @SuppressWarnings(\"unused\")\n+                        int ttl = dataStream.readInt();\n+                        @SuppressWarnings(\"unused\")\n+                        short dataLen = dataStream.readShort();\n+\n+                        // parse the host name\n+                        i = 0;\n+                        while ((segLength = dataStream.readByte()) > 0) {\n+                            for (int index = 0; index < segLength; index++) {\n+                                str[i] = dataStream.readByte();\n+                                i++;\n+                            }\n+                            str[i] = '.';\n+                            i++;\n+                        }\n+\n+                        // check if the host name matches\n+                        String host = new String(str, 0, i, StandardCharsets.UTF_8);\n+                        if (host.startsWith(KLF_HOST_PREFIX)) {\n+                            return true;\n+                        }\n+                    }\n+                }\n+            }\n+        } catch (IOException e) {\n+            // fall through\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Start the listener thread\n+     */\n+    private void startListener() {\n+        Thread listenerThreadX = this.listenerThread;\n+        if (listenerThreadX == null) {\n+            listenerThreadX = listenerThread = new Thread(listenerRunnable);\n+            listenerThreadX.start();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68dad575579d134733613144caffad0a127675f4"}, "originalPosition": 231}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDMzNDYxNA==", "bodyText": "Ok.", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r530334614", "createdAt": "2020-11-25T12:24:37Z", "author": {"login": "andrewfg"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/discovery/VeluxBridgeFinder.java", "diffHunk": "@@ -0,0 +1,305 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.velux.internal.discovery;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.Closeable;\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.MulticastSocket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashSet;\n+import java.util.Random;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class that uses Multicast DNS (mDNS) to discover Velux Bridges and return their ipv4 addresses\n+ *\n+ * @author Andrew Fiddian-Green - Initial contribution\n+ */\n+@NonNullByDefault\n+public class VeluxBridgeFinder implements Closeable {\n+\n+    private final Logger logger = LoggerFactory.getLogger(VeluxBridgeFinder.class);\n+\n+    // timing constants\n+    private static final int BUFFER_SIZE = 256;\n+    private static final int SLEEP_MSECS = 100;\n+    private static final int WARMUP_MSECS = 10;\n+    private static final int TIMEOUT_MSECS = 5000;\n+    private static final int REPEAT_COUNT = 3;\n+\n+    // dns communication constants\n+    private static final int MDNS_PORT = 5353;\n+    private static final String MDNS_ADDR = \"224.0.0.251\";\n+\n+    // dns flag constants\n+    private static final short FLAGS_QR = (short) 0x8000;\n+    private static final short FLAGS_AA = 0x0400;\n+\n+    // dns message class constants\n+    private static final short CLASS_IN = 0x0001;\n+    private static final short CLASS_MASK = 0x7FFF;\n+\n+    // dns message type constants\n+    private static final short TYPE_PTR = 0x000c;\n+\n+    private static final byte NULL = 0x00;\n+\n+    // Velux bridge identifiers\n+    private static final String KLF_SERVICE_ID = \"_http._tcp.local\";\n+    private static final String KLF_HOST_PREFIX = \"VELUX_KLF_\";\n+\n+    private short randomQueryId;\n+\n+    private Set<String> ipAddresses = new HashSet<>();\n+\n+    private @Nullable Thread listenerThread = null;\n+\n+    /**\n+     * A runnable this listens for incoming UDP responses\n+     */\n+    private Runnable listenerRunnable = () -> {\n+        byte[] rcvBytes = new byte[BUFFER_SIZE];\n+\n+        // create a multicast listener socket\n+        try (MulticastSocket rcvSocket = new MulticastSocket(MDNS_PORT)) {\n+            rcvSocket.setReuseAddress(true);\n+            rcvSocket.joinGroup(InetAddress.getByName(MDNS_ADDR));\n+            rcvSocket.setSoTimeout(TIMEOUT_MSECS);\n+\n+            // loop until stopped\n+            while (!Thread.interrupted()) {\n+                // read next packet\n+                DatagramPacket rcvPacket = new DatagramPacket(rcvBytes, rcvBytes.length);\n+                try {\n+                    rcvSocket.receive(rcvPacket);\n+                    if (isKlfLanResponse(rcvPacket.getData())) {\n+                        ipAddresses.add(rcvPacket.getAddress().getHostAddress());\n+                    }\n+                } catch (IOException e) {\n+                    logger.trace(\"listenerRunnable(): mdns packet receive exception '{}'\", e.getMessage());\n+                    continue;\n+                }\n+            }\n+        } catch (IOException e) {\n+            logger.debug(\"listenerRunnable(): udp socket create exception '{}'\", e.getMessage());\n+        }\n+        listenerThread = null;\n+    };\n+\n+    /**\n+     * Build an mDNS query package to query SERVICE_ID looking for host names\n+     *\n+     * @return a byte array containing the query datagram payload, or an empty array if failed\n+     */\n+    private byte[] buildQuery() {\n+        ByteArrayOutputStream byteStream = new ByteArrayOutputStream(BUFFER_SIZE);\n+        DataOutputStream dataStream = new DataOutputStream(byteStream);\n+        try {\n+            dataStream.writeShort(randomQueryId); // id\n+            dataStream.writeShort(0); // flags\n+            dataStream.writeShort(1); // qdCount\n+            dataStream.writeShort(0); // anCount\n+            dataStream.writeShort(0); // nsCount\n+            dataStream.writeShort(0); // arCount\n+            for (String segString : KLF_SERVICE_ID.split(\"\\\\.\")) {\n+                byte[] segBytes = segString.getBytes(StandardCharsets.UTF_8);\n+                dataStream.writeByte(segBytes.length); // length\n+                dataStream.write(segBytes); // byte string\n+            }\n+            dataStream.writeByte(NULL); // end of name\n+            dataStream.writeShort(TYPE_PTR); // type\n+            dataStream.writeShort(CLASS_IN); // class\n+            return byteStream.toByteArray();\n+        } catch (IOException e) {\n+            // fall through\n+        }\n+        return new byte[0];\n+    }\n+\n+    /**\n+     * Parse an mDNS response package and check if it is from a KLF bridge\n+     *\n+     * @param responsePayload a byte array containing the response datagram payload\n+     * @return true if the response is from a KLF bridge\n+     */\n+    private boolean isKlfLanResponse(byte[] responsePayload) {\n+        DataInputStream dataStream = new DataInputStream(new ByteArrayInputStream(responsePayload));\n+        try {\n+            // check if the package id matches the query\n+            short id = dataStream.readShort();\n+            if (id == randomQueryId) {\n+                short flags = dataStream.readShort();\n+                boolean isResponse = (flags & FLAGS_QR) == FLAGS_QR;\n+                boolean isAuthoritative = (flags & FLAGS_AA) == FLAGS_AA;\n+\n+                // check if it is an authoritative response\n+                if (isResponse && isAuthoritative) {\n+                    short qdCount = dataStream.readShort();\n+                    short anCount = dataStream.readShort();\n+\n+                    @SuppressWarnings(\"unused\")\n+                    short nsCount = dataStream.readShort();\n+                    @SuppressWarnings(\"unused\")\n+                    short arCount = dataStream.readShort();\n+\n+                    // check it is an answer (and not a query)\n+                    if ((anCount == 0) || (qdCount != 0)) {\n+                        return false;\n+                    }\n+\n+                    // parse the answers\n+                    for (short an = 0; an < anCount; an++) {\n+                        // parse the name\n+                        byte[] str = new byte[BUFFER_SIZE];\n+                        int i = 0;\n+                        int segLength;\n+                        while ((segLength = dataStream.readByte()) > 0) {\n+                            for (int index = 0; index < segLength; index++) {\n+                                str[i] = dataStream.readByte();\n+                                i++;\n+                            }\n+                            str[i] = '.';\n+                            i++;\n+                        }\n+                        String name = new String(str, 0, i, StandardCharsets.UTF_8);\n+                        short typ = dataStream.readShort();\n+                        short clazz = (short) (CLASS_MASK & dataStream.readShort());\n+                        if (!(name.startsWith(KLF_SERVICE_ID)) || (typ != TYPE_PTR) || (clazz != CLASS_IN)) {\n+                            return false;\n+                        }\n+\n+                        // if we got here, the name and response type are valid\n+                        @SuppressWarnings(\"unused\")\n+                        int ttl = dataStream.readInt();\n+                        @SuppressWarnings(\"unused\")\n+                        short dataLen = dataStream.readShort();\n+\n+                        // parse the host name\n+                        i = 0;\n+                        while ((segLength = dataStream.readByte()) > 0) {\n+                            for (int index = 0; index < segLength; index++) {\n+                                str[i] = dataStream.readByte();\n+                                i++;\n+                            }\n+                            str[i] = '.';\n+                            i++;\n+                        }\n+\n+                        // check if the host name matches\n+                        String host = new String(str, 0, i, StandardCharsets.UTF_8);\n+                        if (host.startsWith(KLF_HOST_PREFIX)) {\n+                            return true;\n+                        }\n+                    }\n+                }\n+            }\n+        } catch (IOException e) {\n+            // fall through\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Start the listener thread\n+     */\n+    private void startListener() {\n+        Thread listenerThreadX = this.listenerThread;\n+        if (listenerThreadX == null) {\n+            listenerThreadX = listenerThread = new Thread(listenerRunnable);\n+            listenerThreadX.start();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTcyNjM4Mg=="}, "originalCommit": {"oid": "68dad575579d134733613144caffad0a127675f4"}, "originalPosition": 231}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMjE5ODI1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/discovery/VeluxDiscoveryService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNjo1MToxNVrOH5L-SA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxMjoyNToyMVrOH5xFGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTcyNzA0OA==", "bodyText": "Can the comment be remvoed?", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r529727048", "createdAt": "2020-11-24T16:51:15Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/discovery/VeluxDiscoveryService.java", "diffHunk": "@@ -45,19 +46,14 @@\n  *\n  * @author Guenther Schreiner - Initial contribution.\n  */\n-//\n-// To-be-discussed: check whether an immediate activation is preferable.\n-// Might be activated by:\n-// @Component(service = DiscoveryService.class, configurationPid = \"discovery.velux\")\n-//\n @NonNullByDefault\n @Component(service = DiscoveryService.class, configurationPid = \"discovery.velux\")\n public class VeluxDiscoveryService extends AbstractDiscoveryService implements Runnable {\n     private final Logger logger = LoggerFactory.getLogger(VeluxDiscoveryService.class);\n \n     // Class internal\n \n-    private static final int DISCOVER_TIMEOUT_SECONDS = 300;\n+    private static final int DISCOVER_TIMEOUT_SECONDS = 60; // 300;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68dad575579d134733613144caffad0a127675f4"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDMzNTAwMQ==", "bodyText": "Yes :)", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r530335001", "createdAt": "2020-11-25T12:25:21Z", "author": {"login": "andrewfg"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/discovery/VeluxDiscoveryService.java", "diffHunk": "@@ -45,19 +46,14 @@\n  *\n  * @author Guenther Schreiner - Initial contribution.\n  */\n-//\n-// To-be-discussed: check whether an immediate activation is preferable.\n-// Might be activated by:\n-// @Component(service = DiscoveryService.class, configurationPid = \"discovery.velux\")\n-//\n @NonNullByDefault\n @Component(service = DiscoveryService.class, configurationPid = \"discovery.velux\")\n public class VeluxDiscoveryService extends AbstractDiscoveryService implements Runnable {\n     private final Logger logger = LoggerFactory.getLogger(VeluxDiscoveryService.class);\n \n     // Class internal\n \n-    private static final int DISCOVER_TIMEOUT_SECONDS = 300;\n+    private static final int DISCOVER_TIMEOUT_SECONDS = 60; // 300;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTcyNzA0OA=="}, "originalCommit": {"oid": "68dad575579d134733613144caffad0a127675f4"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMjIwMDc3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/discovery/VeluxDiscoveryService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNjo1MTo0NlrOH5L_0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxMjoyNjoyMlrOH5xHaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTcyNzQ0Mw==", "bodyText": "Can this be removed?", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r529727443", "createdAt": "2020-11-24T16:51:46Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/discovery/VeluxDiscoveryService.java", "diffHunk": "@@ -161,7 +160,7 @@ protected synchronized void startScan() {\n     public synchronized void stopScan() {\n         logger.trace(\"stopScan() called.\");\n         super.stopScan();\n-        removeOlderResults(getTimestampOfLastScan());\n+        // removeOlderResults(getTimestampOfLastScan());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68dad575579d134733613144caffad0a127675f4"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDMzNTU5NQ==", "bodyText": "Yes.", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r530335595", "createdAt": "2020-11-25T12:26:22Z", "author": {"login": "andrewfg"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/discovery/VeluxDiscoveryService.java", "diffHunk": "@@ -161,7 +160,7 @@ protected synchronized void startScan() {\n     public synchronized void stopScan() {\n         logger.trace(\"stopScan() called.\");\n         super.stopScan();\n-        removeOlderResults(getTimestampOfLastScan());\n+        // removeOlderResults(getTimestampOfLastScan());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTcyNzQ0Mw=="}, "originalCommit": {"oid": "68dad575579d134733613144caffad0a127675f4"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMjIxNzkyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/discovery/VeluxDiscoveryService.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNjo1NToyNVrOH5MKdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxODoyMjowOFrOH5_TDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTczMDE2NQ==", "bodyText": "If I understand correctly, you remove the bridges from the result, which already exist as a Thing. This is done by the framework if the representation properties are the same.", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r529730165", "createdAt": "2020-11-24T16:55:25Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/discovery/VeluxDiscoveryService.java", "diffHunk": "@@ -286,4 +285,27 @@ public boolean removeBridge(VeluxBridgeHandler bridge) {\n     public boolean isEmpty() {\n         return bridgeHandlers.isEmpty();\n     }\n+\n+    /**\n+     * Discover any bridges on the network that are not yet instantiated.\n+     */\n+    private void discoverBridges() {\n+        // discover the list of IP addresses of bridges on the network\n+        Set<String> foundBridgeIpAddresses = VeluxBridgeFinder.discoverIpAddresses();\n+\n+        // remove already instantiated bridges from the list\n+        for (VeluxBridgeHandler existingBridge : bridgeHandlers) {\n+            foundBridgeIpAddresses.remove(existingBridge.veluxBridgeConfiguration().ipAddress);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68dad575579d134733613144caffad0a127675f4"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDM0MjM0Ng==", "bodyText": "Indeed. I am a great fan of representationProperty  (although sadly many contributors seem not understand it). But IMHO even if the Inbox would indeed remove the Bridges, I don't see any point to waste effort to put them in it.", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r530342346", "createdAt": "2020-11-25T12:37:45Z", "author": {"login": "andrewfg"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/discovery/VeluxDiscoveryService.java", "diffHunk": "@@ -286,4 +285,27 @@ public boolean removeBridge(VeluxBridgeHandler bridge) {\n     public boolean isEmpty() {\n         return bridgeHandlers.isEmpty();\n     }\n+\n+    /**\n+     * Discover any bridges on the network that are not yet instantiated.\n+     */\n+    private void discoverBridges() {\n+        // discover the list of IP addresses of bridges on the network\n+        Set<String> foundBridgeIpAddresses = VeluxBridgeFinder.discoverIpAddresses();\n+\n+        // remove already instantiated bridges from the list\n+        for (VeluxBridgeHandler existingBridge : bridgeHandlers) {\n+            foundBridgeIpAddresses.remove(existingBridge.veluxBridgeConfiguration().ipAddress);\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTczMDE2NQ=="}, "originalCommit": {"oid": "68dad575579d134733613144caffad0a127675f4"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDUzNjg3MA==", "bodyText": "To achieve good maintainable code, we shouldn't add code that already exist in the framework and is redundant, then. IMHO the computation effort is negligible wether this is sorted out here or in the framework.", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r530536870", "createdAt": "2020-11-25T17:25:06Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/discovery/VeluxDiscoveryService.java", "diffHunk": "@@ -286,4 +285,27 @@ public boolean removeBridge(VeluxBridgeHandler bridge) {\n     public boolean isEmpty() {\n         return bridgeHandlers.isEmpty();\n     }\n+\n+    /**\n+     * Discover any bridges on the network that are not yet instantiated.\n+     */\n+    private void discoverBridges() {\n+        // discover the list of IP addresses of bridges on the network\n+        Set<String> foundBridgeIpAddresses = VeluxBridgeFinder.discoverIpAddresses();\n+\n+        // remove already instantiated bridges from the list\n+        for (VeluxBridgeHandler existingBridge : bridgeHandlers) {\n+            foundBridgeIpAddresses.remove(existingBridge.veluxBridgeConfiguration().ipAddress);\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTczMDE2NQ=="}, "originalCommit": {"oid": "68dad575579d134733613144caffad0a127675f4"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU2Nzk0OQ==", "bodyText": "Ok.", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r530567949", "createdAt": "2020-11-25T18:22:08Z", "author": {"login": "andrewfg"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/discovery/VeluxDiscoveryService.java", "diffHunk": "@@ -286,4 +285,27 @@ public boolean removeBridge(VeluxBridgeHandler bridge) {\n     public boolean isEmpty() {\n         return bridgeHandlers.isEmpty();\n     }\n+\n+    /**\n+     * Discover any bridges on the network that are not yet instantiated.\n+     */\n+    private void discoverBridges() {\n+        // discover the list of IP addresses of bridges on the network\n+        Set<String> foundBridgeIpAddresses = VeluxBridgeFinder.discoverIpAddresses();\n+\n+        // remove already instantiated bridges from the list\n+        for (VeluxBridgeHandler existingBridge : bridgeHandlers) {\n+            foundBridgeIpAddresses.remove(existingBridge.veluxBridgeConfiguration().ipAddress);\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTczMDE2NQ=="}, "originalCommit": {"oid": "68dad575579d134733613144caffad0a127675f4"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMjI3NDk1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/handler/VeluxBridgeHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNzowODozOFrOH5MuQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxMjozMDowNFrOH5xQAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTczOTMzMQ==", "bodyText": "The supression isn't needed anymore. Are you sure the map contains the key under all circumstances?", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r529739331", "createdAt": "2020-11-24T17:08:38Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/handler/VeluxBridgeHandler.java", "diffHunk": "@@ -452,28 +468,30 @@ private void syncChannelsWithProducts() {\n                     logger.trace(\"syncChannelsWithProducts(): channel {} not found.\", channelUID);\n                     continue;\n                 }\n-                if (!channel2VeluxActuator.get(channelUID).isKnown()) {\n+                @SuppressWarnings(\"null\")\n+                Thing2VeluxActuator actuator = channel2VeluxActuator.get(channelUID);\n+                if (!actuator.isKnown()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68dad575579d134733613144caffad0a127675f4"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDMzNzc5Mw==", "bodyText": "Ok. And yes. (And please can we have null annotations that work properly on Map<> ??)", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r530337793", "createdAt": "2020-11-25T12:30:04Z", "author": {"login": "andrewfg"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/handler/VeluxBridgeHandler.java", "diffHunk": "@@ -452,28 +468,30 @@ private void syncChannelsWithProducts() {\n                     logger.trace(\"syncChannelsWithProducts(): channel {} not found.\", channelUID);\n                     continue;\n                 }\n-                if (!channel2VeluxActuator.get(channelUID).isKnown()) {\n+                @SuppressWarnings(\"null\")\n+                Thing2VeluxActuator actuator = channel2VeluxActuator.get(channelUID);\n+                if (!actuator.isKnown()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTczOTMzMQ=="}, "originalCommit": {"oid": "68dad575579d134733613144caffad0a127675f4"}, "originalPosition": 155}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMjI5MDczOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/handler/VeluxBridgeHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNzoxMjoxM1rOH5M30Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxMjozMjo0NFrOH5xV7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTc0MTc3Nw==", "bodyText": "See above. Logging to info.", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r529741777", "createdAt": "2020-11-24T17:12:13Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/handler/VeluxBridgeHandler.java", "diffHunk": "@@ -706,4 +747,59 @@ private synchronized void handleCommandScheduled(ChannelUID channelUID, Command\n                 new java.util.Date(thisBridge.lastSuccessfulCommunication()).toString());\n         logger.trace(\"handleCommandScheduled({}) done.\", Thread.currentThread());\n     }\n+\n+    /**\n+     * Register the exported actions\n+     */\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singletonList(VeluxActions.class);\n+    }\n+\n+    /**\n+     * Exported method (called by an OpenHAB Rules Action) to issue a reboot command to the hub.\n+     *\n+     * @return true if the command could be issued\n+     */\n+    public boolean runReboot() {\n+        logger.trace(\"runReboot() called on {}\", getThing().getUID());\n+        RunReboot bcp = thisBridge.bridgeAPI().runReboot();\n+        if (bcp != null && handleScheduler != null) {\n+            // background execution of reboot process\n+            handleScheduler.execute(() -> {\n+                if (thisBridge.bridgeCommunicate(bcp)) {\n+                    logger.info(\"Reboot command {}sucessfully sent to {}\", bcp.isCommunicationSuccessful() ? \"\" : \"un\",\n+                            getThing().getUID());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68dad575579d134733613144caffad0a127675f4"}, "originalPosition": 304}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDMzOTMwOA==", "bodyText": "Again @fwolter I must disagree with you on this specific case. The case relates to the user issuing a remote reboot command to the Bridge. Under normal circumstances this would never need to be done. The command is only implemented because some users experience a lock up of the Bridge. So remote reboot is a really exceptional case, and therefore it must definitely be logged at 'INFO' (if not even higher..)", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r530339308", "createdAt": "2020-11-25T12:32:44Z", "author": {"login": "andrewfg"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/handler/VeluxBridgeHandler.java", "diffHunk": "@@ -706,4 +747,59 @@ private synchronized void handleCommandScheduled(ChannelUID channelUID, Command\n                 new java.util.Date(thisBridge.lastSuccessfulCommunication()).toString());\n         logger.trace(\"handleCommandScheduled({}) done.\", Thread.currentThread());\n     }\n+\n+    /**\n+     * Register the exported actions\n+     */\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singletonList(VeluxActions.class);\n+    }\n+\n+    /**\n+     * Exported method (called by an OpenHAB Rules Action) to issue a reboot command to the hub.\n+     *\n+     * @return true if the command could be issued\n+     */\n+    public boolean runReboot() {\n+        logger.trace(\"runReboot() called on {}\", getThing().getUID());\n+        RunReboot bcp = thisBridge.bridgeAPI().runReboot();\n+        if (bcp != null && handleScheduler != null) {\n+            // background execution of reboot process\n+            handleScheduler.execute(() -> {\n+                if (thisBridge.bridgeCommunicate(bcp)) {\n+                    logger.info(\"Reboot command {}sucessfully sent to {}\", bcp.isCommunicationSuccessful() ? \"\" : \"un\",\n+                            getThing().getUID());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTc0MTc3Nw=="}, "originalCommit": {"oid": "68dad575579d134733613144caffad0a127675f4"}, "originalPosition": 304}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMjMwNjA3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/things/VeluxExistingProducts.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNzoxNTo0NlrOH5NBMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxODoyMjo0NVrOH5_UGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTc0NDE3Nw==", "bodyText": "If I see correctly, this doesn't change any semantic. I think it's logical to use logical ORs here. What's the purpose of this change?", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r529744177", "createdAt": "2020-11-24T17:15:46Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/things/VeluxExistingProducts.java", "diffHunk": "@@ -123,8 +123,8 @@ public boolean update(ProductBridgeIndex bridgeProductIndex, int productState, i\n             return false;\n         }\n         VeluxProduct thisProduct = this.get(bridgeProductIndex);\n-        if (thisProduct.setState(productState) || thisProduct.setCurrentPosition(productPosition)\n-                || thisProduct.setTarget(productTarget)) {\n+        if (thisProduct.setState(productState) | thisProduct.setCurrentPosition(productPosition)\n+                | thisProduct.setTarget(productTarget)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "68dad575579d134733613144caffad0a127675f4"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDM0OTI5NQ==", "bodyText": "@fwolter IMHO this change is essential. In a Java if statement based on || the compiler does logical short circuit optimisations; this means that if the leftmost function evaluates to true, then any functions further right need not be, and therefore are not, evaluated. OTOH replacing the || operator by | prevents logical short circuit optimisations, and so it forces all three property setters to be called.", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r530349295", "createdAt": "2020-11-25T12:49:15Z", "author": {"login": "andrewfg"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/things/VeluxExistingProducts.java", "diffHunk": "@@ -123,8 +123,8 @@ public boolean update(ProductBridgeIndex bridgeProductIndex, int productState, i\n             return false;\n         }\n         VeluxProduct thisProduct = this.get(bridgeProductIndex);\n-        if (thisProduct.setState(productState) || thisProduct.setCurrentPosition(productPosition)\n-                || thisProduct.setTarget(productTarget)) {\n+        if (thisProduct.setState(productState) | thisProduct.setCurrentPosition(productPosition)\n+                | thisProduct.setTarget(productTarget)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTc0NDE3Nw=="}, "originalCommit": {"oid": "68dad575579d134733613144caffad0a127675f4"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU0MDYwNA==", "bodyText": "Ok, I see. Can you add a comment that the next contributor/reviewer doesn't stumble upon it?", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r530540604", "createdAt": "2020-11-25T17:31:32Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/things/VeluxExistingProducts.java", "diffHunk": "@@ -123,8 +123,8 @@ public boolean update(ProductBridgeIndex bridgeProductIndex, int productState, i\n             return false;\n         }\n         VeluxProduct thisProduct = this.get(bridgeProductIndex);\n-        if (thisProduct.setState(productState) || thisProduct.setCurrentPosition(productPosition)\n-                || thisProduct.setTarget(productTarget)) {\n+        if (thisProduct.setState(productState) | thisProduct.setCurrentPosition(productPosition)\n+                | thisProduct.setTarget(productTarget)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTc0NDE3Nw=="}, "originalCommit": {"oid": "68dad575579d134733613144caffad0a127675f4"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU2ODIxOA==", "bodyText": "Ok.", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r530568218", "createdAt": "2020-11-25T18:22:45Z", "author": {"login": "andrewfg"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/things/VeluxExistingProducts.java", "diffHunk": "@@ -123,8 +123,8 @@ public boolean update(ProductBridgeIndex bridgeProductIndex, int productState, i\n             return false;\n         }\n         VeluxProduct thisProduct = this.get(bridgeProductIndex);\n-        if (thisProduct.setState(productState) || thisProduct.setCurrentPosition(productPosition)\n-                || thisProduct.setTarget(productTarget)) {\n+        if (thisProduct.setState(productState) | thisProduct.setCurrentPosition(productPosition)\n+                | thisProduct.setTarget(productTarget)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTc0NDE3Nw=="}, "originalCommit": {"oid": "68dad575579d134733613144caffad0a127675f4"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNzcxNTg3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/bridge/slip/io/DataInputStreamWithTimeout.java", "isResolved": true, "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxODo1NDo0MVrOH6AQXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yN1QwNjo1NjowNFrOH6y2SA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU4MzY0NQ==", "bodyText": "This should contain the Thing UID.", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r530583645", "createdAt": "2020-11-25T18:54:41Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/bridge/slip/io/DataInputStreamWithTimeout.java", "diffHunk": "@@ -12,124 +12,199 @@\n  */\n package org.openhab.binding.velux.internal.bridge.slip.io;\n \n-import java.io.DataInputStream;\n+import java.io.Closeable;\n import java.io.IOException;\n import java.io.InputStream;\n-import java.util.concurrent.Callable;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.Future;\n-import java.util.concurrent.RejectedExecutionException;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.TimeoutException;\n+import java.net.SocketTimeoutException;\n+import java.util.Arrays;\n+import java.util.NoSuchElementException;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n /**\n- * This is an extension of {@link java.io.DataInputStream}, which adds timeouts to receive operation.\n- * <P>\n- * A data input stream lets an application read primitive Java data\n- * types from an underlying input stream in a machine-independent\n- * way. An application uses a data output stream to write data that\n- * can later be read by a data input stream.\n- * <p>\n- * For an in-depth discussion, see:\n- * https://stackoverflow.com/questions/804951/is-it-possible-to-read-from-a-inputstream-with-a-timeout\n+ * This is an wrapper around {@link java.io.InputStream} to support socket receive operations.\n+ *\n+ * It implements a secondary polling thread to asynchronously read bytes from the socket input stream into a buffer. And\n+ * it parses the bytes into SLIP messages, which are placed on a message queue. Callers can access the SLIP messages in\n+ * this queue independently from the polling thread.\n  *\n  * @author Guenther Schreiner - Initial contribution.\n+ * @author Andrew Fiddian-Green - Complete rewrite using asynchronous polling thread.\n  */\n @NonNullByDefault\n-class DataInputStreamWithTimeout extends DataInputStream {\n+class DataInputStreamWithTimeout implements Closeable {\n \n-    /*\n-     * ***************************\n-     * ***** Private Objects *****\n-     */\n+    private static final String OH_BINDING_VELUX_BRIDGE = \"OH-binding-velux-bridge\";\n+\n+    private static final int QUEUE_SIZE = 512;\n+    private static final int BUFFER_SIZE = 512;\n+    private static final int SLEEP_INTERVAL_MSECS = 50;\n+\n+    // special character that marks the first and last byte of a slip message\n+    private static final byte SLIP_MARK = (byte) 0xc0;\n+\n+    private final Logger logger = LoggerFactory.getLogger(DataInputStreamWithTimeout.class);\n+\n+    private final Queue<byte[]> slipMessageQueue = new ConcurrentLinkedQueue<>();\n+\n+    private InputStream inputStream;\n+\n+    private String pollException = \"\";\n+    private @Nullable Thread pollThread = null;\n \n     /**\n-     * Executor for asynchronous read command\n+     * A runnable that loops to read bytes from {@link InputStream} and builds SLIP packets from them. The respective\n+     * SLIP packets are placed in a {@link ConcurrentLinkedQueue}.\n      */\n-    ExecutorService executor = Executors.newFixedThreadPool(2);\n+    private Runnable pollRunner = () -> {\n+        byte byt;\n+        byte[] buf = new byte[BUFFER_SIZE];\n+        int i = 0;\n+        pollException = \"\";\n+        slipMessageQueue.clear();\n+        while (!Thread.interrupted()) {\n+            try {\n+                buf[i] = byt = (byte) inputStream.read();\n+                if (byt == SLIP_MARK) {\n+                    if (i > 0) {\n+                        // the minimal slip message is 7 bytes [MM PP LL CC CC KK MM]\n+                        if ((i > 5) && (buf[0] == SLIP_MARK)) {\n+                            slipMessageQueue.offer(Arrays.copyOfRange(buf, 0, i + 1));\n+                            if (slipMessageQueue.size() > QUEUE_SIZE) {\n+                                logger.warn(\"pollRunner() => slip message queue overflow => PLEASE REPORT !!\");\n+                                slipMessageQueue.poll();\n+                            }\n+                        }\n+                        i = 0;\n+                        buf[0] = SLIP_MARK;\n+                        continue;\n+                    }\n+                }\n+                if (++i >= BUFFER_SIZE) {\n+                    i = 0;\n+                }\n+            } catch (SocketTimeoutException e) {\n+                // socket read time outs are OK => just keep on polling\n+                continue;\n+            } catch (IOException e) {\n+                // any other exception => stop polling\n+                pollException = e.getMessage();\n+                logger.debug(\"pollRunner() stopping '{}'\", pollException);\n+                break;\n+            }\n+        }\n+        pollThread = null;\n+    };\n \n     /**\n-     * Creates a DataInputStreamWithTimeout that uses the specified\n-     * underlying DataInputStream.\n+     * Check if there was an exception on the polling loop thread and if so, throw it back on the caller thread.\n      *\n-     * @param in the specified input stream\n+     * @throws IOException\n      */\n-    public DataInputStreamWithTimeout(InputStream in) {\n-        super(in);\n+    private void throwIfPollException() throws IOException {\n+        if (!pollException.isEmpty()) {\n+            logger.debug(\"passPollException() polling loop exception {}\", pollException);\n+            throw new IOException(pollException);\n+        }\n     }\n \n     /**\n-     * Reads up to <code>len</code> bytes of data from the contained\n-     * input stream into an array of bytes. An attempt is made to read\n-     * as many as <code>len</code> bytes, but a smaller number may be read,\n-     * possibly zero. The number of bytes actually read is returned as an\n-     * integer.\n+     * Creates a {@link DataInputStreamWithTimeout} as a wrapper around the specified underlying DataInputStream.\n      *\n-     * <p>\n-     * This method blocks until input data is available, end of file is\n-     * detected, or an exception is thrown <B>until</B> the given timeout.\n-     *\n-     * <p>\n-     * If <code>len</code> is zero, then no bytes are read and\n-     * <code>0</code> is returned; otherwise, there is an attempt to read at\n-     * least one byte. If no byte is available because the stream is at end of\n-     * file, the value <code>-1</code> is returned; otherwise, at least one\n-     * byte is read and stored into <code>b</code>.\n-     *\n-     * <p>\n-     * The first byte read is stored into element <code>b[off]</code>, the\n-     * next one into <code>b[off+1]</code>, and so on. The number of bytes read\n-     * is, at most, equal to <code>len</code>. Let <i>k</i> be the number of\n-     * bytes actually read; these bytes will be stored in elements\n-     * <code>b[off]</code> through <code>b[off+</code><i>k</i><code>-1]</code>,\n-     * leaving elements <code>b[off+</code><i>k</i><code>]</code> through\n-     * <code>b[off+len-1]</code> unaffected.\n+     * @param stream the specified input stream\n+     */\n+    public DataInputStreamWithTimeout(InputStream stream) {\n+        inputStream = stream;\n+    }\n+\n+    /**\n+     * Overridden method of {@link Closeable} interface. Stops the polling thread.\n      *\n-     * <p>\n-     * In every case, elements <code>b[0]</code> through\n-     * <code>b[off]</code> and elements <code>b[off+len]</code> through\n-     * <code>b[b.length-1]</code> are unaffected.\n+     * @throws IOException\n+     */\n+    @Override\n+    public void close() throws IOException {\n+        stopPolling();\n+    }\n+\n+    /**\n+     * Reads and removes the next available SLIP message from the queue. If the queue is empty, continue polling\n+     * until either a message is found, or the timeout expires.\n      *\n-     * @param b the buffer into which the data is read.\n-     * @param off the start offset in the destination array <code>b</code>\n-     * @param len the maximum number of bytes read.\n-     * @param timeoutMSecs the maximum duration of this read before throwing a TimeoutException.\n-     * @return the total number of bytes read into the buffer, or\n-     *         <code>-1</code> if there is no more data because the end\n-     *         of the stream has been reached.\n-     * @exception NullPointerException If <code>b</code> is <code>null</code>.\n-     * @exception IndexOutOfBoundsException If <code>off</code> is negative,\n-     *                <code>len</code> is negative, or <code>len</code> is greater than\n-     *                <code>b.length - off</code>\n-     * @exception IOException if the first byte cannot be read for any reason\n-     *                other than end of file, the stream has been closed and the underlying\n-     *                input stream does not support reading after close, or another I/O\n-     *                error occurs. Additionally it will occur when the timeout happens.\n-     * @see java.io.DataInputStream#read\n+     * @param timeoutMSecs the timeout period in milliseconds.\n+     * @return the next SLIP message if there is one on the queue, or any empty byte[] array if not.\n+     * @throws IOException\n      */\n-    public synchronized int read(byte b[], int off, int len, int timeoutMSecs) throws IOException {\n-        // Definition of Method which encapsulates the Read of data\n-        Callable<Integer> readTask = new Callable<Integer>() {\n-            @Override\n-            public Integer call() throws IOException {\n-                return in.read(b, off, len);\n+    public byte[] readSlipMessage(int timeoutMSecs) throws IOException {\n+        startPolling();\n+        int i = (timeoutMSecs / SLEEP_INTERVAL_MSECS) + 1;\n+        while (i-- >= 0) {\n+            try {\n+                byte[] slip = slipMessageQueue.remove();\n+                logger.trace(\"readSlipMessage() => return slip message\");\n+                return slip;\n+            } catch (NoSuchElementException e) {\n+                // queue empty, wait and continue\n             }\n-        };\n-        try {\n-            Future<Integer> future = executor.submit(readTask);\n-            return future.get(timeoutMSecs, TimeUnit.MILLISECONDS);\n-        } catch (RejectedExecutionException e) {\n-            throw new IOException(\"executor failed\", e);\n-        } catch (ExecutionException e) {\n-            throw new IOException(\"execution failed\", e);\n-        } catch (InterruptedException e) {\n-            throw new IOException(\"read interrupted\", e);\n-        } catch (TimeoutException e) {\n-            throw new IOException(\"read timeout\", e);\n+            try {\n+                Thread.sleep(SLEEP_INTERVAL_MSECS);\n+            } catch (InterruptedException e) {\n+                logger.debug(\"readSlipMessage() => thread interrupt\");\n+                throw new IOException(\"Thread Interrupted\");\n+            }\n+            throwIfPollException();\n+        }\n+        logger.debug(\"readSlipMessage() => no slip message after {}mS => time out\", timeoutMSecs);\n+        return new byte[0];\n+    }\n+\n+    /**\n+     * Get the number of incoming messages in the queue\n+     *\n+     * @return the number of incoming messages in the queue\n+     */\n+    public int available() {\n+        int size = slipMessageQueue.size();\n+        logger.trace(\"available() => slip message count {}\", size);\n+        return size;\n+    }\n+\n+    /**\n+     * Clear the queue\n+     */\n+    public void flush() {\n+        logger.trace(\"flush() called\");\n+        slipMessageQueue.clear();\n+    }\n+\n+    /**\n+     * If necessary start the polling thread\n+     */\n+    private void startPolling() {\n+        Thread pollThreadX = this.pollThread;\n+        if (pollThreadX != null) {\n+            logger.trace(\"startPolling()\");\n+            pollThreadX = pollThread = new Thread(pollRunner);\n+            pollThreadX.setDaemon(true);\n+            pollThreadX.setName(OH_BINDING_VELUX_BRIDGE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e58c50a9777538ffe7de0fb104220df902c237b3"}, "originalPosition": 275}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTE4MzQ2Ng==", "bodyText": "I think these changes caused something to break in the binding. So I am testing again.", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r531183466", "createdAt": "2020-11-26T18:32:22Z", "author": {"login": "andrewfg"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/bridge/slip/io/DataInputStreamWithTimeout.java", "diffHunk": "@@ -12,124 +12,199 @@\n  */\n package org.openhab.binding.velux.internal.bridge.slip.io;\n \n-import java.io.DataInputStream;\n+import java.io.Closeable;\n import java.io.IOException;\n import java.io.InputStream;\n-import java.util.concurrent.Callable;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.Future;\n-import java.util.concurrent.RejectedExecutionException;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.TimeoutException;\n+import java.net.SocketTimeoutException;\n+import java.util.Arrays;\n+import java.util.NoSuchElementException;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n /**\n- * This is an extension of {@link java.io.DataInputStream}, which adds timeouts to receive operation.\n- * <P>\n- * A data input stream lets an application read primitive Java data\n- * types from an underlying input stream in a machine-independent\n- * way. An application uses a data output stream to write data that\n- * can later be read by a data input stream.\n- * <p>\n- * For an in-depth discussion, see:\n- * https://stackoverflow.com/questions/804951/is-it-possible-to-read-from-a-inputstream-with-a-timeout\n+ * This is an wrapper around {@link java.io.InputStream} to support socket receive operations.\n+ *\n+ * It implements a secondary polling thread to asynchronously read bytes from the socket input stream into a buffer. And\n+ * it parses the bytes into SLIP messages, which are placed on a message queue. Callers can access the SLIP messages in\n+ * this queue independently from the polling thread.\n  *\n  * @author Guenther Schreiner - Initial contribution.\n+ * @author Andrew Fiddian-Green - Complete rewrite using asynchronous polling thread.\n  */\n @NonNullByDefault\n-class DataInputStreamWithTimeout extends DataInputStream {\n+class DataInputStreamWithTimeout implements Closeable {\n \n-    /*\n-     * ***************************\n-     * ***** Private Objects *****\n-     */\n+    private static final String OH_BINDING_VELUX_BRIDGE = \"OH-binding-velux-bridge\";\n+\n+    private static final int QUEUE_SIZE = 512;\n+    private static final int BUFFER_SIZE = 512;\n+    private static final int SLEEP_INTERVAL_MSECS = 50;\n+\n+    // special character that marks the first and last byte of a slip message\n+    private static final byte SLIP_MARK = (byte) 0xc0;\n+\n+    private final Logger logger = LoggerFactory.getLogger(DataInputStreamWithTimeout.class);\n+\n+    private final Queue<byte[]> slipMessageQueue = new ConcurrentLinkedQueue<>();\n+\n+    private InputStream inputStream;\n+\n+    private String pollException = \"\";\n+    private @Nullable Thread pollThread = null;\n \n     /**\n-     * Executor for asynchronous read command\n+     * A runnable that loops to read bytes from {@link InputStream} and builds SLIP packets from them. The respective\n+     * SLIP packets are placed in a {@link ConcurrentLinkedQueue}.\n      */\n-    ExecutorService executor = Executors.newFixedThreadPool(2);\n+    private Runnable pollRunner = () -> {\n+        byte byt;\n+        byte[] buf = new byte[BUFFER_SIZE];\n+        int i = 0;\n+        pollException = \"\";\n+        slipMessageQueue.clear();\n+        while (!Thread.interrupted()) {\n+            try {\n+                buf[i] = byt = (byte) inputStream.read();\n+                if (byt == SLIP_MARK) {\n+                    if (i > 0) {\n+                        // the minimal slip message is 7 bytes [MM PP LL CC CC KK MM]\n+                        if ((i > 5) && (buf[0] == SLIP_MARK)) {\n+                            slipMessageQueue.offer(Arrays.copyOfRange(buf, 0, i + 1));\n+                            if (slipMessageQueue.size() > QUEUE_SIZE) {\n+                                logger.warn(\"pollRunner() => slip message queue overflow => PLEASE REPORT !!\");\n+                                slipMessageQueue.poll();\n+                            }\n+                        }\n+                        i = 0;\n+                        buf[0] = SLIP_MARK;\n+                        continue;\n+                    }\n+                }\n+                if (++i >= BUFFER_SIZE) {\n+                    i = 0;\n+                }\n+            } catch (SocketTimeoutException e) {\n+                // socket read time outs are OK => just keep on polling\n+                continue;\n+            } catch (IOException e) {\n+                // any other exception => stop polling\n+                pollException = e.getMessage();\n+                logger.debug(\"pollRunner() stopping '{}'\", pollException);\n+                break;\n+            }\n+        }\n+        pollThread = null;\n+    };\n \n     /**\n-     * Creates a DataInputStreamWithTimeout that uses the specified\n-     * underlying DataInputStream.\n+     * Check if there was an exception on the polling loop thread and if so, throw it back on the caller thread.\n      *\n-     * @param in the specified input stream\n+     * @throws IOException\n      */\n-    public DataInputStreamWithTimeout(InputStream in) {\n-        super(in);\n+    private void throwIfPollException() throws IOException {\n+        if (!pollException.isEmpty()) {\n+            logger.debug(\"passPollException() polling loop exception {}\", pollException);\n+            throw new IOException(pollException);\n+        }\n     }\n \n     /**\n-     * Reads up to <code>len</code> bytes of data from the contained\n-     * input stream into an array of bytes. An attempt is made to read\n-     * as many as <code>len</code> bytes, but a smaller number may be read,\n-     * possibly zero. The number of bytes actually read is returned as an\n-     * integer.\n+     * Creates a {@link DataInputStreamWithTimeout} as a wrapper around the specified underlying DataInputStream.\n      *\n-     * <p>\n-     * This method blocks until input data is available, end of file is\n-     * detected, or an exception is thrown <B>until</B> the given timeout.\n-     *\n-     * <p>\n-     * If <code>len</code> is zero, then no bytes are read and\n-     * <code>0</code> is returned; otherwise, there is an attempt to read at\n-     * least one byte. If no byte is available because the stream is at end of\n-     * file, the value <code>-1</code> is returned; otherwise, at least one\n-     * byte is read and stored into <code>b</code>.\n-     *\n-     * <p>\n-     * The first byte read is stored into element <code>b[off]</code>, the\n-     * next one into <code>b[off+1]</code>, and so on. The number of bytes read\n-     * is, at most, equal to <code>len</code>. Let <i>k</i> be the number of\n-     * bytes actually read; these bytes will be stored in elements\n-     * <code>b[off]</code> through <code>b[off+</code><i>k</i><code>-1]</code>,\n-     * leaving elements <code>b[off+</code><i>k</i><code>]</code> through\n-     * <code>b[off+len-1]</code> unaffected.\n+     * @param stream the specified input stream\n+     */\n+    public DataInputStreamWithTimeout(InputStream stream) {\n+        inputStream = stream;\n+    }\n+\n+    /**\n+     * Overridden method of {@link Closeable} interface. Stops the polling thread.\n      *\n-     * <p>\n-     * In every case, elements <code>b[0]</code> through\n-     * <code>b[off]</code> and elements <code>b[off+len]</code> through\n-     * <code>b[b.length-1]</code> are unaffected.\n+     * @throws IOException\n+     */\n+    @Override\n+    public void close() throws IOException {\n+        stopPolling();\n+    }\n+\n+    /**\n+     * Reads and removes the next available SLIP message from the queue. If the queue is empty, continue polling\n+     * until either a message is found, or the timeout expires.\n      *\n-     * @param b the buffer into which the data is read.\n-     * @param off the start offset in the destination array <code>b</code>\n-     * @param len the maximum number of bytes read.\n-     * @param timeoutMSecs the maximum duration of this read before throwing a TimeoutException.\n-     * @return the total number of bytes read into the buffer, or\n-     *         <code>-1</code> if there is no more data because the end\n-     *         of the stream has been reached.\n-     * @exception NullPointerException If <code>b</code> is <code>null</code>.\n-     * @exception IndexOutOfBoundsException If <code>off</code> is negative,\n-     *                <code>len</code> is negative, or <code>len</code> is greater than\n-     *                <code>b.length - off</code>\n-     * @exception IOException if the first byte cannot be read for any reason\n-     *                other than end of file, the stream has been closed and the underlying\n-     *                input stream does not support reading after close, or another I/O\n-     *                error occurs. Additionally it will occur when the timeout happens.\n-     * @see java.io.DataInputStream#read\n+     * @param timeoutMSecs the timeout period in milliseconds.\n+     * @return the next SLIP message if there is one on the queue, or any empty byte[] array if not.\n+     * @throws IOException\n      */\n-    public synchronized int read(byte b[], int off, int len, int timeoutMSecs) throws IOException {\n-        // Definition of Method which encapsulates the Read of data\n-        Callable<Integer> readTask = new Callable<Integer>() {\n-            @Override\n-            public Integer call() throws IOException {\n-                return in.read(b, off, len);\n+    public byte[] readSlipMessage(int timeoutMSecs) throws IOException {\n+        startPolling();\n+        int i = (timeoutMSecs / SLEEP_INTERVAL_MSECS) + 1;\n+        while (i-- >= 0) {\n+            try {\n+                byte[] slip = slipMessageQueue.remove();\n+                logger.trace(\"readSlipMessage() => return slip message\");\n+                return slip;\n+            } catch (NoSuchElementException e) {\n+                // queue empty, wait and continue\n             }\n-        };\n-        try {\n-            Future<Integer> future = executor.submit(readTask);\n-            return future.get(timeoutMSecs, TimeUnit.MILLISECONDS);\n-        } catch (RejectedExecutionException e) {\n-            throw new IOException(\"executor failed\", e);\n-        } catch (ExecutionException e) {\n-            throw new IOException(\"execution failed\", e);\n-        } catch (InterruptedException e) {\n-            throw new IOException(\"read interrupted\", e);\n-        } catch (TimeoutException e) {\n-            throw new IOException(\"read timeout\", e);\n+            try {\n+                Thread.sleep(SLEEP_INTERVAL_MSECS);\n+            } catch (InterruptedException e) {\n+                logger.debug(\"readSlipMessage() => thread interrupt\");\n+                throw new IOException(\"Thread Interrupted\");\n+            }\n+            throwIfPollException();\n+        }\n+        logger.debug(\"readSlipMessage() => no slip message after {}mS => time out\", timeoutMSecs);\n+        return new byte[0];\n+    }\n+\n+    /**\n+     * Get the number of incoming messages in the queue\n+     *\n+     * @return the number of incoming messages in the queue\n+     */\n+    public int available() {\n+        int size = slipMessageQueue.size();\n+        logger.trace(\"available() => slip message count {}\", size);\n+        return size;\n+    }\n+\n+    /**\n+     * Clear the queue\n+     */\n+    public void flush() {\n+        logger.trace(\"flush() called\");\n+        slipMessageQueue.clear();\n+    }\n+\n+    /**\n+     * If necessary start the polling thread\n+     */\n+    private void startPolling() {\n+        Thread pollThreadX = this.pollThread;\n+        if (pollThreadX != null) {\n+            logger.trace(\"startPolling()\");\n+            pollThreadX = pollThread = new Thread(pollRunner);\n+            pollThreadX.setDaemon(true);\n+            pollThreadX.setName(OH_BINDING_VELUX_BRIDGE);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU4MzY0NQ=="}, "originalCommit": {"oid": "e58c50a9777538ffe7de0fb104220df902c237b3"}, "originalPosition": 275}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTE5MDY1OQ==", "bodyText": "@fwolter I think the problem is the setDaemon(true) call. Indeed from Googling a bit, I think there may be two issues with this..\n\nit seems to run at lower priority than a user thread; and I am certainly observing many read timeouts\nit does not shutdown cleanly; so when I drop a new jar build, it now requires me to reboot the hub\n\nAs it currently stands, it is not useable.", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r531190659", "createdAt": "2020-11-26T18:57:07Z", "author": {"login": "andrewfg"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/bridge/slip/io/DataInputStreamWithTimeout.java", "diffHunk": "@@ -12,124 +12,199 @@\n  */\n package org.openhab.binding.velux.internal.bridge.slip.io;\n \n-import java.io.DataInputStream;\n+import java.io.Closeable;\n import java.io.IOException;\n import java.io.InputStream;\n-import java.util.concurrent.Callable;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.Future;\n-import java.util.concurrent.RejectedExecutionException;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.TimeoutException;\n+import java.net.SocketTimeoutException;\n+import java.util.Arrays;\n+import java.util.NoSuchElementException;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n /**\n- * This is an extension of {@link java.io.DataInputStream}, which adds timeouts to receive operation.\n- * <P>\n- * A data input stream lets an application read primitive Java data\n- * types from an underlying input stream in a machine-independent\n- * way. An application uses a data output stream to write data that\n- * can later be read by a data input stream.\n- * <p>\n- * For an in-depth discussion, see:\n- * https://stackoverflow.com/questions/804951/is-it-possible-to-read-from-a-inputstream-with-a-timeout\n+ * This is an wrapper around {@link java.io.InputStream} to support socket receive operations.\n+ *\n+ * It implements a secondary polling thread to asynchronously read bytes from the socket input stream into a buffer. And\n+ * it parses the bytes into SLIP messages, which are placed on a message queue. Callers can access the SLIP messages in\n+ * this queue independently from the polling thread.\n  *\n  * @author Guenther Schreiner - Initial contribution.\n+ * @author Andrew Fiddian-Green - Complete rewrite using asynchronous polling thread.\n  */\n @NonNullByDefault\n-class DataInputStreamWithTimeout extends DataInputStream {\n+class DataInputStreamWithTimeout implements Closeable {\n \n-    /*\n-     * ***************************\n-     * ***** Private Objects *****\n-     */\n+    private static final String OH_BINDING_VELUX_BRIDGE = \"OH-binding-velux-bridge\";\n+\n+    private static final int QUEUE_SIZE = 512;\n+    private static final int BUFFER_SIZE = 512;\n+    private static final int SLEEP_INTERVAL_MSECS = 50;\n+\n+    // special character that marks the first and last byte of a slip message\n+    private static final byte SLIP_MARK = (byte) 0xc0;\n+\n+    private final Logger logger = LoggerFactory.getLogger(DataInputStreamWithTimeout.class);\n+\n+    private final Queue<byte[]> slipMessageQueue = new ConcurrentLinkedQueue<>();\n+\n+    private InputStream inputStream;\n+\n+    private String pollException = \"\";\n+    private @Nullable Thread pollThread = null;\n \n     /**\n-     * Executor for asynchronous read command\n+     * A runnable that loops to read bytes from {@link InputStream} and builds SLIP packets from them. The respective\n+     * SLIP packets are placed in a {@link ConcurrentLinkedQueue}.\n      */\n-    ExecutorService executor = Executors.newFixedThreadPool(2);\n+    private Runnable pollRunner = () -> {\n+        byte byt;\n+        byte[] buf = new byte[BUFFER_SIZE];\n+        int i = 0;\n+        pollException = \"\";\n+        slipMessageQueue.clear();\n+        while (!Thread.interrupted()) {\n+            try {\n+                buf[i] = byt = (byte) inputStream.read();\n+                if (byt == SLIP_MARK) {\n+                    if (i > 0) {\n+                        // the minimal slip message is 7 bytes [MM PP LL CC CC KK MM]\n+                        if ((i > 5) && (buf[0] == SLIP_MARK)) {\n+                            slipMessageQueue.offer(Arrays.copyOfRange(buf, 0, i + 1));\n+                            if (slipMessageQueue.size() > QUEUE_SIZE) {\n+                                logger.warn(\"pollRunner() => slip message queue overflow => PLEASE REPORT !!\");\n+                                slipMessageQueue.poll();\n+                            }\n+                        }\n+                        i = 0;\n+                        buf[0] = SLIP_MARK;\n+                        continue;\n+                    }\n+                }\n+                if (++i >= BUFFER_SIZE) {\n+                    i = 0;\n+                }\n+            } catch (SocketTimeoutException e) {\n+                // socket read time outs are OK => just keep on polling\n+                continue;\n+            } catch (IOException e) {\n+                // any other exception => stop polling\n+                pollException = e.getMessage();\n+                logger.debug(\"pollRunner() stopping '{}'\", pollException);\n+                break;\n+            }\n+        }\n+        pollThread = null;\n+    };\n \n     /**\n-     * Creates a DataInputStreamWithTimeout that uses the specified\n-     * underlying DataInputStream.\n+     * Check if there was an exception on the polling loop thread and if so, throw it back on the caller thread.\n      *\n-     * @param in the specified input stream\n+     * @throws IOException\n      */\n-    public DataInputStreamWithTimeout(InputStream in) {\n-        super(in);\n+    private void throwIfPollException() throws IOException {\n+        if (!pollException.isEmpty()) {\n+            logger.debug(\"passPollException() polling loop exception {}\", pollException);\n+            throw new IOException(pollException);\n+        }\n     }\n \n     /**\n-     * Reads up to <code>len</code> bytes of data from the contained\n-     * input stream into an array of bytes. An attempt is made to read\n-     * as many as <code>len</code> bytes, but a smaller number may be read,\n-     * possibly zero. The number of bytes actually read is returned as an\n-     * integer.\n+     * Creates a {@link DataInputStreamWithTimeout} as a wrapper around the specified underlying DataInputStream.\n      *\n-     * <p>\n-     * This method blocks until input data is available, end of file is\n-     * detected, or an exception is thrown <B>until</B> the given timeout.\n-     *\n-     * <p>\n-     * If <code>len</code> is zero, then no bytes are read and\n-     * <code>0</code> is returned; otherwise, there is an attempt to read at\n-     * least one byte. If no byte is available because the stream is at end of\n-     * file, the value <code>-1</code> is returned; otherwise, at least one\n-     * byte is read and stored into <code>b</code>.\n-     *\n-     * <p>\n-     * The first byte read is stored into element <code>b[off]</code>, the\n-     * next one into <code>b[off+1]</code>, and so on. The number of bytes read\n-     * is, at most, equal to <code>len</code>. Let <i>k</i> be the number of\n-     * bytes actually read; these bytes will be stored in elements\n-     * <code>b[off]</code> through <code>b[off+</code><i>k</i><code>-1]</code>,\n-     * leaving elements <code>b[off+</code><i>k</i><code>]</code> through\n-     * <code>b[off+len-1]</code> unaffected.\n+     * @param stream the specified input stream\n+     */\n+    public DataInputStreamWithTimeout(InputStream stream) {\n+        inputStream = stream;\n+    }\n+\n+    /**\n+     * Overridden method of {@link Closeable} interface. Stops the polling thread.\n      *\n-     * <p>\n-     * In every case, elements <code>b[0]</code> through\n-     * <code>b[off]</code> and elements <code>b[off+len]</code> through\n-     * <code>b[b.length-1]</code> are unaffected.\n+     * @throws IOException\n+     */\n+    @Override\n+    public void close() throws IOException {\n+        stopPolling();\n+    }\n+\n+    /**\n+     * Reads and removes the next available SLIP message from the queue. If the queue is empty, continue polling\n+     * until either a message is found, or the timeout expires.\n      *\n-     * @param b the buffer into which the data is read.\n-     * @param off the start offset in the destination array <code>b</code>\n-     * @param len the maximum number of bytes read.\n-     * @param timeoutMSecs the maximum duration of this read before throwing a TimeoutException.\n-     * @return the total number of bytes read into the buffer, or\n-     *         <code>-1</code> if there is no more data because the end\n-     *         of the stream has been reached.\n-     * @exception NullPointerException If <code>b</code> is <code>null</code>.\n-     * @exception IndexOutOfBoundsException If <code>off</code> is negative,\n-     *                <code>len</code> is negative, or <code>len</code> is greater than\n-     *                <code>b.length - off</code>\n-     * @exception IOException if the first byte cannot be read for any reason\n-     *                other than end of file, the stream has been closed and the underlying\n-     *                input stream does not support reading after close, or another I/O\n-     *                error occurs. Additionally it will occur when the timeout happens.\n-     * @see java.io.DataInputStream#read\n+     * @param timeoutMSecs the timeout period in milliseconds.\n+     * @return the next SLIP message if there is one on the queue, or any empty byte[] array if not.\n+     * @throws IOException\n      */\n-    public synchronized int read(byte b[], int off, int len, int timeoutMSecs) throws IOException {\n-        // Definition of Method which encapsulates the Read of data\n-        Callable<Integer> readTask = new Callable<Integer>() {\n-            @Override\n-            public Integer call() throws IOException {\n-                return in.read(b, off, len);\n+    public byte[] readSlipMessage(int timeoutMSecs) throws IOException {\n+        startPolling();\n+        int i = (timeoutMSecs / SLEEP_INTERVAL_MSECS) + 1;\n+        while (i-- >= 0) {\n+            try {\n+                byte[] slip = slipMessageQueue.remove();\n+                logger.trace(\"readSlipMessage() => return slip message\");\n+                return slip;\n+            } catch (NoSuchElementException e) {\n+                // queue empty, wait and continue\n             }\n-        };\n-        try {\n-            Future<Integer> future = executor.submit(readTask);\n-            return future.get(timeoutMSecs, TimeUnit.MILLISECONDS);\n-        } catch (RejectedExecutionException e) {\n-            throw new IOException(\"executor failed\", e);\n-        } catch (ExecutionException e) {\n-            throw new IOException(\"execution failed\", e);\n-        } catch (InterruptedException e) {\n-            throw new IOException(\"read interrupted\", e);\n-        } catch (TimeoutException e) {\n-            throw new IOException(\"read timeout\", e);\n+            try {\n+                Thread.sleep(SLEEP_INTERVAL_MSECS);\n+            } catch (InterruptedException e) {\n+                logger.debug(\"readSlipMessage() => thread interrupt\");\n+                throw new IOException(\"Thread Interrupted\");\n+            }\n+            throwIfPollException();\n+        }\n+        logger.debug(\"readSlipMessage() => no slip message after {}mS => time out\", timeoutMSecs);\n+        return new byte[0];\n+    }\n+\n+    /**\n+     * Get the number of incoming messages in the queue\n+     *\n+     * @return the number of incoming messages in the queue\n+     */\n+    public int available() {\n+        int size = slipMessageQueue.size();\n+        logger.trace(\"available() => slip message count {}\", size);\n+        return size;\n+    }\n+\n+    /**\n+     * Clear the queue\n+     */\n+    public void flush() {\n+        logger.trace(\"flush() called\");\n+        slipMessageQueue.clear();\n+    }\n+\n+    /**\n+     * If necessary start the polling thread\n+     */\n+    private void startPolling() {\n+        Thread pollThreadX = this.pollThread;\n+        if (pollThreadX != null) {\n+            logger.trace(\"startPolling()\");\n+            pollThreadX = pollThread = new Thread(pollRunner);\n+            pollThreadX.setDaemon(true);\n+            pollThreadX.setName(OH_BINDING_VELUX_BRIDGE);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU4MzY0NQ=="}, "originalCommit": {"oid": "e58c50a9777538ffe7de0fb104220df902c237b3"}, "originalPosition": 275}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTE5MjIxMw==", "bodyText": "https://www.baeldung.com/java-daemon-thread\nhttps://beginnersbook.com/2015/01/daemon-thread-in-java-with-example/", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r531192213", "createdAt": "2020-11-26T19:02:22Z", "author": {"login": "andrewfg"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/bridge/slip/io/DataInputStreamWithTimeout.java", "diffHunk": "@@ -12,124 +12,199 @@\n  */\n package org.openhab.binding.velux.internal.bridge.slip.io;\n \n-import java.io.DataInputStream;\n+import java.io.Closeable;\n import java.io.IOException;\n import java.io.InputStream;\n-import java.util.concurrent.Callable;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.Future;\n-import java.util.concurrent.RejectedExecutionException;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.TimeoutException;\n+import java.net.SocketTimeoutException;\n+import java.util.Arrays;\n+import java.util.NoSuchElementException;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n /**\n- * This is an extension of {@link java.io.DataInputStream}, which adds timeouts to receive operation.\n- * <P>\n- * A data input stream lets an application read primitive Java data\n- * types from an underlying input stream in a machine-independent\n- * way. An application uses a data output stream to write data that\n- * can later be read by a data input stream.\n- * <p>\n- * For an in-depth discussion, see:\n- * https://stackoverflow.com/questions/804951/is-it-possible-to-read-from-a-inputstream-with-a-timeout\n+ * This is an wrapper around {@link java.io.InputStream} to support socket receive operations.\n+ *\n+ * It implements a secondary polling thread to asynchronously read bytes from the socket input stream into a buffer. And\n+ * it parses the bytes into SLIP messages, which are placed on a message queue. Callers can access the SLIP messages in\n+ * this queue independently from the polling thread.\n  *\n  * @author Guenther Schreiner - Initial contribution.\n+ * @author Andrew Fiddian-Green - Complete rewrite using asynchronous polling thread.\n  */\n @NonNullByDefault\n-class DataInputStreamWithTimeout extends DataInputStream {\n+class DataInputStreamWithTimeout implements Closeable {\n \n-    /*\n-     * ***************************\n-     * ***** Private Objects *****\n-     */\n+    private static final String OH_BINDING_VELUX_BRIDGE = \"OH-binding-velux-bridge\";\n+\n+    private static final int QUEUE_SIZE = 512;\n+    private static final int BUFFER_SIZE = 512;\n+    private static final int SLEEP_INTERVAL_MSECS = 50;\n+\n+    // special character that marks the first and last byte of a slip message\n+    private static final byte SLIP_MARK = (byte) 0xc0;\n+\n+    private final Logger logger = LoggerFactory.getLogger(DataInputStreamWithTimeout.class);\n+\n+    private final Queue<byte[]> slipMessageQueue = new ConcurrentLinkedQueue<>();\n+\n+    private InputStream inputStream;\n+\n+    private String pollException = \"\";\n+    private @Nullable Thread pollThread = null;\n \n     /**\n-     * Executor for asynchronous read command\n+     * A runnable that loops to read bytes from {@link InputStream} and builds SLIP packets from them. The respective\n+     * SLIP packets are placed in a {@link ConcurrentLinkedQueue}.\n      */\n-    ExecutorService executor = Executors.newFixedThreadPool(2);\n+    private Runnable pollRunner = () -> {\n+        byte byt;\n+        byte[] buf = new byte[BUFFER_SIZE];\n+        int i = 0;\n+        pollException = \"\";\n+        slipMessageQueue.clear();\n+        while (!Thread.interrupted()) {\n+            try {\n+                buf[i] = byt = (byte) inputStream.read();\n+                if (byt == SLIP_MARK) {\n+                    if (i > 0) {\n+                        // the minimal slip message is 7 bytes [MM PP LL CC CC KK MM]\n+                        if ((i > 5) && (buf[0] == SLIP_MARK)) {\n+                            slipMessageQueue.offer(Arrays.copyOfRange(buf, 0, i + 1));\n+                            if (slipMessageQueue.size() > QUEUE_SIZE) {\n+                                logger.warn(\"pollRunner() => slip message queue overflow => PLEASE REPORT !!\");\n+                                slipMessageQueue.poll();\n+                            }\n+                        }\n+                        i = 0;\n+                        buf[0] = SLIP_MARK;\n+                        continue;\n+                    }\n+                }\n+                if (++i >= BUFFER_SIZE) {\n+                    i = 0;\n+                }\n+            } catch (SocketTimeoutException e) {\n+                // socket read time outs are OK => just keep on polling\n+                continue;\n+            } catch (IOException e) {\n+                // any other exception => stop polling\n+                pollException = e.getMessage();\n+                logger.debug(\"pollRunner() stopping '{}'\", pollException);\n+                break;\n+            }\n+        }\n+        pollThread = null;\n+    };\n \n     /**\n-     * Creates a DataInputStreamWithTimeout that uses the specified\n-     * underlying DataInputStream.\n+     * Check if there was an exception on the polling loop thread and if so, throw it back on the caller thread.\n      *\n-     * @param in the specified input stream\n+     * @throws IOException\n      */\n-    public DataInputStreamWithTimeout(InputStream in) {\n-        super(in);\n+    private void throwIfPollException() throws IOException {\n+        if (!pollException.isEmpty()) {\n+            logger.debug(\"passPollException() polling loop exception {}\", pollException);\n+            throw new IOException(pollException);\n+        }\n     }\n \n     /**\n-     * Reads up to <code>len</code> bytes of data from the contained\n-     * input stream into an array of bytes. An attempt is made to read\n-     * as many as <code>len</code> bytes, but a smaller number may be read,\n-     * possibly zero. The number of bytes actually read is returned as an\n-     * integer.\n+     * Creates a {@link DataInputStreamWithTimeout} as a wrapper around the specified underlying DataInputStream.\n      *\n-     * <p>\n-     * This method blocks until input data is available, end of file is\n-     * detected, or an exception is thrown <B>until</B> the given timeout.\n-     *\n-     * <p>\n-     * If <code>len</code> is zero, then no bytes are read and\n-     * <code>0</code> is returned; otherwise, there is an attempt to read at\n-     * least one byte. If no byte is available because the stream is at end of\n-     * file, the value <code>-1</code> is returned; otherwise, at least one\n-     * byte is read and stored into <code>b</code>.\n-     *\n-     * <p>\n-     * The first byte read is stored into element <code>b[off]</code>, the\n-     * next one into <code>b[off+1]</code>, and so on. The number of bytes read\n-     * is, at most, equal to <code>len</code>. Let <i>k</i> be the number of\n-     * bytes actually read; these bytes will be stored in elements\n-     * <code>b[off]</code> through <code>b[off+</code><i>k</i><code>-1]</code>,\n-     * leaving elements <code>b[off+</code><i>k</i><code>]</code> through\n-     * <code>b[off+len-1]</code> unaffected.\n+     * @param stream the specified input stream\n+     */\n+    public DataInputStreamWithTimeout(InputStream stream) {\n+        inputStream = stream;\n+    }\n+\n+    /**\n+     * Overridden method of {@link Closeable} interface. Stops the polling thread.\n      *\n-     * <p>\n-     * In every case, elements <code>b[0]</code> through\n-     * <code>b[off]</code> and elements <code>b[off+len]</code> through\n-     * <code>b[b.length-1]</code> are unaffected.\n+     * @throws IOException\n+     */\n+    @Override\n+    public void close() throws IOException {\n+        stopPolling();\n+    }\n+\n+    /**\n+     * Reads and removes the next available SLIP message from the queue. If the queue is empty, continue polling\n+     * until either a message is found, or the timeout expires.\n      *\n-     * @param b the buffer into which the data is read.\n-     * @param off the start offset in the destination array <code>b</code>\n-     * @param len the maximum number of bytes read.\n-     * @param timeoutMSecs the maximum duration of this read before throwing a TimeoutException.\n-     * @return the total number of bytes read into the buffer, or\n-     *         <code>-1</code> if there is no more data because the end\n-     *         of the stream has been reached.\n-     * @exception NullPointerException If <code>b</code> is <code>null</code>.\n-     * @exception IndexOutOfBoundsException If <code>off</code> is negative,\n-     *                <code>len</code> is negative, or <code>len</code> is greater than\n-     *                <code>b.length - off</code>\n-     * @exception IOException if the first byte cannot be read for any reason\n-     *                other than end of file, the stream has been closed and the underlying\n-     *                input stream does not support reading after close, or another I/O\n-     *                error occurs. Additionally it will occur when the timeout happens.\n-     * @see java.io.DataInputStream#read\n+     * @param timeoutMSecs the timeout period in milliseconds.\n+     * @return the next SLIP message if there is one on the queue, or any empty byte[] array if not.\n+     * @throws IOException\n      */\n-    public synchronized int read(byte b[], int off, int len, int timeoutMSecs) throws IOException {\n-        // Definition of Method which encapsulates the Read of data\n-        Callable<Integer> readTask = new Callable<Integer>() {\n-            @Override\n-            public Integer call() throws IOException {\n-                return in.read(b, off, len);\n+    public byte[] readSlipMessage(int timeoutMSecs) throws IOException {\n+        startPolling();\n+        int i = (timeoutMSecs / SLEEP_INTERVAL_MSECS) + 1;\n+        while (i-- >= 0) {\n+            try {\n+                byte[] slip = slipMessageQueue.remove();\n+                logger.trace(\"readSlipMessage() => return slip message\");\n+                return slip;\n+            } catch (NoSuchElementException e) {\n+                // queue empty, wait and continue\n             }\n-        };\n-        try {\n-            Future<Integer> future = executor.submit(readTask);\n-            return future.get(timeoutMSecs, TimeUnit.MILLISECONDS);\n-        } catch (RejectedExecutionException e) {\n-            throw new IOException(\"executor failed\", e);\n-        } catch (ExecutionException e) {\n-            throw new IOException(\"execution failed\", e);\n-        } catch (InterruptedException e) {\n-            throw new IOException(\"read interrupted\", e);\n-        } catch (TimeoutException e) {\n-            throw new IOException(\"read timeout\", e);\n+            try {\n+                Thread.sleep(SLEEP_INTERVAL_MSECS);\n+            } catch (InterruptedException e) {\n+                logger.debug(\"readSlipMessage() => thread interrupt\");\n+                throw new IOException(\"Thread Interrupted\");\n+            }\n+            throwIfPollException();\n+        }\n+        logger.debug(\"readSlipMessage() => no slip message after {}mS => time out\", timeoutMSecs);\n+        return new byte[0];\n+    }\n+\n+    /**\n+     * Get the number of incoming messages in the queue\n+     *\n+     * @return the number of incoming messages in the queue\n+     */\n+    public int available() {\n+        int size = slipMessageQueue.size();\n+        logger.trace(\"available() => slip message count {}\", size);\n+        return size;\n+    }\n+\n+    /**\n+     * Clear the queue\n+     */\n+    public void flush() {\n+        logger.trace(\"flush() called\");\n+        slipMessageQueue.clear();\n+    }\n+\n+    /**\n+     * If necessary start the polling thread\n+     */\n+    private void startPolling() {\n+        Thread pollThreadX = this.pollThread;\n+        if (pollThreadX != null) {\n+            logger.trace(\"startPolling()\");\n+            pollThreadX = pollThread = new Thread(pollRunner);\n+            pollThreadX.setDaemon(true);\n+            pollThreadX.setName(OH_BINDING_VELUX_BRIDGE);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU4MzY0NQ=="}, "originalCommit": {"oid": "e58c50a9777538ffe7de0fb104220df902c237b3"}, "originalPosition": 275}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTE5NDAwMA==", "bodyText": "The cause of the read timeouts must be something different, as threads have the same priority as the thread which created them. See https://docs.oracle.com/javase/7/docs/api/java/lang/Thread.html second paragraph. Priority has nothing wether it's a daemon or not. The link you posted doesn't state anything contrary. It's only said that they are low-priority threads, but that's only a general statement.\nDoes the shutdown work if you disable the Thing in the UI?", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r531194000", "createdAt": "2020-11-26T19:09:08Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/bridge/slip/io/DataInputStreamWithTimeout.java", "diffHunk": "@@ -12,124 +12,199 @@\n  */\n package org.openhab.binding.velux.internal.bridge.slip.io;\n \n-import java.io.DataInputStream;\n+import java.io.Closeable;\n import java.io.IOException;\n import java.io.InputStream;\n-import java.util.concurrent.Callable;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.Future;\n-import java.util.concurrent.RejectedExecutionException;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.TimeoutException;\n+import java.net.SocketTimeoutException;\n+import java.util.Arrays;\n+import java.util.NoSuchElementException;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n /**\n- * This is an extension of {@link java.io.DataInputStream}, which adds timeouts to receive operation.\n- * <P>\n- * A data input stream lets an application read primitive Java data\n- * types from an underlying input stream in a machine-independent\n- * way. An application uses a data output stream to write data that\n- * can later be read by a data input stream.\n- * <p>\n- * For an in-depth discussion, see:\n- * https://stackoverflow.com/questions/804951/is-it-possible-to-read-from-a-inputstream-with-a-timeout\n+ * This is an wrapper around {@link java.io.InputStream} to support socket receive operations.\n+ *\n+ * It implements a secondary polling thread to asynchronously read bytes from the socket input stream into a buffer. And\n+ * it parses the bytes into SLIP messages, which are placed on a message queue. Callers can access the SLIP messages in\n+ * this queue independently from the polling thread.\n  *\n  * @author Guenther Schreiner - Initial contribution.\n+ * @author Andrew Fiddian-Green - Complete rewrite using asynchronous polling thread.\n  */\n @NonNullByDefault\n-class DataInputStreamWithTimeout extends DataInputStream {\n+class DataInputStreamWithTimeout implements Closeable {\n \n-    /*\n-     * ***************************\n-     * ***** Private Objects *****\n-     */\n+    private static final String OH_BINDING_VELUX_BRIDGE = \"OH-binding-velux-bridge\";\n+\n+    private static final int QUEUE_SIZE = 512;\n+    private static final int BUFFER_SIZE = 512;\n+    private static final int SLEEP_INTERVAL_MSECS = 50;\n+\n+    // special character that marks the first and last byte of a slip message\n+    private static final byte SLIP_MARK = (byte) 0xc0;\n+\n+    private final Logger logger = LoggerFactory.getLogger(DataInputStreamWithTimeout.class);\n+\n+    private final Queue<byte[]> slipMessageQueue = new ConcurrentLinkedQueue<>();\n+\n+    private InputStream inputStream;\n+\n+    private String pollException = \"\";\n+    private @Nullable Thread pollThread = null;\n \n     /**\n-     * Executor for asynchronous read command\n+     * A runnable that loops to read bytes from {@link InputStream} and builds SLIP packets from them. The respective\n+     * SLIP packets are placed in a {@link ConcurrentLinkedQueue}.\n      */\n-    ExecutorService executor = Executors.newFixedThreadPool(2);\n+    private Runnable pollRunner = () -> {\n+        byte byt;\n+        byte[] buf = new byte[BUFFER_SIZE];\n+        int i = 0;\n+        pollException = \"\";\n+        slipMessageQueue.clear();\n+        while (!Thread.interrupted()) {\n+            try {\n+                buf[i] = byt = (byte) inputStream.read();\n+                if (byt == SLIP_MARK) {\n+                    if (i > 0) {\n+                        // the minimal slip message is 7 bytes [MM PP LL CC CC KK MM]\n+                        if ((i > 5) && (buf[0] == SLIP_MARK)) {\n+                            slipMessageQueue.offer(Arrays.copyOfRange(buf, 0, i + 1));\n+                            if (slipMessageQueue.size() > QUEUE_SIZE) {\n+                                logger.warn(\"pollRunner() => slip message queue overflow => PLEASE REPORT !!\");\n+                                slipMessageQueue.poll();\n+                            }\n+                        }\n+                        i = 0;\n+                        buf[0] = SLIP_MARK;\n+                        continue;\n+                    }\n+                }\n+                if (++i >= BUFFER_SIZE) {\n+                    i = 0;\n+                }\n+            } catch (SocketTimeoutException e) {\n+                // socket read time outs are OK => just keep on polling\n+                continue;\n+            } catch (IOException e) {\n+                // any other exception => stop polling\n+                pollException = e.getMessage();\n+                logger.debug(\"pollRunner() stopping '{}'\", pollException);\n+                break;\n+            }\n+        }\n+        pollThread = null;\n+    };\n \n     /**\n-     * Creates a DataInputStreamWithTimeout that uses the specified\n-     * underlying DataInputStream.\n+     * Check if there was an exception on the polling loop thread and if so, throw it back on the caller thread.\n      *\n-     * @param in the specified input stream\n+     * @throws IOException\n      */\n-    public DataInputStreamWithTimeout(InputStream in) {\n-        super(in);\n+    private void throwIfPollException() throws IOException {\n+        if (!pollException.isEmpty()) {\n+            logger.debug(\"passPollException() polling loop exception {}\", pollException);\n+            throw new IOException(pollException);\n+        }\n     }\n \n     /**\n-     * Reads up to <code>len</code> bytes of data from the contained\n-     * input stream into an array of bytes. An attempt is made to read\n-     * as many as <code>len</code> bytes, but a smaller number may be read,\n-     * possibly zero. The number of bytes actually read is returned as an\n-     * integer.\n+     * Creates a {@link DataInputStreamWithTimeout} as a wrapper around the specified underlying DataInputStream.\n      *\n-     * <p>\n-     * This method blocks until input data is available, end of file is\n-     * detected, or an exception is thrown <B>until</B> the given timeout.\n-     *\n-     * <p>\n-     * If <code>len</code> is zero, then no bytes are read and\n-     * <code>0</code> is returned; otherwise, there is an attempt to read at\n-     * least one byte. If no byte is available because the stream is at end of\n-     * file, the value <code>-1</code> is returned; otherwise, at least one\n-     * byte is read and stored into <code>b</code>.\n-     *\n-     * <p>\n-     * The first byte read is stored into element <code>b[off]</code>, the\n-     * next one into <code>b[off+1]</code>, and so on. The number of bytes read\n-     * is, at most, equal to <code>len</code>. Let <i>k</i> be the number of\n-     * bytes actually read; these bytes will be stored in elements\n-     * <code>b[off]</code> through <code>b[off+</code><i>k</i><code>-1]</code>,\n-     * leaving elements <code>b[off+</code><i>k</i><code>]</code> through\n-     * <code>b[off+len-1]</code> unaffected.\n+     * @param stream the specified input stream\n+     */\n+    public DataInputStreamWithTimeout(InputStream stream) {\n+        inputStream = stream;\n+    }\n+\n+    /**\n+     * Overridden method of {@link Closeable} interface. Stops the polling thread.\n      *\n-     * <p>\n-     * In every case, elements <code>b[0]</code> through\n-     * <code>b[off]</code> and elements <code>b[off+len]</code> through\n-     * <code>b[b.length-1]</code> are unaffected.\n+     * @throws IOException\n+     */\n+    @Override\n+    public void close() throws IOException {\n+        stopPolling();\n+    }\n+\n+    /**\n+     * Reads and removes the next available SLIP message from the queue. If the queue is empty, continue polling\n+     * until either a message is found, or the timeout expires.\n      *\n-     * @param b the buffer into which the data is read.\n-     * @param off the start offset in the destination array <code>b</code>\n-     * @param len the maximum number of bytes read.\n-     * @param timeoutMSecs the maximum duration of this read before throwing a TimeoutException.\n-     * @return the total number of bytes read into the buffer, or\n-     *         <code>-1</code> if there is no more data because the end\n-     *         of the stream has been reached.\n-     * @exception NullPointerException If <code>b</code> is <code>null</code>.\n-     * @exception IndexOutOfBoundsException If <code>off</code> is negative,\n-     *                <code>len</code> is negative, or <code>len</code> is greater than\n-     *                <code>b.length - off</code>\n-     * @exception IOException if the first byte cannot be read for any reason\n-     *                other than end of file, the stream has been closed and the underlying\n-     *                input stream does not support reading after close, or another I/O\n-     *                error occurs. Additionally it will occur when the timeout happens.\n-     * @see java.io.DataInputStream#read\n+     * @param timeoutMSecs the timeout period in milliseconds.\n+     * @return the next SLIP message if there is one on the queue, or any empty byte[] array if not.\n+     * @throws IOException\n      */\n-    public synchronized int read(byte b[], int off, int len, int timeoutMSecs) throws IOException {\n-        // Definition of Method which encapsulates the Read of data\n-        Callable<Integer> readTask = new Callable<Integer>() {\n-            @Override\n-            public Integer call() throws IOException {\n-                return in.read(b, off, len);\n+    public byte[] readSlipMessage(int timeoutMSecs) throws IOException {\n+        startPolling();\n+        int i = (timeoutMSecs / SLEEP_INTERVAL_MSECS) + 1;\n+        while (i-- >= 0) {\n+            try {\n+                byte[] slip = slipMessageQueue.remove();\n+                logger.trace(\"readSlipMessage() => return slip message\");\n+                return slip;\n+            } catch (NoSuchElementException e) {\n+                // queue empty, wait and continue\n             }\n-        };\n-        try {\n-            Future<Integer> future = executor.submit(readTask);\n-            return future.get(timeoutMSecs, TimeUnit.MILLISECONDS);\n-        } catch (RejectedExecutionException e) {\n-            throw new IOException(\"executor failed\", e);\n-        } catch (ExecutionException e) {\n-            throw new IOException(\"execution failed\", e);\n-        } catch (InterruptedException e) {\n-            throw new IOException(\"read interrupted\", e);\n-        } catch (TimeoutException e) {\n-            throw new IOException(\"read timeout\", e);\n+            try {\n+                Thread.sleep(SLEEP_INTERVAL_MSECS);\n+            } catch (InterruptedException e) {\n+                logger.debug(\"readSlipMessage() => thread interrupt\");\n+                throw new IOException(\"Thread Interrupted\");\n+            }\n+            throwIfPollException();\n+        }\n+        logger.debug(\"readSlipMessage() => no slip message after {}mS => time out\", timeoutMSecs);\n+        return new byte[0];\n+    }\n+\n+    /**\n+     * Get the number of incoming messages in the queue\n+     *\n+     * @return the number of incoming messages in the queue\n+     */\n+    public int available() {\n+        int size = slipMessageQueue.size();\n+        logger.trace(\"available() => slip message count {}\", size);\n+        return size;\n+    }\n+\n+    /**\n+     * Clear the queue\n+     */\n+    public void flush() {\n+        logger.trace(\"flush() called\");\n+        slipMessageQueue.clear();\n+    }\n+\n+    /**\n+     * If necessary start the polling thread\n+     */\n+    private void startPolling() {\n+        Thread pollThreadX = this.pollThread;\n+        if (pollThreadX != null) {\n+            logger.trace(\"startPolling()\");\n+            pollThreadX = pollThread = new Thread(pollRunner);\n+            pollThreadX.setDaemon(true);\n+            pollThreadX.setName(OH_BINDING_VELUX_BRIDGE);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU4MzY0NQ=="}, "originalCommit": {"oid": "e58c50a9777538ffe7de0fb104220df902c237b3"}, "originalPosition": 275}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTIzNTMzMw==", "bodyText": "Yeah, it is probably the daemon bypassing of the polling thread's proper shutdown code.\nThe Velux KLF Bridge is very sensitive to being improperly shutdown. To do it properly, one must read all input notifications from its send buffer (i.e. clear the binding's data input stream), and then properly close the socket with a two way FIN/ACK. If one does not do that, then the KLF will go into a \"zombie\" state where it thinks it still has a socket open, but the binding has gone away. And the only way to eliminate the zombie state is to physically power cycle the unit. (Velux controls roof windows, and users do not appreciate having to crawl about in their attics to do that).\nNow I have implemented all the socket communications as Closeable so that when one tries to shut down the binding, it will force all the sockets and streams to be properly finalized. Part of the orderly shutdown on the socket connection is the Close() action on the DataInputStream polling thread, to clear the Bridge's send buffer. And this works just fine if the DataInputStream polling thread is a user thread. However I suspect that if the DataInputStream polling thread is made into a daemon, then the binding unloading process kills the thread before the binding shutdown code's Close() gets called, and therefore it specifically leaves unread data on the the Bridge's send buffer, and therefore explicitly causes the KLF bridge to go into a zombie state. Requiring manual power cycling.\nThis can happen every time that the binding jar is un/re-reloaded and every time that OH is stopped/started. This is not good.", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r531235333", "createdAt": "2020-11-26T21:57:52Z", "author": {"login": "andrewfg"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/bridge/slip/io/DataInputStreamWithTimeout.java", "diffHunk": "@@ -12,124 +12,199 @@\n  */\n package org.openhab.binding.velux.internal.bridge.slip.io;\n \n-import java.io.DataInputStream;\n+import java.io.Closeable;\n import java.io.IOException;\n import java.io.InputStream;\n-import java.util.concurrent.Callable;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.Future;\n-import java.util.concurrent.RejectedExecutionException;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.TimeoutException;\n+import java.net.SocketTimeoutException;\n+import java.util.Arrays;\n+import java.util.NoSuchElementException;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n /**\n- * This is an extension of {@link java.io.DataInputStream}, which adds timeouts to receive operation.\n- * <P>\n- * A data input stream lets an application read primitive Java data\n- * types from an underlying input stream in a machine-independent\n- * way. An application uses a data output stream to write data that\n- * can later be read by a data input stream.\n- * <p>\n- * For an in-depth discussion, see:\n- * https://stackoverflow.com/questions/804951/is-it-possible-to-read-from-a-inputstream-with-a-timeout\n+ * This is an wrapper around {@link java.io.InputStream} to support socket receive operations.\n+ *\n+ * It implements a secondary polling thread to asynchronously read bytes from the socket input stream into a buffer. And\n+ * it parses the bytes into SLIP messages, which are placed on a message queue. Callers can access the SLIP messages in\n+ * this queue independently from the polling thread.\n  *\n  * @author Guenther Schreiner - Initial contribution.\n+ * @author Andrew Fiddian-Green - Complete rewrite using asynchronous polling thread.\n  */\n @NonNullByDefault\n-class DataInputStreamWithTimeout extends DataInputStream {\n+class DataInputStreamWithTimeout implements Closeable {\n \n-    /*\n-     * ***************************\n-     * ***** Private Objects *****\n-     */\n+    private static final String OH_BINDING_VELUX_BRIDGE = \"OH-binding-velux-bridge\";\n+\n+    private static final int QUEUE_SIZE = 512;\n+    private static final int BUFFER_SIZE = 512;\n+    private static final int SLEEP_INTERVAL_MSECS = 50;\n+\n+    // special character that marks the first and last byte of a slip message\n+    private static final byte SLIP_MARK = (byte) 0xc0;\n+\n+    private final Logger logger = LoggerFactory.getLogger(DataInputStreamWithTimeout.class);\n+\n+    private final Queue<byte[]> slipMessageQueue = new ConcurrentLinkedQueue<>();\n+\n+    private InputStream inputStream;\n+\n+    private String pollException = \"\";\n+    private @Nullable Thread pollThread = null;\n \n     /**\n-     * Executor for asynchronous read command\n+     * A runnable that loops to read bytes from {@link InputStream} and builds SLIP packets from them. The respective\n+     * SLIP packets are placed in a {@link ConcurrentLinkedQueue}.\n      */\n-    ExecutorService executor = Executors.newFixedThreadPool(2);\n+    private Runnable pollRunner = () -> {\n+        byte byt;\n+        byte[] buf = new byte[BUFFER_SIZE];\n+        int i = 0;\n+        pollException = \"\";\n+        slipMessageQueue.clear();\n+        while (!Thread.interrupted()) {\n+            try {\n+                buf[i] = byt = (byte) inputStream.read();\n+                if (byt == SLIP_MARK) {\n+                    if (i > 0) {\n+                        // the minimal slip message is 7 bytes [MM PP LL CC CC KK MM]\n+                        if ((i > 5) && (buf[0] == SLIP_MARK)) {\n+                            slipMessageQueue.offer(Arrays.copyOfRange(buf, 0, i + 1));\n+                            if (slipMessageQueue.size() > QUEUE_SIZE) {\n+                                logger.warn(\"pollRunner() => slip message queue overflow => PLEASE REPORT !!\");\n+                                slipMessageQueue.poll();\n+                            }\n+                        }\n+                        i = 0;\n+                        buf[0] = SLIP_MARK;\n+                        continue;\n+                    }\n+                }\n+                if (++i >= BUFFER_SIZE) {\n+                    i = 0;\n+                }\n+            } catch (SocketTimeoutException e) {\n+                // socket read time outs are OK => just keep on polling\n+                continue;\n+            } catch (IOException e) {\n+                // any other exception => stop polling\n+                pollException = e.getMessage();\n+                logger.debug(\"pollRunner() stopping '{}'\", pollException);\n+                break;\n+            }\n+        }\n+        pollThread = null;\n+    };\n \n     /**\n-     * Creates a DataInputStreamWithTimeout that uses the specified\n-     * underlying DataInputStream.\n+     * Check if there was an exception on the polling loop thread and if so, throw it back on the caller thread.\n      *\n-     * @param in the specified input stream\n+     * @throws IOException\n      */\n-    public DataInputStreamWithTimeout(InputStream in) {\n-        super(in);\n+    private void throwIfPollException() throws IOException {\n+        if (!pollException.isEmpty()) {\n+            logger.debug(\"passPollException() polling loop exception {}\", pollException);\n+            throw new IOException(pollException);\n+        }\n     }\n \n     /**\n-     * Reads up to <code>len</code> bytes of data from the contained\n-     * input stream into an array of bytes. An attempt is made to read\n-     * as many as <code>len</code> bytes, but a smaller number may be read,\n-     * possibly zero. The number of bytes actually read is returned as an\n-     * integer.\n+     * Creates a {@link DataInputStreamWithTimeout} as a wrapper around the specified underlying DataInputStream.\n      *\n-     * <p>\n-     * This method blocks until input data is available, end of file is\n-     * detected, or an exception is thrown <B>until</B> the given timeout.\n-     *\n-     * <p>\n-     * If <code>len</code> is zero, then no bytes are read and\n-     * <code>0</code> is returned; otherwise, there is an attempt to read at\n-     * least one byte. If no byte is available because the stream is at end of\n-     * file, the value <code>-1</code> is returned; otherwise, at least one\n-     * byte is read and stored into <code>b</code>.\n-     *\n-     * <p>\n-     * The first byte read is stored into element <code>b[off]</code>, the\n-     * next one into <code>b[off+1]</code>, and so on. The number of bytes read\n-     * is, at most, equal to <code>len</code>. Let <i>k</i> be the number of\n-     * bytes actually read; these bytes will be stored in elements\n-     * <code>b[off]</code> through <code>b[off+</code><i>k</i><code>-1]</code>,\n-     * leaving elements <code>b[off+</code><i>k</i><code>]</code> through\n-     * <code>b[off+len-1]</code> unaffected.\n+     * @param stream the specified input stream\n+     */\n+    public DataInputStreamWithTimeout(InputStream stream) {\n+        inputStream = stream;\n+    }\n+\n+    /**\n+     * Overridden method of {@link Closeable} interface. Stops the polling thread.\n      *\n-     * <p>\n-     * In every case, elements <code>b[0]</code> through\n-     * <code>b[off]</code> and elements <code>b[off+len]</code> through\n-     * <code>b[b.length-1]</code> are unaffected.\n+     * @throws IOException\n+     */\n+    @Override\n+    public void close() throws IOException {\n+        stopPolling();\n+    }\n+\n+    /**\n+     * Reads and removes the next available SLIP message from the queue. If the queue is empty, continue polling\n+     * until either a message is found, or the timeout expires.\n      *\n-     * @param b the buffer into which the data is read.\n-     * @param off the start offset in the destination array <code>b</code>\n-     * @param len the maximum number of bytes read.\n-     * @param timeoutMSecs the maximum duration of this read before throwing a TimeoutException.\n-     * @return the total number of bytes read into the buffer, or\n-     *         <code>-1</code> if there is no more data because the end\n-     *         of the stream has been reached.\n-     * @exception NullPointerException If <code>b</code> is <code>null</code>.\n-     * @exception IndexOutOfBoundsException If <code>off</code> is negative,\n-     *                <code>len</code> is negative, or <code>len</code> is greater than\n-     *                <code>b.length - off</code>\n-     * @exception IOException if the first byte cannot be read for any reason\n-     *                other than end of file, the stream has been closed and the underlying\n-     *                input stream does not support reading after close, or another I/O\n-     *                error occurs. Additionally it will occur when the timeout happens.\n-     * @see java.io.DataInputStream#read\n+     * @param timeoutMSecs the timeout period in milliseconds.\n+     * @return the next SLIP message if there is one on the queue, or any empty byte[] array if not.\n+     * @throws IOException\n      */\n-    public synchronized int read(byte b[], int off, int len, int timeoutMSecs) throws IOException {\n-        // Definition of Method which encapsulates the Read of data\n-        Callable<Integer> readTask = new Callable<Integer>() {\n-            @Override\n-            public Integer call() throws IOException {\n-                return in.read(b, off, len);\n+    public byte[] readSlipMessage(int timeoutMSecs) throws IOException {\n+        startPolling();\n+        int i = (timeoutMSecs / SLEEP_INTERVAL_MSECS) + 1;\n+        while (i-- >= 0) {\n+            try {\n+                byte[] slip = slipMessageQueue.remove();\n+                logger.trace(\"readSlipMessage() => return slip message\");\n+                return slip;\n+            } catch (NoSuchElementException e) {\n+                // queue empty, wait and continue\n             }\n-        };\n-        try {\n-            Future<Integer> future = executor.submit(readTask);\n-            return future.get(timeoutMSecs, TimeUnit.MILLISECONDS);\n-        } catch (RejectedExecutionException e) {\n-            throw new IOException(\"executor failed\", e);\n-        } catch (ExecutionException e) {\n-            throw new IOException(\"execution failed\", e);\n-        } catch (InterruptedException e) {\n-            throw new IOException(\"read interrupted\", e);\n-        } catch (TimeoutException e) {\n-            throw new IOException(\"read timeout\", e);\n+            try {\n+                Thread.sleep(SLEEP_INTERVAL_MSECS);\n+            } catch (InterruptedException e) {\n+                logger.debug(\"readSlipMessage() => thread interrupt\");\n+                throw new IOException(\"Thread Interrupted\");\n+            }\n+            throwIfPollException();\n+        }\n+        logger.debug(\"readSlipMessage() => no slip message after {}mS => time out\", timeoutMSecs);\n+        return new byte[0];\n+    }\n+\n+    /**\n+     * Get the number of incoming messages in the queue\n+     *\n+     * @return the number of incoming messages in the queue\n+     */\n+    public int available() {\n+        int size = slipMessageQueue.size();\n+        logger.trace(\"available() => slip message count {}\", size);\n+        return size;\n+    }\n+\n+    /**\n+     * Clear the queue\n+     */\n+    public void flush() {\n+        logger.trace(\"flush() called\");\n+        slipMessageQueue.clear();\n+    }\n+\n+    /**\n+     * If necessary start the polling thread\n+     */\n+    private void startPolling() {\n+        Thread pollThreadX = this.pollThread;\n+        if (pollThreadX != null) {\n+            logger.trace(\"startPolling()\");\n+            pollThreadX = pollThread = new Thread(pollRunner);\n+            pollThreadX.setDaemon(true);\n+            pollThreadX.setName(OH_BINDING_VELUX_BRIDGE);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU4MzY0NQ=="}, "originalCommit": {"oid": "e58c50a9777538ffe7de0fb104220df902c237b3"}, "originalPosition": 275}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTIzNjk5OA==", "bodyText": "If the KLF bridge is sensitive to improper shutdown then I think that use of a non-daemon thread is acceptable.", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r531236998", "createdAt": "2020-11-26T22:05:40Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/bridge/slip/io/DataInputStreamWithTimeout.java", "diffHunk": "@@ -12,124 +12,199 @@\n  */\n package org.openhab.binding.velux.internal.bridge.slip.io;\n \n-import java.io.DataInputStream;\n+import java.io.Closeable;\n import java.io.IOException;\n import java.io.InputStream;\n-import java.util.concurrent.Callable;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.Future;\n-import java.util.concurrent.RejectedExecutionException;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.TimeoutException;\n+import java.net.SocketTimeoutException;\n+import java.util.Arrays;\n+import java.util.NoSuchElementException;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n /**\n- * This is an extension of {@link java.io.DataInputStream}, which adds timeouts to receive operation.\n- * <P>\n- * A data input stream lets an application read primitive Java data\n- * types from an underlying input stream in a machine-independent\n- * way. An application uses a data output stream to write data that\n- * can later be read by a data input stream.\n- * <p>\n- * For an in-depth discussion, see:\n- * https://stackoverflow.com/questions/804951/is-it-possible-to-read-from-a-inputstream-with-a-timeout\n+ * This is an wrapper around {@link java.io.InputStream} to support socket receive operations.\n+ *\n+ * It implements a secondary polling thread to asynchronously read bytes from the socket input stream into a buffer. And\n+ * it parses the bytes into SLIP messages, which are placed on a message queue. Callers can access the SLIP messages in\n+ * this queue independently from the polling thread.\n  *\n  * @author Guenther Schreiner - Initial contribution.\n+ * @author Andrew Fiddian-Green - Complete rewrite using asynchronous polling thread.\n  */\n @NonNullByDefault\n-class DataInputStreamWithTimeout extends DataInputStream {\n+class DataInputStreamWithTimeout implements Closeable {\n \n-    /*\n-     * ***************************\n-     * ***** Private Objects *****\n-     */\n+    private static final String OH_BINDING_VELUX_BRIDGE = \"OH-binding-velux-bridge\";\n+\n+    private static final int QUEUE_SIZE = 512;\n+    private static final int BUFFER_SIZE = 512;\n+    private static final int SLEEP_INTERVAL_MSECS = 50;\n+\n+    // special character that marks the first and last byte of a slip message\n+    private static final byte SLIP_MARK = (byte) 0xc0;\n+\n+    private final Logger logger = LoggerFactory.getLogger(DataInputStreamWithTimeout.class);\n+\n+    private final Queue<byte[]> slipMessageQueue = new ConcurrentLinkedQueue<>();\n+\n+    private InputStream inputStream;\n+\n+    private String pollException = \"\";\n+    private @Nullable Thread pollThread = null;\n \n     /**\n-     * Executor for asynchronous read command\n+     * A runnable that loops to read bytes from {@link InputStream} and builds SLIP packets from them. The respective\n+     * SLIP packets are placed in a {@link ConcurrentLinkedQueue}.\n      */\n-    ExecutorService executor = Executors.newFixedThreadPool(2);\n+    private Runnable pollRunner = () -> {\n+        byte byt;\n+        byte[] buf = new byte[BUFFER_SIZE];\n+        int i = 0;\n+        pollException = \"\";\n+        slipMessageQueue.clear();\n+        while (!Thread.interrupted()) {\n+            try {\n+                buf[i] = byt = (byte) inputStream.read();\n+                if (byt == SLIP_MARK) {\n+                    if (i > 0) {\n+                        // the minimal slip message is 7 bytes [MM PP LL CC CC KK MM]\n+                        if ((i > 5) && (buf[0] == SLIP_MARK)) {\n+                            slipMessageQueue.offer(Arrays.copyOfRange(buf, 0, i + 1));\n+                            if (slipMessageQueue.size() > QUEUE_SIZE) {\n+                                logger.warn(\"pollRunner() => slip message queue overflow => PLEASE REPORT !!\");\n+                                slipMessageQueue.poll();\n+                            }\n+                        }\n+                        i = 0;\n+                        buf[0] = SLIP_MARK;\n+                        continue;\n+                    }\n+                }\n+                if (++i >= BUFFER_SIZE) {\n+                    i = 0;\n+                }\n+            } catch (SocketTimeoutException e) {\n+                // socket read time outs are OK => just keep on polling\n+                continue;\n+            } catch (IOException e) {\n+                // any other exception => stop polling\n+                pollException = e.getMessage();\n+                logger.debug(\"pollRunner() stopping '{}'\", pollException);\n+                break;\n+            }\n+        }\n+        pollThread = null;\n+    };\n \n     /**\n-     * Creates a DataInputStreamWithTimeout that uses the specified\n-     * underlying DataInputStream.\n+     * Check if there was an exception on the polling loop thread and if so, throw it back on the caller thread.\n      *\n-     * @param in the specified input stream\n+     * @throws IOException\n      */\n-    public DataInputStreamWithTimeout(InputStream in) {\n-        super(in);\n+    private void throwIfPollException() throws IOException {\n+        if (!pollException.isEmpty()) {\n+            logger.debug(\"passPollException() polling loop exception {}\", pollException);\n+            throw new IOException(pollException);\n+        }\n     }\n \n     /**\n-     * Reads up to <code>len</code> bytes of data from the contained\n-     * input stream into an array of bytes. An attempt is made to read\n-     * as many as <code>len</code> bytes, but a smaller number may be read,\n-     * possibly zero. The number of bytes actually read is returned as an\n-     * integer.\n+     * Creates a {@link DataInputStreamWithTimeout} as a wrapper around the specified underlying DataInputStream.\n      *\n-     * <p>\n-     * This method blocks until input data is available, end of file is\n-     * detected, or an exception is thrown <B>until</B> the given timeout.\n-     *\n-     * <p>\n-     * If <code>len</code> is zero, then no bytes are read and\n-     * <code>0</code> is returned; otherwise, there is an attempt to read at\n-     * least one byte. If no byte is available because the stream is at end of\n-     * file, the value <code>-1</code> is returned; otherwise, at least one\n-     * byte is read and stored into <code>b</code>.\n-     *\n-     * <p>\n-     * The first byte read is stored into element <code>b[off]</code>, the\n-     * next one into <code>b[off+1]</code>, and so on. The number of bytes read\n-     * is, at most, equal to <code>len</code>. Let <i>k</i> be the number of\n-     * bytes actually read; these bytes will be stored in elements\n-     * <code>b[off]</code> through <code>b[off+</code><i>k</i><code>-1]</code>,\n-     * leaving elements <code>b[off+</code><i>k</i><code>]</code> through\n-     * <code>b[off+len-1]</code> unaffected.\n+     * @param stream the specified input stream\n+     */\n+    public DataInputStreamWithTimeout(InputStream stream) {\n+        inputStream = stream;\n+    }\n+\n+    /**\n+     * Overridden method of {@link Closeable} interface. Stops the polling thread.\n      *\n-     * <p>\n-     * In every case, elements <code>b[0]</code> through\n-     * <code>b[off]</code> and elements <code>b[off+len]</code> through\n-     * <code>b[b.length-1]</code> are unaffected.\n+     * @throws IOException\n+     */\n+    @Override\n+    public void close() throws IOException {\n+        stopPolling();\n+    }\n+\n+    /**\n+     * Reads and removes the next available SLIP message from the queue. If the queue is empty, continue polling\n+     * until either a message is found, or the timeout expires.\n      *\n-     * @param b the buffer into which the data is read.\n-     * @param off the start offset in the destination array <code>b</code>\n-     * @param len the maximum number of bytes read.\n-     * @param timeoutMSecs the maximum duration of this read before throwing a TimeoutException.\n-     * @return the total number of bytes read into the buffer, or\n-     *         <code>-1</code> if there is no more data because the end\n-     *         of the stream has been reached.\n-     * @exception NullPointerException If <code>b</code> is <code>null</code>.\n-     * @exception IndexOutOfBoundsException If <code>off</code> is negative,\n-     *                <code>len</code> is negative, or <code>len</code> is greater than\n-     *                <code>b.length - off</code>\n-     * @exception IOException if the first byte cannot be read for any reason\n-     *                other than end of file, the stream has been closed and the underlying\n-     *                input stream does not support reading after close, or another I/O\n-     *                error occurs. Additionally it will occur when the timeout happens.\n-     * @see java.io.DataInputStream#read\n+     * @param timeoutMSecs the timeout period in milliseconds.\n+     * @return the next SLIP message if there is one on the queue, or any empty byte[] array if not.\n+     * @throws IOException\n      */\n-    public synchronized int read(byte b[], int off, int len, int timeoutMSecs) throws IOException {\n-        // Definition of Method which encapsulates the Read of data\n-        Callable<Integer> readTask = new Callable<Integer>() {\n-            @Override\n-            public Integer call() throws IOException {\n-                return in.read(b, off, len);\n+    public byte[] readSlipMessage(int timeoutMSecs) throws IOException {\n+        startPolling();\n+        int i = (timeoutMSecs / SLEEP_INTERVAL_MSECS) + 1;\n+        while (i-- >= 0) {\n+            try {\n+                byte[] slip = slipMessageQueue.remove();\n+                logger.trace(\"readSlipMessage() => return slip message\");\n+                return slip;\n+            } catch (NoSuchElementException e) {\n+                // queue empty, wait and continue\n             }\n-        };\n-        try {\n-            Future<Integer> future = executor.submit(readTask);\n-            return future.get(timeoutMSecs, TimeUnit.MILLISECONDS);\n-        } catch (RejectedExecutionException e) {\n-            throw new IOException(\"executor failed\", e);\n-        } catch (ExecutionException e) {\n-            throw new IOException(\"execution failed\", e);\n-        } catch (InterruptedException e) {\n-            throw new IOException(\"read interrupted\", e);\n-        } catch (TimeoutException e) {\n-            throw new IOException(\"read timeout\", e);\n+            try {\n+                Thread.sleep(SLEEP_INTERVAL_MSECS);\n+            } catch (InterruptedException e) {\n+                logger.debug(\"readSlipMessage() => thread interrupt\");\n+                throw new IOException(\"Thread Interrupted\");\n+            }\n+            throwIfPollException();\n+        }\n+        logger.debug(\"readSlipMessage() => no slip message after {}mS => time out\", timeoutMSecs);\n+        return new byte[0];\n+    }\n+\n+    /**\n+     * Get the number of incoming messages in the queue\n+     *\n+     * @return the number of incoming messages in the queue\n+     */\n+    public int available() {\n+        int size = slipMessageQueue.size();\n+        logger.trace(\"available() => slip message count {}\", size);\n+        return size;\n+    }\n+\n+    /**\n+     * Clear the queue\n+     */\n+    public void flush() {\n+        logger.trace(\"flush() called\");\n+        slipMessageQueue.clear();\n+    }\n+\n+    /**\n+     * If necessary start the polling thread\n+     */\n+    private void startPolling() {\n+        Thread pollThreadX = this.pollThread;\n+        if (pollThreadX != null) {\n+            logger.trace(\"startPolling()\");\n+            pollThreadX = pollThread = new Thread(pollRunner);\n+            pollThreadX.setDaemon(true);\n+            pollThreadX.setName(OH_BINDING_VELUX_BRIDGE);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU4MzY0NQ=="}, "originalCommit": {"oid": "e58c50a9777538ffe7de0fb104220df902c237b3"}, "originalPosition": 275}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTQxMjU1Mg==", "bodyText": "OK", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r531412552", "createdAt": "2020-11-27T06:56:04Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/bridge/slip/io/DataInputStreamWithTimeout.java", "diffHunk": "@@ -12,124 +12,199 @@\n  */\n package org.openhab.binding.velux.internal.bridge.slip.io;\n \n-import java.io.DataInputStream;\n+import java.io.Closeable;\n import java.io.IOException;\n import java.io.InputStream;\n-import java.util.concurrent.Callable;\n-import java.util.concurrent.ExecutionException;\n-import java.util.concurrent.ExecutorService;\n-import java.util.concurrent.Executors;\n-import java.util.concurrent.Future;\n-import java.util.concurrent.RejectedExecutionException;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.TimeoutException;\n+import java.net.SocketTimeoutException;\n+import java.util.Arrays;\n+import java.util.NoSuchElementException;\n+import java.util.Queue;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n /**\n- * This is an extension of {@link java.io.DataInputStream}, which adds timeouts to receive operation.\n- * <P>\n- * A data input stream lets an application read primitive Java data\n- * types from an underlying input stream in a machine-independent\n- * way. An application uses a data output stream to write data that\n- * can later be read by a data input stream.\n- * <p>\n- * For an in-depth discussion, see:\n- * https://stackoverflow.com/questions/804951/is-it-possible-to-read-from-a-inputstream-with-a-timeout\n+ * This is an wrapper around {@link java.io.InputStream} to support socket receive operations.\n+ *\n+ * It implements a secondary polling thread to asynchronously read bytes from the socket input stream into a buffer. And\n+ * it parses the bytes into SLIP messages, which are placed on a message queue. Callers can access the SLIP messages in\n+ * this queue independently from the polling thread.\n  *\n  * @author Guenther Schreiner - Initial contribution.\n+ * @author Andrew Fiddian-Green - Complete rewrite using asynchronous polling thread.\n  */\n @NonNullByDefault\n-class DataInputStreamWithTimeout extends DataInputStream {\n+class DataInputStreamWithTimeout implements Closeable {\n \n-    /*\n-     * ***************************\n-     * ***** Private Objects *****\n-     */\n+    private static final String OH_BINDING_VELUX_BRIDGE = \"OH-binding-velux-bridge\";\n+\n+    private static final int QUEUE_SIZE = 512;\n+    private static final int BUFFER_SIZE = 512;\n+    private static final int SLEEP_INTERVAL_MSECS = 50;\n+\n+    // special character that marks the first and last byte of a slip message\n+    private static final byte SLIP_MARK = (byte) 0xc0;\n+\n+    private final Logger logger = LoggerFactory.getLogger(DataInputStreamWithTimeout.class);\n+\n+    private final Queue<byte[]> slipMessageQueue = new ConcurrentLinkedQueue<>();\n+\n+    private InputStream inputStream;\n+\n+    private String pollException = \"\";\n+    private @Nullable Thread pollThread = null;\n \n     /**\n-     * Executor for asynchronous read command\n+     * A runnable that loops to read bytes from {@link InputStream} and builds SLIP packets from them. The respective\n+     * SLIP packets are placed in a {@link ConcurrentLinkedQueue}.\n      */\n-    ExecutorService executor = Executors.newFixedThreadPool(2);\n+    private Runnable pollRunner = () -> {\n+        byte byt;\n+        byte[] buf = new byte[BUFFER_SIZE];\n+        int i = 0;\n+        pollException = \"\";\n+        slipMessageQueue.clear();\n+        while (!Thread.interrupted()) {\n+            try {\n+                buf[i] = byt = (byte) inputStream.read();\n+                if (byt == SLIP_MARK) {\n+                    if (i > 0) {\n+                        // the minimal slip message is 7 bytes [MM PP LL CC CC KK MM]\n+                        if ((i > 5) && (buf[0] == SLIP_MARK)) {\n+                            slipMessageQueue.offer(Arrays.copyOfRange(buf, 0, i + 1));\n+                            if (slipMessageQueue.size() > QUEUE_SIZE) {\n+                                logger.warn(\"pollRunner() => slip message queue overflow => PLEASE REPORT !!\");\n+                                slipMessageQueue.poll();\n+                            }\n+                        }\n+                        i = 0;\n+                        buf[0] = SLIP_MARK;\n+                        continue;\n+                    }\n+                }\n+                if (++i >= BUFFER_SIZE) {\n+                    i = 0;\n+                }\n+            } catch (SocketTimeoutException e) {\n+                // socket read time outs are OK => just keep on polling\n+                continue;\n+            } catch (IOException e) {\n+                // any other exception => stop polling\n+                pollException = e.getMessage();\n+                logger.debug(\"pollRunner() stopping '{}'\", pollException);\n+                break;\n+            }\n+        }\n+        pollThread = null;\n+    };\n \n     /**\n-     * Creates a DataInputStreamWithTimeout that uses the specified\n-     * underlying DataInputStream.\n+     * Check if there was an exception on the polling loop thread and if so, throw it back on the caller thread.\n      *\n-     * @param in the specified input stream\n+     * @throws IOException\n      */\n-    public DataInputStreamWithTimeout(InputStream in) {\n-        super(in);\n+    private void throwIfPollException() throws IOException {\n+        if (!pollException.isEmpty()) {\n+            logger.debug(\"passPollException() polling loop exception {}\", pollException);\n+            throw new IOException(pollException);\n+        }\n     }\n \n     /**\n-     * Reads up to <code>len</code> bytes of data from the contained\n-     * input stream into an array of bytes. An attempt is made to read\n-     * as many as <code>len</code> bytes, but a smaller number may be read,\n-     * possibly zero. The number of bytes actually read is returned as an\n-     * integer.\n+     * Creates a {@link DataInputStreamWithTimeout} as a wrapper around the specified underlying DataInputStream.\n      *\n-     * <p>\n-     * This method blocks until input data is available, end of file is\n-     * detected, or an exception is thrown <B>until</B> the given timeout.\n-     *\n-     * <p>\n-     * If <code>len</code> is zero, then no bytes are read and\n-     * <code>0</code> is returned; otherwise, there is an attempt to read at\n-     * least one byte. If no byte is available because the stream is at end of\n-     * file, the value <code>-1</code> is returned; otherwise, at least one\n-     * byte is read and stored into <code>b</code>.\n-     *\n-     * <p>\n-     * The first byte read is stored into element <code>b[off]</code>, the\n-     * next one into <code>b[off+1]</code>, and so on. The number of bytes read\n-     * is, at most, equal to <code>len</code>. Let <i>k</i> be the number of\n-     * bytes actually read; these bytes will be stored in elements\n-     * <code>b[off]</code> through <code>b[off+</code><i>k</i><code>-1]</code>,\n-     * leaving elements <code>b[off+</code><i>k</i><code>]</code> through\n-     * <code>b[off+len-1]</code> unaffected.\n+     * @param stream the specified input stream\n+     */\n+    public DataInputStreamWithTimeout(InputStream stream) {\n+        inputStream = stream;\n+    }\n+\n+    /**\n+     * Overridden method of {@link Closeable} interface. Stops the polling thread.\n      *\n-     * <p>\n-     * In every case, elements <code>b[0]</code> through\n-     * <code>b[off]</code> and elements <code>b[off+len]</code> through\n-     * <code>b[b.length-1]</code> are unaffected.\n+     * @throws IOException\n+     */\n+    @Override\n+    public void close() throws IOException {\n+        stopPolling();\n+    }\n+\n+    /**\n+     * Reads and removes the next available SLIP message from the queue. If the queue is empty, continue polling\n+     * until either a message is found, or the timeout expires.\n      *\n-     * @param b the buffer into which the data is read.\n-     * @param off the start offset in the destination array <code>b</code>\n-     * @param len the maximum number of bytes read.\n-     * @param timeoutMSecs the maximum duration of this read before throwing a TimeoutException.\n-     * @return the total number of bytes read into the buffer, or\n-     *         <code>-1</code> if there is no more data because the end\n-     *         of the stream has been reached.\n-     * @exception NullPointerException If <code>b</code> is <code>null</code>.\n-     * @exception IndexOutOfBoundsException If <code>off</code> is negative,\n-     *                <code>len</code> is negative, or <code>len</code> is greater than\n-     *                <code>b.length - off</code>\n-     * @exception IOException if the first byte cannot be read for any reason\n-     *                other than end of file, the stream has been closed and the underlying\n-     *                input stream does not support reading after close, or another I/O\n-     *                error occurs. Additionally it will occur when the timeout happens.\n-     * @see java.io.DataInputStream#read\n+     * @param timeoutMSecs the timeout period in milliseconds.\n+     * @return the next SLIP message if there is one on the queue, or any empty byte[] array if not.\n+     * @throws IOException\n      */\n-    public synchronized int read(byte b[], int off, int len, int timeoutMSecs) throws IOException {\n-        // Definition of Method which encapsulates the Read of data\n-        Callable<Integer> readTask = new Callable<Integer>() {\n-            @Override\n-            public Integer call() throws IOException {\n-                return in.read(b, off, len);\n+    public byte[] readSlipMessage(int timeoutMSecs) throws IOException {\n+        startPolling();\n+        int i = (timeoutMSecs / SLEEP_INTERVAL_MSECS) + 1;\n+        while (i-- >= 0) {\n+            try {\n+                byte[] slip = slipMessageQueue.remove();\n+                logger.trace(\"readSlipMessage() => return slip message\");\n+                return slip;\n+            } catch (NoSuchElementException e) {\n+                // queue empty, wait and continue\n             }\n-        };\n-        try {\n-            Future<Integer> future = executor.submit(readTask);\n-            return future.get(timeoutMSecs, TimeUnit.MILLISECONDS);\n-        } catch (RejectedExecutionException e) {\n-            throw new IOException(\"executor failed\", e);\n-        } catch (ExecutionException e) {\n-            throw new IOException(\"execution failed\", e);\n-        } catch (InterruptedException e) {\n-            throw new IOException(\"read interrupted\", e);\n-        } catch (TimeoutException e) {\n-            throw new IOException(\"read timeout\", e);\n+            try {\n+                Thread.sleep(SLEEP_INTERVAL_MSECS);\n+            } catch (InterruptedException e) {\n+                logger.debug(\"readSlipMessage() => thread interrupt\");\n+                throw new IOException(\"Thread Interrupted\");\n+            }\n+            throwIfPollException();\n+        }\n+        logger.debug(\"readSlipMessage() => no slip message after {}mS => time out\", timeoutMSecs);\n+        return new byte[0];\n+    }\n+\n+    /**\n+     * Get the number of incoming messages in the queue\n+     *\n+     * @return the number of incoming messages in the queue\n+     */\n+    public int available() {\n+        int size = slipMessageQueue.size();\n+        logger.trace(\"available() => slip message count {}\", size);\n+        return size;\n+    }\n+\n+    /**\n+     * Clear the queue\n+     */\n+    public void flush() {\n+        logger.trace(\"flush() called\");\n+        slipMessageQueue.clear();\n+    }\n+\n+    /**\n+     * If necessary start the polling thread\n+     */\n+    private void startPolling() {\n+        Thread pollThreadX = this.pollThread;\n+        if (pollThreadX != null) {\n+            logger.trace(\"startPolling()\");\n+            pollThreadX = pollThread = new Thread(pollRunner);\n+            pollThreadX.setDaemon(true);\n+            pollThreadX.setName(OH_BINDING_VELUX_BRIDGE);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU4MzY0NQ=="}, "originalCommit": {"oid": "e58c50a9777538ffe7de0fb104220df902c237b3"}, "originalPosition": 275}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyODIwODM4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/bridge/slip/SlipVeluxBridge.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQyMTo1MDoyM1rOH6E5HA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxMzozMzowMFrOH6bncg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY1OTYxMg==", "bodyText": "You don't need to set looping if you are just going to break out of the loop anyway. There are a lot of other places you are doing this too.", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r530659612", "createdAt": "2020-11-25T21:50:23Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/bridge/slip/SlipVeluxBridge.java", "diffHunk": "@@ -181,214 +182,244 @@ public long lastSuccessfulCommunication() {\n     }\n \n     /**\n-     * Initializes a client/server communication towards <b>Velux</b> veluxBridge\n-     * based on the Basic I/O interface {@link Connection#io} and parameters\n-     * passed as arguments (see below).\n+     * Initializes a client/server communication towards the Velux Bridge based on the Basic I/O interface\n+     * {@link Connection#io} and parameters passed as arguments (see below).\n      *\n-     * @param communication Structure of interface type {@link SlipBridgeCommunicationProtocol} describing the\n+     * @param communication a structure of interface type {@link SlipBridgeCommunicationProtocol} describing the\n      *            intended communication, that is request and response interactions as well as appropriate URL\n      *            definition.\n-     * @param useAuthentication boolean flag to decide whether to use authenticated communication.\n-     * @return <b>success</b> of type boolean which signals the success of the communication.\n+     * @param useAuthentication a boolean flag to select whether to use authenticated communication.\n+     * @return a boolean which in general signals the success of the communication, but in the\n+     *         special case of receive-only calls, signals if any products were updated during the call\n      */\n     private synchronized boolean bridgeDirectCommunicate(SlipBridgeCommunicationProtocol communication,\n             boolean useAuthentication) {\n-        String host = this.bridgeInstance.veluxBridgeConfiguration().ipAddress;\n-        logger.trace(\"bridgeDirectCommunicate({},{}authenticated) on {} called.\", host, communication.name(),\n+        logger.trace(\"bridgeDirectCommunicate() '{}', {}authenticated\", communication.name(),\n                 useAuthentication ? \"\" : \"un\");\n \n-        assert this.bridgeInstance.veluxBridgeConfiguration().protocol.contentEquals(\"slip\");\n-\n-        long communicationStartInMSecs = System.currentTimeMillis();\n+        // store common parameters as constants for frequent use\n+        final short txCmd = communication.getRequestCommand().toShort();\n+        final byte[] txData = communication.getRequestDataAsArrayOfBytes();\n+        final Command txEnum = Command.get(txCmd);\n+        final String txName = txEnum.toString();\n+        final boolean isSequentialEnforced = this.bridgeInstance.veluxBridgeConfiguration().isSequentialEnforced;\n+        final boolean isProtocolTraceEnabled = this.bridgeInstance.veluxBridgeConfiguration().isProtocolTraceEnabled;\n+        final long expiryTime = System.currentTimeMillis() + COMMUNICATION_TIMEOUT_MSECS;\n \n-        boolean isSequentialEnforced = this.bridgeInstance.veluxBridgeConfiguration().isSequentialEnforced;\n-        boolean isProtocolTraceEnabled = this.bridgeInstance.veluxBridgeConfiguration().isProtocolTraceEnabled;\n+        // logger format string\n+        final String loggerFmt = String.format(\"bridgeDirectCommunicate() [%s] %s => {} {} {}\",\n+                this.bridgeInstance.veluxBridgeConfiguration().ipAddress, txName);\n \n-        // From parameters\n-        short command = communication.getRequestCommand().toShort();\n-        byte[] data = communication.getRequestDataAsArrayOfBytes();\n-        // For further use at different logging statements\n-        String commandString = Command.get(command).toString();\n+        assert this.bridgeInstance.veluxBridgeConfiguration().protocol.contentEquals(\"slip\");\n \n         if (isProtocolTraceEnabled) {\n             Threads.findDeadlocked();\n         }\n \n-        logger.debug(\"bridgeDirectCommunicate({},{}authenticated) on {} initiated by {}.\", host, commandString,\n-                useAuthentication ? \"\" : \"un\", Thread.currentThread());\n-        boolean success = false;\n+        logger.debug(loggerFmt, \"started =>\", Thread.currentThread(), \"\");\n \n-        communication: do {\n-            if (communicationStartInMSecs + COMMUNICATION_TIMEOUT_MSECS < System.currentTimeMillis()) {\n-                logger.warn(\n-                        \"{} bridgeDirectCommunicate({}) on {}: communication handshake failed (unexpected sequence of requests/responses).\",\n-                        VeluxBindingConstants.BINDING_VALUES_SEPARATOR, communication.name(), host);\n-                break;\n-            }\n+        boolean looping = false;\n+        boolean success = false;\n+        boolean sending = false;\n+        boolean rcvonly = false;\n+        byte[] txPacket = emptyPacket;\n \n-            // Special handling\n-            if (Command.get(command) == Command.GW_OPENHAB_CLOSE) {\n-                logger.trace(\"bridgeDirectCommunicate(): special command: shutting down connection.\");\n+        // handling of the requests\n+        switch (txEnum) {\n+            case GW_OPENHAB_CLOSE:\n+                logger.trace(loggerFmt, \"shut down command\", \"=> executing\", \"\");\n                 connection.resetConnection();\n                 success = true;\n-                continue;\n-            }\n+                break;\n \n-            // Normal processing\n-            logger.trace(\"bridgeDirectCommunicate() on {}: working on request {} with {} bytes of data.\", host,\n-                    commandString, data.length);\n-            byte[] sendBytes = emptyPacket;\n-            if (Command.get(command) == Command.GW_OPENHAB_RECEIVEONLY) {\n-                logger.trace(\n-                        \"bridgeDirectCommunicate() on {}: special command: determine whether there is any message waiting.\",\n-                        host);\n-                logger.trace(\"bridgeDirectCommunicate(): check for a waiting message.\");\n-                if (!connection.isMessageAvailable()) {\n-                    logger.trace(\"bridgeDirectCommunicate() on {}: no message waiting, aborting.\", host);\n-                    break communication;\n+            case GW_OPENHAB_RECEIVEONLY:\n+                logger.trace(loggerFmt, \"receive-only mode\", \"=> checking messages\", \"\");\n+                if (!connection.isAlive()) {\n+                    logger.trace(loggerFmt, \"no connection\", \"=> opening\", \"\");\n+                    looping = true;\n+                } else if (connection.isMessageAvailable()) {\n+                    logger.trace(loggerFmt, \"message(s) waiting\", \"=> start reading\", \"\");\n+                    looping = true;\n+                } else {\n+                    logger.trace(loggerFmt, \"no waiting messages\", \"=> done\", \"\");\n                 }\n-                logger.trace(\"bridgeDirectCommunicate() on {}: there is a message waiting.\", host);\n-            } else {\n-                SlipEncoding t = new SlipEncoding(command, data);\n-                if (!t.isValid()) {\n-                    logger.warn(\"bridgeDirectCommunicate() on {}: SlipEncoding() failed, aborting.\", host);\n+                rcvonly = true;\n+                break;\n+\n+            default:\n+                logger.trace(loggerFmt, \"send mode\", \"=> preparing command\", \"\");\n+                SlipEncoding slipEnc = new SlipEncoding(txCmd, txData);\n+                if (!slipEnc.isValid()) {\n+                    logger.debug(loggerFmt, \"slip encoding error\", \"=> aborting\", \"\");\n                     break;\n                 }\n-                logger.trace(\"bridgeDirectCommunicate() on {}: transportEncoding={}.\", host, t.toString());\n-                sendBytes = new SlipRFC1055().encode(t.toMessage());\n+                txPacket = new SlipRFC1055().encode(slipEnc.toMessage());\n+                logger.trace(loggerFmt, \"command ready\", \"=> start sending\", \"\");\n+                looping = sending = true;\n+        }\n+\n+        while (looping) {\n+            // timeout\n+            if (System.currentTimeMillis() > expiryTime) {\n+                logger.warn(loggerFmt, \"process loop time out\", \"=> aborting\", \"=> PLEASE REPORT !!\");\n+                looping = false;\n+                break;\n             }\n-            do {\n-                if (communicationStartInMSecs + COMMUNICATION_TIMEOUT_MSECS < System.currentTimeMillis()) {\n-                    logger.warn(\"bridgeDirectCommunicate() on {}: receive takes too long. Please report to maintainer.\",\n-                            host);\n-                    break communication;\n-                }\n-                byte[] receivedPacket;\n-                try {\n-                    if (sendBytes.length > 0) {\n-                        logger.trace(\"bridgeDirectCommunicate() on {}: sending {} bytes.\", host, sendBytes.length);\n-                        if (isProtocolTraceEnabled) {\n-                            logger.info(\"Sending command {}.\", commandString);\n-                        }\n+\n+            // send command (optionally), and receive response\n+            byte[] rxPacket;\n+            try {\n+                if (sending) {\n+                    if (isProtocolTraceEnabled) {\n+                        logger.info(\"sending command {}\", txName);\n+                    }\n+                    if (logger.isTraceEnabled()) {\n+                        logger.trace(loggerFmt, txName, \"=> sending data =>\", new Packet(txData));\n                     } else {\n-                        logger.trace(\"bridgeDirectCommunicate() on {}: initiating receive-only.\", host);\n+                        logger.debug(loggerFmt, txName, \"=> sending data length =>\", txData.length);\n                     }\n-                    // (Optionally) Send and receive packet.\n-                    receivedPacket = connection.io(this.bridgeInstance, sendBytes);\n-                    // Once being sent, it should never be sent again\n-                    sendBytes = emptyPacket;\n-                } catch (Exception e) {\n-                    logger.warn(\"bridgeDirectCommunicate() on {}: connection.io returns {}\", host, e.getMessage());\n-                    break communication;\n-                }\n-                logger.trace(\"bridgeDirectCommunicate() on {}: received packet {}.\", host,\n-                        new Packet(receivedPacket).toString());\n-                byte[] response;\n-                try {\n-                    response = new SlipRFC1055().decode(receivedPacket);\n-                } catch (ParseException e) {\n-                    logger.warn(\"bridgeDirectCommunicate() on {}: method SlipRFC1055() raised a decoding error: {}.\",\n-                            host, e.getMessage());\n-                    break communication;\n                 }\n-                SlipEncoding tr = new SlipEncoding(response);\n-                if (!tr.isValid()) {\n-                    logger.warn(\"bridgeDirectCommunicate() on {}: method SlipEncoding() raised a decoding error.\",\n-                            host);\n-                    break communication;\n-                }\n-                short responseCommand = tr.getCommand();\n-                byte[] responseData = tr.getData();\n-                logger.debug(\"bridgeDirectCommunicate() on {}: working on response {} with {} bytes of data.\", host,\n-                        Command.get(responseCommand).toString(), responseData.length);\n-                if (isProtocolTraceEnabled) {\n-                    logger.info(\"Received answer {}.\", Command.get(responseCommand).toString());\n+                rxPacket = connection.io(this.bridgeInstance, sending ? txPacket : emptyPacket);\n+                // message sent, don't send it again\n+                sending = false;\n+                if (rxPacket.length == 0) {\n+                    // only log in send mode (in receive-only mode, no response is ok)\n+                    if (!rcvonly) {\n+                        logger.debug(loggerFmt, \"no response\", \"=> aborting\", \"\");\n+                    }\n+                    looping = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e58c50a9777538ffe7de0fb104220df902c237b3"}, "originalPosition": 258}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTAxMjI5Mw==", "bodyText": "Yes, that is indeed correct. This bridgeDirectCommunicate() method is THE most critical piece of code in the whole binding, with many different flow control paths that depend on multiple different hardware situations. The previous version of the code was very non transparent; with multiple loop control expressions; two layers of looping; multiple break and continue statements within the inner and outer loops plus multiply embedded switch statements at different levels; and even using labelled break statements. It was IMHO (with apologies to Guenther) a mess. So I totally rewrote this method to flatten it and make it better self documenting. And I spent about a month extensively testing it with 5 different users to ensure that it works. I am willing in those cases where looping = false; break; does indeed break the main outer loop to delete that line, (but I will probably replace it with a comment line instead), but I am not willing to fundamentally mess with the flow control logic once more.", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r531012293", "createdAt": "2020-11-26T12:58:50Z", "author": {"login": "andrewfg"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/bridge/slip/SlipVeluxBridge.java", "diffHunk": "@@ -181,214 +182,244 @@ public long lastSuccessfulCommunication() {\n     }\n \n     /**\n-     * Initializes a client/server communication towards <b>Velux</b> veluxBridge\n-     * based on the Basic I/O interface {@link Connection#io} and parameters\n-     * passed as arguments (see below).\n+     * Initializes a client/server communication towards the Velux Bridge based on the Basic I/O interface\n+     * {@link Connection#io} and parameters passed as arguments (see below).\n      *\n-     * @param communication Structure of interface type {@link SlipBridgeCommunicationProtocol} describing the\n+     * @param communication a structure of interface type {@link SlipBridgeCommunicationProtocol} describing the\n      *            intended communication, that is request and response interactions as well as appropriate URL\n      *            definition.\n-     * @param useAuthentication boolean flag to decide whether to use authenticated communication.\n-     * @return <b>success</b> of type boolean which signals the success of the communication.\n+     * @param useAuthentication a boolean flag to select whether to use authenticated communication.\n+     * @return a boolean which in general signals the success of the communication, but in the\n+     *         special case of receive-only calls, signals if any products were updated during the call\n      */\n     private synchronized boolean bridgeDirectCommunicate(SlipBridgeCommunicationProtocol communication,\n             boolean useAuthentication) {\n-        String host = this.bridgeInstance.veluxBridgeConfiguration().ipAddress;\n-        logger.trace(\"bridgeDirectCommunicate({},{}authenticated) on {} called.\", host, communication.name(),\n+        logger.trace(\"bridgeDirectCommunicate() '{}', {}authenticated\", communication.name(),\n                 useAuthentication ? \"\" : \"un\");\n \n-        assert this.bridgeInstance.veluxBridgeConfiguration().protocol.contentEquals(\"slip\");\n-\n-        long communicationStartInMSecs = System.currentTimeMillis();\n+        // store common parameters as constants for frequent use\n+        final short txCmd = communication.getRequestCommand().toShort();\n+        final byte[] txData = communication.getRequestDataAsArrayOfBytes();\n+        final Command txEnum = Command.get(txCmd);\n+        final String txName = txEnum.toString();\n+        final boolean isSequentialEnforced = this.bridgeInstance.veluxBridgeConfiguration().isSequentialEnforced;\n+        final boolean isProtocolTraceEnabled = this.bridgeInstance.veluxBridgeConfiguration().isProtocolTraceEnabled;\n+        final long expiryTime = System.currentTimeMillis() + COMMUNICATION_TIMEOUT_MSECS;\n \n-        boolean isSequentialEnforced = this.bridgeInstance.veluxBridgeConfiguration().isSequentialEnforced;\n-        boolean isProtocolTraceEnabled = this.bridgeInstance.veluxBridgeConfiguration().isProtocolTraceEnabled;\n+        // logger format string\n+        final String loggerFmt = String.format(\"bridgeDirectCommunicate() [%s] %s => {} {} {}\",\n+                this.bridgeInstance.veluxBridgeConfiguration().ipAddress, txName);\n \n-        // From parameters\n-        short command = communication.getRequestCommand().toShort();\n-        byte[] data = communication.getRequestDataAsArrayOfBytes();\n-        // For further use at different logging statements\n-        String commandString = Command.get(command).toString();\n+        assert this.bridgeInstance.veluxBridgeConfiguration().protocol.contentEquals(\"slip\");\n \n         if (isProtocolTraceEnabled) {\n             Threads.findDeadlocked();\n         }\n \n-        logger.debug(\"bridgeDirectCommunicate({},{}authenticated) on {} initiated by {}.\", host, commandString,\n-                useAuthentication ? \"\" : \"un\", Thread.currentThread());\n-        boolean success = false;\n+        logger.debug(loggerFmt, \"started =>\", Thread.currentThread(), \"\");\n \n-        communication: do {\n-            if (communicationStartInMSecs + COMMUNICATION_TIMEOUT_MSECS < System.currentTimeMillis()) {\n-                logger.warn(\n-                        \"{} bridgeDirectCommunicate({}) on {}: communication handshake failed (unexpected sequence of requests/responses).\",\n-                        VeluxBindingConstants.BINDING_VALUES_SEPARATOR, communication.name(), host);\n-                break;\n-            }\n+        boolean looping = false;\n+        boolean success = false;\n+        boolean sending = false;\n+        boolean rcvonly = false;\n+        byte[] txPacket = emptyPacket;\n \n-            // Special handling\n-            if (Command.get(command) == Command.GW_OPENHAB_CLOSE) {\n-                logger.trace(\"bridgeDirectCommunicate(): special command: shutting down connection.\");\n+        // handling of the requests\n+        switch (txEnum) {\n+            case GW_OPENHAB_CLOSE:\n+                logger.trace(loggerFmt, \"shut down command\", \"=> executing\", \"\");\n                 connection.resetConnection();\n                 success = true;\n-                continue;\n-            }\n+                break;\n \n-            // Normal processing\n-            logger.trace(\"bridgeDirectCommunicate() on {}: working on request {} with {} bytes of data.\", host,\n-                    commandString, data.length);\n-            byte[] sendBytes = emptyPacket;\n-            if (Command.get(command) == Command.GW_OPENHAB_RECEIVEONLY) {\n-                logger.trace(\n-                        \"bridgeDirectCommunicate() on {}: special command: determine whether there is any message waiting.\",\n-                        host);\n-                logger.trace(\"bridgeDirectCommunicate(): check for a waiting message.\");\n-                if (!connection.isMessageAvailable()) {\n-                    logger.trace(\"bridgeDirectCommunicate() on {}: no message waiting, aborting.\", host);\n-                    break communication;\n+            case GW_OPENHAB_RECEIVEONLY:\n+                logger.trace(loggerFmt, \"receive-only mode\", \"=> checking messages\", \"\");\n+                if (!connection.isAlive()) {\n+                    logger.trace(loggerFmt, \"no connection\", \"=> opening\", \"\");\n+                    looping = true;\n+                } else if (connection.isMessageAvailable()) {\n+                    logger.trace(loggerFmt, \"message(s) waiting\", \"=> start reading\", \"\");\n+                    looping = true;\n+                } else {\n+                    logger.trace(loggerFmt, \"no waiting messages\", \"=> done\", \"\");\n                 }\n-                logger.trace(\"bridgeDirectCommunicate() on {}: there is a message waiting.\", host);\n-            } else {\n-                SlipEncoding t = new SlipEncoding(command, data);\n-                if (!t.isValid()) {\n-                    logger.warn(\"bridgeDirectCommunicate() on {}: SlipEncoding() failed, aborting.\", host);\n+                rcvonly = true;\n+                break;\n+\n+            default:\n+                logger.trace(loggerFmt, \"send mode\", \"=> preparing command\", \"\");\n+                SlipEncoding slipEnc = new SlipEncoding(txCmd, txData);\n+                if (!slipEnc.isValid()) {\n+                    logger.debug(loggerFmt, \"slip encoding error\", \"=> aborting\", \"\");\n                     break;\n                 }\n-                logger.trace(\"bridgeDirectCommunicate() on {}: transportEncoding={}.\", host, t.toString());\n-                sendBytes = new SlipRFC1055().encode(t.toMessage());\n+                txPacket = new SlipRFC1055().encode(slipEnc.toMessage());\n+                logger.trace(loggerFmt, \"command ready\", \"=> start sending\", \"\");\n+                looping = sending = true;\n+        }\n+\n+        while (looping) {\n+            // timeout\n+            if (System.currentTimeMillis() > expiryTime) {\n+                logger.warn(loggerFmt, \"process loop time out\", \"=> aborting\", \"=> PLEASE REPORT !!\");\n+                looping = false;\n+                break;\n             }\n-            do {\n-                if (communicationStartInMSecs + COMMUNICATION_TIMEOUT_MSECS < System.currentTimeMillis()) {\n-                    logger.warn(\"bridgeDirectCommunicate() on {}: receive takes too long. Please report to maintainer.\",\n-                            host);\n-                    break communication;\n-                }\n-                byte[] receivedPacket;\n-                try {\n-                    if (sendBytes.length > 0) {\n-                        logger.trace(\"bridgeDirectCommunicate() on {}: sending {} bytes.\", host, sendBytes.length);\n-                        if (isProtocolTraceEnabled) {\n-                            logger.info(\"Sending command {}.\", commandString);\n-                        }\n+\n+            // send command (optionally), and receive response\n+            byte[] rxPacket;\n+            try {\n+                if (sending) {\n+                    if (isProtocolTraceEnabled) {\n+                        logger.info(\"sending command {}\", txName);\n+                    }\n+                    if (logger.isTraceEnabled()) {\n+                        logger.trace(loggerFmt, txName, \"=> sending data =>\", new Packet(txData));\n                     } else {\n-                        logger.trace(\"bridgeDirectCommunicate() on {}: initiating receive-only.\", host);\n+                        logger.debug(loggerFmt, txName, \"=> sending data length =>\", txData.length);\n                     }\n-                    // (Optionally) Send and receive packet.\n-                    receivedPacket = connection.io(this.bridgeInstance, sendBytes);\n-                    // Once being sent, it should never be sent again\n-                    sendBytes = emptyPacket;\n-                } catch (Exception e) {\n-                    logger.warn(\"bridgeDirectCommunicate() on {}: connection.io returns {}\", host, e.getMessage());\n-                    break communication;\n-                }\n-                logger.trace(\"bridgeDirectCommunicate() on {}: received packet {}.\", host,\n-                        new Packet(receivedPacket).toString());\n-                byte[] response;\n-                try {\n-                    response = new SlipRFC1055().decode(receivedPacket);\n-                } catch (ParseException e) {\n-                    logger.warn(\"bridgeDirectCommunicate() on {}: method SlipRFC1055() raised a decoding error: {}.\",\n-                            host, e.getMessage());\n-                    break communication;\n                 }\n-                SlipEncoding tr = new SlipEncoding(response);\n-                if (!tr.isValid()) {\n-                    logger.warn(\"bridgeDirectCommunicate() on {}: method SlipEncoding() raised a decoding error.\",\n-                            host);\n-                    break communication;\n-                }\n-                short responseCommand = tr.getCommand();\n-                byte[] responseData = tr.getData();\n-                logger.debug(\"bridgeDirectCommunicate() on {}: working on response {} with {} bytes of data.\", host,\n-                        Command.get(responseCommand).toString(), responseData.length);\n-                if (isProtocolTraceEnabled) {\n-                    logger.info(\"Received answer {}.\", Command.get(responseCommand).toString());\n+                rxPacket = connection.io(this.bridgeInstance, sending ? txPacket : emptyPacket);\n+                // message sent, don't send it again\n+                sending = false;\n+                if (rxPacket.length == 0) {\n+                    // only log in send mode (in receive-only mode, no response is ok)\n+                    if (!rcvonly) {\n+                        logger.debug(loggerFmt, \"no response\", \"=> aborting\", \"\");\n+                    }\n+                    looping = false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY1OTYxMg=="}, "originalCommit": {"oid": "e58c50a9777538ffe7de0fb104220df902c237b3"}, "originalPosition": 258}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTAzMTkyMg==", "bodyText": "It was IMHO (with apologies to Guenther) a mess\n\nCouldn' agree more. This method has grown from minor version to next version to adapt the new features (and obstacles) of the surrending framework activities.", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r531031922", "createdAt": "2020-11-26T13:33:00Z", "author": {"login": "gs4711"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/bridge/slip/SlipVeluxBridge.java", "diffHunk": "@@ -181,214 +182,244 @@ public long lastSuccessfulCommunication() {\n     }\n \n     /**\n-     * Initializes a client/server communication towards <b>Velux</b> veluxBridge\n-     * based on the Basic I/O interface {@link Connection#io} and parameters\n-     * passed as arguments (see below).\n+     * Initializes a client/server communication towards the Velux Bridge based on the Basic I/O interface\n+     * {@link Connection#io} and parameters passed as arguments (see below).\n      *\n-     * @param communication Structure of interface type {@link SlipBridgeCommunicationProtocol} describing the\n+     * @param communication a structure of interface type {@link SlipBridgeCommunicationProtocol} describing the\n      *            intended communication, that is request and response interactions as well as appropriate URL\n      *            definition.\n-     * @param useAuthentication boolean flag to decide whether to use authenticated communication.\n-     * @return <b>success</b> of type boolean which signals the success of the communication.\n+     * @param useAuthentication a boolean flag to select whether to use authenticated communication.\n+     * @return a boolean which in general signals the success of the communication, but in the\n+     *         special case of receive-only calls, signals if any products were updated during the call\n      */\n     private synchronized boolean bridgeDirectCommunicate(SlipBridgeCommunicationProtocol communication,\n             boolean useAuthentication) {\n-        String host = this.bridgeInstance.veluxBridgeConfiguration().ipAddress;\n-        logger.trace(\"bridgeDirectCommunicate({},{}authenticated) on {} called.\", host, communication.name(),\n+        logger.trace(\"bridgeDirectCommunicate() '{}', {}authenticated\", communication.name(),\n                 useAuthentication ? \"\" : \"un\");\n \n-        assert this.bridgeInstance.veluxBridgeConfiguration().protocol.contentEquals(\"slip\");\n-\n-        long communicationStartInMSecs = System.currentTimeMillis();\n+        // store common parameters as constants for frequent use\n+        final short txCmd = communication.getRequestCommand().toShort();\n+        final byte[] txData = communication.getRequestDataAsArrayOfBytes();\n+        final Command txEnum = Command.get(txCmd);\n+        final String txName = txEnum.toString();\n+        final boolean isSequentialEnforced = this.bridgeInstance.veluxBridgeConfiguration().isSequentialEnforced;\n+        final boolean isProtocolTraceEnabled = this.bridgeInstance.veluxBridgeConfiguration().isProtocolTraceEnabled;\n+        final long expiryTime = System.currentTimeMillis() + COMMUNICATION_TIMEOUT_MSECS;\n \n-        boolean isSequentialEnforced = this.bridgeInstance.veluxBridgeConfiguration().isSequentialEnforced;\n-        boolean isProtocolTraceEnabled = this.bridgeInstance.veluxBridgeConfiguration().isProtocolTraceEnabled;\n+        // logger format string\n+        final String loggerFmt = String.format(\"bridgeDirectCommunicate() [%s] %s => {} {} {}\",\n+                this.bridgeInstance.veluxBridgeConfiguration().ipAddress, txName);\n \n-        // From parameters\n-        short command = communication.getRequestCommand().toShort();\n-        byte[] data = communication.getRequestDataAsArrayOfBytes();\n-        // For further use at different logging statements\n-        String commandString = Command.get(command).toString();\n+        assert this.bridgeInstance.veluxBridgeConfiguration().protocol.contentEquals(\"slip\");\n \n         if (isProtocolTraceEnabled) {\n             Threads.findDeadlocked();\n         }\n \n-        logger.debug(\"bridgeDirectCommunicate({},{}authenticated) on {} initiated by {}.\", host, commandString,\n-                useAuthentication ? \"\" : \"un\", Thread.currentThread());\n-        boolean success = false;\n+        logger.debug(loggerFmt, \"started =>\", Thread.currentThread(), \"\");\n \n-        communication: do {\n-            if (communicationStartInMSecs + COMMUNICATION_TIMEOUT_MSECS < System.currentTimeMillis()) {\n-                logger.warn(\n-                        \"{} bridgeDirectCommunicate({}) on {}: communication handshake failed (unexpected sequence of requests/responses).\",\n-                        VeluxBindingConstants.BINDING_VALUES_SEPARATOR, communication.name(), host);\n-                break;\n-            }\n+        boolean looping = false;\n+        boolean success = false;\n+        boolean sending = false;\n+        boolean rcvonly = false;\n+        byte[] txPacket = emptyPacket;\n \n-            // Special handling\n-            if (Command.get(command) == Command.GW_OPENHAB_CLOSE) {\n-                logger.trace(\"bridgeDirectCommunicate(): special command: shutting down connection.\");\n+        // handling of the requests\n+        switch (txEnum) {\n+            case GW_OPENHAB_CLOSE:\n+                logger.trace(loggerFmt, \"shut down command\", \"=> executing\", \"\");\n                 connection.resetConnection();\n                 success = true;\n-                continue;\n-            }\n+                break;\n \n-            // Normal processing\n-            logger.trace(\"bridgeDirectCommunicate() on {}: working on request {} with {} bytes of data.\", host,\n-                    commandString, data.length);\n-            byte[] sendBytes = emptyPacket;\n-            if (Command.get(command) == Command.GW_OPENHAB_RECEIVEONLY) {\n-                logger.trace(\n-                        \"bridgeDirectCommunicate() on {}: special command: determine whether there is any message waiting.\",\n-                        host);\n-                logger.trace(\"bridgeDirectCommunicate(): check for a waiting message.\");\n-                if (!connection.isMessageAvailable()) {\n-                    logger.trace(\"bridgeDirectCommunicate() on {}: no message waiting, aborting.\", host);\n-                    break communication;\n+            case GW_OPENHAB_RECEIVEONLY:\n+                logger.trace(loggerFmt, \"receive-only mode\", \"=> checking messages\", \"\");\n+                if (!connection.isAlive()) {\n+                    logger.trace(loggerFmt, \"no connection\", \"=> opening\", \"\");\n+                    looping = true;\n+                } else if (connection.isMessageAvailable()) {\n+                    logger.trace(loggerFmt, \"message(s) waiting\", \"=> start reading\", \"\");\n+                    looping = true;\n+                } else {\n+                    logger.trace(loggerFmt, \"no waiting messages\", \"=> done\", \"\");\n                 }\n-                logger.trace(\"bridgeDirectCommunicate() on {}: there is a message waiting.\", host);\n-            } else {\n-                SlipEncoding t = new SlipEncoding(command, data);\n-                if (!t.isValid()) {\n-                    logger.warn(\"bridgeDirectCommunicate() on {}: SlipEncoding() failed, aborting.\", host);\n+                rcvonly = true;\n+                break;\n+\n+            default:\n+                logger.trace(loggerFmt, \"send mode\", \"=> preparing command\", \"\");\n+                SlipEncoding slipEnc = new SlipEncoding(txCmd, txData);\n+                if (!slipEnc.isValid()) {\n+                    logger.debug(loggerFmt, \"slip encoding error\", \"=> aborting\", \"\");\n                     break;\n                 }\n-                logger.trace(\"bridgeDirectCommunicate() on {}: transportEncoding={}.\", host, t.toString());\n-                sendBytes = new SlipRFC1055().encode(t.toMessage());\n+                txPacket = new SlipRFC1055().encode(slipEnc.toMessage());\n+                logger.trace(loggerFmt, \"command ready\", \"=> start sending\", \"\");\n+                looping = sending = true;\n+        }\n+\n+        while (looping) {\n+            // timeout\n+            if (System.currentTimeMillis() > expiryTime) {\n+                logger.warn(loggerFmt, \"process loop time out\", \"=> aborting\", \"=> PLEASE REPORT !!\");\n+                looping = false;\n+                break;\n             }\n-            do {\n-                if (communicationStartInMSecs + COMMUNICATION_TIMEOUT_MSECS < System.currentTimeMillis()) {\n-                    logger.warn(\"bridgeDirectCommunicate() on {}: receive takes too long. Please report to maintainer.\",\n-                            host);\n-                    break communication;\n-                }\n-                byte[] receivedPacket;\n-                try {\n-                    if (sendBytes.length > 0) {\n-                        logger.trace(\"bridgeDirectCommunicate() on {}: sending {} bytes.\", host, sendBytes.length);\n-                        if (isProtocolTraceEnabled) {\n-                            logger.info(\"Sending command {}.\", commandString);\n-                        }\n+\n+            // send command (optionally), and receive response\n+            byte[] rxPacket;\n+            try {\n+                if (sending) {\n+                    if (isProtocolTraceEnabled) {\n+                        logger.info(\"sending command {}\", txName);\n+                    }\n+                    if (logger.isTraceEnabled()) {\n+                        logger.trace(loggerFmt, txName, \"=> sending data =>\", new Packet(txData));\n                     } else {\n-                        logger.trace(\"bridgeDirectCommunicate() on {}: initiating receive-only.\", host);\n+                        logger.debug(loggerFmt, txName, \"=> sending data length =>\", txData.length);\n                     }\n-                    // (Optionally) Send and receive packet.\n-                    receivedPacket = connection.io(this.bridgeInstance, sendBytes);\n-                    // Once being sent, it should never be sent again\n-                    sendBytes = emptyPacket;\n-                } catch (Exception e) {\n-                    logger.warn(\"bridgeDirectCommunicate() on {}: connection.io returns {}\", host, e.getMessage());\n-                    break communication;\n-                }\n-                logger.trace(\"bridgeDirectCommunicate() on {}: received packet {}.\", host,\n-                        new Packet(receivedPacket).toString());\n-                byte[] response;\n-                try {\n-                    response = new SlipRFC1055().decode(receivedPacket);\n-                } catch (ParseException e) {\n-                    logger.warn(\"bridgeDirectCommunicate() on {}: method SlipRFC1055() raised a decoding error: {}.\",\n-                            host, e.getMessage());\n-                    break communication;\n                 }\n-                SlipEncoding tr = new SlipEncoding(response);\n-                if (!tr.isValid()) {\n-                    logger.warn(\"bridgeDirectCommunicate() on {}: method SlipEncoding() raised a decoding error.\",\n-                            host);\n-                    break communication;\n-                }\n-                short responseCommand = tr.getCommand();\n-                byte[] responseData = tr.getData();\n-                logger.debug(\"bridgeDirectCommunicate() on {}: working on response {} with {} bytes of data.\", host,\n-                        Command.get(responseCommand).toString(), responseData.length);\n-                if (isProtocolTraceEnabled) {\n-                    logger.info(\"Received answer {}.\", Command.get(responseCommand).toString());\n+                rxPacket = connection.io(this.bridgeInstance, sending ? txPacket : emptyPacket);\n+                // message sent, don't send it again\n+                sending = false;\n+                if (rxPacket.length == 0) {\n+                    // only log in send mode (in receive-only mode, no response is ok)\n+                    if (!rcvonly) {\n+                        logger.debug(loggerFmt, \"no response\", \"=> aborting\", \"\");\n+                    }\n+                    looping = false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY1OTYxMg=="}, "originalCommit": {"oid": "e58c50a9777538ffe7de0fb104220df902c237b3"}, "originalPosition": 258}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyODIxNDY5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/bridge/slip/SlipVeluxBridge.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQyMTo1MzowMlrOH6E88Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxMjo1OTozMFrOH6acTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY2MDU5Mw==", "bodyText": "Please don't use assert. Please throw an exception instead.", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r530660593", "createdAt": "2020-11-25T21:53:02Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/bridge/slip/SlipVeluxBridge.java", "diffHunk": "@@ -181,214 +182,244 @@ public long lastSuccessfulCommunication() {\n     }\n \n     /**\n-     * Initializes a client/server communication towards <b>Velux</b> veluxBridge\n-     * based on the Basic I/O interface {@link Connection#io} and parameters\n-     * passed as arguments (see below).\n+     * Initializes a client/server communication towards the Velux Bridge based on the Basic I/O interface\n+     * {@link Connection#io} and parameters passed as arguments (see below).\n      *\n-     * @param communication Structure of interface type {@link SlipBridgeCommunicationProtocol} describing the\n+     * @param communication a structure of interface type {@link SlipBridgeCommunicationProtocol} describing the\n      *            intended communication, that is request and response interactions as well as appropriate URL\n      *            definition.\n-     * @param useAuthentication boolean flag to decide whether to use authenticated communication.\n-     * @return <b>success</b> of type boolean which signals the success of the communication.\n+     * @param useAuthentication a boolean flag to select whether to use authenticated communication.\n+     * @return a boolean which in general signals the success of the communication, but in the\n+     *         special case of receive-only calls, signals if any products were updated during the call\n      */\n     private synchronized boolean bridgeDirectCommunicate(SlipBridgeCommunicationProtocol communication,\n             boolean useAuthentication) {\n-        String host = this.bridgeInstance.veluxBridgeConfiguration().ipAddress;\n-        logger.trace(\"bridgeDirectCommunicate({},{}authenticated) on {} called.\", host, communication.name(),\n+        logger.trace(\"bridgeDirectCommunicate() '{}', {}authenticated\", communication.name(),\n                 useAuthentication ? \"\" : \"un\");\n \n-        assert this.bridgeInstance.veluxBridgeConfiguration().protocol.contentEquals(\"slip\");\n-\n-        long communicationStartInMSecs = System.currentTimeMillis();\n+        // store common parameters as constants for frequent use\n+        final short txCmd = communication.getRequestCommand().toShort();\n+        final byte[] txData = communication.getRequestDataAsArrayOfBytes();\n+        final Command txEnum = Command.get(txCmd);\n+        final String txName = txEnum.toString();\n+        final boolean isSequentialEnforced = this.bridgeInstance.veluxBridgeConfiguration().isSequentialEnforced;\n+        final boolean isProtocolTraceEnabled = this.bridgeInstance.veluxBridgeConfiguration().isProtocolTraceEnabled;\n+        final long expiryTime = System.currentTimeMillis() + COMMUNICATION_TIMEOUT_MSECS;\n \n-        boolean isSequentialEnforced = this.bridgeInstance.veluxBridgeConfiguration().isSequentialEnforced;\n-        boolean isProtocolTraceEnabled = this.bridgeInstance.veluxBridgeConfiguration().isProtocolTraceEnabled;\n+        // logger format string\n+        final String loggerFmt = String.format(\"bridgeDirectCommunicate() [%s] %s => {} {} {}\",\n+                this.bridgeInstance.veluxBridgeConfiguration().ipAddress, txName);\n \n-        // From parameters\n-        short command = communication.getRequestCommand().toShort();\n-        byte[] data = communication.getRequestDataAsArrayOfBytes();\n-        // For further use at different logging statements\n-        String commandString = Command.get(command).toString();\n+        assert this.bridgeInstance.veluxBridgeConfiguration().protocol.contentEquals(\"slip\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e58c50a9777538ffe7de0fb104220df902c237b3"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTAxMjY4Ng==", "bodyText": "The assert never triggers, so I will just delete that line.", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r531012686", "createdAt": "2020-11-26T12:59:30Z", "author": {"login": "andrewfg"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/bridge/slip/SlipVeluxBridge.java", "diffHunk": "@@ -181,214 +182,244 @@ public long lastSuccessfulCommunication() {\n     }\n \n     /**\n-     * Initializes a client/server communication towards <b>Velux</b> veluxBridge\n-     * based on the Basic I/O interface {@link Connection#io} and parameters\n-     * passed as arguments (see below).\n+     * Initializes a client/server communication towards the Velux Bridge based on the Basic I/O interface\n+     * {@link Connection#io} and parameters passed as arguments (see below).\n      *\n-     * @param communication Structure of interface type {@link SlipBridgeCommunicationProtocol} describing the\n+     * @param communication a structure of interface type {@link SlipBridgeCommunicationProtocol} describing the\n      *            intended communication, that is request and response interactions as well as appropriate URL\n      *            definition.\n-     * @param useAuthentication boolean flag to decide whether to use authenticated communication.\n-     * @return <b>success</b> of type boolean which signals the success of the communication.\n+     * @param useAuthentication a boolean flag to select whether to use authenticated communication.\n+     * @return a boolean which in general signals the success of the communication, but in the\n+     *         special case of receive-only calls, signals if any products were updated during the call\n      */\n     private synchronized boolean bridgeDirectCommunicate(SlipBridgeCommunicationProtocol communication,\n             boolean useAuthentication) {\n-        String host = this.bridgeInstance.veluxBridgeConfiguration().ipAddress;\n-        logger.trace(\"bridgeDirectCommunicate({},{}authenticated) on {} called.\", host, communication.name(),\n+        logger.trace(\"bridgeDirectCommunicate() '{}', {}authenticated\", communication.name(),\n                 useAuthentication ? \"\" : \"un\");\n \n-        assert this.bridgeInstance.veluxBridgeConfiguration().protocol.contentEquals(\"slip\");\n-\n-        long communicationStartInMSecs = System.currentTimeMillis();\n+        // store common parameters as constants for frequent use\n+        final short txCmd = communication.getRequestCommand().toShort();\n+        final byte[] txData = communication.getRequestDataAsArrayOfBytes();\n+        final Command txEnum = Command.get(txCmd);\n+        final String txName = txEnum.toString();\n+        final boolean isSequentialEnforced = this.bridgeInstance.veluxBridgeConfiguration().isSequentialEnforced;\n+        final boolean isProtocolTraceEnabled = this.bridgeInstance.veluxBridgeConfiguration().isProtocolTraceEnabled;\n+        final long expiryTime = System.currentTimeMillis() + COMMUNICATION_TIMEOUT_MSECS;\n \n-        boolean isSequentialEnforced = this.bridgeInstance.veluxBridgeConfiguration().isSequentialEnforced;\n-        boolean isProtocolTraceEnabled = this.bridgeInstance.veluxBridgeConfiguration().isProtocolTraceEnabled;\n+        // logger format string\n+        final String loggerFmt = String.format(\"bridgeDirectCommunicate() [%s] %s => {} {} {}\",\n+                this.bridgeInstance.veluxBridgeConfiguration().ipAddress, txName);\n \n-        // From parameters\n-        short command = communication.getRequestCommand().toShort();\n-        byte[] data = communication.getRequestDataAsArrayOfBytes();\n-        // For further use at different logging statements\n-        String commandString = Command.get(command).toString();\n+        assert this.bridgeInstance.veluxBridgeConfiguration().protocol.contentEquals(\"slip\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY2MDU5Mw=="}, "originalCommit": {"oid": "e58c50a9777538ffe7de0fb104220df902c237b3"}, "originalPosition": 104}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyODIzMDEyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/discovery/VeluxBridgeFinder.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQyMTo1ODoxMlrOH6FFog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxMzozOTo0OVrOH6b29A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY2MjgxOA==", "bodyText": "What's wrong with reading in bulk?", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r530662818", "createdAt": "2020-11-25T21:58:12Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/discovery/VeluxBridgeFinder.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.velux.internal.discovery;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.Closeable;\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.MulticastSocket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashSet;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class that uses Multicast DNS (mDNS) to discover Velux Bridges and return their ipv4 addresses\n+ *\n+ * @author Andrew Fiddian-Green - Initial contribution\n+ */\n+@NonNullByDefault\n+public class VeluxBridgeFinder implements Closeable {\n+\n+    private final Logger logger = LoggerFactory.getLogger(VeluxBridgeFinder.class);\n+\n+    // timing constants\n+    private static final int BUFFER_SIZE = 256;\n+    private static final int SLEEP_MSECS = 100;\n+    private static final int WARMUP_MSECS = 10;\n+    private static final int TIMEOUT_MSECS = 5000;\n+    private static final int REPEAT_COUNT = 3;\n+\n+    // dns communication constants\n+    private static final int MDNS_PORT = 5353;\n+    private static final String MDNS_ADDR = \"224.0.0.251\";\n+\n+    // dns flag constants\n+    private static final short FLAGS_QR = (short) 0x8000;\n+    private static final short FLAGS_AA = 0x0400;\n+\n+    // dns message class constants\n+    private static final short CLASS_IN = 0x0001;\n+    private static final short CLASS_MASK = 0x7FFF;\n+\n+    // dns message type constants\n+    private static final short TYPE_PTR = 0x000c;\n+\n+    private static final byte NULL = 0x00;\n+\n+    // Velux bridge identifiers\n+    private static final String KLF_SERVICE_ID = \"_http._tcp.local\";\n+    private static final String KLF_HOST_PREFIX = \"VELUX_KLF_\";\n+\n+    private short randomQueryId;\n+\n+    private Set<String> ipAddresses = new HashSet<>();\n+\n+    private @Nullable Future<?> listenerTask = null;\n+    private ScheduledExecutorService scheduler;\n+\n+    /**\n+     * A runnable this listens for incoming UDP responses\n+     */\n+    private Runnable listenerRunnable = () -> {\n+        byte[] rcvBytes = new byte[BUFFER_SIZE];\n+\n+        // create a multicast listener socket\n+        try (MulticastSocket rcvSocket = new MulticastSocket(MDNS_PORT)) {\n+            rcvSocket.setReuseAddress(true);\n+            rcvSocket.joinGroup(InetAddress.getByName(MDNS_ADDR));\n+            rcvSocket.setSoTimeout(TIMEOUT_MSECS);\n+\n+            // loop until stopped\n+            while (!Thread.interrupted()) {\n+                // read next packet\n+                DatagramPacket rcvPacket = new DatagramPacket(rcvBytes, rcvBytes.length);\n+                try {\n+                    rcvSocket.receive(rcvPacket);\n+                    if (isKlfLanResponse(rcvPacket.getData())) {\n+                        ipAddresses.add(rcvPacket.getAddress().getHostAddress());\n+                    }\n+                } catch (IOException e) {\n+                    logger.trace(\"listenerRunnable(): mdns packet receive exception '{}'\", e.getMessage());\n+                    continue;\n+                }\n+            }\n+        } catch (IOException e) {\n+            logger.debug(\"listenerRunnable(): udp socket create exception '{}'\", e.getMessage());\n+        }\n+        listenerTask = null;\n+    };\n+\n+    /**\n+     * Build an mDNS query package to query SERVICE_ID looking for host names\n+     *\n+     * @return a byte array containing the query datagram payload, or an empty array if failed\n+     */\n+    private byte[] buildQuery() {\n+        ByteArrayOutputStream byteStream = new ByteArrayOutputStream(BUFFER_SIZE);\n+        DataOutputStream dataStream = new DataOutputStream(byteStream);\n+        try {\n+            dataStream.writeShort(randomQueryId); // id\n+            dataStream.writeShort(0); // flags\n+            dataStream.writeShort(1); // qdCount\n+            dataStream.writeShort(0); // anCount\n+            dataStream.writeShort(0); // nsCount\n+            dataStream.writeShort(0); // arCount\n+            for (String segString : KLF_SERVICE_ID.split(\"\\\\.\")) {\n+                byte[] segBytes = segString.getBytes(StandardCharsets.UTF_8);\n+                dataStream.writeByte(segBytes.length); // length\n+                dataStream.write(segBytes); // byte string\n+            }\n+            dataStream.writeByte(NULL); // end of name\n+            dataStream.writeShort(TYPE_PTR); // type\n+            dataStream.writeShort(CLASS_IN); // class\n+            return byteStream.toByteArray();\n+        } catch (IOException e) {\n+            // fall through\n+        }\n+        return new byte[0];\n+    }\n+\n+    /**\n+     * Parse an mDNS response package and check if it is from a KLF bridge\n+     *\n+     * @param responsePayload a byte array containing the response datagram payload\n+     * @return true if the response is from a KLF bridge\n+     */\n+    private boolean isKlfLanResponse(byte[] responsePayload) {\n+        DataInputStream dataStream = new DataInputStream(new ByteArrayInputStream(responsePayload));\n+        try {\n+            // check if the package id matches the query\n+            short id = dataStream.readShort();\n+            if (id == randomQueryId) {\n+                short flags = dataStream.readShort();\n+                boolean isResponse = (flags & FLAGS_QR) == FLAGS_QR;\n+                boolean isAuthoritative = (flags & FLAGS_AA) == FLAGS_AA;\n+\n+                // check if it is an authoritative response\n+                if (isResponse && isAuthoritative) {\n+                    short qdCount = dataStream.readShort();\n+                    short anCount = dataStream.readShort();\n+\n+                    @SuppressWarnings(\"unused\")\n+                    short nsCount = dataStream.readShort();\n+                    @SuppressWarnings(\"unused\")\n+                    short arCount = dataStream.readShort();\n+\n+                    // check it is an answer (and not a query)\n+                    if ((anCount == 0) || (qdCount != 0)) {\n+                        return false;\n+                    }\n+\n+                    // parse the answers\n+                    for (short an = 0; an < anCount; an++) {\n+                        // parse the name\n+                        byte[] str = new byte[BUFFER_SIZE];\n+                        int i = 0;\n+                        int segLength;\n+                        while ((segLength = dataStream.readByte()) > 0) {\n+                            for (int index = 0; index < segLength; index++) {\n+                                str[i] = dataStream.readByte();\n+                                i++;\n+                            }\n+                            str[i] = '.';\n+                            i++;\n+                        }\n+                        String name = new String(str, 0, i, StandardCharsets.UTF_8);\n+                        short typ = dataStream.readShort();\n+                        short clazz = (short) (CLASS_MASK & dataStream.readShort());\n+                        if (!(name.startsWith(KLF_SERVICE_ID)) || (typ != TYPE_PTR) || (clazz != CLASS_IN)) {\n+                            return false;\n+                        }\n+\n+                        // if we got here, the name and response type are valid\n+                        @SuppressWarnings(\"unused\")\n+                        int ttl = dataStream.readInt();\n+                        @SuppressWarnings(\"unused\")\n+                        short dataLen = dataStream.readShort();\n+\n+                        // parse the host name\n+                        i = 0;\n+                        while ((segLength = dataStream.readByte()) > 0) {\n+                            for (int index = 0; index < segLength; index++) {\n+                                str[i] = dataStream.readByte();\n+                                i++;\n+                            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e58c50a9777538ffe7de0fb104220df902c237b3"}, "originalPosition": 208}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTAxMzI3Ng==", "bodyText": "I guess my counter question is \"what's wrong with reading byte by byte\"? But I will rewrite it to please you..", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r531013276", "createdAt": "2020-11-26T13:00:37Z", "author": {"login": "andrewfg"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/discovery/VeluxBridgeFinder.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.velux.internal.discovery;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.Closeable;\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.MulticastSocket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashSet;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class that uses Multicast DNS (mDNS) to discover Velux Bridges and return their ipv4 addresses\n+ *\n+ * @author Andrew Fiddian-Green - Initial contribution\n+ */\n+@NonNullByDefault\n+public class VeluxBridgeFinder implements Closeable {\n+\n+    private final Logger logger = LoggerFactory.getLogger(VeluxBridgeFinder.class);\n+\n+    // timing constants\n+    private static final int BUFFER_SIZE = 256;\n+    private static final int SLEEP_MSECS = 100;\n+    private static final int WARMUP_MSECS = 10;\n+    private static final int TIMEOUT_MSECS = 5000;\n+    private static final int REPEAT_COUNT = 3;\n+\n+    // dns communication constants\n+    private static final int MDNS_PORT = 5353;\n+    private static final String MDNS_ADDR = \"224.0.0.251\";\n+\n+    // dns flag constants\n+    private static final short FLAGS_QR = (short) 0x8000;\n+    private static final short FLAGS_AA = 0x0400;\n+\n+    // dns message class constants\n+    private static final short CLASS_IN = 0x0001;\n+    private static final short CLASS_MASK = 0x7FFF;\n+\n+    // dns message type constants\n+    private static final short TYPE_PTR = 0x000c;\n+\n+    private static final byte NULL = 0x00;\n+\n+    // Velux bridge identifiers\n+    private static final String KLF_SERVICE_ID = \"_http._tcp.local\";\n+    private static final String KLF_HOST_PREFIX = \"VELUX_KLF_\";\n+\n+    private short randomQueryId;\n+\n+    private Set<String> ipAddresses = new HashSet<>();\n+\n+    private @Nullable Future<?> listenerTask = null;\n+    private ScheduledExecutorService scheduler;\n+\n+    /**\n+     * A runnable this listens for incoming UDP responses\n+     */\n+    private Runnable listenerRunnable = () -> {\n+        byte[] rcvBytes = new byte[BUFFER_SIZE];\n+\n+        // create a multicast listener socket\n+        try (MulticastSocket rcvSocket = new MulticastSocket(MDNS_PORT)) {\n+            rcvSocket.setReuseAddress(true);\n+            rcvSocket.joinGroup(InetAddress.getByName(MDNS_ADDR));\n+            rcvSocket.setSoTimeout(TIMEOUT_MSECS);\n+\n+            // loop until stopped\n+            while (!Thread.interrupted()) {\n+                // read next packet\n+                DatagramPacket rcvPacket = new DatagramPacket(rcvBytes, rcvBytes.length);\n+                try {\n+                    rcvSocket.receive(rcvPacket);\n+                    if (isKlfLanResponse(rcvPacket.getData())) {\n+                        ipAddresses.add(rcvPacket.getAddress().getHostAddress());\n+                    }\n+                } catch (IOException e) {\n+                    logger.trace(\"listenerRunnable(): mdns packet receive exception '{}'\", e.getMessage());\n+                    continue;\n+                }\n+            }\n+        } catch (IOException e) {\n+            logger.debug(\"listenerRunnable(): udp socket create exception '{}'\", e.getMessage());\n+        }\n+        listenerTask = null;\n+    };\n+\n+    /**\n+     * Build an mDNS query package to query SERVICE_ID looking for host names\n+     *\n+     * @return a byte array containing the query datagram payload, or an empty array if failed\n+     */\n+    private byte[] buildQuery() {\n+        ByteArrayOutputStream byteStream = new ByteArrayOutputStream(BUFFER_SIZE);\n+        DataOutputStream dataStream = new DataOutputStream(byteStream);\n+        try {\n+            dataStream.writeShort(randomQueryId); // id\n+            dataStream.writeShort(0); // flags\n+            dataStream.writeShort(1); // qdCount\n+            dataStream.writeShort(0); // anCount\n+            dataStream.writeShort(0); // nsCount\n+            dataStream.writeShort(0); // arCount\n+            for (String segString : KLF_SERVICE_ID.split(\"\\\\.\")) {\n+                byte[] segBytes = segString.getBytes(StandardCharsets.UTF_8);\n+                dataStream.writeByte(segBytes.length); // length\n+                dataStream.write(segBytes); // byte string\n+            }\n+            dataStream.writeByte(NULL); // end of name\n+            dataStream.writeShort(TYPE_PTR); // type\n+            dataStream.writeShort(CLASS_IN); // class\n+            return byteStream.toByteArray();\n+        } catch (IOException e) {\n+            // fall through\n+        }\n+        return new byte[0];\n+    }\n+\n+    /**\n+     * Parse an mDNS response package and check if it is from a KLF bridge\n+     *\n+     * @param responsePayload a byte array containing the response datagram payload\n+     * @return true if the response is from a KLF bridge\n+     */\n+    private boolean isKlfLanResponse(byte[] responsePayload) {\n+        DataInputStream dataStream = new DataInputStream(new ByteArrayInputStream(responsePayload));\n+        try {\n+            // check if the package id matches the query\n+            short id = dataStream.readShort();\n+            if (id == randomQueryId) {\n+                short flags = dataStream.readShort();\n+                boolean isResponse = (flags & FLAGS_QR) == FLAGS_QR;\n+                boolean isAuthoritative = (flags & FLAGS_AA) == FLAGS_AA;\n+\n+                // check if it is an authoritative response\n+                if (isResponse && isAuthoritative) {\n+                    short qdCount = dataStream.readShort();\n+                    short anCount = dataStream.readShort();\n+\n+                    @SuppressWarnings(\"unused\")\n+                    short nsCount = dataStream.readShort();\n+                    @SuppressWarnings(\"unused\")\n+                    short arCount = dataStream.readShort();\n+\n+                    // check it is an answer (and not a query)\n+                    if ((anCount == 0) || (qdCount != 0)) {\n+                        return false;\n+                    }\n+\n+                    // parse the answers\n+                    for (short an = 0; an < anCount; an++) {\n+                        // parse the name\n+                        byte[] str = new byte[BUFFER_SIZE];\n+                        int i = 0;\n+                        int segLength;\n+                        while ((segLength = dataStream.readByte()) > 0) {\n+                            for (int index = 0; index < segLength; index++) {\n+                                str[i] = dataStream.readByte();\n+                                i++;\n+                            }\n+                            str[i] = '.';\n+                            i++;\n+                        }\n+                        String name = new String(str, 0, i, StandardCharsets.UTF_8);\n+                        short typ = dataStream.readShort();\n+                        short clazz = (short) (CLASS_MASK & dataStream.readShort());\n+                        if (!(name.startsWith(KLF_SERVICE_ID)) || (typ != TYPE_PTR) || (clazz != CLASS_IN)) {\n+                            return false;\n+                        }\n+\n+                        // if we got here, the name and response type are valid\n+                        @SuppressWarnings(\"unused\")\n+                        int ttl = dataStream.readInt();\n+                        @SuppressWarnings(\"unused\")\n+                        short dataLen = dataStream.readShort();\n+\n+                        // parse the host name\n+                        i = 0;\n+                        while ((segLength = dataStream.readByte()) > 0) {\n+                            for (int index = 0; index < segLength; index++) {\n+                                str[i] = dataStream.readByte();\n+                                i++;\n+                            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY2MjgxOA=="}, "originalCommit": {"oid": "e58c50a9777538ffe7de0fb104220df902c237b3"}, "originalPosition": 208}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTAzNTg5Mg==", "bodyText": "Bulk reads are more efficient in most cases. Also makes the code more concise and thus better maintainable.", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r531035892", "createdAt": "2020-11-26T13:39:49Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/discovery/VeluxBridgeFinder.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.velux.internal.discovery;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.Closeable;\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.MulticastSocket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashSet;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class that uses Multicast DNS (mDNS) to discover Velux Bridges and return their ipv4 addresses\n+ *\n+ * @author Andrew Fiddian-Green - Initial contribution\n+ */\n+@NonNullByDefault\n+public class VeluxBridgeFinder implements Closeable {\n+\n+    private final Logger logger = LoggerFactory.getLogger(VeluxBridgeFinder.class);\n+\n+    // timing constants\n+    private static final int BUFFER_SIZE = 256;\n+    private static final int SLEEP_MSECS = 100;\n+    private static final int WARMUP_MSECS = 10;\n+    private static final int TIMEOUT_MSECS = 5000;\n+    private static final int REPEAT_COUNT = 3;\n+\n+    // dns communication constants\n+    private static final int MDNS_PORT = 5353;\n+    private static final String MDNS_ADDR = \"224.0.0.251\";\n+\n+    // dns flag constants\n+    private static final short FLAGS_QR = (short) 0x8000;\n+    private static final short FLAGS_AA = 0x0400;\n+\n+    // dns message class constants\n+    private static final short CLASS_IN = 0x0001;\n+    private static final short CLASS_MASK = 0x7FFF;\n+\n+    // dns message type constants\n+    private static final short TYPE_PTR = 0x000c;\n+\n+    private static final byte NULL = 0x00;\n+\n+    // Velux bridge identifiers\n+    private static final String KLF_SERVICE_ID = \"_http._tcp.local\";\n+    private static final String KLF_HOST_PREFIX = \"VELUX_KLF_\";\n+\n+    private short randomQueryId;\n+\n+    private Set<String> ipAddresses = new HashSet<>();\n+\n+    private @Nullable Future<?> listenerTask = null;\n+    private ScheduledExecutorService scheduler;\n+\n+    /**\n+     * A runnable this listens for incoming UDP responses\n+     */\n+    private Runnable listenerRunnable = () -> {\n+        byte[] rcvBytes = new byte[BUFFER_SIZE];\n+\n+        // create a multicast listener socket\n+        try (MulticastSocket rcvSocket = new MulticastSocket(MDNS_PORT)) {\n+            rcvSocket.setReuseAddress(true);\n+            rcvSocket.joinGroup(InetAddress.getByName(MDNS_ADDR));\n+            rcvSocket.setSoTimeout(TIMEOUT_MSECS);\n+\n+            // loop until stopped\n+            while (!Thread.interrupted()) {\n+                // read next packet\n+                DatagramPacket rcvPacket = new DatagramPacket(rcvBytes, rcvBytes.length);\n+                try {\n+                    rcvSocket.receive(rcvPacket);\n+                    if (isKlfLanResponse(rcvPacket.getData())) {\n+                        ipAddresses.add(rcvPacket.getAddress().getHostAddress());\n+                    }\n+                } catch (IOException e) {\n+                    logger.trace(\"listenerRunnable(): mdns packet receive exception '{}'\", e.getMessage());\n+                    continue;\n+                }\n+            }\n+        } catch (IOException e) {\n+            logger.debug(\"listenerRunnable(): udp socket create exception '{}'\", e.getMessage());\n+        }\n+        listenerTask = null;\n+    };\n+\n+    /**\n+     * Build an mDNS query package to query SERVICE_ID looking for host names\n+     *\n+     * @return a byte array containing the query datagram payload, or an empty array if failed\n+     */\n+    private byte[] buildQuery() {\n+        ByteArrayOutputStream byteStream = new ByteArrayOutputStream(BUFFER_SIZE);\n+        DataOutputStream dataStream = new DataOutputStream(byteStream);\n+        try {\n+            dataStream.writeShort(randomQueryId); // id\n+            dataStream.writeShort(0); // flags\n+            dataStream.writeShort(1); // qdCount\n+            dataStream.writeShort(0); // anCount\n+            dataStream.writeShort(0); // nsCount\n+            dataStream.writeShort(0); // arCount\n+            for (String segString : KLF_SERVICE_ID.split(\"\\\\.\")) {\n+                byte[] segBytes = segString.getBytes(StandardCharsets.UTF_8);\n+                dataStream.writeByte(segBytes.length); // length\n+                dataStream.write(segBytes); // byte string\n+            }\n+            dataStream.writeByte(NULL); // end of name\n+            dataStream.writeShort(TYPE_PTR); // type\n+            dataStream.writeShort(CLASS_IN); // class\n+            return byteStream.toByteArray();\n+        } catch (IOException e) {\n+            // fall through\n+        }\n+        return new byte[0];\n+    }\n+\n+    /**\n+     * Parse an mDNS response package and check if it is from a KLF bridge\n+     *\n+     * @param responsePayload a byte array containing the response datagram payload\n+     * @return true if the response is from a KLF bridge\n+     */\n+    private boolean isKlfLanResponse(byte[] responsePayload) {\n+        DataInputStream dataStream = new DataInputStream(new ByteArrayInputStream(responsePayload));\n+        try {\n+            // check if the package id matches the query\n+            short id = dataStream.readShort();\n+            if (id == randomQueryId) {\n+                short flags = dataStream.readShort();\n+                boolean isResponse = (flags & FLAGS_QR) == FLAGS_QR;\n+                boolean isAuthoritative = (flags & FLAGS_AA) == FLAGS_AA;\n+\n+                // check if it is an authoritative response\n+                if (isResponse && isAuthoritative) {\n+                    short qdCount = dataStream.readShort();\n+                    short anCount = dataStream.readShort();\n+\n+                    @SuppressWarnings(\"unused\")\n+                    short nsCount = dataStream.readShort();\n+                    @SuppressWarnings(\"unused\")\n+                    short arCount = dataStream.readShort();\n+\n+                    // check it is an answer (and not a query)\n+                    if ((anCount == 0) || (qdCount != 0)) {\n+                        return false;\n+                    }\n+\n+                    // parse the answers\n+                    for (short an = 0; an < anCount; an++) {\n+                        // parse the name\n+                        byte[] str = new byte[BUFFER_SIZE];\n+                        int i = 0;\n+                        int segLength;\n+                        while ((segLength = dataStream.readByte()) > 0) {\n+                            for (int index = 0; index < segLength; index++) {\n+                                str[i] = dataStream.readByte();\n+                                i++;\n+                            }\n+                            str[i] = '.';\n+                            i++;\n+                        }\n+                        String name = new String(str, 0, i, StandardCharsets.UTF_8);\n+                        short typ = dataStream.readShort();\n+                        short clazz = (short) (CLASS_MASK & dataStream.readShort());\n+                        if (!(name.startsWith(KLF_SERVICE_ID)) || (typ != TYPE_PTR) || (clazz != CLASS_IN)) {\n+                            return false;\n+                        }\n+\n+                        // if we got here, the name and response type are valid\n+                        @SuppressWarnings(\"unused\")\n+                        int ttl = dataStream.readInt();\n+                        @SuppressWarnings(\"unused\")\n+                        short dataLen = dataStream.readShort();\n+\n+                        // parse the host name\n+                        i = 0;\n+                        while ((segLength = dataStream.readByte()) > 0) {\n+                            for (int index = 0; index < segLength; index++) {\n+                                str[i] = dataStream.readByte();\n+                                i++;\n+                            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY2MjgxOA=="}, "originalCommit": {"oid": "e58c50a9777538ffe7de0fb104220df902c237b3"}, "originalPosition": 208}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyODI1OTQxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/discovery/VeluxBridgeFinder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQyMjowNzo0MVrOH6FVmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxMzowMjoyNVrOH6aiag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY2NjkwNw==", "bodyText": "Since this is a very long running task you should run this asynchronously so that it can be cancelled by the caller if they need to.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Set<String> discoverBridgeIpAddresses() {\n          \n          \n            \n                private Future<Set<String>> discoverBridgeIpAddresses() {\n          \n      \n    \n    \n  \n\nAs far as how to implement the future, I suggest using a FutureTask.", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r530666907", "createdAt": "2020-11-25T22:07:41Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/discovery/VeluxBridgeFinder.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.velux.internal.discovery;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.Closeable;\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.MulticastSocket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashSet;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class that uses Multicast DNS (mDNS) to discover Velux Bridges and return their ipv4 addresses\n+ *\n+ * @author Andrew Fiddian-Green - Initial contribution\n+ */\n+@NonNullByDefault\n+public class VeluxBridgeFinder implements Closeable {\n+\n+    private final Logger logger = LoggerFactory.getLogger(VeluxBridgeFinder.class);\n+\n+    // timing constants\n+    private static final int BUFFER_SIZE = 256;\n+    private static final int SLEEP_MSECS = 100;\n+    private static final int WARMUP_MSECS = 10;\n+    private static final int TIMEOUT_MSECS = 5000;\n+    private static final int REPEAT_COUNT = 3;\n+\n+    // dns communication constants\n+    private static final int MDNS_PORT = 5353;\n+    private static final String MDNS_ADDR = \"224.0.0.251\";\n+\n+    // dns flag constants\n+    private static final short FLAGS_QR = (short) 0x8000;\n+    private static final short FLAGS_AA = 0x0400;\n+\n+    // dns message class constants\n+    private static final short CLASS_IN = 0x0001;\n+    private static final short CLASS_MASK = 0x7FFF;\n+\n+    // dns message type constants\n+    private static final short TYPE_PTR = 0x000c;\n+\n+    private static final byte NULL = 0x00;\n+\n+    // Velux bridge identifiers\n+    private static final String KLF_SERVICE_ID = \"_http._tcp.local\";\n+    private static final String KLF_HOST_PREFIX = \"VELUX_KLF_\";\n+\n+    private short randomQueryId;\n+\n+    private Set<String> ipAddresses = new HashSet<>();\n+\n+    private @Nullable Future<?> listenerTask = null;\n+    private ScheduledExecutorService scheduler;\n+\n+    /**\n+     * A runnable this listens for incoming UDP responses\n+     */\n+    private Runnable listenerRunnable = () -> {\n+        byte[] rcvBytes = new byte[BUFFER_SIZE];\n+\n+        // create a multicast listener socket\n+        try (MulticastSocket rcvSocket = new MulticastSocket(MDNS_PORT)) {\n+            rcvSocket.setReuseAddress(true);\n+            rcvSocket.joinGroup(InetAddress.getByName(MDNS_ADDR));\n+            rcvSocket.setSoTimeout(TIMEOUT_MSECS);\n+\n+            // loop until stopped\n+            while (!Thread.interrupted()) {\n+                // read next packet\n+                DatagramPacket rcvPacket = new DatagramPacket(rcvBytes, rcvBytes.length);\n+                try {\n+                    rcvSocket.receive(rcvPacket);\n+                    if (isKlfLanResponse(rcvPacket.getData())) {\n+                        ipAddresses.add(rcvPacket.getAddress().getHostAddress());\n+                    }\n+                } catch (IOException e) {\n+                    logger.trace(\"listenerRunnable(): mdns packet receive exception '{}'\", e.getMessage());\n+                    continue;\n+                }\n+            }\n+        } catch (IOException e) {\n+            logger.debug(\"listenerRunnable(): udp socket create exception '{}'\", e.getMessage());\n+        }\n+        listenerTask = null;\n+    };\n+\n+    /**\n+     * Build an mDNS query package to query SERVICE_ID looking for host names\n+     *\n+     * @return a byte array containing the query datagram payload, or an empty array if failed\n+     */\n+    private byte[] buildQuery() {\n+        ByteArrayOutputStream byteStream = new ByteArrayOutputStream(BUFFER_SIZE);\n+        DataOutputStream dataStream = new DataOutputStream(byteStream);\n+        try {\n+            dataStream.writeShort(randomQueryId); // id\n+            dataStream.writeShort(0); // flags\n+            dataStream.writeShort(1); // qdCount\n+            dataStream.writeShort(0); // anCount\n+            dataStream.writeShort(0); // nsCount\n+            dataStream.writeShort(0); // arCount\n+            for (String segString : KLF_SERVICE_ID.split(\"\\\\.\")) {\n+                byte[] segBytes = segString.getBytes(StandardCharsets.UTF_8);\n+                dataStream.writeByte(segBytes.length); // length\n+                dataStream.write(segBytes); // byte string\n+            }\n+            dataStream.writeByte(NULL); // end of name\n+            dataStream.writeShort(TYPE_PTR); // type\n+            dataStream.writeShort(CLASS_IN); // class\n+            return byteStream.toByteArray();\n+        } catch (IOException e) {\n+            // fall through\n+        }\n+        return new byte[0];\n+    }\n+\n+    /**\n+     * Parse an mDNS response package and check if it is from a KLF bridge\n+     *\n+     * @param responsePayload a byte array containing the response datagram payload\n+     * @return true if the response is from a KLF bridge\n+     */\n+    private boolean isKlfLanResponse(byte[] responsePayload) {\n+        DataInputStream dataStream = new DataInputStream(new ByteArrayInputStream(responsePayload));\n+        try {\n+            // check if the package id matches the query\n+            short id = dataStream.readShort();\n+            if (id == randomQueryId) {\n+                short flags = dataStream.readShort();\n+                boolean isResponse = (flags & FLAGS_QR) == FLAGS_QR;\n+                boolean isAuthoritative = (flags & FLAGS_AA) == FLAGS_AA;\n+\n+                // check if it is an authoritative response\n+                if (isResponse && isAuthoritative) {\n+                    short qdCount = dataStream.readShort();\n+                    short anCount = dataStream.readShort();\n+\n+                    @SuppressWarnings(\"unused\")\n+                    short nsCount = dataStream.readShort();\n+                    @SuppressWarnings(\"unused\")\n+                    short arCount = dataStream.readShort();\n+\n+                    // check it is an answer (and not a query)\n+                    if ((anCount == 0) || (qdCount != 0)) {\n+                        return false;\n+                    }\n+\n+                    // parse the answers\n+                    for (short an = 0; an < anCount; an++) {\n+                        // parse the name\n+                        byte[] str = new byte[BUFFER_SIZE];\n+                        int i = 0;\n+                        int segLength;\n+                        while ((segLength = dataStream.readByte()) > 0) {\n+                            for (int index = 0; index < segLength; index++) {\n+                                str[i] = dataStream.readByte();\n+                                i++;\n+                            }\n+                            str[i] = '.';\n+                            i++;\n+                        }\n+                        String name = new String(str, 0, i, StandardCharsets.UTF_8);\n+                        short typ = dataStream.readShort();\n+                        short clazz = (short) (CLASS_MASK & dataStream.readShort());\n+                        if (!(name.startsWith(KLF_SERVICE_ID)) || (typ != TYPE_PTR) || (clazz != CLASS_IN)) {\n+                            return false;\n+                        }\n+\n+                        // if we got here, the name and response type are valid\n+                        @SuppressWarnings(\"unused\")\n+                        int ttl = dataStream.readInt();\n+                        @SuppressWarnings(\"unused\")\n+                        short dataLen = dataStream.readShort();\n+\n+                        // parse the host name\n+                        i = 0;\n+                        while ((segLength = dataStream.readByte()) > 0) {\n+                            for (int index = 0; index < segLength; index++) {\n+                                str[i] = dataStream.readByte();\n+                                i++;\n+                            }\n+                            str[i] = '.';\n+                            i++;\n+                        }\n+\n+                        // check if the host name matches\n+                        String host = new String(str, 0, i, StandardCharsets.UTF_8);\n+                        if (host.startsWith(KLF_HOST_PREFIX)) {\n+                            return true;\n+                        }\n+                    }\n+                }\n+            }\n+        } catch (IOException e) {\n+            // fall through\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Start the listener task\n+     */\n+    private void startListener() {\n+        listenerTask = scheduler.submit(listenerRunnable);\n+    }\n+\n+    /**\n+     * Stop the listener task\n+     */\n+    private void stopListener() {\n+        Future<?> listenerTask = this.listenerTask;\n+        if (listenerTask != null) {\n+            listenerTask.cancel(false);\n+        }\n+        this.listenerTask = null;\n+    }\n+\n+    /**\n+     * Private method that searches for Velux Bridges and returns their IP addresses\n+     *\n+     * @return list of dotted IP address e.g. '123.123.123.123'\n+     */\n+    private Set<String> discoverBridgeIpAddresses() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e58c50a9777538ffe7de0fb104220df902c237b3"}, "originalPosition": 250}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTAxNDI1MA==", "bodyText": "Thanks for the suggestion. I think the simplest solution is to wrap the whole thing in a lambda expression called on the discovery service's task scheduler.", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r531014250", "createdAt": "2020-11-26T13:02:25Z", "author": {"login": "andrewfg"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/discovery/VeluxBridgeFinder.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.velux.internal.discovery;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.Closeable;\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.MulticastSocket;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashSet;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class that uses Multicast DNS (mDNS) to discover Velux Bridges and return their ipv4 addresses\n+ *\n+ * @author Andrew Fiddian-Green - Initial contribution\n+ */\n+@NonNullByDefault\n+public class VeluxBridgeFinder implements Closeable {\n+\n+    private final Logger logger = LoggerFactory.getLogger(VeluxBridgeFinder.class);\n+\n+    // timing constants\n+    private static final int BUFFER_SIZE = 256;\n+    private static final int SLEEP_MSECS = 100;\n+    private static final int WARMUP_MSECS = 10;\n+    private static final int TIMEOUT_MSECS = 5000;\n+    private static final int REPEAT_COUNT = 3;\n+\n+    // dns communication constants\n+    private static final int MDNS_PORT = 5353;\n+    private static final String MDNS_ADDR = \"224.0.0.251\";\n+\n+    // dns flag constants\n+    private static final short FLAGS_QR = (short) 0x8000;\n+    private static final short FLAGS_AA = 0x0400;\n+\n+    // dns message class constants\n+    private static final short CLASS_IN = 0x0001;\n+    private static final short CLASS_MASK = 0x7FFF;\n+\n+    // dns message type constants\n+    private static final short TYPE_PTR = 0x000c;\n+\n+    private static final byte NULL = 0x00;\n+\n+    // Velux bridge identifiers\n+    private static final String KLF_SERVICE_ID = \"_http._tcp.local\";\n+    private static final String KLF_HOST_PREFIX = \"VELUX_KLF_\";\n+\n+    private short randomQueryId;\n+\n+    private Set<String> ipAddresses = new HashSet<>();\n+\n+    private @Nullable Future<?> listenerTask = null;\n+    private ScheduledExecutorService scheduler;\n+\n+    /**\n+     * A runnable this listens for incoming UDP responses\n+     */\n+    private Runnable listenerRunnable = () -> {\n+        byte[] rcvBytes = new byte[BUFFER_SIZE];\n+\n+        // create a multicast listener socket\n+        try (MulticastSocket rcvSocket = new MulticastSocket(MDNS_PORT)) {\n+            rcvSocket.setReuseAddress(true);\n+            rcvSocket.joinGroup(InetAddress.getByName(MDNS_ADDR));\n+            rcvSocket.setSoTimeout(TIMEOUT_MSECS);\n+\n+            // loop until stopped\n+            while (!Thread.interrupted()) {\n+                // read next packet\n+                DatagramPacket rcvPacket = new DatagramPacket(rcvBytes, rcvBytes.length);\n+                try {\n+                    rcvSocket.receive(rcvPacket);\n+                    if (isKlfLanResponse(rcvPacket.getData())) {\n+                        ipAddresses.add(rcvPacket.getAddress().getHostAddress());\n+                    }\n+                } catch (IOException e) {\n+                    logger.trace(\"listenerRunnable(): mdns packet receive exception '{}'\", e.getMessage());\n+                    continue;\n+                }\n+            }\n+        } catch (IOException e) {\n+            logger.debug(\"listenerRunnable(): udp socket create exception '{}'\", e.getMessage());\n+        }\n+        listenerTask = null;\n+    };\n+\n+    /**\n+     * Build an mDNS query package to query SERVICE_ID looking for host names\n+     *\n+     * @return a byte array containing the query datagram payload, or an empty array if failed\n+     */\n+    private byte[] buildQuery() {\n+        ByteArrayOutputStream byteStream = new ByteArrayOutputStream(BUFFER_SIZE);\n+        DataOutputStream dataStream = new DataOutputStream(byteStream);\n+        try {\n+            dataStream.writeShort(randomQueryId); // id\n+            dataStream.writeShort(0); // flags\n+            dataStream.writeShort(1); // qdCount\n+            dataStream.writeShort(0); // anCount\n+            dataStream.writeShort(0); // nsCount\n+            dataStream.writeShort(0); // arCount\n+            for (String segString : KLF_SERVICE_ID.split(\"\\\\.\")) {\n+                byte[] segBytes = segString.getBytes(StandardCharsets.UTF_8);\n+                dataStream.writeByte(segBytes.length); // length\n+                dataStream.write(segBytes); // byte string\n+            }\n+            dataStream.writeByte(NULL); // end of name\n+            dataStream.writeShort(TYPE_PTR); // type\n+            dataStream.writeShort(CLASS_IN); // class\n+            return byteStream.toByteArray();\n+        } catch (IOException e) {\n+            // fall through\n+        }\n+        return new byte[0];\n+    }\n+\n+    /**\n+     * Parse an mDNS response package and check if it is from a KLF bridge\n+     *\n+     * @param responsePayload a byte array containing the response datagram payload\n+     * @return true if the response is from a KLF bridge\n+     */\n+    private boolean isKlfLanResponse(byte[] responsePayload) {\n+        DataInputStream dataStream = new DataInputStream(new ByteArrayInputStream(responsePayload));\n+        try {\n+            // check if the package id matches the query\n+            short id = dataStream.readShort();\n+            if (id == randomQueryId) {\n+                short flags = dataStream.readShort();\n+                boolean isResponse = (flags & FLAGS_QR) == FLAGS_QR;\n+                boolean isAuthoritative = (flags & FLAGS_AA) == FLAGS_AA;\n+\n+                // check if it is an authoritative response\n+                if (isResponse && isAuthoritative) {\n+                    short qdCount = dataStream.readShort();\n+                    short anCount = dataStream.readShort();\n+\n+                    @SuppressWarnings(\"unused\")\n+                    short nsCount = dataStream.readShort();\n+                    @SuppressWarnings(\"unused\")\n+                    short arCount = dataStream.readShort();\n+\n+                    // check it is an answer (and not a query)\n+                    if ((anCount == 0) || (qdCount != 0)) {\n+                        return false;\n+                    }\n+\n+                    // parse the answers\n+                    for (short an = 0; an < anCount; an++) {\n+                        // parse the name\n+                        byte[] str = new byte[BUFFER_SIZE];\n+                        int i = 0;\n+                        int segLength;\n+                        while ((segLength = dataStream.readByte()) > 0) {\n+                            for (int index = 0; index < segLength; index++) {\n+                                str[i] = dataStream.readByte();\n+                                i++;\n+                            }\n+                            str[i] = '.';\n+                            i++;\n+                        }\n+                        String name = new String(str, 0, i, StandardCharsets.UTF_8);\n+                        short typ = dataStream.readShort();\n+                        short clazz = (short) (CLASS_MASK & dataStream.readShort());\n+                        if (!(name.startsWith(KLF_SERVICE_ID)) || (typ != TYPE_PTR) || (clazz != CLASS_IN)) {\n+                            return false;\n+                        }\n+\n+                        // if we got here, the name and response type are valid\n+                        @SuppressWarnings(\"unused\")\n+                        int ttl = dataStream.readInt();\n+                        @SuppressWarnings(\"unused\")\n+                        short dataLen = dataStream.readShort();\n+\n+                        // parse the host name\n+                        i = 0;\n+                        while ((segLength = dataStream.readByte()) > 0) {\n+                            for (int index = 0; index < segLength; index++) {\n+                                str[i] = dataStream.readByte();\n+                                i++;\n+                            }\n+                            str[i] = '.';\n+                            i++;\n+                        }\n+\n+                        // check if the host name matches\n+                        String host = new String(str, 0, i, StandardCharsets.UTF_8);\n+                        if (host.startsWith(KLF_HOST_PREFIX)) {\n+                            return true;\n+                        }\n+                    }\n+                }\n+            }\n+        } catch (IOException e) {\n+            // fall through\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Start the listener task\n+     */\n+    private void startListener() {\n+        listenerTask = scheduler.submit(listenerRunnable);\n+    }\n+\n+    /**\n+     * Stop the listener task\n+     */\n+    private void stopListener() {\n+        Future<?> listenerTask = this.listenerTask;\n+        if (listenerTask != null) {\n+            listenerTask.cancel(false);\n+        }\n+        this.listenerTask = null;\n+    }\n+\n+    /**\n+     * Private method that searches for Velux Bridges and returns their IP addresses\n+     *\n+     * @return list of dotted IP address e.g. '123.123.123.123'\n+     */\n+    private Set<String> discoverBridgeIpAddresses() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY2NjkwNw=="}, "originalCommit": {"oid": "e58c50a9777538ffe7de0fb104220df902c237b3"}, "originalPosition": 250}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyODI3NTM0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/handler/VeluxBridgeHandler.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQyMjoxNDo1MlrOH6FfLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxODo1OToxNVrOH6lVug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY2OTM1OQ==", "bodyText": "Please create the executor with a NamedThreadFactory so that you can give the threads names that you can tie to this binding/handler. Also make sure that the created threads are daemon.", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r530669359", "createdAt": "2020-11-25T22:14:52Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/handler/VeluxBridgeHandler.java", "diffHunk": "@@ -250,10 +260,7 @@ public void initialize() {\n             logger.warn(\"initialize(): scheduler is shutdown, aborting the initialization of this bridge.\");\n             return;\n         }\n-        if (handleScheduler.isShutdown()) {\n-            logger.trace(\"initialize(): handleScheduler is shutdown, aborting the initialization of this bridge.\");\n-            return;\n-        }\n+        handleScheduler = Executors.newSingleThreadExecutor();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e58c50a9777538ffe7de0fb104220df902c237b3"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTAxMzQ0Nw==", "bodyText": "Ok.", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r531013447", "createdAt": "2020-11-26T13:00:56Z", "author": {"login": "andrewfg"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/handler/VeluxBridgeHandler.java", "diffHunk": "@@ -250,10 +260,7 @@ public void initialize() {\n             logger.warn(\"initialize(): scheduler is shutdown, aborting the initialization of this bridge.\");\n             return;\n         }\n-        if (handleScheduler.isShutdown()) {\n-            logger.trace(\"initialize(): handleScheduler is shutdown, aborting the initialization of this bridge.\");\n-            return;\n-        }\n+        handleScheduler = Executors.newSingleThreadExecutor();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY2OTM1OQ=="}, "originalCommit": {"oid": "e58c50a9777538ffe7de0fb104220df902c237b3"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTE5MTIyNg==", "bodyText": "Also make sure that the created threads are daemon.\n\n@cpmeister see my issue with @fwolter further above; why do you want it to be daemon? It seems to reduce the performance to an unacceptable level.", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r531191226", "createdAt": "2020-11-26T18:59:15Z", "author": {"login": "andrewfg"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/handler/VeluxBridgeHandler.java", "diffHunk": "@@ -250,10 +260,7 @@ public void initialize() {\n             logger.warn(\"initialize(): scheduler is shutdown, aborting the initialization of this bridge.\");\n             return;\n         }\n-        if (handleScheduler.isShutdown()) {\n-            logger.trace(\"initialize(): handleScheduler is shutdown, aborting the initialization of this bridge.\");\n-            return;\n-        }\n+        handleScheduler = Executors.newSingleThreadExecutor();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY2OTM1OQ=="}, "originalCommit": {"oid": "e58c50a9777538ffe7de0fb104220df902c237b3"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyODI4NzE0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/things/VeluxExistingProducts.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQyMjoxOTo0MlrOH6FmMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxMzowNzo0M1rOH6at8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY3MTE1Mw==", "bodyText": "I'd prefer if you avoided all of the boolean operator trickery in general.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    /*\n          \n          \n            \n                     * If the following if statement used the || operator, the compiler would do logical short circuit optimisation\n          \n          \n            \n                     * so that if the leftmost function evaluated to true, the further right functions would not get called; so we\n          \n          \n            \n                     * use the | operator instead which prevents short circuiting so all three property setters are always called.\n          \n          \n            \n                     */\n          \n          \n            \n                    if (thisProduct.setState(productState) | thisProduct.setCurrentPosition(productPosition)\n          \n          \n            \n                            | thisProduct.setTarget(productTarget)) {\n          \n          \n            \n                        dirty = true;\n          \n          \n            \n                    dirty |= thisProduct.setState(productState);\n          \n          \n            \n                    dirty |= thisProduct.setCurrentPosition(productPosition);\n          \n          \n            \n                    dirty |= thisProduct.setTarget(productTarget);\n          \n          \n            \n                    if (dirty) {", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r530671153", "createdAt": "2020-11-25T22:19:42Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/things/VeluxExistingProducts.java", "diffHunk": "@@ -123,8 +123,13 @@ public boolean update(ProductBridgeIndex bridgeProductIndex, int productState, i\n             return false;\n         }\n         VeluxProduct thisProduct = this.get(bridgeProductIndex);\n-        if (thisProduct.setState(productState) || thisProduct.setCurrentPosition(productPosition)\n-                || thisProduct.setTarget(productTarget)) {\n+        /*\n+         * If the following if statement used the || operator, the compiler would do logical short circuit optimisation\n+         * so that if the leftmost function evaluated to true, the further right functions would not get called; so we\n+         * use the | operator instead which prevents short circuiting so all three property setters are always called.\n+         */\n+        if (thisProduct.setState(productState) | thisProduct.setCurrentPosition(productPosition)\n+                | thisProduct.setTarget(productTarget)) {\n             dirty = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e58c50a9777538ffe7de0fb104220df902c237b3"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTAxNzIwMA==", "bodyText": "Hmm. The difference between || and | is a well documented (albeit little understood) aspect of Java, so I would not call it 'trickery'. However I will unwrap the single line multi | expression to multi line single |= expressions, if you insist. I am pretty sure the compiler would generate the same underlying executable code anyway.", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r531017200", "createdAt": "2020-11-26T13:07:43Z", "author": {"login": "andrewfg"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/things/VeluxExistingProducts.java", "diffHunk": "@@ -123,8 +123,13 @@ public boolean update(ProductBridgeIndex bridgeProductIndex, int productState, i\n             return false;\n         }\n         VeluxProduct thisProduct = this.get(bridgeProductIndex);\n-        if (thisProduct.setState(productState) || thisProduct.setCurrentPosition(productPosition)\n-                || thisProduct.setTarget(productTarget)) {\n+        /*\n+         * If the following if statement used the || operator, the compiler would do logical short circuit optimisation\n+         * so that if the leftmost function evaluated to true, the further right functions would not get called; so we\n+         * use the | operator instead which prevents short circuiting so all three property setters are always called.\n+         */\n+        if (thisProduct.setState(productState) | thisProduct.setCurrentPosition(productPosition)\n+                | thisProduct.setTarget(productTarget)) {\n             dirty = true;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY3MTE1Mw=="}, "originalCommit": {"oid": "e58c50a9777538ffe7de0fb104220df902c237b3"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyODI5Mzg0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/handler/VeluxBridgeHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQyMjoyMjoyMlrOH6Fp7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQyMjoyMjoyMlrOH6Fp7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY3MjExMQ==", "bodyText": "see earlier comment", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r530672111", "createdAt": "2020-11-25T22:22:22Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/handler/VeluxBridgeHandler.java", "diffHunk": "@@ -397,9 +409,10 @@ private void bridgeParamsUpdated() {\n     private synchronized void refreshOpenHAB() {\n         logger.debug(\"refreshOpenHAB() initiated by {} starting cycle {}.\", Thread.currentThread(), refreshCounter);\n \n-        if (handleScheduler.isShutdown()) {\n-            logger.trace(\"refreshOpenHAB(): handleScheduler is shutdown, recreating a scheduler pool.\");\n-            handleScheduler = ThreadPoolManager.getScheduledPool(VeluxBindingConstants.BINDING_ID);\n+        ExecutorService handleScheduler = this.handleScheduler;\n+        if ((handleScheduler == null) || handleScheduler.isShutdown()) {\n+            logger.trace(\"refreshOpenHAB(): handleScheduler is shutdown, recreating a scheduler.\");\n+            handleScheduler = Executors.newSingleThreadExecutor();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e58c50a9777538ffe7de0fb104220df902c237b3"}, "originalPosition": 102}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM0MzAzNDQwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/bridge/slip/io/DataInputStreamWithTimeout.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQxOTo1MjozMVrOH8LVIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0zMFQyMjozMDo1M1rOH8QcWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg2MjI0MQ==", "bodyText": "You should shutdown the executor here.", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r532862241", "createdAt": "2020-11-30T19:52:31Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/bridge/slip/io/DataInputStreamWithTimeout.java", "diffHunk": "@@ -12,124 +12,220 @@\n  */\n package org.openhab.binding.velux.internal.bridge.slip.io;\n \n-import java.io.DataInputStream;\n+import java.io.Closeable;\n import java.io.IOException;\n import java.io.InputStream;\n+import java.net.SocketTimeoutException;\n+import java.util.Arrays;\n+import java.util.NoSuchElementException;\n+import java.util.Queue;\n import java.util.concurrent.Callable;\n-import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.ExecutorService;\n import java.util.concurrent.Executors;\n-import java.util.concurrent.Future;\n-import java.util.concurrent.RejectedExecutionException;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.TimeoutException;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.velux.internal.handler.VeluxBridgeHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n /**\n- * This is an extension of {@link java.io.DataInputStream}, which adds timeouts to receive operation.\n- * <P>\n- * A data input stream lets an application read primitive Java data\n- * types from an underlying input stream in a machine-independent\n- * way. An application uses a data output stream to write data that\n- * can later be read by a data input stream.\n- * <p>\n- * For an in-depth discussion, see:\n- * https://stackoverflow.com/questions/804951/is-it-possible-to-read-from-a-inputstream-with-a-timeout\n+ * This is an wrapper around {@link java.io.InputStream} to support socket receive operations.\n+ *\n+ * It implements a secondary polling thread to asynchronously read bytes from the socket input stream into a buffer. And\n+ * it parses the bytes into SLIP messages, which are placed on a message queue. Callers can access the SLIP messages in\n+ * this queue independently from the polling thread.\n  *\n  * @author Guenther Schreiner - Initial contribution.\n+ * @author Andrew Fiddian-Green - Complete rewrite using asynchronous polling thread.\n  */\n @NonNullByDefault\n-class DataInputStreamWithTimeout extends DataInputStream {\n+class DataInputStreamWithTimeout implements Closeable {\n \n-    /*\n-     * ***************************\n-     * ***** Private Objects *****\n-     */\n+    private static final int QUEUE_SIZE = 512;\n+    private static final int BUFFER_SIZE = 512;\n+    private static final int SLEEP_INTERVAL_MSECS = 50;\n+\n+    // special character that marks the first and last byte of a slip message\n+    private static final byte SLIP_MARK = (byte) 0xc0;\n+\n+    private final Logger logger = LoggerFactory.getLogger(DataInputStreamWithTimeout.class);\n+\n+    private final Queue<byte[]> slipMessageQueue = new ConcurrentLinkedQueue<>();\n+\n+    private InputStream inputStream;\n+\n+    private String pollException = \"\";\n+    private @Nullable Poller pollRunner = null;\n+    private ExecutorService executor;\n+\n+    private class Poller implements Callable<Boolean> {\n+\n+        private boolean interrupted = false;\n+\n+        public void interrupt() {\n+            interrupted = true;\n+        }\n+\n+        /**\n+         * Task that loops to read bytes from {@link InputStream} and build SLIP packets from them. The SLIP packets are\n+         * placed in a {@link ConcurrentLinkedQueue}. It loops continuously until 'interrupt()' or 'Thread.interrupt()'\n+         * are called when terminates early after the next socket read timeout.\n+         */\n+        @Override\n+        public Boolean call() throws Exception {\n+            byte[] buf = new byte[BUFFER_SIZE];\n+            byte byt;\n+            int i = 0;\n+\n+            // clean start, no exception, empty queue\n+            pollException = \"\";\n+            slipMessageQueue.clear();\n+\n+            // loop forever or until internally or externally interrupted\n+            while ((!interrupted) && (!Thread.interrupted())) {\n+                try {\n+                    buf[i] = byt = (byte) inputStream.read();\n+                    if (byt == SLIP_MARK) {\n+                        if (i > 0) {\n+                            // the minimal slip message is 7 bytes [MM PP LL CC CC KK MM]\n+                            if ((i > 5) && (buf[0] == SLIP_MARK)) {\n+                                slipMessageQueue.offer(Arrays.copyOfRange(buf, 0, i + 1));\n+                                if (slipMessageQueue.size() > QUEUE_SIZE) {\n+                                    logger.warn(\"pollRunner() => slip message queue overflow => PLEASE REPORT !!\");\n+                                    slipMessageQueue.poll();\n+                                }\n+                            }\n+                            i = 0;\n+                            buf[0] = SLIP_MARK;\n+                            continue;\n+                        }\n+                    }\n+                    if (++i >= BUFFER_SIZE) {\n+                        i = 0;\n+                    }\n+                } catch (SocketTimeoutException e) {\n+                    // socket read time outs are OK => keep on polling\n+                    continue;\n+                } catch (IOException e) {\n+                    // any other exception => stop polling\n+                    pollException = e.getMessage();\n+                    logger.debug(\"pollRunner() stopping '{}'\", pollException);\n+                    break;\n+                }\n+            }\n+\n+            // we only get here if shutdown or an error occurs so free ourself so we can be recreated again\n+            pollRunner = null;\n+            return true;\n+        }\n+    }\n \n     /**\n-     * Executor for asynchronous read command\n+     * Check if there was an exception on the polling loop task and if so, throw it back on the caller thread.\n+     *\n+     * @throws IOException\n      */\n-    ExecutorService executor = Executors.newFixedThreadPool(2);\n+    private void throwIfPollException() throws IOException {\n+        if (!pollException.isEmpty()) {\n+            logger.debug(\"passPollException() polling loop exception {}\", pollException);\n+            throw new IOException(pollException);\n+        }\n+    }\n \n     /**\n-     * Creates a DataInputStreamWithTimeout that uses the specified\n-     * underlying DataInputStream.\n+     * Creates a {@link DataInputStreamWithTimeout} as a wrapper around the specified underlying {@link InputStream}\n      *\n-     * @param in the specified input stream\n+     * @param stream the specified input stream\n+     * @param bridge the actual Bridge Thing instance\n      */\n-    public DataInputStreamWithTimeout(InputStream in) {\n-        super(in);\n+    public DataInputStreamWithTimeout(InputStream stream, VeluxBridgeHandler bridge) {\n+        inputStream = stream;\n+        executor = Executors.newSingleThreadExecutor(bridge.getThreadFactory());\n     }\n \n     /**\n-     * Reads up to <code>len</code> bytes of data from the contained\n-     * input stream into an array of bytes. An attempt is made to read\n-     * as many as <code>len</code> bytes, but a smaller number may be read,\n-     * possibly zero. The number of bytes actually read is returned as an\n-     * integer.\n-     *\n-     * <p>\n-     * This method blocks until input data is available, end of file is\n-     * detected, or an exception is thrown <B>until</B> the given timeout.\n-     *\n-     * <p>\n-     * If <code>len</code> is zero, then no bytes are read and\n-     * <code>0</code> is returned; otherwise, there is an attempt to read at\n-     * least one byte. If no byte is available because the stream is at end of\n-     * file, the value <code>-1</code> is returned; otherwise, at least one\n-     * byte is read and stored into <code>b</code>.\n-     *\n-     * <p>\n-     * The first byte read is stored into element <code>b[off]</code>, the\n-     * next one into <code>b[off+1]</code>, and so on. The number of bytes read\n-     * is, at most, equal to <code>len</code>. Let <i>k</i> be the number of\n-     * bytes actually read; these bytes will be stored in elements\n-     * <code>b[off]</code> through <code>b[off+</code><i>k</i><code>-1]</code>,\n-     * leaving elements <code>b[off+</code><i>k</i><code>]</code> through\n-     * <code>b[off+len-1]</code> unaffected.\n+     * Overridden method of {@link Closeable} interface. Stops the polling thread.\n      *\n-     * <p>\n-     * In every case, elements <code>b[0]</code> through\n-     * <code>b[off]</code> and elements <code>b[off+len]</code> through\n-     * <code>b[b.length-1]</code> are unaffected.\n+     * @throws IOException\n+     */\n+    @Override\n+    public void close() throws IOException {\n+        stopPolling();\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b2fc1c96a532869697eaa5a8a7c3e85a89c1ea79"}, "originalPosition": 201}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjk0NjAwOQ==", "bodyText": "Ok. Will do.", "url": "https://github.com/openhab/openhab-addons/pull/8777#discussion_r532946009", "createdAt": "2020-11-30T22:30:53Z", "author": {"login": "andrewfg"}, "path": "bundles/org.openhab.binding.velux/src/main/java/org/openhab/binding/velux/internal/bridge/slip/io/DataInputStreamWithTimeout.java", "diffHunk": "@@ -12,124 +12,220 @@\n  */\n package org.openhab.binding.velux.internal.bridge.slip.io;\n \n-import java.io.DataInputStream;\n+import java.io.Closeable;\n import java.io.IOException;\n import java.io.InputStream;\n+import java.net.SocketTimeoutException;\n+import java.util.Arrays;\n+import java.util.NoSuchElementException;\n+import java.util.Queue;\n import java.util.concurrent.Callable;\n-import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.ExecutorService;\n import java.util.concurrent.Executors;\n-import java.util.concurrent.Future;\n-import java.util.concurrent.RejectedExecutionException;\n-import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.TimeoutException;\n \n import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.velux.internal.handler.VeluxBridgeHandler;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n /**\n- * This is an extension of {@link java.io.DataInputStream}, which adds timeouts to receive operation.\n- * <P>\n- * A data input stream lets an application read primitive Java data\n- * types from an underlying input stream in a machine-independent\n- * way. An application uses a data output stream to write data that\n- * can later be read by a data input stream.\n- * <p>\n- * For an in-depth discussion, see:\n- * https://stackoverflow.com/questions/804951/is-it-possible-to-read-from-a-inputstream-with-a-timeout\n+ * This is an wrapper around {@link java.io.InputStream} to support socket receive operations.\n+ *\n+ * It implements a secondary polling thread to asynchronously read bytes from the socket input stream into a buffer. And\n+ * it parses the bytes into SLIP messages, which are placed on a message queue. Callers can access the SLIP messages in\n+ * this queue independently from the polling thread.\n  *\n  * @author Guenther Schreiner - Initial contribution.\n+ * @author Andrew Fiddian-Green - Complete rewrite using asynchronous polling thread.\n  */\n @NonNullByDefault\n-class DataInputStreamWithTimeout extends DataInputStream {\n+class DataInputStreamWithTimeout implements Closeable {\n \n-    /*\n-     * ***************************\n-     * ***** Private Objects *****\n-     */\n+    private static final int QUEUE_SIZE = 512;\n+    private static final int BUFFER_SIZE = 512;\n+    private static final int SLEEP_INTERVAL_MSECS = 50;\n+\n+    // special character that marks the first and last byte of a slip message\n+    private static final byte SLIP_MARK = (byte) 0xc0;\n+\n+    private final Logger logger = LoggerFactory.getLogger(DataInputStreamWithTimeout.class);\n+\n+    private final Queue<byte[]> slipMessageQueue = new ConcurrentLinkedQueue<>();\n+\n+    private InputStream inputStream;\n+\n+    private String pollException = \"\";\n+    private @Nullable Poller pollRunner = null;\n+    private ExecutorService executor;\n+\n+    private class Poller implements Callable<Boolean> {\n+\n+        private boolean interrupted = false;\n+\n+        public void interrupt() {\n+            interrupted = true;\n+        }\n+\n+        /**\n+         * Task that loops to read bytes from {@link InputStream} and build SLIP packets from them. The SLIP packets are\n+         * placed in a {@link ConcurrentLinkedQueue}. It loops continuously until 'interrupt()' or 'Thread.interrupt()'\n+         * are called when terminates early after the next socket read timeout.\n+         */\n+        @Override\n+        public Boolean call() throws Exception {\n+            byte[] buf = new byte[BUFFER_SIZE];\n+            byte byt;\n+            int i = 0;\n+\n+            // clean start, no exception, empty queue\n+            pollException = \"\";\n+            slipMessageQueue.clear();\n+\n+            // loop forever or until internally or externally interrupted\n+            while ((!interrupted) && (!Thread.interrupted())) {\n+                try {\n+                    buf[i] = byt = (byte) inputStream.read();\n+                    if (byt == SLIP_MARK) {\n+                        if (i > 0) {\n+                            // the minimal slip message is 7 bytes [MM PP LL CC CC KK MM]\n+                            if ((i > 5) && (buf[0] == SLIP_MARK)) {\n+                                slipMessageQueue.offer(Arrays.copyOfRange(buf, 0, i + 1));\n+                                if (slipMessageQueue.size() > QUEUE_SIZE) {\n+                                    logger.warn(\"pollRunner() => slip message queue overflow => PLEASE REPORT !!\");\n+                                    slipMessageQueue.poll();\n+                                }\n+                            }\n+                            i = 0;\n+                            buf[0] = SLIP_MARK;\n+                            continue;\n+                        }\n+                    }\n+                    if (++i >= BUFFER_SIZE) {\n+                        i = 0;\n+                    }\n+                } catch (SocketTimeoutException e) {\n+                    // socket read time outs are OK => keep on polling\n+                    continue;\n+                } catch (IOException e) {\n+                    // any other exception => stop polling\n+                    pollException = e.getMessage();\n+                    logger.debug(\"pollRunner() stopping '{}'\", pollException);\n+                    break;\n+                }\n+            }\n+\n+            // we only get here if shutdown or an error occurs so free ourself so we can be recreated again\n+            pollRunner = null;\n+            return true;\n+        }\n+    }\n \n     /**\n-     * Executor for asynchronous read command\n+     * Check if there was an exception on the polling loop task and if so, throw it back on the caller thread.\n+     *\n+     * @throws IOException\n      */\n-    ExecutorService executor = Executors.newFixedThreadPool(2);\n+    private void throwIfPollException() throws IOException {\n+        if (!pollException.isEmpty()) {\n+            logger.debug(\"passPollException() polling loop exception {}\", pollException);\n+            throw new IOException(pollException);\n+        }\n+    }\n \n     /**\n-     * Creates a DataInputStreamWithTimeout that uses the specified\n-     * underlying DataInputStream.\n+     * Creates a {@link DataInputStreamWithTimeout} as a wrapper around the specified underlying {@link InputStream}\n      *\n-     * @param in the specified input stream\n+     * @param stream the specified input stream\n+     * @param bridge the actual Bridge Thing instance\n      */\n-    public DataInputStreamWithTimeout(InputStream in) {\n-        super(in);\n+    public DataInputStreamWithTimeout(InputStream stream, VeluxBridgeHandler bridge) {\n+        inputStream = stream;\n+        executor = Executors.newSingleThreadExecutor(bridge.getThreadFactory());\n     }\n \n     /**\n-     * Reads up to <code>len</code> bytes of data from the contained\n-     * input stream into an array of bytes. An attempt is made to read\n-     * as many as <code>len</code> bytes, but a smaller number may be read,\n-     * possibly zero. The number of bytes actually read is returned as an\n-     * integer.\n-     *\n-     * <p>\n-     * This method blocks until input data is available, end of file is\n-     * detected, or an exception is thrown <B>until</B> the given timeout.\n-     *\n-     * <p>\n-     * If <code>len</code> is zero, then no bytes are read and\n-     * <code>0</code> is returned; otherwise, there is an attempt to read at\n-     * least one byte. If no byte is available because the stream is at end of\n-     * file, the value <code>-1</code> is returned; otherwise, at least one\n-     * byte is read and stored into <code>b</code>.\n-     *\n-     * <p>\n-     * The first byte read is stored into element <code>b[off]</code>, the\n-     * next one into <code>b[off+1]</code>, and so on. The number of bytes read\n-     * is, at most, equal to <code>len</code>. Let <i>k</i> be the number of\n-     * bytes actually read; these bytes will be stored in elements\n-     * <code>b[off]</code> through <code>b[off+</code><i>k</i><code>-1]</code>,\n-     * leaving elements <code>b[off+</code><i>k</i><code>]</code> through\n-     * <code>b[off+len-1]</code> unaffected.\n+     * Overridden method of {@link Closeable} interface. Stops the polling thread.\n      *\n-     * <p>\n-     * In every case, elements <code>b[0]</code> through\n-     * <code>b[off]</code> and elements <code>b[off+len]</code> through\n-     * <code>b[b.length-1]</code> are unaffected.\n+     * @throws IOException\n+     */\n+    @Override\n+    public void close() throws IOException {\n+        stopPolling();\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg2MjI0MQ=="}, "originalCommit": {"oid": "b2fc1c96a532869697eaa5a8a7c3e85a89c1ea79"}, "originalPosition": 201}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4069, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}