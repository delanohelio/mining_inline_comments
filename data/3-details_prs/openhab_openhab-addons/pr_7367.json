{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAzMDQ2Nzc4", "number": 7367, "title": "[chromecast] Refactoring of binding", "bodyText": "Refactoring of binding\n\nSome stuff lying around in my branches.\nSigned-off-by: Christoph Weitkamp github@christophweitkamp.de", "createdAt": "2020-04-14T08:36:30Z", "url": "https://github.com/openhab/openhab-addons/pull/7367", "merged": true, "mergeCommit": {"oid": "954422e76614f4483b7544cfaa8317fa19fbdb0a"}, "closed": true, "closedAt": "2020-04-18T17:20:20Z", "author": {"login": "cweitkamp"}, "timelineItems": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcXfu-_gFqTM5MjczNTQ0OA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcY5NQcAFqTM5NTkzMzA4Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyNzM1NDQ4", "url": "https://github.com/openhab/openhab-addons/pull/7367#pullrequestreview-392735448", "createdAt": "2020-04-14T09:01:23Z", "commit": {"oid": "6842ab3408206f7aadbc5a3770c8367a8ca328b8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwOTowMToyM1rOGFFAhQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQwOTowMToyM1rOGFFAhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzk3ODExNw==", "bodyText": "Similar to the Google TTS add-on, you can simplify the conversion to hexadecimal and left padding the 0's using\nString fileNameHash = String.format(\"%032x\", bigInt);", "url": "https://github.com/openhab/openhab-addons/pull/7367#discussion_r407978117", "createdAt": "2020-04-14T09:01:23Z", "author": {"login": "wborn"}, "path": "bundles/org.openhab.binding.chromecast/src/main/java/org/openhab/binding/chromecast/internal/utils/ByteArrayFileCache.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.chromecast.internal.utils;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.ConfigConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This is a simple file based cache implementation.\n+ *\n+ * @author Christoph Weitkamp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ByteArrayFileCache {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ByteArrayFileCache.class);\n+\n+    private static final String MD5_ALGORITHM = \"MD5\";\n+\n+    static final String CACHE_FOLDER_NAME = \"cache\";\n+    private static final char EXTENSION_SEPARATOR = '.';\n+    private static final char UNIX_SEPARATOR = '/';\n+    private static final char WINDOWS_SEPARATOR = '\\\\';\n+\n+    private final File cacheFolder;\n+\n+    static final long ONE_DAY_IN_MILLIS = TimeUnit.DAYS.toMillis(1);\n+    private int expiry = 0;\n+\n+    private static final Map<String, File> FILES_IN_CACHE = new ConcurrentHashMap<>();\n+\n+    /**\n+     * Creates a new {@link ByteArrayFileCache} instance for a service. Creates a <code>cache</code> folder under\n+     * <code>$userdata/cache/$servicePID</code>.\n+     *\n+     * @param servicePID PID of the service\n+     */\n+    public ByteArrayFileCache(String servicePID) {\n+        // TODO track and limit folder size\n+        // TODO support user specific folder\n+        cacheFolder = new File(new File(ConfigConstants.getUserDataFolder(), CACHE_FOLDER_NAME), servicePID);\n+        if (!cacheFolder.exists()) {\n+            logger.debug(\"Creating cache folder '{}'\", cacheFolder.getAbsolutePath());\n+            cacheFolder.mkdirs();\n+        }\n+        logger.debug(\"Using cache folder '{}'\", cacheFolder.getAbsolutePath());\n+    }\n+\n+    /**\n+     * Creates a new {@link ByteArrayFileCache} instance for a service. Creates a <code>cache</code> folder under\n+     * <code>$userdata/cache/$servicePID/</code>.\n+     *\n+     * @param servicePID PID of the service\n+     * @param int the days for how long the files stay in the cache valid. Must be positive. 0 to\n+     *            disables this functionality.\n+     */\n+    public ByteArrayFileCache(String servicePID, int expiry) {\n+        this(servicePID);\n+        if (expiry < 0) {\n+            throw new IllegalArgumentException(\"Cache expiration time must be greater than or equal to 0\");\n+        }\n+        this.expiry = expiry;\n+    }\n+\n+    /**\n+     * Adds a file to the cache. If the cache previously contained a file for the key, the old file is replaced by the\n+     * new content.\n+     *\n+     * @param key the key with which the file is to be associated\n+     * @param content the content for the file to be associated with the specified key\n+     */\n+    public void put(String key, byte[] content) {\n+        writeFile(getUniqueFile(key), content);\n+    }\n+\n+    /**\n+     * Adds a file to the cache.\n+     *\n+     * @param key the key with which the file is to be associated\n+     * @param content the content for the file to be associated with the specified key\n+     */\n+    public void putIfAbsent(String key, byte[] content) {\n+        File fileInCache = getUniqueFile(key);\n+        if (fileInCache.exists()) {\n+            logger.debug(\"File '{}' present in cache\", fileInCache.getName());\n+            // update time of last use\n+            fileInCache.setLastModified(System.currentTimeMillis());\n+        } else {\n+            writeFile(fileInCache, content);\n+        }\n+    }\n+\n+    /**\n+     * Adds a file to the cache and returns the content of the file.\n+     *\n+     * @param key the key with which the file is to be associated\n+     * @param content the content for the file to be associated with the specified key\n+     * @return the content of the file associated with the given key\n+     */\n+    public byte[] putIfAbsentAndGet(String key, byte[] content) {\n+        putIfAbsent(key, content);\n+\n+        return content;\n+    }\n+\n+    /**\n+     * Writes the given content to the given {@link File}.\n+     *\n+     * @param fileInCache the {@link File}\n+     * @param content the content to be written\n+     */\n+    private void writeFile(File fileInCache, byte[] content) {\n+        logger.debug(\"Caching file '{}'\", fileInCache.getName());\n+        try {\n+            Files.write(fileInCache.toPath(), content);\n+        } catch (IOException e) {\n+            logger.warn(\"Could not write file '{}'\u00a0to cache\", fileInCache.getName(), e);\n+        }\n+    }\n+\n+    /**\n+     * Checks if the key is present in the cache.\n+     *\n+     * @param key the key whose presence in the cache is to be tested\n+     * @return true if the cache contains a file for the specified key\n+     */\n+    public boolean containsKey(String key) {\n+        return getUniqueFile(key).exists();\n+    }\n+\n+    /**\n+     * Removes the file associated with the given key from the cache.\n+     *\n+     * @param key the key whose associated file is to be removed\n+     */\n+    public void remove(String key) {\n+        deleteFile(getUniqueFile(key));\n+    }\n+\n+    /**\n+     * Deletes the given {@link File}.\n+     *\n+     * @param fileInCache the {@link File}\n+     */\n+    private void deleteFile(File fileInCache) {\n+        if (fileInCache.exists()) {\n+            logger.debug(\"Deleting file '{}' from cache\", fileInCache.getName());\n+            fileInCache.delete();\n+        } else {\n+            logger.debug(\"File '{}' not found in cache\", fileInCache.getName());\n+        }\n+    }\n+\n+    /**\n+     * Removes all files from the cache.\n+     */\n+    public void clear() {\n+        File[] filesInCache = cacheFolder.listFiles();\n+        if (filesInCache != null && filesInCache.length > 0) {\n+            logger.debug(\"Deleting all files from cache\");\n+            Arrays.stream(filesInCache).forEach(File::delete);\n+        }\n+    }\n+\n+    /**\n+     * Removes expired files from the cache.\n+     */\n+    public void clearExpired() {\n+        // exit if expiry is set to 0 (disabled)\n+        if (expiry <= 0) {\n+            return;\n+        }\n+        File[] filesInCache = cacheFolder.listFiles();\n+        if (filesInCache != null && filesInCache.length > 0) {\n+            logger.debug(\"Deleting expired files from cache\");\n+            Arrays.stream(filesInCache).filter(file -> isExpired(file)).forEach(File::delete);\n+        }\n+    }\n+\n+    /**\n+     * Checks if the given {@link File} is expired.\n+     *\n+     * @param fileInCache the {@link File}\n+     * @return <code>true</code> if the file is expired, <code>false</code> otherwise\n+     */\n+    private boolean isExpired(File fileInCache) {\n+        // exit if expiry is set to 0 (disabled)\n+        if (expiry <= 0) {\n+            return false;\n+        }\n+        return expiry * ONE_DAY_IN_MILLIS < System.currentTimeMillis() - fileInCache.lastModified();\n+    }\n+\n+    /**\n+     * Returns the content of the file associated with the given key, if it is present.\n+     *\n+     * @param key the key whose associated file is to be returned\n+     * @return the content of the file associated with the given key\n+     */\n+    public byte[] get(String key) {\n+        return readFile(getUniqueFile(key));\n+    }\n+\n+    /**\n+     * Reads the content from the given {@link File}, if it is present.\n+     *\n+     * @param fileInCache the {@link File}\n+     * @return the content of the file\n+     */\n+    private byte[] readFile(File fileInCache) {\n+        if (fileInCache.exists()) {\n+            logger.debug(\"Reading file '{}' from cache\", fileInCache.getName());\n+            // update time of last use\n+            fileInCache.setLastModified(System.currentTimeMillis());\n+            try {\n+                return Files.readAllBytes(fileInCache.toPath());\n+            } catch (IOException e) {\n+                logger.warn(\"Could not read file '{}'\u00a0from cache\", fileInCache.getName(), e);\n+            }\n+        } else {\n+            logger.debug(\"File '{}' not found in cache\", fileInCache.getName());\n+        }\n+        return new byte[0];\n+    }\n+\n+    /**\n+     * Creates a unique {@link File} from the key with which the file is to be associated.\n+     *\n+     * @param key the key with which the file is to be associated\n+     * @return unique file for the file associated with the given key\n+     */\n+    File getUniqueFile(String key) {\n+        String uniqueFileName = getUniqueFileName(key);\n+        if (FILES_IN_CACHE.containsKey(uniqueFileName)) {\n+            return FILES_IN_CACHE.get(uniqueFileName);\n+        } else {\n+            String fileExtension = getFileExtension(key);\n+            File fileInCache = new File(cacheFolder,\n+                    uniqueFileName + (fileExtension == null ? \"\" : EXTENSION_SEPARATOR + fileExtension));\n+            FILES_IN_CACHE.put(uniqueFileName, fileInCache);\n+            return fileInCache;\n+        }\n+    }\n+\n+    /**\n+     * Gets the extension of a file name.\n+     *\n+     * @param fileName the file name to retrieve the extension of\n+     * @return the extension of the file or null if none exists\n+     */\n+    @Nullable\n+    String getFileExtension(String fileName) {\n+        int extensionPos = fileName.lastIndexOf(EXTENSION_SEPARATOR);\n+        int lastSeparatorPos = Math.max(fileName.lastIndexOf(UNIX_SEPARATOR), fileName.lastIndexOf(WINDOWS_SEPARATOR));\n+        return lastSeparatorPos > extensionPos ? null : fileName.substring(extensionPos + 1).replaceFirst(\"\\\\?.*$\", \"\");\n+    }\n+\n+    /**\n+     * Creates a unique file name from the key with which the file is to be associated.\n+     *\n+     * @param key the key with which the file is to be associated\n+     * @return unique file name for the file associated with the given key\n+     */\n+    String getUniqueFileName(String key) {\n+        try {\n+            MessageDigest md = MessageDigest.getInstance(MD5_ALGORITHM);\n+            byte[] bytesOfKey = key.getBytes(StandardCharsets.UTF_8);\n+            byte[] md5Hash = md.digest(bytesOfKey);\n+            BigInteger bigInt = new BigInteger(1, md5Hash);\n+            String fileNameHash = bigInt.toString(16);\n+            // We need to zero pad it if you actually want the full 32 chars\n+            while (fileNameHash.length() < 32) {\n+                fileNameHash = \"0\" + fileNameHash;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6842ab3408206f7aadbc5a3770c8367a8ca328b8"}, "originalPosition": 298}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkzMDUxMTUy", "url": "https://github.com/openhab/openhab-addons/pull/7367#pullrequestreview-393051152", "createdAt": "2020-04-14T15:36:57Z", "commit": {"oid": "ec4c562f2e68eceb4e323a7ef29744e7e523c086"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxNTozNjo1N1rOGFUsHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxNTozNjo1N1rOGFUsHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODIzNTAzOA==", "bodyText": "I should change this mistake too.", "url": "https://github.com/openhab/openhab-addons/pull/7367#discussion_r408235038", "createdAt": "2020-04-14T15:36:57Z", "author": {"login": "cweitkamp"}, "path": "bundles/org.openhab.binding.chromecast/src/main/resources/ESH-INF/i18n/chromecast_de.properties", "diffHunk": "@@ -17,6 +17,8 @@ thing-type.config.chromecast.device.ipAddress.label = IP-Adresse\n thing-type.config.chromecast.device.ipAddress.description = Lokale IP-Adresse oder Hostname des Chromecast Ger\ufffdtes.\n thing-type.config.chromecast.device.port.label = Port\n thing-type.config.chromecast.device.port.description = Port des Chromecast Ger\ufffdtes.\n+thing-type.config.chromecast.device.refreshRate.label = Aktualisierungsintervall\n+thing-type.config.chromecast.device.refreshRate.description = Intervall zur Aktualisierung des Chromecast Ger\ufffdtes.\n \n # channel types\n channel-type.kodi.stop.label = Stop", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec4c562f2e68eceb4e323a7ef29744e7e523c086"}, "originalPosition": 8}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkzMTYxMzk5", "url": "https://github.com/openhab/openhab-addons/pull/7367#pullrequestreview-393161399", "createdAt": "2020-04-14T17:51:59Z", "commit": {"oid": "cda5702bde5734236034eb2f0864200e6211afbe"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQxNzo1MTo1OVrOGFaNGg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMDowOToyMFrOGFfBkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODMyNTQwMg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private @Nullable final String callbackUrl;\n          \n          \n            \n                private final @Nullable String callbackUrl;", "url": "https://github.com/openhab/openhab-addons/pull/7367#discussion_r408325402", "createdAt": "2020-04-14T17:51:59Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.chromecast/src/main/java/org/openhab/binding/chromecast/internal/ChromecastAudioSink.java", "diffHunk": "@@ -25,30 +25,36 @@\n import org.slf4j.LoggerFactory;\n \n /**\n- * Handles the AudioSink portion of the Chromecast plugin. Note that we store volume in\n+ * Handles the AudioSink portion of the Chromecast add-on.\n  *\n  * @author Jason Holmes - Initial contribution\n  */\n+@NonNullByDefault\n public class ChromecastAudioSink {\n-    private final Logger logger = LoggerFactory.getLogger(getClass());\n+    private final Logger logger = LoggerFactory.getLogger(ChromecastAudioSink.class);\n+\n+    private static final String MIME_TYPE_AUDIO_WAV = \"audio/wav\";\n+    private static final String MIME_TYPE_AUDIO_MPEG = \"audio/mpeg\";\n+\n     private final ChromecastCommander commander;\n     private final AudioHTTPServer audioHTTPServer;\n-    private final String callbackUrl;\n+    private @Nullable final String callbackUrl;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cda5702bde5734236034eb2f0864200e6211afbe"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODMyNzU2NA==", "bodyText": "This is out of scope of this PR but just wanted to point out that this code doesn't take into account other audio formats.", "url": "https://github.com/openhab/openhab-addons/pull/7367#discussion_r408327564", "createdAt": "2020-04-14T17:55:17Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.chromecast/src/main/java/org/openhab/binding/chromecast/internal/ChromecastAudioSink.java", "diffHunk": "@@ -68,11 +74,8 @@ public void process(AudioStream audioStream) throws UnsupportedAudioFormatExcept\n                     return;\n                 }\n             }\n-\n-            String mimeType = Objects.equals(audioStream.getFormat().getCodec(), AudioFormat.CODEC_MP3) ? \"audio/mpeg\"\n-                    : \"audio/wav\";\n-\n-            commander.playMedia(\"Notification\", url, mimeType);\n+            commander.playMedia(\"Notification\", url,\n+                    AudioFormat.MP3.isCompatible(audioStream.getFormat()) ? MIME_TYPE_AUDIO_MPEG : MIME_TYPE_AUDIO_WAV);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cda5702bde5734236034eb2f0864200e6211afbe"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM4OTA0Mw==", "bodyText": "Are title and mimeType supposed to be nullable?", "url": "https://github.com/openhab/openhab-addons/pull/7367#discussion_r408389043", "createdAt": "2020-04-14T19:41:28Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.chromecast/src/main/java/org/openhab/binding/chromecast/internal/ChromecastCommander.java", "diffHunk": "@@ -219,7 +219,7 @@ private void handleMute(final Command command) {\n         }\n     }\n \n-    void playMedia(String title, String url, String mimeType) {\n+    void playMedia(@Nullable String title, @Nullable String url, @Nullable String mimeType) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cda5702bde5734236034eb2f0864200e6211afbe"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM5MjU1NA==", "bodyText": "Is image cache thread-safe?", "url": "https://github.com/openhab/openhab-addons/pull/7367#discussion_r408392554", "createdAt": "2020-04-14T19:48:00Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.chromecast/src/main/java/org/openhab/binding/chromecast/internal/ChromecastStatusUpdater.java", "diffHunk": "@@ -245,21 +246,39 @@ private void updateImage(Map<String, Object> metadata) {\n             }\n         }\n \n-        // Poor man's cache. If the imageSrc is the same, don't update them.\n-        if (Objects.equals(this.imageSrc, imageSrc)) {\n-            return;\n-        } else {\n-            this.imageSrc = imageSrc;\n-        }\n-\n         if (callback.isLinked(CHANNEL_IMAGE_SRC)) {\n-            callback.updateState(CHANNEL_IMAGE_SRC, imageSrc == null ? UNDEF : new StringType(imageSrc));\n+            callback.updateState(CHANNEL_IMAGE_SRC, imageSrc == null ? UnDefType.UNDEF : new StringType(imageSrc));\n         }\n \n         if (callback.isLinked(CHANNEL_IMAGE)) {\n-            State image = imageSrc == null ? UNDEF : HttpUtil.downloadImage(imageSrc);\n-            callback.updateState(CHANNEL_IMAGE, image == null ? UNDEF : image);\n+            State image = imageSrc == null ? UnDefType.UNDEF : downloadImageFromCache(imageSrc);\n+            callback.updateState(CHANNEL_IMAGE, image == null ? UnDefType.UNDEF : image);\n+        }\n+    }\n+\n+    private @Nullable RawType downloadImage(String url) {\n+        logger.debug(\"Trying to download the content of URL '{}'\", url);\n+        RawType downloadedImage = HttpUtil.downloadImage(url);\n+        if (downloadedImage == null) {\n+            logger.debug(\"Failed to download the content of URL '{}'\", url);\n+        }\n+        return downloadedImage;\n+    }\n+\n+    private @Nullable RawType downloadImageFromCache(String url) {\n+        if (IMAGE_CACHE.containsKey(url)) {\n+            byte[] bytes = IMAGE_CACHE.get(url);\n+            String contentType = HttpUtil.guessContentTypeFromData(bytes);\n+            return new RawType(bytes,\n+                    contentType == null || contentType.isEmpty() ? RawType.DEFAULT_MIME_TYPE : contentType);\n+        } else {\n+            RawType image = downloadImage(url);\n+            if (image != null) {\n+                IMAGE_CACHE.put(url, image.getBytes());\n+                return image;\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cda5702bde5734236034eb2f0864200e6211afbe"}, "originalPosition": 224}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODM5NzcwMg==", "bodyText": "If you are trying to prevent rehashes you need take into account the loadFactor.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    final Map<String, Object> properties = new HashMap<>(3);\n          \n          \n            \n                    final Map<String, Object> properties = new HashMap<>(5);\n          \n      \n    \n    \n  \n\nAt 0.75 loadFactor an initial capacity of 5 is safe to hold 3 entries without rehashing.", "url": "https://github.com/openhab/openhab-addons/pull/7367#discussion_r408397702", "createdAt": "2020-04-14T19:57:17Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.chromecast/src/main/java/org/openhab/binding/chromecast/internal/discovery/ChromecastDiscoveryParticipant.java", "diffHunk": "@@ -54,13 +58,13 @@ public String getServiceType() {\n     }\n \n     @Override\n-    public DiscoveryResult createResult(ServiceInfo service) {\n+    public @Nullable DiscoveryResult createResult(ServiceInfo service) {\n         final ThingUID uid = getThingUID(service);\n         if (uid == null) {\n             return null;\n         }\n \n-        final Map<String, Object> properties = new HashMap<>(2);\n+        final Map<String, Object> properties = new HashMap<>(3);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cda5702bde5734236034eb2f0864200e6211afbe"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQwMjMyNQ==", "bodyText": "Why can't you just throw an exception instead of making it seem like the cached file is empty to callers?", "url": "https://github.com/openhab/openhab-addons/pull/7367#discussion_r408402325", "createdAt": "2020-04-14T20:05:35Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.chromecast/src/main/java/org/openhab/binding/chromecast/internal/utils/ByteArrayFileCache.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.chromecast.internal.utils;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.ConfigConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This is a simple file based cache implementation.\n+ *\n+ * @author Christoph Weitkamp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ByteArrayFileCache {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ByteArrayFileCache.class);\n+\n+    private static final String MD5_ALGORITHM = \"MD5\";\n+\n+    static final String CACHE_FOLDER_NAME = \"cache\";\n+    private static final char EXTENSION_SEPARATOR = '.';\n+    private static final char UNIX_SEPARATOR = '/';\n+    private static final char WINDOWS_SEPARATOR = '\\\\';\n+\n+    private final File cacheFolder;\n+\n+    static final long ONE_DAY_IN_MILLIS = TimeUnit.DAYS.toMillis(1);\n+    private int expiry = 0;\n+\n+    private static final Map<String, File> FILES_IN_CACHE = new ConcurrentHashMap<>();\n+\n+    /**\n+     * Creates a new {@link ByteArrayFileCache} instance for a service. Creates a <code>cache</code> folder under\n+     * <code>$userdata/cache/$servicePID</code>.\n+     *\n+     * @param servicePID PID of the service\n+     */\n+    public ByteArrayFileCache(String servicePID) {\n+        // TODO track and limit folder size\n+        // TODO support user specific folder\n+        cacheFolder = new File(new File(ConfigConstants.getUserDataFolder(), CACHE_FOLDER_NAME), servicePID);\n+        if (!cacheFolder.exists()) {\n+            logger.debug(\"Creating cache folder '{}'\", cacheFolder.getAbsolutePath());\n+            cacheFolder.mkdirs();\n+        }\n+        logger.debug(\"Using cache folder '{}'\", cacheFolder.getAbsolutePath());\n+    }\n+\n+    /**\n+     * Creates a new {@link ByteArrayFileCache} instance for a service. Creates a <code>cache</code> folder under\n+     * <code>$userdata/cache/$servicePID/</code>.\n+     *\n+     * @param servicePID PID of the service\n+     * @param int the days for how long the files stay in the cache valid. Must be positive. 0 to\n+     *            disables this functionality.\n+     */\n+    public ByteArrayFileCache(String servicePID, int expiry) {\n+        this(servicePID);\n+        if (expiry < 0) {\n+            throw new IllegalArgumentException(\"Cache expiration time must be greater than or equal to 0\");\n+        }\n+        this.expiry = expiry;\n+    }\n+\n+    /**\n+     * Adds a file to the cache. If the cache previously contained a file for the key, the old file is replaced by the\n+     * new content.\n+     *\n+     * @param key the key with which the file is to be associated\n+     * @param content the content for the file to be associated with the specified key\n+     */\n+    public void put(String key, byte[] content) {\n+        writeFile(getUniqueFile(key), content);\n+    }\n+\n+    /**\n+     * Adds a file to the cache.\n+     *\n+     * @param key the key with which the file is to be associated\n+     * @param content the content for the file to be associated with the specified key\n+     */\n+    public void putIfAbsent(String key, byte[] content) {\n+        File fileInCache = getUniqueFile(key);\n+        if (fileInCache.exists()) {\n+            logger.debug(\"File '{}' present in cache\", fileInCache.getName());\n+            // update time of last use\n+            fileInCache.setLastModified(System.currentTimeMillis());\n+        } else {\n+            writeFile(fileInCache, content);\n+        }\n+    }\n+\n+    /**\n+     * Adds a file to the cache and returns the content of the file.\n+     *\n+     * @param key the key with which the file is to be associated\n+     * @param content the content for the file to be associated with the specified key\n+     * @return the content of the file associated with the given key\n+     */\n+    public byte[] putIfAbsentAndGet(String key, byte[] content) {\n+        putIfAbsent(key, content);\n+\n+        return content;\n+    }\n+\n+    /**\n+     * Writes the given content to the given {@link File}.\n+     *\n+     * @param fileInCache the {@link File}\n+     * @param content the content to be written\n+     */\n+    private void writeFile(File fileInCache, byte[] content) {\n+        logger.debug(\"Caching file '{}'\", fileInCache.getName());\n+        try {\n+            Files.write(fileInCache.toPath(), content);\n+        } catch (IOException e) {\n+            logger.warn(\"Could not write file '{}'\u00a0to cache\", fileInCache.getName(), e);\n+        }\n+    }\n+\n+    /**\n+     * Checks if the key is present in the cache.\n+     *\n+     * @param key the key whose presence in the cache is to be tested\n+     * @return true if the cache contains a file for the specified key\n+     */\n+    public boolean containsKey(String key) {\n+        return getUniqueFile(key).exists();\n+    }\n+\n+    /**\n+     * Removes the file associated with the given key from the cache.\n+     *\n+     * @param key the key whose associated file is to be removed\n+     */\n+    public void remove(String key) {\n+        deleteFile(getUniqueFile(key));\n+    }\n+\n+    /**\n+     * Deletes the given {@link File}.\n+     *\n+     * @param fileInCache the {@link File}\n+     */\n+    private void deleteFile(File fileInCache) {\n+        if (fileInCache.exists()) {\n+            logger.debug(\"Deleting file '{}' from cache\", fileInCache.getName());\n+            fileInCache.delete();\n+        } else {\n+            logger.debug(\"File '{}' not found in cache\", fileInCache.getName());\n+        }\n+    }\n+\n+    /**\n+     * Removes all files from the cache.\n+     */\n+    public void clear() {\n+        File[] filesInCache = cacheFolder.listFiles();\n+        if (filesInCache != null && filesInCache.length > 0) {\n+            logger.debug(\"Deleting all files from cache\");\n+            Arrays.stream(filesInCache).forEach(File::delete);\n+        }\n+    }\n+\n+    /**\n+     * Removes expired files from the cache.\n+     */\n+    public void clearExpired() {\n+        // exit if expiry is set to 0 (disabled)\n+        if (expiry <= 0) {\n+            return;\n+        }\n+        File[] filesInCache = cacheFolder.listFiles();\n+        if (filesInCache != null && filesInCache.length > 0) {\n+            logger.debug(\"Deleting expired files from cache\");\n+            Arrays.stream(filesInCache).filter(file -> isExpired(file)).forEach(File::delete);\n+        }\n+    }\n+\n+    /**\n+     * Checks if the given {@link File} is expired.\n+     *\n+     * @param fileInCache the {@link File}\n+     * @return <code>true</code> if the file is expired, <code>false</code> otherwise\n+     */\n+    private boolean isExpired(File fileInCache) {\n+        // exit if expiry is set to 0 (disabled)\n+        if (expiry <= 0) {\n+            return false;\n+        }\n+        return expiry * ONE_DAY_IN_MILLIS < System.currentTimeMillis() - fileInCache.lastModified();\n+    }\n+\n+    /**\n+     * Returns the content of the file associated with the given key, if it is present.\n+     *\n+     * @param key the key whose associated file is to be returned\n+     * @return the content of the file associated with the given key\n+     */\n+    public byte[] get(String key) {\n+        return readFile(getUniqueFile(key));\n+    }\n+\n+    /**\n+     * Reads the content from the given {@link File}, if it is present.\n+     *\n+     * @param fileInCache the {@link File}\n+     * @return the content of the file\n+     */\n+    private byte[] readFile(File fileInCache) {\n+        if (fileInCache.exists()) {\n+            logger.debug(\"Reading file '{}' from cache\", fileInCache.getName());\n+            // update time of last use\n+            fileInCache.setLastModified(System.currentTimeMillis());\n+            try {\n+                return Files.readAllBytes(fileInCache.toPath());\n+            } catch (IOException e) {\n+                logger.warn(\"Could not read file '{}'\u00a0from cache\", fileInCache.getName(), e);\n+            }\n+        } else {\n+            logger.debug(\"File '{}' not found in cache\", fileInCache.getName());\n+        }\n+        return new byte[0];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cda5702bde5734236034eb2f0864200e6211afbe"}, "originalPosition": 248}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQwNDM3MA==", "bodyText": "Surely there are simpler ways to generate a unique file name than using an MD5 hash. Wouldn't the hashcode of the key suffice?", "url": "https://github.com/openhab/openhab-addons/pull/7367#discussion_r408404370", "createdAt": "2020-04-14T20:09:20Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.chromecast/src/main/java/org/openhab/binding/chromecast/internal/utils/ByteArrayFileCache.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.chromecast.internal.utils;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.security.MessageDigest;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.ConfigConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This is a simple file based cache implementation.\n+ *\n+ * @author Christoph Weitkamp - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ByteArrayFileCache {\n+\n+    private final Logger logger = LoggerFactory.getLogger(ByteArrayFileCache.class);\n+\n+    private static final String MD5_ALGORITHM = \"MD5\";\n+\n+    static final String CACHE_FOLDER_NAME = \"cache\";\n+    private static final char EXTENSION_SEPARATOR = '.';\n+    private static final char UNIX_SEPARATOR = '/';\n+    private static final char WINDOWS_SEPARATOR = '\\\\';\n+\n+    private final File cacheFolder;\n+\n+    static final long ONE_DAY_IN_MILLIS = TimeUnit.DAYS.toMillis(1);\n+    private int expiry = 0;\n+\n+    private static final Map<String, File> FILES_IN_CACHE = new ConcurrentHashMap<>();\n+\n+    /**\n+     * Creates a new {@link ByteArrayFileCache} instance for a service. Creates a <code>cache</code> folder under\n+     * <code>$userdata/cache/$servicePID</code>.\n+     *\n+     * @param servicePID PID of the service\n+     */\n+    public ByteArrayFileCache(String servicePID) {\n+        // TODO track and limit folder size\n+        // TODO support user specific folder\n+        cacheFolder = new File(new File(ConfigConstants.getUserDataFolder(), CACHE_FOLDER_NAME), servicePID);\n+        if (!cacheFolder.exists()) {\n+            logger.debug(\"Creating cache folder '{}'\", cacheFolder.getAbsolutePath());\n+            cacheFolder.mkdirs();\n+        }\n+        logger.debug(\"Using cache folder '{}'\", cacheFolder.getAbsolutePath());\n+    }\n+\n+    /**\n+     * Creates a new {@link ByteArrayFileCache} instance for a service. Creates a <code>cache</code> folder under\n+     * <code>$userdata/cache/$servicePID/</code>.\n+     *\n+     * @param servicePID PID of the service\n+     * @param int the days for how long the files stay in the cache valid. Must be positive. 0 to\n+     *            disables this functionality.\n+     */\n+    public ByteArrayFileCache(String servicePID, int expiry) {\n+        this(servicePID);\n+        if (expiry < 0) {\n+            throw new IllegalArgumentException(\"Cache expiration time must be greater than or equal to 0\");\n+        }\n+        this.expiry = expiry;\n+    }\n+\n+    /**\n+     * Adds a file to the cache. If the cache previously contained a file for the key, the old file is replaced by the\n+     * new content.\n+     *\n+     * @param key the key with which the file is to be associated\n+     * @param content the content for the file to be associated with the specified key\n+     */\n+    public void put(String key, byte[] content) {\n+        writeFile(getUniqueFile(key), content);\n+    }\n+\n+    /**\n+     * Adds a file to the cache.\n+     *\n+     * @param key the key with which the file is to be associated\n+     * @param content the content for the file to be associated with the specified key\n+     */\n+    public void putIfAbsent(String key, byte[] content) {\n+        File fileInCache = getUniqueFile(key);\n+        if (fileInCache.exists()) {\n+            logger.debug(\"File '{}' present in cache\", fileInCache.getName());\n+            // update time of last use\n+            fileInCache.setLastModified(System.currentTimeMillis());\n+        } else {\n+            writeFile(fileInCache, content);\n+        }\n+    }\n+\n+    /**\n+     * Adds a file to the cache and returns the content of the file.\n+     *\n+     * @param key the key with which the file is to be associated\n+     * @param content the content for the file to be associated with the specified key\n+     * @return the content of the file associated with the given key\n+     */\n+    public byte[] putIfAbsentAndGet(String key, byte[] content) {\n+        putIfAbsent(key, content);\n+\n+        return content;\n+    }\n+\n+    /**\n+     * Writes the given content to the given {@link File}.\n+     *\n+     * @param fileInCache the {@link File}\n+     * @param content the content to be written\n+     */\n+    private void writeFile(File fileInCache, byte[] content) {\n+        logger.debug(\"Caching file '{}'\", fileInCache.getName());\n+        try {\n+            Files.write(fileInCache.toPath(), content);\n+        } catch (IOException e) {\n+            logger.warn(\"Could not write file '{}'\u00a0to cache\", fileInCache.getName(), e);\n+        }\n+    }\n+\n+    /**\n+     * Checks if the key is present in the cache.\n+     *\n+     * @param key the key whose presence in the cache is to be tested\n+     * @return true if the cache contains a file for the specified key\n+     */\n+    public boolean containsKey(String key) {\n+        return getUniqueFile(key).exists();\n+    }\n+\n+    /**\n+     * Removes the file associated with the given key from the cache.\n+     *\n+     * @param key the key whose associated file is to be removed\n+     */\n+    public void remove(String key) {\n+        deleteFile(getUniqueFile(key));\n+    }\n+\n+    /**\n+     * Deletes the given {@link File}.\n+     *\n+     * @param fileInCache the {@link File}\n+     */\n+    private void deleteFile(File fileInCache) {\n+        if (fileInCache.exists()) {\n+            logger.debug(\"Deleting file '{}' from cache\", fileInCache.getName());\n+            fileInCache.delete();\n+        } else {\n+            logger.debug(\"File '{}' not found in cache\", fileInCache.getName());\n+        }\n+    }\n+\n+    /**\n+     * Removes all files from the cache.\n+     */\n+    public void clear() {\n+        File[] filesInCache = cacheFolder.listFiles();\n+        if (filesInCache != null && filesInCache.length > 0) {\n+            logger.debug(\"Deleting all files from cache\");\n+            Arrays.stream(filesInCache).forEach(File::delete);\n+        }\n+    }\n+\n+    /**\n+     * Removes expired files from the cache.\n+     */\n+    public void clearExpired() {\n+        // exit if expiry is set to 0 (disabled)\n+        if (expiry <= 0) {\n+            return;\n+        }\n+        File[] filesInCache = cacheFolder.listFiles();\n+        if (filesInCache != null && filesInCache.length > 0) {\n+            logger.debug(\"Deleting expired files from cache\");\n+            Arrays.stream(filesInCache).filter(file -> isExpired(file)).forEach(File::delete);\n+        }\n+    }\n+\n+    /**\n+     * Checks if the given {@link File} is expired.\n+     *\n+     * @param fileInCache the {@link File}\n+     * @return <code>true</code> if the file is expired, <code>false</code> otherwise\n+     */\n+    private boolean isExpired(File fileInCache) {\n+        // exit if expiry is set to 0 (disabled)\n+        if (expiry <= 0) {\n+            return false;\n+        }\n+        return expiry * ONE_DAY_IN_MILLIS < System.currentTimeMillis() - fileInCache.lastModified();\n+    }\n+\n+    /**\n+     * Returns the content of the file associated with the given key, if it is present.\n+     *\n+     * @param key the key whose associated file is to be returned\n+     * @return the content of the file associated with the given key\n+     */\n+    public byte[] get(String key) {\n+        return readFile(getUniqueFile(key));\n+    }\n+\n+    /**\n+     * Reads the content from the given {@link File}, if it is present.\n+     *\n+     * @param fileInCache the {@link File}\n+     * @return the content of the file\n+     */\n+    private byte[] readFile(File fileInCache) {\n+        if (fileInCache.exists()) {\n+            logger.debug(\"Reading file '{}' from cache\", fileInCache.getName());\n+            // update time of last use\n+            fileInCache.setLastModified(System.currentTimeMillis());\n+            try {\n+                return Files.readAllBytes(fileInCache.toPath());\n+            } catch (IOException e) {\n+                logger.warn(\"Could not read file '{}'\u00a0from cache\", fileInCache.getName(), e);\n+            }\n+        } else {\n+            logger.debug(\"File '{}' not found in cache\", fileInCache.getName());\n+        }\n+        return new byte[0];\n+    }\n+\n+    /**\n+     * Creates a unique {@link File} from the key with which the file is to be associated.\n+     *\n+     * @param key the key with which the file is to be associated\n+     * @return unique file for the file associated with the given key\n+     */\n+    File getUniqueFile(String key) {\n+        String uniqueFileName = getUniqueFileName(key);\n+        if (FILES_IN_CACHE.containsKey(uniqueFileName)) {\n+            return FILES_IN_CACHE.get(uniqueFileName);\n+        } else {\n+            String fileExtension = getFileExtension(key);\n+            File fileInCache = new File(cacheFolder,\n+                    uniqueFileName + (fileExtension == null ? \"\" : EXTENSION_SEPARATOR + fileExtension));\n+            FILES_IN_CACHE.put(uniqueFileName, fileInCache);\n+            return fileInCache;\n+        }\n+    }\n+\n+    /**\n+     * Gets the extension of a file name.\n+     *\n+     * @param fileName the file name to retrieve the extension of\n+     * @return the extension of the file or null if none exists\n+     */\n+    @Nullable\n+    String getFileExtension(String fileName) {\n+        int extensionPos = fileName.lastIndexOf(EXTENSION_SEPARATOR);\n+        int lastSeparatorPos = Math.max(fileName.lastIndexOf(UNIX_SEPARATOR), fileName.lastIndexOf(WINDOWS_SEPARATOR));\n+        return lastSeparatorPos > extensionPos ? null : fileName.substring(extensionPos + 1).replaceFirst(\"\\\\?.*$\", \"\");\n+    }\n+\n+    /**\n+     * Creates a unique file name from the key with which the file is to be associated.\n+     *\n+     * @param key the key with which the file is to be associated\n+     * @return unique file name for the file associated with the given key\n+     */\n+    String getUniqueFileName(String key) {\n+        try {\n+            final MessageDigest md = MessageDigest.getInstance(MD5_ALGORITHM);\n+            return String.format(\"%032x\", new BigInteger(1, md.digest(key.getBytes(StandardCharsets.UTF_8))));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cda5702bde5734236034eb2f0864200e6211afbe"}, "originalPosition": 292}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0dbda82be1ce4c026a5cb83f1b278c155b152da0", "author": {"user": {"login": "cweitkamp", "name": "Christoph Weitkamp"}}, "url": "https://github.com/openhab/openhab-addons/commit/0dbda82be1ce4c026a5cb83f1b278c155b152da0", "committedDate": "2020-04-16T09:54:44Z", "message": "Refactoring of binding\n\nSigned-off-by: Christoph Weitkamp <github@christophweitkamp.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "982b81bd351dd5b41e3e53f88d9446a1d87d6f1d", "author": {"user": {"login": "cweitkamp", "name": "Christoph Weitkamp"}}, "url": "https://github.com/openhab/openhab-addons/commit/982b81bd351dd5b41e3e53f88d9446a1d87d6f1d", "committedDate": "2020-04-16T09:54:44Z", "message": "Incorporated comments from review\n\nSigned-off-by: Christoph Weitkamp <github@christophweitkamp.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "952e3f35d1dcefa99c17f049307a7c03b6b5a31a", "author": {"user": {"login": "cweitkamp", "name": "Christoph Weitkamp"}}, "url": "https://github.com/openhab/openhab-addons/commit/952e3f35d1dcefa99c17f049307a7c03b6b5a31a", "committedDate": "2020-04-16T09:54:45Z", "message": "Incorporated comments from review\n\nSigned-off-by: Christoph Weitkamp <github@christophweitkamp.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c84761fc800500d88dbd91a1ffa51123f1240728", "author": {"user": {"login": "cweitkamp", "name": "Christoph Weitkamp"}}, "url": "https://github.com/openhab/openhab-addons/commit/c84761fc800500d88dbd91a1ffa51123f1240728", "committedDate": "2020-04-16T09:54:45Z", "message": "Applied spotless formatter\n\nSigned-off-by: Christoph Weitkamp <github@christophweitkamp.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "57d5dcea711f2a8e30411ef55b25c31533df5ccd", "author": {"user": {"login": "cweitkamp", "name": "Christoph Weitkamp"}}, "url": "https://github.com/openhab/openhab-addons/commit/57d5dcea711f2a8e30411ef55b25c31533df5ccd", "committedDate": "2020-04-16T09:54:46Z", "message": "Annotated missing class\n\nSigned-off-by: Christoph Weitkamp <github@christophweitkamp.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "41c829467756bf99064eca16d637c1dea9502259", "author": {"user": {"login": "cweitkamp", "name": "Christoph Weitkamp"}}, "url": "https://github.com/openhab/openhab-addons/commit/41c829467756bf99064eca16d637c1dea9502259", "committedDate": "2020-04-16T10:39:14Z", "message": "Incorporated comments from review\n\nSigned-off-by: Christoph Weitkamp <github@christophweitkamp.de>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "cda5702bde5734236034eb2f0864200e6211afbe", "author": {"user": {"login": "cweitkamp", "name": "Christoph Weitkamp"}}, "url": "https://github.com/openhab/openhab-addons/commit/cda5702bde5734236034eb2f0864200e6211afbe", "committedDate": "2020-04-14T16:23:01Z", "message": "Annotated missing class\n\nSigned-off-by: Christoph Weitkamp <github@christophweitkamp.de>"}, "afterCommit": {"oid": "41c829467756bf99064eca16d637c1dea9502259", "author": {"user": {"login": "cweitkamp", "name": "Christoph Weitkamp"}}, "url": "https://github.com/openhab/openhab-addons/commit/41c829467756bf99064eca16d637c1dea9502259", "committedDate": "2020-04-16T10:39:14Z", "message": "Incorporated comments from review\n\nSigned-off-by: Christoph Weitkamp <github@christophweitkamp.de>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk1OTMzMDgy", "url": "https://github.com/openhab/openhab-addons/pull/7367#pullrequestreview-395933082", "createdAt": "2020-04-18T17:19:20Z", "commit": {"oid": "41c829467756bf99064eca16d637c1dea9502259"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 804, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}