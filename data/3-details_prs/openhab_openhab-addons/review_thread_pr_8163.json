{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDUzOTM1MTE3", "number": 8163, "reviewThreads": {"totalCount": 43, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMDoxMDoxMFrOERmUTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNlQxODoyNDoyMFrOEguJrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2ODg5MDM4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.modbus.studer/.gitignore", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMDoxMDoxMFrOG2Z2Cw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQyMjoyNjo1NVrOG2_U7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY5OTcyMw==", "bodyText": "Does this file found its way accidentally into your PR?", "url": "https://github.com/openhab/openhab-addons/pull/8163#discussion_r459699723", "createdAt": "2020-07-23T20:10:10Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.modbus.studer/.gitignore", "diffHunk": "@@ -0,0 +1,2 @@\n+/.apt_generated/", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0fec996bb398b4e6e9c879bea3c18f5108737a57"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDMxMzgzNg==", "bodyText": "Yes, accidentally it is here. In the next commit it will be deleted.", "url": "https://github.com/openhab/openhab-addons/pull/8163#discussion_r460313836", "createdAt": "2020-07-24T22:26:55Z", "author": {"login": "giovannimirulla"}, "path": "bundles/org.openhab.binding.modbus.studer/.gitignore", "diffHunk": "@@ -0,0 +1,2 @@\n+/.apt_generated/", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY5OTcyMw=="}, "originalCommit": {"oid": "0fec996bb398b4e6e9c879bea3c18f5108737a57"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2ODkyNDk5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.modbus.studer/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMDoyMDo1NVrOG2aLbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMDoyMDo1NVrOG2aLbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTcwNTE5OA==", "bodyText": "Can you add the Thing Type IDs, which need to be specified in the config? Alternatively you could replace the first column e.g. bsp instead of BSP.", "url": "https://github.com/openhab/openhab-addons/pull/8163#discussion_r459705198", "createdAt": "2020-07-23T20:20:55Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.modbus.studer/README.md", "diffHunk": "@@ -0,0 +1,142 @@\n+# Studer\n+\n+This extension adds support for the Studer protocol.\n+\n+Studer Innotec, founded in 1987 by Roland Studer, is an ISO certified company that develops and manufactures inverters, inverter/chargers and MPPT solar charge controllers to communicate over the Modbus protocol entirely in Switzerland \n+\n+For a list of certified products see this page: https://www.studer-innotec.com/\n+\n+## Supported Things\n+\n+This bundle adds the following thing type to the Modbus binding.\n+Note, that the things will show up under the Modbus binding.\n+\n+| Thing Type | Description |Picture |\n+| --- | --- | --- |\n+| BSP | For BSP that offer a highly precise measuring for Xtender, VarioTrack and VarioString systems | ![BSP](doc/bsp.png) |\n+| Xtender | For the Xtender models for system capacities from 0.5kVA to 72kVA that allow for the optimal use of available energy | ![Xtender](doc/xtender.png) |\n+| VarioTrack | For the VarioTrack models of MPPT solar charge controllers for systems with solar PV capacity from 1 - 75kWp | ![VarioTrack](doc/variotrack.png) |\n+| VarioString | For the VarioString models of MPPT solar charge controllers for systems with solar PV capacity from 4  | ![VarioString](doc/variostring.png) |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0fec996bb398b4e6e9c879bea3c18f5108737a57"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2ODkzMzQ4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.modbus.studer/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMDoyMzo0M1rOG2aQ4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMDoyMzo0M1rOG2aQ4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTcwNjU5NQ==", "bodyText": "Same for below\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            All channels readed for a BSP device\n          \n          \n            \n            All channels read for a BSP device", "url": "https://github.com/openhab/openhab-addons/pull/8163#discussion_r459706595", "createdAt": "2020-07-23T20:23:43Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.modbus.studer/README.md", "diffHunk": "@@ -0,0 +1,142 @@\n+# Studer\n+\n+This extension adds support for the Studer protocol.\n+\n+Studer Innotec, founded in 1987 by Roland Studer, is an ISO certified company that develops and manufactures inverters, inverter/chargers and MPPT solar charge controllers to communicate over the Modbus protocol entirely in Switzerland \n+\n+For a list of certified products see this page: https://www.studer-innotec.com/\n+\n+## Supported Things\n+\n+This bundle adds the following thing type to the Modbus binding.\n+Note, that the things will show up under the Modbus binding.\n+\n+| Thing Type | Description |Picture |\n+| --- | --- | --- |\n+| BSP | For BSP that offer a highly precise measuring for Xtender, VarioTrack and VarioString systems | ![BSP](doc/bsp.png) |\n+| Xtender | For the Xtender models for system capacities from 0.5kVA to 72kVA that allow for the optimal use of available energy | ![Xtender](doc/xtender.png) |\n+| VarioTrack | For the VarioTrack models of MPPT solar charge controllers for systems with solar PV capacity from 1 - 75kWp | ![VarioTrack](doc/variotrack.png) |\n+| VarioString | For the VarioString models of MPPT solar charge controllers for systems with solar PV capacity from 4  | ![VarioString](doc/variostring.png) |\n+\n+\n+## Thing Configuration\n+\n+You need first to set up a Serial Modbus bridge according to the Modbus documentation.\n+Things in this extension will use the selected bridge to connect to the device.\n+\n+For defining a thing textually, you have to find out the start address of the model block and the length of it.\n+While the length is usually fixed, the address is not.\n+Please refer to your device's vendor documentation how model blocks are laid for your equipment.\n+\n+The following parameters are valid for all thing types:\n+\n+| Parameter | Type    | Required | Default if omitted  | Description                             |\n+|-----------|---------|----------|---------------------|-----------------------------------------|\n+| address   | integer | yes      | `first slave of device`       | Address of slave       |\n+| refresh   | integer | yes       | 5                   | Poll interval in seconds. Increase this if you encounter connection errors |\n+\n+## Channels\n+\n+The following Channels, and their associated channel types are shown below divided by device.\n+\n+#### BSP \n+\n+All channels readed for a BSP device", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0fec996bb398b4e6e9c879bea3c18f5108737a57"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2ODkzNzgwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.modbus.studer/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMDoyNTowNVrOG2aTkw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMDoyNTowNVrOG2aTkw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTcwNzI4Mw==", "bodyText": "Since you use Units of Measure, you can do this:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Number XtenderStuderThing_InputVoltage \"Input Voltage [%.2f V]\"  \n          \n          \n            \n            Number XtenderStuderThing_InputVoltage \"Input Voltage [%.2f %unit%]\"", "url": "https://github.com/openhab/openhab-addons/pull/8163#discussion_r459707283", "createdAt": "2020-07-23T20:25:05Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.modbus.studer/README.md", "diffHunk": "@@ -0,0 +1,142 @@\n+# Studer\n+\n+This extension adds support for the Studer protocol.\n+\n+Studer Innotec, founded in 1987 by Roland Studer, is an ISO certified company that develops and manufactures inverters, inverter/chargers and MPPT solar charge controllers to communicate over the Modbus protocol entirely in Switzerland \n+\n+For a list of certified products see this page: https://www.studer-innotec.com/\n+\n+## Supported Things\n+\n+This bundle adds the following thing type to the Modbus binding.\n+Note, that the things will show up under the Modbus binding.\n+\n+| Thing Type | Description |Picture |\n+| --- | --- | --- |\n+| BSP | For BSP that offer a highly precise measuring for Xtender, VarioTrack and VarioString systems | ![BSP](doc/bsp.png) |\n+| Xtender | For the Xtender models for system capacities from 0.5kVA to 72kVA that allow for the optimal use of available energy | ![Xtender](doc/xtender.png) |\n+| VarioTrack | For the VarioTrack models of MPPT solar charge controllers for systems with solar PV capacity from 1 - 75kWp | ![VarioTrack](doc/variotrack.png) |\n+| VarioString | For the VarioString models of MPPT solar charge controllers for systems with solar PV capacity from 4  | ![VarioString](doc/variostring.png) |\n+\n+\n+## Thing Configuration\n+\n+You need first to set up a Serial Modbus bridge according to the Modbus documentation.\n+Things in this extension will use the selected bridge to connect to the device.\n+\n+For defining a thing textually, you have to find out the start address of the model block and the length of it.\n+While the length is usually fixed, the address is not.\n+Please refer to your device's vendor documentation how model blocks are laid for your equipment.\n+\n+The following parameters are valid for all thing types:\n+\n+| Parameter | Type    | Required | Default if omitted  | Description                             |\n+|-----------|---------|----------|---------------------|-----------------------------------------|\n+| address   | integer | yes      | `first slave of device`       | Address of slave       |\n+| refresh   | integer | yes       | 5                   | Poll interval in seconds. Increase this if you encounter connection errors |\n+\n+## Channels\n+\n+The following Channels, and their associated channel types are shown below divided by device.\n+\n+#### BSP \n+\n+All channels readed for a BSP device\n+\n+| Channel            | Type                     | Description           |\n+| ------------------ | ------------------------ | --------------------- |\n+| power              | Number:Power             | Power                 |\n+| batteryVoltage     | Number:ElectricPotential | Battery voltage       |\n+| batteryCurrent     | Number:ElectricCurrent   | Battery current       |\n+| stateOfCharge      | Number:Dimensionless     | State of Charge       |\n+| batteryTemperature | Number:Temperature       | Battery temperature   |\n+\n+#### Xtender \n+\n+All channels readed for a Xtender device\n+\n+| Channel           | Type                     | Description             |\n+| ----------------- | ------------------------ | ----------------------- |\n+| inputVoltage      | Number:ElectricPotential | Input voltage           |\n+| inputCurrent      | Number:ElectricCurrent   | Input current           |\n+| inputActivePower  | Number:Power             | Input active power      |\n+| inputFrequency    | Number:Frequency         | Input frequency         |\n+| outputVoltage     | Number:ElectricPotential | Output voltage          |\n+| outputCurrent     | Number:ElectricCurrent   | Output current          |\n+| outputActivePower | Number:Power             | Output active power     |\n+| outputFrequency   | Number:Frequency         | Output frequency        |\n+| operatingState    | String                   | Operating state         |\n+| stateInverter     | String                   | State of the inverter   |\n+\n+#### VarioTrack \n+\n+All channels readed for a VarioTrack device\n+\n+| Channel              | Type                     | Description                               |\n+| -------------------- | ------------------------ | ----------------------------------------- |\n+| modelVarioTrack      | String                   | Model of VarioTrack                       |\n+| voltagePVGenerator   | Number:ElectricPotential | Voltage of the PV generator               |\n+| powerPVGenerator     | Number:Power             | Power of the PV generator                 |\n+| productionCurrentDay | Number:Energy            | Production in (kWh) for the current day   |\n+| batteryVoltage       | Number:ElectricPotential | Battery voltage                           |\n+| batteryCurrent       | Number:ElectricCurrent   | Battery current                           |\n+| operatingMode        | String                   | Operating mode                            |\n+| stateVarioTrack      | String                   | State of the VarioTrack                   |\n+\n+#### VarioString \n+\n+All channels readed for a VarioString device\n+\n+| Channel                 | Type                     | Description                                   |\n+| ----------------------- | ------------------------ | --------------------------------------------- |\n+| PVVoltage               | Number:ElectricPotential | PV voltage                                    |\n+| PVCurrent               | Number:ElectricCurrent   | PV current                                    |\n+| PVPower                 | Number:Power             | PV power                                      |\n+| ProductionPVCurrentDay  | Number:Energy            | Production PV in (kWh) for the current day    |\n+| PV1Voltage              | Number:ElectricPotential | PV1 voltage                                   |\n+| PV1Current              | Number:ElectricCurrent   | PV1 current                                   |\n+| PV1Power                | Number:Power             | PV1 power                                     |\n+| ProductionPV1CurrentDay | Number:Energy            | Production PV1 in (kWh) for the current day   |\n+| PV2Voltage              | Number:ElectricPotential | PV2 voltage                                   |\n+| PV2Current              | Number:ElectricCurrent   | PV2 current                                   |\n+| PV2Power                | Number:Power             | PV2 power                                     |\n+| ProductionPV2CurrentDay | Number:Energy            | Production PV2 in (kWh) for the current day   |\n+| batteryVoltage          | Number:ElectricPotential | Battery voltage                               |\n+| batteryCurrent          | Number:ElectricCurrent   | Battery current                               |\n+| PVMode                  | String                   | PV operating mode                             |\n+| PV1Mode                 | String                   | PV1 operating mode                            |\n+| PV2Mode                 | String                   | PV2 operating mode                            |\n+| stateVarioString        | String                   | State of the VarioString                      |\n+\n+## Example\n+\n+### Thing Configuration\n+\n+```\n+Bridge modbus:serial:bridge [port=\"/dev/ttyUSB0\",baud=9600,dataBits=8,parity=\"even\",stopBits=\"1.0\",encoding=\"rtu\"]\n+Thing modbus:xtender:bridge:xtenderdevice \"Xtender\" (modbus:serial:modbusbridge) [ slaveAddress=10, refresh=5 ]\n+```\n+\n+Note: Make sure that refresh and slave address are numerical, without quotes.\n+\n+### Item Configuration\n+\n+```\n+Number XtenderStuderThing_InputVoltage \"Input Voltage [%.2f V]\"  ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0fec996bb398b4e6e9c879bea3c18f5108737a57"}, "originalPosition": 125}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2ODk1MTkxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.modbus.studer/src/main/java/org/openhab/binding/modbus/studer/internal/StuderConfiguration.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMDoyOTozN1rOG2acow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMDoyOTozN1rOG2acow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTcwOTYwMw==", "bodyText": "Is there a reason why you made this static?", "url": "https://github.com/openhab/openhab-addons/pull/8163#discussion_r459709603", "createdAt": "2020-07-23T20:29:37Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.modbus.studer/src/main/java/org/openhab/binding/modbus/studer/internal/StuderConfiguration.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.studer.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The {@link StuderConfiguration} class contains fields mapping thing configuration parameters.\n+ *\n+ * @author Giovanni Mirulla - Initial contribution\n+ */\n+@NonNullByDefault\n+public class StuderConfiguration {\n+\n+    /**\n+     * Refresh interval in seconds\n+     */\n+    private static int refresh = 5;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0fec996bb398b4e6e9c879bea3c18f5108737a57"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2ODk1NjAyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.modbus.studer/src/main/java/org/openhab/binding/modbus/studer/internal/StuderHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMDozMDo1MFrOG2afGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMDozMDo1MFrOG2afGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTcxMDIzMg==", "bodyText": "It's good practice to append the unit to the field name e.g. refreshSec.", "url": "https://github.com/openhab/openhab-addons/pull/8163#discussion_r459710232", "createdAt": "2020-07-23T20:30:50Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.modbus.studer/src/main/java/org/openhab/binding/modbus/studer/internal/StuderHandler.java", "diffHunk": "@@ -0,0 +1,460 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.studer.internal;\n+\n+import static org.openhab.binding.modbus.studer.internal.StuderBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.modbus.handler.EndpointNotInitializedException;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.ModeXtender;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.State;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VSMode;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VTMode;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VTType;\n+import org.openhab.io.transport.modbus.AsyncModbusFailure;\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link StuderHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Giovanni Mirulla - Initial contribution\n+ */\n+@SuppressWarnings(\"unused\")\n+@NonNullByDefault\n+public class StuderHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(StuderHandler.class);\n+\n+    private @Nullable StuderConfiguration config;\n+\n+    /**\n+     * Array of tasks used to poll the device\n+     */\n+    private ArrayList<PollTask> pollTasks = new ArrayList<PollTask>();\n+\n+    /**\n+     * Communication interface to the slave endpoint we're connecting to\n+     */\n+    protected volatile @Nullable ModbusCommunicationInterface comms = null;\n+\n+    /**\n+     * Importing parser methods and enums\n+     */\n+    final StuderParser parser = new StuderParser();\n+\n+    /**\n+     * Support variable for slave address\n+     */\n+    protected int slaveAddress;\n+\n+    /**\n+     * Support variable for refresh\n+     */\n+    protected final int refresh;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0fec996bb398b4e6e9c879bea3c18f5108737a57"}, "originalPosition": 89}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2ODk2OTc1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.modbus.studer/src/main/java/org/openhab/binding/modbus/studer/internal/StuderHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMDozNDo1MFrOG2anYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMDozNDo1MFrOG2anYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTcxMjM1Mw==", "bodyText": "You could initialize this field with en empty array to avoid declaring it as Nullable. Then, the suppression annotation can be removed, too.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Integer @Nullable [] registers;\n          \n          \n            \n                private Integer[] registers = new Integer[0];", "url": "https://github.com/openhab/openhab-addons/pull/8163#discussion_r459712353", "createdAt": "2020-07-23T20:34:50Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.modbus.studer/src/main/java/org/openhab/binding/modbus/studer/internal/StuderHandler.java", "diffHunk": "@@ -0,0 +1,460 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.studer.internal;\n+\n+import static org.openhab.binding.modbus.studer.internal.StuderBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.modbus.handler.EndpointNotInitializedException;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.ModeXtender;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.State;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VSMode;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VTMode;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VTType;\n+import org.openhab.io.transport.modbus.AsyncModbusFailure;\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link StuderHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Giovanni Mirulla - Initial contribution\n+ */\n+@SuppressWarnings(\"unused\")\n+@NonNullByDefault\n+public class StuderHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(StuderHandler.class);\n+\n+    private @Nullable StuderConfiguration config;\n+\n+    /**\n+     * Array of tasks used to poll the device\n+     */\n+    private ArrayList<PollTask> pollTasks = new ArrayList<PollTask>();\n+\n+    /**\n+     * Communication interface to the slave endpoint we're connecting to\n+     */\n+    protected volatile @Nullable ModbusCommunicationInterface comms = null;\n+\n+    /**\n+     * Importing parser methods and enums\n+     */\n+    final StuderParser parser = new StuderParser();\n+\n+    /**\n+     * Support variable for slave address\n+     */\n+    protected int slaveAddress;\n+\n+    /**\n+     * Support variable for refresh\n+     */\n+    protected final int refresh;\n+\n+    /**\n+     * Support variable for type of thing\n+     */\n+    protected final ThingTypeUID type;\n+\n+    /**\n+     * Array of registers of Studer slave to read, we store this once initialization is complete\n+     */\n+    private Integer @Nullable [] registers;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0fec996bb398b4e6e9c879bea3c18f5108737a57"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2ODk4MjY5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.modbus.studer/src/main/java/org/openhab/binding/modbus/studer/internal/StuderHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMDozODo0MVrOG2avKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMDozODo0MVrOG2avKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTcxNDM0NA==", "bodyText": "ciao is never used. What is your intention with this assignment?", "url": "https://github.com/openhab/openhab-addons/pull/8163#discussion_r459714344", "createdAt": "2020-07-23T20:38:41Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.modbus.studer/src/main/java/org/openhab/binding/modbus/studer/internal/StuderHandler.java", "diffHunk": "@@ -0,0 +1,460 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.studer.internal;\n+\n+import static org.openhab.binding.modbus.studer.internal.StuderBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.modbus.handler.EndpointNotInitializedException;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.ModeXtender;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.State;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VSMode;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VTMode;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VTType;\n+import org.openhab.io.transport.modbus.AsyncModbusFailure;\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link StuderHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Giovanni Mirulla - Initial contribution\n+ */\n+@SuppressWarnings(\"unused\")\n+@NonNullByDefault\n+public class StuderHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(StuderHandler.class);\n+\n+    private @Nullable StuderConfiguration config;\n+\n+    /**\n+     * Array of tasks used to poll the device\n+     */\n+    private ArrayList<PollTask> pollTasks = new ArrayList<PollTask>();\n+\n+    /**\n+     * Communication interface to the slave endpoint we're connecting to\n+     */\n+    protected volatile @Nullable ModbusCommunicationInterface comms = null;\n+\n+    /**\n+     * Importing parser methods and enums\n+     */\n+    final StuderParser parser = new StuderParser();\n+\n+    /**\n+     * Support variable for slave address\n+     */\n+    protected int slaveAddress;\n+\n+    /**\n+     * Support variable for refresh\n+     */\n+    protected final int refresh;\n+\n+    /**\n+     * Support variable for type of thing\n+     */\n+    protected final ThingTypeUID type;\n+\n+    /**\n+     * Array of registers of Studer slave to read, we store this once initialization is complete\n+     */\n+    private Integer @Nullable [] registers;\n+\n+    /**\n+     * Instances of this handler\n+     *\n+     * @param thing the thing to handle\n+     * @param type the type of thing to handle\n+     * @param slaveAddress the address of thing\n+     * @param refresh the address of thing\n+     */\n+    public StuderHandler(Thing thing, ThingTypeUID type, int slaveAddress, int refresh) {\n+        super(thing);\n+        this.type = type;\n+        this.slaveAddress = slaveAddress;\n+        this.refresh = refresh;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+\n+        // Currently we do not support any commands\n+    }\n+\n+    /**\n+     * Initialization:\n+     * Load the config object\n+     * Connect to the slave bridge\n+     * Get registers to poll\n+     * Start the periodic polling\n+     */\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(StuderConfiguration.class);\n+        startUp();\n+    }\n+\n+    /*\n+     * This method starts the operation of this handler\n+     * Connect to the slave bridge\n+     * Get registers to poll\n+     * Start the periodic polling\n+     */\n+    @SuppressWarnings(\"null\")\n+    private void startUp() {\n+\n+        connectEndpoint();\n+\n+        if (comms == null || config == null) {\n+            logger.debug(\"Invalid endpoint/config/manager ref for studer handler\");\n+            return;\n+        }\n+\n+        if (!pollTasks.isEmpty()) {\n+            return;\n+        }\n+\n+        if (type.equals(THING_TYPE_BSP)) {\n+            Set<Integer> keys = CHANNELS_BSP.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_XTENDER)) {\n+            Set<Integer> keys = CHANNELS_XTENDER.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_VARIOTRACK)) {\n+            Set<Integer> keys = CHANNELS_VARIOTRACK.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_VARIOSTRING)) {\n+            Set<Integer> keys = CHANNELS_VARIOSTRING.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        }\n+\n+        for (int r : registers) {\n+            registerPollTask(slaveAddress, r);\n+\n+        }\n+    }\n+\n+    /**\n+     * Dispose the binding correctly\n+     */\n+    @Override\n+    public void dispose() {\n+        tearDown();\n+    }\n+\n+    /**\n+     * Unregister the poll tasks and release the endpoint reference\n+     */\n+    private void tearDown() {\n+        unregisterPollTasks();\n+        unregisterEndpoint();\n+    }\n+\n+    /**\n+     * Get the endpoint handler from the bridge this handler is connected to\n+     * Checks that we're connected to the right type of bridge\n+     *\n+     * @return the endpoint handler or null if the bridge does not exist\n+     */\n+    private @Nullable ModbusEndpointThingHandler getEndpointThingHandler() {\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"Bridge is null\");\n+            return null;\n+        }\n+        if (bridge.getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Bridge is not online\");\n+            return null;\n+        }\n+\n+        ThingHandler handler = bridge.getHandler();\n+        if (handler == null) {\n+            logger.debug(\"Bridge handler is null\");\n+            return null;\n+        }\n+\n+        if (handler instanceof ModbusEndpointThingHandler) {\n+            ModbusEndpointThingHandler slaveEndpoint = (ModbusEndpointThingHandler) handler;\n+            return slaveEndpoint;\n+        } else {\n+            logger.debug(\"Unexpected bridge handler: {}\", handler);\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Get a reference to the modbus endpoint\n+     */\n+    private void connectEndpoint() {\n+        if (comms != null) {\n+            return;\n+        }\n+\n+        ModbusEndpointThingHandler slaveEndpointThingHandler = getEndpointThingHandler();\n+        if (slaveEndpointThingHandler == null) {\n+            @SuppressWarnings(\"null\")\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\n+                    String.format(\"Bridge '%s' is offline\", label));\n+            logger.debug(\"No bridge handler available -- aborting init for {}\", label);\n+            return;\n+        }\n+        try {\n+            int ciao = slaveEndpointThingHandler.getSlaveId();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0fec996bb398b4e6e9c879bea3c18f5108737a57"}, "originalPosition": 241}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2ODk4MzQ2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.modbus.studer/src/main/java/org/openhab/binding/modbus/studer/internal/StuderHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMDozODo1OVrOG2avog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMDozODo1OVrOG2avog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTcxNDQ2Ng==", "bodyText": "Do you ignore the exception by intention?", "url": "https://github.com/openhab/openhab-addons/pull/8163#discussion_r459714466", "createdAt": "2020-07-23T20:38:59Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.modbus.studer/src/main/java/org/openhab/binding/modbus/studer/internal/StuderHandler.java", "diffHunk": "@@ -0,0 +1,460 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.studer.internal;\n+\n+import static org.openhab.binding.modbus.studer.internal.StuderBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.modbus.handler.EndpointNotInitializedException;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.ModeXtender;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.State;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VSMode;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VTMode;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VTType;\n+import org.openhab.io.transport.modbus.AsyncModbusFailure;\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link StuderHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Giovanni Mirulla - Initial contribution\n+ */\n+@SuppressWarnings(\"unused\")\n+@NonNullByDefault\n+public class StuderHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(StuderHandler.class);\n+\n+    private @Nullable StuderConfiguration config;\n+\n+    /**\n+     * Array of tasks used to poll the device\n+     */\n+    private ArrayList<PollTask> pollTasks = new ArrayList<PollTask>();\n+\n+    /**\n+     * Communication interface to the slave endpoint we're connecting to\n+     */\n+    protected volatile @Nullable ModbusCommunicationInterface comms = null;\n+\n+    /**\n+     * Importing parser methods and enums\n+     */\n+    final StuderParser parser = new StuderParser();\n+\n+    /**\n+     * Support variable for slave address\n+     */\n+    protected int slaveAddress;\n+\n+    /**\n+     * Support variable for refresh\n+     */\n+    protected final int refresh;\n+\n+    /**\n+     * Support variable for type of thing\n+     */\n+    protected final ThingTypeUID type;\n+\n+    /**\n+     * Array of registers of Studer slave to read, we store this once initialization is complete\n+     */\n+    private Integer @Nullable [] registers;\n+\n+    /**\n+     * Instances of this handler\n+     *\n+     * @param thing the thing to handle\n+     * @param type the type of thing to handle\n+     * @param slaveAddress the address of thing\n+     * @param refresh the address of thing\n+     */\n+    public StuderHandler(Thing thing, ThingTypeUID type, int slaveAddress, int refresh) {\n+        super(thing);\n+        this.type = type;\n+        this.slaveAddress = slaveAddress;\n+        this.refresh = refresh;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+\n+        // Currently we do not support any commands\n+    }\n+\n+    /**\n+     * Initialization:\n+     * Load the config object\n+     * Connect to the slave bridge\n+     * Get registers to poll\n+     * Start the periodic polling\n+     */\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(StuderConfiguration.class);\n+        startUp();\n+    }\n+\n+    /*\n+     * This method starts the operation of this handler\n+     * Connect to the slave bridge\n+     * Get registers to poll\n+     * Start the periodic polling\n+     */\n+    @SuppressWarnings(\"null\")\n+    private void startUp() {\n+\n+        connectEndpoint();\n+\n+        if (comms == null || config == null) {\n+            logger.debug(\"Invalid endpoint/config/manager ref for studer handler\");\n+            return;\n+        }\n+\n+        if (!pollTasks.isEmpty()) {\n+            return;\n+        }\n+\n+        if (type.equals(THING_TYPE_BSP)) {\n+            Set<Integer> keys = CHANNELS_BSP.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_XTENDER)) {\n+            Set<Integer> keys = CHANNELS_XTENDER.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_VARIOTRACK)) {\n+            Set<Integer> keys = CHANNELS_VARIOTRACK.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_VARIOSTRING)) {\n+            Set<Integer> keys = CHANNELS_VARIOSTRING.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        }\n+\n+        for (int r : registers) {\n+            registerPollTask(slaveAddress, r);\n+\n+        }\n+    }\n+\n+    /**\n+     * Dispose the binding correctly\n+     */\n+    @Override\n+    public void dispose() {\n+        tearDown();\n+    }\n+\n+    /**\n+     * Unregister the poll tasks and release the endpoint reference\n+     */\n+    private void tearDown() {\n+        unregisterPollTasks();\n+        unregisterEndpoint();\n+    }\n+\n+    /**\n+     * Get the endpoint handler from the bridge this handler is connected to\n+     * Checks that we're connected to the right type of bridge\n+     *\n+     * @return the endpoint handler or null if the bridge does not exist\n+     */\n+    private @Nullable ModbusEndpointThingHandler getEndpointThingHandler() {\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"Bridge is null\");\n+            return null;\n+        }\n+        if (bridge.getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Bridge is not online\");\n+            return null;\n+        }\n+\n+        ThingHandler handler = bridge.getHandler();\n+        if (handler == null) {\n+            logger.debug(\"Bridge handler is null\");\n+            return null;\n+        }\n+\n+        if (handler instanceof ModbusEndpointThingHandler) {\n+            ModbusEndpointThingHandler slaveEndpoint = (ModbusEndpointThingHandler) handler;\n+            return slaveEndpoint;\n+        } else {\n+            logger.debug(\"Unexpected bridge handler: {}\", handler);\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Get a reference to the modbus endpoint\n+     */\n+    private void connectEndpoint() {\n+        if (comms != null) {\n+            return;\n+        }\n+\n+        ModbusEndpointThingHandler slaveEndpointThingHandler = getEndpointThingHandler();\n+        if (slaveEndpointThingHandler == null) {\n+            @SuppressWarnings(\"null\")\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\n+                    String.format(\"Bridge '%s' is offline\", label));\n+            logger.debug(\"No bridge handler available -- aborting init for {}\", label);\n+            return;\n+        }\n+        try {\n+            int ciao = slaveEndpointThingHandler.getSlaveId();\n+            comms = slaveEndpointThingHandler.getCommunicationInterface();\n+        } catch (EndpointNotInitializedException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0fec996bb398b4e6e9c879bea3c18f5108737a57"}, "originalPosition": 243}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2ODk5MDQ5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.modbus.studer/src/main/java/org/openhab/binding/modbus/studer/internal/StuderHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMDo0MTowN1rOG2az5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMDo0MTowN1rOG2az5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTcxNTU1OA==", "bodyText": "You could use the local variable, then the compiler doesn't complain.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (studerConfig == null || comms == null) {\n          \n          \n            \n                    if (studerConfig == null || mycomms == null) {", "url": "https://github.com/openhab/openhab-addons/pull/8163#discussion_r459715558", "createdAt": "2020-07-23T20:41:07Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.modbus.studer/src/main/java/org/openhab/binding/modbus/studer/internal/StuderHandler.java", "diffHunk": "@@ -0,0 +1,460 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.studer.internal;\n+\n+import static org.openhab.binding.modbus.studer.internal.StuderBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.modbus.handler.EndpointNotInitializedException;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.ModeXtender;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.State;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VSMode;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VTMode;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VTType;\n+import org.openhab.io.transport.modbus.AsyncModbusFailure;\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link StuderHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Giovanni Mirulla - Initial contribution\n+ */\n+@SuppressWarnings(\"unused\")\n+@NonNullByDefault\n+public class StuderHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(StuderHandler.class);\n+\n+    private @Nullable StuderConfiguration config;\n+\n+    /**\n+     * Array of tasks used to poll the device\n+     */\n+    private ArrayList<PollTask> pollTasks = new ArrayList<PollTask>();\n+\n+    /**\n+     * Communication interface to the slave endpoint we're connecting to\n+     */\n+    protected volatile @Nullable ModbusCommunicationInterface comms = null;\n+\n+    /**\n+     * Importing parser methods and enums\n+     */\n+    final StuderParser parser = new StuderParser();\n+\n+    /**\n+     * Support variable for slave address\n+     */\n+    protected int slaveAddress;\n+\n+    /**\n+     * Support variable for refresh\n+     */\n+    protected final int refresh;\n+\n+    /**\n+     * Support variable for type of thing\n+     */\n+    protected final ThingTypeUID type;\n+\n+    /**\n+     * Array of registers of Studer slave to read, we store this once initialization is complete\n+     */\n+    private Integer @Nullable [] registers;\n+\n+    /**\n+     * Instances of this handler\n+     *\n+     * @param thing the thing to handle\n+     * @param type the type of thing to handle\n+     * @param slaveAddress the address of thing\n+     * @param refresh the address of thing\n+     */\n+    public StuderHandler(Thing thing, ThingTypeUID type, int slaveAddress, int refresh) {\n+        super(thing);\n+        this.type = type;\n+        this.slaveAddress = slaveAddress;\n+        this.refresh = refresh;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+\n+        // Currently we do not support any commands\n+    }\n+\n+    /**\n+     * Initialization:\n+     * Load the config object\n+     * Connect to the slave bridge\n+     * Get registers to poll\n+     * Start the periodic polling\n+     */\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(StuderConfiguration.class);\n+        startUp();\n+    }\n+\n+    /*\n+     * This method starts the operation of this handler\n+     * Connect to the slave bridge\n+     * Get registers to poll\n+     * Start the periodic polling\n+     */\n+    @SuppressWarnings(\"null\")\n+    private void startUp() {\n+\n+        connectEndpoint();\n+\n+        if (comms == null || config == null) {\n+            logger.debug(\"Invalid endpoint/config/manager ref for studer handler\");\n+            return;\n+        }\n+\n+        if (!pollTasks.isEmpty()) {\n+            return;\n+        }\n+\n+        if (type.equals(THING_TYPE_BSP)) {\n+            Set<Integer> keys = CHANNELS_BSP.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_XTENDER)) {\n+            Set<Integer> keys = CHANNELS_XTENDER.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_VARIOTRACK)) {\n+            Set<Integer> keys = CHANNELS_VARIOTRACK.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_VARIOSTRING)) {\n+            Set<Integer> keys = CHANNELS_VARIOSTRING.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        }\n+\n+        for (int r : registers) {\n+            registerPollTask(slaveAddress, r);\n+\n+        }\n+    }\n+\n+    /**\n+     * Dispose the binding correctly\n+     */\n+    @Override\n+    public void dispose() {\n+        tearDown();\n+    }\n+\n+    /**\n+     * Unregister the poll tasks and release the endpoint reference\n+     */\n+    private void tearDown() {\n+        unregisterPollTasks();\n+        unregisterEndpoint();\n+    }\n+\n+    /**\n+     * Get the endpoint handler from the bridge this handler is connected to\n+     * Checks that we're connected to the right type of bridge\n+     *\n+     * @return the endpoint handler or null if the bridge does not exist\n+     */\n+    private @Nullable ModbusEndpointThingHandler getEndpointThingHandler() {\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"Bridge is null\");\n+            return null;\n+        }\n+        if (bridge.getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Bridge is not online\");\n+            return null;\n+        }\n+\n+        ThingHandler handler = bridge.getHandler();\n+        if (handler == null) {\n+            logger.debug(\"Bridge handler is null\");\n+            return null;\n+        }\n+\n+        if (handler instanceof ModbusEndpointThingHandler) {\n+            ModbusEndpointThingHandler slaveEndpoint = (ModbusEndpointThingHandler) handler;\n+            return slaveEndpoint;\n+        } else {\n+            logger.debug(\"Unexpected bridge handler: {}\", handler);\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Get a reference to the modbus endpoint\n+     */\n+    private void connectEndpoint() {\n+        if (comms != null) {\n+            return;\n+        }\n+\n+        ModbusEndpointThingHandler slaveEndpointThingHandler = getEndpointThingHandler();\n+        if (slaveEndpointThingHandler == null) {\n+            @SuppressWarnings(\"null\")\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\n+                    String.format(\"Bridge '%s' is offline\", label));\n+            logger.debug(\"No bridge handler available -- aborting init for {}\", label);\n+            return;\n+        }\n+        try {\n+            int ciao = slaveEndpointThingHandler.getSlaveId();\n+            comms = slaveEndpointThingHandler.getCommunicationInterface();\n+        } catch (EndpointNotInitializedException e) {\n+        }\n+        if (comms == null) {\n+            @SuppressWarnings(\"null\")\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\n+                    String.format(\"Bridge '%s' not completely initialized\", label));\n+            logger.debug(\"Bridge not initialized fully (no endpoint) -- aborting init for {}\", this);\n+            return;\n+        }\n+    }\n+\n+    /**\n+     * Remove the endpoint if exists\n+     */\n+    private void unregisterEndpoint() {\n+        // Comms will be close()'d by endpoint thing handler\n+        comms = null;\n+    }\n+\n+    private synchronized void unregisterPollTasks() {\n+        if (pollTasks.isEmpty()) {\n+            return;\n+        }\n+        logger.debug(\"Unregistering polling from ModbusManager\");\n+        @Nullable\n+        ModbusCommunicationInterface mycomms = comms;\n+        if (mycomms != null) {\n+            for (PollTask t : pollTasks) {\n+                mycomms.unregisterRegularPoll(t);\n+                pollTasks.remove(t);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Register poll task\n+     * This is where we set up our regular poller\n+     */\n+    @SuppressWarnings(\"null\")\n+    private synchronized void registerPollTask(int slaveAddress, int n) {\n+        if (pollTasks.size() >= registers.length) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+            throw new IllegalStateException(\"New pollTask invalid\");\n+        }\n+        @Nullable\n+        ModbusCommunicationInterface mycomms = comms;\n+        @Nullable\n+        StuderConfiguration studerConfig = config;\n+        if (studerConfig == null || comms == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0fec996bb398b4e6e9c879bea3c18f5108737a57"}, "originalPosition": 292}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2ODk5NzcwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.modbus.studer/src/main/java/org/openhab/binding/modbus/studer/internal/StuderHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMDo0MzoxMlrOG2a4IQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMDo0MzoxMlrOG2a4IQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTcxNjY0MQ==", "bodyText": "Can you use a speaking name for n? E.g. registerNumber", "url": "https://github.com/openhab/openhab-addons/pull/8163#discussion_r459716641", "createdAt": "2020-07-23T20:43:12Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.modbus.studer/src/main/java/org/openhab/binding/modbus/studer/internal/StuderHandler.java", "diffHunk": "@@ -0,0 +1,460 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.studer.internal;\n+\n+import static org.openhab.binding.modbus.studer.internal.StuderBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.modbus.handler.EndpointNotInitializedException;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.ModeXtender;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.State;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VSMode;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VTMode;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VTType;\n+import org.openhab.io.transport.modbus.AsyncModbusFailure;\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link StuderHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Giovanni Mirulla - Initial contribution\n+ */\n+@SuppressWarnings(\"unused\")\n+@NonNullByDefault\n+public class StuderHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(StuderHandler.class);\n+\n+    private @Nullable StuderConfiguration config;\n+\n+    /**\n+     * Array of tasks used to poll the device\n+     */\n+    private ArrayList<PollTask> pollTasks = new ArrayList<PollTask>();\n+\n+    /**\n+     * Communication interface to the slave endpoint we're connecting to\n+     */\n+    protected volatile @Nullable ModbusCommunicationInterface comms = null;\n+\n+    /**\n+     * Importing parser methods and enums\n+     */\n+    final StuderParser parser = new StuderParser();\n+\n+    /**\n+     * Support variable for slave address\n+     */\n+    protected int slaveAddress;\n+\n+    /**\n+     * Support variable for refresh\n+     */\n+    protected final int refresh;\n+\n+    /**\n+     * Support variable for type of thing\n+     */\n+    protected final ThingTypeUID type;\n+\n+    /**\n+     * Array of registers of Studer slave to read, we store this once initialization is complete\n+     */\n+    private Integer @Nullable [] registers;\n+\n+    /**\n+     * Instances of this handler\n+     *\n+     * @param thing the thing to handle\n+     * @param type the type of thing to handle\n+     * @param slaveAddress the address of thing\n+     * @param refresh the address of thing\n+     */\n+    public StuderHandler(Thing thing, ThingTypeUID type, int slaveAddress, int refresh) {\n+        super(thing);\n+        this.type = type;\n+        this.slaveAddress = slaveAddress;\n+        this.refresh = refresh;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+\n+        // Currently we do not support any commands\n+    }\n+\n+    /**\n+     * Initialization:\n+     * Load the config object\n+     * Connect to the slave bridge\n+     * Get registers to poll\n+     * Start the periodic polling\n+     */\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(StuderConfiguration.class);\n+        startUp();\n+    }\n+\n+    /*\n+     * This method starts the operation of this handler\n+     * Connect to the slave bridge\n+     * Get registers to poll\n+     * Start the periodic polling\n+     */\n+    @SuppressWarnings(\"null\")\n+    private void startUp() {\n+\n+        connectEndpoint();\n+\n+        if (comms == null || config == null) {\n+            logger.debug(\"Invalid endpoint/config/manager ref for studer handler\");\n+            return;\n+        }\n+\n+        if (!pollTasks.isEmpty()) {\n+            return;\n+        }\n+\n+        if (type.equals(THING_TYPE_BSP)) {\n+            Set<Integer> keys = CHANNELS_BSP.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_XTENDER)) {\n+            Set<Integer> keys = CHANNELS_XTENDER.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_VARIOTRACK)) {\n+            Set<Integer> keys = CHANNELS_VARIOTRACK.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_VARIOSTRING)) {\n+            Set<Integer> keys = CHANNELS_VARIOSTRING.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        }\n+\n+        for (int r : registers) {\n+            registerPollTask(slaveAddress, r);\n+\n+        }\n+    }\n+\n+    /**\n+     * Dispose the binding correctly\n+     */\n+    @Override\n+    public void dispose() {\n+        tearDown();\n+    }\n+\n+    /**\n+     * Unregister the poll tasks and release the endpoint reference\n+     */\n+    private void tearDown() {\n+        unregisterPollTasks();\n+        unregisterEndpoint();\n+    }\n+\n+    /**\n+     * Get the endpoint handler from the bridge this handler is connected to\n+     * Checks that we're connected to the right type of bridge\n+     *\n+     * @return the endpoint handler or null if the bridge does not exist\n+     */\n+    private @Nullable ModbusEndpointThingHandler getEndpointThingHandler() {\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"Bridge is null\");\n+            return null;\n+        }\n+        if (bridge.getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Bridge is not online\");\n+            return null;\n+        }\n+\n+        ThingHandler handler = bridge.getHandler();\n+        if (handler == null) {\n+            logger.debug(\"Bridge handler is null\");\n+            return null;\n+        }\n+\n+        if (handler instanceof ModbusEndpointThingHandler) {\n+            ModbusEndpointThingHandler slaveEndpoint = (ModbusEndpointThingHandler) handler;\n+            return slaveEndpoint;\n+        } else {\n+            logger.debug(\"Unexpected bridge handler: {}\", handler);\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Get a reference to the modbus endpoint\n+     */\n+    private void connectEndpoint() {\n+        if (comms != null) {\n+            return;\n+        }\n+\n+        ModbusEndpointThingHandler slaveEndpointThingHandler = getEndpointThingHandler();\n+        if (slaveEndpointThingHandler == null) {\n+            @SuppressWarnings(\"null\")\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\n+                    String.format(\"Bridge '%s' is offline\", label));\n+            logger.debug(\"No bridge handler available -- aborting init for {}\", label);\n+            return;\n+        }\n+        try {\n+            int ciao = slaveEndpointThingHandler.getSlaveId();\n+            comms = slaveEndpointThingHandler.getCommunicationInterface();\n+        } catch (EndpointNotInitializedException e) {\n+        }\n+        if (comms == null) {\n+            @SuppressWarnings(\"null\")\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\n+                    String.format(\"Bridge '%s' not completely initialized\", label));\n+            logger.debug(\"Bridge not initialized fully (no endpoint) -- aborting init for {}\", this);\n+            return;\n+        }\n+    }\n+\n+    /**\n+     * Remove the endpoint if exists\n+     */\n+    private void unregisterEndpoint() {\n+        // Comms will be close()'d by endpoint thing handler\n+        comms = null;\n+    }\n+\n+    private synchronized void unregisterPollTasks() {\n+        if (pollTasks.isEmpty()) {\n+            return;\n+        }\n+        logger.debug(\"Unregistering polling from ModbusManager\");\n+        @Nullable\n+        ModbusCommunicationInterface mycomms = comms;\n+        if (mycomms != null) {\n+            for (PollTask t : pollTasks) {\n+                mycomms.unregisterRegularPoll(t);\n+                pollTasks.remove(t);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Register poll task\n+     * This is where we set up our regular poller\n+     */\n+    @SuppressWarnings(\"null\")\n+    private synchronized void registerPollTask(int slaveAddress, int n) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0fec996bb398b4e6e9c879bea3c18f5108737a57"}, "originalPosition": 283}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2OTAwMjA1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.modbus.studer/src/main/java/org/openhab/binding/modbus/studer/internal/StuderHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMDo0NDozOFrOG2a65w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMDo0NDozOFrOG2a65w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTcxNzM1MQ==", "bodyText": "Can you remove this?", "url": "https://github.com/openhab/openhab-addons/pull/8163#discussion_r459717351", "createdAt": "2020-07-23T20:44:38Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.modbus.studer/src/main/java/org/openhab/binding/modbus/studer/internal/StuderHandler.java", "diffHunk": "@@ -0,0 +1,460 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.studer.internal;\n+\n+import static org.openhab.binding.modbus.studer.internal.StuderBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.modbus.handler.EndpointNotInitializedException;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.ModeXtender;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.State;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VSMode;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VTMode;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VTType;\n+import org.openhab.io.transport.modbus.AsyncModbusFailure;\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link StuderHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Giovanni Mirulla - Initial contribution\n+ */\n+@SuppressWarnings(\"unused\")\n+@NonNullByDefault\n+public class StuderHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(StuderHandler.class);\n+\n+    private @Nullable StuderConfiguration config;\n+\n+    /**\n+     * Array of tasks used to poll the device\n+     */\n+    private ArrayList<PollTask> pollTasks = new ArrayList<PollTask>();\n+\n+    /**\n+     * Communication interface to the slave endpoint we're connecting to\n+     */\n+    protected volatile @Nullable ModbusCommunicationInterface comms = null;\n+\n+    /**\n+     * Importing parser methods and enums\n+     */\n+    final StuderParser parser = new StuderParser();\n+\n+    /**\n+     * Support variable for slave address\n+     */\n+    protected int slaveAddress;\n+\n+    /**\n+     * Support variable for refresh\n+     */\n+    protected final int refresh;\n+\n+    /**\n+     * Support variable for type of thing\n+     */\n+    protected final ThingTypeUID type;\n+\n+    /**\n+     * Array of registers of Studer slave to read, we store this once initialization is complete\n+     */\n+    private Integer @Nullable [] registers;\n+\n+    /**\n+     * Instances of this handler\n+     *\n+     * @param thing the thing to handle\n+     * @param type the type of thing to handle\n+     * @param slaveAddress the address of thing\n+     * @param refresh the address of thing\n+     */\n+    public StuderHandler(Thing thing, ThingTypeUID type, int slaveAddress, int refresh) {\n+        super(thing);\n+        this.type = type;\n+        this.slaveAddress = slaveAddress;\n+        this.refresh = refresh;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+\n+        // Currently we do not support any commands\n+    }\n+\n+    /**\n+     * Initialization:\n+     * Load the config object\n+     * Connect to the slave bridge\n+     * Get registers to poll\n+     * Start the periodic polling\n+     */\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(StuderConfiguration.class);\n+        startUp();\n+    }\n+\n+    /*\n+     * This method starts the operation of this handler\n+     * Connect to the slave bridge\n+     * Get registers to poll\n+     * Start the periodic polling\n+     */\n+    @SuppressWarnings(\"null\")\n+    private void startUp() {\n+\n+        connectEndpoint();\n+\n+        if (comms == null || config == null) {\n+            logger.debug(\"Invalid endpoint/config/manager ref for studer handler\");\n+            return;\n+        }\n+\n+        if (!pollTasks.isEmpty()) {\n+            return;\n+        }\n+\n+        if (type.equals(THING_TYPE_BSP)) {\n+            Set<Integer> keys = CHANNELS_BSP.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_XTENDER)) {\n+            Set<Integer> keys = CHANNELS_XTENDER.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_VARIOTRACK)) {\n+            Set<Integer> keys = CHANNELS_VARIOTRACK.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_VARIOSTRING)) {\n+            Set<Integer> keys = CHANNELS_VARIOSTRING.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        }\n+\n+        for (int r : registers) {\n+            registerPollTask(slaveAddress, r);\n+\n+        }\n+    }\n+\n+    /**\n+     * Dispose the binding correctly\n+     */\n+    @Override\n+    public void dispose() {\n+        tearDown();\n+    }\n+\n+    /**\n+     * Unregister the poll tasks and release the endpoint reference\n+     */\n+    private void tearDown() {\n+        unregisterPollTasks();\n+        unregisterEndpoint();\n+    }\n+\n+    /**\n+     * Get the endpoint handler from the bridge this handler is connected to\n+     * Checks that we're connected to the right type of bridge\n+     *\n+     * @return the endpoint handler or null if the bridge does not exist\n+     */\n+    private @Nullable ModbusEndpointThingHandler getEndpointThingHandler() {\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"Bridge is null\");\n+            return null;\n+        }\n+        if (bridge.getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Bridge is not online\");\n+            return null;\n+        }\n+\n+        ThingHandler handler = bridge.getHandler();\n+        if (handler == null) {\n+            logger.debug(\"Bridge handler is null\");\n+            return null;\n+        }\n+\n+        if (handler instanceof ModbusEndpointThingHandler) {\n+            ModbusEndpointThingHandler slaveEndpoint = (ModbusEndpointThingHandler) handler;\n+            return slaveEndpoint;\n+        } else {\n+            logger.debug(\"Unexpected bridge handler: {}\", handler);\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Get a reference to the modbus endpoint\n+     */\n+    private void connectEndpoint() {\n+        if (comms != null) {\n+            return;\n+        }\n+\n+        ModbusEndpointThingHandler slaveEndpointThingHandler = getEndpointThingHandler();\n+        if (slaveEndpointThingHandler == null) {\n+            @SuppressWarnings(\"null\")\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\n+                    String.format(\"Bridge '%s' is offline\", label));\n+            logger.debug(\"No bridge handler available -- aborting init for {}\", label);\n+            return;\n+        }\n+        try {\n+            int ciao = slaveEndpointThingHandler.getSlaveId();\n+            comms = slaveEndpointThingHandler.getCommunicationInterface();\n+        } catch (EndpointNotInitializedException e) {\n+        }\n+        if (comms == null) {\n+            @SuppressWarnings(\"null\")\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\n+                    String.format(\"Bridge '%s' not completely initialized\", label));\n+            logger.debug(\"Bridge not initialized fully (no endpoint) -- aborting init for {}\", this);\n+            return;\n+        }\n+    }\n+\n+    /**\n+     * Remove the endpoint if exists\n+     */\n+    private void unregisterEndpoint() {\n+        // Comms will be close()'d by endpoint thing handler\n+        comms = null;\n+    }\n+\n+    private synchronized void unregisterPollTasks() {\n+        if (pollTasks.isEmpty()) {\n+            return;\n+        }\n+        logger.debug(\"Unregistering polling from ModbusManager\");\n+        @Nullable\n+        ModbusCommunicationInterface mycomms = comms;\n+        if (mycomms != null) {\n+            for (PollTask t : pollTasks) {\n+                mycomms.unregisterRegularPoll(t);\n+                pollTasks.remove(t);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Register poll task\n+     * This is where we set up our regular poller\n+     */\n+    @SuppressWarnings(\"null\")\n+    private synchronized void registerPollTask(int slaveAddress, int n) {\n+        if (pollTasks.size() >= registers.length) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+            throw new IllegalStateException(\"New pollTask invalid\");\n+        }\n+        @Nullable\n+        ModbusCommunicationInterface mycomms = comms;\n+        @Nullable\n+        StuderConfiguration studerConfig = config;\n+        if (studerConfig == null || comms == null) {\n+            throw new IllegalStateException(\"registerPollTask called without proper configuration\");\n+        }\n+\n+        logger.debug(\"Setting up regular polling\");\n+\n+        ModbusReadRequestBlueprint request = new ModbusReadRequestBlueprint(slaveAddress,\n+                ModbusReadFunctionCode.READ_INPUT_REGISTERS, n, 2, studerConfig.maxTries);\n+        long refreshMillis = 3 * 1000;\n+        PollTask pollTask = mycomms.registerRegularPoll(request, refreshMillis, 1000, result -> {\n+            if (result.getRegisters().isPresent()) {\n+                ModbusRegisterArray reg = result.getRegisters().get();\n+                handlePolledData(n, reg);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR);\n+                return;\n+            }\n+            if (getThing().getStatus() != ThingStatus.ONLINE) {\n+                updateStatus(ThingStatus.ONLINE);\n+            }\n+        }, this::handleError);\n+        pollTasks.add(pollTask);\n+    }\n+\n+    /**\n+     * This method is called each time new data has been polled from the modbus slave\n+     * The register array is first parsed, then each of the channels are updated\n+     * to the new values\n+     *\n+     * @param n register readed\n+     * @param registers byte array read from the modbus slave\n+     */\n+    protected void handlePolledData(int n, ModbusRegisterArray registers) {\n+        // TODO Auto-generated method stub", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0fec996bb398b4e6e9c879bea3c18f5108737a57"}, "originalPosition": 325}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2OTAwNDgyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.modbus.studer/src/main/java/org/openhab/binding/modbus/studer/internal/StuderHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMDo0NToyNFrOG2a8fA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMDo0NToyNFrOG2a8fA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTcxNzc1Ng==", "bodyText": "See above n.", "url": "https://github.com/openhab/openhab-addons/pull/8163#discussion_r459717756", "createdAt": "2020-07-23T20:45:24Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.modbus.studer/src/main/java/org/openhab/binding/modbus/studer/internal/StuderHandler.java", "diffHunk": "@@ -0,0 +1,460 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.studer.internal;\n+\n+import static org.openhab.binding.modbus.studer.internal.StuderBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.modbus.handler.EndpointNotInitializedException;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.ModeXtender;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.State;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VSMode;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VTMode;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VTType;\n+import org.openhab.io.transport.modbus.AsyncModbusFailure;\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link StuderHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Giovanni Mirulla - Initial contribution\n+ */\n+@SuppressWarnings(\"unused\")\n+@NonNullByDefault\n+public class StuderHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(StuderHandler.class);\n+\n+    private @Nullable StuderConfiguration config;\n+\n+    /**\n+     * Array of tasks used to poll the device\n+     */\n+    private ArrayList<PollTask> pollTasks = new ArrayList<PollTask>();\n+\n+    /**\n+     * Communication interface to the slave endpoint we're connecting to\n+     */\n+    protected volatile @Nullable ModbusCommunicationInterface comms = null;\n+\n+    /**\n+     * Importing parser methods and enums\n+     */\n+    final StuderParser parser = new StuderParser();\n+\n+    /**\n+     * Support variable for slave address\n+     */\n+    protected int slaveAddress;\n+\n+    /**\n+     * Support variable for refresh\n+     */\n+    protected final int refresh;\n+\n+    /**\n+     * Support variable for type of thing\n+     */\n+    protected final ThingTypeUID type;\n+\n+    /**\n+     * Array of registers of Studer slave to read, we store this once initialization is complete\n+     */\n+    private Integer @Nullable [] registers;\n+\n+    /**\n+     * Instances of this handler\n+     *\n+     * @param thing the thing to handle\n+     * @param type the type of thing to handle\n+     * @param slaveAddress the address of thing\n+     * @param refresh the address of thing\n+     */\n+    public StuderHandler(Thing thing, ThingTypeUID type, int slaveAddress, int refresh) {\n+        super(thing);\n+        this.type = type;\n+        this.slaveAddress = slaveAddress;\n+        this.refresh = refresh;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+\n+        // Currently we do not support any commands\n+    }\n+\n+    /**\n+     * Initialization:\n+     * Load the config object\n+     * Connect to the slave bridge\n+     * Get registers to poll\n+     * Start the periodic polling\n+     */\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(StuderConfiguration.class);\n+        startUp();\n+    }\n+\n+    /*\n+     * This method starts the operation of this handler\n+     * Connect to the slave bridge\n+     * Get registers to poll\n+     * Start the periodic polling\n+     */\n+    @SuppressWarnings(\"null\")\n+    private void startUp() {\n+\n+        connectEndpoint();\n+\n+        if (comms == null || config == null) {\n+            logger.debug(\"Invalid endpoint/config/manager ref for studer handler\");\n+            return;\n+        }\n+\n+        if (!pollTasks.isEmpty()) {\n+            return;\n+        }\n+\n+        if (type.equals(THING_TYPE_BSP)) {\n+            Set<Integer> keys = CHANNELS_BSP.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_XTENDER)) {\n+            Set<Integer> keys = CHANNELS_XTENDER.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_VARIOTRACK)) {\n+            Set<Integer> keys = CHANNELS_VARIOTRACK.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_VARIOSTRING)) {\n+            Set<Integer> keys = CHANNELS_VARIOSTRING.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        }\n+\n+        for (int r : registers) {\n+            registerPollTask(slaveAddress, r);\n+\n+        }\n+    }\n+\n+    /**\n+     * Dispose the binding correctly\n+     */\n+    @Override\n+    public void dispose() {\n+        tearDown();\n+    }\n+\n+    /**\n+     * Unregister the poll tasks and release the endpoint reference\n+     */\n+    private void tearDown() {\n+        unregisterPollTasks();\n+        unregisterEndpoint();\n+    }\n+\n+    /**\n+     * Get the endpoint handler from the bridge this handler is connected to\n+     * Checks that we're connected to the right type of bridge\n+     *\n+     * @return the endpoint handler or null if the bridge does not exist\n+     */\n+    private @Nullable ModbusEndpointThingHandler getEndpointThingHandler() {\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"Bridge is null\");\n+            return null;\n+        }\n+        if (bridge.getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Bridge is not online\");\n+            return null;\n+        }\n+\n+        ThingHandler handler = bridge.getHandler();\n+        if (handler == null) {\n+            logger.debug(\"Bridge handler is null\");\n+            return null;\n+        }\n+\n+        if (handler instanceof ModbusEndpointThingHandler) {\n+            ModbusEndpointThingHandler slaveEndpoint = (ModbusEndpointThingHandler) handler;\n+            return slaveEndpoint;\n+        } else {\n+            logger.debug(\"Unexpected bridge handler: {}\", handler);\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Get a reference to the modbus endpoint\n+     */\n+    private void connectEndpoint() {\n+        if (comms != null) {\n+            return;\n+        }\n+\n+        ModbusEndpointThingHandler slaveEndpointThingHandler = getEndpointThingHandler();\n+        if (slaveEndpointThingHandler == null) {\n+            @SuppressWarnings(\"null\")\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\n+                    String.format(\"Bridge '%s' is offline\", label));\n+            logger.debug(\"No bridge handler available -- aborting init for {}\", label);\n+            return;\n+        }\n+        try {\n+            int ciao = slaveEndpointThingHandler.getSlaveId();\n+            comms = slaveEndpointThingHandler.getCommunicationInterface();\n+        } catch (EndpointNotInitializedException e) {\n+        }\n+        if (comms == null) {\n+            @SuppressWarnings(\"null\")\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\n+                    String.format(\"Bridge '%s' not completely initialized\", label));\n+            logger.debug(\"Bridge not initialized fully (no endpoint) -- aborting init for {}\", this);\n+            return;\n+        }\n+    }\n+\n+    /**\n+     * Remove the endpoint if exists\n+     */\n+    private void unregisterEndpoint() {\n+        // Comms will be close()'d by endpoint thing handler\n+        comms = null;\n+    }\n+\n+    private synchronized void unregisterPollTasks() {\n+        if (pollTasks.isEmpty()) {\n+            return;\n+        }\n+        logger.debug(\"Unregistering polling from ModbusManager\");\n+        @Nullable\n+        ModbusCommunicationInterface mycomms = comms;\n+        if (mycomms != null) {\n+            for (PollTask t : pollTasks) {\n+                mycomms.unregisterRegularPoll(t);\n+                pollTasks.remove(t);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Register poll task\n+     * This is where we set up our regular poller\n+     */\n+    @SuppressWarnings(\"null\")\n+    private synchronized void registerPollTask(int slaveAddress, int n) {\n+        if (pollTasks.size() >= registers.length) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+            throw new IllegalStateException(\"New pollTask invalid\");\n+        }\n+        @Nullable\n+        ModbusCommunicationInterface mycomms = comms;\n+        @Nullable\n+        StuderConfiguration studerConfig = config;\n+        if (studerConfig == null || comms == null) {\n+            throw new IllegalStateException(\"registerPollTask called without proper configuration\");\n+        }\n+\n+        logger.debug(\"Setting up regular polling\");\n+\n+        ModbusReadRequestBlueprint request = new ModbusReadRequestBlueprint(slaveAddress,\n+                ModbusReadFunctionCode.READ_INPUT_REGISTERS, n, 2, studerConfig.maxTries);\n+        long refreshMillis = 3 * 1000;\n+        PollTask pollTask = mycomms.registerRegularPoll(request, refreshMillis, 1000, result -> {\n+            if (result.getRegisters().isPresent()) {\n+                ModbusRegisterArray reg = result.getRegisters().get();\n+                handlePolledData(n, reg);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR);\n+                return;\n+            }\n+            if (getThing().getStatus() != ThingStatus.ONLINE) {\n+                updateStatus(ThingStatus.ONLINE);\n+            }\n+        }, this::handleError);\n+        pollTasks.add(pollTask);\n+    }\n+\n+    /**\n+     * This method is called each time new data has been polled from the modbus slave\n+     * The register array is first parsed, then each of the channels are updated\n+     * to the new values\n+     *\n+     * @param n register readed\n+     * @param registers byte array read from the modbus slave\n+     */\n+    protected void handlePolledData(int n, ModbusRegisterArray registers) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0fec996bb398b4e6e9c879bea3c18f5108737a57"}, "originalPosition": 324}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2OTA0NzQ0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.modbus.studer/src/main/java/org/openhab/binding/modbus/studer/internal/StuderHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMDo1ODozOVrOG2bWMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMDo1ODozOVrOG2bWMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTcyNDMzNw==", "bodyText": "What do you expect to throw a NumberFormatException? The cast in line 331 will throw a ClassCastException if quantity is not a number. You could hexToFloat() let return the complex type Float, which can be null, too. Then, the cast is not needed.", "url": "https://github.com/openhab/openhab-addons/pull/8163#discussion_r459724337", "createdAt": "2020-07-23T20:58:39Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.modbus.studer/src/main/java/org/openhab/binding/modbus/studer/internal/StuderHandler.java", "diffHunk": "@@ -0,0 +1,460 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.studer.internal;\n+\n+import static org.openhab.binding.modbus.studer.internal.StuderBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.modbus.handler.EndpointNotInitializedException;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.ModeXtender;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.State;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VSMode;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VTMode;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VTType;\n+import org.openhab.io.transport.modbus.AsyncModbusFailure;\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link StuderHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Giovanni Mirulla - Initial contribution\n+ */\n+@SuppressWarnings(\"unused\")\n+@NonNullByDefault\n+public class StuderHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(StuderHandler.class);\n+\n+    private @Nullable StuderConfiguration config;\n+\n+    /**\n+     * Array of tasks used to poll the device\n+     */\n+    private ArrayList<PollTask> pollTasks = new ArrayList<PollTask>();\n+\n+    /**\n+     * Communication interface to the slave endpoint we're connecting to\n+     */\n+    protected volatile @Nullable ModbusCommunicationInterface comms = null;\n+\n+    /**\n+     * Importing parser methods and enums\n+     */\n+    final StuderParser parser = new StuderParser();\n+\n+    /**\n+     * Support variable for slave address\n+     */\n+    protected int slaveAddress;\n+\n+    /**\n+     * Support variable for refresh\n+     */\n+    protected final int refresh;\n+\n+    /**\n+     * Support variable for type of thing\n+     */\n+    protected final ThingTypeUID type;\n+\n+    /**\n+     * Array of registers of Studer slave to read, we store this once initialization is complete\n+     */\n+    private Integer @Nullable [] registers;\n+\n+    /**\n+     * Instances of this handler\n+     *\n+     * @param thing the thing to handle\n+     * @param type the type of thing to handle\n+     * @param slaveAddress the address of thing\n+     * @param refresh the address of thing\n+     */\n+    public StuderHandler(Thing thing, ThingTypeUID type, int slaveAddress, int refresh) {\n+        super(thing);\n+        this.type = type;\n+        this.slaveAddress = slaveAddress;\n+        this.refresh = refresh;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+\n+        // Currently we do not support any commands\n+    }\n+\n+    /**\n+     * Initialization:\n+     * Load the config object\n+     * Connect to the slave bridge\n+     * Get registers to poll\n+     * Start the periodic polling\n+     */\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(StuderConfiguration.class);\n+        startUp();\n+    }\n+\n+    /*\n+     * This method starts the operation of this handler\n+     * Connect to the slave bridge\n+     * Get registers to poll\n+     * Start the periodic polling\n+     */\n+    @SuppressWarnings(\"null\")\n+    private void startUp() {\n+\n+        connectEndpoint();\n+\n+        if (comms == null || config == null) {\n+            logger.debug(\"Invalid endpoint/config/manager ref for studer handler\");\n+            return;\n+        }\n+\n+        if (!pollTasks.isEmpty()) {\n+            return;\n+        }\n+\n+        if (type.equals(THING_TYPE_BSP)) {\n+            Set<Integer> keys = CHANNELS_BSP.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_XTENDER)) {\n+            Set<Integer> keys = CHANNELS_XTENDER.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_VARIOTRACK)) {\n+            Set<Integer> keys = CHANNELS_VARIOTRACK.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_VARIOSTRING)) {\n+            Set<Integer> keys = CHANNELS_VARIOSTRING.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        }\n+\n+        for (int r : registers) {\n+            registerPollTask(slaveAddress, r);\n+\n+        }\n+    }\n+\n+    /**\n+     * Dispose the binding correctly\n+     */\n+    @Override\n+    public void dispose() {\n+        tearDown();\n+    }\n+\n+    /**\n+     * Unregister the poll tasks and release the endpoint reference\n+     */\n+    private void tearDown() {\n+        unregisterPollTasks();\n+        unregisterEndpoint();\n+    }\n+\n+    /**\n+     * Get the endpoint handler from the bridge this handler is connected to\n+     * Checks that we're connected to the right type of bridge\n+     *\n+     * @return the endpoint handler or null if the bridge does not exist\n+     */\n+    private @Nullable ModbusEndpointThingHandler getEndpointThingHandler() {\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"Bridge is null\");\n+            return null;\n+        }\n+        if (bridge.getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Bridge is not online\");\n+            return null;\n+        }\n+\n+        ThingHandler handler = bridge.getHandler();\n+        if (handler == null) {\n+            logger.debug(\"Bridge handler is null\");\n+            return null;\n+        }\n+\n+        if (handler instanceof ModbusEndpointThingHandler) {\n+            ModbusEndpointThingHandler slaveEndpoint = (ModbusEndpointThingHandler) handler;\n+            return slaveEndpoint;\n+        } else {\n+            logger.debug(\"Unexpected bridge handler: {}\", handler);\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Get a reference to the modbus endpoint\n+     */\n+    private void connectEndpoint() {\n+        if (comms != null) {\n+            return;\n+        }\n+\n+        ModbusEndpointThingHandler slaveEndpointThingHandler = getEndpointThingHandler();\n+        if (slaveEndpointThingHandler == null) {\n+            @SuppressWarnings(\"null\")\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\n+                    String.format(\"Bridge '%s' is offline\", label));\n+            logger.debug(\"No bridge handler available -- aborting init for {}\", label);\n+            return;\n+        }\n+        try {\n+            int ciao = slaveEndpointThingHandler.getSlaveId();\n+            comms = slaveEndpointThingHandler.getCommunicationInterface();\n+        } catch (EndpointNotInitializedException e) {\n+        }\n+        if (comms == null) {\n+            @SuppressWarnings(\"null\")\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\n+                    String.format(\"Bridge '%s' not completely initialized\", label));\n+            logger.debug(\"Bridge not initialized fully (no endpoint) -- aborting init for {}\", this);\n+            return;\n+        }\n+    }\n+\n+    /**\n+     * Remove the endpoint if exists\n+     */\n+    private void unregisterEndpoint() {\n+        // Comms will be close()'d by endpoint thing handler\n+        comms = null;\n+    }\n+\n+    private synchronized void unregisterPollTasks() {\n+        if (pollTasks.isEmpty()) {\n+            return;\n+        }\n+        logger.debug(\"Unregistering polling from ModbusManager\");\n+        @Nullable\n+        ModbusCommunicationInterface mycomms = comms;\n+        if (mycomms != null) {\n+            for (PollTask t : pollTasks) {\n+                mycomms.unregisterRegularPoll(t);\n+                pollTasks.remove(t);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Register poll task\n+     * This is where we set up our regular poller\n+     */\n+    @SuppressWarnings(\"null\")\n+    private synchronized void registerPollTask(int slaveAddress, int n) {\n+        if (pollTasks.size() >= registers.length) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+            throw new IllegalStateException(\"New pollTask invalid\");\n+        }\n+        @Nullable\n+        ModbusCommunicationInterface mycomms = comms;\n+        @Nullable\n+        StuderConfiguration studerConfig = config;\n+        if (studerConfig == null || comms == null) {\n+            throw new IllegalStateException(\"registerPollTask called without proper configuration\");\n+        }\n+\n+        logger.debug(\"Setting up regular polling\");\n+\n+        ModbusReadRequestBlueprint request = new ModbusReadRequestBlueprint(slaveAddress,\n+                ModbusReadFunctionCode.READ_INPUT_REGISTERS, n, 2, studerConfig.maxTries);\n+        long refreshMillis = 3 * 1000;\n+        PollTask pollTask = mycomms.registerRegularPoll(request, refreshMillis, 1000, result -> {\n+            if (result.getRegisters().isPresent()) {\n+                ModbusRegisterArray reg = result.getRegisters().get();\n+                handlePolledData(n, reg);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR);\n+                return;\n+            }\n+            if (getThing().getStatus() != ThingStatus.ONLINE) {\n+                updateStatus(ThingStatus.ONLINE);\n+            }\n+        }, this::handleError);\n+        pollTasks.add(pollTask);\n+    }\n+\n+    /**\n+     * This method is called each time new data has been polled from the modbus slave\n+     * The register array is first parsed, then each of the channels are updated\n+     * to the new values\n+     *\n+     * @param n register readed\n+     * @param registers byte array read from the modbus slave\n+     */\n+    protected void handlePolledData(int n, ModbusRegisterArray registers) {\n+        // TODO Auto-generated method stub\n+        String hexString = registers.toHexString().toString();\n+        Object quantity = parser.hexToFloat(hexString);\n+        if (quantity != null) {\n+            try {\n+                if (type.equals(THING_TYPE_BSP)) {\n+                    updateState(CHANNELS_BSP.get(n), new QuantityType<>((float) quantity, UNIT_CHANNELS_BSP.get(n)));\n+                } else if (type.equals(THING_TYPE_XTENDER)) {\n+                    handlePolledDataXtender(n, quantity);\n+                } else if (type.equals(THING_TYPE_VARIOTRACK)) {\n+                    handlePolledDataVarioTrack(n, quantity);\n+                } else if (type.equals(THING_TYPE_VARIOSTRING)) {\n+                    handlePolledDataVarioString(n, quantity);\n+                }\n+            } catch (NumberFormatException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0fec996bb398b4e6e9c879bea3c18f5108737a57"}, "originalPosition": 339}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2OTA1Nzk0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.modbus.studer/src/main/java/org/openhab/binding/modbus/studer/internal/StuderHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMTowMTo1MFrOG2bcqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMTowMTo1MFrOG2bcqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTcyNTk5Mg==", "bodyText": "vsmode can't be null as getVSModeByCode() is declared as NonNull. So, this will always yield false. Same for below.", "url": "https://github.com/openhab/openhab-addons/pull/8163#discussion_r459725992", "createdAt": "2020-07-23T21:01:50Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.modbus.studer/src/main/java/org/openhab/binding/modbus/studer/internal/StuderHandler.java", "diffHunk": "@@ -0,0 +1,460 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.studer.internal;\n+\n+import static org.openhab.binding.modbus.studer.internal.StuderBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.modbus.handler.EndpointNotInitializedException;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.ModeXtender;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.State;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VSMode;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VTMode;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VTType;\n+import org.openhab.io.transport.modbus.AsyncModbusFailure;\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link StuderHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Giovanni Mirulla - Initial contribution\n+ */\n+@SuppressWarnings(\"unused\")\n+@NonNullByDefault\n+public class StuderHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(StuderHandler.class);\n+\n+    private @Nullable StuderConfiguration config;\n+\n+    /**\n+     * Array of tasks used to poll the device\n+     */\n+    private ArrayList<PollTask> pollTasks = new ArrayList<PollTask>();\n+\n+    /**\n+     * Communication interface to the slave endpoint we're connecting to\n+     */\n+    protected volatile @Nullable ModbusCommunicationInterface comms = null;\n+\n+    /**\n+     * Importing parser methods and enums\n+     */\n+    final StuderParser parser = new StuderParser();\n+\n+    /**\n+     * Support variable for slave address\n+     */\n+    protected int slaveAddress;\n+\n+    /**\n+     * Support variable for refresh\n+     */\n+    protected final int refresh;\n+\n+    /**\n+     * Support variable for type of thing\n+     */\n+    protected final ThingTypeUID type;\n+\n+    /**\n+     * Array of registers of Studer slave to read, we store this once initialization is complete\n+     */\n+    private Integer @Nullable [] registers;\n+\n+    /**\n+     * Instances of this handler\n+     *\n+     * @param thing the thing to handle\n+     * @param type the type of thing to handle\n+     * @param slaveAddress the address of thing\n+     * @param refresh the address of thing\n+     */\n+    public StuderHandler(Thing thing, ThingTypeUID type, int slaveAddress, int refresh) {\n+        super(thing);\n+        this.type = type;\n+        this.slaveAddress = slaveAddress;\n+        this.refresh = refresh;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+\n+        // Currently we do not support any commands\n+    }\n+\n+    /**\n+     * Initialization:\n+     * Load the config object\n+     * Connect to the slave bridge\n+     * Get registers to poll\n+     * Start the periodic polling\n+     */\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(StuderConfiguration.class);\n+        startUp();\n+    }\n+\n+    /*\n+     * This method starts the operation of this handler\n+     * Connect to the slave bridge\n+     * Get registers to poll\n+     * Start the periodic polling\n+     */\n+    @SuppressWarnings(\"null\")\n+    private void startUp() {\n+\n+        connectEndpoint();\n+\n+        if (comms == null || config == null) {\n+            logger.debug(\"Invalid endpoint/config/manager ref for studer handler\");\n+            return;\n+        }\n+\n+        if (!pollTasks.isEmpty()) {\n+            return;\n+        }\n+\n+        if (type.equals(THING_TYPE_BSP)) {\n+            Set<Integer> keys = CHANNELS_BSP.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_XTENDER)) {\n+            Set<Integer> keys = CHANNELS_XTENDER.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_VARIOTRACK)) {\n+            Set<Integer> keys = CHANNELS_VARIOTRACK.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_VARIOSTRING)) {\n+            Set<Integer> keys = CHANNELS_VARIOSTRING.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        }\n+\n+        for (int r : registers) {\n+            registerPollTask(slaveAddress, r);\n+\n+        }\n+    }\n+\n+    /**\n+     * Dispose the binding correctly\n+     */\n+    @Override\n+    public void dispose() {\n+        tearDown();\n+    }\n+\n+    /**\n+     * Unregister the poll tasks and release the endpoint reference\n+     */\n+    private void tearDown() {\n+        unregisterPollTasks();\n+        unregisterEndpoint();\n+    }\n+\n+    /**\n+     * Get the endpoint handler from the bridge this handler is connected to\n+     * Checks that we're connected to the right type of bridge\n+     *\n+     * @return the endpoint handler or null if the bridge does not exist\n+     */\n+    private @Nullable ModbusEndpointThingHandler getEndpointThingHandler() {\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"Bridge is null\");\n+            return null;\n+        }\n+        if (bridge.getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Bridge is not online\");\n+            return null;\n+        }\n+\n+        ThingHandler handler = bridge.getHandler();\n+        if (handler == null) {\n+            logger.debug(\"Bridge handler is null\");\n+            return null;\n+        }\n+\n+        if (handler instanceof ModbusEndpointThingHandler) {\n+            ModbusEndpointThingHandler slaveEndpoint = (ModbusEndpointThingHandler) handler;\n+            return slaveEndpoint;\n+        } else {\n+            logger.debug(\"Unexpected bridge handler: {}\", handler);\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Get a reference to the modbus endpoint\n+     */\n+    private void connectEndpoint() {\n+        if (comms != null) {\n+            return;\n+        }\n+\n+        ModbusEndpointThingHandler slaveEndpointThingHandler = getEndpointThingHandler();\n+        if (slaveEndpointThingHandler == null) {\n+            @SuppressWarnings(\"null\")\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\n+                    String.format(\"Bridge '%s' is offline\", label));\n+            logger.debug(\"No bridge handler available -- aborting init for {}\", label);\n+            return;\n+        }\n+        try {\n+            int ciao = slaveEndpointThingHandler.getSlaveId();\n+            comms = slaveEndpointThingHandler.getCommunicationInterface();\n+        } catch (EndpointNotInitializedException e) {\n+        }\n+        if (comms == null) {\n+            @SuppressWarnings(\"null\")\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\n+                    String.format(\"Bridge '%s' not completely initialized\", label));\n+            logger.debug(\"Bridge not initialized fully (no endpoint) -- aborting init for {}\", this);\n+            return;\n+        }\n+    }\n+\n+    /**\n+     * Remove the endpoint if exists\n+     */\n+    private void unregisterEndpoint() {\n+        // Comms will be close()'d by endpoint thing handler\n+        comms = null;\n+    }\n+\n+    private synchronized void unregisterPollTasks() {\n+        if (pollTasks.isEmpty()) {\n+            return;\n+        }\n+        logger.debug(\"Unregistering polling from ModbusManager\");\n+        @Nullable\n+        ModbusCommunicationInterface mycomms = comms;\n+        if (mycomms != null) {\n+            for (PollTask t : pollTasks) {\n+                mycomms.unregisterRegularPoll(t);\n+                pollTasks.remove(t);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Register poll task\n+     * This is where we set up our regular poller\n+     */\n+    @SuppressWarnings(\"null\")\n+    private synchronized void registerPollTask(int slaveAddress, int n) {\n+        if (pollTasks.size() >= registers.length) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+            throw new IllegalStateException(\"New pollTask invalid\");\n+        }\n+        @Nullable\n+        ModbusCommunicationInterface mycomms = comms;\n+        @Nullable\n+        StuderConfiguration studerConfig = config;\n+        if (studerConfig == null || comms == null) {\n+            throw new IllegalStateException(\"registerPollTask called without proper configuration\");\n+        }\n+\n+        logger.debug(\"Setting up regular polling\");\n+\n+        ModbusReadRequestBlueprint request = new ModbusReadRequestBlueprint(slaveAddress,\n+                ModbusReadFunctionCode.READ_INPUT_REGISTERS, n, 2, studerConfig.maxTries);\n+        long refreshMillis = 3 * 1000;\n+        PollTask pollTask = mycomms.registerRegularPoll(request, refreshMillis, 1000, result -> {\n+            if (result.getRegisters().isPresent()) {\n+                ModbusRegisterArray reg = result.getRegisters().get();\n+                handlePolledData(n, reg);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR);\n+                return;\n+            }\n+            if (getThing().getStatus() != ThingStatus.ONLINE) {\n+                updateStatus(ThingStatus.ONLINE);\n+            }\n+        }, this::handleError);\n+        pollTasks.add(pollTask);\n+    }\n+\n+    /**\n+     * This method is called each time new data has been polled from the modbus slave\n+     * The register array is first parsed, then each of the channels are updated\n+     * to the new values\n+     *\n+     * @param n register readed\n+     * @param registers byte array read from the modbus slave\n+     */\n+    protected void handlePolledData(int n, ModbusRegisterArray registers) {\n+        // TODO Auto-generated method stub\n+        String hexString = registers.toHexString().toString();\n+        Object quantity = parser.hexToFloat(hexString);\n+        if (quantity != null) {\n+            try {\n+                if (type.equals(THING_TYPE_BSP)) {\n+                    updateState(CHANNELS_BSP.get(n), new QuantityType<>((float) quantity, UNIT_CHANNELS_BSP.get(n)));\n+                } else if (type.equals(THING_TYPE_XTENDER)) {\n+                    handlePolledDataXtender(n, quantity);\n+                } else if (type.equals(THING_TYPE_VARIOTRACK)) {\n+                    handlePolledDataVarioTrack(n, quantity);\n+                } else if (type.equals(THING_TYPE_VARIOSTRING)) {\n+                    handlePolledDataVarioString(n, quantity);\n+                }\n+            } catch (NumberFormatException e) {\n+                // Do nothing\n+            }\n+        }\n+        resetCommunicationError();\n+    }\n+\n+    /**\n+     * This method is called each time new data has been polled from the VarioString slave\n+     * The register array is first parsed, then each of the channels are updated\n+     * to the new values\n+     */\n+    @SuppressWarnings(\"null\")\n+    protected void handlePolledDataVarioString(int n, Object quantity) {\n+        switch (CHANNELS_VARIOSTRING.get(n)) {\n+            case CHANNEL_PV_OPERATING_MODE:\n+            case CHANNEL_PV1_OPERATING_MODE:\n+            case CHANNEL_PV2_OPERATING_MODE:\n+                VSMode vsmode = StuderParser.getVSModeByCode((int) (float) quantity);\n+                updateState(CHANNELS_VARIOSTRING.get(n),\n+                        vsmode == null ? UnDefType.UNDEF : new StringType(vsmode.name()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0fec996bb398b4e6e9c879bea3c18f5108737a57"}, "originalPosition": 359}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2OTA3Njg1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.modbus.studer/src/main/java/org/openhab/binding/modbus/studer/internal/StuderHandlerFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMTowNzo1OVrOG2boPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMTowNzo1OVrOG2boPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTcyODk1Ng==", "bodyText": "Reading the configuration must be done in initialize() of the ThingHandler, because the ThingHandler object is re-used when the configuration is changed. In this case dispose() followed by initialize() is invoked on the same object.", "url": "https://github.com/openhab/openhab-addons/pull/8163#discussion_r459728956", "createdAt": "2020-07-23T21:07:59Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.modbus.studer/src/main/java/org/openhab/binding/modbus/studer/internal/StuderHandlerFactory.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.studer.internal;\n+\n+import static org.openhab.binding.modbus.studer.internal.StuderBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link StuderHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Giovanni Mirulla - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(configurationPid = \"binding.studer\", service = ThingHandlerFactory.class)\n+public class StuderHandlerFactory extends BaseThingHandlerFactory {\n+    /**\n+     * Logger instance\n+     */\n+    private final Logger logger = LoggerFactory.getLogger(StuderHandlerFactory.class);\n+\n+    @Override\n+    public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n+        return SUPPORTED_THING_TYPES_UIDS.contains(thingTypeUID);\n+    }\n+\n+    @Override\n+    protected @Nullable ThingHandler createHandler(Thing thing) {\n+        ThingTypeUID thingTypeUID = thing.getThingTypeUID();\n+        Configuration config = thing.getConfiguration();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0fec996bb398b4e6e9c879bea3c18f5108737a57"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2OTA5NDE0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.modbus.studer/src/main/java/org/openhab/binding/modbus/studer/internal/StuderHandlerFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMToxNDozMFrOG2bzag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMToxNDozMFrOG2bzag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTczMTgxOA==", "bodyText": "You could create a configuration DTO, which can be filled automatically by invoking BaseThingHandler.getConfigAs(). That would avoid such type checks. However, If you want to stick with this implementation, it's good practice to check the type with instanceof beforehand, instead of relying on catching a ClassCastException or a NullPointerException. Also, you might give the user an advise, in case he forgets to specify the slave address or used a wrong type.", "url": "https://github.com/openhab/openhab-addons/pull/8163#discussion_r459731818", "createdAt": "2020-07-23T21:14:30Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.modbus.studer/src/main/java/org/openhab/binding/modbus/studer/internal/StuderHandlerFactory.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.studer.internal;\n+\n+import static org.openhab.binding.modbus.studer.internal.StuderBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link StuderHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Giovanni Mirulla - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(configurationPid = \"binding.studer\", service = ThingHandlerFactory.class)\n+public class StuderHandlerFactory extends BaseThingHandlerFactory {\n+    /**\n+     * Logger instance\n+     */\n+    private final Logger logger = LoggerFactory.getLogger(StuderHandlerFactory.class);\n+\n+    @Override\n+    public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n+        return SUPPORTED_THING_TYPES_UIDS.contains(thingTypeUID);\n+    }\n+\n+    @Override\n+    protected @Nullable ThingHandler createHandler(Thing thing) {\n+        ThingTypeUID thingTypeUID = thing.getThingTypeUID();\n+        Configuration config = thing.getConfiguration();\n+        int slaveAddress = 0;\n+        try {\n+            slaveAddress = ((BigDecimal) config.get(SLAVE_ADDRESS)).intValue();\n+        } catch (Exception e) {\n+            // Do nothing\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0fec996bb398b4e6e9c879bea3c18f5108737a57"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2OTEwNjk5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.modbus.studer/src/main/java/org/openhab/binding/modbus/studer/internal/StuderParser.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMToxODo0N1rOG2b7RA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMToxODo0N1rOG2b7RA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTczMzgyOA==", "bodyText": "You should specify the concrete exception you want to catch, since catching Exception catches also all runtime exceptions.", "url": "https://github.com/openhab/openhab-addons/pull/8163#discussion_r459733828", "createdAt": "2020-07-23T21:18:47Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.modbus.studer/src/main/java/org/openhab/binding/modbus/studer/internal/StuderParser.java", "diffHunk": "@@ -0,0 +1,237 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.studer.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link StuderParser} class with helper method\n+ * and possible values for mode and state\n+ *\n+ * @author Giovanni Mirulla - Initial contribution\n+ */\n+@NonNullByDefault\n+public class StuderParser {\n+    public enum ModeXtender {\n+        INVALID(0),\n+        INVERTER(1),\n+        CHARGER(2),\n+        BOOST(3),\n+        INJECTION(4),\n+        UNKNOWN(-1);\n+\n+        private final int code;\n+\n+        ModeXtender(int code) {\n+            this.code = code;\n+        }\n+\n+        public int code() {\n+            return this.code;\n+        }\n+    }\n+\n+    public static ModeXtender getModeXtenderByCode(int code) {\n+        switch (code) {\n+            case 0:\n+                return ModeXtender.INVALID;\n+            case 1:\n+                return ModeXtender.INVERTER;\n+            case 2:\n+                return ModeXtender.CHARGER;\n+            case 3:\n+                return ModeXtender.BOOST;\n+            case 4:\n+                return ModeXtender.INJECTION;\n+            default:\n+                return ModeXtender.UNKNOWN;\n+        }\n+    }\n+\n+    public enum State {\n+        OFF(0),\n+        ON(1),\n+        UNKNOWN(-1);\n+\n+        private final int code;\n+\n+        State(int code) {\n+            this.code = code;\n+        }\n+\n+        public int code() {\n+            return this.code;\n+        }\n+    }\n+\n+    public static State getStateByCode(int code) {\n+        switch (code) {\n+            case 0:\n+                return State.OFF;\n+            case 1:\n+                return State.ON;\n+            default:\n+                return State.UNKNOWN;\n+        }\n+    }\n+\n+    public enum VTType {\n+        VT80(0),\n+        VT65(1),\n+        UNKNOWN(-1);\n+\n+        private final int code;\n+\n+        VTType(int code) {\n+            this.code = code;\n+        }\n+\n+        public int code() {\n+            return this.code;\n+        }\n+    }\n+\n+    public static VTType getVTTypeByCode(int code) {\n+        switch (code) {\n+            case 0:\n+                return VTType.VT80;\n+            case 1:\n+                return VTType.VT65;\n+            default:\n+                return VTType.UNKNOWN;\n+        }\n+    }\n+\n+    public enum VTMode {\n+        NIGHT(0),\n+        STARTUP(1),\n+        CHARGER(3),\n+        SECURITY(5),\n+        OFF(6),\n+        CHARGE(8),\n+        CHARGEV(9),\n+        CHARGEI(10),\n+        CHARGET(11),\n+        CHIBSP(12),\n+        UNKNOWN(-1);\n+\n+        private final int code;\n+\n+        VTMode(int code) {\n+            this.code = code;\n+        }\n+\n+        public int code() {\n+            return this.code;\n+        }\n+    }\n+\n+    public static VTMode getVTModeByCode(int code) {\n+        switch (code) {\n+            case 0:\n+                return VTMode.NIGHT;\n+            case 1:\n+                return VTMode.STARTUP;\n+            case 3:\n+                return VTMode.CHARGER;\n+            case 5:\n+                return VTMode.SECURITY;\n+            case 6:\n+                return VTMode.OFF;\n+            case 8:\n+                return VTMode.CHARGE;\n+            case 9:\n+                return VTMode.CHARGEV;\n+            case 10:\n+                return VTMode.CHARGEI;\n+            case 11:\n+                return VTMode.CHARGET;\n+            case 12:\n+                return VTMode.CHIBSP;\n+            default:\n+                return VTMode.UNKNOWN;\n+        }\n+    }\n+\n+    public enum VSMode {\n+        NIGHT(0),\n+        SECURITY(1),\n+        OFF(2),\n+        CHARGE(3),\n+        CHARGEV(4),\n+        CHARGEI(5),\n+        CHARGEP(6),\n+        CHARGEIPV(7),\n+        CHARGET(8),\n+        CHIBSP(10),\n+        UNKNOWN(-1);\n+\n+        private final int code;\n+\n+        VSMode(int code) {\n+            this.code = code;\n+        }\n+\n+        public int code() {\n+            return this.code;\n+        }\n+    }\n+\n+    public static VSMode getVSModeByCode(int code) {\n+        switch (code) {\n+            case 0:\n+                return VSMode.NIGHT;\n+            case 1:\n+                return VSMode.SECURITY;\n+            case 2:\n+                return VSMode.OFF;\n+            case 3:\n+                return VSMode.CHARGE;\n+            case 4:\n+                return VSMode.CHARGEV;\n+            case 5:\n+                return VSMode.CHARGEI;\n+            case 6:\n+                return VSMode.CHARGEP;\n+            case 7:\n+                return VSMode.CHARGEIPV;\n+            case 8:\n+                return VSMode.CHARGET;\n+            case 10:\n+                return VSMode.CHIBSP;\n+            default:\n+                return VSMode.UNKNOWN;\n+        }\n+    }\n+\n+    /**\n+     * Convert an hex string to float\n+     *\n+     * @param hex string to convert from\n+     * @return the converted float\n+     */\n+    public @Nullable Object hexToFloat(String hex) {\n+        String t = hex.replaceAll(\" \", \"\");\n+        try {\n+            float f = Float.intBitsToFloat((int) Long.parseLong(t, 16));\n+            if (Float.isNaN(f)) {\n+                return null;\n+            } else {\n+                return f;\n+            }\n+        } catch (Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0fec996bb398b4e6e9c879bea3c18f5108737a57"}, "originalPosition": 233}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2OTExODI4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.modbus.studer/src/main/resources/ESH-INF/thing/BSP-channel-types.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMToyMjoxNlrOG2cByw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQyMjozNDoyN1rOG2_cyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTczNTQ5OQ==", "bodyText": "Is the accuracy of all these values so high, that two digits after the decimal point are reasonable?", "url": "https://github.com/openhab/openhab-addons/pull/8163#discussion_r459735499", "createdAt": "2020-07-23T21:22:16Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.modbus.studer/src/main/resources/ESH-INF/thing/BSP-channel-types.xml", "diffHunk": "@@ -0,0 +1,21 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"modbus\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\" xsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<!-- Power Channel Type -->\n+\t<channel-type id=\"Pbat\">\n+\t\t<item-type>Number:Power</item-type>\n+\t\t<label>Power</label>\n+\t\t<state readOnly=\"true\" pattern=\"%.2f %unit%\" />", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0fec996bb398b4e6e9c879bea3c18f5108737a57"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDMxNTg1MQ==", "bodyText": "For more accurate actions yes. Use remains at the user's discretion", "url": "https://github.com/openhab/openhab-addons/pull/8163#discussion_r460315851", "createdAt": "2020-07-24T22:34:27Z", "author": {"login": "giovannimirulla"}, "path": "bundles/org.openhab.binding.modbus.studer/src/main/resources/ESH-INF/thing/BSP-channel-types.xml", "diffHunk": "@@ -0,0 +1,21 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"modbus\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\" xsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<!-- Power Channel Type -->\n+\t<channel-type id=\"Pbat\">\n+\t\t<item-type>Number:Power</item-type>\n+\t\t<label>Power</label>\n+\t\t<state readOnly=\"true\" pattern=\"%.2f %unit%\" />", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTczNTQ5OQ=="}, "originalCommit": {"oid": "0fec996bb398b4e6e9c879bea3c18f5108737a57"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2OTEyMDUwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.modbus.studer/src/main/resources/ESH-INF/thing/BSP-channel-types.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMToyMjo1MFrOG2cDDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMToyMjo1MFrOG2cDDA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTczNTgyMA==", "bodyText": "Words in labels should be capitalized. See https://www.openhab.org/docs/developer/bindings/thing-xml.html#formatting-labels-and-descriptions", "url": "https://github.com/openhab/openhab-addons/pull/8163#discussion_r459735820", "createdAt": "2020-07-23T21:22:50Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.modbus.studer/src/main/resources/ESH-INF/thing/BSP-channel-types.xml", "diffHunk": "@@ -0,0 +1,21 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"modbus\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\" xsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<!-- Power Channel Type -->\n+\t<channel-type id=\"Pbat\">\n+\t\t<item-type>Number:Power</item-type>\n+\t\t<label>Power</label>\n+\t\t<state readOnly=\"true\" pattern=\"%.2f %unit%\" />\n+\t</channel-type>\n+\t<!-- State of charge Channel Type -->\n+\t<channel-type id=\"SOC\">\n+\t\t<item-type>Number:Dimensionless</item-type>\n+\t\t<label>State of charge</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0fec996bb398b4e6e9c879bea3c18f5108737a57"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2OTEzNjAyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.modbus.studer/src/main/java/org/openhab/binding/modbus/studer/internal/StuderHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMToyODoxMVrOG2cMiA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMToyODoxMVrOG2cMiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTczODI0OA==", "bodyText": "This field is never used.", "url": "https://github.com/openhab/openhab-addons/pull/8163#discussion_r459738248", "createdAt": "2020-07-23T21:28:11Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.modbus.studer/src/main/java/org/openhab/binding/modbus/studer/internal/StuderHandler.java", "diffHunk": "@@ -0,0 +1,460 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.studer.internal;\n+\n+import static org.openhab.binding.modbus.studer.internal.StuderBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.modbus.handler.EndpointNotInitializedException;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.ModeXtender;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.State;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VSMode;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VTMode;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VTType;\n+import org.openhab.io.transport.modbus.AsyncModbusFailure;\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link StuderHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Giovanni Mirulla - Initial contribution\n+ */\n+@SuppressWarnings(\"unused\")\n+@NonNullByDefault\n+public class StuderHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(StuderHandler.class);\n+\n+    private @Nullable StuderConfiguration config;\n+\n+    /**\n+     * Array of tasks used to poll the device\n+     */\n+    private ArrayList<PollTask> pollTasks = new ArrayList<PollTask>();\n+\n+    /**\n+     * Communication interface to the slave endpoint we're connecting to\n+     */\n+    protected volatile @Nullable ModbusCommunicationInterface comms = null;\n+\n+    /**\n+     * Importing parser methods and enums\n+     */\n+    final StuderParser parser = new StuderParser();\n+\n+    /**\n+     * Support variable for slave address\n+     */\n+    protected int slaveAddress;\n+\n+    /**\n+     * Support variable for refresh\n+     */\n+    protected final int refresh;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0fec996bb398b4e6e9c879bea3c18f5108737a57"}, "originalPosition": 89}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2OTEzODkyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.modbus.studer/src/main/resources/ESH-INF/thing/thing-types.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMToyOToxMlrOG2cOUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMToyOToxMlrOG2cOUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTczODcwNw==", "bodyText": "\"Sample\"?", "url": "https://github.com/openhab/openhab-addons/pull/8163#discussion_r459738707", "createdAt": "2020-07-23T21:29:12Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.modbus.studer/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,140 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"modbus\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\" xsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<!-- BSP Thing Type -->\n+\t<thing-type id=\"bsp\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"serial\" />\n+\t\t</supported-bridge-type-refs>\n+\t\t<label>BSP Studer Thing</label>\n+\t\t<description>Sample thing for Studer BSP Device</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"batteryVoltage\" typeId=\"Ubat\" />\n+\t\t\t<channel id=\"batteryCurrent\" typeId=\"Ibat\" />\n+\t\t\t<channel id=\"power\" typeId=\"Pbat\" />\n+\t\t\t<channel id=\"stateOfCharge\" typeId=\"SOC\" />\n+\t\t\t<channel id=\"batteryTemperature\" typeId=\"Tbat\" />\n+\t\t</channels>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"slaveAddress\" type=\"integer\" min=\"60\" max=\"61\">\n+\t\t\t\t<label>Slave address</label>\n+\t\t\t\t<description>Slave address of BSP device</description>\n+\t\t\t\t<default>60</default>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refresh\" type=\"integer\" min=\"0\" unit=\"s\">\n+\t\t\t\t<label>Refresh Interval</label>\n+\t\t\t\t<description>Poll interval. Use zero to disable automatic polling.</description>\n+\t\t\t\t<default>5</default>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\t<!-- Xtender Thing Type -->\n+\t<thing-type id=\"xtender\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"serial\" />\n+\t\t</supported-bridge-type-refs>\n+\t\t<label>Xtender Studer Thing</label>\n+\t\t<description>Sample thing for Studer Xtender Device</description>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0fec996bb398b4e6e9c879bea3c18f5108737a57"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2OTE1MTA1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.modbus.studer/src/main/java/org/openhab/binding/modbus/studer/internal/StuderHandlerFactory.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMTozMzozMVrOG2cV5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yM1QyMTozMzozMVrOG2cV5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTc0MDY0Nw==", "bodyText": "The logger is never used.", "url": "https://github.com/openhab/openhab-addons/pull/8163#discussion_r459740647", "createdAt": "2020-07-23T21:33:31Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.modbus.studer/src/main/java/org/openhab/binding/modbus/studer/internal/StuderHandlerFactory.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.studer.internal;\n+\n+import static org.openhab.binding.modbus.studer.internal.StuderBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link StuderHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Giovanni Mirulla - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(configurationPid = \"binding.studer\", service = ThingHandlerFactory.class)\n+public class StuderHandlerFactory extends BaseThingHandlerFactory {\n+    /**\n+     * Logger instance\n+     */\n+    private final Logger logger = LoggerFactory.getLogger(StuderHandlerFactory.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0fec996bb398b4e6e9c879bea3c18f5108737a57"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3NDg0MDAxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.modbus.studer/src/main/java/org/openhab/binding/modbus/studer/internal/StuderHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNlQxNzowMTo0NlrOG3Nv5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNlQxNzowMTo0NlrOG3Nv5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU1MDExOA==", "bodyText": "Can you remove this? Same for 3 method annotations below.", "url": "https://github.com/openhab/openhab-addons/pull/8163#discussion_r460550118", "createdAt": "2020-07-26T17:01:46Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.modbus.studer/src/main/java/org/openhab/binding/modbus/studer/internal/StuderHandler.java", "diffHunk": "@@ -0,0 +1,432 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.studer.internal;\n+\n+import static org.openhab.binding.modbus.studer.internal.StuderBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.ModeXtender;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.State;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VSMode;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VTMode;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VTType;\n+import org.openhab.io.transport.modbus.AsyncModbusFailure;\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link StuderHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Giovanni Mirulla - Initial contribution\n+ */\n+@SuppressWarnings(\"unused\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1beda2af42278133bf6c04d0a361266dbcc601da"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3NDg0MDYzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.modbus.studer/src/main/java/org/openhab/binding/modbus/studer/internal/StuderHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNlQxNzowMjo0MlrOG3NwLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNlQxNzowMjo0MlrOG3NwLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU1MDE5MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    logger.debug(\"Initializing thing whit configuration: {}\", thing.getConfiguration());\n          \n          \n            \n                    logger.debug(\"Initializing thing with configuration: {}\", thing.getConfiguration());", "url": "https://github.com/openhab/openhab-addons/pull/8163#discussion_r460550191", "createdAt": "2020-07-26T17:02:42Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.modbus.studer/src/main/java/org/openhab/binding/modbus/studer/internal/StuderHandler.java", "diffHunk": "@@ -0,0 +1,432 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.studer.internal;\n+\n+import static org.openhab.binding.modbus.studer.internal.StuderBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.ModeXtender;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.State;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VSMode;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VTMode;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VTType;\n+import org.openhab.io.transport.modbus.AsyncModbusFailure;\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link StuderHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Giovanni Mirulla - Initial contribution\n+ */\n+@SuppressWarnings(\"unused\")\n+@NonNullByDefault\n+public class StuderHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(StuderHandler.class);\n+\n+    private @Nullable StuderConfiguration config;\n+\n+    /**\n+     * Array of tasks used to poll the device\n+     */\n+    private ArrayList<PollTask> pollTasks = new ArrayList<PollTask>();\n+\n+    /**\n+     * Communication interface to the slave endpoint we're connecting to\n+     */\n+    protected volatile @Nullable ModbusCommunicationInterface comms = null;\n+\n+    /**\n+     * Importing parser methods and enums\n+     */\n+    final StuderParser parser = new StuderParser();\n+    /**\n+     * Support variable for type of thing\n+     */\n+    protected ThingTypeUID type;\n+\n+    /**\n+     * Array of registers of Studer slave to read, we store this once initialization is complete\n+     */\n+    private Integer[] registers = new Integer[0];\n+\n+    /**\n+     * Instances of this handler\n+     *\n+     * @param thing the thing to handle\n+     * @param type the type of thing to handle\n+     * @param slaveAddress the address of thing\n+     * @param refreshSec the address of thing\n+     */\n+    public StuderHandler(Thing thing) {\n+        super(thing);\n+        this.type = thing.getThingTypeUID();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+\n+        // Currently we do not support any commands\n+    }\n+\n+    /**\n+     * Initialization:\n+     * Load the config object\n+     * Connect to the slave bridge\n+     * Get registers to poll\n+     * Start the periodic polling\n+     */\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(StuderConfiguration.class);\n+        logger.debug(\"Initializing thing whit configuration: {}\", thing.getConfiguration());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1beda2af42278133bf6c04d0a361266dbcc601da"}, "originalPosition": 118}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3NDg0NjAzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.modbus.studer/src/main/java/org/openhab/binding/modbus/studer/internal/StuderHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNlQxNzowODowMlrOG3NyoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNlQxNzowODowMlrOG3NyoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU1MDgxNg==", "bodyText": "These annotations can be removed. The compiler can detect it on local variables itself.", "url": "https://github.com/openhab/openhab-addons/pull/8163#discussion_r460550816", "createdAt": "2020-07-26T17:08:02Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.modbus.studer/src/main/java/org/openhab/binding/modbus/studer/internal/StuderHandler.java", "diffHunk": "@@ -0,0 +1,432 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.studer.internal;\n+\n+import static org.openhab.binding.modbus.studer.internal.StuderBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.ModeXtender;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.State;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VSMode;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VTMode;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VTType;\n+import org.openhab.io.transport.modbus.AsyncModbusFailure;\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link StuderHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Giovanni Mirulla - Initial contribution\n+ */\n+@SuppressWarnings(\"unused\")\n+@NonNullByDefault\n+public class StuderHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(StuderHandler.class);\n+\n+    private @Nullable StuderConfiguration config;\n+\n+    /**\n+     * Array of tasks used to poll the device\n+     */\n+    private ArrayList<PollTask> pollTasks = new ArrayList<PollTask>();\n+\n+    /**\n+     * Communication interface to the slave endpoint we're connecting to\n+     */\n+    protected volatile @Nullable ModbusCommunicationInterface comms = null;\n+\n+    /**\n+     * Importing parser methods and enums\n+     */\n+    final StuderParser parser = new StuderParser();\n+    /**\n+     * Support variable for type of thing\n+     */\n+    protected ThingTypeUID type;\n+\n+    /**\n+     * Array of registers of Studer slave to read, we store this once initialization is complete\n+     */\n+    private Integer[] registers = new Integer[0];\n+\n+    /**\n+     * Instances of this handler\n+     *\n+     * @param thing the thing to handle\n+     * @param type the type of thing to handle\n+     * @param slaveAddress the address of thing\n+     * @param refreshSec the address of thing\n+     */\n+    public StuderHandler(Thing thing) {\n+        super(thing);\n+        this.type = thing.getThingTypeUID();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+\n+        // Currently we do not support any commands\n+    }\n+\n+    /**\n+     * Initialization:\n+     * Load the config object\n+     * Connect to the slave bridge\n+     * Get registers to poll\n+     * Start the periodic polling\n+     */\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(StuderConfiguration.class);\n+        logger.debug(\"Initializing thing whit configuration: {}\", thing.getConfiguration());\n+\n+        startUp();\n+    }\n+\n+    /*\n+     * This method starts the operation of this handler\n+     * Connect to the slave bridge\n+     * Get registers to poll\n+     * Start the periodic polling\n+     */\n+    @SuppressWarnings(\"null\")\n+    private void startUp() {\n+\n+        connectEndpoint();\n+\n+        if (comms == null || config == null) {\n+            logger.debug(\"Invalid endpoint/config/manager ref for studer handler\");\n+            return;\n+        }\n+\n+        if (!pollTasks.isEmpty()) {\n+            return;\n+        }\n+\n+        if (type.equals(THING_TYPE_BSP)) {\n+            Set<Integer> keys = CHANNELS_BSP.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_XTENDER)) {\n+            Set<Integer> keys = CHANNELS_XTENDER.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_VARIOTRACK)) {\n+            Set<Integer> keys = CHANNELS_VARIOTRACK.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_VARIOSTRING)) {\n+            Set<Integer> keys = CHANNELS_VARIOSTRING.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        }\n+\n+        for (int r : registers) {\n+            registerPollTask(r);\n+\n+        }\n+    }\n+\n+    /**\n+     * Dispose the binding correctly\n+     */\n+    @Override\n+    public void dispose() {\n+        tearDown();\n+    }\n+\n+    /**\n+     * Unregister the poll tasks and release the endpoint reference\n+     */\n+    private void tearDown() {\n+        unregisterPollTasks();\n+        unregisterEndpoint();\n+    }\n+\n+    /**\n+     * Get the endpoint handler from the bridge this handler is connected to\n+     * Checks that we're connected to the right type of bridge\n+     *\n+     * @return the endpoint handler or null if the bridge does not exist\n+     */\n+    private @Nullable ModbusEndpointThingHandler getEndpointThingHandler() {\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"Bridge is null\");\n+            return null;\n+        }\n+        if (bridge.getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Bridge is not online\");\n+            return null;\n+        }\n+\n+        ThingHandler handler = bridge.getHandler();\n+        if (handler == null) {\n+            logger.debug(\"Bridge handler is null\");\n+            return null;\n+        }\n+\n+        if (handler instanceof ModbusEndpointThingHandler) {\n+            ModbusEndpointThingHandler slaveEndpoint = (ModbusEndpointThingHandler) handler;\n+            return slaveEndpoint;\n+        } else {\n+            logger.debug(\"Unexpected bridge handler: {}\", handler);\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Get a reference to the modbus endpoint\n+     */\n+    private void connectEndpoint() {\n+        if (comms != null) {\n+            return;\n+        }\n+\n+        ModbusEndpointThingHandler slaveEndpointThingHandler = getEndpointThingHandler();\n+        if (slaveEndpointThingHandler == null) {\n+            @SuppressWarnings(\"null\")\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\n+                    String.format(\"Bridge '%s' is offline\", label));\n+            logger.debug(\"No bridge handler available -- aborting init for {}\", label);\n+            return;\n+        }\n+        comms = slaveEndpointThingHandler.getCommunicationInterface();\n+        if (comms == null) {\n+            @SuppressWarnings(\"null\")\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\n+                    String.format(\"Bridge '%s' not completely initialized\", label));\n+            logger.debug(\"Bridge not initialized fully (no endpoint) -- aborting init for {}\", this);\n+            return;\n+        }\n+    }\n+\n+    /**\n+     * Remove the endpoint if exists\n+     */\n+    private void unregisterEndpoint() {\n+        // Comms will be close()'d by endpoint thing handler\n+        comms = null;\n+    }\n+\n+    private synchronized void unregisterPollTasks() {\n+        if (pollTasks.isEmpty()) {\n+            return;\n+        }\n+        logger.debug(\"Unregistering polling from ModbusManager\");\n+        @Nullable\n+        ModbusCommunicationInterface mycomms = comms;\n+        if (mycomms != null) {\n+            for (PollTask t : pollTasks) {\n+                mycomms.unregisterRegularPoll(t);\n+            }\n+            pollTasks.clear();\n+        }\n+    }\n+\n+    /**\n+     * Register poll task\n+     * This is where we set up our regular poller\n+     */\n+    @SuppressWarnings(\"null\")\n+    private synchronized void registerPollTask(int registerNumber) {\n+        if (pollTasks.size() >= registers.length) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+            throw new IllegalStateException(\"New pollTask invalid\");\n+        }\n+        @Nullable\n+        ModbusCommunicationInterface mycomms = comms;\n+        @Nullable", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1beda2af42278133bf6c04d0a361266dbcc601da"}, "originalPosition": 274}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3NDg0OTc1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.modbus.studer/src/main/java/org/openhab/binding/modbus/studer/internal/StuderHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNlQxNzoxMjo0MlrOG3N0UQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yN1QxMjoxNDowMVrOG3f00g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU1MTI0OQ==", "bodyText": "This will throw an IllegalArgumentException, if the user doesn't set studerConfig.refreshSec or set it to 0. You could add a sanity check in initialize().", "url": "https://github.com/openhab/openhab-addons/pull/8163#discussion_r460551249", "createdAt": "2020-07-26T17:12:42Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.modbus.studer/src/main/java/org/openhab/binding/modbus/studer/internal/StuderHandler.java", "diffHunk": "@@ -0,0 +1,432 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.studer.internal;\n+\n+import static org.openhab.binding.modbus.studer.internal.StuderBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.ModeXtender;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.State;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VSMode;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VTMode;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VTType;\n+import org.openhab.io.transport.modbus.AsyncModbusFailure;\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link StuderHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Giovanni Mirulla - Initial contribution\n+ */\n+@SuppressWarnings(\"unused\")\n+@NonNullByDefault\n+public class StuderHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(StuderHandler.class);\n+\n+    private @Nullable StuderConfiguration config;\n+\n+    /**\n+     * Array of tasks used to poll the device\n+     */\n+    private ArrayList<PollTask> pollTasks = new ArrayList<PollTask>();\n+\n+    /**\n+     * Communication interface to the slave endpoint we're connecting to\n+     */\n+    protected volatile @Nullable ModbusCommunicationInterface comms = null;\n+\n+    /**\n+     * Importing parser methods and enums\n+     */\n+    final StuderParser parser = new StuderParser();\n+    /**\n+     * Support variable for type of thing\n+     */\n+    protected ThingTypeUID type;\n+\n+    /**\n+     * Array of registers of Studer slave to read, we store this once initialization is complete\n+     */\n+    private Integer[] registers = new Integer[0];\n+\n+    /**\n+     * Instances of this handler\n+     *\n+     * @param thing the thing to handle\n+     * @param type the type of thing to handle\n+     * @param slaveAddress the address of thing\n+     * @param refreshSec the address of thing\n+     */\n+    public StuderHandler(Thing thing) {\n+        super(thing);\n+        this.type = thing.getThingTypeUID();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+\n+        // Currently we do not support any commands\n+    }\n+\n+    /**\n+     * Initialization:\n+     * Load the config object\n+     * Connect to the slave bridge\n+     * Get registers to poll\n+     * Start the periodic polling\n+     */\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(StuderConfiguration.class);\n+        logger.debug(\"Initializing thing whit configuration: {}\", thing.getConfiguration());\n+\n+        startUp();\n+    }\n+\n+    /*\n+     * This method starts the operation of this handler\n+     * Connect to the slave bridge\n+     * Get registers to poll\n+     * Start the periodic polling\n+     */\n+    @SuppressWarnings(\"null\")\n+    private void startUp() {\n+\n+        connectEndpoint();\n+\n+        if (comms == null || config == null) {\n+            logger.debug(\"Invalid endpoint/config/manager ref for studer handler\");\n+            return;\n+        }\n+\n+        if (!pollTasks.isEmpty()) {\n+            return;\n+        }\n+\n+        if (type.equals(THING_TYPE_BSP)) {\n+            Set<Integer> keys = CHANNELS_BSP.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_XTENDER)) {\n+            Set<Integer> keys = CHANNELS_XTENDER.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_VARIOTRACK)) {\n+            Set<Integer> keys = CHANNELS_VARIOTRACK.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_VARIOSTRING)) {\n+            Set<Integer> keys = CHANNELS_VARIOSTRING.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        }\n+\n+        for (int r : registers) {\n+            registerPollTask(r);\n+\n+        }\n+    }\n+\n+    /**\n+     * Dispose the binding correctly\n+     */\n+    @Override\n+    public void dispose() {\n+        tearDown();\n+    }\n+\n+    /**\n+     * Unregister the poll tasks and release the endpoint reference\n+     */\n+    private void tearDown() {\n+        unregisterPollTasks();\n+        unregisterEndpoint();\n+    }\n+\n+    /**\n+     * Get the endpoint handler from the bridge this handler is connected to\n+     * Checks that we're connected to the right type of bridge\n+     *\n+     * @return the endpoint handler or null if the bridge does not exist\n+     */\n+    private @Nullable ModbusEndpointThingHandler getEndpointThingHandler() {\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"Bridge is null\");\n+            return null;\n+        }\n+        if (bridge.getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Bridge is not online\");\n+            return null;\n+        }\n+\n+        ThingHandler handler = bridge.getHandler();\n+        if (handler == null) {\n+            logger.debug(\"Bridge handler is null\");\n+            return null;\n+        }\n+\n+        if (handler instanceof ModbusEndpointThingHandler) {\n+            ModbusEndpointThingHandler slaveEndpoint = (ModbusEndpointThingHandler) handler;\n+            return slaveEndpoint;\n+        } else {\n+            logger.debug(\"Unexpected bridge handler: {}\", handler);\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Get a reference to the modbus endpoint\n+     */\n+    private void connectEndpoint() {\n+        if (comms != null) {\n+            return;\n+        }\n+\n+        ModbusEndpointThingHandler slaveEndpointThingHandler = getEndpointThingHandler();\n+        if (slaveEndpointThingHandler == null) {\n+            @SuppressWarnings(\"null\")\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\n+                    String.format(\"Bridge '%s' is offline\", label));\n+            logger.debug(\"No bridge handler available -- aborting init for {}\", label);\n+            return;\n+        }\n+        comms = slaveEndpointThingHandler.getCommunicationInterface();\n+        if (comms == null) {\n+            @SuppressWarnings(\"null\")\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\n+                    String.format(\"Bridge '%s' not completely initialized\", label));\n+            logger.debug(\"Bridge not initialized fully (no endpoint) -- aborting init for {}\", this);\n+            return;\n+        }\n+    }\n+\n+    /**\n+     * Remove the endpoint if exists\n+     */\n+    private void unregisterEndpoint() {\n+        // Comms will be close()'d by endpoint thing handler\n+        comms = null;\n+    }\n+\n+    private synchronized void unregisterPollTasks() {\n+        if (pollTasks.isEmpty()) {\n+            return;\n+        }\n+        logger.debug(\"Unregistering polling from ModbusManager\");\n+        @Nullable\n+        ModbusCommunicationInterface mycomms = comms;\n+        if (mycomms != null) {\n+            for (PollTask t : pollTasks) {\n+                mycomms.unregisterRegularPoll(t);\n+            }\n+            pollTasks.clear();\n+        }\n+    }\n+\n+    /**\n+     * Register poll task\n+     * This is where we set up our regular poller\n+     */\n+    @SuppressWarnings(\"null\")\n+    private synchronized void registerPollTask(int registerNumber) {\n+        if (pollTasks.size() >= registers.length) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+            throw new IllegalStateException(\"New pollTask invalid\");\n+        }\n+        @Nullable\n+        ModbusCommunicationInterface mycomms = comms;\n+        @Nullable\n+        StuderConfiguration studerConfig = config;\n+        if (studerConfig == null || mycomms == null) {\n+            throw new IllegalStateException(\"registerPollTask called without proper configuration\");\n+        }\n+\n+        logger.debug(\"Setting up regular polling\");\n+\n+        ModbusReadRequestBlueprint request = new ModbusReadRequestBlueprint(studerConfig.slaveAddress,\n+                ModbusReadFunctionCode.READ_INPUT_REGISTERS, registerNumber, 2, studerConfig.maxTries);\n+        long refreshMillis = studerConfig.refreshSec * 1000;\n+        PollTask pollTask = mycomms.registerRegularPoll(request, refreshMillis, 1000, result -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1beda2af42278133bf6c04d0a361266dbcc601da"}, "originalPosition": 285}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDg0NjI5MA==", "bodyText": "I hadn't noticed, now I change it into required on config description XML files with a minimum value of 1. Refresh setted to 0 isn't handled by registerRegularPoll method but I based the code on the SunSpec binding. I tested it and I think a check is not needed", "url": "https://github.com/openhab/openhab-addons/pull/8163#discussion_r460846290", "createdAt": "2020-07-27T12:14:01Z", "author": {"login": "giovannimirulla"}, "path": "bundles/org.openhab.binding.modbus.studer/src/main/java/org/openhab/binding/modbus/studer/internal/StuderHandler.java", "diffHunk": "@@ -0,0 +1,432 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.studer.internal;\n+\n+import static org.openhab.binding.modbus.studer.internal.StuderBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.ModeXtender;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.State;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VSMode;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VTMode;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VTType;\n+import org.openhab.io.transport.modbus.AsyncModbusFailure;\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link StuderHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Giovanni Mirulla - Initial contribution\n+ */\n+@SuppressWarnings(\"unused\")\n+@NonNullByDefault\n+public class StuderHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(StuderHandler.class);\n+\n+    private @Nullable StuderConfiguration config;\n+\n+    /**\n+     * Array of tasks used to poll the device\n+     */\n+    private ArrayList<PollTask> pollTasks = new ArrayList<PollTask>();\n+\n+    /**\n+     * Communication interface to the slave endpoint we're connecting to\n+     */\n+    protected volatile @Nullable ModbusCommunicationInterface comms = null;\n+\n+    /**\n+     * Importing parser methods and enums\n+     */\n+    final StuderParser parser = new StuderParser();\n+    /**\n+     * Support variable for type of thing\n+     */\n+    protected ThingTypeUID type;\n+\n+    /**\n+     * Array of registers of Studer slave to read, we store this once initialization is complete\n+     */\n+    private Integer[] registers = new Integer[0];\n+\n+    /**\n+     * Instances of this handler\n+     *\n+     * @param thing the thing to handle\n+     * @param type the type of thing to handle\n+     * @param slaveAddress the address of thing\n+     * @param refreshSec the address of thing\n+     */\n+    public StuderHandler(Thing thing) {\n+        super(thing);\n+        this.type = thing.getThingTypeUID();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+\n+        // Currently we do not support any commands\n+    }\n+\n+    /**\n+     * Initialization:\n+     * Load the config object\n+     * Connect to the slave bridge\n+     * Get registers to poll\n+     * Start the periodic polling\n+     */\n+    @SuppressWarnings(\"null\")\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(StuderConfiguration.class);\n+        logger.debug(\"Initializing thing whit configuration: {}\", thing.getConfiguration());\n+\n+        startUp();\n+    }\n+\n+    /*\n+     * This method starts the operation of this handler\n+     * Connect to the slave bridge\n+     * Get registers to poll\n+     * Start the periodic polling\n+     */\n+    @SuppressWarnings(\"null\")\n+    private void startUp() {\n+\n+        connectEndpoint();\n+\n+        if (comms == null || config == null) {\n+            logger.debug(\"Invalid endpoint/config/manager ref for studer handler\");\n+            return;\n+        }\n+\n+        if (!pollTasks.isEmpty()) {\n+            return;\n+        }\n+\n+        if (type.equals(THING_TYPE_BSP)) {\n+            Set<Integer> keys = CHANNELS_BSP.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_XTENDER)) {\n+            Set<Integer> keys = CHANNELS_XTENDER.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_VARIOTRACK)) {\n+            Set<Integer> keys = CHANNELS_VARIOTRACK.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_VARIOSTRING)) {\n+            Set<Integer> keys = CHANNELS_VARIOSTRING.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        }\n+\n+        for (int r : registers) {\n+            registerPollTask(r);\n+\n+        }\n+    }\n+\n+    /**\n+     * Dispose the binding correctly\n+     */\n+    @Override\n+    public void dispose() {\n+        tearDown();\n+    }\n+\n+    /**\n+     * Unregister the poll tasks and release the endpoint reference\n+     */\n+    private void tearDown() {\n+        unregisterPollTasks();\n+        unregisterEndpoint();\n+    }\n+\n+    /**\n+     * Get the endpoint handler from the bridge this handler is connected to\n+     * Checks that we're connected to the right type of bridge\n+     *\n+     * @return the endpoint handler or null if the bridge does not exist\n+     */\n+    private @Nullable ModbusEndpointThingHandler getEndpointThingHandler() {\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"Bridge is null\");\n+            return null;\n+        }\n+        if (bridge.getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Bridge is not online\");\n+            return null;\n+        }\n+\n+        ThingHandler handler = bridge.getHandler();\n+        if (handler == null) {\n+            logger.debug(\"Bridge handler is null\");\n+            return null;\n+        }\n+\n+        if (handler instanceof ModbusEndpointThingHandler) {\n+            ModbusEndpointThingHandler slaveEndpoint = (ModbusEndpointThingHandler) handler;\n+            return slaveEndpoint;\n+        } else {\n+            logger.debug(\"Unexpected bridge handler: {}\", handler);\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Get a reference to the modbus endpoint\n+     */\n+    private void connectEndpoint() {\n+        if (comms != null) {\n+            return;\n+        }\n+\n+        ModbusEndpointThingHandler slaveEndpointThingHandler = getEndpointThingHandler();\n+        if (slaveEndpointThingHandler == null) {\n+            @SuppressWarnings(\"null\")\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\n+                    String.format(\"Bridge '%s' is offline\", label));\n+            logger.debug(\"No bridge handler available -- aborting init for {}\", label);\n+            return;\n+        }\n+        comms = slaveEndpointThingHandler.getCommunicationInterface();\n+        if (comms == null) {\n+            @SuppressWarnings(\"null\")\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\n+                    String.format(\"Bridge '%s' not completely initialized\", label));\n+            logger.debug(\"Bridge not initialized fully (no endpoint) -- aborting init for {}\", this);\n+            return;\n+        }\n+    }\n+\n+    /**\n+     * Remove the endpoint if exists\n+     */\n+    private void unregisterEndpoint() {\n+        // Comms will be close()'d by endpoint thing handler\n+        comms = null;\n+    }\n+\n+    private synchronized void unregisterPollTasks() {\n+        if (pollTasks.isEmpty()) {\n+            return;\n+        }\n+        logger.debug(\"Unregistering polling from ModbusManager\");\n+        @Nullable\n+        ModbusCommunicationInterface mycomms = comms;\n+        if (mycomms != null) {\n+            for (PollTask t : pollTasks) {\n+                mycomms.unregisterRegularPoll(t);\n+            }\n+            pollTasks.clear();\n+        }\n+    }\n+\n+    /**\n+     * Register poll task\n+     * This is where we set up our regular poller\n+     */\n+    @SuppressWarnings(\"null\")\n+    private synchronized void registerPollTask(int registerNumber) {\n+        if (pollTasks.size() >= registers.length) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+            throw new IllegalStateException(\"New pollTask invalid\");\n+        }\n+        @Nullable\n+        ModbusCommunicationInterface mycomms = comms;\n+        @Nullable\n+        StuderConfiguration studerConfig = config;\n+        if (studerConfig == null || mycomms == null) {\n+            throw new IllegalStateException(\"registerPollTask called without proper configuration\");\n+        }\n+\n+        logger.debug(\"Setting up regular polling\");\n+\n+        ModbusReadRequestBlueprint request = new ModbusReadRequestBlueprint(studerConfig.slaveAddress,\n+                ModbusReadFunctionCode.READ_INPUT_REGISTERS, registerNumber, 2, studerConfig.maxTries);\n+        long refreshMillis = studerConfig.refreshSec * 1000;\n+        PollTask pollTask = mycomms.registerRegularPoll(request, refreshMillis, 1000, result -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU1MTI0OQ=="}, "originalCommit": {"oid": "1beda2af42278133bf6c04d0a361266dbcc601da"}, "originalPosition": 285}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg3NDg1NDAwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.modbus.studer/src/main/resources/ESH-INF/thing/thing-types.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNlQxNzoxODozM1rOG3N2bQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNlQxNzoxODozM1rOG3N2bQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU1MTc4OQ==", "bodyText": "Is 0 handled in the code? Same for below.", "url": "https://github.com/openhab/openhab-addons/pull/8163#discussion_r460551789", "createdAt": "2020-07-26T17:18:33Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.modbus.studer/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,143 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"modbus\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<!-- BSP Thing Type -->\n+\t<thing-type id=\"bsp\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"serial\"/>\n+\t\t</supported-bridge-type-refs>\n+\t\t<label>BSP Studer Thing</label>\n+\t\t<description>Thing for Studer BSP Device</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"batteryVoltage\" typeId=\"Ubat\"/>\n+\t\t\t<channel id=\"batteryCurrent\" typeId=\"Ibat\"/>\n+\t\t\t<channel id=\"power\" typeId=\"Pbat\"/>\n+\t\t\t<channel id=\"stateOfCharge\" typeId=\"SOC\"/>\n+\t\t\t<channel id=\"batteryTemperature\" typeId=\"Tbat\"/>\n+\t\t</channels>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"slaveAddress\" type=\"integer\" min=\"60\" max=\"61\">\n+\t\t\t\t<label>Slave Address</label>\n+\t\t\t\t<description>Slave address of BSP device</description>\n+\t\t\t\t<default>60</default>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refreshSec\" type=\"integer\" min=\"0\" unit=\"s\">\n+\t\t\t\t<label>Refresh Interval</label>\n+\t\t\t\t<description>Poll interval. Use zero to disable automatic polling.</description>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1beda2af42278133bf6c04d0a361266dbcc601da"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4MzM4MTQwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.modbus.studer/src/main/resources/ESH-INF/thing/thing-types.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxMDo0MTo0NVrOHHGUlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxMDo0MjozN1rOHHGWEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzIwNTY1Mw==", "bodyText": "required as element is deprecated use attribute required.", "url": "https://github.com/openhab/openhab-addons/pull/8163#discussion_r477205653", "createdAt": "2020-08-26T10:41:45Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.modbus.studer/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,147 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"modbus\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<!-- BSP Thing Type -->\n+\t<thing-type id=\"bsp\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"serial\"/>\n+\t\t</supported-bridge-type-refs>\n+\t\t<label>BSP Studer Thing</label>\n+\t\t<description>Thing for Studer BSP Device</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"batteryVoltage\" typeId=\"Ubat\"/>\n+\t\t\t<channel id=\"batteryCurrent\" typeId=\"Ibat\"/>\n+\t\t\t<channel id=\"power\" typeId=\"Pbat\"/>\n+\t\t\t<channel id=\"stateOfCharge\" typeId=\"SOC\"/>\n+\t\t\t<channel id=\"batteryTemperature\" typeId=\"Tbat\"/>\n+\t\t</channels>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"slaveAddress\" type=\"integer\" min=\"60\" max=\"61\">\n+\t\t\t\t<label>Slave Address</label>\n+\t\t\t\t<description>Slave address of BSP device</description>\n+\t\t\t\t<default>60</default>\n+\t\t\t\t<required>true</required>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refreshSec\" type=\"integer\" min=\"1\" unit=\"s\">\n+\t\t\t\t<label>Refresh Interval</label>\n+\t\t\t\t<description>Poll interval</description>\n+\t\t\t\t<default>5</default>\n+\t\t\t\t<required>true</required>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\t<!-- Xtender Thing Type -->\n+\t<thing-type id=\"xtender\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"serial\"/>\n+\t\t</supported-bridge-type-refs>\n+\t\t<label>Xtender Studer Thing</label>\n+\t\t<description>Thing for Studer Xtender Device</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"inputVoltage\" typeId=\"Uin\"/>\n+\t\t\t<channel id=\"inputCurrent\" typeId=\"Iin\"/>\n+\t\t\t<channel id=\"inputActivePower\" typeId=\"Pina\"/>\n+\t\t\t<channel id=\"inputFrequency\" typeId=\"Fin\"/>\n+\t\t\t<channel id=\"outputVoltage\" typeId=\"Uout\"/>\n+\t\t\t<channel id=\"outputCurrent\" typeId=\"Iout\"/>\n+\t\t\t<channel id=\"outputActivePower\" typeId=\"Pouta\"/>\n+\t\t\t<channel id=\"outputFrequency\" typeId=\"Fout\"/>\n+\t\t\t<channel id=\"operatingState\" typeId=\"Mode\"/>\n+\t\t\t<channel id=\"stateInverter\" typeId=\"XTstate\"/>\n+\t\t</channels>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"slaveAddress\" type=\"integer\" min=\"10\" max=\"19\">\n+\t\t\t\t<label>Slave Address</label>\n+\t\t\t\t<description>Slave address of Xtender device</description>\n+\t\t\t\t<default>10</default>\n+\t\t\t\t<required>true</required>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refreshSec\" type=\"integer\" min=\"1\" unit=\"s\">\n+\t\t\t\t<label>Refresh Interval</label>\n+\t\t\t\t<description>Poll interval</description>\n+\t\t\t\t<default>5</default>\n+\t\t\t\t<required>true</required>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\t<!-- VarioTrack Thing Type -->\n+\t<thing-type id=\"variotrack\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"serial\"/>\n+\t\t</supported-bridge-type-refs>\n+\t\t<label>VarioTrack Studer Thing</label>\n+\t\t<description>Thing for Studer VarioTrack Device</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"batteryVoltage\" typeId=\"Ubat\"/>\n+\t\t\t<channel id=\"batteryCurrent\" typeId=\"Ibat\"/>\n+\t\t\t<channel id=\"modelVarioTrack\" typeId=\"Type\"/>\n+\t\t\t<channel id=\"voltagePVGenerator\" typeId=\"Upv\"/>\n+\t\t\t<channel id=\"powerPVGenerator\" typeId=\"Psol\"/>\n+\t\t\t<channel id=\"productionCurrentDay\" typeId=\"Ed\"/>\n+\t\t\t<channel id=\"operatingMode\" typeId=\"Mode\"/>\n+\t\t\t<channel id=\"stateVarioTrack\" typeId=\"VTstate\"/>\n+\t\t</channels>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"slaveAddress\" type=\"integer\" min=\"20\" max=\"35\">\n+\t\t\t\t<label>Slave Address</label>\n+\t\t\t\t<description>Slave address of VarioTrack device</description>\n+\t\t\t\t<default>20</default>\n+\t\t\t\t<required>true</required>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refreshSec\" type=\"integer\" min=\"1\" unit=\"s\">\n+\t\t\t\t<label>Refresh Interval</label>\n+\t\t\t\t<description>Poll interval</description>\n+\t\t\t\t<default>5</default>\n+\t\t\t\t<required>true</required>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\t<!-- VarioString Thing Type -->\n+\t<thing-type id=\"variostring\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"serial\"/>\n+\t\t</supported-bridge-type-refs>\n+\t\t<label>VarioString Studer Thing</label>\n+\t\t<description>Thing for Studer VarioString Device</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"batteryVoltage\" typeId=\"Ubat\"/>\n+\t\t\t<channel id=\"batteryCurrent\" typeId=\"Ibat\"/>\n+\t\t\t<channel id=\"PVVoltage\" typeId=\"Upv0\"/>\n+\t\t\t<channel id=\"PVCurrent\" typeId=\"Ipv0\"/>\n+\t\t\t<channel id=\"PVPower\" typeId=\"Ppv0\"/>\n+\t\t\t<channel id=\"ProductionPVCurrentDay\" typeId=\"Ed0\"/>\n+\t\t\t<channel id=\"PVMode\" typeId=\"Mod0\"/>\n+\t\t\t<channel id=\"PV1Voltage\" typeId=\"Upv1\"/>\n+\t\t\t<channel id=\"PV1Current\" typeId=\"Ipv1\"/>\n+\t\t\t<channel id=\"PV1Power\" typeId=\"Ppv1\"/>\n+\t\t\t<channel id=\"ProductionPV1CurrentDay\" typeId=\"Ed1\"/>\n+\t\t\t<channel id=\"PV1Mode\" typeId=\"Mod1\"/>\n+\t\t\t<channel id=\"PV2Voltage\" typeId=\"Upv2\"/>\n+\t\t\t<channel id=\"PV2Current\" typeId=\"Ipv2\"/>\n+\t\t\t<channel id=\"PV2Power\" typeId=\"Ppv2\"/>\n+\t\t\t<channel id=\"ProductionPV2CurrentDay\" typeId=\"Ed2\"/>\n+\t\t\t<channel id=\"PV2Mode\" typeId=\"Mod2\"/>\n+\t\t\t<channel id=\"stateVarioString\" typeId=\"VSstate\"/>\n+\t\t</channels>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"slaveAddress\" type=\"integer\" min=\"40\" max=\"55\">\n+\t\t\t\t<label>Slave Address</label>\n+\t\t\t\t<description>Slave address of VarioString device</description>\n+\t\t\t\t<default>40</default>\n+\t\t\t\t<required>true</required>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef8c36c89dd25dfc366754439f5d01bf55f443ef"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzIwNjAzMg==", "bodyText": "technically if you have a default value it's not needed to make it required as the default guarantees it's always set.", "url": "https://github.com/openhab/openhab-addons/pull/8163#discussion_r477206032", "createdAt": "2020-08-26T10:42:37Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.modbus.studer/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,147 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"modbus\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<!-- BSP Thing Type -->\n+\t<thing-type id=\"bsp\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"serial\"/>\n+\t\t</supported-bridge-type-refs>\n+\t\t<label>BSP Studer Thing</label>\n+\t\t<description>Thing for Studer BSP Device</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"batteryVoltage\" typeId=\"Ubat\"/>\n+\t\t\t<channel id=\"batteryCurrent\" typeId=\"Ibat\"/>\n+\t\t\t<channel id=\"power\" typeId=\"Pbat\"/>\n+\t\t\t<channel id=\"stateOfCharge\" typeId=\"SOC\"/>\n+\t\t\t<channel id=\"batteryTemperature\" typeId=\"Tbat\"/>\n+\t\t</channels>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"slaveAddress\" type=\"integer\" min=\"60\" max=\"61\">\n+\t\t\t\t<label>Slave Address</label>\n+\t\t\t\t<description>Slave address of BSP device</description>\n+\t\t\t\t<default>60</default>\n+\t\t\t\t<required>true</required>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refreshSec\" type=\"integer\" min=\"1\" unit=\"s\">\n+\t\t\t\t<label>Refresh Interval</label>\n+\t\t\t\t<description>Poll interval</description>\n+\t\t\t\t<default>5</default>\n+\t\t\t\t<required>true</required>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\t<!-- Xtender Thing Type -->\n+\t<thing-type id=\"xtender\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"serial\"/>\n+\t\t</supported-bridge-type-refs>\n+\t\t<label>Xtender Studer Thing</label>\n+\t\t<description>Thing for Studer Xtender Device</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"inputVoltage\" typeId=\"Uin\"/>\n+\t\t\t<channel id=\"inputCurrent\" typeId=\"Iin\"/>\n+\t\t\t<channel id=\"inputActivePower\" typeId=\"Pina\"/>\n+\t\t\t<channel id=\"inputFrequency\" typeId=\"Fin\"/>\n+\t\t\t<channel id=\"outputVoltage\" typeId=\"Uout\"/>\n+\t\t\t<channel id=\"outputCurrent\" typeId=\"Iout\"/>\n+\t\t\t<channel id=\"outputActivePower\" typeId=\"Pouta\"/>\n+\t\t\t<channel id=\"outputFrequency\" typeId=\"Fout\"/>\n+\t\t\t<channel id=\"operatingState\" typeId=\"Mode\"/>\n+\t\t\t<channel id=\"stateInverter\" typeId=\"XTstate\"/>\n+\t\t</channels>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"slaveAddress\" type=\"integer\" min=\"10\" max=\"19\">\n+\t\t\t\t<label>Slave Address</label>\n+\t\t\t\t<description>Slave address of Xtender device</description>\n+\t\t\t\t<default>10</default>\n+\t\t\t\t<required>true</required>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refreshSec\" type=\"integer\" min=\"1\" unit=\"s\">\n+\t\t\t\t<label>Refresh Interval</label>\n+\t\t\t\t<description>Poll interval</description>\n+\t\t\t\t<default>5</default>\n+\t\t\t\t<required>true</required>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\t<!-- VarioTrack Thing Type -->\n+\t<thing-type id=\"variotrack\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"serial\"/>\n+\t\t</supported-bridge-type-refs>\n+\t\t<label>VarioTrack Studer Thing</label>\n+\t\t<description>Thing for Studer VarioTrack Device</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"batteryVoltage\" typeId=\"Ubat\"/>\n+\t\t\t<channel id=\"batteryCurrent\" typeId=\"Ibat\"/>\n+\t\t\t<channel id=\"modelVarioTrack\" typeId=\"Type\"/>\n+\t\t\t<channel id=\"voltagePVGenerator\" typeId=\"Upv\"/>\n+\t\t\t<channel id=\"powerPVGenerator\" typeId=\"Psol\"/>\n+\t\t\t<channel id=\"productionCurrentDay\" typeId=\"Ed\"/>\n+\t\t\t<channel id=\"operatingMode\" typeId=\"Mode\"/>\n+\t\t\t<channel id=\"stateVarioTrack\" typeId=\"VTstate\"/>\n+\t\t</channels>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"slaveAddress\" type=\"integer\" min=\"20\" max=\"35\">\n+\t\t\t\t<label>Slave Address</label>\n+\t\t\t\t<description>Slave address of VarioTrack device</description>\n+\t\t\t\t<default>20</default>\n+\t\t\t\t<required>true</required>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refreshSec\" type=\"integer\" min=\"1\" unit=\"s\">\n+\t\t\t\t<label>Refresh Interval</label>\n+\t\t\t\t<description>Poll interval</description>\n+\t\t\t\t<default>5</default>\n+\t\t\t\t<required>true</required>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\t<!-- VarioString Thing Type -->\n+\t<thing-type id=\"variostring\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"serial\"/>\n+\t\t</supported-bridge-type-refs>\n+\t\t<label>VarioString Studer Thing</label>\n+\t\t<description>Thing for Studer VarioString Device</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"batteryVoltage\" typeId=\"Ubat\"/>\n+\t\t\t<channel id=\"batteryCurrent\" typeId=\"Ibat\"/>\n+\t\t\t<channel id=\"PVVoltage\" typeId=\"Upv0\"/>\n+\t\t\t<channel id=\"PVCurrent\" typeId=\"Ipv0\"/>\n+\t\t\t<channel id=\"PVPower\" typeId=\"Ppv0\"/>\n+\t\t\t<channel id=\"ProductionPVCurrentDay\" typeId=\"Ed0\"/>\n+\t\t\t<channel id=\"PVMode\" typeId=\"Mod0\"/>\n+\t\t\t<channel id=\"PV1Voltage\" typeId=\"Upv1\"/>\n+\t\t\t<channel id=\"PV1Current\" typeId=\"Ipv1\"/>\n+\t\t\t<channel id=\"PV1Power\" typeId=\"Ppv1\"/>\n+\t\t\t<channel id=\"ProductionPV1CurrentDay\" typeId=\"Ed1\"/>\n+\t\t\t<channel id=\"PV1Mode\" typeId=\"Mod1\"/>\n+\t\t\t<channel id=\"PV2Voltage\" typeId=\"Upv2\"/>\n+\t\t\t<channel id=\"PV2Current\" typeId=\"Ipv2\"/>\n+\t\t\t<channel id=\"PV2Power\" typeId=\"Ppv2\"/>\n+\t\t\t<channel id=\"ProductionPV2CurrentDay\" typeId=\"Ed2\"/>\n+\t\t\t<channel id=\"PV2Mode\" typeId=\"Mod2\"/>\n+\t\t\t<channel id=\"stateVarioString\" typeId=\"VSstate\"/>\n+\t\t</channels>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"slaveAddress\" type=\"integer\" min=\"40\" max=\"55\">\n+\t\t\t\t<label>Slave Address</label>\n+\t\t\t\t<description>Slave address of VarioString device</description>\n+\t\t\t\t<default>40</default>\n+\t\t\t\t<required>true</required>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzIwNTY1Mw=="}, "originalCommit": {"oid": "ef8c36c89dd25dfc366754439f5d01bf55f443ef"}, "originalPosition": 136}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4MzM4ODIxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.modbus.studer/src/main/java/org/openhab/binding/modbus/studer/internal/StuderConfiguration.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxMDo0NDowNVrOHHGYxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxMDo0NDowNVrOHHGYxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzIwNjcyNA==", "bodyText": "In the readme it is named refresh. In general configuration parameters, like refresh don't have the unit in the name. (Something we do require for static final fields.)", "url": "https://github.com/openhab/openhab-addons/pull/8163#discussion_r477206724", "createdAt": "2020-08-26T10:44:05Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.modbus.studer/src/main/java/org/openhab/binding/modbus/studer/internal/StuderConfiguration.java", "diffHunk": "@@ -0,0 +1,36 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.studer.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The {@link StuderConfiguration} class contains fields mapping thing configuration parameters.\n+ *\n+ * @author Giovanni Mirulla - Initial contribution\n+ */\n+@NonNullByDefault\n+public class StuderConfiguration {\n+    /**\n+     * Address of slave device\n+     */\n+    public int slaveAddress = 0;\n+    /**\n+     * Refresh interval in seconds\n+     */\n+    public int refreshSec = 5;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef8c36c89dd25dfc366754439f5d01bf55f443ef"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4MzQwNzc0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.modbus.studer/src/main/java/org/openhab/binding/modbus/studer/internal/StuderParser.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxMDo1MDoxM1rOHHGkoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxMDo1MDoxM1rOHHGkoQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzIwOTc2MQ==", "bodyText": "To make the code a little bit better return Float here. It allows for less casting in the rest of the code. Or you can just return the primitive float and instead of doing the null check later on, do the isNaN check. That way you can work with primitive values.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public @Nullable Object hexToFloat(String hex) {\n          \n          \n            \n                public @Nullable Float hexToFloat(String hex) {", "url": "https://github.com/openhab/openhab-addons/pull/8163#discussion_r477209761", "createdAt": "2020-08-26T10:50:13Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.modbus.studer/src/main/java/org/openhab/binding/modbus/studer/internal/StuderParser.java", "diffHunk": "@@ -0,0 +1,233 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.studer.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link StuderParser} class with helper method\n+ * and possible values for mode and state\n+ *\n+ * @author Giovanni Mirulla - Initial contribution\n+ */\n+@NonNullByDefault\n+public class StuderParser {\n+    public enum ModeXtender {\n+        INVALID(0),\n+        INVERTER(1),\n+        CHARGER(2),\n+        BOOST(3),\n+        INJECTION(4),\n+        UNKNOWN(-1);\n+\n+        private final int code;\n+\n+        ModeXtender(int code) {\n+            this.code = code;\n+        }\n+\n+        public int code() {\n+            return this.code;\n+        }\n+    }\n+\n+    public static ModeXtender getModeXtenderByCode(int code) {\n+        switch (code) {\n+            case 0:\n+                return ModeXtender.INVALID;\n+            case 1:\n+                return ModeXtender.INVERTER;\n+            case 2:\n+                return ModeXtender.CHARGER;\n+            case 3:\n+                return ModeXtender.BOOST;\n+            case 4:\n+                return ModeXtender.INJECTION;\n+            default:\n+                return ModeXtender.UNKNOWN;\n+        }\n+    }\n+\n+    public enum State {\n+        OFF(0),\n+        ON(1),\n+        UNKNOWN(-1);\n+\n+        private final int code;\n+\n+        State(int code) {\n+            this.code = code;\n+        }\n+\n+        public int code() {\n+            return this.code;\n+        }\n+    }\n+\n+    public static State getStateByCode(int code) {\n+        switch (code) {\n+            case 0:\n+                return State.OFF;\n+            case 1:\n+                return State.ON;\n+            default:\n+                return State.UNKNOWN;\n+        }\n+    }\n+\n+    public enum VTType {\n+        VT80(0),\n+        VT65(1),\n+        UNKNOWN(-1);\n+\n+        private final int code;\n+\n+        VTType(int code) {\n+            this.code = code;\n+        }\n+\n+        public int code() {\n+            return this.code;\n+        }\n+    }\n+\n+    public static VTType getVTTypeByCode(int code) {\n+        switch (code) {\n+            case 0:\n+                return VTType.VT80;\n+            case 1:\n+                return VTType.VT65;\n+            default:\n+                return VTType.UNKNOWN;\n+        }\n+    }\n+\n+    public enum VTMode {\n+        NIGHT(0),\n+        STARTUP(1),\n+        CHARGER(3),\n+        SECURITY(5),\n+        OFF(6),\n+        CHARGE(8),\n+        CHARGEV(9),\n+        CHARGEI(10),\n+        CHARGET(11),\n+        CHIBSP(12),\n+        UNKNOWN(-1);\n+\n+        private final int code;\n+\n+        VTMode(int code) {\n+            this.code = code;\n+        }\n+\n+        public int code() {\n+            return this.code;\n+        }\n+    }\n+\n+    public static VTMode getVTModeByCode(int code) {\n+        switch (code) {\n+            case 0:\n+                return VTMode.NIGHT;\n+            case 1:\n+                return VTMode.STARTUP;\n+            case 3:\n+                return VTMode.CHARGER;\n+            case 5:\n+                return VTMode.SECURITY;\n+            case 6:\n+                return VTMode.OFF;\n+            case 8:\n+                return VTMode.CHARGE;\n+            case 9:\n+                return VTMode.CHARGEV;\n+            case 10:\n+                return VTMode.CHARGEI;\n+            case 11:\n+                return VTMode.CHARGET;\n+            case 12:\n+                return VTMode.CHIBSP;\n+            default:\n+                return VTMode.UNKNOWN;\n+        }\n+    }\n+\n+    public enum VSMode {\n+        NIGHT(0),\n+        SECURITY(1),\n+        OFF(2),\n+        CHARGE(3),\n+        CHARGEV(4),\n+        CHARGEI(5),\n+        CHARGEP(6),\n+        CHARGEIPV(7),\n+        CHARGET(8),\n+        CHIBSP(10),\n+        UNKNOWN(-1);\n+\n+        private final int code;\n+\n+        VSMode(int code) {\n+            this.code = code;\n+        }\n+\n+        public int code() {\n+            return this.code;\n+        }\n+    }\n+\n+    public static VSMode getVSModeByCode(int code) {\n+        switch (code) {\n+            case 0:\n+                return VSMode.NIGHT;\n+            case 1:\n+                return VSMode.SECURITY;\n+            case 2:\n+                return VSMode.OFF;\n+            case 3:\n+                return VSMode.CHARGE;\n+            case 4:\n+                return VSMode.CHARGEV;\n+            case 5:\n+                return VSMode.CHARGEI;\n+            case 6:\n+                return VSMode.CHARGEP;\n+            case 7:\n+                return VSMode.CHARGEIPV;\n+            case 8:\n+                return VSMode.CHARGET;\n+            case 10:\n+                return VSMode.CHIBSP;\n+            default:\n+                return VSMode.UNKNOWN;\n+        }\n+    }\n+\n+    /**\n+     * Convert an hex string to float\n+     *\n+     * @param hex string to convert from\n+     * @return the converted float\n+     */\n+    public @Nullable Object hexToFloat(String hex) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef8c36c89dd25dfc366754439f5d01bf55f443ef"}, "originalPosition": 224}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4MzQwODY4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.modbus.studer/src/main/java/org/openhab/binding/modbus/studer/internal/StuderHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxMDo1MDozMFrOHHGlKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxMDo1MDozMFrOHHGlKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzIwOTg5Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Object quantity = parser.hexToFloat(hexString);\n          \n          \n            \n                    Float quantity = parser.hexToFloat(hexString);", "url": "https://github.com/openhab/openhab-addons/pull/8163#discussion_r477209897", "createdAt": "2020-08-26T10:50:30Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.modbus.studer/src/main/java/org/openhab/binding/modbus/studer/internal/StuderHandler.java", "diffHunk": "@@ -0,0 +1,425 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.studer.internal;\n+\n+import static org.openhab.binding.modbus.studer.internal.StuderBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.ModeXtender;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.State;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VSMode;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VTMode;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VTType;\n+import org.openhab.io.transport.modbus.AsyncModbusFailure;\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link StuderHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Giovanni Mirulla - Initial contribution\n+ */\n+@NonNullByDefault\n+public class StuderHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(StuderHandler.class);\n+\n+    private @Nullable StuderConfiguration config;\n+\n+    /**\n+     * Array of tasks used to poll the device\n+     */\n+    private ArrayList<PollTask> pollTasks = new ArrayList<PollTask>();\n+\n+    /**\n+     * Communication interface to the slave endpoint we're connecting to\n+     */\n+    protected volatile @Nullable ModbusCommunicationInterface comms = null;\n+\n+    /**\n+     * Importing parser methods and enums\n+     */\n+    final StuderParser parser = new StuderParser();\n+    /**\n+     * Support variable for type of thing\n+     */\n+    protected ThingTypeUID type;\n+\n+    /**\n+     * Array of registers of Studer slave to read, we store this once initialization is complete\n+     */\n+    private Integer[] registers = new Integer[0];\n+\n+    /**\n+     * Instances of this handler\n+     *\n+     * @param thing the thing to handle\n+     * @param type the type of thing to handle\n+     * @param slaveAddress the address of thing\n+     * @param refreshSec the address of thing\n+     */\n+    public StuderHandler(Thing thing) {\n+        super(thing);\n+        this.type = thing.getThingTypeUID();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+\n+        // Currently we do not support any commands\n+    }\n+\n+    /**\n+     * Initialization:\n+     * Load the config object\n+     * Connect to the slave bridge\n+     * Get registers to poll\n+     * Start the periodic polling\n+     */\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(StuderConfiguration.class);\n+        logger.debug(\"Initializing thing with configuration: {}\", thing.getConfiguration());\n+\n+        startUp();\n+    }\n+\n+    /*\n+     * This method starts the operation of this handler\n+     * Connect to the slave bridge\n+     * Get registers to poll\n+     * Start the periodic polling\n+     */\n+    private void startUp() {\n+\n+        connectEndpoint();\n+\n+        if (comms == null || config == null) {\n+            logger.debug(\"Invalid endpoint/config/manager ref for studer handler\");\n+            return;\n+        }\n+\n+        if (!pollTasks.isEmpty()) {\n+            return;\n+        }\n+\n+        if (type.equals(THING_TYPE_BSP)) {\n+            Set<Integer> keys = CHANNELS_BSP.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_XTENDER)) {\n+            Set<Integer> keys = CHANNELS_XTENDER.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_VARIOTRACK)) {\n+            Set<Integer> keys = CHANNELS_VARIOTRACK.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_VARIOSTRING)) {\n+            Set<Integer> keys = CHANNELS_VARIOSTRING.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        }\n+\n+        for (int r : registers) {\n+            registerPollTask(r);\n+\n+        }\n+    }\n+\n+    /**\n+     * Dispose the binding correctly\n+     */\n+    @Override\n+    public void dispose() {\n+        tearDown();\n+    }\n+\n+    /**\n+     * Unregister the poll tasks and release the endpoint reference\n+     */\n+    private void tearDown() {\n+        unregisterPollTasks();\n+        unregisterEndpoint();\n+    }\n+\n+    /**\n+     * Get the endpoint handler from the bridge this handler is connected to\n+     * Checks that we're connected to the right type of bridge\n+     *\n+     * @return the endpoint handler or null if the bridge does not exist\n+     */\n+    private @Nullable ModbusEndpointThingHandler getEndpointThingHandler() {\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"Bridge is null\");\n+            return null;\n+        }\n+        if (bridge.getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Bridge is not online\");\n+            return null;\n+        }\n+\n+        ThingHandler handler = bridge.getHandler();\n+        if (handler == null) {\n+            logger.debug(\"Bridge handler is null\");\n+            return null;\n+        }\n+\n+        if (handler instanceof ModbusEndpointThingHandler) {\n+            ModbusEndpointThingHandler slaveEndpoint = (ModbusEndpointThingHandler) handler;\n+            return slaveEndpoint;\n+        } else {\n+            logger.debug(\"Unexpected bridge handler: {}\", handler);\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Get a reference to the modbus endpoint\n+     */\n+    private void connectEndpoint() {\n+        if (comms != null) {\n+            return;\n+        }\n+\n+        ModbusEndpointThingHandler slaveEndpointThingHandler = getEndpointThingHandler();\n+        if (slaveEndpointThingHandler == null) {\n+            @SuppressWarnings(\"null\")\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\n+                    String.format(\"Bridge '%s' is offline\", label));\n+            logger.debug(\"No bridge handler available -- aborting init for {}\", label);\n+            return;\n+        }\n+        comms = slaveEndpointThingHandler.getCommunicationInterface();\n+        if (comms == null) {\n+            @SuppressWarnings(\"null\")\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\n+                    String.format(\"Bridge '%s' not completely initialized\", label));\n+            logger.debug(\"Bridge not initialized fully (no endpoint) -- aborting init for {}\", this);\n+            return;\n+        }\n+    }\n+\n+    /**\n+     * Remove the endpoint if exists\n+     */\n+    private void unregisterEndpoint() {\n+        // Comms will be close()'d by endpoint thing handler\n+        comms = null;\n+    }\n+\n+    private synchronized void unregisterPollTasks() {\n+        if (pollTasks.isEmpty()) {\n+            return;\n+        }\n+        logger.debug(\"Unregistering polling from ModbusManager\");\n+        ModbusCommunicationInterface mycomms = comms;\n+        if (mycomms != null) {\n+            for (PollTask t : pollTasks) {\n+                mycomms.unregisterRegularPoll(t);\n+            }\n+            pollTasks.clear();\n+        }\n+    }\n+\n+    /**\n+     * Register poll task\n+     * This is where we set up our regular poller\n+     */\n+    private synchronized void registerPollTask(int registerNumber) {\n+        if (pollTasks.size() >= registers.length) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+            throw new IllegalStateException(\"New pollTask invalid\");\n+        }\n+        ModbusCommunicationInterface mycomms = comms;\n+        StuderConfiguration studerConfig = config;\n+        if (studerConfig == null || mycomms == null) {\n+            throw new IllegalStateException(\"registerPollTask called without proper configuration\");\n+        }\n+\n+        logger.debug(\"Setting up regular polling\");\n+\n+        ModbusReadRequestBlueprint request = new ModbusReadRequestBlueprint(studerConfig.slaveAddress,\n+                ModbusReadFunctionCode.READ_INPUT_REGISTERS, registerNumber, 2, studerConfig.maxTries);\n+        long refreshMillis = studerConfig.refreshSec * 1000;\n+        PollTask pollTask = mycomms.registerRegularPoll(request, refreshMillis, 1000, result -> {\n+            if (result.getRegisters().isPresent()) {\n+                ModbusRegisterArray reg = result.getRegisters().get();\n+                handlePolledData(registerNumber, reg);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR);\n+                return;\n+            }\n+            if (getThing().getStatus() != ThingStatus.ONLINE) {\n+                updateStatus(ThingStatus.ONLINE);\n+            }\n+        }, this::handleError);\n+        pollTasks.add(pollTask);\n+    }\n+\n+    /**\n+     * This method is called each time new data has been polled from the modbus slave\n+     * The register array is first parsed, then each of the channels are updated\n+     * to the new values\n+     *\n+     * @param n register readed\n+     * @param registers byte array read from the modbus slave\n+     */\n+    protected void handlePolledData(int registerNumber, ModbusRegisterArray registers) {\n+        String hexString = registers.toHexString().toString();\n+        Object quantity = parser.hexToFloat(hexString);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef8c36c89dd25dfc366754439f5d01bf55f443ef"}, "originalPosition": 303}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4MzQxMjg0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.modbus.studer/src/main/java/org/openhab/binding/modbus/studer/internal/StuderHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxMDo1MTo0OVrOHHGnrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxMDo1MTo0OVrOHHGnrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzIxMDU0Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    new QuantityType<>((float) quantity, UNIT_CHANNELS_BSP.get(registerNumber)));\n          \n          \n            \n                                    new QuantityType<>(quantity, UNIT_CHANNELS_BSP.get(registerNumber)));", "url": "https://github.com/openhab/openhab-addons/pull/8163#discussion_r477210543", "createdAt": "2020-08-26T10:51:49Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.modbus.studer/src/main/java/org/openhab/binding/modbus/studer/internal/StuderHandler.java", "diffHunk": "@@ -0,0 +1,425 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.studer.internal;\n+\n+import static org.openhab.binding.modbus.studer.internal.StuderBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.ModeXtender;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.State;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VSMode;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VTMode;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VTType;\n+import org.openhab.io.transport.modbus.AsyncModbusFailure;\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link StuderHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Giovanni Mirulla - Initial contribution\n+ */\n+@NonNullByDefault\n+public class StuderHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(StuderHandler.class);\n+\n+    private @Nullable StuderConfiguration config;\n+\n+    /**\n+     * Array of tasks used to poll the device\n+     */\n+    private ArrayList<PollTask> pollTasks = new ArrayList<PollTask>();\n+\n+    /**\n+     * Communication interface to the slave endpoint we're connecting to\n+     */\n+    protected volatile @Nullable ModbusCommunicationInterface comms = null;\n+\n+    /**\n+     * Importing parser methods and enums\n+     */\n+    final StuderParser parser = new StuderParser();\n+    /**\n+     * Support variable for type of thing\n+     */\n+    protected ThingTypeUID type;\n+\n+    /**\n+     * Array of registers of Studer slave to read, we store this once initialization is complete\n+     */\n+    private Integer[] registers = new Integer[0];\n+\n+    /**\n+     * Instances of this handler\n+     *\n+     * @param thing the thing to handle\n+     * @param type the type of thing to handle\n+     * @param slaveAddress the address of thing\n+     * @param refreshSec the address of thing\n+     */\n+    public StuderHandler(Thing thing) {\n+        super(thing);\n+        this.type = thing.getThingTypeUID();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+\n+        // Currently we do not support any commands\n+    }\n+\n+    /**\n+     * Initialization:\n+     * Load the config object\n+     * Connect to the slave bridge\n+     * Get registers to poll\n+     * Start the periodic polling\n+     */\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(StuderConfiguration.class);\n+        logger.debug(\"Initializing thing with configuration: {}\", thing.getConfiguration());\n+\n+        startUp();\n+    }\n+\n+    /*\n+     * This method starts the operation of this handler\n+     * Connect to the slave bridge\n+     * Get registers to poll\n+     * Start the periodic polling\n+     */\n+    private void startUp() {\n+\n+        connectEndpoint();\n+\n+        if (comms == null || config == null) {\n+            logger.debug(\"Invalid endpoint/config/manager ref for studer handler\");\n+            return;\n+        }\n+\n+        if (!pollTasks.isEmpty()) {\n+            return;\n+        }\n+\n+        if (type.equals(THING_TYPE_BSP)) {\n+            Set<Integer> keys = CHANNELS_BSP.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_XTENDER)) {\n+            Set<Integer> keys = CHANNELS_XTENDER.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_VARIOTRACK)) {\n+            Set<Integer> keys = CHANNELS_VARIOTRACK.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_VARIOSTRING)) {\n+            Set<Integer> keys = CHANNELS_VARIOSTRING.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        }\n+\n+        for (int r : registers) {\n+            registerPollTask(r);\n+\n+        }\n+    }\n+\n+    /**\n+     * Dispose the binding correctly\n+     */\n+    @Override\n+    public void dispose() {\n+        tearDown();\n+    }\n+\n+    /**\n+     * Unregister the poll tasks and release the endpoint reference\n+     */\n+    private void tearDown() {\n+        unregisterPollTasks();\n+        unregisterEndpoint();\n+    }\n+\n+    /**\n+     * Get the endpoint handler from the bridge this handler is connected to\n+     * Checks that we're connected to the right type of bridge\n+     *\n+     * @return the endpoint handler or null if the bridge does not exist\n+     */\n+    private @Nullable ModbusEndpointThingHandler getEndpointThingHandler() {\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"Bridge is null\");\n+            return null;\n+        }\n+        if (bridge.getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Bridge is not online\");\n+            return null;\n+        }\n+\n+        ThingHandler handler = bridge.getHandler();\n+        if (handler == null) {\n+            logger.debug(\"Bridge handler is null\");\n+            return null;\n+        }\n+\n+        if (handler instanceof ModbusEndpointThingHandler) {\n+            ModbusEndpointThingHandler slaveEndpoint = (ModbusEndpointThingHandler) handler;\n+            return slaveEndpoint;\n+        } else {\n+            logger.debug(\"Unexpected bridge handler: {}\", handler);\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Get a reference to the modbus endpoint\n+     */\n+    private void connectEndpoint() {\n+        if (comms != null) {\n+            return;\n+        }\n+\n+        ModbusEndpointThingHandler slaveEndpointThingHandler = getEndpointThingHandler();\n+        if (slaveEndpointThingHandler == null) {\n+            @SuppressWarnings(\"null\")\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\n+                    String.format(\"Bridge '%s' is offline\", label));\n+            logger.debug(\"No bridge handler available -- aborting init for {}\", label);\n+            return;\n+        }\n+        comms = slaveEndpointThingHandler.getCommunicationInterface();\n+        if (comms == null) {\n+            @SuppressWarnings(\"null\")\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\n+                    String.format(\"Bridge '%s' not completely initialized\", label));\n+            logger.debug(\"Bridge not initialized fully (no endpoint) -- aborting init for {}\", this);\n+            return;\n+        }\n+    }\n+\n+    /**\n+     * Remove the endpoint if exists\n+     */\n+    private void unregisterEndpoint() {\n+        // Comms will be close()'d by endpoint thing handler\n+        comms = null;\n+    }\n+\n+    private synchronized void unregisterPollTasks() {\n+        if (pollTasks.isEmpty()) {\n+            return;\n+        }\n+        logger.debug(\"Unregistering polling from ModbusManager\");\n+        ModbusCommunicationInterface mycomms = comms;\n+        if (mycomms != null) {\n+            for (PollTask t : pollTasks) {\n+                mycomms.unregisterRegularPoll(t);\n+            }\n+            pollTasks.clear();\n+        }\n+    }\n+\n+    /**\n+     * Register poll task\n+     * This is where we set up our regular poller\n+     */\n+    private synchronized void registerPollTask(int registerNumber) {\n+        if (pollTasks.size() >= registers.length) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+            throw new IllegalStateException(\"New pollTask invalid\");\n+        }\n+        ModbusCommunicationInterface mycomms = comms;\n+        StuderConfiguration studerConfig = config;\n+        if (studerConfig == null || mycomms == null) {\n+            throw new IllegalStateException(\"registerPollTask called without proper configuration\");\n+        }\n+\n+        logger.debug(\"Setting up regular polling\");\n+\n+        ModbusReadRequestBlueprint request = new ModbusReadRequestBlueprint(studerConfig.slaveAddress,\n+                ModbusReadFunctionCode.READ_INPUT_REGISTERS, registerNumber, 2, studerConfig.maxTries);\n+        long refreshMillis = studerConfig.refreshSec * 1000;\n+        PollTask pollTask = mycomms.registerRegularPoll(request, refreshMillis, 1000, result -> {\n+            if (result.getRegisters().isPresent()) {\n+                ModbusRegisterArray reg = result.getRegisters().get();\n+                handlePolledData(registerNumber, reg);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR);\n+                return;\n+            }\n+            if (getThing().getStatus() != ThingStatus.ONLINE) {\n+                updateStatus(ThingStatus.ONLINE);\n+            }\n+        }, this::handleError);\n+        pollTasks.add(pollTask);\n+    }\n+\n+    /**\n+     * This method is called each time new data has been polled from the modbus slave\n+     * The register array is first parsed, then each of the channels are updated\n+     * to the new values\n+     *\n+     * @param n register readed\n+     * @param registers byte array read from the modbus slave\n+     */\n+    protected void handlePolledData(int registerNumber, ModbusRegisterArray registers) {\n+        String hexString = registers.toHexString().toString();\n+        Object quantity = parser.hexToFloat(hexString);\n+        if (quantity != null) {\n+            if (type.equals(THING_TYPE_BSP)) {\n+                updateState(CHANNELS_BSP.get(registerNumber),\n+                        new QuantityType<>((float) quantity, UNIT_CHANNELS_BSP.get(registerNumber)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef8c36c89dd25dfc366754439f5d01bf55f443ef"}, "originalPosition": 307}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4MzQxMzc0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.modbus.studer/src/main/java/org/openhab/binding/modbus/studer/internal/StuderHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxMDo1MjowNFrOHHGoLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxMDo1MjowNFrOHHGoLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzIxMDY3MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                protected void handlePolledDataVarioString(int registerNumber, Object quantity) {\n          \n          \n            \n                protected void handlePolledDataVarioString(int registerNumber, Float quantity) {", "url": "https://github.com/openhab/openhab-addons/pull/8163#discussion_r477210670", "createdAt": "2020-08-26T10:52:04Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.modbus.studer/src/main/java/org/openhab/binding/modbus/studer/internal/StuderHandler.java", "diffHunk": "@@ -0,0 +1,425 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.studer.internal;\n+\n+import static org.openhab.binding.modbus.studer.internal.StuderBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.ModeXtender;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.State;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VSMode;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VTMode;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VTType;\n+import org.openhab.io.transport.modbus.AsyncModbusFailure;\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link StuderHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Giovanni Mirulla - Initial contribution\n+ */\n+@NonNullByDefault\n+public class StuderHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(StuderHandler.class);\n+\n+    private @Nullable StuderConfiguration config;\n+\n+    /**\n+     * Array of tasks used to poll the device\n+     */\n+    private ArrayList<PollTask> pollTasks = new ArrayList<PollTask>();\n+\n+    /**\n+     * Communication interface to the slave endpoint we're connecting to\n+     */\n+    protected volatile @Nullable ModbusCommunicationInterface comms = null;\n+\n+    /**\n+     * Importing parser methods and enums\n+     */\n+    final StuderParser parser = new StuderParser();\n+    /**\n+     * Support variable for type of thing\n+     */\n+    protected ThingTypeUID type;\n+\n+    /**\n+     * Array of registers of Studer slave to read, we store this once initialization is complete\n+     */\n+    private Integer[] registers = new Integer[0];\n+\n+    /**\n+     * Instances of this handler\n+     *\n+     * @param thing the thing to handle\n+     * @param type the type of thing to handle\n+     * @param slaveAddress the address of thing\n+     * @param refreshSec the address of thing\n+     */\n+    public StuderHandler(Thing thing) {\n+        super(thing);\n+        this.type = thing.getThingTypeUID();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+\n+        // Currently we do not support any commands\n+    }\n+\n+    /**\n+     * Initialization:\n+     * Load the config object\n+     * Connect to the slave bridge\n+     * Get registers to poll\n+     * Start the periodic polling\n+     */\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(StuderConfiguration.class);\n+        logger.debug(\"Initializing thing with configuration: {}\", thing.getConfiguration());\n+\n+        startUp();\n+    }\n+\n+    /*\n+     * This method starts the operation of this handler\n+     * Connect to the slave bridge\n+     * Get registers to poll\n+     * Start the periodic polling\n+     */\n+    private void startUp() {\n+\n+        connectEndpoint();\n+\n+        if (comms == null || config == null) {\n+            logger.debug(\"Invalid endpoint/config/manager ref for studer handler\");\n+            return;\n+        }\n+\n+        if (!pollTasks.isEmpty()) {\n+            return;\n+        }\n+\n+        if (type.equals(THING_TYPE_BSP)) {\n+            Set<Integer> keys = CHANNELS_BSP.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_XTENDER)) {\n+            Set<Integer> keys = CHANNELS_XTENDER.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_VARIOTRACK)) {\n+            Set<Integer> keys = CHANNELS_VARIOTRACK.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_VARIOSTRING)) {\n+            Set<Integer> keys = CHANNELS_VARIOSTRING.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        }\n+\n+        for (int r : registers) {\n+            registerPollTask(r);\n+\n+        }\n+    }\n+\n+    /**\n+     * Dispose the binding correctly\n+     */\n+    @Override\n+    public void dispose() {\n+        tearDown();\n+    }\n+\n+    /**\n+     * Unregister the poll tasks and release the endpoint reference\n+     */\n+    private void tearDown() {\n+        unregisterPollTasks();\n+        unregisterEndpoint();\n+    }\n+\n+    /**\n+     * Get the endpoint handler from the bridge this handler is connected to\n+     * Checks that we're connected to the right type of bridge\n+     *\n+     * @return the endpoint handler or null if the bridge does not exist\n+     */\n+    private @Nullable ModbusEndpointThingHandler getEndpointThingHandler() {\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"Bridge is null\");\n+            return null;\n+        }\n+        if (bridge.getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Bridge is not online\");\n+            return null;\n+        }\n+\n+        ThingHandler handler = bridge.getHandler();\n+        if (handler == null) {\n+            logger.debug(\"Bridge handler is null\");\n+            return null;\n+        }\n+\n+        if (handler instanceof ModbusEndpointThingHandler) {\n+            ModbusEndpointThingHandler slaveEndpoint = (ModbusEndpointThingHandler) handler;\n+            return slaveEndpoint;\n+        } else {\n+            logger.debug(\"Unexpected bridge handler: {}\", handler);\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Get a reference to the modbus endpoint\n+     */\n+    private void connectEndpoint() {\n+        if (comms != null) {\n+            return;\n+        }\n+\n+        ModbusEndpointThingHandler slaveEndpointThingHandler = getEndpointThingHandler();\n+        if (slaveEndpointThingHandler == null) {\n+            @SuppressWarnings(\"null\")\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\n+                    String.format(\"Bridge '%s' is offline\", label));\n+            logger.debug(\"No bridge handler available -- aborting init for {}\", label);\n+            return;\n+        }\n+        comms = slaveEndpointThingHandler.getCommunicationInterface();\n+        if (comms == null) {\n+            @SuppressWarnings(\"null\")\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\n+                    String.format(\"Bridge '%s' not completely initialized\", label));\n+            logger.debug(\"Bridge not initialized fully (no endpoint) -- aborting init for {}\", this);\n+            return;\n+        }\n+    }\n+\n+    /**\n+     * Remove the endpoint if exists\n+     */\n+    private void unregisterEndpoint() {\n+        // Comms will be close()'d by endpoint thing handler\n+        comms = null;\n+    }\n+\n+    private synchronized void unregisterPollTasks() {\n+        if (pollTasks.isEmpty()) {\n+            return;\n+        }\n+        logger.debug(\"Unregistering polling from ModbusManager\");\n+        ModbusCommunicationInterface mycomms = comms;\n+        if (mycomms != null) {\n+            for (PollTask t : pollTasks) {\n+                mycomms.unregisterRegularPoll(t);\n+            }\n+            pollTasks.clear();\n+        }\n+    }\n+\n+    /**\n+     * Register poll task\n+     * This is where we set up our regular poller\n+     */\n+    private synchronized void registerPollTask(int registerNumber) {\n+        if (pollTasks.size() >= registers.length) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+            throw new IllegalStateException(\"New pollTask invalid\");\n+        }\n+        ModbusCommunicationInterface mycomms = comms;\n+        StuderConfiguration studerConfig = config;\n+        if (studerConfig == null || mycomms == null) {\n+            throw new IllegalStateException(\"registerPollTask called without proper configuration\");\n+        }\n+\n+        logger.debug(\"Setting up regular polling\");\n+\n+        ModbusReadRequestBlueprint request = new ModbusReadRequestBlueprint(studerConfig.slaveAddress,\n+                ModbusReadFunctionCode.READ_INPUT_REGISTERS, registerNumber, 2, studerConfig.maxTries);\n+        long refreshMillis = studerConfig.refreshSec * 1000;\n+        PollTask pollTask = mycomms.registerRegularPoll(request, refreshMillis, 1000, result -> {\n+            if (result.getRegisters().isPresent()) {\n+                ModbusRegisterArray reg = result.getRegisters().get();\n+                handlePolledData(registerNumber, reg);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR);\n+                return;\n+            }\n+            if (getThing().getStatus() != ThingStatus.ONLINE) {\n+                updateStatus(ThingStatus.ONLINE);\n+            }\n+        }, this::handleError);\n+        pollTasks.add(pollTask);\n+    }\n+\n+    /**\n+     * This method is called each time new data has been polled from the modbus slave\n+     * The register array is first parsed, then each of the channels are updated\n+     * to the new values\n+     *\n+     * @param n register readed\n+     * @param registers byte array read from the modbus slave\n+     */\n+    protected void handlePolledData(int registerNumber, ModbusRegisterArray registers) {\n+        String hexString = registers.toHexString().toString();\n+        Object quantity = parser.hexToFloat(hexString);\n+        if (quantity != null) {\n+            if (type.equals(THING_TYPE_BSP)) {\n+                updateState(CHANNELS_BSP.get(registerNumber),\n+                        new QuantityType<>((float) quantity, UNIT_CHANNELS_BSP.get(registerNumber)));\n+            } else if (type.equals(THING_TYPE_XTENDER)) {\n+                handlePolledDataXtender(registerNumber, quantity);\n+            } else if (type.equals(THING_TYPE_VARIOTRACK)) {\n+                handlePolledDataVarioTrack(registerNumber, quantity);\n+            } else if (type.equals(THING_TYPE_VARIOSTRING)) {\n+                handlePolledDataVarioString(registerNumber, quantity);\n+            }\n+        }\n+        resetCommunicationError();\n+    }\n+\n+    /**\n+     * This method is called each time new data has been polled from the VarioString slave\n+     * The register array is first parsed, then each of the channels are updated\n+     * to the new values\n+     */\n+    protected void handlePolledDataVarioString(int registerNumber, Object quantity) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef8c36c89dd25dfc366754439f5d01bf55f443ef"}, "originalPosition": 324}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4MzQxNTM1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.modbus.studer/src/main/java/org/openhab/binding/modbus/studer/internal/StuderHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxMDo1MjozOFrOHHGpLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxMDo1MjozOFrOHHGpLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzIxMDkyNQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            VSMode vsmode = StuderParser.getVSModeByCode((int) (float) quantity);\n          \n          \n            \n                            VSMode vsmode = StuderParser.getVSModeByCode(quantity.intValue());", "url": "https://github.com/openhab/openhab-addons/pull/8163#discussion_r477210925", "createdAt": "2020-08-26T10:52:38Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.modbus.studer/src/main/java/org/openhab/binding/modbus/studer/internal/StuderHandler.java", "diffHunk": "@@ -0,0 +1,425 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.studer.internal;\n+\n+import static org.openhab.binding.modbus.studer.internal.StuderBindingConstants.*;\n+\n+import java.util.ArrayList;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.openhab.binding.modbus.handler.ModbusEndpointThingHandler;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.ModeXtender;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.State;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VSMode;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VTMode;\n+import org.openhab.binding.modbus.studer.internal.StuderParser.VTType;\n+import org.openhab.io.transport.modbus.AsyncModbusFailure;\n+import org.openhab.io.transport.modbus.ModbusCommunicationInterface;\n+import org.openhab.io.transport.modbus.ModbusReadFunctionCode;\n+import org.openhab.io.transport.modbus.ModbusReadRequestBlueprint;\n+import org.openhab.io.transport.modbus.ModbusRegisterArray;\n+import org.openhab.io.transport.modbus.PollTask;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link StuderHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Giovanni Mirulla - Initial contribution\n+ */\n+@NonNullByDefault\n+public class StuderHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(StuderHandler.class);\n+\n+    private @Nullable StuderConfiguration config;\n+\n+    /**\n+     * Array of tasks used to poll the device\n+     */\n+    private ArrayList<PollTask> pollTasks = new ArrayList<PollTask>();\n+\n+    /**\n+     * Communication interface to the slave endpoint we're connecting to\n+     */\n+    protected volatile @Nullable ModbusCommunicationInterface comms = null;\n+\n+    /**\n+     * Importing parser methods and enums\n+     */\n+    final StuderParser parser = new StuderParser();\n+    /**\n+     * Support variable for type of thing\n+     */\n+    protected ThingTypeUID type;\n+\n+    /**\n+     * Array of registers of Studer slave to read, we store this once initialization is complete\n+     */\n+    private Integer[] registers = new Integer[0];\n+\n+    /**\n+     * Instances of this handler\n+     *\n+     * @param thing the thing to handle\n+     * @param type the type of thing to handle\n+     * @param slaveAddress the address of thing\n+     * @param refreshSec the address of thing\n+     */\n+    public StuderHandler(Thing thing) {\n+        super(thing);\n+        this.type = thing.getThingTypeUID();\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+\n+        // Currently we do not support any commands\n+    }\n+\n+    /**\n+     * Initialization:\n+     * Load the config object\n+     * Connect to the slave bridge\n+     * Get registers to poll\n+     * Start the periodic polling\n+     */\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(StuderConfiguration.class);\n+        logger.debug(\"Initializing thing with configuration: {}\", thing.getConfiguration());\n+\n+        startUp();\n+    }\n+\n+    /*\n+     * This method starts the operation of this handler\n+     * Connect to the slave bridge\n+     * Get registers to poll\n+     * Start the periodic polling\n+     */\n+    private void startUp() {\n+\n+        connectEndpoint();\n+\n+        if (comms == null || config == null) {\n+            logger.debug(\"Invalid endpoint/config/manager ref for studer handler\");\n+            return;\n+        }\n+\n+        if (!pollTasks.isEmpty()) {\n+            return;\n+        }\n+\n+        if (type.equals(THING_TYPE_BSP)) {\n+            Set<Integer> keys = CHANNELS_BSP.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_XTENDER)) {\n+            Set<Integer> keys = CHANNELS_XTENDER.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_VARIOTRACK)) {\n+            Set<Integer> keys = CHANNELS_VARIOTRACK.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        } else if (type.equals(THING_TYPE_VARIOSTRING)) {\n+            Set<Integer> keys = CHANNELS_VARIOSTRING.keySet();\n+            registers = keys.toArray(new Integer[keys.size()]);\n+        }\n+\n+        for (int r : registers) {\n+            registerPollTask(r);\n+\n+        }\n+    }\n+\n+    /**\n+     * Dispose the binding correctly\n+     */\n+    @Override\n+    public void dispose() {\n+        tearDown();\n+    }\n+\n+    /**\n+     * Unregister the poll tasks and release the endpoint reference\n+     */\n+    private void tearDown() {\n+        unregisterPollTasks();\n+        unregisterEndpoint();\n+    }\n+\n+    /**\n+     * Get the endpoint handler from the bridge this handler is connected to\n+     * Checks that we're connected to the right type of bridge\n+     *\n+     * @return the endpoint handler or null if the bridge does not exist\n+     */\n+    private @Nullable ModbusEndpointThingHandler getEndpointThingHandler() {\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            logger.debug(\"Bridge is null\");\n+            return null;\n+        }\n+        if (bridge.getStatus() != ThingStatus.ONLINE) {\n+            logger.debug(\"Bridge is not online\");\n+            return null;\n+        }\n+\n+        ThingHandler handler = bridge.getHandler();\n+        if (handler == null) {\n+            logger.debug(\"Bridge handler is null\");\n+            return null;\n+        }\n+\n+        if (handler instanceof ModbusEndpointThingHandler) {\n+            ModbusEndpointThingHandler slaveEndpoint = (ModbusEndpointThingHandler) handler;\n+            return slaveEndpoint;\n+        } else {\n+            logger.debug(\"Unexpected bridge handler: {}\", handler);\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Get a reference to the modbus endpoint\n+     */\n+    private void connectEndpoint() {\n+        if (comms != null) {\n+            return;\n+        }\n+\n+        ModbusEndpointThingHandler slaveEndpointThingHandler = getEndpointThingHandler();\n+        if (slaveEndpointThingHandler == null) {\n+            @SuppressWarnings(\"null\")\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\n+                    String.format(\"Bridge '%s' is offline\", label));\n+            logger.debug(\"No bridge handler available -- aborting init for {}\", label);\n+            return;\n+        }\n+        comms = slaveEndpointThingHandler.getCommunicationInterface();\n+        if (comms == null) {\n+            @SuppressWarnings(\"null\")\n+            String label = Optional.ofNullable(getBridge()).map(b -> b.getLabel()).orElse(\"<null>\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE,\n+                    String.format(\"Bridge '%s' not completely initialized\", label));\n+            logger.debug(\"Bridge not initialized fully (no endpoint) -- aborting init for {}\", this);\n+            return;\n+        }\n+    }\n+\n+    /**\n+     * Remove the endpoint if exists\n+     */\n+    private void unregisterEndpoint() {\n+        // Comms will be close()'d by endpoint thing handler\n+        comms = null;\n+    }\n+\n+    private synchronized void unregisterPollTasks() {\n+        if (pollTasks.isEmpty()) {\n+            return;\n+        }\n+        logger.debug(\"Unregistering polling from ModbusManager\");\n+        ModbusCommunicationInterface mycomms = comms;\n+        if (mycomms != null) {\n+            for (PollTask t : pollTasks) {\n+                mycomms.unregisterRegularPoll(t);\n+            }\n+            pollTasks.clear();\n+        }\n+    }\n+\n+    /**\n+     * Register poll task\n+     * This is where we set up our regular poller\n+     */\n+    private synchronized void registerPollTask(int registerNumber) {\n+        if (pollTasks.size() >= registers.length) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+            throw new IllegalStateException(\"New pollTask invalid\");\n+        }\n+        ModbusCommunicationInterface mycomms = comms;\n+        StuderConfiguration studerConfig = config;\n+        if (studerConfig == null || mycomms == null) {\n+            throw new IllegalStateException(\"registerPollTask called without proper configuration\");\n+        }\n+\n+        logger.debug(\"Setting up regular polling\");\n+\n+        ModbusReadRequestBlueprint request = new ModbusReadRequestBlueprint(studerConfig.slaveAddress,\n+                ModbusReadFunctionCode.READ_INPUT_REGISTERS, registerNumber, 2, studerConfig.maxTries);\n+        long refreshMillis = studerConfig.refreshSec * 1000;\n+        PollTask pollTask = mycomms.registerRegularPoll(request, refreshMillis, 1000, result -> {\n+            if (result.getRegisters().isPresent()) {\n+                ModbusRegisterArray reg = result.getRegisters().get();\n+                handlePolledData(registerNumber, reg);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR);\n+                return;\n+            }\n+            if (getThing().getStatus() != ThingStatus.ONLINE) {\n+                updateStatus(ThingStatus.ONLINE);\n+            }\n+        }, this::handleError);\n+        pollTasks.add(pollTask);\n+    }\n+\n+    /**\n+     * This method is called each time new data has been polled from the modbus slave\n+     * The register array is first parsed, then each of the channels are updated\n+     * to the new values\n+     *\n+     * @param n register readed\n+     * @param registers byte array read from the modbus slave\n+     */\n+    protected void handlePolledData(int registerNumber, ModbusRegisterArray registers) {\n+        String hexString = registers.toHexString().toString();\n+        Object quantity = parser.hexToFloat(hexString);\n+        if (quantity != null) {\n+            if (type.equals(THING_TYPE_BSP)) {\n+                updateState(CHANNELS_BSP.get(registerNumber),\n+                        new QuantityType<>((float) quantity, UNIT_CHANNELS_BSP.get(registerNumber)));\n+            } else if (type.equals(THING_TYPE_XTENDER)) {\n+                handlePolledDataXtender(registerNumber, quantity);\n+            } else if (type.equals(THING_TYPE_VARIOTRACK)) {\n+                handlePolledDataVarioTrack(registerNumber, quantity);\n+            } else if (type.equals(THING_TYPE_VARIOSTRING)) {\n+                handlePolledDataVarioString(registerNumber, quantity);\n+            }\n+        }\n+        resetCommunicationError();\n+    }\n+\n+    /**\n+     * This method is called each time new data has been polled from the VarioString slave\n+     * The register array is first parsed, then each of the channels are updated\n+     * to the new values\n+     */\n+    protected void handlePolledDataVarioString(int registerNumber, Object quantity) {\n+        switch (CHANNELS_VARIOSTRING.get(registerNumber)) {\n+            case CHANNEL_PV_OPERATING_MODE:\n+            case CHANNEL_PV1_OPERATING_MODE:\n+            case CHANNEL_PV2_OPERATING_MODE:\n+                VSMode vsmode = StuderParser.getVSModeByCode((int) (float) quantity);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef8c36c89dd25dfc366754439f5d01bf55f443ef"}, "originalPosition": 329}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4MzQyNjIxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.modbus.studer/src/main/resources/ESH-INF/thing/VarioTrack-channel-types.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxMDo1NjoxMVrOHHGv4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxMDo1NjoxMVrOHHGv4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzIxMjY0MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t<label>Voltage of the PV Generator</label>\n          \n          \n            \n            \t\t<label>PV Generator Voltage</label>", "url": "https://github.com/openhab/openhab-addons/pull/8163#discussion_r477212641", "createdAt": "2020-08-26T10:56:11Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.modbus.studer/src/main/resources/ESH-INF/thing/VarioTrack-channel-types.xml", "diffHunk": "@@ -0,0 +1,66 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"modbus\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<!-- Model of VarioTrack Channel Type -->\n+\t<channel-type id=\"Type\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Model of VarioTrack</label>\n+\t\t<state readOnly=\"true\">\n+\t\t\t<options>\n+\t\t\t\t<option value=\"VT80\">VT-80</option>\n+\t\t\t\t<option value=\"VT65\">VT-65</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\t<!-- Voltage of the PV generator Channel Type -->\n+\t<channel-type id=\"Upv\">\n+\t\t<item-type>Number:ElectricPotential</item-type>\n+\t\t<label>Voltage of the PV Generator</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef8c36c89dd25dfc366754439f5d01bf55f443ef"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4MzQyODY1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.modbus.studer/src/main/resources/ESH-INF/thing/VarioTrack-channel-types.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxMDo1Njo1NVrOHHGxZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxMDo1Njo1NVrOHHGxZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzIxMzAzMQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t<label>Production in (kWh) for the Current Day</label>\n          \n          \n            \n            \t\t<label>Current Day Production</label>\n          \n      \n    \n    \n  \n\nThe label text you have is more a description. Maybe add it as description.", "url": "https://github.com/openhab/openhab-addons/pull/8163#discussion_r477213031", "createdAt": "2020-08-26T10:56:55Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.modbus.studer/src/main/resources/ESH-INF/thing/VarioTrack-channel-types.xml", "diffHunk": "@@ -0,0 +1,66 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"modbus\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<!-- Model of VarioTrack Channel Type -->\n+\t<channel-type id=\"Type\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Model of VarioTrack</label>\n+\t\t<state readOnly=\"true\">\n+\t\t\t<options>\n+\t\t\t\t<option value=\"VT80\">VT-80</option>\n+\t\t\t\t<option value=\"VT65\">VT-65</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\t<!-- Voltage of the PV generator Channel Type -->\n+\t<channel-type id=\"Upv\">\n+\t\t<item-type>Number:ElectricPotential</item-type>\n+\t\t<label>Voltage of the PV Generator</label>\n+\t\t<state readOnly=\"true\" pattern=\"%.2f %unit%\"/>\n+\t</channel-type>\n+\t<!-- Power of the PV generator Channel Type -->\n+\t<channel-type id=\"Psol\">\n+\t\t<item-type>Number:Power</item-type>\n+\t\t<label>Power of the PV Generator</label>\n+\t\t<state readOnly=\"true\" pattern=\"%.2f %unit%\"/>\n+\t</channel-type>\n+\t<!-- Production in (kWh) for the current day Channel Type -->\n+\t<channel-type id=\"Ed\">\n+\t\t<item-type>Number:Energy</item-type>\n+\t\t<label>Production in (kWh) for the Current Day</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef8c36c89dd25dfc366754439f5d01bf55f443ef"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4MzQ0MjQ3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.modbus.studer/README.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxMTowMToyN1rOHHG56A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNVQxMzo1MDo0OFrOHNiJSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzIxNTIwOA==", "bodyText": "Any reason these channels have uppercase first character.\nIt also looks these channels could be designed as groups. So a group for pv,  pv1 and pv2?", "url": "https://github.com/openhab/openhab-addons/pull/8163#discussion_r477215208", "createdAt": "2020-08-26T11:01:27Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.modbus.studer/README.md", "diffHunk": "@@ -0,0 +1,142 @@\n+# Studer\n+\n+This extension adds support for the Studer protocol.\n+\n+Studer Innotec, founded in 1987 by Roland Studer, is an ISO certified company that develops and manufactures inverters, inverter/chargers and MPPT solar charge controllers to communicate over the Modbus protocol entirely in Switzerland \n+\n+For a list of certified products see this page: https://www.studer-innotec.com/\n+\n+## Supported Things\n+\n+This bundle adds the following thing type to the Modbus binding.\n+Note, that the things will show up under the Modbus binding.\n+\n+| Thing Type IDs | Description |Picture |\n+| --- | --- | --- |\n+| bsp | For BSP that offer a highly precise measuring for Xtender, VarioTrack and VarioString systems | ![BSP](doc/bsp.png) |\n+| xtender | For the Xtender models for system capacities from 0.5kVA to 72kVA that allow for the optimal use of available energy | ![Xtender](doc/xtender.png) |\n+| variotrack | For the VarioTrack models of MPPT solar charge controllers for systems with solar PV capacity from 1 - 75kWp | ![VarioTrack](doc/variotrack.png) |\n+| variostring | For the VarioString models of MPPT solar charge controllers for systems with solar PV capacity from 4  | ![VarioString](doc/variostring.png) |\n+\n+\n+## Thing Configuration\n+\n+You need first to set up a Serial Modbus bridge according to the Modbus documentation.\n+Things in this extension will use the selected bridge to connect to the device.\n+\n+For defining a thing textually, you have to find out the start address of the model block and the length of it.\n+While the length is usually fixed, the address is not.\n+Please refer to your device's vendor documentation how model blocks are laid for your equipment.\n+\n+The following parameters are valid for all thing types:\n+\n+| Parameter | Type    | Required | Default if omitted  | Description                             |\n+|-----------|---------|----------|---------------------|-----------------------------------------|\n+| address   | integer | yes      | `first slave of device`       | Address of slave       |\n+| refresh   | integer | yes       | 5                   | Poll interval in seconds. Increase this if you encounter connection errors |\n+\n+## Channels\n+\n+The following Channels, and their associated channel types are shown below divided by device.\n+\n+#### BSP \n+\n+All channels read for a BSP device\n+\n+| Channel            | Type                     | Description           |\n+| ------------------ | ------------------------ | --------------------- |\n+| power              | Number:Power             | Power                 |\n+| batteryVoltage     | Number:ElectricPotential | Battery voltage       |\n+| batteryCurrent     | Number:ElectricCurrent   | Battery current       |\n+| stateOfCharge      | Number:Dimensionless     | State of Charge       |\n+| batteryTemperature | Number:Temperature       | Battery temperature   |\n+\n+#### Xtender \n+\n+All channels read for a Xtender device\n+\n+| Channel           | Type                     | Description             |\n+| ----------------- | ------------------------ | ----------------------- |\n+| inputVoltage      | Number:ElectricPotential | Input voltage           |\n+| inputCurrent      | Number:ElectricCurrent   | Input current           |\n+| inputActivePower  | Number:Power             | Input active power      |\n+| inputFrequency    | Number:Frequency         | Input frequency         |\n+| outputVoltage     | Number:ElectricPotential | Output voltage          |\n+| outputCurrent     | Number:ElectricCurrent   | Output current          |\n+| outputActivePower | Number:Power             | Output active power     |\n+| outputFrequency   | Number:Frequency         | Output frequency        |\n+| operatingState    | String                   | Operating state         |\n+| stateInverter     | String                   | State of the inverter   |\n+\n+#### VarioTrack \n+\n+All channels read for a VarioTrack device\n+\n+| Channel              | Type                     | Description                               |\n+| -------------------- | ------------------------ | ----------------------------------------- |\n+| modelVarioTrack      | String                   | Model of VarioTrack                       |\n+| voltagePVGenerator   | Number:ElectricPotential | Voltage of the PV generator               |\n+| powerPVGenerator     | Number:Power             | Power of the PV generator                 |\n+| productionCurrentDay | Number:Energy            | Production in (kWh) for the current day   |\n+| batteryVoltage       | Number:ElectricPotential | Battery voltage                           |\n+| batteryCurrent       | Number:ElectricCurrent   | Battery current                           |\n+| operatingMode        | String                   | Operating mode                            |\n+| stateVarioTrack      | String                   | State of the VarioTrack                   |\n+\n+#### VarioString \n+\n+All channels read for a VarioString device\n+\n+| Channel                 | Type                     | Description                                   |\n+| ----------------------- | ------------------------ | --------------------------------------------- |\n+| PVVoltage               | Number:ElectricPotential | PV voltage                                    |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef8c36c89dd25dfc366754439f5d01bf55f443ef"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzk1Mjk2OA==", "bodyText": "PV I think is an acronym. I would like to group them into groups but I don't know how.", "url": "https://github.com/openhab/openhab-addons/pull/8163#discussion_r483952968", "createdAt": "2020-09-05T13:50:48Z", "author": {"login": "giovannimirulla"}, "path": "bundles/org.openhab.binding.modbus.studer/README.md", "diffHunk": "@@ -0,0 +1,142 @@\n+# Studer\n+\n+This extension adds support for the Studer protocol.\n+\n+Studer Innotec, founded in 1987 by Roland Studer, is an ISO certified company that develops and manufactures inverters, inverter/chargers and MPPT solar charge controllers to communicate over the Modbus protocol entirely in Switzerland \n+\n+For a list of certified products see this page: https://www.studer-innotec.com/\n+\n+## Supported Things\n+\n+This bundle adds the following thing type to the Modbus binding.\n+Note, that the things will show up under the Modbus binding.\n+\n+| Thing Type IDs | Description |Picture |\n+| --- | --- | --- |\n+| bsp | For BSP that offer a highly precise measuring for Xtender, VarioTrack and VarioString systems | ![BSP](doc/bsp.png) |\n+| xtender | For the Xtender models for system capacities from 0.5kVA to 72kVA that allow for the optimal use of available energy | ![Xtender](doc/xtender.png) |\n+| variotrack | For the VarioTrack models of MPPT solar charge controllers for systems with solar PV capacity from 1 - 75kWp | ![VarioTrack](doc/variotrack.png) |\n+| variostring | For the VarioString models of MPPT solar charge controllers for systems with solar PV capacity from 4  | ![VarioString](doc/variostring.png) |\n+\n+\n+## Thing Configuration\n+\n+You need first to set up a Serial Modbus bridge according to the Modbus documentation.\n+Things in this extension will use the selected bridge to connect to the device.\n+\n+For defining a thing textually, you have to find out the start address of the model block and the length of it.\n+While the length is usually fixed, the address is not.\n+Please refer to your device's vendor documentation how model blocks are laid for your equipment.\n+\n+The following parameters are valid for all thing types:\n+\n+| Parameter | Type    | Required | Default if omitted  | Description                             |\n+|-----------|---------|----------|---------------------|-----------------------------------------|\n+| address   | integer | yes      | `first slave of device`       | Address of slave       |\n+| refresh   | integer | yes       | 5                   | Poll interval in seconds. Increase this if you encounter connection errors |\n+\n+## Channels\n+\n+The following Channels, and their associated channel types are shown below divided by device.\n+\n+#### BSP \n+\n+All channels read for a BSP device\n+\n+| Channel            | Type                     | Description           |\n+| ------------------ | ------------------------ | --------------------- |\n+| power              | Number:Power             | Power                 |\n+| batteryVoltage     | Number:ElectricPotential | Battery voltage       |\n+| batteryCurrent     | Number:ElectricCurrent   | Battery current       |\n+| stateOfCharge      | Number:Dimensionless     | State of Charge       |\n+| batteryTemperature | Number:Temperature       | Battery temperature   |\n+\n+#### Xtender \n+\n+All channels read for a Xtender device\n+\n+| Channel           | Type                     | Description             |\n+| ----------------- | ------------------------ | ----------------------- |\n+| inputVoltage      | Number:ElectricPotential | Input voltage           |\n+| inputCurrent      | Number:ElectricCurrent   | Input current           |\n+| inputActivePower  | Number:Power             | Input active power      |\n+| inputFrequency    | Number:Frequency         | Input frequency         |\n+| outputVoltage     | Number:ElectricPotential | Output voltage          |\n+| outputCurrent     | Number:ElectricCurrent   | Output current          |\n+| outputActivePower | Number:Power             | Output active power     |\n+| outputFrequency   | Number:Frequency         | Output frequency        |\n+| operatingState    | String                   | Operating state         |\n+| stateInverter     | String                   | State of the inverter   |\n+\n+#### VarioTrack \n+\n+All channels read for a VarioTrack device\n+\n+| Channel              | Type                     | Description                               |\n+| -------------------- | ------------------------ | ----------------------------------------- |\n+| modelVarioTrack      | String                   | Model of VarioTrack                       |\n+| voltagePVGenerator   | Number:ElectricPotential | Voltage of the PV generator               |\n+| powerPVGenerator     | Number:Power             | Power of the PV generator                 |\n+| productionCurrentDay | Number:Energy            | Production in (kWh) for the current day   |\n+| batteryVoltage       | Number:ElectricPotential | Battery voltage                           |\n+| batteryCurrent       | Number:ElectricCurrent   | Battery current                           |\n+| operatingMode        | String                   | Operating mode                            |\n+| stateVarioTrack      | String                   | State of the VarioTrack                   |\n+\n+#### VarioString \n+\n+All channels read for a VarioString device\n+\n+| Channel                 | Type                     | Description                                   |\n+| ----------------------- | ------------------------ | --------------------------------------------- |\n+| PVVoltage               | Number:ElectricPotential | PV voltage                                    |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzIxNTIwOA=="}, "originalCommit": {"oid": "ef8c36c89dd25dfc366754439f5d01bf55f443ef"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4MzQ0NDAzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.modbus.studer/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxMTowMTo1NFrOHHG60g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxMTowMTo1NFrOHHG60g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzIxNTQ0Mg==", "bodyText": "Can you format this table. You can use http://markdowntable.com/", "url": "https://github.com/openhab/openhab-addons/pull/8163#discussion_r477215442", "createdAt": "2020-08-26T11:01:54Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.modbus.studer/README.md", "diffHunk": "@@ -0,0 +1,142 @@\n+# Studer\n+\n+This extension adds support for the Studer protocol.\n+\n+Studer Innotec, founded in 1987 by Roland Studer, is an ISO certified company that develops and manufactures inverters, inverter/chargers and MPPT solar charge controllers to communicate over the Modbus protocol entirely in Switzerland \n+\n+For a list of certified products see this page: https://www.studer-innotec.com/\n+\n+## Supported Things\n+\n+This bundle adds the following thing type to the Modbus binding.\n+Note, that the things will show up under the Modbus binding.\n+\n+| Thing Type IDs | Description |Picture |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef8c36c89dd25dfc366754439f5d01bf55f443ef"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4MzQ0NTUyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.modbus.studer/src/main/resources/ESH-INF/thing/thing-types.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxMTowMjoyNVrOHHG72Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxMTowMjoyNVrOHHG72Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzIxNTcwNQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t<label>VarioString Studer Thing</label>\n          \n          \n            \n            \t\t<label>VarioString Studer</label>", "url": "https://github.com/openhab/openhab-addons/pull/8163#discussion_r477215705", "createdAt": "2020-08-26T11:02:25Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.modbus.studer/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,147 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"modbus\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<!-- BSP Thing Type -->\n+\t<thing-type id=\"bsp\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"serial\"/>\n+\t\t</supported-bridge-type-refs>\n+\t\t<label>BSP Studer Thing</label>\n+\t\t<description>Thing for Studer BSP Device</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"batteryVoltage\" typeId=\"Ubat\"/>\n+\t\t\t<channel id=\"batteryCurrent\" typeId=\"Ibat\"/>\n+\t\t\t<channel id=\"power\" typeId=\"Pbat\"/>\n+\t\t\t<channel id=\"stateOfCharge\" typeId=\"SOC\"/>\n+\t\t\t<channel id=\"batteryTemperature\" typeId=\"Tbat\"/>\n+\t\t</channels>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"slaveAddress\" type=\"integer\" min=\"60\" max=\"61\">\n+\t\t\t\t<label>Slave Address</label>\n+\t\t\t\t<description>Slave address of BSP device</description>\n+\t\t\t\t<default>60</default>\n+\t\t\t\t<required>true</required>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refreshSec\" type=\"integer\" min=\"1\" unit=\"s\">\n+\t\t\t\t<label>Refresh Interval</label>\n+\t\t\t\t<description>Poll interval</description>\n+\t\t\t\t<default>5</default>\n+\t\t\t\t<required>true</required>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\t<!-- Xtender Thing Type -->\n+\t<thing-type id=\"xtender\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"serial\"/>\n+\t\t</supported-bridge-type-refs>\n+\t\t<label>Xtender Studer Thing</label>\n+\t\t<description>Thing for Studer Xtender Device</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"inputVoltage\" typeId=\"Uin\"/>\n+\t\t\t<channel id=\"inputCurrent\" typeId=\"Iin\"/>\n+\t\t\t<channel id=\"inputActivePower\" typeId=\"Pina\"/>\n+\t\t\t<channel id=\"inputFrequency\" typeId=\"Fin\"/>\n+\t\t\t<channel id=\"outputVoltage\" typeId=\"Uout\"/>\n+\t\t\t<channel id=\"outputCurrent\" typeId=\"Iout\"/>\n+\t\t\t<channel id=\"outputActivePower\" typeId=\"Pouta\"/>\n+\t\t\t<channel id=\"outputFrequency\" typeId=\"Fout\"/>\n+\t\t\t<channel id=\"operatingState\" typeId=\"Mode\"/>\n+\t\t\t<channel id=\"stateInverter\" typeId=\"XTstate\"/>\n+\t\t</channels>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"slaveAddress\" type=\"integer\" min=\"10\" max=\"19\">\n+\t\t\t\t<label>Slave Address</label>\n+\t\t\t\t<description>Slave address of Xtender device</description>\n+\t\t\t\t<default>10</default>\n+\t\t\t\t<required>true</required>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refreshSec\" type=\"integer\" min=\"1\" unit=\"s\">\n+\t\t\t\t<label>Refresh Interval</label>\n+\t\t\t\t<description>Poll interval</description>\n+\t\t\t\t<default>5</default>\n+\t\t\t\t<required>true</required>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\t<!-- VarioTrack Thing Type -->\n+\t<thing-type id=\"variotrack\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"serial\"/>\n+\t\t</supported-bridge-type-refs>\n+\t\t<label>VarioTrack Studer Thing</label>\n+\t\t<description>Thing for Studer VarioTrack Device</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"batteryVoltage\" typeId=\"Ubat\"/>\n+\t\t\t<channel id=\"batteryCurrent\" typeId=\"Ibat\"/>\n+\t\t\t<channel id=\"modelVarioTrack\" typeId=\"Type\"/>\n+\t\t\t<channel id=\"voltagePVGenerator\" typeId=\"Upv\"/>\n+\t\t\t<channel id=\"powerPVGenerator\" typeId=\"Psol\"/>\n+\t\t\t<channel id=\"productionCurrentDay\" typeId=\"Ed\"/>\n+\t\t\t<channel id=\"operatingMode\" typeId=\"Mode\"/>\n+\t\t\t<channel id=\"stateVarioTrack\" typeId=\"VTstate\"/>\n+\t\t</channels>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"slaveAddress\" type=\"integer\" min=\"20\" max=\"35\">\n+\t\t\t\t<label>Slave Address</label>\n+\t\t\t\t<description>Slave address of VarioTrack device</description>\n+\t\t\t\t<default>20</default>\n+\t\t\t\t<required>true</required>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refreshSec\" type=\"integer\" min=\"1\" unit=\"s\">\n+\t\t\t\t<label>Refresh Interval</label>\n+\t\t\t\t<description>Poll interval</description>\n+\t\t\t\t<default>5</default>\n+\t\t\t\t<required>true</required>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\t<!-- VarioString Thing Type -->\n+\t<thing-type id=\"variostring\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"serial\"/>\n+\t\t</supported-bridge-type-refs>\n+\t\t<label>VarioString Studer Thing</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef8c36c89dd25dfc366754439f5d01bf55f443ef"}, "originalPosition": 109}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4MzQ0Nzg0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.modbus.studer/src/main/resources/ESH-INF/thing/VariotString-channel-types.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxMTowMzoxMVrOHHG9TQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxMTowMzoxMVrOHHG9TQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzIxNjA3Nw==", "bodyText": "Any reason this channel  is not a item-type Switch or Contact?", "url": "https://github.com/openhab/openhab-addons/pull/8163#discussion_r477216077", "createdAt": "2020-08-26T11:03:11Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.modbus.studer/src/main/resources/ESH-INF/thing/VariotString-channel-types.xml", "diffHunk": "@@ -0,0 +1,149 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"modbus\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<!-- PV voltage Channel Type -->\n+\t<channel-type id=\"Upv0\">\n+\t\t<item-type>Number:ElectricPotential</item-type>\n+\t\t<label>PV Voltage</label>\n+\t\t<state readOnly=\"true\" pattern=\"%.2f %unit%\"/>\n+\t</channel-type>\n+\t<!-- PV current Channel Type -->\n+\t<channel-type id=\"Ipv0\">\n+\t\t<item-type>Number:ElectricCurrent</item-type>\n+\t\t<label>PV Current</label>\n+\t\t<state readOnly=\"true\" pattern=\"%.2f %unit%\"/>\n+\t</channel-type>\n+\t<!-- PV Power Channel Type -->\n+\t<channel-type id=\"Ppv0\">\n+\t\t<item-type>Number:Power</item-type>\n+\t\t<label>PV Power</label>\n+\t\t<state readOnly=\"true\" pattern=\"%.2f %unit%\"/>\n+\t</channel-type>\n+\t<!-- Production PV in (kWh) for the current day Channel Type -->\n+\t<channel-type id=\"Ed0\">\n+\t\t<item-type>Number:Energy</item-type>\n+\t\t<label>Production PV in (kWh) for the Current Day</label>\n+\t\t<state readOnly=\"true\" pattern=\"%.2f %unit%\"/>\n+\t</channel-type>\n+\t<!-- PV operating mode Channel Type -->\n+\t<channel-type id=\"Mod0\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>PV Operating State</label>\n+\t\t<state readOnly=\"true\">\n+\t\t\t<options>\n+\t\t\t\t<option value=\"NIGHT\">Night</option>\n+\t\t\t\t<option value=\"SECURITY\">Security</option>\n+\t\t\t\t<option value=\"OFF\">OFF</option>\n+\t\t\t\t<option value=\"CHARGE\">Charge</option>\n+\t\t\t\t<option value=\"CHARGEV\">Charge V</option>\n+\t\t\t\t<option value=\"CHARGEI\">Charge I</option>\n+\t\t\t\t<option value=\"CHARGEP\">Charge P</option>\n+\t\t\t\t<option value=\"CHARGEIPV\">Charge Ipv</option>\n+\t\t\t\t<option value=\"CHARGET\">Charge T</option>\n+\t\t\t\t<option value=\"UNKNOWN\">---</option>\n+\t\t\t\t<option value=\"CHIBSP\">Ch. Ibsp</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\t<!-- PV1 voltage Channel Type -->\n+\t<channel-type id=\"Upv1\">\n+\t\t<item-type>Number:ElectricPotential</item-type>\n+\t\t<label>PV1 Voltage</label>\n+\t\t<state readOnly=\"true\" pattern=\"%.2f %unit%\"/>\n+\t</channel-type>\n+\t<!-- PV1 current Channel Type -->\n+\t<channel-type id=\"Ipv1\">\n+\t\t<item-type>Number:ElectricCurrent</item-type>\n+\t\t<label>PV1 Current</label>\n+\t\t<state readOnly=\"true\" pattern=\"%.2f %unit%\"/>\n+\t</channel-type>\n+\t<!-- PV1 Power Channel Type -->\n+\t<channel-type id=\"Ppv1\">\n+\t\t<item-type>Number:Power</item-type>\n+\t\t<label>PV1 Power</label>\n+\t\t<state readOnly=\"true\" pattern=\"%.2f %unit%\"/>\n+\t</channel-type>\n+\t<!-- Production PV1 in (kWh) for the current day Channel Type -->\n+\t<channel-type id=\"Ed1\">\n+\t\t<item-type>Number:Energy</item-type>\n+\t\t<label>Production PV1 in (kWh) for the Current Day</label>\n+\t\t<state readOnly=\"true\" pattern=\"%.2f %unit%\"/>\n+\t</channel-type>\n+\t<!-- PV1 operating mode Channel Type -->\n+\t<channel-type id=\"Mod1\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>PV1 Operating State</label>\n+\t\t<state readOnly=\"true\">\n+\t\t\t<options>\n+\t\t\t\t<option value=\"NIGHT\">Night</option>\n+\t\t\t\t<option value=\"SECURITY\">Security</option>\n+\t\t\t\t<option value=\"OFF\">OFF</option>\n+\t\t\t\t<option value=\"CHARGE\">Charge</option>\n+\t\t\t\t<option value=\"CHARGEV\">Charge V</option>\n+\t\t\t\t<option value=\"CHARGEI\">Charge I</option>\n+\t\t\t\t<option value=\"CHARGEP\">Charge P</option>\n+\t\t\t\t<option value=\"CHARGEIPV\">Charge Ipv</option>\n+\t\t\t\t<option value=\"CHARGET\">Charge T</option>\n+\t\t\t\t<option value=\"UNKNOWN\">---</option>\n+\t\t\t\t<option value=\"CHIBSP\">Ch. Ibsp</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\t<!-- PV2 voltage Channel Type -->\n+\t<channel-type id=\"Upv2\">\n+\t\t<item-type>Number:ElectricPotential</item-type>\n+\t\t<label>PV2 Voltage</label>\n+\t\t<state readOnly=\"true\" pattern=\"%.2f %unit%\"/>\n+\t</channel-type>\n+\t<!-- PV2 current Channel Type -->\n+\t<channel-type id=\"Ipv2\">\n+\t\t<item-type>Number:ElectricCurrent</item-type>\n+\t\t<label>PV2 Current</label>\n+\t\t<state readOnly=\"true\" pattern=\"%.2f %unit%\"/>\n+\t</channel-type>\n+\t<!-- PV2 Power Channel Type -->\n+\t<channel-type id=\"Ppv2\">\n+\t\t<item-type>Number:Power</item-type>\n+\t\t<label>PV2 Power</label>\n+\t\t<state readOnly=\"true\" pattern=\"%.2f %unit%\"/>\n+\t</channel-type>\n+\t<!-- Production PV2 in (kWh) for the current day Channel Type -->\n+\t<channel-type id=\"Ed2\">\n+\t\t<item-type>Number:Energy</item-type>\n+\t\t<label>Production PV2 in (kWh) for the Current Day</label>\n+\t\t<state readOnly=\"true\" pattern=\"%.2f %unit%\"/>\n+\t</channel-type>\n+\t<!-- PV operating mode Channel Type -->\n+\t<channel-type id=\"Mod2\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>PV2 Operating State</label>\n+\t\t<state readOnly=\"true\">\n+\t\t\t<options>\n+\t\t\t\t<option value=\"NIGHT\">Night</option>\n+\t\t\t\t<option value=\"SECURITY\">Security</option>\n+\t\t\t\t<option value=\"OFF\">OFF</option>\n+\t\t\t\t<option value=\"CHARGE\">Charge</option>\n+\t\t\t\t<option value=\"CHARGEV\">Charge V</option>\n+\t\t\t\t<option value=\"CHARGEI\">Charge I</option>\n+\t\t\t\t<option value=\"CHARGEP\">Charge P</option>\n+\t\t\t\t<option value=\"CHARGEIPV\">Charge Ipv</option>\n+\t\t\t\t<option value=\"CHARGET\">Charge T</option>\n+\t\t\t\t<option value=\"UNKNOWN\">---</option>\n+\t\t\t\t<option value=\"CHIBSP\">Ch. Ibsp</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\t<!-- State of the VarioString Channel Type -->\n+\t<channel-type id=\"VSstate\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef8c36c89dd25dfc366754439f5d01bf55f443ef"}, "originalPosition": 139}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk4MzQ2MzQzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.modbus.studer/src/main/java/org/openhab/binding/modbus/studer/internal/StuderParser.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQxMTowODowNVrOHHHG5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNVQxNTo0OToyN1rOHNivHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzIxODUzNQ==", "bodyText": "It looks that in cases the value is unknown the channel should be set to UnDefType.UNDEF. That is the generic indicator the status is unknown. You seem to create a custom undefined state here. Same comment for the other enums. I also see this because the unknown state isn't mentioned in the options list in the thing xml files. That seem to suggest the unknown state should be the undef state I mentioned.", "url": "https://github.com/openhab/openhab-addons/pull/8163#discussion_r477218535", "createdAt": "2020-08-26T11:08:05Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.modbus.studer/src/main/java/org/openhab/binding/modbus/studer/internal/StuderParser.java", "diffHunk": "@@ -0,0 +1,233 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.studer.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link StuderParser} class with helper method\n+ * and possible values for mode and state\n+ *\n+ * @author Giovanni Mirulla - Initial contribution\n+ */\n+@NonNullByDefault\n+public class StuderParser {\n+    public enum ModeXtender {\n+        INVALID(0),\n+        INVERTER(1),\n+        CHARGER(2),\n+        BOOST(3),\n+        INJECTION(4),\n+        UNKNOWN(-1);\n+\n+        private final int code;\n+\n+        ModeXtender(int code) {\n+            this.code = code;\n+        }\n+\n+        public int code() {\n+            return this.code;\n+        }\n+    }\n+\n+    public static ModeXtender getModeXtenderByCode(int code) {\n+        switch (code) {\n+            case 0:\n+                return ModeXtender.INVALID;\n+            case 1:\n+                return ModeXtender.INVERTER;\n+            case 2:\n+                return ModeXtender.CHARGER;\n+            case 3:\n+                return ModeXtender.BOOST;\n+            case 4:\n+                return ModeXtender.INJECTION;\n+            default:\n+                return ModeXtender.UNKNOWN;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef8c36c89dd25dfc366754439f5d01bf55f443ef"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzk2MjY1NA==", "bodyText": "I created it because the studer devices have UNKNOWN state and because when I pass the Mode on updateState, I pass as StringType. I change it and now when the UNKNOWN state occurs the updateState has UnDefType.UNDEF", "url": "https://github.com/openhab/openhab-addons/pull/8163#discussion_r483962654", "createdAt": "2020-09-05T15:49:27Z", "author": {"login": "giovannimirulla"}, "path": "bundles/org.openhab.binding.modbus.studer/src/main/java/org/openhab/binding/modbus/studer/internal/StuderParser.java", "diffHunk": "@@ -0,0 +1,233 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.modbus.studer.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link StuderParser} class with helper method\n+ * and possible values for mode and state\n+ *\n+ * @author Giovanni Mirulla - Initial contribution\n+ */\n+@NonNullByDefault\n+public class StuderParser {\n+    public enum ModeXtender {\n+        INVALID(0),\n+        INVERTER(1),\n+        CHARGER(2),\n+        BOOST(3),\n+        INJECTION(4),\n+        UNKNOWN(-1);\n+\n+        private final int code;\n+\n+        ModeXtender(int code) {\n+            this.code = code;\n+        }\n+\n+        public int code() {\n+            return this.code;\n+        }\n+    }\n+\n+    public static ModeXtender getModeXtenderByCode(int code) {\n+        switch (code) {\n+            case 0:\n+                return ModeXtender.INVALID;\n+            case 1:\n+                return ModeXtender.INVERTER;\n+            case 2:\n+                return ModeXtender.CHARGER;\n+            case 3:\n+                return ModeXtender.BOOST;\n+            case 4:\n+                return ModeXtender.INJECTION;\n+            default:\n+                return ModeXtender.UNKNOWN;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzIxODUzNQ=="}, "originalCommit": {"oid": "ef8c36c89dd25dfc366754439f5d01bf55f443ef"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyNzQ2MDMxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.modbus.studer/src/main/resources/ESH-INF/thing/thing-types.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNlQxODoyNDoyMFrOHNrHVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNlQxODoyNDoyMFrOHNrHVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA5OTkyNQ==", "bodyText": "The thing definition refresh should also be updated:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t<parameter name=\"refreshSec\" type=\"integer\" min=\"1\" unit=\"s\">\n          \n          \n            \n            \t\t\t<parameter name=\"refresh\" type=\"integer\" min=\"1\" unit=\"s\">\n          \n      \n    \n    \n  \n\nSame comment for other things.", "url": "https://github.com/openhab/openhab-addons/pull/8163#discussion_r484099925", "createdAt": "2020-09-06T18:24:20Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.modbus.studer/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,139 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"modbus\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<!-- BSP Thing Type -->\n+\t<thing-type id=\"bsp\">\n+\t\t<supported-bridge-type-refs>\n+\t\t\t<bridge-type-ref id=\"serial\"/>\n+\t\t</supported-bridge-type-refs>\n+\t\t<label>BSP Studer</label>\n+\t\t<description>Thing for Studer BSP Device</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"batteryVoltage\" typeId=\"Ubat\"/>\n+\t\t\t<channel id=\"batteryCurrent\" typeId=\"Ibat\"/>\n+\t\t\t<channel id=\"power\" typeId=\"Pbat\"/>\n+\t\t\t<channel id=\"stateOfCharge\" typeId=\"SOC\"/>\n+\t\t\t<channel id=\"batteryTemperature\" typeId=\"Tbat\"/>\n+\t\t</channels>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"slaveAddress\" type=\"integer\" min=\"60\" max=\"61\">\n+\t\t\t\t<label>Slave Address</label>\n+\t\t\t\t<description>Slave address of BSP device</description>\n+\t\t\t\t<default>60</default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refreshSec\" type=\"integer\" min=\"1\" unit=\"s\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bd8046e6d6ba92e26edf7c76d58229bb58cdeb71"}, "originalPosition": 26}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4740, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}