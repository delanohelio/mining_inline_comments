{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEyNDk2MTE3", "number": 7533, "title": "[bticinosmarther] Initial contribution", "bodyText": "[bticinosmarther] Initial contribution\nThe BTicino Smarther binding implements a bridge to the C2C Legrand/Bticino Smarther v2.0 API and allows users to control their BTicino Smarther chronothermostat units (all models) with openHAB.\nBTicino Smarther units have their own API set and doesn't conform to the OpenWebNet protocol.\nMain thread in openHAB Community on this binding:\n\nhttps://community.openhab.org/t/bticino-smarther-thermostat-binding/73329\n\nCompanion HABPanel widget for this binding:\n\nhttps://community.openhab.org/t/custom-widget-bticino-smarther-widget/97522\n\nOther threads in openHAB Community where the idea to build this binding came from:\n\nhttps://community.openhab.org/t/btcino-smarther-x8000/92671\nhttps://community.openhab.org/t/bticino-smarther-thermostat/39621\n\nSigned-off-by: Fabio Possieri fabio.possieri@gmail.com", "createdAt": "2020-05-02T19:18:54Z", "url": "https://github.com/openhab/openhab-addons/pull/7533", "merged": true, "mergeCommit": {"oid": "8a5c07f05f4b1dd5108543a6031375741d560f49"}, "closed": true, "closedAt": "2020-06-28T21:01:01Z", "author": {"login": "MrRonfo"}, "timelineItems": {"totalCount": 36, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABckE829gFqTQxNzE2Njk1NQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcvy7eGAFqTQzODgxMjg0Mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE3MTY2OTU1", "url": "https://github.com/openhab/openhab-addons/pull/7533#pullrequestreview-417166955", "createdAt": "2020-05-22T20:28:11Z", "commit": {"oid": "19cf0c876eff6c53b1c2f4864ae682e3d33fb7a3"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 34, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQyMDoyODoxMlrOGZi4dQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QxMTowNjozMlrOGZo01A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQzOTA5Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Optionally, if you want to later receive push notifications on the status of your units, consider to make your openHAB installation reacheble in https from a public IP or domain (see [Note on notifications](#note-on-notifications)).\n          \n          \n            \n            Optionally, if you want to later receive push notifications on the status of your units, consider to make your openHAB installation reachable in https from a public IP or domain (see [Note on notifications](#note-on-notifications)).", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429439093", "createdAt": "2020-05-22T20:28:12Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.smarther/README.md", "diffHunk": "@@ -0,0 +1,315 @@\n+# BTicino Smarther Binding\n+\n+The Smarther binding implements a bridge to the Legrand/Bticino Smarther v2.0 API and allows you to control your BTicino Smarther chronothermostat units with openHAB, making it possible to discover Smarther units connected to your Legrand/BTicino Smarther account.\n+\n+Smarther chronothermostat is produced by Bticino (https://www.bticino.com/products-catalogue/smarther-the-connected-thermostat/), has its own API set and doesn't support the OpenWebNet protocol.\n+\n+Companion HABPanel widget can be found here: [BTicino Smarther HABPanel widget](https://github.com/MrRonfo/openhab-smarther-widget)\n+\n+# Configuring the binding\n+\n+The binding requires you to register an Application with Legrand Developer portal at https://developer.legrand.com - this will get you a set of Client ID and Client Secret parameters to be used by your binding configuration\n+\n+Optionally, if you want to later receive push notifications on the status of your units, consider to make your openHAB installation reacheble in https from a public IP or domain (see [Note on notifications](#note-on-notifications)).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19cf0c876eff6c53b1c2f4864ae682e3d33fb7a3"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ0MTk4Ng==", "bodyText": "The correct path for documentation images is doc/ at the same level as src/", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429441986", "createdAt": "2020-05-22T20:37:15Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.smarther/README.md", "diffHunk": "@@ -0,0 +1,315 @@\n+# BTicino Smarther Binding\n+\n+The Smarther binding implements a bridge to the Legrand/Bticino Smarther v2.0 API and allows you to control your BTicino Smarther chronothermostat units with openHAB, making it possible to discover Smarther units connected to your Legrand/BTicino Smarther account.\n+\n+Smarther chronothermostat is produced by Bticino (https://www.bticino.com/products-catalogue/smarther-the-connected-thermostat/), has its own API set and doesn't support the OpenWebNet protocol.\n+\n+Companion HABPanel widget can be found here: [BTicino Smarther HABPanel widget](https://github.com/MrRonfo/openhab-smarther-widget)\n+\n+# Configuring the binding\n+\n+The binding requires you to register an Application with Legrand Developer portal at https://developer.legrand.com - this will get you a set of Client ID and Client Secret parameters to be used by your binding configuration\n+\n+Optionally, if you want to later receive push notifications on the status of your units, consider to make your openHAB installation reacheble in https from a public IP or domain (see [Note on notifications](#note-on-notifications)).\n+\n+## Create an account\n+\n+Follow the instructions in the tutorial at https://developer.legrand.com/tutorials/getting-started/, under: \n+\n+* Step 1 : Create an account\n+* Step 2 : Subscribe to a product and get subscription key\n+\n+There's also a Step 3 in this tutorial, you can skip it as not needed to complete this process.\n+Simply write down your \"Primary Key\" as it will be needed later on in the setup.\n+\n+## Create an application\n+\n+Follow the instructions in the tutorial at https://developer.legrand.com/tutorials/create-an-application/, under: \n+\n+* Step 1 : Register your application\n+* Step 2 : Check scopes\n+* Step 3 : Getting application details\n+\n+When registering your new Legrand Application for openHAB Smarther Bridge you have to specify the allowed Reply URL, aka white-listed address. Here you have to specify the URL to the Bridge Authorization page on your server.\n+\n+For example if you run your openHAB server on http://openhabianpi:8080 you should set `http://openhabianpi:8080/smarther/connectsmarther` as the \"First Reply URL\" required field in Step 1. Other Reply URLs (second, third, etc.) you can leave them blank.\n+\n+This is **very important** since the authorize process with Legrand takes place using your client web browser and Legrand will have to know the right URL to your openHAB server for the authorization to be completed. When you have authorized with Legrand, this Redirect URI is where authorization tokens for your openHAB Smarther Brigde will be sent and they have to be received by the servlet on `/smarther/connectsmarther`.\n+\n+![Application 1](src/main/resources/images/application-1.png)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19cf0c876eff6c53b1c2f4864ae682e3d33fb7a3"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ0MzkxOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            4. Go to your preferred openHAB admin UI and add a new Thing - select the **\"Smarther Bridge\"**. Choose new Id for the bridge, unless you like the generated one. Put in your _Primary Key_ (in _Subscription Key_ field), _Client ID_ and _Cliend Secret_ in their respective fields of the bridge configuration. Set _Use Notifications_ to `ON` if your openHAB server is reacheable from a public https URL (see [Note on notifications](#note-on-notifications)), set `OFF` otherwise. You can leave the _Bridge Status Refresh Period_ as is. Save the bridge.\n          \n          \n            \n            4. Go to your preferred openHAB admin UI and add a new Thing - select the **\"Smarther Bridge\"**. Choose new Id for the bridge, unless you like the generated one. Put in your _Primary Key_ (in _Subscription Key_ field), _Client ID_ and _Client Secret_ in their respective fields of the bridge configuration. Set _Use Notifications_ to `ON` if your openHAB server is reacheable from a public https URL (see [Note on notifications](#note-on-notifications)), set `OFF` otherwise. You can leave the _Bridge Status Refresh Period_ as is. Save the bridge.", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429443919", "createdAt": "2020-05-22T20:43:18Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.smarther/README.md", "diffHunk": "@@ -0,0 +1,315 @@\n+# BTicino Smarther Binding\n+\n+The Smarther binding implements a bridge to the Legrand/Bticino Smarther v2.0 API and allows you to control your BTicino Smarther chronothermostat units with openHAB, making it possible to discover Smarther units connected to your Legrand/BTicino Smarther account.\n+\n+Smarther chronothermostat is produced by Bticino (https://www.bticino.com/products-catalogue/smarther-the-connected-thermostat/), has its own API set and doesn't support the OpenWebNet protocol.\n+\n+Companion HABPanel widget can be found here: [BTicino Smarther HABPanel widget](https://github.com/MrRonfo/openhab-smarther-widget)\n+\n+# Configuring the binding\n+\n+The binding requires you to register an Application with Legrand Developer portal at https://developer.legrand.com - this will get you a set of Client ID and Client Secret parameters to be used by your binding configuration\n+\n+Optionally, if you want to later receive push notifications on the status of your units, consider to make your openHAB installation reacheble in https from a public IP or domain (see [Note on notifications](#note-on-notifications)).\n+\n+## Create an account\n+\n+Follow the instructions in the tutorial at https://developer.legrand.com/tutorials/getting-started/, under: \n+\n+* Step 1 : Create an account\n+* Step 2 : Subscribe to a product and get subscription key\n+\n+There's also a Step 3 in this tutorial, you can skip it as not needed to complete this process.\n+Simply write down your \"Primary Key\" as it will be needed later on in the setup.\n+\n+## Create an application\n+\n+Follow the instructions in the tutorial at https://developer.legrand.com/tutorials/create-an-application/, under: \n+\n+* Step 1 : Register your application\n+* Step 2 : Check scopes\n+* Step 3 : Getting application details\n+\n+When registering your new Legrand Application for openHAB Smarther Bridge you have to specify the allowed Reply URL, aka white-listed address. Here you have to specify the URL to the Bridge Authorization page on your server.\n+\n+For example if you run your openHAB server on http://openhabianpi:8080 you should set `http://openhabianpi:8080/smarther/connectsmarther` as the \"First Reply URL\" required field in Step 1. Other Reply URLs (second, third, etc.) you can leave them blank.\n+\n+This is **very important** since the authorize process with Legrand takes place using your client web browser and Legrand will have to know the right URL to your openHAB server for the authorization to be completed. When you have authorized with Legrand, this Redirect URI is where authorization tokens for your openHAB Smarther Brigde will be sent and they have to be received by the servlet on `/smarther/connectsmarther`.\n+\n+![Application 1](src/main/resources/images/application-1.png)\n+\n+On Step 2, please make sure to select both `comfort.read` and `comfort.write` scopes, as they're mandatory for the binding to work.\n+\n+![Application 2](src/main/resources/images/application-2.png)\n+\n+Usually, Step 3 is then completed by Legrand within 1-2 days and you'll receive an email containing your application's Client ID and Client Secret.\n+\n+### Note on notifications\n+\n+If you want to later receive push notifications (device status) from Legrand for this application, you must have your openHAB server reacheable from a public IP/address and use the related public IP/address and public port when filling-in the \"Reply URL\" field in Step 1.\n+\n+## Configure the binding\n+\n+1. Install the binding and make sure the _Smarther Binding_ is listed on your server.\n+2. Complete the _Create an account_ and _Create an application_ steps if you have not already done so (see above).\n+3. Make sure you have your Legrand account _Primary Key_ and your Legrand application _Client ID_ and _Client Secret_ identities available.\n+4. Go to your preferred openHAB admin UI and add a new Thing - select the **\"Smarther Bridge\"**. Choose new Id for the bridge, unless you like the generated one. Put in your _Primary Key_ (in _Subscription Key_ field), _Client ID_ and _Cliend Secret_ in their respective fields of the bridge configuration. Set _Use Notifications_ to `ON` if your openHAB server is reacheable from a public https URL (see [Note on notifications](#note-on-notifications)), set `OFF` otherwise. You can leave the _Bridge Status Refresh Period_ as is. Save the bridge.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19cf0c876eff6c53b1c2f4864ae682e3d33fb7a3"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ0NDE1Nw==", "bodyText": "If you put every sentence into a dedicated line, diffs are easier to read", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429444157", "createdAt": "2020-05-22T20:44:04Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.smarther/README.md", "diffHunk": "@@ -0,0 +1,315 @@\n+# BTicino Smarther Binding\n+\n+The Smarther binding implements a bridge to the Legrand/Bticino Smarther v2.0 API and allows you to control your BTicino Smarther chronothermostat units with openHAB, making it possible to discover Smarther units connected to your Legrand/BTicino Smarther account.\n+\n+Smarther chronothermostat is produced by Bticino (https://www.bticino.com/products-catalogue/smarther-the-connected-thermostat/), has its own API set and doesn't support the OpenWebNet protocol.\n+\n+Companion HABPanel widget can be found here: [BTicino Smarther HABPanel widget](https://github.com/MrRonfo/openhab-smarther-widget)\n+\n+# Configuring the binding\n+\n+The binding requires you to register an Application with Legrand Developer portal at https://developer.legrand.com - this will get you a set of Client ID and Client Secret parameters to be used by your binding configuration\n+\n+Optionally, if you want to later receive push notifications on the status of your units, consider to make your openHAB installation reacheble in https from a public IP or domain (see [Note on notifications](#note-on-notifications)).\n+\n+## Create an account\n+\n+Follow the instructions in the tutorial at https://developer.legrand.com/tutorials/getting-started/, under: \n+\n+* Step 1 : Create an account\n+* Step 2 : Subscribe to a product and get subscription key\n+\n+There's also a Step 3 in this tutorial, you can skip it as not needed to complete this process.\n+Simply write down your \"Primary Key\" as it will be needed later on in the setup.\n+\n+## Create an application\n+\n+Follow the instructions in the tutorial at https://developer.legrand.com/tutorials/create-an-application/, under: \n+\n+* Step 1 : Register your application\n+* Step 2 : Check scopes\n+* Step 3 : Getting application details\n+\n+When registering your new Legrand Application for openHAB Smarther Bridge you have to specify the allowed Reply URL, aka white-listed address. Here you have to specify the URL to the Bridge Authorization page on your server.\n+\n+For example if you run your openHAB server on http://openhabianpi:8080 you should set `http://openhabianpi:8080/smarther/connectsmarther` as the \"First Reply URL\" required field in Step 1. Other Reply URLs (second, third, etc.) you can leave them blank.\n+\n+This is **very important** since the authorize process with Legrand takes place using your client web browser and Legrand will have to know the right URL to your openHAB server for the authorization to be completed. When you have authorized with Legrand, this Redirect URI is where authorization tokens for your openHAB Smarther Brigde will be sent and they have to be received by the servlet on `/smarther/connectsmarther`.\n+\n+![Application 1](src/main/resources/images/application-1.png)\n+\n+On Step 2, please make sure to select both `comfort.read` and `comfort.write` scopes, as they're mandatory for the binding to work.\n+\n+![Application 2](src/main/resources/images/application-2.png)\n+\n+Usually, Step 3 is then completed by Legrand within 1-2 days and you'll receive an email containing your application's Client ID and Client Secret.\n+\n+### Note on notifications\n+\n+If you want to later receive push notifications (device status) from Legrand for this application, you must have your openHAB server reacheable from a public IP/address and use the related public IP/address and public port when filling-in the \"Reply URL\" field in Step 1.\n+\n+## Configure the binding\n+\n+1. Install the binding and make sure the _Smarther Binding_ is listed on your server.\n+2. Complete the _Create an account_ and _Create an application_ steps if you have not already done so (see above).\n+3. Make sure you have your Legrand account _Primary Key_ and your Legrand application _Client ID_ and _Client Secret_ identities available.\n+4. Go to your preferred openHAB admin UI and add a new Thing - select the **\"Smarther Bridge\"**. Choose new Id for the bridge, unless you like the generated one. Put in your _Primary Key_ (in _Subscription Key_ field), _Client ID_ and _Cliend Secret_ in their respective fields of the bridge configuration. Set _Use Notifications_ to `ON` if your openHAB server is reacheable from a public https URL (see [Note on notifications](#note-on-notifications)), set `OFF` otherwise. You can leave the _Bridge Status Refresh Period_ as is. Save the bridge.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19cf0c876eff6c53b1c2f4864ae682e3d33fb7a3"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ0NTk5Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            * Flush ounting installation item (X8000)\n          \n          \n            \n            * Flush mounting installation item (X8000)", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429445996", "createdAt": "2020-05-22T20:49:31Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.smarther/README.md", "diffHunk": "@@ -0,0 +1,315 @@\n+# BTicino Smarther Binding\n+\n+The Smarther binding implements a bridge to the Legrand/Bticino Smarther v2.0 API and allows you to control your BTicino Smarther chronothermostat units with openHAB, making it possible to discover Smarther units connected to your Legrand/BTicino Smarther account.\n+\n+Smarther chronothermostat is produced by Bticino (https://www.bticino.com/products-catalogue/smarther-the-connected-thermostat/), has its own API set and doesn't support the OpenWebNet protocol.\n+\n+Companion HABPanel widget can be found here: [BTicino Smarther HABPanel widget](https://github.com/MrRonfo/openhab-smarther-widget)\n+\n+# Configuring the binding\n+\n+The binding requires you to register an Application with Legrand Developer portal at https://developer.legrand.com - this will get you a set of Client ID and Client Secret parameters to be used by your binding configuration\n+\n+Optionally, if you want to later receive push notifications on the status of your units, consider to make your openHAB installation reacheble in https from a public IP or domain (see [Note on notifications](#note-on-notifications)).\n+\n+## Create an account\n+\n+Follow the instructions in the tutorial at https://developer.legrand.com/tutorials/getting-started/, under: \n+\n+* Step 1 : Create an account\n+* Step 2 : Subscribe to a product and get subscription key\n+\n+There's also a Step 3 in this tutorial, you can skip it as not needed to complete this process.\n+Simply write down your \"Primary Key\" as it will be needed later on in the setup.\n+\n+## Create an application\n+\n+Follow the instructions in the tutorial at https://developer.legrand.com/tutorials/create-an-application/, under: \n+\n+* Step 1 : Register your application\n+* Step 2 : Check scopes\n+* Step 3 : Getting application details\n+\n+When registering your new Legrand Application for openHAB Smarther Bridge you have to specify the allowed Reply URL, aka white-listed address. Here you have to specify the URL to the Bridge Authorization page on your server.\n+\n+For example if you run your openHAB server on http://openhabianpi:8080 you should set `http://openhabianpi:8080/smarther/connectsmarther` as the \"First Reply URL\" required field in Step 1. Other Reply URLs (second, third, etc.) you can leave them blank.\n+\n+This is **very important** since the authorize process with Legrand takes place using your client web browser and Legrand will have to know the right URL to your openHAB server for the authorization to be completed. When you have authorized with Legrand, this Redirect URI is where authorization tokens for your openHAB Smarther Brigde will be sent and they have to be received by the servlet on `/smarther/connectsmarther`.\n+\n+![Application 1](src/main/resources/images/application-1.png)\n+\n+On Step 2, please make sure to select both `comfort.read` and `comfort.write` scopes, as they're mandatory for the binding to work.\n+\n+![Application 2](src/main/resources/images/application-2.png)\n+\n+Usually, Step 3 is then completed by Legrand within 1-2 days and you'll receive an email containing your application's Client ID and Client Secret.\n+\n+### Note on notifications\n+\n+If you want to later receive push notifications (device status) from Legrand for this application, you must have your openHAB server reacheable from a public IP/address and use the related public IP/address and public port when filling-in the \"Reply URL\" field in Step 1.\n+\n+## Configure the binding\n+\n+1. Install the binding and make sure the _Smarther Binding_ is listed on your server.\n+2. Complete the _Create an account_ and _Create an application_ steps if you have not already done so (see above).\n+3. Make sure you have your Legrand account _Primary Key_ and your Legrand application _Client ID_ and _Client Secret_ identities available.\n+4. Go to your preferred openHAB admin UI and add a new Thing - select the **\"Smarther Bridge\"**. Choose new Id for the bridge, unless you like the generated one. Put in your _Primary Key_ (in _Subscription Key_ field), _Client ID_ and _Cliend Secret_ in their respective fields of the bridge configuration. Set _Use Notifications_ to `ON` if your openHAB server is reacheable from a public https URL (see [Note on notifications](#note-on-notifications)), set `OFF` otherwise. You can leave the _Bridge Status Refresh Period_ as is. Save the bridge.\n+5. The bridge thing will stay in state _INITIALIZING_ and eventually go _OFFLINE_ - this is fine, as you now have to authorize this bridge with Legrand.\n+6. Go to the authorization page of your server (see [Create an application](#create-an-application)) `http://<your openHAB address>:<your openHAB port>/smarther/connectsmarther`. Your newly added bridge should be listed there (along with the available locations).\n+7. Press the _\"Authorize Bridge\"_ button. This will take you either to the login page of Legrand portal or directly to the authorization screen. Login and/or authorize the application. If the Reply URL is correct you will be returned and the entry should show your Bridge is authorized with your Client ID; otherwise, go back to your application configuration on Legrand portal and ensure you have set the right Reply URL (see [Troubleshooting](#troubleshooting) below).\n+8. The binding will be updated with a refresh token and go _ONLINE_. The refresh token is used to re-authorize the bridge with Legrand Smarther API whenever required.\n+\n+![Tutorial 1](src/main/resources/images/tutorial-1.png)\n+\n+![Tutorial 2](src/main/resources/images/tutorial-2.png)\n+\n+![Tutorial 3](src/main/resources/images/tutorial-3.png)\n+\n+Now that you have got your bridge _ONLINE_ it is time to discover your devices! Go to Paper UI Inbox and search for **\"Smarther Chronothermostat\"** things. Any Smarther Chronothermostat device currently available on your account should show up immediately.\n+\n+If no devices show up you may have to trigger the openHAB discovery several times as bridge will only find active devices known by the Smarther API at the time the discovery is triggered.\n+\n+Should the bridge configuration be broken for any reason, the authorization procedure can be reinitiated from step 6 whenever required. You can force reinitialization by authorizing again on the `/smarther/connectsmarther` page, even if the page shows it as already authorized. This will reset the refresh token.\n+\n+The following configuration options are available on the Smarther Bridge thing:\n+\n+| Parameter             | Description                                                                                                                                        | Condition |\n+|-----------------------|----------------------------------------------------------------------------------------------------------------------------------------------------|-----------|\n+| subscriptionKey       | This is the Primary Key provided by Legrand when you create a new Account and subscribe to a product                                               | Required  |\n+| clientId              | This is the Client ID provided by Legrand when you add a new Application for openHAB to your Legrand account                                       | Required  |\n+| clientSecret          | This is the Client Secret provided by Legrand when you add a new Application for openHAB to your Legrand account                                   | Required  |\n+| useNotifications      | ON = the bridge subscribes to receive push notifications on devices status change; OFF = status updates are requested (pull) on a periodical basis |           |\n+| statusRefreshPeriod   | This is the frequency of the polling requests to the Smarther API to update the bridge status (in minutes)                                         |           |\n+\n+The following configuration options are available on the Smarther Chronothermostat thing:\n+\n+| Parameter             | Description                                                                                                                                        | Condition |\n+|-----------------------|----------------------------------------------------------------------------------------------------------------------------------------------------|-----------|\n+| plantId               | This is the Plant Id of the location the Chronothermostat module is installed in, provided by Smarther API                                         | Read-only |\n+| moduleId              | This is the Module Id of the Chronothermostat module, provided by Smarther API                                                                     | Read-only |\n+| settingsAutoupdate    | ON = the thermostat settings are aligned with current status whenever it changes; OFF = settings are aligned to status only upon initialization    |           |\n+| programsRefreshPeriod | This is the frequency the Smarther API gateway is called to refresh Programs list used in \"automatic\" mode (in hours)                              |           |\n+| numberOfEndDays       | This is the number of days to be displayed in module settings, as options list for \"End Date\" field in \"manual\" mode                               |           |\n+| statusRefreshPeriod   | This is the frequency of the polling requests to the Smarther API to update the module status and sensor data (in minutes)                         |           |\n+\n+## Troubleshooting\n+\n+When configuring the binding (see step 7 [here](#configure-the-binding)), you can receive the following error from Legrand portal:\n+\n+```\n+{\n+  \"error\": \"invalid_request\",\n+  \"error_description\": \"The reply url host xxxxx doesn't match with the ones configured on the application\"\n+}\n+```\n+\n+This means you've either opened the `/smarther/connectsmarther` page from the wrong address or set the wrong \"Reply URL\" attribute in your application (see step 1 [here](#create-an-application)). Please remember these two strings must match for authentication process to work.\n+\n+To solve the issue, either:\n+\n+* Correct the address you're accessing the `/smarther/connectsmarther` page from, to match the \"Reply URL\" attribute registered in your application, or\n+* Should you have specified a wrong \"Reply URL\" attribute in your application, go to the Legrand portal and correct it accordingly then resubmit the application for approval.\n+\n+## Supported Things\n+\n+All Smarther Chronothermostat device models should be discoverable through this binding:\n+\n+* Flush ounting installation item (X8000)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19cf0c876eff6c53b1c2f4864ae682e3d33fb7a3"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ1MDM2NQ==", "bodyText": "Since we are going to remove the Apache Commons dependencies, could you replace the line with standard Java code? See #7722", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429450365", "createdAt": "2020-05-22T21:03:11Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/account/SmartherAccountService.java", "diffHunk": "@@ -0,0 +1,250 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.account;\n+\n+import static org.openhab.binding.smarther.internal.SmartherBindingConstants.*;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.lang.invoke.MethodHandles;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Hashtable;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherGatewayException;\n+import org.openhab.binding.smarther.internal.api.model.Notification;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.component.ComponentContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.http.HttpService;\n+import org.osgi.service.http.NamespaceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SmartherAccountService} class to manage the servlets and bind authorization servlet to bridges.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@Component(service = SmartherAccountService.class, immediate = true, configurationPid = \"binding.smarther.accountService\")\n+@NonNullByDefault\n+public class SmartherAccountService {\n+\n+    private static final String TEMPLATE_PATH = \"templates/\";\n+    private static final String IMAGE_PATH = \"web\";\n+    private static final String TEMPLATE_APPLICATION = TEMPLATE_PATH + \"application.html\";\n+    private static final String TEMPLATE_INDEX = TEMPLATE_PATH + \"index.html\";\n+    private static final String ERROR_UKNOWN_BRIDGE = \"Returned 'state' by doesn't match any Bridges. Has the bridge been removed?\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private final List<SmartherAccountHandler> handlers = new ArrayList<>();\n+\n+    private @NonNullByDefault({}) HttpService httpService;\n+    private @NonNullByDefault({}) BundleContext bundleContext;\n+\n+    @Activate\n+    protected void activate(ComponentContext componentContext, Map<String, Object> properties) {\n+        try {\n+            bundleContext = componentContext.getBundleContext();\n+\n+            // Register the authorization servlet\n+            httpService.registerServlet(AUTH_SERVLET_ALIAS, createAuthorizationServlet(), new Hashtable<>(),\n+                    httpService.createDefaultHttpContext());\n+            httpService.registerResources(AUTH_SERVLET_ALIAS + IMG_SERVLET_ALIAS, IMAGE_PATH, null);\n+\n+            // Register the notification servlet\n+            httpService.registerServlet(NOTIFY_SERVLET_ALIAS, createNotificationServlet(), new Hashtable<>(),\n+                    httpService.createDefaultHttpContext());\n+        } catch (NamespaceException | ServletException | IOException e) {\n+            logger.warn(\"Error during Smarther servlet startup\", e);\n+        }\n+    }\n+\n+    @Deactivate\n+    protected void deactivate(ComponentContext componentContext) {\n+        // Unregister the authorization servlet\n+        httpService.unregister(AUTH_SERVLET_ALIAS);\n+        httpService.unregister(AUTH_SERVLET_ALIAS + IMG_SERVLET_ALIAS);\n+\n+        // Unregister the notification servlet\n+        httpService.unregister(NOTIFY_SERVLET_ALIAS);\n+    }\n+\n+    /**\n+     * Creates a new {@link SmartherAuthorizationServlet}.\n+     *\n+     * @return the newly created servlet\n+     * @throws IOException thrown when an HTML template could not be read\n+     */\n+    private HttpServlet createAuthorizationServlet() throws IOException {\n+        return new SmartherAuthorizationServlet(this, readTemplate(TEMPLATE_INDEX), readTemplate(TEMPLATE_APPLICATION));\n+    }\n+\n+    /**\n+     * Creates a new {@link SmartherNotificationServlet}.\n+     *\n+     * @return the newly created servlet\n+     */\n+    private HttpServlet createNotificationServlet() {\n+        return new SmartherNotificationServlet(this);\n+    }\n+\n+    /**\n+     * Reads a template from file and returns the content as String.\n+     *\n+     * @param templateName name of the template file to read\n+     * @return The content of the template file\n+     * @throws IOException thrown when an HTML template could not be read\n+     */\n+    private String readTemplate(String templateName) throws IOException {\n+        final URL index = bundleContext.getBundle().getEntry(templateName);\n+\n+        if (index == null) {\n+            throw new FileNotFoundException(\n+                    String.format(\"Cannot find template '%s' - failed to initialize Smarther servlet\", templateName));\n+        } else {\n+            try (InputStream inputStream = index.openStream()) {\n+                return IOUtils.toString(inputStream);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19cf0c876eff6c53b1c2f4864ae682e3d33fb7a3"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ1NDA1OA==", "bodyText": "Apache Commons", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429454058", "createdAt": "2020-05-22T21:15:29Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/account/SmartherAuthorizationServlet.java", "diffHunk": "@@ -0,0 +1,235 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.account;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.util.MultiMap;\n+import org.eclipse.jetty.util.StringUtil;\n+import org.eclipse.jetty.util.UrlEncoded;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherAuthorizationException;\n+import org.openhab.binding.smarther.internal.api.model.Location;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SmartherAuthorizationServlet} manages the authorization with the BTicino/Legrand API gateway. The servlet\n+ * implements the Authorization Code flow and saves the resulting refreshToken with the bridge.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmartherAuthorizationServlet extends HttpServlet {\n+\n+    private static final long serialVersionUID = 5199173744807168342L;\n+\n+    private static final String CONTENT_TYPE = \"text/html;charset=UTF-8\";\n+    private static final String X_FORWARDED_PROTO = \"X-Forwarded-Proto\";\n+\n+    // Simple HTML templates for inserting messages.\n+    private static final String HTML_EMPTY_APPLICATIONS = \"<p class='block'>Manually add a Smarther Bridge to authorize it here<p>\";\n+    private static final String HTML_BRIDGE_AUTHORIZED = \"<p class='block authorized'>Bridge authorized for Client Id %s</p>\";\n+    private static final String HTML_ERROR = \"<p class='block error'>Call to Smarther API gateway failed with error: %s</p>\";\n+\n+    private static final Pattern MESSAGE_KEY_PATTERN = Pattern.compile(\"\\\\$\\\\{([^\\\\}]+)\\\\}\");\n+\n+    // Keys present in the index.html\n+    private static final String KEY_PAGE_REFRESH = \"pageRefresh\";\n+    private static final String HTML_META_REFRESH_CONTENT = \"<meta http-equiv='refresh' content='10; url=%s'>\";\n+    private static final String KEY_AUTHORIZED_BRIDGE = \"authorizedBridge\";\n+    private static final String KEY_ERROR = \"error\";\n+    private static final String KEY_APPLICATIONS = \"applications\";\n+    private static final String KEY_REDIRECT_URI = \"redirectUri\";\n+    // Keys present in the application.html\n+    private static final String APPLICATION_ID = \"application.id\";\n+    private static final String APPLICATION_NAME = \"application.name\";\n+    private static final String APPLICATION_LOCATIONS = \"application.locations\";\n+    private static final String APPLICATION_AUTHORIZED_CLASS = \"application.authorized\";\n+    private static final String APPLICATION_AUTHORIZE = \"application.authorize\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private final SmartherAccountService accountService;\n+    private final String indexTemplate;\n+    private final String applicationTemplate;\n+\n+    public SmartherAuthorizationServlet(SmartherAccountService accountService, String indexTemplate,\n+            String applicationTemplate) {\n+        this.accountService = accountService;\n+        this.indexTemplate = indexTemplate;\n+        this.applicationTemplate = applicationTemplate;\n+    }\n+\n+    @Override\n+    protected void doGet(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+            throws ServletException, IOException {\n+        if (req == null || resp == null) {\n+            throw new SmartherAuthorizationException(\"Authorization callback with null request/response\");\n+        }\n+\n+        final String servletBaseURL = extractServletBaseURL(req);\n+        final Map<String, String> replaceMap = new HashMap<>();\n+        logger.debug(\"Authorization callback servlet received GET request {}\", servletBaseURL);\n+\n+        // Handle the received data\n+        handleSmartherRedirect(replaceMap, servletBaseURL, req.getQueryString());\n+\n+        // Build response for the caller\n+        resp.setContentType(CONTENT_TYPE);\n+        replaceMap.put(KEY_REDIRECT_URI, servletBaseURL);\n+        replaceMap.put(KEY_APPLICATIONS, formatApplications(applicationTemplate, servletBaseURL));\n+        resp.getWriter().append(replaceKeysFromMap(indexTemplate, replaceMap));\n+        resp.getWriter().close();\n+    }\n+\n+    /**\n+     * Extracts the servlet base URL from received HTTP request, possibly handling reverse proxies.\n+     *\n+     * @param req The received HTTP request\n+     * @return A string containing the servlet base URL\n+     */\n+    private String extractServletBaseURL(HttpServletRequest req) {\n+        final StringBuffer requestURL = req.getRequestURL();\n+\n+        // Try to infer the real protocol from request headers\n+        final String realProtocol = StringUtils.defaultIfBlank(req.getHeader(X_FORWARDED_PROTO), req.getScheme());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19cf0c876eff6c53b1c2f4864ae682e3d33fb7a3"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ1NTExNQ==", "bodyText": "Apache Commons", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429455115", "createdAt": "2020-05-22T21:19:10Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/account/SmartherAuthorizationServlet.java", "diffHunk": "@@ -0,0 +1,235 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.account;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.util.MultiMap;\n+import org.eclipse.jetty.util.StringUtil;\n+import org.eclipse.jetty.util.UrlEncoded;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherAuthorizationException;\n+import org.openhab.binding.smarther.internal.api.model.Location;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SmartherAuthorizationServlet} manages the authorization with the BTicino/Legrand API gateway. The servlet\n+ * implements the Authorization Code flow and saves the resulting refreshToken with the bridge.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmartherAuthorizationServlet extends HttpServlet {\n+\n+    private static final long serialVersionUID = 5199173744807168342L;\n+\n+    private static final String CONTENT_TYPE = \"text/html;charset=UTF-8\";\n+    private static final String X_FORWARDED_PROTO = \"X-Forwarded-Proto\";\n+\n+    // Simple HTML templates for inserting messages.\n+    private static final String HTML_EMPTY_APPLICATIONS = \"<p class='block'>Manually add a Smarther Bridge to authorize it here<p>\";\n+    private static final String HTML_BRIDGE_AUTHORIZED = \"<p class='block authorized'>Bridge authorized for Client Id %s</p>\";\n+    private static final String HTML_ERROR = \"<p class='block error'>Call to Smarther API gateway failed with error: %s</p>\";\n+\n+    private static final Pattern MESSAGE_KEY_PATTERN = Pattern.compile(\"\\\\$\\\\{([^\\\\}]+)\\\\}\");\n+\n+    // Keys present in the index.html\n+    private static final String KEY_PAGE_REFRESH = \"pageRefresh\";\n+    private static final String HTML_META_REFRESH_CONTENT = \"<meta http-equiv='refresh' content='10; url=%s'>\";\n+    private static final String KEY_AUTHORIZED_BRIDGE = \"authorizedBridge\";\n+    private static final String KEY_ERROR = \"error\";\n+    private static final String KEY_APPLICATIONS = \"applications\";\n+    private static final String KEY_REDIRECT_URI = \"redirectUri\";\n+    // Keys present in the application.html\n+    private static final String APPLICATION_ID = \"application.id\";\n+    private static final String APPLICATION_NAME = \"application.name\";\n+    private static final String APPLICATION_LOCATIONS = \"application.locations\";\n+    private static final String APPLICATION_AUTHORIZED_CLASS = \"application.authorized\";\n+    private static final String APPLICATION_AUTHORIZE = \"application.authorize\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private final SmartherAccountService accountService;\n+    private final String indexTemplate;\n+    private final String applicationTemplate;\n+\n+    public SmartherAuthorizationServlet(SmartherAccountService accountService, String indexTemplate,\n+            String applicationTemplate) {\n+        this.accountService = accountService;\n+        this.indexTemplate = indexTemplate;\n+        this.applicationTemplate = applicationTemplate;\n+    }\n+\n+    @Override\n+    protected void doGet(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+            throws ServletException, IOException {\n+        if (req == null || resp == null) {\n+            throw new SmartherAuthorizationException(\"Authorization callback with null request/response\");\n+        }\n+\n+        final String servletBaseURL = extractServletBaseURL(req);\n+        final Map<String, String> replaceMap = new HashMap<>();\n+        logger.debug(\"Authorization callback servlet received GET request {}\", servletBaseURL);\n+\n+        // Handle the received data\n+        handleSmartherRedirect(replaceMap, servletBaseURL, req.getQueryString());\n+\n+        // Build response for the caller\n+        resp.setContentType(CONTENT_TYPE);\n+        replaceMap.put(KEY_REDIRECT_URI, servletBaseURL);\n+        replaceMap.put(KEY_APPLICATIONS, formatApplications(applicationTemplate, servletBaseURL));\n+        resp.getWriter().append(replaceKeysFromMap(indexTemplate, replaceMap));\n+        resp.getWriter().close();\n+    }\n+\n+    /**\n+     * Extracts the servlet base URL from received HTTP request, possibly handling reverse proxies.\n+     *\n+     * @param req The received HTTP request\n+     * @return A string containing the servlet base URL\n+     */\n+    private String extractServletBaseURL(HttpServletRequest req) {\n+        final StringBuffer requestURL = req.getRequestURL();\n+\n+        // Try to infer the real protocol from request headers\n+        final String realProtocol = StringUtils.defaultIfBlank(req.getHeader(X_FORWARDED_PROTO), req.getScheme());\n+\n+        return requestURL.replace(0, requestURL.indexOf(\":\"), realProtocol).toString();\n+    }\n+\n+    /**\n+     * Handles a possible call from BTicino/Legrand API gateway to the redirect_uri. If that is the case,\n+     * BTicino/Legrand API gateway will pass the authorization codes via the url and these are processed. In case of an\n+     * error this is shown to the user. If the user was authorized this is passed on to the handler. Based on all these\n+     * different outcomes the HTML is generated to inform the user.\n+     *\n+     * @param replaceMap a map with key String values that will be mapped in the HTML templates\n+     * @param servletBaseURL the servlet base, which should be used as the BTicino/Legrand API gateway redirect_uri\n+     *            value\n+     * @param queryString the query part of the GET request this servlet is processing\n+     */\n+    private void handleSmartherRedirect(Map<String, String> replaceMap, String servletBaseURL,\n+            @Nullable String queryString) {\n+        replaceMap.put(KEY_AUTHORIZED_BRIDGE, \"\");\n+        replaceMap.put(KEY_ERROR, \"\");\n+        replaceMap.put(KEY_PAGE_REFRESH, \"\");\n+\n+        if (queryString != null) {\n+            final MultiMap<String> params = new MultiMap<>();\n+            UrlEncoded.decodeTo(queryString, params, StandardCharsets.UTF_8.name());\n+            final String reqCode = params.getString(\"code\");\n+            final String reqState = params.getString(\"state\");\n+            final String reqError = params.getString(\"error\");\n+\n+            replaceMap.put(KEY_PAGE_REFRESH,\n+                    params.isEmpty() ? \"\" : String.format(HTML_META_REFRESH_CONTENT, servletBaseURL));\n+            if (!StringUtil.isBlank(reqError)) {\n+                logger.debug(\"Authorization redirected with an error: {}\", reqError);\n+                replaceMap.put(KEY_ERROR, String.format(HTML_ERROR, reqError));\n+            } else if (!StringUtil.isBlank(reqState)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19cf0c876eff6c53b1c2f4864ae682e3d33fb7a3"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ1NjE3Ng==", "bodyText": "What do you want to catch here? If you really have to catch an unchecked Exception, better specify the exact type.", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429456176", "createdAt": "2020-05-22T21:23:14Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/account/SmartherAuthorizationServlet.java", "diffHunk": "@@ -0,0 +1,235 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.account;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.util.MultiMap;\n+import org.eclipse.jetty.util.StringUtil;\n+import org.eclipse.jetty.util.UrlEncoded;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherAuthorizationException;\n+import org.openhab.binding.smarther.internal.api.model.Location;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SmartherAuthorizationServlet} manages the authorization with the BTicino/Legrand API gateway. The servlet\n+ * implements the Authorization Code flow and saves the resulting refreshToken with the bridge.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmartherAuthorizationServlet extends HttpServlet {\n+\n+    private static final long serialVersionUID = 5199173744807168342L;\n+\n+    private static final String CONTENT_TYPE = \"text/html;charset=UTF-8\";\n+    private static final String X_FORWARDED_PROTO = \"X-Forwarded-Proto\";\n+\n+    // Simple HTML templates for inserting messages.\n+    private static final String HTML_EMPTY_APPLICATIONS = \"<p class='block'>Manually add a Smarther Bridge to authorize it here<p>\";\n+    private static final String HTML_BRIDGE_AUTHORIZED = \"<p class='block authorized'>Bridge authorized for Client Id %s</p>\";\n+    private static final String HTML_ERROR = \"<p class='block error'>Call to Smarther API gateway failed with error: %s</p>\";\n+\n+    private static final Pattern MESSAGE_KEY_PATTERN = Pattern.compile(\"\\\\$\\\\{([^\\\\}]+)\\\\}\");\n+\n+    // Keys present in the index.html\n+    private static final String KEY_PAGE_REFRESH = \"pageRefresh\";\n+    private static final String HTML_META_REFRESH_CONTENT = \"<meta http-equiv='refresh' content='10; url=%s'>\";\n+    private static final String KEY_AUTHORIZED_BRIDGE = \"authorizedBridge\";\n+    private static final String KEY_ERROR = \"error\";\n+    private static final String KEY_APPLICATIONS = \"applications\";\n+    private static final String KEY_REDIRECT_URI = \"redirectUri\";\n+    // Keys present in the application.html\n+    private static final String APPLICATION_ID = \"application.id\";\n+    private static final String APPLICATION_NAME = \"application.name\";\n+    private static final String APPLICATION_LOCATIONS = \"application.locations\";\n+    private static final String APPLICATION_AUTHORIZED_CLASS = \"application.authorized\";\n+    private static final String APPLICATION_AUTHORIZE = \"application.authorize\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private final SmartherAccountService accountService;\n+    private final String indexTemplate;\n+    private final String applicationTemplate;\n+\n+    public SmartherAuthorizationServlet(SmartherAccountService accountService, String indexTemplate,\n+            String applicationTemplate) {\n+        this.accountService = accountService;\n+        this.indexTemplate = indexTemplate;\n+        this.applicationTemplate = applicationTemplate;\n+    }\n+\n+    @Override\n+    protected void doGet(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+            throws ServletException, IOException {\n+        if (req == null || resp == null) {\n+            throw new SmartherAuthorizationException(\"Authorization callback with null request/response\");\n+        }\n+\n+        final String servletBaseURL = extractServletBaseURL(req);\n+        final Map<String, String> replaceMap = new HashMap<>();\n+        logger.debug(\"Authorization callback servlet received GET request {}\", servletBaseURL);\n+\n+        // Handle the received data\n+        handleSmartherRedirect(replaceMap, servletBaseURL, req.getQueryString());\n+\n+        // Build response for the caller\n+        resp.setContentType(CONTENT_TYPE);\n+        replaceMap.put(KEY_REDIRECT_URI, servletBaseURL);\n+        replaceMap.put(KEY_APPLICATIONS, formatApplications(applicationTemplate, servletBaseURL));\n+        resp.getWriter().append(replaceKeysFromMap(indexTemplate, replaceMap));\n+        resp.getWriter().close();\n+    }\n+\n+    /**\n+     * Extracts the servlet base URL from received HTTP request, possibly handling reverse proxies.\n+     *\n+     * @param req The received HTTP request\n+     * @return A string containing the servlet base URL\n+     */\n+    private String extractServletBaseURL(HttpServletRequest req) {\n+        final StringBuffer requestURL = req.getRequestURL();\n+\n+        // Try to infer the real protocol from request headers\n+        final String realProtocol = StringUtils.defaultIfBlank(req.getHeader(X_FORWARDED_PROTO), req.getScheme());\n+\n+        return requestURL.replace(0, requestURL.indexOf(\":\"), realProtocol).toString();\n+    }\n+\n+    /**\n+     * Handles a possible call from BTicino/Legrand API gateway to the redirect_uri. If that is the case,\n+     * BTicino/Legrand API gateway will pass the authorization codes via the url and these are processed. In case of an\n+     * error this is shown to the user. If the user was authorized this is passed on to the handler. Based on all these\n+     * different outcomes the HTML is generated to inform the user.\n+     *\n+     * @param replaceMap a map with key String values that will be mapped in the HTML templates\n+     * @param servletBaseURL the servlet base, which should be used as the BTicino/Legrand API gateway redirect_uri\n+     *            value\n+     * @param queryString the query part of the GET request this servlet is processing\n+     */\n+    private void handleSmartherRedirect(Map<String, String> replaceMap, String servletBaseURL,\n+            @Nullable String queryString) {\n+        replaceMap.put(KEY_AUTHORIZED_BRIDGE, \"\");\n+        replaceMap.put(KEY_ERROR, \"\");\n+        replaceMap.put(KEY_PAGE_REFRESH, \"\");\n+\n+        if (queryString != null) {\n+            final MultiMap<String> params = new MultiMap<>();\n+            UrlEncoded.decodeTo(queryString, params, StandardCharsets.UTF_8.name());\n+            final String reqCode = params.getString(\"code\");\n+            final String reqState = params.getString(\"state\");\n+            final String reqError = params.getString(\"error\");\n+\n+            replaceMap.put(KEY_PAGE_REFRESH,\n+                    params.isEmpty() ? \"\" : String.format(HTML_META_REFRESH_CONTENT, servletBaseURL));\n+            if (!StringUtil.isBlank(reqError)) {\n+                logger.debug(\"Authorization redirected with an error: {}\", reqError);\n+                replaceMap.put(KEY_ERROR, String.format(HTML_ERROR, reqError));\n+            } else if (!StringUtil.isBlank(reqState)) {\n+                try {\n+                    logger.debug(\"Received from authorization - state:[{}] code:[{}]\", reqState, reqCode);\n+                    replaceMap.put(KEY_AUTHORIZED_BRIDGE, String.format(HTML_BRIDGE_AUTHORIZED,\n+                            accountService.authorize(servletBaseURL, reqState, reqCode)));\n+                } catch (RuntimeException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19cf0c876eff6c53b1c2f4864ae682e3d33fb7a3"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ1Njg3Mg==", "bodyText": "Apache Commons", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429456872", "createdAt": "2020-05-22T21:26:01Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/account/SmartherNotificationServlet.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.account;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherAuthorizationException;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherGatewayException;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherNotificationException;\n+import org.openhab.binding.smarther.internal.api.model.ModelUtil;\n+import org.openhab.binding.smarther.internal.api.model.Notification;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.reflect.TypeToken;\n+\n+/**\n+ * The {@link SmartherNotificationServlet} manages the notifications from BTicino/Legrand C2C notification service.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmartherNotificationServlet extends HttpServlet {\n+\n+    private static final long serialVersionUID = -2474355132186048438L;\n+\n+    private static final String CONTENT_TYPE = \"application/json;charset=UTF-8\";\n+    private static final String OK_RESULT_MSG = \"{\\\"result\\\":0}\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private final SmartherAccountService accountService;\n+\n+    public SmartherNotificationServlet(SmartherAccountService accountService) {\n+        this.accountService = accountService;\n+    }\n+\n+    @Override\n+    protected void doPost(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+            throws ServletException, IOException {\n+        if (req == null || resp == null) {\n+            throw new SmartherNotificationException(\"Notification callback with null request/response\");\n+        }\n+\n+        logger.debug(\"Notification callback servlet received POST request {}\", req.getRequestURI());\n+\n+        // Handle the received data\n+        final String requestBody = req.getReader().lines().collect(Collectors.joining(System.lineSeparator()));\n+        final String responseBody = handleSmartherNotifications(requestBody);\n+\n+        // Build response for the caller\n+        resp.setContentType(CONTENT_TYPE);\n+        resp.getWriter().append(responseBody);\n+        resp.setStatus(HttpStatus.OK_200);\n+        resp.getWriter().close();\n+    }\n+\n+    /**\n+     * Handles a notification payload received from BTicino/Legrand C2C notification service. If that is the case,\n+     * BTicino/Legrand C2C notification service will pass a list of notifications via the url and these are processed.\n+     * In case of an error, this is logged and the notifications are not passed on to the handler. Based on all these\n+     * different outcomes, the response is generated to inform the C2C service.\n+     *\n+     * @param payload the body part of the POST request this servlet is processing\n+     */\n+    private String handleSmartherNotifications(@Nullable String payload) {\n+        logger.trace(\"C2C listener received payload: {}\", payload);\n+        if (!StringUtils.isBlank(payload)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19cf0c876eff6c53b1c2f4864ae682e3d33fb7a3"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ2NDIyOA==", "bodyText": "Can you use Java native date time classes here? That would prevent an additional dependency to Joda.", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429464228", "createdAt": "2020-05-22T21:44:25Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/api/model/Chronothermostat.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.api.model;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.joda.time.DateTime;\n+import org.openhab.binding.smarther.internal.api.model.Enums.LoadState;\n+import org.openhab.binding.smarther.internal.api.model.Enums.MeasureUnit;\n+\n+import com.google.gson.annotations.SerializedName;\n+\n+/**\n+ * Smarther API Chronothermostat DTO class.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+public class Chronothermostat {\n+\n+    private String function;\n+    private String mode;\n+    @SerializedName(\"setPoint\")\n+    private Measure setPointTemperature;\n+    private List<Program> programs;\n+    @SerializedName(\"temperatureFormat\")\n+    private String temperatureFormat;\n+    @SerializedName(\"loadState\")\n+    private String loadState;\n+    @SerializedName(\"activationTime\")\n+    private String activationTime;\n+    private String time;\n+    private Sensor thermometer;\n+    private Sensor hygrometer;\n+    private boolean online;\n+    private Sender sender;\n+\n+    public String getFunction() {\n+        return function;\n+    }\n+\n+    public String getMode() {\n+        return mode;\n+    }\n+\n+    public Measure getSetPointTemperature() {\n+        return setPointTemperature;\n+    }\n+\n+    public List<Program> getPrograms() {\n+        return (programs != null) ? programs : Collections.emptyList();\n+    }\n+\n+    public String getTemperatureFormat() {\n+        return temperatureFormat;\n+    }\n+\n+    public MeasureUnit getTemperatureFormatUnit() {\n+        return MeasureUnit.fromValue(temperatureFormat);\n+    }\n+\n+    public boolean isTemperatureFormatCelsius() {\n+        return MeasureUnit.CELSIUS.getValue().equals(temperatureFormat);\n+    }\n+\n+    public boolean isTemperatureFormatFahrenheit() {\n+        return MeasureUnit.FAHRENHEIT.getValue().equals(temperatureFormat);\n+    }\n+\n+    public String getLoadState() {\n+        return loadState;\n+    }\n+\n+    public boolean isActive() {\n+        return LoadState.fromValue(loadState).isActive();\n+    }\n+\n+    public String getActivationTime() {\n+        return activationTime;\n+    }\n+\n+    public String getActivationTimeLabel() {\n+        String timeLabel = \"Forever\";\n+        if (activationTime != null) {\n+            final DateTime dateActivationTime = new DateTime(activationTime);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19cf0c876eff6c53b1c2f4864ae682e3d33fb7a3"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ2NDU4NQ==", "bodyText": "Apache Commons", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429464585", "createdAt": "2020-05-22T21:45:44Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/api/model/Location.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.api.model;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * Smarther API Location data class.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class Location {\n+\n+    private String plantId;\n+    private String name;\n+    private @Nullable String subscriptionId;\n+    private @Nullable String endpointUrl;\n+\n+    private Location(Plant plant, @Nullable Subscription subscription) {\n+        super();\n+        this.plantId = plant.getId();\n+        this.name = plant.getName();\n+        if (subscription != null) {\n+            this.subscriptionId = subscription.getSubscriptionId();\n+            this.endpointUrl = subscription.getEndpointUrl();\n+        }\n+    }\n+\n+    public static Location fromPlant(Plant plant, @Nullable Subscription subscription) {\n+        return new Location(plant, subscription);\n+    }\n+\n+    public static Location fromPlant(Plant plant) {\n+        return new Location(plant, null);\n+    }\n+\n+    public static Location fromPlant(Plant plant, Optional<Subscription> subscription) {\n+        return (subscription.isPresent()) ? new Location(plant, subscription.get()) : new Location(plant, null);\n+    }\n+\n+    public String getPlantId() {\n+        return plantId;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public boolean hasSubscription() {\n+        return StringUtils.isNotBlank(subscriptionId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19cf0c876eff6c53b1c2f4864ae682e3d33fb7a3"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ2NDk4Nw==", "bodyText": "Apache Commons", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429464987", "createdAt": "2020-05-22T21:47:05Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/api/model/Measure.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.api.model;\n+\n+import java.util.Optional;\n+\n+import javax.measure.quantity.Dimensionless;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.ImperialUnits;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.smarther.internal.api.model.Enums.MeasureUnit;\n+\n+import com.google.gson.annotations.SerializedName;\n+\n+import tec.uom.se.unit.Units;\n+\n+/**\n+ * Smarther API Measure DTO class.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+public class Measure {\n+\n+    @SerializedName(\"timeStamp\")\n+    private String timestamp;\n+    private String value;\n+    private String unit;\n+\n+    public String getTimestamp() {\n+        return timestamp;\n+    }\n+\n+    public String getValue() {\n+        return value;\n+    }\n+\n+    public String getUnit() {\n+        return unit;\n+    }\n+\n+    public MeasureUnit getMeasureUnit() {\n+        return MeasureUnit.fromValue(unit);\n+    }\n+\n+    public State toState() {\n+        State state = UnDefType.UNDEF;\n+        final Optional<Double> optValue = (StringUtils.isBlank(value)) ? Optional.empty()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19cf0c876eff6c53b1c2f4864ae682e3d33fb7a3"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ2NTQ4NA==", "bodyText": "Can you use Java native date time classes here? That would prevent an additional dependency to Joda.", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429465484", "createdAt": "2020-05-22T21:49:06Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/api/model/ModuleSettings.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.api.model;\n+\n+import static org.openhab.binding.smarther.internal.SmartherBindingConstants.*;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.joda.time.DateTime;\n+import org.joda.time.format.DateTimeFormat;\n+import org.openhab.binding.smarther.internal.api.model.Enums.BoostTime;\n+import org.openhab.binding.smarther.internal.api.model.Enums.Function;\n+import org.openhab.binding.smarther.internal.api.model.Enums.Mode;\n+\n+/**\n+ * Smarther API ModuleSettings update data class.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ModuleSettings {\n+\n+    private transient String plantId;\n+    private transient String moduleId;\n+    private Function function;\n+    private Mode mode;\n+    private QuantityType<Temperature> setPointTemperature;\n+    private int program;\n+    private BoostTime boostTime;\n+    private @Nullable String endDate;\n+    private int endHour;\n+    private int endMinute;\n+\n+    public ModuleSettings(String plantId, String moduleId) {\n+        this.plantId = plantId;\n+        this.moduleId = moduleId;\n+        this.function = Function.HEATING;\n+        this.mode = Mode.AUTOMATIC;\n+        this.setPointTemperature = QuantityType.valueOf(7.0, SIUnits.CELSIUS);\n+        this.program = 0;\n+        this.boostTime = BoostTime.MINUTES_30;\n+        this.endDate = null;\n+        this.endHour = 0;\n+        this.endMinute = 0;\n+    }\n+\n+    public void updateFromChronothermostat(Chronothermostat chronothermostat) {\n+        this.function = Function.fromValue(chronothermostat.getFunction());\n+    }\n+\n+    public String getPlantId() {\n+        return plantId;\n+    }\n+\n+    public String getModuleId() {\n+        return moduleId;\n+    }\n+\n+    public Function getFunction() {\n+        return function;\n+    }\n+\n+    public Mode getMode() {\n+        return mode;\n+    }\n+\n+    public void setMode(Mode mode) {\n+        this.mode = mode;\n+    }\n+\n+    public QuantityType<Temperature> getSetPointTemperature() {\n+        return setPointTemperature;\n+    }\n+\n+    @Nullable\n+    public QuantityType<Temperature> getSetPointTemperature(Unit<?> targetUnit) {\n+        return setPointTemperature.toUnit(targetUnit);\n+    }\n+\n+    public void setSetPointTemperature(QuantityType<Temperature> setPointTemperature) {\n+        this.setPointTemperature = setPointTemperature;\n+    }\n+\n+    public int getProgram() {\n+        return program;\n+    }\n+\n+    public void setProgram(int program) {\n+        this.program = program;\n+    }\n+\n+    public BoostTime getBoostTime() {\n+        return boostTime;\n+    }\n+\n+    public void setBoostTime(BoostTime boostTime) {\n+        this.boostTime = boostTime;\n+    }\n+\n+    @Nullable\n+    public String getEndDate() {\n+        return endDate;\n+    }\n+\n+    public boolean isEndDateExpired() {\n+        if (endDate == null) {\n+            return false;\n+        }\n+\n+        final DateTime dtEndDate = DateTimeFormat.forPattern(DATE_FORMAT).parseDateTime(endDate).withTimeAtStartOfDay();\n+        final DateTime dtToday = DateTime.now().withTimeAtStartOfDay();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19cf0c876eff6c53b1c2f4864ae682e3d33fb7a3"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ2NTUzOQ==", "bodyText": "Apache Commons", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429465539", "createdAt": "2020-05-22T21:49:16Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/api/model/ModuleSettings.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.api.model;\n+\n+import static org.openhab.binding.smarther.internal.SmartherBindingConstants.*;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.joda.time.DateTime;\n+import org.joda.time.format.DateTimeFormat;\n+import org.openhab.binding.smarther.internal.api.model.Enums.BoostTime;\n+import org.openhab.binding.smarther.internal.api.model.Enums.Function;\n+import org.openhab.binding.smarther.internal.api.model.Enums.Mode;\n+\n+/**\n+ * Smarther API ModuleSettings update data class.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ModuleSettings {\n+\n+    private transient String plantId;\n+    private transient String moduleId;\n+    private Function function;\n+    private Mode mode;\n+    private QuantityType<Temperature> setPointTemperature;\n+    private int program;\n+    private BoostTime boostTime;\n+    private @Nullable String endDate;\n+    private int endHour;\n+    private int endMinute;\n+\n+    public ModuleSettings(String plantId, String moduleId) {\n+        this.plantId = plantId;\n+        this.moduleId = moduleId;\n+        this.function = Function.HEATING;\n+        this.mode = Mode.AUTOMATIC;\n+        this.setPointTemperature = QuantityType.valueOf(7.0, SIUnits.CELSIUS);\n+        this.program = 0;\n+        this.boostTime = BoostTime.MINUTES_30;\n+        this.endDate = null;\n+        this.endHour = 0;\n+        this.endMinute = 0;\n+    }\n+\n+    public void updateFromChronothermostat(Chronothermostat chronothermostat) {\n+        this.function = Function.fromValue(chronothermostat.getFunction());\n+    }\n+\n+    public String getPlantId() {\n+        return plantId;\n+    }\n+\n+    public String getModuleId() {\n+        return moduleId;\n+    }\n+\n+    public Function getFunction() {\n+        return function;\n+    }\n+\n+    public Mode getMode() {\n+        return mode;\n+    }\n+\n+    public void setMode(Mode mode) {\n+        this.mode = mode;\n+    }\n+\n+    public QuantityType<Temperature> getSetPointTemperature() {\n+        return setPointTemperature;\n+    }\n+\n+    @Nullable\n+    public QuantityType<Temperature> getSetPointTemperature(Unit<?> targetUnit) {\n+        return setPointTemperature.toUnit(targetUnit);\n+    }\n+\n+    public void setSetPointTemperature(QuantityType<Temperature> setPointTemperature) {\n+        this.setPointTemperature = setPointTemperature;\n+    }\n+\n+    public int getProgram() {\n+        return program;\n+    }\n+\n+    public void setProgram(int program) {\n+        this.program = program;\n+    }\n+\n+    public BoostTime getBoostTime() {\n+        return boostTime;\n+    }\n+\n+    public void setBoostTime(BoostTime boostTime) {\n+        this.boostTime = boostTime;\n+    }\n+\n+    @Nullable\n+    public String getEndDate() {\n+        return endDate;\n+    }\n+\n+    public boolean isEndDateExpired() {\n+        if (endDate == null) {\n+            return false;\n+        }\n+\n+        final DateTime dtEndDate = DateTimeFormat.forPattern(DATE_FORMAT).parseDateTime(endDate).withTimeAtStartOfDay();\n+        final DateTime dtToday = DateTime.now().withTimeAtStartOfDay();\n+\n+        return (dtEndDate.isBefore(dtToday));\n+    }\n+\n+    public void setEndDate(String endDate) {\n+        this.endDate = StringUtils.stripToNull(endDate);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19cf0c876eff6c53b1c2f4864ae682e3d33fb7a3"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQ2NTY4Ng==", "bodyText": "Can you use Java native date time classes here? That would prevent an additional dependency to Joda.", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429465686", "createdAt": "2020-05-22T21:49:56Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/api/model/ModuleSettings.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.api.model;\n+\n+import static org.openhab.binding.smarther.internal.SmartherBindingConstants.*;\n+\n+import javax.measure.Unit;\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.joda.time.DateTime;\n+import org.joda.time.format.DateTimeFormat;\n+import org.openhab.binding.smarther.internal.api.model.Enums.BoostTime;\n+import org.openhab.binding.smarther.internal.api.model.Enums.Function;\n+import org.openhab.binding.smarther.internal.api.model.Enums.Mode;\n+\n+/**\n+ * Smarther API ModuleSettings update data class.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class ModuleSettings {\n+\n+    private transient String plantId;\n+    private transient String moduleId;\n+    private Function function;\n+    private Mode mode;\n+    private QuantityType<Temperature> setPointTemperature;\n+    private int program;\n+    private BoostTime boostTime;\n+    private @Nullable String endDate;\n+    private int endHour;\n+    private int endMinute;\n+\n+    public ModuleSettings(String plantId, String moduleId) {\n+        this.plantId = plantId;\n+        this.moduleId = moduleId;\n+        this.function = Function.HEATING;\n+        this.mode = Mode.AUTOMATIC;\n+        this.setPointTemperature = QuantityType.valueOf(7.0, SIUnits.CELSIUS);\n+        this.program = 0;\n+        this.boostTime = BoostTime.MINUTES_30;\n+        this.endDate = null;\n+        this.endHour = 0;\n+        this.endMinute = 0;\n+    }\n+\n+    public void updateFromChronothermostat(Chronothermostat chronothermostat) {\n+        this.function = Function.fromValue(chronothermostat.getFunction());\n+    }\n+\n+    public String getPlantId() {\n+        return plantId;\n+    }\n+\n+    public String getModuleId() {\n+        return moduleId;\n+    }\n+\n+    public Function getFunction() {\n+        return function;\n+    }\n+\n+    public Mode getMode() {\n+        return mode;\n+    }\n+\n+    public void setMode(Mode mode) {\n+        this.mode = mode;\n+    }\n+\n+    public QuantityType<Temperature> getSetPointTemperature() {\n+        return setPointTemperature;\n+    }\n+\n+    @Nullable\n+    public QuantityType<Temperature> getSetPointTemperature(Unit<?> targetUnit) {\n+        return setPointTemperature.toUnit(targetUnit);\n+    }\n+\n+    public void setSetPointTemperature(QuantityType<Temperature> setPointTemperature) {\n+        this.setPointTemperature = setPointTemperature;\n+    }\n+\n+    public int getProgram() {\n+        return program;\n+    }\n+\n+    public void setProgram(int program) {\n+        this.program = program;\n+    }\n+\n+    public BoostTime getBoostTime() {\n+        return boostTime;\n+    }\n+\n+    public void setBoostTime(BoostTime boostTime) {\n+        this.boostTime = boostTime;\n+    }\n+\n+    @Nullable\n+    public String getEndDate() {\n+        return endDate;\n+    }\n+\n+    public boolean isEndDateExpired() {\n+        if (endDate == null) {\n+            return false;\n+        }\n+\n+        final DateTime dtEndDate = DateTimeFormat.forPattern(DATE_FORMAT).parseDateTime(endDate).withTimeAtStartOfDay();\n+        final DateTime dtToday = DateTime.now().withTimeAtStartOfDay();\n+\n+        return (dtEndDate.isBefore(dtToday));\n+    }\n+\n+    public void setEndDate(String endDate) {\n+        this.endDate = StringUtils.stripToNull(endDate);\n+    }\n+\n+    public int getEndHour() {\n+        return endHour;\n+    }\n+\n+    public void setEndHour(int endHour) {\n+        this.endHour = endHour;\n+    }\n+\n+    public int getEndMinute() {\n+        return endMinute;\n+    }\n+\n+    public void setEndMinute(int endMinute) {\n+        this.endMinute = endMinute;\n+    }\n+\n+    public String getActivationTime() {\n+        if (mode.equals(Mode.MANUAL) && (endDate != null)) {\n+            DateTime d = DateTimeFormat.forPattern(DATE_FORMAT).parseDateTime(endDate);\n+            d = d.withTime(endHour, endMinute, 0, 0);\n+            return d.toString(DATETIME_FORMAT);\n+        } else if (mode.equals(Mode.BOOST)) {\n+            DateTime d1 = DateTime.now().withSecondOfMinute(0).withMillisOfSecond(0);\n+            DateTime d2 = d1.plusMinutes(boostTime.getValue());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19cf0c876eff6c53b1c2f4864ae682e3d33fb7a3"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUyODc1Mw==", "bodyText": "What Exception do you want to catch here? Would a checked Exception be sufficient?", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429528753", "createdAt": "2020-05-23T08:56:09Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/discovery/SmartherModuleDiscoveryService.java", "diffHunk": "@@ -0,0 +1,155 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.discovery;\n+\n+import static org.openhab.binding.smarther.internal.SmartherBindingConstants.*;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.commons.lang.WordUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.openhab.binding.smarther.internal.account.SmartherAccountHandler;\n+import org.openhab.binding.smarther.internal.api.model.Location;\n+import org.openhab.binding.smarther.internal.api.model.Module;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SmartherModuleDiscoveryService} queries the Smarther API gateway for available modules.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.smarther\")\n+@NonNullByDefault\n+public class SmartherModuleDiscoveryService extends AbstractDiscoveryService\n+        implements DiscoveryService, ThingHandlerService {\n+\n+    // Only modules can be discovered. A bridge must be manually added.\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections.singleton(THING_TYPE_MODULE);\n+    // The call to listModules is fast\n+    private static final int DISCOVERY_TIME_SECONDS = 10;\n+    // Handling of the background scan for new devices\n+    private static final boolean BACKGROUND_SCAN_ENABLED = false;\n+    private static final long BACKGROUND_SCAN_REFRESH_MINUTES = 1;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private @NonNullByDefault({}) SmartherAccountHandler bridgeHandler;\n+    private @NonNullByDefault({}) ThingUID bridgeUID;\n+\n+    private @Nullable ScheduledFuture<?> backgroundFuture;\n+\n+    public SmartherModuleDiscoveryService() {\n+        super(SUPPORTED_THING_TYPES_UIDS, DISCOVERY_TIME_SECONDS);\n+    }\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypes() {\n+        return SUPPORTED_THING_TYPES_UIDS;\n+    }\n+\n+    @Override\n+    public void activate() {\n+        Map<String, @Nullable Object> properties = new HashMap<>();\n+        properties.put(DiscoveryService.CONFIG_PROPERTY_BACKGROUND_DISCOVERY, Boolean.TRUE);\n+        super.activate(properties);\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        super.deactivate();\n+    }\n+\n+    @Override\n+    public void setThingHandler(@Nullable ThingHandler handler) {\n+        if (handler instanceof SmartherAccountHandler) {\n+            bridgeHandler = (SmartherAccountHandler) handler;\n+            bridgeUID = bridgeHandler.getUID();\n+        }\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return bridgeHandler;\n+    }\n+\n+    @Override\n+    protected synchronized void startBackgroundDiscovery() {\n+        stopBackgroundDiscovery();\n+        if (BACKGROUND_SCAN_ENABLED) {\n+            backgroundFuture = scheduler.scheduleWithFixedDelay(this::startScan, BACKGROUND_SCAN_REFRESH_MINUTES,\n+                    BACKGROUND_SCAN_REFRESH_MINUTES, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    @Override\n+    protected synchronized void stopBackgroundDiscovery() {\n+        if (backgroundFuture != null) {\n+            backgroundFuture.cancel(true);\n+            backgroundFuture = null;\n+        }\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        // If the bridge is not online no other thing devices can be found, so no reason to scan at this moment.\n+        removeOlderResults(getTimestampOfLastScan());\n+        if (bridgeHandler != null && bridgeHandler.isOnline()) {\n+            logger.debug(\"Starting modules discovery for bridge {}\", bridgeUID);\n+            try {\n+                bridgeHandler.listLocations()\n+                        .forEach(l -> bridgeHandler.listModules(l).forEach(m -> thingDiscovered(l, m)));\n+            } catch (RuntimeException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19cf0c876eff6c53b1c2f4864ae682e3d33fb7a3"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUyODg0MA==", "bodyText": "Logging the stacktrace (last parameter) needs only be done if a bug in your code has been detected", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429528840", "createdAt": "2020-05-23T08:57:38Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/discovery/SmartherModuleDiscoveryService.java", "diffHunk": "@@ -0,0 +1,155 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.discovery;\n+\n+import static org.openhab.binding.smarther.internal.SmartherBindingConstants.*;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.commons.lang.WordUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.openhab.binding.smarther.internal.account.SmartherAccountHandler;\n+import org.openhab.binding.smarther.internal.api.model.Location;\n+import org.openhab.binding.smarther.internal.api.model.Module;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SmartherModuleDiscoveryService} queries the Smarther API gateway for available modules.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.smarther\")\n+@NonNullByDefault\n+public class SmartherModuleDiscoveryService extends AbstractDiscoveryService\n+        implements DiscoveryService, ThingHandlerService {\n+\n+    // Only modules can be discovered. A bridge must be manually added.\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections.singleton(THING_TYPE_MODULE);\n+    // The call to listModules is fast\n+    private static final int DISCOVERY_TIME_SECONDS = 10;\n+    // Handling of the background scan for new devices\n+    private static final boolean BACKGROUND_SCAN_ENABLED = false;\n+    private static final long BACKGROUND_SCAN_REFRESH_MINUTES = 1;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private @NonNullByDefault({}) SmartherAccountHandler bridgeHandler;\n+    private @NonNullByDefault({}) ThingUID bridgeUID;\n+\n+    private @Nullable ScheduledFuture<?> backgroundFuture;\n+\n+    public SmartherModuleDiscoveryService() {\n+        super(SUPPORTED_THING_TYPES_UIDS, DISCOVERY_TIME_SECONDS);\n+    }\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypes() {\n+        return SUPPORTED_THING_TYPES_UIDS;\n+    }\n+\n+    @Override\n+    public void activate() {\n+        Map<String, @Nullable Object> properties = new HashMap<>();\n+        properties.put(DiscoveryService.CONFIG_PROPERTY_BACKGROUND_DISCOVERY, Boolean.TRUE);\n+        super.activate(properties);\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        super.deactivate();\n+    }\n+\n+    @Override\n+    public void setThingHandler(@Nullable ThingHandler handler) {\n+        if (handler instanceof SmartherAccountHandler) {\n+            bridgeHandler = (SmartherAccountHandler) handler;\n+            bridgeUID = bridgeHandler.getUID();\n+        }\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return bridgeHandler;\n+    }\n+\n+    @Override\n+    protected synchronized void startBackgroundDiscovery() {\n+        stopBackgroundDiscovery();\n+        if (BACKGROUND_SCAN_ENABLED) {\n+            backgroundFuture = scheduler.scheduleWithFixedDelay(this::startScan, BACKGROUND_SCAN_REFRESH_MINUTES,\n+                    BACKGROUND_SCAN_REFRESH_MINUTES, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    @Override\n+    protected synchronized void stopBackgroundDiscovery() {\n+        if (backgroundFuture != null) {\n+            backgroundFuture.cancel(true);\n+            backgroundFuture = null;\n+        }\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        // If the bridge is not online no other thing devices can be found, so no reason to scan at this moment.\n+        removeOlderResults(getTimestampOfLastScan());\n+        if (bridgeHandler != null && bridgeHandler.isOnline()) {\n+            logger.debug(\"Starting modules discovery for bridge {}\", bridgeUID);\n+            try {\n+                bridgeHandler.listLocations()\n+                        .forEach(l -> bridgeHandler.listModules(l).forEach(m -> thingDiscovered(l, m)));\n+            } catch (RuntimeException e) {\n+                logger.warn(\"Finding modules failed with message: {}\", e.getMessage(), e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19cf0c876eff6c53b1c2f4864ae682e3d33fb7a3"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUyOTU3Mw==", "bodyText": "You don't need to validate the config again, if you specify min/max etc. in the XML files.", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429529573", "createdAt": "2020-05-23T09:08:41Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/handler/SmartherBridgeHandler.java", "diffHunk": "@@ -0,0 +1,629 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.handler;\n+\n+import static org.openhab.binding.smarther.internal.SmartherBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.net.InetAddress;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.UnknownHostException;\n+import java.time.Duration;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.auth.client.oauth2.AccessTokenRefreshListener;\n+import org.eclipse.smarthome.core.auth.client.oauth2.AccessTokenResponse;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthClientService;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthException;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthFactory;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthResponseException;\n+import org.eclipse.smarthome.core.cache.ExpiringCache;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.smarther.internal.account.SmartherAccountHandler;\n+import org.openhab.binding.smarther.internal.account.SmartherNotificationHandler;\n+import org.openhab.binding.smarther.internal.api.SmartherApi;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherAuthorizationException;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherGatewayException;\n+import org.openhab.binding.smarther.internal.api.model.Location;\n+import org.openhab.binding.smarther.internal.api.model.Module;\n+import org.openhab.binding.smarther.internal.api.model.ModuleSettings;\n+import org.openhab.binding.smarther.internal.api.model.ModuleStatus;\n+import org.openhab.binding.smarther.internal.api.model.Notification;\n+import org.openhab.binding.smarther.internal.api.model.Plant;\n+import org.openhab.binding.smarther.internal.api.model.Program;\n+import org.openhab.binding.smarther.internal.api.model.Subscription;\n+import org.openhab.binding.smarther.internal.config.SmartherBridgeConfiguration;\n+import org.openhab.binding.smarther.internal.discovery.SmartherModuleDiscoveryService;\n+import org.openhab.binding.smarther.internal.model.BridgeStatus;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SmartherBridgeHandler} is responsible for accessing the BTicino/Legrand Smarther API gateway.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmartherBridgeHandler extends BaseBridgeHandler\n+        implements SmartherAccountHandler, SmartherNotificationHandler, AccessTokenRefreshListener {\n+\n+    private static final long POLL_INITIAL_DELAY = 5;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private final OAuthFactory oAuthFactory;\n+    private final HttpClient httpClient;\n+\n+    // Field members assigned in initialize method\n+    private @NonNullByDefault({}) Future<?> pollFuture;\n+    private @NonNullByDefault({}) OAuthClientService oAuthService;\n+    private @NonNullByDefault({}) SmartherApi smartherApi;\n+    private @NonNullByDefault({}) SmartherBridgeConfiguration config;\n+\n+    // Bridge local status\n+    private @NonNullByDefault({}) ExpiringCache<List<Location>> locationCache;\n+    private @NonNullByDefault({}) BridgeStatus bridgeStatus;\n+\n+    public SmartherBridgeHandler(Bridge bridge, OAuthFactory oAuthFactory, HttpClient httpClient) {\n+        super(bridge);\n+        this.oAuthFactory = oAuthFactory;\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(SmartherModuleDiscoveryService.class);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        switch (channelUID.getId()) {\n+            case CHANNEL_ACCESS_TOKEN:\n+                if (command instanceof RefreshType) {\n+                    onAccessTokenResponse(getAccessTokenResponse());\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_FETCH_CONFIG:\n+                if (command instanceof OnOffType) {\n+                    if (OnOffType.ON.equals(command)) {\n+                        logger.debug(\"Bridge[{}] Manually triggered channel to refresh the Bridge config\",\n+                                thing.getUID());\n+                        schedulePoll();\n+                        updateChannelState(CHANNEL_FETCH_CONFIG, OnOffType.OFF);\n+                    }\n+                    return;\n+                }\n+                break;\n+        }\n+\n+        if (command instanceof RefreshType) {\n+            // Avoid logging wrong command when refresh command is sent\n+            return;\n+        }\n+\n+        logger.debug(\"Bridge[{}] Received command {} of wrong type {} on channel {}\", thing.getUID(), command,\n+                command.getClass().getTypeName(), channelUID.getId());\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Bridge[{}] Initialize handler\", thing.getUID());\n+\n+        config = getConfigAs(SmartherBridgeConfiguration.class);\n+        if (StringUtils.isBlank(config.getSubscriptionKey())) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Subscription Key' property is not set or empty. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+        if (StringUtils.isBlank(config.getClientId())) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Client Id' property is not set or empty. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+        if (StringUtils.isBlank(config.getClientSecret())) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Client Secret' property is not set or empty. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+        if (config.getStatusRefreshPeriod() <= 0) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Bridge Status Refresh Period' must be > 0. If you have an older thing please recreate it.\");\n+            return;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19cf0c876eff6c53b1c2f4864ae682e3d33fb7a3"}, "originalPosition": 169}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUyOTk1MQ==", "bodyText": "It's bad practice to catch unchecked Exceptions. If you expect a particular error, catch it explicitly with a checked Exception.", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429529951", "createdAt": "2020-05-23T09:14:40Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/handler/SmartherBridgeHandler.java", "diffHunk": "@@ -0,0 +1,629 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.handler;\n+\n+import static org.openhab.binding.smarther.internal.SmartherBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.net.InetAddress;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.UnknownHostException;\n+import java.time.Duration;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.auth.client.oauth2.AccessTokenRefreshListener;\n+import org.eclipse.smarthome.core.auth.client.oauth2.AccessTokenResponse;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthClientService;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthException;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthFactory;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthResponseException;\n+import org.eclipse.smarthome.core.cache.ExpiringCache;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.smarther.internal.account.SmartherAccountHandler;\n+import org.openhab.binding.smarther.internal.account.SmartherNotificationHandler;\n+import org.openhab.binding.smarther.internal.api.SmartherApi;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherAuthorizationException;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherGatewayException;\n+import org.openhab.binding.smarther.internal.api.model.Location;\n+import org.openhab.binding.smarther.internal.api.model.Module;\n+import org.openhab.binding.smarther.internal.api.model.ModuleSettings;\n+import org.openhab.binding.smarther.internal.api.model.ModuleStatus;\n+import org.openhab.binding.smarther.internal.api.model.Notification;\n+import org.openhab.binding.smarther.internal.api.model.Plant;\n+import org.openhab.binding.smarther.internal.api.model.Program;\n+import org.openhab.binding.smarther.internal.api.model.Subscription;\n+import org.openhab.binding.smarther.internal.config.SmartherBridgeConfiguration;\n+import org.openhab.binding.smarther.internal.discovery.SmartherModuleDiscoveryService;\n+import org.openhab.binding.smarther.internal.model.BridgeStatus;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SmartherBridgeHandler} is responsible for accessing the BTicino/Legrand Smarther API gateway.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmartherBridgeHandler extends BaseBridgeHandler\n+        implements SmartherAccountHandler, SmartherNotificationHandler, AccessTokenRefreshListener {\n+\n+    private static final long POLL_INITIAL_DELAY = 5;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private final OAuthFactory oAuthFactory;\n+    private final HttpClient httpClient;\n+\n+    // Field members assigned in initialize method\n+    private @NonNullByDefault({}) Future<?> pollFuture;\n+    private @NonNullByDefault({}) OAuthClientService oAuthService;\n+    private @NonNullByDefault({}) SmartherApi smartherApi;\n+    private @NonNullByDefault({}) SmartherBridgeConfiguration config;\n+\n+    // Bridge local status\n+    private @NonNullByDefault({}) ExpiringCache<List<Location>> locationCache;\n+    private @NonNullByDefault({}) BridgeStatus bridgeStatus;\n+\n+    public SmartherBridgeHandler(Bridge bridge, OAuthFactory oAuthFactory, HttpClient httpClient) {\n+        super(bridge);\n+        this.oAuthFactory = oAuthFactory;\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(SmartherModuleDiscoveryService.class);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        switch (channelUID.getId()) {\n+            case CHANNEL_ACCESS_TOKEN:\n+                if (command instanceof RefreshType) {\n+                    onAccessTokenResponse(getAccessTokenResponse());\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_FETCH_CONFIG:\n+                if (command instanceof OnOffType) {\n+                    if (OnOffType.ON.equals(command)) {\n+                        logger.debug(\"Bridge[{}] Manually triggered channel to refresh the Bridge config\",\n+                                thing.getUID());\n+                        schedulePoll();\n+                        updateChannelState(CHANNEL_FETCH_CONFIG, OnOffType.OFF);\n+                    }\n+                    return;\n+                }\n+                break;\n+        }\n+\n+        if (command instanceof RefreshType) {\n+            // Avoid logging wrong command when refresh command is sent\n+            return;\n+        }\n+\n+        logger.debug(\"Bridge[{}] Received command {} of wrong type {} on channel {}\", thing.getUID(), command,\n+                command.getClass().getTypeName(), channelUID.getId());\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Bridge[{}] Initialize handler\", thing.getUID());\n+\n+        config = getConfigAs(SmartherBridgeConfiguration.class);\n+        if (StringUtils.isBlank(config.getSubscriptionKey())) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Subscription Key' property is not set or empty. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+        if (StringUtils.isBlank(config.getClientId())) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Client Id' property is not set or empty. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+        if (StringUtils.isBlank(config.getClientSecret())) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Client Secret' property is not set or empty. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+        if (config.getStatusRefreshPeriod() <= 0) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Bridge Status Refresh Period' must be > 0. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        // Initialize OAuth2 authentication support\n+        oAuthService = oAuthFactory.createOAuthClientService(thing.getUID().getAsString(), SMARTHER_API_TOKEN_URL,\n+                SMARTHER_AUTHORIZE_URL, config.getClientId(), config.getClientSecret(), SMARTHER_API_SCOPES, false);\n+        oAuthService.addAccessTokenRefreshListener(SmartherBridgeHandler.this);\n+        smartherApi = new SmartherApi(config.getSubscriptionKey(), oAuthService, scheduler, httpClient);\n+\n+        // Setup locations (plant Ids) local cache\n+        locationCache = new ExpiringCache<>(Duration.ofMinutes(config.getStatusRefreshPeriod()), this::getLocationList);\n+        bridgeStatus = new BridgeStatus();\n+\n+        schedulePoll();\n+\n+        logger.debug(\"Bridge[{}] Finished initializing!\", thing.getUID());\n+    }\n+\n+    private void updateNotifications(List<Subscription> subscriptions) {\n+        // Get the notifications list from bridge config\n+        List<String> notifications = config.getNotifications();\n+\n+        for (Subscription s : subscriptions) {\n+            if (s.getEndpointUrl().equalsIgnoreCase(config.getNotificationUrl())\n+                    && !notifications.contains(s.getSubscriptionId())) {\n+                // Add the external subscription to notifications list\n+                notifications = config.addNotification(s.getSubscriptionId());\n+\n+                // Save the updated notifications list back to bridge config\n+                Configuration configuration = editConfiguration();\n+                configuration.put(PROPERTY_NOTIFICATIONS, notifications);\n+                updateConfiguration(configuration);\n+            }\n+        }\n+    }\n+\n+    private List<Location> getLocationList() {\n+        // Retrieve the plants list from the API Gateway\n+        final List<Plant> plants = listPlants();\n+\n+        List<Location> locations;\n+        if (config.isUseNotifications()) {\n+            // Retrieve the subscriptions list from the API Gateway\n+            final List<Subscription> subscriptions = getSubscriptionList();\n+\n+            // Enrich the notifications list with externally registered subscriptions\n+            updateNotifications(subscriptions);\n+\n+            // Get the notifications list from bridge config\n+            final List<String> notifications = config.getNotifications();\n+\n+            locations = plants.stream().map(p -> Location.fromPlant(p, subscriptions.stream()\n+                    .filter(s -> s.getPlantId().equals(p.getId()) && notifications.contains(s.getSubscriptionId()))\n+                    .findFirst())).collect(Collectors.toList());\n+        } else {\n+            locations = plants.stream().map(p -> Location.fromPlant(p)).collect(Collectors.toList());\n+        }\n+        logger.debug(\"Bridge[{}] Available locations: {}\", thing.getUID(), locations);\n+\n+        return locations;\n+    }\n+\n+    @Override\n+    public void handleRemoval() {\n+        super.handleRemoval();\n+        stopPoll(true);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Bridge[{}] Dispose handler\", thing.getUID());\n+        if (oAuthService != null) {\n+            oAuthService.removeAccessTokenRefreshListener(this);\n+        }\n+        oAuthFactory.ungetOAuthService(thing.getUID().getAsString());\n+        stopPoll(true);\n+        logger.debug(\"Bridge[{}] Finished disposing!\", thing.getUID());\n+    }\n+\n+    /**\n+     * This method initiates a new thread for polling the available Smarther plants and update the plants\n+     * information.\n+     */\n+    private void schedulePoll() {\n+        stopPoll(false);\n+        // Schedule poll to start after POLL_INITIAL_DELAY sec and run periodically based on status refresh period\n+        pollFuture = scheduler.scheduleWithFixedDelay(this::poll, POLL_INITIAL_DELAY,\n+                config.getStatusRefreshPeriod() * 60, TimeUnit.SECONDS);\n+        logger.debug(\"Bridge[{}] Scheduled poll for {} sec out, then every {} min\", thing.getUID(), POLL_INITIAL_DELAY,\n+                config.getStatusRefreshPeriod());\n+    }\n+\n+    /**\n+     * Cancels all running schedulers.\n+     *\n+     * @param mayInterruptIfRunning true if the thread executing this task should be interrupted; otherwise, in-progress\n+     *            tasks are allowed to complete.\n+     */\n+    private synchronized void stopPoll(boolean mayInterruptIfRunning) {\n+        if (pollFuture != null && !pollFuture.isCancelled()) {\n+            pollFuture.cancel(mayInterruptIfRunning);\n+            pollFuture = null;\n+        }\n+    }\n+\n+    /**\n+     * Calls the Smarther API and collects plant data. Returns true if method completed without errors.\n+     *\n+     * @return true if method completed without errors.\n+     */\n+    private synchronized boolean poll() {\n+        try {\n+            onAccessTokenResponse(getAccessTokenResponse());\n+\n+            expireCache();\n+            listLocations();\n+\n+            updateStatus(ThingStatus.ONLINE);\n+            return true;\n+        } catch (SmartherAuthorizationException e) {\n+            logger.warn(\"Bridge[{}] Authorization error during polling: {}\", thing.getUID(), e.getMessage());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+            schedulePoll();\n+            return false;\n+        } catch (SmartherGatewayException e) {\n+            logger.warn(\"Bridge[{}] API Gateway error during polling: {}\", thing.getUID(), e.getMessage());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            schedulePoll();\n+            return false;\n+        } catch (RuntimeException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19cf0c876eff6c53b1c2f4864ae682e3d33fb7a3"}, "originalPosition": 299}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUzMTQyNA==", "bodyText": "Unchecked exception", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429531424", "createdAt": "2020-05-23T09:38:17Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/handler/SmartherBridgeHandler.java", "diffHunk": "@@ -0,0 +1,629 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.handler;\n+\n+import static org.openhab.binding.smarther.internal.SmartherBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.net.InetAddress;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.UnknownHostException;\n+import java.time.Duration;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.auth.client.oauth2.AccessTokenRefreshListener;\n+import org.eclipse.smarthome.core.auth.client.oauth2.AccessTokenResponse;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthClientService;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthException;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthFactory;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthResponseException;\n+import org.eclipse.smarthome.core.cache.ExpiringCache;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.smarther.internal.account.SmartherAccountHandler;\n+import org.openhab.binding.smarther.internal.account.SmartherNotificationHandler;\n+import org.openhab.binding.smarther.internal.api.SmartherApi;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherAuthorizationException;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherGatewayException;\n+import org.openhab.binding.smarther.internal.api.model.Location;\n+import org.openhab.binding.smarther.internal.api.model.Module;\n+import org.openhab.binding.smarther.internal.api.model.ModuleSettings;\n+import org.openhab.binding.smarther.internal.api.model.ModuleStatus;\n+import org.openhab.binding.smarther.internal.api.model.Notification;\n+import org.openhab.binding.smarther.internal.api.model.Plant;\n+import org.openhab.binding.smarther.internal.api.model.Program;\n+import org.openhab.binding.smarther.internal.api.model.Subscription;\n+import org.openhab.binding.smarther.internal.config.SmartherBridgeConfiguration;\n+import org.openhab.binding.smarther.internal.discovery.SmartherModuleDiscoveryService;\n+import org.openhab.binding.smarther.internal.model.BridgeStatus;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SmartherBridgeHandler} is responsible for accessing the BTicino/Legrand Smarther API gateway.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmartherBridgeHandler extends BaseBridgeHandler\n+        implements SmartherAccountHandler, SmartherNotificationHandler, AccessTokenRefreshListener {\n+\n+    private static final long POLL_INITIAL_DELAY = 5;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private final OAuthFactory oAuthFactory;\n+    private final HttpClient httpClient;\n+\n+    // Field members assigned in initialize method\n+    private @NonNullByDefault({}) Future<?> pollFuture;\n+    private @NonNullByDefault({}) OAuthClientService oAuthService;\n+    private @NonNullByDefault({}) SmartherApi smartherApi;\n+    private @NonNullByDefault({}) SmartherBridgeConfiguration config;\n+\n+    // Bridge local status\n+    private @NonNullByDefault({}) ExpiringCache<List<Location>> locationCache;\n+    private @NonNullByDefault({}) BridgeStatus bridgeStatus;\n+\n+    public SmartherBridgeHandler(Bridge bridge, OAuthFactory oAuthFactory, HttpClient httpClient) {\n+        super(bridge);\n+        this.oAuthFactory = oAuthFactory;\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(SmartherModuleDiscoveryService.class);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        switch (channelUID.getId()) {\n+            case CHANNEL_ACCESS_TOKEN:\n+                if (command instanceof RefreshType) {\n+                    onAccessTokenResponse(getAccessTokenResponse());\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_FETCH_CONFIG:\n+                if (command instanceof OnOffType) {\n+                    if (OnOffType.ON.equals(command)) {\n+                        logger.debug(\"Bridge[{}] Manually triggered channel to refresh the Bridge config\",\n+                                thing.getUID());\n+                        schedulePoll();\n+                        updateChannelState(CHANNEL_FETCH_CONFIG, OnOffType.OFF);\n+                    }\n+                    return;\n+                }\n+                break;\n+        }\n+\n+        if (command instanceof RefreshType) {\n+            // Avoid logging wrong command when refresh command is sent\n+            return;\n+        }\n+\n+        logger.debug(\"Bridge[{}] Received command {} of wrong type {} on channel {}\", thing.getUID(), command,\n+                command.getClass().getTypeName(), channelUID.getId());\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Bridge[{}] Initialize handler\", thing.getUID());\n+\n+        config = getConfigAs(SmartherBridgeConfiguration.class);\n+        if (StringUtils.isBlank(config.getSubscriptionKey())) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Subscription Key' property is not set or empty. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+        if (StringUtils.isBlank(config.getClientId())) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Client Id' property is not set or empty. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+        if (StringUtils.isBlank(config.getClientSecret())) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Client Secret' property is not set or empty. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+        if (config.getStatusRefreshPeriod() <= 0) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Bridge Status Refresh Period' must be > 0. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        // Initialize OAuth2 authentication support\n+        oAuthService = oAuthFactory.createOAuthClientService(thing.getUID().getAsString(), SMARTHER_API_TOKEN_URL,\n+                SMARTHER_AUTHORIZE_URL, config.getClientId(), config.getClientSecret(), SMARTHER_API_SCOPES, false);\n+        oAuthService.addAccessTokenRefreshListener(SmartherBridgeHandler.this);\n+        smartherApi = new SmartherApi(config.getSubscriptionKey(), oAuthService, scheduler, httpClient);\n+\n+        // Setup locations (plant Ids) local cache\n+        locationCache = new ExpiringCache<>(Duration.ofMinutes(config.getStatusRefreshPeriod()), this::getLocationList);\n+        bridgeStatus = new BridgeStatus();\n+\n+        schedulePoll();\n+\n+        logger.debug(\"Bridge[{}] Finished initializing!\", thing.getUID());\n+    }\n+\n+    private void updateNotifications(List<Subscription> subscriptions) {\n+        // Get the notifications list from bridge config\n+        List<String> notifications = config.getNotifications();\n+\n+        for (Subscription s : subscriptions) {\n+            if (s.getEndpointUrl().equalsIgnoreCase(config.getNotificationUrl())\n+                    && !notifications.contains(s.getSubscriptionId())) {\n+                // Add the external subscription to notifications list\n+                notifications = config.addNotification(s.getSubscriptionId());\n+\n+                // Save the updated notifications list back to bridge config\n+                Configuration configuration = editConfiguration();\n+                configuration.put(PROPERTY_NOTIFICATIONS, notifications);\n+                updateConfiguration(configuration);\n+            }\n+        }\n+    }\n+\n+    private List<Location> getLocationList() {\n+        // Retrieve the plants list from the API Gateway\n+        final List<Plant> plants = listPlants();\n+\n+        List<Location> locations;\n+        if (config.isUseNotifications()) {\n+            // Retrieve the subscriptions list from the API Gateway\n+            final List<Subscription> subscriptions = getSubscriptionList();\n+\n+            // Enrich the notifications list with externally registered subscriptions\n+            updateNotifications(subscriptions);\n+\n+            // Get the notifications list from bridge config\n+            final List<String> notifications = config.getNotifications();\n+\n+            locations = plants.stream().map(p -> Location.fromPlant(p, subscriptions.stream()\n+                    .filter(s -> s.getPlantId().equals(p.getId()) && notifications.contains(s.getSubscriptionId()))\n+                    .findFirst())).collect(Collectors.toList());\n+        } else {\n+            locations = plants.stream().map(p -> Location.fromPlant(p)).collect(Collectors.toList());\n+        }\n+        logger.debug(\"Bridge[{}] Available locations: {}\", thing.getUID(), locations);\n+\n+        return locations;\n+    }\n+\n+    @Override\n+    public void handleRemoval() {\n+        super.handleRemoval();\n+        stopPoll(true);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Bridge[{}] Dispose handler\", thing.getUID());\n+        if (oAuthService != null) {\n+            oAuthService.removeAccessTokenRefreshListener(this);\n+        }\n+        oAuthFactory.ungetOAuthService(thing.getUID().getAsString());\n+        stopPoll(true);\n+        logger.debug(\"Bridge[{}] Finished disposing!\", thing.getUID());\n+    }\n+\n+    /**\n+     * This method initiates a new thread for polling the available Smarther plants and update the plants\n+     * information.\n+     */\n+    private void schedulePoll() {\n+        stopPoll(false);\n+        // Schedule poll to start after POLL_INITIAL_DELAY sec and run periodically based on status refresh period\n+        pollFuture = scheduler.scheduleWithFixedDelay(this::poll, POLL_INITIAL_DELAY,\n+                config.getStatusRefreshPeriod() * 60, TimeUnit.SECONDS);\n+        logger.debug(\"Bridge[{}] Scheduled poll for {} sec out, then every {} min\", thing.getUID(), POLL_INITIAL_DELAY,\n+                config.getStatusRefreshPeriod());\n+    }\n+\n+    /**\n+     * Cancels all running schedulers.\n+     *\n+     * @param mayInterruptIfRunning true if the thread executing this task should be interrupted; otherwise, in-progress\n+     *            tasks are allowed to complete.\n+     */\n+    private synchronized void stopPoll(boolean mayInterruptIfRunning) {\n+        if (pollFuture != null && !pollFuture.isCancelled()) {\n+            pollFuture.cancel(mayInterruptIfRunning);\n+            pollFuture = null;\n+        }\n+    }\n+\n+    /**\n+     * Calls the Smarther API and collects plant data. Returns true if method completed without errors.\n+     *\n+     * @return true if method completed without errors.\n+     */\n+    private synchronized boolean poll() {\n+        try {\n+            onAccessTokenResponse(getAccessTokenResponse());\n+\n+            expireCache();\n+            listLocations();\n+\n+            updateStatus(ThingStatus.ONLINE);\n+            return true;\n+        } catch (SmartherAuthorizationException e) {\n+            logger.warn(\"Bridge[{}] Authorization error during polling: {}\", thing.getUID(), e.getMessage());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+            schedulePoll();\n+            return false;\n+        } catch (SmartherGatewayException e) {\n+            logger.warn(\"Bridge[{}] API Gateway error during polling: {}\", thing.getUID(), e.getMessage());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            schedulePoll();\n+            return false;\n+        } catch (RuntimeException e) {\n+            // All other exceptions apart from Authorization and Gateway issues\n+            logger.warn(\"Bridge[{}] Unexpected error during polling, please report if this keeps occurring: \",\n+                    thing.getUID(), e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, e.getMessage());\n+            schedulePoll();\n+            return false;\n+        }\n+    }\n+\n+    private void expireCache() {\n+        logger.debug(\"Bridge[{}] Invalidating location cache\", thing.getUID());\n+        locationCache.invalidateValue();\n+    }\n+\n+    public SmartherBridgeConfiguration getSmartherBridgeConfig() {\n+        return config;\n+    }\n+\n+    private @Nullable AccessTokenResponse getAccessTokenResponse() {\n+        try {\n+            return (oAuthService == null) ? null : oAuthService.getAccessTokenResponse();\n+        } catch (OAuthException | IOException | OAuthResponseException | RuntimeException e) {\n+            throw new SmartherAuthorizationException(e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    public void onAccessTokenResponse(@Nullable AccessTokenResponse tokenResponse) {\n+        updateChannelState(CHANNEL_ACCESS_TOKEN,\n+                new StringType((tokenResponse == null) ? null : tokenResponse.getAccessToken()));\n+    }\n+\n+    /**\n+     * Convenience method to update the channel state but only if the channel is linked.\n+     *\n+     * @param channelId id of the channel to update\n+     * @param state State to set on the channel\n+     */\n+    private void updateChannelState(String channelId, State state) {\n+        final Channel channel = thing.getChannel(channelId);\n+\n+        if (channel != null && isLinked(channel.getUID())) {\n+            updateState(channel.getUID(), state);\n+        }\n+    }\n+\n+    /**\n+     * Convenience method to update the api calls counter of local bridge status.\n+     */\n+    private void updateApiCallsCounter() {\n+        updateChannelState(CHANNEL_API_CALLS_HANDLED, new DecimalType(bridgeStatus.incrementApiCallsHandled()));\n+    }\n+\n+    // ===========================================================================\n+    //\n+    // Implementation of SmartherAccountHandler interface\n+    //\n+    // ===========================================================================\n+\n+    @Override\n+    public ThingUID getUID() {\n+        return thing.getUID();\n+    }\n+\n+    @Override\n+    public String getLabel() {\n+        return StringUtils.defaultString(thing.getLabel());\n+    }\n+\n+    @Override\n+    public List<Location> listLocations() {\n+        final List<Location> locations = locationCache.getValue();\n+        return (locations == null) ? Collections.emptyList() : locations;\n+    }\n+\n+    @Override\n+    public boolean hasLocation(String plantId) {\n+        final List<Location> locations = locationCache.getValue();\n+        return (locations == null) ? false : locations.stream().anyMatch(l -> l.getPlantId().equals(plantId));\n+    }\n+\n+    @Override\n+    public List<Plant> listPlants() {\n+        updateApiCallsCounter();\n+        return smartherApi.getPlantList();\n+    }\n+\n+    @Override\n+    public List<Subscription> getSubscriptionList() {\n+        updateApiCallsCounter();\n+        return smartherApi.getSubscriptionList();\n+    }\n+\n+    @Override\n+    public String addSubscription(String plantId, String notificationUrl) {\n+        updateApiCallsCounter();\n+        return smartherApi.subscribe(plantId, notificationUrl);\n+    }\n+\n+    @Override\n+    public void removeSubscription(String plantId, String subscriptionId) {\n+        updateApiCallsCounter();\n+        smartherApi.unsubscribe(plantId, subscriptionId);\n+    }\n+\n+    @Override\n+    public List<Module> listModules(Location location) {\n+        updateApiCallsCounter();\n+        return smartherApi.getTopology(location.getPlantId());\n+    }\n+\n+    @Override\n+    public ModuleStatus getModuleStatus(String plantId, String moduleId) {\n+        updateApiCallsCounter();\n+        return smartherApi.getModuleStatus(plantId, moduleId);\n+    }\n+\n+    @Override\n+    public boolean setModuleStatus(ModuleSettings moduleSettings) {\n+        updateApiCallsCounter();\n+        return smartherApi.setModuleStatus(moduleSettings);\n+    }\n+\n+    @Override\n+    public List<Program> getModuleProgramList(String plantId, String moduleId) {\n+        updateApiCallsCounter();\n+        return smartherApi.getProgramList(plantId, moduleId);\n+    }\n+\n+    @Override\n+    public boolean isAuthorized() {\n+        try {\n+            final AccessTokenResponse accessTokenResponse = getAccessTokenResponse();\n+\n+            return (accessTokenResponse != null && accessTokenResponse.getAccessToken() != null\n+                    && accessTokenResponse.getRefreshToken() != null);\n+        } catch (SmartherAuthorizationException e) {\n+            return false;\n+        }\n+    }\n+\n+    @Override\n+    public boolean isOnline() {\n+        return (thing.getStatus() == ThingStatus.ONLINE);\n+    }\n+\n+    @Override\n+    public String authorize(String redirectUrl, String reqCode, String notificationUrl) {\n+        try {\n+            logger.debug(\"Bridge[{}] Call API gateway to get access token. RedirectUri: {}\", thing.getUID(),\n+                    redirectUrl);\n+\n+            // OAuth2 call to get access token from received authorization code\n+            oAuthService.getAccessTokenResponseByAuthorizationCode(reqCode, redirectUrl);\n+\n+            // Store the notification URL in bridge configuration\n+            Configuration configuration = editConfiguration();\n+            configuration.put(PROPERTY_NOTIFICATION_URL, notificationUrl);\n+            updateConfiguration(configuration);\n+            config.setNotificationUrl(notificationUrl);\n+            logger.debug(\"Bridge[{}] Store notification URL: {}\", thing.getUID(), notificationUrl);\n+\n+            // Reschedule the polling thread\n+            schedulePoll();\n+\n+            return config.getClientId();\n+        } catch (RuntimeException | OAuthException | IOException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19cf0c876eff6c53b1c2f4864ae682e3d33fb7a3"}, "originalPosition": 466}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUzMTQ2NQ==", "bodyText": "Logging stacktrace", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429531465", "createdAt": "2020-05-23T09:39:09Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/handler/SmartherBridgeHandler.java", "diffHunk": "@@ -0,0 +1,629 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.handler;\n+\n+import static org.openhab.binding.smarther.internal.SmartherBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.net.InetAddress;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.UnknownHostException;\n+import java.time.Duration;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.auth.client.oauth2.AccessTokenRefreshListener;\n+import org.eclipse.smarthome.core.auth.client.oauth2.AccessTokenResponse;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthClientService;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthException;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthFactory;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthResponseException;\n+import org.eclipse.smarthome.core.cache.ExpiringCache;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.smarther.internal.account.SmartherAccountHandler;\n+import org.openhab.binding.smarther.internal.account.SmartherNotificationHandler;\n+import org.openhab.binding.smarther.internal.api.SmartherApi;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherAuthorizationException;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherGatewayException;\n+import org.openhab.binding.smarther.internal.api.model.Location;\n+import org.openhab.binding.smarther.internal.api.model.Module;\n+import org.openhab.binding.smarther.internal.api.model.ModuleSettings;\n+import org.openhab.binding.smarther.internal.api.model.ModuleStatus;\n+import org.openhab.binding.smarther.internal.api.model.Notification;\n+import org.openhab.binding.smarther.internal.api.model.Plant;\n+import org.openhab.binding.smarther.internal.api.model.Program;\n+import org.openhab.binding.smarther.internal.api.model.Subscription;\n+import org.openhab.binding.smarther.internal.config.SmartherBridgeConfiguration;\n+import org.openhab.binding.smarther.internal.discovery.SmartherModuleDiscoveryService;\n+import org.openhab.binding.smarther.internal.model.BridgeStatus;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SmartherBridgeHandler} is responsible for accessing the BTicino/Legrand Smarther API gateway.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmartherBridgeHandler extends BaseBridgeHandler\n+        implements SmartherAccountHandler, SmartherNotificationHandler, AccessTokenRefreshListener {\n+\n+    private static final long POLL_INITIAL_DELAY = 5;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private final OAuthFactory oAuthFactory;\n+    private final HttpClient httpClient;\n+\n+    // Field members assigned in initialize method\n+    private @NonNullByDefault({}) Future<?> pollFuture;\n+    private @NonNullByDefault({}) OAuthClientService oAuthService;\n+    private @NonNullByDefault({}) SmartherApi smartherApi;\n+    private @NonNullByDefault({}) SmartherBridgeConfiguration config;\n+\n+    // Bridge local status\n+    private @NonNullByDefault({}) ExpiringCache<List<Location>> locationCache;\n+    private @NonNullByDefault({}) BridgeStatus bridgeStatus;\n+\n+    public SmartherBridgeHandler(Bridge bridge, OAuthFactory oAuthFactory, HttpClient httpClient) {\n+        super(bridge);\n+        this.oAuthFactory = oAuthFactory;\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(SmartherModuleDiscoveryService.class);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        switch (channelUID.getId()) {\n+            case CHANNEL_ACCESS_TOKEN:\n+                if (command instanceof RefreshType) {\n+                    onAccessTokenResponse(getAccessTokenResponse());\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_FETCH_CONFIG:\n+                if (command instanceof OnOffType) {\n+                    if (OnOffType.ON.equals(command)) {\n+                        logger.debug(\"Bridge[{}] Manually triggered channel to refresh the Bridge config\",\n+                                thing.getUID());\n+                        schedulePoll();\n+                        updateChannelState(CHANNEL_FETCH_CONFIG, OnOffType.OFF);\n+                    }\n+                    return;\n+                }\n+                break;\n+        }\n+\n+        if (command instanceof RefreshType) {\n+            // Avoid logging wrong command when refresh command is sent\n+            return;\n+        }\n+\n+        logger.debug(\"Bridge[{}] Received command {} of wrong type {} on channel {}\", thing.getUID(), command,\n+                command.getClass().getTypeName(), channelUID.getId());\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Bridge[{}] Initialize handler\", thing.getUID());\n+\n+        config = getConfigAs(SmartherBridgeConfiguration.class);\n+        if (StringUtils.isBlank(config.getSubscriptionKey())) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Subscription Key' property is not set or empty. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+        if (StringUtils.isBlank(config.getClientId())) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Client Id' property is not set or empty. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+        if (StringUtils.isBlank(config.getClientSecret())) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Client Secret' property is not set or empty. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+        if (config.getStatusRefreshPeriod() <= 0) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Bridge Status Refresh Period' must be > 0. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        // Initialize OAuth2 authentication support\n+        oAuthService = oAuthFactory.createOAuthClientService(thing.getUID().getAsString(), SMARTHER_API_TOKEN_URL,\n+                SMARTHER_AUTHORIZE_URL, config.getClientId(), config.getClientSecret(), SMARTHER_API_SCOPES, false);\n+        oAuthService.addAccessTokenRefreshListener(SmartherBridgeHandler.this);\n+        smartherApi = new SmartherApi(config.getSubscriptionKey(), oAuthService, scheduler, httpClient);\n+\n+        // Setup locations (plant Ids) local cache\n+        locationCache = new ExpiringCache<>(Duration.ofMinutes(config.getStatusRefreshPeriod()), this::getLocationList);\n+        bridgeStatus = new BridgeStatus();\n+\n+        schedulePoll();\n+\n+        logger.debug(\"Bridge[{}] Finished initializing!\", thing.getUID());\n+    }\n+\n+    private void updateNotifications(List<Subscription> subscriptions) {\n+        // Get the notifications list from bridge config\n+        List<String> notifications = config.getNotifications();\n+\n+        for (Subscription s : subscriptions) {\n+            if (s.getEndpointUrl().equalsIgnoreCase(config.getNotificationUrl())\n+                    && !notifications.contains(s.getSubscriptionId())) {\n+                // Add the external subscription to notifications list\n+                notifications = config.addNotification(s.getSubscriptionId());\n+\n+                // Save the updated notifications list back to bridge config\n+                Configuration configuration = editConfiguration();\n+                configuration.put(PROPERTY_NOTIFICATIONS, notifications);\n+                updateConfiguration(configuration);\n+            }\n+        }\n+    }\n+\n+    private List<Location> getLocationList() {\n+        // Retrieve the plants list from the API Gateway\n+        final List<Plant> plants = listPlants();\n+\n+        List<Location> locations;\n+        if (config.isUseNotifications()) {\n+            // Retrieve the subscriptions list from the API Gateway\n+            final List<Subscription> subscriptions = getSubscriptionList();\n+\n+            // Enrich the notifications list with externally registered subscriptions\n+            updateNotifications(subscriptions);\n+\n+            // Get the notifications list from bridge config\n+            final List<String> notifications = config.getNotifications();\n+\n+            locations = plants.stream().map(p -> Location.fromPlant(p, subscriptions.stream()\n+                    .filter(s -> s.getPlantId().equals(p.getId()) && notifications.contains(s.getSubscriptionId()))\n+                    .findFirst())).collect(Collectors.toList());\n+        } else {\n+            locations = plants.stream().map(p -> Location.fromPlant(p)).collect(Collectors.toList());\n+        }\n+        logger.debug(\"Bridge[{}] Available locations: {}\", thing.getUID(), locations);\n+\n+        return locations;\n+    }\n+\n+    @Override\n+    public void handleRemoval() {\n+        super.handleRemoval();\n+        stopPoll(true);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Bridge[{}] Dispose handler\", thing.getUID());\n+        if (oAuthService != null) {\n+            oAuthService.removeAccessTokenRefreshListener(this);\n+        }\n+        oAuthFactory.ungetOAuthService(thing.getUID().getAsString());\n+        stopPoll(true);\n+        logger.debug(\"Bridge[{}] Finished disposing!\", thing.getUID());\n+    }\n+\n+    /**\n+     * This method initiates a new thread for polling the available Smarther plants and update the plants\n+     * information.\n+     */\n+    private void schedulePoll() {\n+        stopPoll(false);\n+        // Schedule poll to start after POLL_INITIAL_DELAY sec and run periodically based on status refresh period\n+        pollFuture = scheduler.scheduleWithFixedDelay(this::poll, POLL_INITIAL_DELAY,\n+                config.getStatusRefreshPeriod() * 60, TimeUnit.SECONDS);\n+        logger.debug(\"Bridge[{}] Scheduled poll for {} sec out, then every {} min\", thing.getUID(), POLL_INITIAL_DELAY,\n+                config.getStatusRefreshPeriod());\n+    }\n+\n+    /**\n+     * Cancels all running schedulers.\n+     *\n+     * @param mayInterruptIfRunning true if the thread executing this task should be interrupted; otherwise, in-progress\n+     *            tasks are allowed to complete.\n+     */\n+    private synchronized void stopPoll(boolean mayInterruptIfRunning) {\n+        if (pollFuture != null && !pollFuture.isCancelled()) {\n+            pollFuture.cancel(mayInterruptIfRunning);\n+            pollFuture = null;\n+        }\n+    }\n+\n+    /**\n+     * Calls the Smarther API and collects plant data. Returns true if method completed without errors.\n+     *\n+     * @return true if method completed without errors.\n+     */\n+    private synchronized boolean poll() {\n+        try {\n+            onAccessTokenResponse(getAccessTokenResponse());\n+\n+            expireCache();\n+            listLocations();\n+\n+            updateStatus(ThingStatus.ONLINE);\n+            return true;\n+        } catch (SmartherAuthorizationException e) {\n+            logger.warn(\"Bridge[{}] Authorization error during polling: {}\", thing.getUID(), e.getMessage());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+            schedulePoll();\n+            return false;\n+        } catch (SmartherGatewayException e) {\n+            logger.warn(\"Bridge[{}] API Gateway error during polling: {}\", thing.getUID(), e.getMessage());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            schedulePoll();\n+            return false;\n+        } catch (RuntimeException e) {\n+            // All other exceptions apart from Authorization and Gateway issues\n+            logger.warn(\"Bridge[{}] Unexpected error during polling, please report if this keeps occurring: \",\n+                    thing.getUID(), e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, e.getMessage());\n+            schedulePoll();\n+            return false;\n+        }\n+    }\n+\n+    private void expireCache() {\n+        logger.debug(\"Bridge[{}] Invalidating location cache\", thing.getUID());\n+        locationCache.invalidateValue();\n+    }\n+\n+    public SmartherBridgeConfiguration getSmartherBridgeConfig() {\n+        return config;\n+    }\n+\n+    private @Nullable AccessTokenResponse getAccessTokenResponse() {\n+        try {\n+            return (oAuthService == null) ? null : oAuthService.getAccessTokenResponse();\n+        } catch (OAuthException | IOException | OAuthResponseException | RuntimeException e) {\n+            throw new SmartherAuthorizationException(e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    public void onAccessTokenResponse(@Nullable AccessTokenResponse tokenResponse) {\n+        updateChannelState(CHANNEL_ACCESS_TOKEN,\n+                new StringType((tokenResponse == null) ? null : tokenResponse.getAccessToken()));\n+    }\n+\n+    /**\n+     * Convenience method to update the channel state but only if the channel is linked.\n+     *\n+     * @param channelId id of the channel to update\n+     * @param state State to set on the channel\n+     */\n+    private void updateChannelState(String channelId, State state) {\n+        final Channel channel = thing.getChannel(channelId);\n+\n+        if (channel != null && isLinked(channel.getUID())) {\n+            updateState(channel.getUID(), state);\n+        }\n+    }\n+\n+    /**\n+     * Convenience method to update the api calls counter of local bridge status.\n+     */\n+    private void updateApiCallsCounter() {\n+        updateChannelState(CHANNEL_API_CALLS_HANDLED, new DecimalType(bridgeStatus.incrementApiCallsHandled()));\n+    }\n+\n+    // ===========================================================================\n+    //\n+    // Implementation of SmartherAccountHandler interface\n+    //\n+    // ===========================================================================\n+\n+    @Override\n+    public ThingUID getUID() {\n+        return thing.getUID();\n+    }\n+\n+    @Override\n+    public String getLabel() {\n+        return StringUtils.defaultString(thing.getLabel());\n+    }\n+\n+    @Override\n+    public List<Location> listLocations() {\n+        final List<Location> locations = locationCache.getValue();\n+        return (locations == null) ? Collections.emptyList() : locations;\n+    }\n+\n+    @Override\n+    public boolean hasLocation(String plantId) {\n+        final List<Location> locations = locationCache.getValue();\n+        return (locations == null) ? false : locations.stream().anyMatch(l -> l.getPlantId().equals(plantId));\n+    }\n+\n+    @Override\n+    public List<Plant> listPlants() {\n+        updateApiCallsCounter();\n+        return smartherApi.getPlantList();\n+    }\n+\n+    @Override\n+    public List<Subscription> getSubscriptionList() {\n+        updateApiCallsCounter();\n+        return smartherApi.getSubscriptionList();\n+    }\n+\n+    @Override\n+    public String addSubscription(String plantId, String notificationUrl) {\n+        updateApiCallsCounter();\n+        return smartherApi.subscribe(plantId, notificationUrl);\n+    }\n+\n+    @Override\n+    public void removeSubscription(String plantId, String subscriptionId) {\n+        updateApiCallsCounter();\n+        smartherApi.unsubscribe(plantId, subscriptionId);\n+    }\n+\n+    @Override\n+    public List<Module> listModules(Location location) {\n+        updateApiCallsCounter();\n+        return smartherApi.getTopology(location.getPlantId());\n+    }\n+\n+    @Override\n+    public ModuleStatus getModuleStatus(String plantId, String moduleId) {\n+        updateApiCallsCounter();\n+        return smartherApi.getModuleStatus(plantId, moduleId);\n+    }\n+\n+    @Override\n+    public boolean setModuleStatus(ModuleSettings moduleSettings) {\n+        updateApiCallsCounter();\n+        return smartherApi.setModuleStatus(moduleSettings);\n+    }\n+\n+    @Override\n+    public List<Program> getModuleProgramList(String plantId, String moduleId) {\n+        updateApiCallsCounter();\n+        return smartherApi.getProgramList(plantId, moduleId);\n+    }\n+\n+    @Override\n+    public boolean isAuthorized() {\n+        try {\n+            final AccessTokenResponse accessTokenResponse = getAccessTokenResponse();\n+\n+            return (accessTokenResponse != null && accessTokenResponse.getAccessToken() != null\n+                    && accessTokenResponse.getRefreshToken() != null);\n+        } catch (SmartherAuthorizationException e) {\n+            return false;\n+        }\n+    }\n+\n+    @Override\n+    public boolean isOnline() {\n+        return (thing.getStatus() == ThingStatus.ONLINE);\n+    }\n+\n+    @Override\n+    public String authorize(String redirectUrl, String reqCode, String notificationUrl) {\n+        try {\n+            logger.debug(\"Bridge[{}] Call API gateway to get access token. RedirectUri: {}\", thing.getUID(),\n+                    redirectUrl);\n+\n+            // OAuth2 call to get access token from received authorization code\n+            oAuthService.getAccessTokenResponseByAuthorizationCode(reqCode, redirectUrl);\n+\n+            // Store the notification URL in bridge configuration\n+            Configuration configuration = editConfiguration();\n+            configuration.put(PROPERTY_NOTIFICATION_URL, notificationUrl);\n+            updateConfiguration(configuration);\n+            config.setNotificationUrl(notificationUrl);\n+            logger.debug(\"Bridge[{}] Store notification URL: {}\", thing.getUID(), notificationUrl);\n+\n+            // Reschedule the polling thread\n+            schedulePoll();\n+\n+            return config.getClientId();\n+        } catch (RuntimeException | OAuthException | IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+            throw new SmartherGatewayException(e.getMessage(), e);\n+        } catch (OAuthResponseException e) {\n+            throw new SmartherAuthorizationException(e.toString(), e);\n+        }\n+    }\n+\n+    @Override\n+    public boolean equalsThingUID(String thingUID) {\n+        return thing.getUID().getAsString().equals(thingUID);\n+    }\n+\n+    @Override\n+    public String formatAuthorizationUrl(String redirectUri) {\n+        try {\n+            return oAuthService.getAuthorizationUrl(redirectUri, null, thing.getUID().getAsString());\n+        } catch (OAuthException e) {\n+            logger.warn(\"Bridge[{}] Error constructing AuthorizationUrl: \", thing.getUID(), e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19cf0c876eff6c53b1c2f4864ae682e3d33fb7a3"}, "originalPosition": 484}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUzMTczMg==", "bodyText": "Minor improvement:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (config.isUseNotifications() && maybeModuleHandler.isPresent()) {\n          \n          \n            \n                        maybeModuleHandler.get().handleNotification(notification);\n          \n          \n            \n                    if (config.isUseNotifications()) {\n          \n          \n            \n                        maybeModuleHandler.ifPresent(h -> h.handleNotification(notification));", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429531732", "createdAt": "2020-05-23T09:43:43Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/handler/SmartherBridgeHandler.java", "diffHunk": "@@ -0,0 +1,629 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.handler;\n+\n+import static org.openhab.binding.smarther.internal.SmartherBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.net.InetAddress;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.UnknownHostException;\n+import java.time.Duration;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.auth.client.oauth2.AccessTokenRefreshListener;\n+import org.eclipse.smarthome.core.auth.client.oauth2.AccessTokenResponse;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthClientService;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthException;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthFactory;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthResponseException;\n+import org.eclipse.smarthome.core.cache.ExpiringCache;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.smarther.internal.account.SmartherAccountHandler;\n+import org.openhab.binding.smarther.internal.account.SmartherNotificationHandler;\n+import org.openhab.binding.smarther.internal.api.SmartherApi;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherAuthorizationException;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherGatewayException;\n+import org.openhab.binding.smarther.internal.api.model.Location;\n+import org.openhab.binding.smarther.internal.api.model.Module;\n+import org.openhab.binding.smarther.internal.api.model.ModuleSettings;\n+import org.openhab.binding.smarther.internal.api.model.ModuleStatus;\n+import org.openhab.binding.smarther.internal.api.model.Notification;\n+import org.openhab.binding.smarther.internal.api.model.Plant;\n+import org.openhab.binding.smarther.internal.api.model.Program;\n+import org.openhab.binding.smarther.internal.api.model.Subscription;\n+import org.openhab.binding.smarther.internal.config.SmartherBridgeConfiguration;\n+import org.openhab.binding.smarther.internal.discovery.SmartherModuleDiscoveryService;\n+import org.openhab.binding.smarther.internal.model.BridgeStatus;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SmartherBridgeHandler} is responsible for accessing the BTicino/Legrand Smarther API gateway.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmartherBridgeHandler extends BaseBridgeHandler\n+        implements SmartherAccountHandler, SmartherNotificationHandler, AccessTokenRefreshListener {\n+\n+    private static final long POLL_INITIAL_DELAY = 5;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private final OAuthFactory oAuthFactory;\n+    private final HttpClient httpClient;\n+\n+    // Field members assigned in initialize method\n+    private @NonNullByDefault({}) Future<?> pollFuture;\n+    private @NonNullByDefault({}) OAuthClientService oAuthService;\n+    private @NonNullByDefault({}) SmartherApi smartherApi;\n+    private @NonNullByDefault({}) SmartherBridgeConfiguration config;\n+\n+    // Bridge local status\n+    private @NonNullByDefault({}) ExpiringCache<List<Location>> locationCache;\n+    private @NonNullByDefault({}) BridgeStatus bridgeStatus;\n+\n+    public SmartherBridgeHandler(Bridge bridge, OAuthFactory oAuthFactory, HttpClient httpClient) {\n+        super(bridge);\n+        this.oAuthFactory = oAuthFactory;\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(SmartherModuleDiscoveryService.class);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        switch (channelUID.getId()) {\n+            case CHANNEL_ACCESS_TOKEN:\n+                if (command instanceof RefreshType) {\n+                    onAccessTokenResponse(getAccessTokenResponse());\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_FETCH_CONFIG:\n+                if (command instanceof OnOffType) {\n+                    if (OnOffType.ON.equals(command)) {\n+                        logger.debug(\"Bridge[{}] Manually triggered channel to refresh the Bridge config\",\n+                                thing.getUID());\n+                        schedulePoll();\n+                        updateChannelState(CHANNEL_FETCH_CONFIG, OnOffType.OFF);\n+                    }\n+                    return;\n+                }\n+                break;\n+        }\n+\n+        if (command instanceof RefreshType) {\n+            // Avoid logging wrong command when refresh command is sent\n+            return;\n+        }\n+\n+        logger.debug(\"Bridge[{}] Received command {} of wrong type {} on channel {}\", thing.getUID(), command,\n+                command.getClass().getTypeName(), channelUID.getId());\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Bridge[{}] Initialize handler\", thing.getUID());\n+\n+        config = getConfigAs(SmartherBridgeConfiguration.class);\n+        if (StringUtils.isBlank(config.getSubscriptionKey())) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Subscription Key' property is not set or empty. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+        if (StringUtils.isBlank(config.getClientId())) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Client Id' property is not set or empty. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+        if (StringUtils.isBlank(config.getClientSecret())) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Client Secret' property is not set or empty. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+        if (config.getStatusRefreshPeriod() <= 0) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Bridge Status Refresh Period' must be > 0. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        // Initialize OAuth2 authentication support\n+        oAuthService = oAuthFactory.createOAuthClientService(thing.getUID().getAsString(), SMARTHER_API_TOKEN_URL,\n+                SMARTHER_AUTHORIZE_URL, config.getClientId(), config.getClientSecret(), SMARTHER_API_SCOPES, false);\n+        oAuthService.addAccessTokenRefreshListener(SmartherBridgeHandler.this);\n+        smartherApi = new SmartherApi(config.getSubscriptionKey(), oAuthService, scheduler, httpClient);\n+\n+        // Setup locations (plant Ids) local cache\n+        locationCache = new ExpiringCache<>(Duration.ofMinutes(config.getStatusRefreshPeriod()), this::getLocationList);\n+        bridgeStatus = new BridgeStatus();\n+\n+        schedulePoll();\n+\n+        logger.debug(\"Bridge[{}] Finished initializing!\", thing.getUID());\n+    }\n+\n+    private void updateNotifications(List<Subscription> subscriptions) {\n+        // Get the notifications list from bridge config\n+        List<String> notifications = config.getNotifications();\n+\n+        for (Subscription s : subscriptions) {\n+            if (s.getEndpointUrl().equalsIgnoreCase(config.getNotificationUrl())\n+                    && !notifications.contains(s.getSubscriptionId())) {\n+                // Add the external subscription to notifications list\n+                notifications = config.addNotification(s.getSubscriptionId());\n+\n+                // Save the updated notifications list back to bridge config\n+                Configuration configuration = editConfiguration();\n+                configuration.put(PROPERTY_NOTIFICATIONS, notifications);\n+                updateConfiguration(configuration);\n+            }\n+        }\n+    }\n+\n+    private List<Location> getLocationList() {\n+        // Retrieve the plants list from the API Gateway\n+        final List<Plant> plants = listPlants();\n+\n+        List<Location> locations;\n+        if (config.isUseNotifications()) {\n+            // Retrieve the subscriptions list from the API Gateway\n+            final List<Subscription> subscriptions = getSubscriptionList();\n+\n+            // Enrich the notifications list with externally registered subscriptions\n+            updateNotifications(subscriptions);\n+\n+            // Get the notifications list from bridge config\n+            final List<String> notifications = config.getNotifications();\n+\n+            locations = plants.stream().map(p -> Location.fromPlant(p, subscriptions.stream()\n+                    .filter(s -> s.getPlantId().equals(p.getId()) && notifications.contains(s.getSubscriptionId()))\n+                    .findFirst())).collect(Collectors.toList());\n+        } else {\n+            locations = plants.stream().map(p -> Location.fromPlant(p)).collect(Collectors.toList());\n+        }\n+        logger.debug(\"Bridge[{}] Available locations: {}\", thing.getUID(), locations);\n+\n+        return locations;\n+    }\n+\n+    @Override\n+    public void handleRemoval() {\n+        super.handleRemoval();\n+        stopPoll(true);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Bridge[{}] Dispose handler\", thing.getUID());\n+        if (oAuthService != null) {\n+            oAuthService.removeAccessTokenRefreshListener(this);\n+        }\n+        oAuthFactory.ungetOAuthService(thing.getUID().getAsString());\n+        stopPoll(true);\n+        logger.debug(\"Bridge[{}] Finished disposing!\", thing.getUID());\n+    }\n+\n+    /**\n+     * This method initiates a new thread for polling the available Smarther plants and update the plants\n+     * information.\n+     */\n+    private void schedulePoll() {\n+        stopPoll(false);\n+        // Schedule poll to start after POLL_INITIAL_DELAY sec and run periodically based on status refresh period\n+        pollFuture = scheduler.scheduleWithFixedDelay(this::poll, POLL_INITIAL_DELAY,\n+                config.getStatusRefreshPeriod() * 60, TimeUnit.SECONDS);\n+        logger.debug(\"Bridge[{}] Scheduled poll for {} sec out, then every {} min\", thing.getUID(), POLL_INITIAL_DELAY,\n+                config.getStatusRefreshPeriod());\n+    }\n+\n+    /**\n+     * Cancels all running schedulers.\n+     *\n+     * @param mayInterruptIfRunning true if the thread executing this task should be interrupted; otherwise, in-progress\n+     *            tasks are allowed to complete.\n+     */\n+    private synchronized void stopPoll(boolean mayInterruptIfRunning) {\n+        if (pollFuture != null && !pollFuture.isCancelled()) {\n+            pollFuture.cancel(mayInterruptIfRunning);\n+            pollFuture = null;\n+        }\n+    }\n+\n+    /**\n+     * Calls the Smarther API and collects plant data. Returns true if method completed without errors.\n+     *\n+     * @return true if method completed without errors.\n+     */\n+    private synchronized boolean poll() {\n+        try {\n+            onAccessTokenResponse(getAccessTokenResponse());\n+\n+            expireCache();\n+            listLocations();\n+\n+            updateStatus(ThingStatus.ONLINE);\n+            return true;\n+        } catch (SmartherAuthorizationException e) {\n+            logger.warn(\"Bridge[{}] Authorization error during polling: {}\", thing.getUID(), e.getMessage());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+            schedulePoll();\n+            return false;\n+        } catch (SmartherGatewayException e) {\n+            logger.warn(\"Bridge[{}] API Gateway error during polling: {}\", thing.getUID(), e.getMessage());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            schedulePoll();\n+            return false;\n+        } catch (RuntimeException e) {\n+            // All other exceptions apart from Authorization and Gateway issues\n+            logger.warn(\"Bridge[{}] Unexpected error during polling, please report if this keeps occurring: \",\n+                    thing.getUID(), e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, e.getMessage());\n+            schedulePoll();\n+            return false;\n+        }\n+    }\n+\n+    private void expireCache() {\n+        logger.debug(\"Bridge[{}] Invalidating location cache\", thing.getUID());\n+        locationCache.invalidateValue();\n+    }\n+\n+    public SmartherBridgeConfiguration getSmartherBridgeConfig() {\n+        return config;\n+    }\n+\n+    private @Nullable AccessTokenResponse getAccessTokenResponse() {\n+        try {\n+            return (oAuthService == null) ? null : oAuthService.getAccessTokenResponse();\n+        } catch (OAuthException | IOException | OAuthResponseException | RuntimeException e) {\n+            throw new SmartherAuthorizationException(e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    public void onAccessTokenResponse(@Nullable AccessTokenResponse tokenResponse) {\n+        updateChannelState(CHANNEL_ACCESS_TOKEN,\n+                new StringType((tokenResponse == null) ? null : tokenResponse.getAccessToken()));\n+    }\n+\n+    /**\n+     * Convenience method to update the channel state but only if the channel is linked.\n+     *\n+     * @param channelId id of the channel to update\n+     * @param state State to set on the channel\n+     */\n+    private void updateChannelState(String channelId, State state) {\n+        final Channel channel = thing.getChannel(channelId);\n+\n+        if (channel != null && isLinked(channel.getUID())) {\n+            updateState(channel.getUID(), state);\n+        }\n+    }\n+\n+    /**\n+     * Convenience method to update the api calls counter of local bridge status.\n+     */\n+    private void updateApiCallsCounter() {\n+        updateChannelState(CHANNEL_API_CALLS_HANDLED, new DecimalType(bridgeStatus.incrementApiCallsHandled()));\n+    }\n+\n+    // ===========================================================================\n+    //\n+    // Implementation of SmartherAccountHandler interface\n+    //\n+    // ===========================================================================\n+\n+    @Override\n+    public ThingUID getUID() {\n+        return thing.getUID();\n+    }\n+\n+    @Override\n+    public String getLabel() {\n+        return StringUtils.defaultString(thing.getLabel());\n+    }\n+\n+    @Override\n+    public List<Location> listLocations() {\n+        final List<Location> locations = locationCache.getValue();\n+        return (locations == null) ? Collections.emptyList() : locations;\n+    }\n+\n+    @Override\n+    public boolean hasLocation(String plantId) {\n+        final List<Location> locations = locationCache.getValue();\n+        return (locations == null) ? false : locations.stream().anyMatch(l -> l.getPlantId().equals(plantId));\n+    }\n+\n+    @Override\n+    public List<Plant> listPlants() {\n+        updateApiCallsCounter();\n+        return smartherApi.getPlantList();\n+    }\n+\n+    @Override\n+    public List<Subscription> getSubscriptionList() {\n+        updateApiCallsCounter();\n+        return smartherApi.getSubscriptionList();\n+    }\n+\n+    @Override\n+    public String addSubscription(String plantId, String notificationUrl) {\n+        updateApiCallsCounter();\n+        return smartherApi.subscribe(plantId, notificationUrl);\n+    }\n+\n+    @Override\n+    public void removeSubscription(String plantId, String subscriptionId) {\n+        updateApiCallsCounter();\n+        smartherApi.unsubscribe(plantId, subscriptionId);\n+    }\n+\n+    @Override\n+    public List<Module> listModules(Location location) {\n+        updateApiCallsCounter();\n+        return smartherApi.getTopology(location.getPlantId());\n+    }\n+\n+    @Override\n+    public ModuleStatus getModuleStatus(String plantId, String moduleId) {\n+        updateApiCallsCounter();\n+        return smartherApi.getModuleStatus(plantId, moduleId);\n+    }\n+\n+    @Override\n+    public boolean setModuleStatus(ModuleSettings moduleSettings) {\n+        updateApiCallsCounter();\n+        return smartherApi.setModuleStatus(moduleSettings);\n+    }\n+\n+    @Override\n+    public List<Program> getModuleProgramList(String plantId, String moduleId) {\n+        updateApiCallsCounter();\n+        return smartherApi.getProgramList(plantId, moduleId);\n+    }\n+\n+    @Override\n+    public boolean isAuthorized() {\n+        try {\n+            final AccessTokenResponse accessTokenResponse = getAccessTokenResponse();\n+\n+            return (accessTokenResponse != null && accessTokenResponse.getAccessToken() != null\n+                    && accessTokenResponse.getRefreshToken() != null);\n+        } catch (SmartherAuthorizationException e) {\n+            return false;\n+        }\n+    }\n+\n+    @Override\n+    public boolean isOnline() {\n+        return (thing.getStatus() == ThingStatus.ONLINE);\n+    }\n+\n+    @Override\n+    public String authorize(String redirectUrl, String reqCode, String notificationUrl) {\n+        try {\n+            logger.debug(\"Bridge[{}] Call API gateway to get access token. RedirectUri: {}\", thing.getUID(),\n+                    redirectUrl);\n+\n+            // OAuth2 call to get access token from received authorization code\n+            oAuthService.getAccessTokenResponseByAuthorizationCode(reqCode, redirectUrl);\n+\n+            // Store the notification URL in bridge configuration\n+            Configuration configuration = editConfiguration();\n+            configuration.put(PROPERTY_NOTIFICATION_URL, notificationUrl);\n+            updateConfiguration(configuration);\n+            config.setNotificationUrl(notificationUrl);\n+            logger.debug(\"Bridge[{}] Store notification URL: {}\", thing.getUID(), notificationUrl);\n+\n+            // Reschedule the polling thread\n+            schedulePoll();\n+\n+            return config.getClientId();\n+        } catch (RuntimeException | OAuthException | IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+            throw new SmartherGatewayException(e.getMessage(), e);\n+        } catch (OAuthResponseException e) {\n+            throw new SmartherAuthorizationException(e.toString(), e);\n+        }\n+    }\n+\n+    @Override\n+    public boolean equalsThingUID(String thingUID) {\n+        return thing.getUID().getAsString().equals(thingUID);\n+    }\n+\n+    @Override\n+    public String formatAuthorizationUrl(String redirectUri) {\n+        try {\n+            return oAuthService.getAuthorizationUrl(redirectUri, null, thing.getUID().getAsString());\n+        } catch (OAuthException e) {\n+            logger.warn(\"Bridge[{}] Error constructing AuthorizationUrl: \", thing.getUID(), e);\n+            return \"\";\n+        }\n+    }\n+\n+    // ===========================================================================\n+    //\n+    // Implementation of SmartherNotificationHandler interface\n+    //\n+    // ===========================================================================\n+\n+    @Override\n+    public boolean useNotifications() {\n+        return config.isUseNotifications();\n+    }\n+\n+    @Override\n+    public synchronized void registerNotification(String plantId) {\n+        if (!config.isUseNotifications()) {\n+            return;\n+        }\n+\n+        List<Location> locations = locationCache.getValue();\n+        if (locations != null) {\n+            final Optional<Location> maybeLocation = locations.stream().filter(l -> l.getPlantId().equals(plantId))\n+                    .findFirst();\n+            if (maybeLocation.isPresent()) {\n+                Location location = maybeLocation.get();\n+                if (!location.hasSubscription()) {\n+                    // Validate notification Url (must be non-null and https)\n+                    final String notificationUrl = config.getNotificationUrl();\n+                    if (isValidNotificationUrl(notificationUrl)) {\n+                        // Call gateway to register plant subscription\n+                        String subscriptionId = addSubscription(plantId, config.getNotificationUrl());\n+                        logger.debug(\"Bridge[{}] Notification registered: [plantId={}, subscriptionId={}]\",\n+                                thing.getUID(), plantId, subscriptionId);\n+\n+                        // Add the new subscription to notifications list\n+                        List<String> notifications = config.addNotification(subscriptionId);\n+\n+                        // Save the updated notifications list back to bridge config\n+                        Configuration configuration = editConfiguration();\n+                        configuration.put(PROPERTY_NOTIFICATIONS, notifications);\n+                        updateConfiguration(configuration);\n+\n+                        // Update the local locationCache with the added data\n+                        locations.stream().forEach(l -> {\n+                            if (l.getPlantId().equals(plantId)) {\n+                                l.setSubscription(subscriptionId, config.getNotificationUrl());\n+                            }\n+                        });\n+                        locationCache.putValue(locations);\n+                    } else {\n+                        logger.warn(\"Bridge[{}] Invalid notification Url [{}]: must be non-null, public https address\",\n+                                thing.getUID(), notificationUrl);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void handleNotification(Notification notification) {\n+        logger.debug(\"Bridge[{}] Notification received: [id={}]\", thing.getUID(), notification.getId());\n+\n+        updateChannelState(CHANNEL_NOTIFS_RECEIVED, new DecimalType(bridgeStatus.incrementNotificationsReceived()));\n+\n+        final String plantId = notification.getData().toChronothermostat().getSender().getPlant().getId();\n+        final String moduleId = notification.getData().toChronothermostat().getSender().getPlant().getModule().getId();\n+\n+        Optional<SmartherModuleHandler> maybeModuleHandler = getThing().getThings().stream()\n+                .map(t -> (SmartherModuleHandler) t.getHandler()).filter(h -> h.isLinkedTo(plantId, moduleId))\n+                .findFirst();\n+\n+        if (config.isUseNotifications() && maybeModuleHandler.isPresent()) {\n+            maybeModuleHandler.get().handleNotification(notification);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19cf0c876eff6c53b1c2f4864ae682e3d33fb7a3"}, "originalPosition": 559}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUzMTk4MA==", "bodyText": "Joda", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429531980", "createdAt": "2020-05-23T09:48:00Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/handler/SmartherDynamicStateDescriptionProvider.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.handler;\n+\n+import static org.openhab.binding.smarther.internal.SmartherBindingConstants.DATE_FORMAT;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseDynamicStateDescriptionProvider;\n+import org.eclipse.smarthome.core.thing.type.DynamicStateDescriptionProvider;\n+import org.eclipse.smarthome.core.types.StateOption;\n+import org.joda.time.DateTime;\n+import org.openhab.binding.smarther.internal.api.model.Program;\n+import org.osgi.service.component.annotations.Component;\n+\n+/**\n+ * Dynamically create the users list of programs and setting dates.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@Component(service = { DynamicStateDescriptionProvider.class, SmartherDynamicStateDescriptionProvider.class })\n+@NonNullByDefault\n+public class SmartherDynamicStateDescriptionProvider extends BaseDynamicStateDescriptionProvider {\n+\n+    private static final String LABEL_FOREVER = \"Forever\";\n+    private static final String LABEL_TODAY = \"Today\";\n+    private static final String LABEL_TOMORROW = \"Tomorrow\";\n+\n+    public void setEndDates(ChannelUID channelUID, int maxEndDays) {\n+        List<StateOption> endDates = new ArrayList<StateOption>();\n+\n+        endDates.add(new StateOption(\"\", LABEL_FOREVER));\n+\n+        final DateTime today = DateTime.now().withTimeAtStartOfDay();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19cf0c876eff6c53b1c2f4864ae682e3d33fb7a3"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUzMzY4OQ==", "bodyText": "Are you sure the unit will be Temperature under all circumstances? You can use toUnit() to convert the QuantityType to a well known unit. It will return null if it cannot be converted.\nThen, you can skip the fahrenheit check, too.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    @SuppressWarnings(\"unchecked\")\n          \n          \n            \n                    QuantityType<Temperature> newMeasure = (QuantityType<Temperature>) command;\n          \n          \n            \n                    QuantityType<?> quantity = (QuantityType<?>) command;\n          \n          \n            \n                    QuantityType<?> newMeasure = quantity.toUnit(SIUnits.CELSIUS);", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429533689", "createdAt": "2020-05-23T10:15:59Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/handler/SmartherModuleHandler.java", "diffHunk": "@@ -0,0 +1,535 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.handler;\n+\n+import static org.openhab.binding.smarther.internal.SmartherBindingConstants.*;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.cache.ExpiringCache;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.ImperialUnits;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.scheduler.CronScheduler;\n+import org.eclipse.smarthome.core.scheduler.ScheduledCompletableFuture;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.joda.time.DateTime;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherGatewayException;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherSubscriptionAlreadyExistsException;\n+import org.openhab.binding.smarther.internal.api.model.Chronothermostat;\n+import org.openhab.binding.smarther.internal.api.model.Enums.BoostTime;\n+import org.openhab.binding.smarther.internal.api.model.Enums.Mode;\n+import org.openhab.binding.smarther.internal.api.model.ModuleSettings;\n+import org.openhab.binding.smarther.internal.api.model.ModuleStatus;\n+import org.openhab.binding.smarther.internal.api.model.Notification;\n+import org.openhab.binding.smarther.internal.api.model.Program;\n+import org.openhab.binding.smarther.internal.config.SmartherModuleConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SmartherModuleHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmartherModuleHandler extends BaseThingHandler {\n+\n+    private static final String DAILY_MIDNIGHT = \"1 0 0 * * ? *\";\n+    private static final long POLL_INITIAL_DELAY = 5;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private final CronScheduler cronScheduler;\n+    private final SmartherDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final ChannelUID programChannelUID;\n+    private final ChannelUID endDateChannelUID;\n+\n+    // Field members assigned in initialize method\n+    private @NonNullByDefault({}) ScheduledCompletableFuture<Void> jobFuture;\n+    private @NonNullByDefault({}) Future<?> pollFuture;\n+    private @NonNullByDefault({}) SmartherBridgeHandler bridgeHandler;\n+    private @NonNullByDefault({}) SmartherModuleConfiguration config;\n+\n+    // Chronothermostat local status\n+    private @NonNullByDefault({}) ExpiringCache<List<Program>> programCache;\n+    private @NonNullByDefault({}) Chronothermostat chronothermostat;\n+    private @NonNullByDefault({}) ModuleSettings moduleSettings;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param thing Thing representing this module.\n+     */\n+    public SmartherModuleHandler(Thing thing, CronScheduler scheduler,\n+            SmartherDynamicStateDescriptionProvider provider) {\n+        super(thing);\n+        this.cronScheduler = scheduler;\n+        this.dynamicStateDescriptionProvider = provider;\n+        this.programChannelUID = new ChannelUID(thing.getUID(), CHANNEL_SETTINGS_PROGRAM);\n+        this.endDateChannelUID = new ChannelUID(thing.getUID(), CHANNEL_SETTINGS_ENDDATE);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        try {\n+            handleCommandInternal(channelUID, command);\n+\n+            updateModuleStatus();\n+        } catch (SmartherGatewayException ex) {\n+            // catch exceptions and handle it in your binding\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, ex.getMessage());\n+        }\n+    }\n+\n+    private void handleCommandInternal(ChannelUID channelUID, Command command) throws SmartherGatewayException {\n+        switch (channelUID.getId()) {\n+            case CHANNEL_SETTINGS_MODE:\n+                if (command instanceof StringType) {\n+                    moduleSettings.setMode(Mode.fromValue(command.toString()));\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_TEMPERATURE:\n+                if (changeTemperature(command)) {\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_PROGRAM:\n+                if (command instanceof DecimalType) {\n+                    moduleSettings.setProgram(((DecimalType) command).intValue());\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_BOOSTTIME:\n+                if (command instanceof DecimalType) {\n+                    moduleSettings.setBoostTime(BoostTime.fromValue(((DecimalType) command).intValue()));\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_ENDDATE:\n+                if (command instanceof StringType) {\n+                    moduleSettings.setEndDate(command.toString());\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_ENDHOUR:\n+                if (changeTimeHour(command)) {\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_ENDMINUTE:\n+                if (changeTimeMinute(command)) {\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_POWER:\n+                if (command instanceof OnOffType) {\n+                    if (OnOffType.ON.equals(command)) {\n+                        // Send change to the remote module\n+                        applyModuleSettings();\n+                        updateChannelState(CHANNEL_SETTINGS_POWER, OnOffType.OFF);\n+                    }\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_FETCH_CONFIG:\n+                if (command instanceof OnOffType) {\n+                    if (OnOffType.ON.equals(command)) {\n+                        logger.debug(\"Module[{}] Manually triggered channel to refresh the Module config\",\n+                                thing.getUID());\n+                        programCache.invalidateValue();\n+                        programCache.getValue();\n+                        updateChannelState(CHANNEL_FETCH_CONFIG, OnOffType.OFF);\n+                    }\n+                    return;\n+                }\n+                break;\n+        }\n+\n+        if (command instanceof RefreshType) {\n+            // Avoid logging wrong command when refresh command is sent\n+            return;\n+        }\n+\n+        logger.debug(\"Module[{}] Received command {} of wrong type {} on channel {}\", thing.getUID(), command,\n+                command.getClass().getTypeName(), channelUID.getId());\n+    }\n+\n+    private void applyModuleSettings() {\n+        // Send change to the remote module\n+        if (bridgeHandler.setModuleStatus(moduleSettings)) {\n+            // Change applied, update module status\n+            logger.debug(\"Module[{}] New settings applied!\", thing.getUID());\n+        }\n+    }\n+\n+    private boolean changeTemperature(Command command) {\n+        if (!(command instanceof QuantityType)) {\n+            return false;\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        QuantityType<Temperature> newMeasure = (QuantityType<Temperature>) command;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19cf0c876eff6c53b1c2f4864ae682e3d33fb7a3"}, "originalPosition": 205}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUzNDAyMg==", "bodyText": "See above", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429534022", "createdAt": "2020-05-23T10:21:36Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/handler/SmartherModuleHandler.java", "diffHunk": "@@ -0,0 +1,535 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.handler;\n+\n+import static org.openhab.binding.smarther.internal.SmartherBindingConstants.*;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.cache.ExpiringCache;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.ImperialUnits;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.scheduler.CronScheduler;\n+import org.eclipse.smarthome.core.scheduler.ScheduledCompletableFuture;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.joda.time.DateTime;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherGatewayException;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherSubscriptionAlreadyExistsException;\n+import org.openhab.binding.smarther.internal.api.model.Chronothermostat;\n+import org.openhab.binding.smarther.internal.api.model.Enums.BoostTime;\n+import org.openhab.binding.smarther.internal.api.model.Enums.Mode;\n+import org.openhab.binding.smarther.internal.api.model.ModuleSettings;\n+import org.openhab.binding.smarther.internal.api.model.ModuleStatus;\n+import org.openhab.binding.smarther.internal.api.model.Notification;\n+import org.openhab.binding.smarther.internal.api.model.Program;\n+import org.openhab.binding.smarther.internal.config.SmartherModuleConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SmartherModuleHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmartherModuleHandler extends BaseThingHandler {\n+\n+    private static final String DAILY_MIDNIGHT = \"1 0 0 * * ? *\";\n+    private static final long POLL_INITIAL_DELAY = 5;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private final CronScheduler cronScheduler;\n+    private final SmartherDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final ChannelUID programChannelUID;\n+    private final ChannelUID endDateChannelUID;\n+\n+    // Field members assigned in initialize method\n+    private @NonNullByDefault({}) ScheduledCompletableFuture<Void> jobFuture;\n+    private @NonNullByDefault({}) Future<?> pollFuture;\n+    private @NonNullByDefault({}) SmartherBridgeHandler bridgeHandler;\n+    private @NonNullByDefault({}) SmartherModuleConfiguration config;\n+\n+    // Chronothermostat local status\n+    private @NonNullByDefault({}) ExpiringCache<List<Program>> programCache;\n+    private @NonNullByDefault({}) Chronothermostat chronothermostat;\n+    private @NonNullByDefault({}) ModuleSettings moduleSettings;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param thing Thing representing this module.\n+     */\n+    public SmartherModuleHandler(Thing thing, CronScheduler scheduler,\n+            SmartherDynamicStateDescriptionProvider provider) {\n+        super(thing);\n+        this.cronScheduler = scheduler;\n+        this.dynamicStateDescriptionProvider = provider;\n+        this.programChannelUID = new ChannelUID(thing.getUID(), CHANNEL_SETTINGS_PROGRAM);\n+        this.endDateChannelUID = new ChannelUID(thing.getUID(), CHANNEL_SETTINGS_ENDDATE);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        try {\n+            handleCommandInternal(channelUID, command);\n+\n+            updateModuleStatus();\n+        } catch (SmartherGatewayException ex) {\n+            // catch exceptions and handle it in your binding\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, ex.getMessage());\n+        }\n+    }\n+\n+    private void handleCommandInternal(ChannelUID channelUID, Command command) throws SmartherGatewayException {\n+        switch (channelUID.getId()) {\n+            case CHANNEL_SETTINGS_MODE:\n+                if (command instanceof StringType) {\n+                    moduleSettings.setMode(Mode.fromValue(command.toString()));\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_TEMPERATURE:\n+                if (changeTemperature(command)) {\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_PROGRAM:\n+                if (command instanceof DecimalType) {\n+                    moduleSettings.setProgram(((DecimalType) command).intValue());\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_BOOSTTIME:\n+                if (command instanceof DecimalType) {\n+                    moduleSettings.setBoostTime(BoostTime.fromValue(((DecimalType) command).intValue()));\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_ENDDATE:\n+                if (command instanceof StringType) {\n+                    moduleSettings.setEndDate(command.toString());\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_ENDHOUR:\n+                if (changeTimeHour(command)) {\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_ENDMINUTE:\n+                if (changeTimeMinute(command)) {\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_POWER:\n+                if (command instanceof OnOffType) {\n+                    if (OnOffType.ON.equals(command)) {\n+                        // Send change to the remote module\n+                        applyModuleSettings();\n+                        updateChannelState(CHANNEL_SETTINGS_POWER, OnOffType.OFF);\n+                    }\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_FETCH_CONFIG:\n+                if (command instanceof OnOffType) {\n+                    if (OnOffType.ON.equals(command)) {\n+                        logger.debug(\"Module[{}] Manually triggered channel to refresh the Module config\",\n+                                thing.getUID());\n+                        programCache.invalidateValue();\n+                        programCache.getValue();\n+                        updateChannelState(CHANNEL_FETCH_CONFIG, OnOffType.OFF);\n+                    }\n+                    return;\n+                }\n+                break;\n+        }\n+\n+        if (command instanceof RefreshType) {\n+            // Avoid logging wrong command when refresh command is sent\n+            return;\n+        }\n+\n+        logger.debug(\"Module[{}] Received command {} of wrong type {} on channel {}\", thing.getUID(), command,\n+                command.getClass().getTypeName(), channelUID.getId());\n+    }\n+\n+    private void applyModuleSettings() {\n+        // Send change to the remote module\n+        if (bridgeHandler.setModuleStatus(moduleSettings)) {\n+            // Change applied, update module status\n+            logger.debug(\"Module[{}] New settings applied!\", thing.getUID());\n+        }\n+    }\n+\n+    private boolean changeTemperature(Command command) {\n+        if (!(command instanceof QuantityType)) {\n+            return false;\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        QuantityType<Temperature> newMeasure = (QuantityType<Temperature>) command;\n+\n+        // Check remote device temperature limits\n+        if (newMeasure.getUnit() == SIUnits.CELSIUS) {\n+            if (newMeasure.doubleValue() < 7.1 || newMeasure.doubleValue() > 40.0) {\n+                return false;\n+            }\n+        } else if (newMeasure.getUnit() == ImperialUnits.FAHRENHEIT) {\n+            if (newMeasure.doubleValue() < 44.7 || newMeasure.doubleValue() > 104) {\n+                return false;\n+            }\n+        }\n+\n+        // Only tenth degree increments are allowed\n+        double newTemperature = Math.round(newMeasure.doubleValue() * 10) / 10.0;\n+\n+        moduleSettings.setSetPointTemperature(QuantityType.valueOf(newTemperature, newMeasure.getUnit()));\n+        return true;\n+    }\n+\n+    private boolean changeTimeHour(Command command) {\n+        if (command instanceof DecimalType) {\n+            int endHour = ((DecimalType) command).intValue();\n+            if (endHour >= 0 && endHour <= 23) {\n+                moduleSettings.setEndHour(endHour);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean changeTimeMinute(Command command) {\n+        if (command instanceof DecimalType) {\n+            int endMinute = ((DecimalType) command).intValue();\n+            if (endMinute >= 0 && endMinute <= 59) {\n+                // Only 15 min increments are allowed\n+                endMinute = Math.round(endMinute / 15) * 15;\n+                moduleSettings.setEndMinute(endMinute);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    public void handleNotification(Notification notification) {\n+        chronothermostat = notification.getData().toChronothermostat();\n+        if (config.isSettingsAutoupdate()) {\n+            moduleSettings.updateFromChronothermostat(chronothermostat);\n+        }\n+        logger.debug(\"Module[{}] Handle notification: [{}]\", thing.getUID(), chronothermostat);\n+\n+        updateModuleStatus();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Module[{}] Initialize handler\", thing.getUID());\n+\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            return;\n+        }\n+\n+        bridgeHandler = (SmartherBridgeHandler) bridge.getHandler();\n+        if (bridgeHandler == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, String.format(\n+                    \"Missing configuration from the Smarther Bridge (UID:%s). Fix configuration or report if this problem remains.\",\n+                    bridge.getBridgeUID()));\n+            return;\n+        }\n+\n+        config = getConfigAs(SmartherModuleConfiguration.class);\n+        if (StringUtils.isBlank(config.getPlantId())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19cf0c876eff6c53b1c2f4864ae682e3d33fb7a3"}, "originalPosition": 278}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUzNDMwNQ==", "bodyText": "See above", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429534305", "createdAt": "2020-05-23T10:26:16Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/handler/SmartherModuleHandler.java", "diffHunk": "@@ -0,0 +1,535 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.handler;\n+\n+import static org.openhab.binding.smarther.internal.SmartherBindingConstants.*;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.cache.ExpiringCache;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.ImperialUnits;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.scheduler.CronScheduler;\n+import org.eclipse.smarthome.core.scheduler.ScheduledCompletableFuture;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.joda.time.DateTime;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherGatewayException;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherSubscriptionAlreadyExistsException;\n+import org.openhab.binding.smarther.internal.api.model.Chronothermostat;\n+import org.openhab.binding.smarther.internal.api.model.Enums.BoostTime;\n+import org.openhab.binding.smarther.internal.api.model.Enums.Mode;\n+import org.openhab.binding.smarther.internal.api.model.ModuleSettings;\n+import org.openhab.binding.smarther.internal.api.model.ModuleStatus;\n+import org.openhab.binding.smarther.internal.api.model.Notification;\n+import org.openhab.binding.smarther.internal.api.model.Program;\n+import org.openhab.binding.smarther.internal.config.SmartherModuleConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SmartherModuleHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmartherModuleHandler extends BaseThingHandler {\n+\n+    private static final String DAILY_MIDNIGHT = \"1 0 0 * * ? *\";\n+    private static final long POLL_INITIAL_DELAY = 5;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private final CronScheduler cronScheduler;\n+    private final SmartherDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final ChannelUID programChannelUID;\n+    private final ChannelUID endDateChannelUID;\n+\n+    // Field members assigned in initialize method\n+    private @NonNullByDefault({}) ScheduledCompletableFuture<Void> jobFuture;\n+    private @NonNullByDefault({}) Future<?> pollFuture;\n+    private @NonNullByDefault({}) SmartherBridgeHandler bridgeHandler;\n+    private @NonNullByDefault({}) SmartherModuleConfiguration config;\n+\n+    // Chronothermostat local status\n+    private @NonNullByDefault({}) ExpiringCache<List<Program>> programCache;\n+    private @NonNullByDefault({}) Chronothermostat chronothermostat;\n+    private @NonNullByDefault({}) ModuleSettings moduleSettings;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param thing Thing representing this module.\n+     */\n+    public SmartherModuleHandler(Thing thing, CronScheduler scheduler,\n+            SmartherDynamicStateDescriptionProvider provider) {\n+        super(thing);\n+        this.cronScheduler = scheduler;\n+        this.dynamicStateDescriptionProvider = provider;\n+        this.programChannelUID = new ChannelUID(thing.getUID(), CHANNEL_SETTINGS_PROGRAM);\n+        this.endDateChannelUID = new ChannelUID(thing.getUID(), CHANNEL_SETTINGS_ENDDATE);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        try {\n+            handleCommandInternal(channelUID, command);\n+\n+            updateModuleStatus();\n+        } catch (SmartherGatewayException ex) {\n+            // catch exceptions and handle it in your binding\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, ex.getMessage());\n+        }\n+    }\n+\n+    private void handleCommandInternal(ChannelUID channelUID, Command command) throws SmartherGatewayException {\n+        switch (channelUID.getId()) {\n+            case CHANNEL_SETTINGS_MODE:\n+                if (command instanceof StringType) {\n+                    moduleSettings.setMode(Mode.fromValue(command.toString()));\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_TEMPERATURE:\n+                if (changeTemperature(command)) {\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_PROGRAM:\n+                if (command instanceof DecimalType) {\n+                    moduleSettings.setProgram(((DecimalType) command).intValue());\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_BOOSTTIME:\n+                if (command instanceof DecimalType) {\n+                    moduleSettings.setBoostTime(BoostTime.fromValue(((DecimalType) command).intValue()));\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_ENDDATE:\n+                if (command instanceof StringType) {\n+                    moduleSettings.setEndDate(command.toString());\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_ENDHOUR:\n+                if (changeTimeHour(command)) {\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_ENDMINUTE:\n+                if (changeTimeMinute(command)) {\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_POWER:\n+                if (command instanceof OnOffType) {\n+                    if (OnOffType.ON.equals(command)) {\n+                        // Send change to the remote module\n+                        applyModuleSettings();\n+                        updateChannelState(CHANNEL_SETTINGS_POWER, OnOffType.OFF);\n+                    }\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_FETCH_CONFIG:\n+                if (command instanceof OnOffType) {\n+                    if (OnOffType.ON.equals(command)) {\n+                        logger.debug(\"Module[{}] Manually triggered channel to refresh the Module config\",\n+                                thing.getUID());\n+                        programCache.invalidateValue();\n+                        programCache.getValue();\n+                        updateChannelState(CHANNEL_FETCH_CONFIG, OnOffType.OFF);\n+                    }\n+                    return;\n+                }\n+                break;\n+        }\n+\n+        if (command instanceof RefreshType) {\n+            // Avoid logging wrong command when refresh command is sent\n+            return;\n+        }\n+\n+        logger.debug(\"Module[{}] Received command {} of wrong type {} on channel {}\", thing.getUID(), command,\n+                command.getClass().getTypeName(), channelUID.getId());\n+    }\n+\n+    private void applyModuleSettings() {\n+        // Send change to the remote module\n+        if (bridgeHandler.setModuleStatus(moduleSettings)) {\n+            // Change applied, update module status\n+            logger.debug(\"Module[{}] New settings applied!\", thing.getUID());\n+        }\n+    }\n+\n+    private boolean changeTemperature(Command command) {\n+        if (!(command instanceof QuantityType)) {\n+            return false;\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        QuantityType<Temperature> newMeasure = (QuantityType<Temperature>) command;\n+\n+        // Check remote device temperature limits\n+        if (newMeasure.getUnit() == SIUnits.CELSIUS) {\n+            if (newMeasure.doubleValue() < 7.1 || newMeasure.doubleValue() > 40.0) {\n+                return false;\n+            }\n+        } else if (newMeasure.getUnit() == ImperialUnits.FAHRENHEIT) {\n+            if (newMeasure.doubleValue() < 44.7 || newMeasure.doubleValue() > 104) {\n+                return false;\n+            }\n+        }\n+\n+        // Only tenth degree increments are allowed\n+        double newTemperature = Math.round(newMeasure.doubleValue() * 10) / 10.0;\n+\n+        moduleSettings.setSetPointTemperature(QuantityType.valueOf(newTemperature, newMeasure.getUnit()));\n+        return true;\n+    }\n+\n+    private boolean changeTimeHour(Command command) {\n+        if (command instanceof DecimalType) {\n+            int endHour = ((DecimalType) command).intValue();\n+            if (endHour >= 0 && endHour <= 23) {\n+                moduleSettings.setEndHour(endHour);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean changeTimeMinute(Command command) {\n+        if (command instanceof DecimalType) {\n+            int endMinute = ((DecimalType) command).intValue();\n+            if (endMinute >= 0 && endMinute <= 59) {\n+                // Only 15 min increments are allowed\n+                endMinute = Math.round(endMinute / 15) * 15;\n+                moduleSettings.setEndMinute(endMinute);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    public void handleNotification(Notification notification) {\n+        chronothermostat = notification.getData().toChronothermostat();\n+        if (config.isSettingsAutoupdate()) {\n+            moduleSettings.updateFromChronothermostat(chronothermostat);\n+        }\n+        logger.debug(\"Module[{}] Handle notification: [{}]\", thing.getUID(), chronothermostat);\n+\n+        updateModuleStatus();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Module[{}] Initialize handler\", thing.getUID());\n+\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            return;\n+        }\n+\n+        bridgeHandler = (SmartherBridgeHandler) bridge.getHandler();\n+        if (bridgeHandler == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, String.format(\n+                    \"Missing configuration from the Smarther Bridge (UID:%s). Fix configuration or report if this problem remains.\",\n+                    bridge.getBridgeUID()));\n+            return;\n+        }\n+\n+        config = getConfigAs(SmartherModuleConfiguration.class);\n+        if (StringUtils.isBlank(config.getPlantId())) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Plant Id' property is not set or empty. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+        if (StringUtils.isBlank(config.getModuleId())) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Module Id' property is not set or empty. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+        if (config.getProgramsRefreshPeriod() <= 0) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Programs Refresh Period' must be > 0. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+        if (config.getStatusRefreshPeriod() <= 0) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Module Status Refresh Period' must be > 0. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+\n+        programCache = new ExpiringCache<>(Duration.ofHours(config.getProgramsRefreshPeriod()), this::getProgramList);\n+        moduleSettings = new ModuleSettings(config.getPlantId(), config.getModuleId());\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduleJob();\n+        schedulePoll();\n+\n+        logger.debug(\"Module[{}] Finished initializing!\", thing.getUID());\n+    }\n+\n+    private List<Program> getProgramList() {\n+        final List<Program> programs = bridgeHandler.getModuleProgramList(config.getPlantId(), config.getModuleId());\n+        logger.debug(\"Module[{}] Programs: {}\", thing.getUID(), programs);\n+        return programs;\n+    }\n+\n+    @Override\n+    public void handleRemoval() {\n+        super.handleRemoval();\n+        stopPoll(true);\n+        stopJob(true);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Module[{}] Dispose handler\", thing.getUID());\n+        stopPoll(true);\n+        stopJob(true);\n+        try {\n+            bridgeHandler.unregisterNotification(config.getPlantId());\n+        } catch (SmartherGatewayException e) {\n+            logger.warn(\"Module[{}] API Gateway error during disposing: {}\", thing.getUID(), e.getMessage());\n+        }\n+        logger.debug(\"Module[{}] Finished disposing!\", thing.getUID());\n+    }\n+\n+    /**\n+     * This method initiates a new thread for executing internal recurring jobs.\n+     */\n+    private synchronized void scheduleJob() {\n+        stopJob(false);\n+        // Schedule daily job to start daily, at midnight\n+        jobFuture = cronScheduler.schedule(this::dailyJob, DAILY_MIDNIGHT);\n+        logger.debug(\"Module[{}] Scheduled recurring job {} to start at midnight\", thing.getUID(),\n+                Integer.toHexString(jobFuture.hashCode()));\n+        // Execute daily job immediately at startup\n+        this.dailyJob();\n+    }\n+\n+    /**\n+     * Cancels all running jobs.\n+     *\n+     * @param mayInterruptIfRunning true if the thread executing this task should be interrupted; otherwise, in-progress\n+     *            tasks are allowed to complete.\n+     */\n+    private synchronized void stopJob(boolean mayInterruptIfRunning) {\n+        if (jobFuture != null && !jobFuture.isCancelled()) {\n+            jobFuture.cancel(mayInterruptIfRunning);\n+            jobFuture = null;\n+        }\n+    }\n+\n+    /**\n+     * Action to be executed by the daily job: refresh the end dates list for \"manual\" mode.\n+     */\n+    private void dailyJob() {\n+        try {\n+            logger.debug(\"Module[{}] Daily job, refreshing the end dates list for \\\"manual\\\" mode\", thing.getUID());\n+            // Refresh the end dates list for \"manual\" mode\n+            dynamicStateDescriptionProvider.setEndDates(endDateChannelUID, config.getNumberOfEndDays());\n+            // If expired, update EndDate in module settings\n+            if (moduleSettings != null && moduleSettings.isEndDateExpired()) {\n+                final DateTime today = DateTime.now().withTimeAtStartOfDay();\n+                moduleSettings.setEndDate(today.toString(DATE_FORMAT));\n+                updateChannelState(CHANNEL_SETTINGS_ENDDATE, new StringType(moduleSettings.getEndDate()));\n+            }\n+        } catch (RuntimeException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19cf0c876eff6c53b1c2f4864ae682e3d33fb7a3"}, "originalPosition": 376}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUzNDcxNw==", "bodyText": "From the concurrency perspective, getBridge() could return null here.", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429534717", "createdAt": "2020-05-23T10:34:29Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/handler/SmartherModuleHandler.java", "diffHunk": "@@ -0,0 +1,535 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.handler;\n+\n+import static org.openhab.binding.smarther.internal.SmartherBindingConstants.*;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.cache.ExpiringCache;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.ImperialUnits;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.scheduler.CronScheduler;\n+import org.eclipse.smarthome.core.scheduler.ScheduledCompletableFuture;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.joda.time.DateTime;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherGatewayException;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherSubscriptionAlreadyExistsException;\n+import org.openhab.binding.smarther.internal.api.model.Chronothermostat;\n+import org.openhab.binding.smarther.internal.api.model.Enums.BoostTime;\n+import org.openhab.binding.smarther.internal.api.model.Enums.Mode;\n+import org.openhab.binding.smarther.internal.api.model.ModuleSettings;\n+import org.openhab.binding.smarther.internal.api.model.ModuleStatus;\n+import org.openhab.binding.smarther.internal.api.model.Notification;\n+import org.openhab.binding.smarther.internal.api.model.Program;\n+import org.openhab.binding.smarther.internal.config.SmartherModuleConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SmartherModuleHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmartherModuleHandler extends BaseThingHandler {\n+\n+    private static final String DAILY_MIDNIGHT = \"1 0 0 * * ? *\";\n+    private static final long POLL_INITIAL_DELAY = 5;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private final CronScheduler cronScheduler;\n+    private final SmartherDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final ChannelUID programChannelUID;\n+    private final ChannelUID endDateChannelUID;\n+\n+    // Field members assigned in initialize method\n+    private @NonNullByDefault({}) ScheduledCompletableFuture<Void> jobFuture;\n+    private @NonNullByDefault({}) Future<?> pollFuture;\n+    private @NonNullByDefault({}) SmartherBridgeHandler bridgeHandler;\n+    private @NonNullByDefault({}) SmartherModuleConfiguration config;\n+\n+    // Chronothermostat local status\n+    private @NonNullByDefault({}) ExpiringCache<List<Program>> programCache;\n+    private @NonNullByDefault({}) Chronothermostat chronothermostat;\n+    private @NonNullByDefault({}) ModuleSettings moduleSettings;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param thing Thing representing this module.\n+     */\n+    public SmartherModuleHandler(Thing thing, CronScheduler scheduler,\n+            SmartherDynamicStateDescriptionProvider provider) {\n+        super(thing);\n+        this.cronScheduler = scheduler;\n+        this.dynamicStateDescriptionProvider = provider;\n+        this.programChannelUID = new ChannelUID(thing.getUID(), CHANNEL_SETTINGS_PROGRAM);\n+        this.endDateChannelUID = new ChannelUID(thing.getUID(), CHANNEL_SETTINGS_ENDDATE);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        try {\n+            handleCommandInternal(channelUID, command);\n+\n+            updateModuleStatus();\n+        } catch (SmartherGatewayException ex) {\n+            // catch exceptions and handle it in your binding\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, ex.getMessage());\n+        }\n+    }\n+\n+    private void handleCommandInternal(ChannelUID channelUID, Command command) throws SmartherGatewayException {\n+        switch (channelUID.getId()) {\n+            case CHANNEL_SETTINGS_MODE:\n+                if (command instanceof StringType) {\n+                    moduleSettings.setMode(Mode.fromValue(command.toString()));\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_TEMPERATURE:\n+                if (changeTemperature(command)) {\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_PROGRAM:\n+                if (command instanceof DecimalType) {\n+                    moduleSettings.setProgram(((DecimalType) command).intValue());\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_BOOSTTIME:\n+                if (command instanceof DecimalType) {\n+                    moduleSettings.setBoostTime(BoostTime.fromValue(((DecimalType) command).intValue()));\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_ENDDATE:\n+                if (command instanceof StringType) {\n+                    moduleSettings.setEndDate(command.toString());\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_ENDHOUR:\n+                if (changeTimeHour(command)) {\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_ENDMINUTE:\n+                if (changeTimeMinute(command)) {\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_POWER:\n+                if (command instanceof OnOffType) {\n+                    if (OnOffType.ON.equals(command)) {\n+                        // Send change to the remote module\n+                        applyModuleSettings();\n+                        updateChannelState(CHANNEL_SETTINGS_POWER, OnOffType.OFF);\n+                    }\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_FETCH_CONFIG:\n+                if (command instanceof OnOffType) {\n+                    if (OnOffType.ON.equals(command)) {\n+                        logger.debug(\"Module[{}] Manually triggered channel to refresh the Module config\",\n+                                thing.getUID());\n+                        programCache.invalidateValue();\n+                        programCache.getValue();\n+                        updateChannelState(CHANNEL_FETCH_CONFIG, OnOffType.OFF);\n+                    }\n+                    return;\n+                }\n+                break;\n+        }\n+\n+        if (command instanceof RefreshType) {\n+            // Avoid logging wrong command when refresh command is sent\n+            return;\n+        }\n+\n+        logger.debug(\"Module[{}] Received command {} of wrong type {} on channel {}\", thing.getUID(), command,\n+                command.getClass().getTypeName(), channelUID.getId());\n+    }\n+\n+    private void applyModuleSettings() {\n+        // Send change to the remote module\n+        if (bridgeHandler.setModuleStatus(moduleSettings)) {\n+            // Change applied, update module status\n+            logger.debug(\"Module[{}] New settings applied!\", thing.getUID());\n+        }\n+    }\n+\n+    private boolean changeTemperature(Command command) {\n+        if (!(command instanceof QuantityType)) {\n+            return false;\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        QuantityType<Temperature> newMeasure = (QuantityType<Temperature>) command;\n+\n+        // Check remote device temperature limits\n+        if (newMeasure.getUnit() == SIUnits.CELSIUS) {\n+            if (newMeasure.doubleValue() < 7.1 || newMeasure.doubleValue() > 40.0) {\n+                return false;\n+            }\n+        } else if (newMeasure.getUnit() == ImperialUnits.FAHRENHEIT) {\n+            if (newMeasure.doubleValue() < 44.7 || newMeasure.doubleValue() > 104) {\n+                return false;\n+            }\n+        }\n+\n+        // Only tenth degree increments are allowed\n+        double newTemperature = Math.round(newMeasure.doubleValue() * 10) / 10.0;\n+\n+        moduleSettings.setSetPointTemperature(QuantityType.valueOf(newTemperature, newMeasure.getUnit()));\n+        return true;\n+    }\n+\n+    private boolean changeTimeHour(Command command) {\n+        if (command instanceof DecimalType) {\n+            int endHour = ((DecimalType) command).intValue();\n+            if (endHour >= 0 && endHour <= 23) {\n+                moduleSettings.setEndHour(endHour);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean changeTimeMinute(Command command) {\n+        if (command instanceof DecimalType) {\n+            int endMinute = ((DecimalType) command).intValue();\n+            if (endMinute >= 0 && endMinute <= 59) {\n+                // Only 15 min increments are allowed\n+                endMinute = Math.round(endMinute / 15) * 15;\n+                moduleSettings.setEndMinute(endMinute);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    public void handleNotification(Notification notification) {\n+        chronothermostat = notification.getData().toChronothermostat();\n+        if (config.isSettingsAutoupdate()) {\n+            moduleSettings.updateFromChronothermostat(chronothermostat);\n+        }\n+        logger.debug(\"Module[{}] Handle notification: [{}]\", thing.getUID(), chronothermostat);\n+\n+        updateModuleStatus();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Module[{}] Initialize handler\", thing.getUID());\n+\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            return;\n+        }\n+\n+        bridgeHandler = (SmartherBridgeHandler) bridge.getHandler();\n+        if (bridgeHandler == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, String.format(\n+                    \"Missing configuration from the Smarther Bridge (UID:%s). Fix configuration or report if this problem remains.\",\n+                    bridge.getBridgeUID()));\n+            return;\n+        }\n+\n+        config = getConfigAs(SmartherModuleConfiguration.class);\n+        if (StringUtils.isBlank(config.getPlantId())) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Plant Id' property is not set or empty. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+        if (StringUtils.isBlank(config.getModuleId())) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Module Id' property is not set or empty. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+        if (config.getProgramsRefreshPeriod() <= 0) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Programs Refresh Period' must be > 0. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+        if (config.getStatusRefreshPeriod() <= 0) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Module Status Refresh Period' must be > 0. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+\n+        programCache = new ExpiringCache<>(Duration.ofHours(config.getProgramsRefreshPeriod()), this::getProgramList);\n+        moduleSettings = new ModuleSettings(config.getPlantId(), config.getModuleId());\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduleJob();\n+        schedulePoll();\n+\n+        logger.debug(\"Module[{}] Finished initializing!\", thing.getUID());\n+    }\n+\n+    private List<Program> getProgramList() {\n+        final List<Program> programs = bridgeHandler.getModuleProgramList(config.getPlantId(), config.getModuleId());\n+        logger.debug(\"Module[{}] Programs: {}\", thing.getUID(), programs);\n+        return programs;\n+    }\n+\n+    @Override\n+    public void handleRemoval() {\n+        super.handleRemoval();\n+        stopPoll(true);\n+        stopJob(true);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Module[{}] Dispose handler\", thing.getUID());\n+        stopPoll(true);\n+        stopJob(true);\n+        try {\n+            bridgeHandler.unregisterNotification(config.getPlantId());\n+        } catch (SmartherGatewayException e) {\n+            logger.warn(\"Module[{}] API Gateway error during disposing: {}\", thing.getUID(), e.getMessage());\n+        }\n+        logger.debug(\"Module[{}] Finished disposing!\", thing.getUID());\n+    }\n+\n+    /**\n+     * This method initiates a new thread for executing internal recurring jobs.\n+     */\n+    private synchronized void scheduleJob() {\n+        stopJob(false);\n+        // Schedule daily job to start daily, at midnight\n+        jobFuture = cronScheduler.schedule(this::dailyJob, DAILY_MIDNIGHT);\n+        logger.debug(\"Module[{}] Scheduled recurring job {} to start at midnight\", thing.getUID(),\n+                Integer.toHexString(jobFuture.hashCode()));\n+        // Execute daily job immediately at startup\n+        this.dailyJob();\n+    }\n+\n+    /**\n+     * Cancels all running jobs.\n+     *\n+     * @param mayInterruptIfRunning true if the thread executing this task should be interrupted; otherwise, in-progress\n+     *            tasks are allowed to complete.\n+     */\n+    private synchronized void stopJob(boolean mayInterruptIfRunning) {\n+        if (jobFuture != null && !jobFuture.isCancelled()) {\n+            jobFuture.cancel(mayInterruptIfRunning);\n+            jobFuture = null;\n+        }\n+    }\n+\n+    /**\n+     * Action to be executed by the daily job: refresh the end dates list for \"manual\" mode.\n+     */\n+    private void dailyJob() {\n+        try {\n+            logger.debug(\"Module[{}] Daily job, refreshing the end dates list for \\\"manual\\\" mode\", thing.getUID());\n+            // Refresh the end dates list for \"manual\" mode\n+            dynamicStateDescriptionProvider.setEndDates(endDateChannelUID, config.getNumberOfEndDays());\n+            // If expired, update EndDate in module settings\n+            if (moduleSettings != null && moduleSettings.isEndDateExpired()) {\n+                final DateTime today = DateTime.now().withTimeAtStartOfDay();\n+                moduleSettings.setEndDate(today.toString(DATE_FORMAT));\n+                updateChannelState(CHANNEL_SETTINGS_ENDDATE, new StringType(moduleSettings.getEndDate()));\n+            }\n+        } catch (RuntimeException e) {\n+            logger.warn(\"Module[{}] Unexpected error on daily job, please report if this keeps occurring: \",\n+                    thing.getUID(), e);\n+        }\n+    }\n+\n+    /**\n+     * This method initiates a new thread for polling the Module status.\n+     */\n+    private void schedulePoll() {\n+        stopPoll(false);\n+        // Schedule poll to start after POLL_INITIAL_DELAY sec and run periodically based on status refresh period\n+        pollFuture = scheduler.scheduleWithFixedDelay(this::poll, POLL_INITIAL_DELAY,\n+                config.getStatusRefreshPeriod() * 60, TimeUnit.SECONDS);\n+        logger.debug(\"Module[{}] Scheduled poll for {} sec out, then every {} min\", thing.getUID(), POLL_INITIAL_DELAY,\n+                config.getStatusRefreshPeriod());\n+    }\n+\n+    /**\n+     * Cancels all running schedulers.\n+     *\n+     * @param mayInterruptIfRunning true if the thread executing this task should be interrupted; otherwise, in-progress\n+     *            tasks are allowed to complete.\n+     */\n+    private synchronized void stopPoll(boolean mayInterruptIfRunning) {\n+        if (pollFuture != null && !pollFuture.isCancelled()) {\n+            pollFuture.cancel(mayInterruptIfRunning);\n+            pollFuture = null;\n+        }\n+    }\n+\n+    /**\n+     * Calls the Smarther API and collects module data. Returns true if method completed without errors.\n+     *\n+     * @return true if method completed without errors.\n+     */\n+    private synchronized boolean poll() {\n+        try {\n+            @SuppressWarnings(\"null\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19cf0c876eff6c53b1c2f4864ae682e3d33fb7a3"}, "originalPosition": 414}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUzNDgxMQ==", "bodyText": "See above", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429534811", "createdAt": "2020-05-23T10:35:58Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/handler/SmartherModuleHandler.java", "diffHunk": "@@ -0,0 +1,535 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.handler;\n+\n+import static org.openhab.binding.smarther.internal.SmartherBindingConstants.*;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.cache.ExpiringCache;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.ImperialUnits;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.scheduler.CronScheduler;\n+import org.eclipse.smarthome.core.scheduler.ScheduledCompletableFuture;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.joda.time.DateTime;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherGatewayException;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherSubscriptionAlreadyExistsException;\n+import org.openhab.binding.smarther.internal.api.model.Chronothermostat;\n+import org.openhab.binding.smarther.internal.api.model.Enums.BoostTime;\n+import org.openhab.binding.smarther.internal.api.model.Enums.Mode;\n+import org.openhab.binding.smarther.internal.api.model.ModuleSettings;\n+import org.openhab.binding.smarther.internal.api.model.ModuleStatus;\n+import org.openhab.binding.smarther.internal.api.model.Notification;\n+import org.openhab.binding.smarther.internal.api.model.Program;\n+import org.openhab.binding.smarther.internal.config.SmartherModuleConfiguration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SmartherModuleHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmartherModuleHandler extends BaseThingHandler {\n+\n+    private static final String DAILY_MIDNIGHT = \"1 0 0 * * ? *\";\n+    private static final long POLL_INITIAL_DELAY = 5;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private final CronScheduler cronScheduler;\n+    private final SmartherDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final ChannelUID programChannelUID;\n+    private final ChannelUID endDateChannelUID;\n+\n+    // Field members assigned in initialize method\n+    private @NonNullByDefault({}) ScheduledCompletableFuture<Void> jobFuture;\n+    private @NonNullByDefault({}) Future<?> pollFuture;\n+    private @NonNullByDefault({}) SmartherBridgeHandler bridgeHandler;\n+    private @NonNullByDefault({}) SmartherModuleConfiguration config;\n+\n+    // Chronothermostat local status\n+    private @NonNullByDefault({}) ExpiringCache<List<Program>> programCache;\n+    private @NonNullByDefault({}) Chronothermostat chronothermostat;\n+    private @NonNullByDefault({}) ModuleSettings moduleSettings;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param thing Thing representing this module.\n+     */\n+    public SmartherModuleHandler(Thing thing, CronScheduler scheduler,\n+            SmartherDynamicStateDescriptionProvider provider) {\n+        super(thing);\n+        this.cronScheduler = scheduler;\n+        this.dynamicStateDescriptionProvider = provider;\n+        this.programChannelUID = new ChannelUID(thing.getUID(), CHANNEL_SETTINGS_PROGRAM);\n+        this.endDateChannelUID = new ChannelUID(thing.getUID(), CHANNEL_SETTINGS_ENDDATE);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        try {\n+            handleCommandInternal(channelUID, command);\n+\n+            updateModuleStatus();\n+        } catch (SmartherGatewayException ex) {\n+            // catch exceptions and handle it in your binding\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, ex.getMessage());\n+        }\n+    }\n+\n+    private void handleCommandInternal(ChannelUID channelUID, Command command) throws SmartherGatewayException {\n+        switch (channelUID.getId()) {\n+            case CHANNEL_SETTINGS_MODE:\n+                if (command instanceof StringType) {\n+                    moduleSettings.setMode(Mode.fromValue(command.toString()));\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_TEMPERATURE:\n+                if (changeTemperature(command)) {\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_PROGRAM:\n+                if (command instanceof DecimalType) {\n+                    moduleSettings.setProgram(((DecimalType) command).intValue());\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_BOOSTTIME:\n+                if (command instanceof DecimalType) {\n+                    moduleSettings.setBoostTime(BoostTime.fromValue(((DecimalType) command).intValue()));\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_ENDDATE:\n+                if (command instanceof StringType) {\n+                    moduleSettings.setEndDate(command.toString());\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_ENDHOUR:\n+                if (changeTimeHour(command)) {\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_ENDMINUTE:\n+                if (changeTimeMinute(command)) {\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_POWER:\n+                if (command instanceof OnOffType) {\n+                    if (OnOffType.ON.equals(command)) {\n+                        // Send change to the remote module\n+                        applyModuleSettings();\n+                        updateChannelState(CHANNEL_SETTINGS_POWER, OnOffType.OFF);\n+                    }\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_FETCH_CONFIG:\n+                if (command instanceof OnOffType) {\n+                    if (OnOffType.ON.equals(command)) {\n+                        logger.debug(\"Module[{}] Manually triggered channel to refresh the Module config\",\n+                                thing.getUID());\n+                        programCache.invalidateValue();\n+                        programCache.getValue();\n+                        updateChannelState(CHANNEL_FETCH_CONFIG, OnOffType.OFF);\n+                    }\n+                    return;\n+                }\n+                break;\n+        }\n+\n+        if (command instanceof RefreshType) {\n+            // Avoid logging wrong command when refresh command is sent\n+            return;\n+        }\n+\n+        logger.debug(\"Module[{}] Received command {} of wrong type {} on channel {}\", thing.getUID(), command,\n+                command.getClass().getTypeName(), channelUID.getId());\n+    }\n+\n+    private void applyModuleSettings() {\n+        // Send change to the remote module\n+        if (bridgeHandler.setModuleStatus(moduleSettings)) {\n+            // Change applied, update module status\n+            logger.debug(\"Module[{}] New settings applied!\", thing.getUID());\n+        }\n+    }\n+\n+    private boolean changeTemperature(Command command) {\n+        if (!(command instanceof QuantityType)) {\n+            return false;\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        QuantityType<Temperature> newMeasure = (QuantityType<Temperature>) command;\n+\n+        // Check remote device temperature limits\n+        if (newMeasure.getUnit() == SIUnits.CELSIUS) {\n+            if (newMeasure.doubleValue() < 7.1 || newMeasure.doubleValue() > 40.0) {\n+                return false;\n+            }\n+        } else if (newMeasure.getUnit() == ImperialUnits.FAHRENHEIT) {\n+            if (newMeasure.doubleValue() < 44.7 || newMeasure.doubleValue() > 104) {\n+                return false;\n+            }\n+        }\n+\n+        // Only tenth degree increments are allowed\n+        double newTemperature = Math.round(newMeasure.doubleValue() * 10) / 10.0;\n+\n+        moduleSettings.setSetPointTemperature(QuantityType.valueOf(newTemperature, newMeasure.getUnit()));\n+        return true;\n+    }\n+\n+    private boolean changeTimeHour(Command command) {\n+        if (command instanceof DecimalType) {\n+            int endHour = ((DecimalType) command).intValue();\n+            if (endHour >= 0 && endHour <= 23) {\n+                moduleSettings.setEndHour(endHour);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean changeTimeMinute(Command command) {\n+        if (command instanceof DecimalType) {\n+            int endMinute = ((DecimalType) command).intValue();\n+            if (endMinute >= 0 && endMinute <= 59) {\n+                // Only 15 min increments are allowed\n+                endMinute = Math.round(endMinute / 15) * 15;\n+                moduleSettings.setEndMinute(endMinute);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    public void handleNotification(Notification notification) {\n+        chronothermostat = notification.getData().toChronothermostat();\n+        if (config.isSettingsAutoupdate()) {\n+            moduleSettings.updateFromChronothermostat(chronothermostat);\n+        }\n+        logger.debug(\"Module[{}] Handle notification: [{}]\", thing.getUID(), chronothermostat);\n+\n+        updateModuleStatus();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Module[{}] Initialize handler\", thing.getUID());\n+\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            return;\n+        }\n+\n+        bridgeHandler = (SmartherBridgeHandler) bridge.getHandler();\n+        if (bridgeHandler == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, String.format(\n+                    \"Missing configuration from the Smarther Bridge (UID:%s). Fix configuration or report if this problem remains.\",\n+                    bridge.getBridgeUID()));\n+            return;\n+        }\n+\n+        config = getConfigAs(SmartherModuleConfiguration.class);\n+        if (StringUtils.isBlank(config.getPlantId())) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Plant Id' property is not set or empty. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+        if (StringUtils.isBlank(config.getModuleId())) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Module Id' property is not set or empty. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+        if (config.getProgramsRefreshPeriod() <= 0) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Programs Refresh Period' must be > 0. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+        if (config.getStatusRefreshPeriod() <= 0) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Module Status Refresh Period' must be > 0. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+\n+        programCache = new ExpiringCache<>(Duration.ofHours(config.getProgramsRefreshPeriod()), this::getProgramList);\n+        moduleSettings = new ModuleSettings(config.getPlantId(), config.getModuleId());\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduleJob();\n+        schedulePoll();\n+\n+        logger.debug(\"Module[{}] Finished initializing!\", thing.getUID());\n+    }\n+\n+    private List<Program> getProgramList() {\n+        final List<Program> programs = bridgeHandler.getModuleProgramList(config.getPlantId(), config.getModuleId());\n+        logger.debug(\"Module[{}] Programs: {}\", thing.getUID(), programs);\n+        return programs;\n+    }\n+\n+    @Override\n+    public void handleRemoval() {\n+        super.handleRemoval();\n+        stopPoll(true);\n+        stopJob(true);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Module[{}] Dispose handler\", thing.getUID());\n+        stopPoll(true);\n+        stopJob(true);\n+        try {\n+            bridgeHandler.unregisterNotification(config.getPlantId());\n+        } catch (SmartherGatewayException e) {\n+            logger.warn(\"Module[{}] API Gateway error during disposing: {}\", thing.getUID(), e.getMessage());\n+        }\n+        logger.debug(\"Module[{}] Finished disposing!\", thing.getUID());\n+    }\n+\n+    /**\n+     * This method initiates a new thread for executing internal recurring jobs.\n+     */\n+    private synchronized void scheduleJob() {\n+        stopJob(false);\n+        // Schedule daily job to start daily, at midnight\n+        jobFuture = cronScheduler.schedule(this::dailyJob, DAILY_MIDNIGHT);\n+        logger.debug(\"Module[{}] Scheduled recurring job {} to start at midnight\", thing.getUID(),\n+                Integer.toHexString(jobFuture.hashCode()));\n+        // Execute daily job immediately at startup\n+        this.dailyJob();\n+    }\n+\n+    /**\n+     * Cancels all running jobs.\n+     *\n+     * @param mayInterruptIfRunning true if the thread executing this task should be interrupted; otherwise, in-progress\n+     *            tasks are allowed to complete.\n+     */\n+    private synchronized void stopJob(boolean mayInterruptIfRunning) {\n+        if (jobFuture != null && !jobFuture.isCancelled()) {\n+            jobFuture.cancel(mayInterruptIfRunning);\n+            jobFuture = null;\n+        }\n+    }\n+\n+    /**\n+     * Action to be executed by the daily job: refresh the end dates list for \"manual\" mode.\n+     */\n+    private void dailyJob() {\n+        try {\n+            logger.debug(\"Module[{}] Daily job, refreshing the end dates list for \\\"manual\\\" mode\", thing.getUID());\n+            // Refresh the end dates list for \"manual\" mode\n+            dynamicStateDescriptionProvider.setEndDates(endDateChannelUID, config.getNumberOfEndDays());\n+            // If expired, update EndDate in module settings\n+            if (moduleSettings != null && moduleSettings.isEndDateExpired()) {\n+                final DateTime today = DateTime.now().withTimeAtStartOfDay();\n+                moduleSettings.setEndDate(today.toString(DATE_FORMAT));\n+                updateChannelState(CHANNEL_SETTINGS_ENDDATE, new StringType(moduleSettings.getEndDate()));\n+            }\n+        } catch (RuntimeException e) {\n+            logger.warn(\"Module[{}] Unexpected error on daily job, please report if this keeps occurring: \",\n+                    thing.getUID(), e);\n+        }\n+    }\n+\n+    /**\n+     * This method initiates a new thread for polling the Module status.\n+     */\n+    private void schedulePoll() {\n+        stopPoll(false);\n+        // Schedule poll to start after POLL_INITIAL_DELAY sec and run periodically based on status refresh period\n+        pollFuture = scheduler.scheduleWithFixedDelay(this::poll, POLL_INITIAL_DELAY,\n+                config.getStatusRefreshPeriod() * 60, TimeUnit.SECONDS);\n+        logger.debug(\"Module[{}] Scheduled poll for {} sec out, then every {} min\", thing.getUID(), POLL_INITIAL_DELAY,\n+                config.getStatusRefreshPeriod());\n+    }\n+\n+    /**\n+     * Cancels all running schedulers.\n+     *\n+     * @param mayInterruptIfRunning true if the thread executing this task should be interrupted; otherwise, in-progress\n+     *            tasks are allowed to complete.\n+     */\n+    private synchronized void stopPoll(boolean mayInterruptIfRunning) {\n+        if (pollFuture != null && !pollFuture.isCancelled()) {\n+            pollFuture.cancel(mayInterruptIfRunning);\n+            pollFuture = null;\n+        }\n+    }\n+\n+    /**\n+     * Calls the Smarther API and collects module data. Returns true if method completed without errors.\n+     *\n+     * @return true if method completed without errors.\n+     */\n+    private synchronized boolean poll() {\n+        try {\n+            @SuppressWarnings(\"null\")\n+            final ThingStatusInfo bridgeStatusInfo = getBridge().getStatusInfo();\n+\n+            if (bridgeStatusInfo.getStatus() == ThingStatus.ONLINE) {\n+                ModuleStatus moduleStatus = bridgeHandler.getModuleStatus(config.getPlantId(), config.getModuleId());\n+                if (!moduleStatus.hasChronothermostat()) {\n+                    throw new SmartherGatewayException(\"No chronothermostat data found\");\n+                }\n+\n+                boolean isFirstRemoteUpdate = (chronothermostat == null);\n+                chronothermostat = moduleStatus.toChronothermostat();\n+                if (isFirstRemoteUpdate || config.isSettingsAutoupdate()) {\n+                    moduleSettings.updateFromChronothermostat(chronothermostat);\n+                }\n+                logger.debug(\"Module[{}] Status: [{}]\", thing.getUID(), chronothermostat);\n+\n+                // Refresh the programs list for \"automatic\" mode\n+                dynamicStateDescriptionProvider.setPrograms(programChannelUID, programCache.getValue());\n+\n+                updateModuleStatus();\n+\n+                bridgeHandler.registerNotification(config.getPlantId());\n+\n+                // Everything is ok > set the Thing state to Online\n+                updateStatus(ThingStatus.ONLINE);\n+                return true;\n+            } else if (thing.getStatus() != ThingStatus.OFFLINE) {\n+                logger.debug(\"Module[{}] Switched {} as Bridge is not online\", thing.getUID(),\n+                        bridgeStatusInfo.getStatus());\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE, \"Smarther Bridge Offline\");\n+            }\n+            return false;\n+        } catch (SmartherSubscriptionAlreadyExistsException e) {\n+            logger.debug(\"Module[{}] Subscription error during polling: {}\", thing.getUID(), e.getMessage());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, e.getMessage());\n+            schedulePoll();\n+            return false;\n+        } catch (SmartherGatewayException e) {\n+            logger.warn(\"Module[{}] API Gateway error during polling: {}\", thing.getUID(), e.getMessage());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            schedulePoll();\n+            return false;\n+        } catch (RuntimeException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19cf0c876eff6c53b1c2f4864ae682e3d33fb7a3"}, "originalPosition": 456}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUzNDk2NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t<description>This is the binding for BTicino Smarther chronothermostat units.</description>\n          \n          \n            \n            \t<description>This is the binding for BTicino Smarther chronothermostat units</description>", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429534964", "createdAt": "2020-05-23T10:38:36Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.smarther/src/main/resources/ESH-INF/binding/binding.xml", "diffHunk": "@@ -0,0 +1,10 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<binding:binding id=\"smarther\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:binding=\"https://openhab.org/schemas/binding/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/binding/v1.0.0 https://openhab.org/schemas/binding-1.0.0.xsd\">\n+\n+\t<name>Smarther Binding</name>\n+\t<description>This is the binding for BTicino Smarther chronothermostat units.</description>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19cf0c876eff6c53b1c2f4864ae682e3d33fb7a3"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUzNjM3Ng==", "bodyText": "Does this found accidentally into your commit?", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429536376", "createdAt": "2020-05-23T11:05:00Z", "author": {"login": "fwolter"}, "path": "bundles/pom.xml", "diffHunk": "@@ -1,6 +1,5 @@\n <?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n-<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n-  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19cf0c876eff6c53b1c2f4864ae682e3d33fb7a3"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUzNjQ1Ng==", "bodyText": "Is there a reason for extending from an unchecked exception? Would extends Exception be sufficient?", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429536456", "createdAt": "2020-05-23T11:06:10Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/api/exception/SmartherAuthorizationException.java", "diffHunk": "@@ -0,0 +1,46 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.api.exception;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * BTicino/Legrand API gateway authorization problems exception class.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmartherAuthorizationException extends RuntimeException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19cf0c876eff6c53b1c2f4864ae682e3d33fb7a3"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUzNjQ2Mw==", "bodyText": "See above", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429536463", "createdAt": "2020-05-23T11:06:22Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/api/exception/SmartherGatewayException.java", "diffHunk": "@@ -0,0 +1,46 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.api.exception;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * Generic BTicino/Legrand API gateway exception class.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmartherGatewayException extends RuntimeException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19cf0c876eff6c53b1c2f4864ae682e3d33fb7a3"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTUzNjQ2OA==", "bodyText": "See above", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r429536468", "createdAt": "2020-05-23T11:06:32Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/api/exception/SmartherNotificationException.java", "diffHunk": "@@ -0,0 +1,46 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.api.exception;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * BTicino/Legrand C2C service notification problems exception class.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmartherNotificationException extends RuntimeException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "19cf0c876eff6c53b1c2f4864ae682e3d33fb7a3"}, "originalPosition": 23}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE3MzU4MDIy", "url": "https://github.com/openhab/openhab-addons/pull/7533#pullrequestreview-417358022", "createdAt": "2020-05-24T13:18:35Z", "commit": {"oid": "a80349e8c03cdc936c4854f77bade8200829924a"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2b5d6517841993d699bf9c35cfb152f0d23d01e6", "author": {"user": {"login": "MrRonfo", "name": "Fabio Possieri"}}, "url": "https://github.com/openhab/openhab-addons/commit/2b5d6517841993d699bf9c35cfb152f0d23d01e6", "committedDate": "2020-05-25T21:39:30Z", "message": "FIxed reference to bridge authorization process.\n\nSigned-off-by: Fabio Possieri <fabio.possieri@gmail.com>"}, "afterCommit": {"oid": "ae26de1cd33f0ddef5e30296127aeb326c1163dd", "author": {"user": {"login": "MrRonfo", "name": "Fabio Possieri"}}, "url": "https://github.com/openhab/openhab-addons/commit/ae26de1cd33f0ddef5e30296127aeb326c1163dd", "committedDate": "2020-05-25T21:42:12Z", "message": "FIxed reference to bridge authorization process.\n\nSigned-off-by: Fabio Possieri <fabio.possieri@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ae26de1cd33f0ddef5e30296127aeb326c1163dd", "author": {"user": {"login": "MrRonfo", "name": "Fabio Possieri"}}, "url": "https://github.com/openhab/openhab-addons/commit/ae26de1cd33f0ddef5e30296127aeb326c1163dd", "committedDate": "2020-05-25T21:42:12Z", "message": "FIxed reference to bridge authorization process.\n\nSigned-off-by: Fabio Possieri <fabio.possieri@gmail.com>"}, "afterCommit": {"oid": "691a6fba423de88e4347016ce5b56655e0cd1b77", "author": {"user": {"login": "MrRonfo", "name": "Fabio Possieri"}}, "url": "https://github.com/openhab/openhab-addons/commit/691a6fba423de88e4347016ce5b56655e0cd1b77", "committedDate": "2020-05-26T18:37:02Z", "message": "FIxed reference to bridge authorization process.\n\nSigned-off-by: Fabio Possieri <fabio.possieri@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE5NTkzMTM3", "url": "https://github.com/openhab/openhab-addons/pull/7533#pullrequestreview-419593137", "createdAt": "2020-05-27T20:43:47Z", "commit": {"oid": "691a6fba423de88e4347016ce5b56655e0cd1b77"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMDo0Mzo0OFrOGbcaWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMToxNjo1MFrOGbdc_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQzMDIzMg==", "bodyText": "This will also be true if cause is one of your custom RuntimeExceptions. Is this intended?", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r431430232", "createdAt": "2020-05-27T20:43:48Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/api/SmartherApiConnector.java", "diffHunk": "@@ -0,0 +1,312 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.api;\n+\n+import static org.eclipse.jetty.http.HttpStatus.*;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Function;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherAuthorizationException;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherGatewayException;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherSubscriptionAlreadyExistsException;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherTokenExpiredException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * Class to perform the actual call to the BTicino/Legrand API gateway, interprets the returned Http status codes, and\n+ * handles the error codes returned by the API gateway.\n+ *\n+ * Response mappings:\n+ * <ul>\n+ * <li>Plants : 200, 204, 400, 401, 404, 408, 469, 470, 500</li>\n+ * <li>Topology : 200, 400, 401, 404, 408, 469, 470, 500</li>\n+ * <li>Measures : 200, 400, 401, 404, 408, 469, 470, 500</li>\n+ * <li>ProgramList : 200, 400, 401, 404, 408, 469, 470, 500</li>\n+ * <li>Get Status : 200, 400, 401, 404, 408, 469, 470, 500</li>\n+ * <li>Set Status : 200, 400, 401, 404, 408, 430, 469, 470, 486, 500</li>\n+ * <li>Get Subscriptions : 200, 204, 400, 401, 404, 500</li>\n+ * <li>Subscribe : 201, 400, 401, 404, 409, 500</li>\n+ * <li>Delete Subscription : 200, 400, 401, 404, 500</li>\n+ * </ul>\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmartherApiConnector {\n+\n+    private static final String RETRY_AFTER_HEADER = \"Retry-After\";\n+    private static final String AUTHORIZATION_HEADER = \"Authorization\";\n+    private static final String SUBSCRIPTION_HEADER = \"Ocp-Apim-Subscription-Key\";\n+\n+    private static final String ERROR_CODE = \"statusCode\";\n+    private static final String ERROR_MESSAGE = \"message\";\n+    private static final String TOKEN_EXPIRED = \"expired\";\n+    private static final String AUTHORIZATION_ERROR = \"error_description\";\n+\n+    private static final int HTTP_CLIENT_TIMEOUT_SECONDS = 10;\n+    private static final int HTTP_CLIENT_RETRY_COUNT = 5;\n+\n+    // Set Chronothermostat Status > Wrong input parameters\n+    private static final int WRONG_INPUT_PARAMS_430 = 430;\n+    // Official application password expired: password used in the Thermostat official app is expired.\n+    private static final int APP_PASSWORD_EXPIRED_469 = 469;\n+    // Official application terms and conditions expired: terms and conditions for Thermostat official app are expired.\n+    private static final int APP_TERMS_EXPIRED_470 = 470;\n+    // Set Chronothermostat Status > Busy visual user interface\n+    private static final int BUSY_VISUAL_UI_486 = 486;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private final JsonParser parser = new JsonParser();\n+    private final HttpClient httpClient;\n+    private final ScheduledExecutorService scheduler;\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param scheduler Scheduler to reschedule calls when rate limit exceeded or call not ready\n+     * @param httpClient http client to use to make http calls\n+     */\n+    public SmartherApiConnector(ScheduledExecutorService scheduler, HttpClient httpClient) {\n+        this.scheduler = scheduler;\n+        this.httpClient = httpClient;\n+    }\n+\n+    /**\n+     * Performs a call to the BTicino/Legrand API gateway and returns the raw response. In there are problems this\n+     * method can throw a SmartherGateway exception.\n+     *\n+     * @param requester The function to construct the request with http client that is passed as argument to the\n+     *            function\n+     * @param subscription The subscription string to use in the Subscription header\n+     * @param authorization The authorization string to use in the Authorization header\n+     * @return the raw reponse given\n+     */\n+    public ContentResponse request(Function<HttpClient, Request> requester, String subscription, String authorization) {\n+        final Caller caller = new Caller(requester, subscription, authorization);\n+\n+        try {\n+            return caller.call().get();\n+        } catch (InterruptedException e) {\n+            Thread.currentThread().interrupt();\n+            throw new SmartherGatewayException(\"Thread interrupted\");\n+        } catch (ExecutionException e) {\n+            final Throwable cause = e.getCause();\n+\n+            if (cause instanceof RuntimeException) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "691a6fba423de88e4347016ce5b56655e0cd1b77"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQzMzgzNw==", "bodyText": "Can this be done by String.trim()? Then, length() == 0 can be replaced by isEmpty()", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r431433837", "createdAt": "2020-05-27T20:50:24Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/util/StringUtil.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.util;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.StringWriter;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link StringUtil} class defines common String utility functions, which are used across the whole binding.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class StringUtil {\n+\n+    private static final int EOF = -1;\n+    private static final int DEFAULT_BUFFER_SIZE = 1024 * 4;\n+\n+    /**\n+     * Checks if a String is whitespace, empty (\"\") or null.\n+     *\n+     * @param str the String to check, may be null\n+     * @return true if the String is null, empty or whitespace\n+     */\n+    public static boolean isBlank(@Nullable String str) {\n+        int strLen;\n+        if (str == null || (strLen = str.length()) == 0) {\n+            return true;\n+        }\n+        for (int i = 0; i < strLen; i++) {\n+            if (!Character.isWhitespace(str.charAt(i))) {\n+                return false;\n+            }\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7793a4f48ce3b905430b78b943996752b41d59d8"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ0Njg2Mw==", "bodyText": "Can this be done by String.trim()?", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r431446863", "createdAt": "2020-05-27T21:15:52Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/util/StringUtil.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.util;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.StringWriter;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link StringUtil} class defines common String utility functions, which are used across the whole binding.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class StringUtil {\n+\n+    private static final int EOF = -1;\n+    private static final int DEFAULT_BUFFER_SIZE = 1024 * 4;\n+\n+    /**\n+     * Checks if a String is whitespace, empty (\"\") or null.\n+     *\n+     * @param str the String to check, may be null\n+     * @return true if the String is null, empty or whitespace\n+     */\n+    public static boolean isBlank(@Nullable String str) {\n+        int strLen;\n+        if (str == null || (strLen = str.length()) == 0) {\n+            return true;\n+        }\n+        for (int i = 0; i < strLen; i++) {\n+            if (!Character.isWhitespace(str.charAt(i))) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Returns either the passed in String, or if the String is whitespace, empty (\"\") or null, the value of defaultStr.\n+     *\n+     * @param str the String to check, may be null\n+     * @param defaultStr the default String to return\n+     * @return the passed in String, or the default\n+     */\n+    public static String defaultIfBlank(String str, String defaultStr) {\n+        return StringUtil.isBlank(str) ? defaultStr : str;\n+    }\n+\n+    /**\n+     * Strips whitespace from the start and end of a String returning null if the String is empty (\"\") after the strip.\n+     *\n+     * @param str the String to be stripped, may be null\n+     * @return the stripped String, null if whitespace, empty or null String input\n+     */\n+    public static @Nullable String stripToNull(@Nullable String str) {\n+        if (str == null || str.length() == 0) {\n+            return null;\n+        }\n+\n+        int strLen = str.length();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7793a4f48ce3b905430b78b943996752b41d59d8"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ0NzI5NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (str == null || str.length() == 0) {\n          \n          \n            \n                    if (str == null || str.isEmpty()) {", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r431447295", "createdAt": "2020-05-27T21:16:50Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/util/StringUtil.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.util;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.StringWriter;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link StringUtil} class defines common String utility functions, which are used across the whole binding.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class StringUtil {\n+\n+    private static final int EOF = -1;\n+    private static final int DEFAULT_BUFFER_SIZE = 1024 * 4;\n+\n+    /**\n+     * Checks if a String is whitespace, empty (\"\") or null.\n+     *\n+     * @param str the String to check, may be null\n+     * @return true if the String is null, empty or whitespace\n+     */\n+    public static boolean isBlank(@Nullable String str) {\n+        int strLen;\n+        if (str == null || (strLen = str.length()) == 0) {\n+            return true;\n+        }\n+        for (int i = 0; i < strLen; i++) {\n+            if (!Character.isWhitespace(str.charAt(i))) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Returns either the passed in String, or if the String is whitespace, empty (\"\") or null, the value of defaultStr.\n+     *\n+     * @param str the String to check, may be null\n+     * @param defaultStr the default String to return\n+     * @return the passed in String, or the default\n+     */\n+    public static String defaultIfBlank(String str, String defaultStr) {\n+        return StringUtil.isBlank(str) ? defaultStr : str;\n+    }\n+\n+    /**\n+     * Strips whitespace from the start and end of a String returning null if the String is empty (\"\") after the strip.\n+     *\n+     * @param str the String to be stripped, may be null\n+     * @return the stripped String, null if whitespace, empty or null String input\n+     */\n+    public static @Nullable String stripToNull(@Nullable String str) {\n+        if (str == null || str.length() == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7793a4f48ce3b905430b78b943996752b41d59d8"}, "originalPosition": 71}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e510d2e9f9049337f3a57322f5ff93f2887ed83b", "author": {"user": {"login": "MrRonfo", "name": "Fabio Possieri"}}, "url": "https://github.com/openhab/openhab-addons/commit/e510d2e9f9049337f3a57322f5ff93f2887ed83b", "committedDate": "2020-05-28T18:42:15Z", "message": "Some fixes applied following PR Review from fwolter.\n\nMoved API model classes to dto package, upgraded from old Date classes\nto LocalDate and LocalDateTime, optimized StringUtil methods.\n\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>\nSigned-off-by: Fabio Possieri <fabio.possieri@gmail.com>"}, "afterCommit": {"oid": "5c671cc66c8d8a0c0c06e1973c7c34c370a8f774", "author": {"user": {"login": "MrRonfo", "name": "Fabio Possieri"}}, "url": "https://github.com/openhab/openhab-addons/commit/5c671cc66c8d8a0c0c06e1973c7c34c370a8f774", "committedDate": "2020-05-29T19:16:22Z", "message": "Aligned pom.xml to OH 2.5.6 snapshot\n\nSigned-off-by: Fabio Possieri <fabio.possieri@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxNDI5MjIz", "url": "https://github.com/openhab/openhab-addons/pull/7533#pullrequestreview-421429223", "createdAt": "2020-05-30T17:21:37Z", "commit": {"oid": "5c671cc66c8d8a0c0c06e1973c7c34c370a8f774"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxNTEzNjU5", "url": "https://github.com/openhab/openhab-addons/pull/7533#pullrequestreview-421513659", "createdAt": "2020-05-31T17:36:57Z", "commit": {"oid": "88eb92825089dd1210be50cbdee1c754431c8736"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMVQxNzozNjo1N1rOGc6Q6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMVQxNzo1MTozMFrOGc6VZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk2NzkxMg==", "bodyText": "Can you make these Nullable?", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r432967912", "createdAt": "2020-05-31T17:36:57Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/handler/SmartherModuleHandler.java", "diffHunk": "@@ -0,0 +1,661 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.handler;\n+\n+import static org.openhab.binding.smarther.internal.SmartherBindingConstants.*;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.cache.ExpiringCache;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.scheduler.CronScheduler;\n+import org.eclipse.smarthome.core.scheduler.ScheduledCompletableFuture;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.smarther.internal.api.dto.Chronothermostat;\n+import org.openhab.binding.smarther.internal.api.dto.Enums.BoostTime;\n+import org.openhab.binding.smarther.internal.api.dto.Enums.Mode;\n+import org.openhab.binding.smarther.internal.api.dto.ModuleStatus;\n+import org.openhab.binding.smarther.internal.api.dto.Notification;\n+import org.openhab.binding.smarther.internal.api.dto.Program;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherGatewayException;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherSubscriptionAlreadyExistsException;\n+import org.openhab.binding.smarther.internal.config.SmartherModuleConfiguration;\n+import org.openhab.binding.smarther.internal.model.ModuleSettings;\n+import org.openhab.binding.smarther.internal.util.StringUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@code SmartherModuleHandler} class is responsible of a single Smarther Chronothermostat, handling the commands\n+ * that are sent to one of its channels.\n+ * Each Smarther Chronothermostat communicates with the Smarther API via its assigned {@code SmartherBridgeHandler}.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmartherModuleHandler extends BaseThingHandler {\n+\n+    private static final String DAILY_MIDNIGHT = \"1 0 0 * * ? *\";\n+    private static final long POLL_INITIAL_DELAY = 5;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private final CronScheduler cronScheduler;\n+    private final SmartherDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final ChannelUID programChannelUID;\n+    private final ChannelUID endDateChannelUID;\n+\n+    // Field members assigned in initialize method\n+    private @NonNullByDefault({}) ScheduledCompletableFuture<Void> jobFuture;\n+    private @NonNullByDefault({}) Future<?> pollFuture;\n+    private @NonNullByDefault({}) SmartherBridgeHandler bridgeHandler;\n+    private @NonNullByDefault({}) SmartherModuleConfiguration config;\n+\n+    // Chronothermostat local status\n+    private @NonNullByDefault({}) ExpiringCache<List<Program>> programCache;\n+    private @NonNullByDefault({}) Chronothermostat chronothermostat;\n+    private @NonNullByDefault({}) ModuleSettings moduleSettings;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88eb92825089dd1210be50cbdee1c754431c8736"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk2ODE1NQ==", "bodyText": "You should validate the command content before passing it to any fromValue OR make SmartherIllegalPropertyValueException also a checked exception and catch it here.", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r432968155", "createdAt": "2020-05-31T17:40:22Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/handler/SmartherModuleHandler.java", "diffHunk": "@@ -0,0 +1,661 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.handler;\n+\n+import static org.openhab.binding.smarther.internal.SmartherBindingConstants.*;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.cache.ExpiringCache;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.scheduler.CronScheduler;\n+import org.eclipse.smarthome.core.scheduler.ScheduledCompletableFuture;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.smarther.internal.api.dto.Chronothermostat;\n+import org.openhab.binding.smarther.internal.api.dto.Enums.BoostTime;\n+import org.openhab.binding.smarther.internal.api.dto.Enums.Mode;\n+import org.openhab.binding.smarther.internal.api.dto.ModuleStatus;\n+import org.openhab.binding.smarther.internal.api.dto.Notification;\n+import org.openhab.binding.smarther.internal.api.dto.Program;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherGatewayException;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherSubscriptionAlreadyExistsException;\n+import org.openhab.binding.smarther.internal.config.SmartherModuleConfiguration;\n+import org.openhab.binding.smarther.internal.model.ModuleSettings;\n+import org.openhab.binding.smarther.internal.util.StringUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@code SmartherModuleHandler} class is responsible of a single Smarther Chronothermostat, handling the commands\n+ * that are sent to one of its channels.\n+ * Each Smarther Chronothermostat communicates with the Smarther API via its assigned {@code SmartherBridgeHandler}.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmartherModuleHandler extends BaseThingHandler {\n+\n+    private static final String DAILY_MIDNIGHT = \"1 0 0 * * ? *\";\n+    private static final long POLL_INITIAL_DELAY = 5;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private final CronScheduler cronScheduler;\n+    private final SmartherDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final ChannelUID programChannelUID;\n+    private final ChannelUID endDateChannelUID;\n+\n+    // Field members assigned in initialize method\n+    private @NonNullByDefault({}) ScheduledCompletableFuture<Void> jobFuture;\n+    private @NonNullByDefault({}) Future<?> pollFuture;\n+    private @NonNullByDefault({}) SmartherBridgeHandler bridgeHandler;\n+    private @NonNullByDefault({}) SmartherModuleConfiguration config;\n+\n+    // Chronothermostat local status\n+    private @NonNullByDefault({}) ExpiringCache<List<Program>> programCache;\n+    private @NonNullByDefault({}) Chronothermostat chronothermostat;\n+    private @NonNullByDefault({}) ModuleSettings moduleSettings;\n+\n+    /**\n+     * Constructs a {@code SmartherModuleHandler} for the given thing, scheduler and dynamic state description provider.\n+     *\n+     * @param thing\n+     *            the {@link Thing} thing to be used\n+     * @param scheduler\n+     *            the {@link CronScheduler} periodic job scheduler to be used\n+     * @param provider\n+     *            the {@link SmartherDynamicStateDescriptionProvider} dynamic state description provider to be used\n+     */\n+    public SmartherModuleHandler(Thing thing, CronScheduler scheduler,\n+            SmartherDynamicStateDescriptionProvider provider) {\n+        super(thing);\n+        this.cronScheduler = scheduler;\n+        this.dynamicStateDescriptionProvider = provider;\n+        this.programChannelUID = new ChannelUID(thing.getUID(), CHANNEL_SETTINGS_PROGRAM);\n+        this.endDateChannelUID = new ChannelUID(thing.getUID(), CHANNEL_SETTINGS_ENDDATE);\n+    }\n+\n+    // ===========================================================================\n+    //\n+    // Chronothermostat thing lifecycle management methods\n+    //\n+    // ===========================================================================\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Module[{}] Initialize handler\", thing.getUID());\n+\n+        Bridge bridge = getBridge();\n+        if (bridge == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            return;\n+        }\n+\n+        bridgeHandler = (SmartherBridgeHandler) bridge.getHandler();\n+        if (bridgeHandler == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, String.format(\n+                    \"Missing configuration from the Smarther Bridge (UID:%s). Fix configuration or report if this problem remains.\",\n+                    bridge.getBridgeUID()));\n+            return;\n+        }\n+\n+        config = getConfigAs(SmartherModuleConfiguration.class);\n+        if (StringUtil.isBlank(config.getPlantId())) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Plant Id' property is not set or empty. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+        if (StringUtil.isBlank(config.getModuleId())) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Module Id' property is not set or empty. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+        if (config.getProgramsRefreshPeriod() <= 0) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Programs Refresh Period' must be > 0. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+        if (config.getStatusRefreshPeriod() <= 0) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Module Status Refresh Period' must be > 0. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+\n+        programCache = new ExpiringCache<>(Duration.ofHours(config.getProgramsRefreshPeriod()),\n+                this::programCacheAction);\n+        moduleSettings = new ModuleSettings(config.getPlantId(), config.getModuleId());\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduleJob();\n+        schedulePoll();\n+\n+        logger.debug(\"Module[{}] Finished initializing!\", thing.getUID());\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        try {\n+            handleCommandInternal(channelUID, command);\n+\n+            updateModuleStatus();\n+        } catch (SmartherGatewayException ex) {\n+            // catch exceptions and handle it in your binding\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, ex.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Handles the command sent to a given Channel of this Chronothermostat.\n+     *\n+     * @param channelUID\n+     *            the identifier of the Channel\n+     * @param command\n+     *            the command sent to the given Channel\n+     *\n+     * @throws {@link SmartherGatewayException}\n+     *             in case of communication issues with the Smarther API\n+     */\n+    private void handleCommandInternal(ChannelUID channelUID, Command command) throws SmartherGatewayException {\n+        switch (channelUID.getId()) {\n+            case CHANNEL_SETTINGS_MODE:\n+                if (command instanceof StringType) {\n+                    moduleSettings.setMode(Mode.fromValue(command.toString()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88eb92825089dd1210be50cbdee1c754431c8736"}, "originalPosition": 193}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk2ODYxMA==", "bodyText": "This exception is never catched. You could log it and simply return. Then, you could remove this (unchecked) exception completely. If you're fancy, you could respond with a 500 Internal Server Error additionally.", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r432968610", "createdAt": "2020-05-31T17:45:55Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/account/SmartherNotificationServlet.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.account;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.smarther.internal.api.dto.Notification;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherGatewayException;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherNotificationException;\n+import org.openhab.binding.smarther.internal.util.ModelUtil;\n+import org.openhab.binding.smarther.internal.util.StringUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.reflect.TypeToken;\n+\n+/**\n+ * The {@code SmartherNotificationServlet} class acts as the registered endpoint to receive module status notifications\n+ * from the Legrand/Bticino C2C Webhook notification service.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmartherNotificationServlet extends HttpServlet {\n+\n+    private static final long serialVersionUID = -2474355132186048438L;\n+\n+    private static final String CONTENT_TYPE = \"application/json;charset=UTF-8\";\n+    private static final String OK_RESULT_MSG = \"{\\\"result\\\":0}\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private final SmartherAccountService accountService;\n+\n+    /**\n+     * Constructs a {@code SmartherNotificationServlet} associated to the given {@link SmartherAccountService} service.\n+     *\n+     * @param accountService\n+     *            the account service to associate to the servlet\n+     */\n+    public SmartherNotificationServlet(SmartherAccountService accountService) {\n+        this.accountService = accountService;\n+    }\n+\n+    @Override\n+    protected void doPost(@Nullable HttpServletRequest req, @Nullable HttpServletResponse resp)\n+            throws ServletException, IOException {\n+        if (req == null || resp == null) {\n+            throw new SmartherNotificationException(\"Notification callback with null request/response\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88eb92825089dd1210be50cbdee1c754431c8736"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjk2OTA2Mg==", "bodyText": "It's implicitly derived from DiscoveryService via AbstractDiscoveryService.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            public class SmartherModuleDiscoveryService extends AbstractDiscoveryService\n          \n          \n            \n                    implements DiscoveryService, ThingHandlerService {\n          \n          \n            \n            public class SmartherModuleDiscoveryService extends AbstractDiscoveryService\n          \n          \n            \n                    implements ThingHandlerService {", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r432969062", "createdAt": "2020-05-31T17:51:30Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/discovery/SmartherModuleDiscoveryService.java", "diffHunk": "@@ -0,0 +1,173 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.discovery;\n+\n+import static org.openhab.binding.smarther.internal.SmartherBindingConstants.*;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.openhab.binding.smarther.internal.account.SmartherAccountHandler;\n+import org.openhab.binding.smarther.internal.api.dto.Location;\n+import org.openhab.binding.smarther.internal.api.dto.Module;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@code SmartherModuleDiscoveryService} queries the Smarther API gateway to discover available Chronothermostat\n+ * modules inside existing plants registered under the configured Bridges.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.smarther\")\n+@NonNullByDefault\n+public class SmartherModuleDiscoveryService extends AbstractDiscoveryService\n+        implements DiscoveryService, ThingHandlerService {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "88eb92825089dd1210be50cbdee1c754431c8736"}, "originalPosition": 51}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI3NDcxOTc2", "url": "https://github.com/openhab/openhab-addons/pull/7533#pullrequestreview-427471976", "createdAt": "2020-06-09T19:24:26Z", "commit": {"oid": "ae593650e21d2592486a7e36653f6f7345c1fd40"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxOToyNDoyNlrOGhY8cQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxOTo1NToxOVrOGhZ7wA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY2NDg4MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return (programs != null) ? programs : new ArrayList<>();\n          \n          \n            \n                    return (programs != null) ? programs : Collections.emptyList();", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r437664881", "createdAt": "2020-06-09T19:24:26Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/api/dto/Chronothermostat.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.api.dto;\n+\n+import static org.openhab.binding.smarther.internal.SmartherBindingConstants.*;\n+\n+import java.time.ZonedDateTime;\n+import java.time.format.DateTimeParseException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.smarther.internal.api.dto.Enums.LoadState;\n+import org.openhab.binding.smarther.internal.api.dto.Enums.MeasureUnit;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherIllegalPropertyValueException;\n+import org.openhab.binding.smarther.internal.util.DateUtil;\n+\n+import com.google.gson.annotations.SerializedName;\n+\n+/**\n+ * The {@code Chronothermostat} class defines the dto for Smarther API chronothermostat object.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+public class Chronothermostat {\n+\n+    private static final String TIME_FOREVER = \"Forever\";\n+\n+    private String function;\n+    private String mode;\n+    @SerializedName(\"setPoint\")\n+    private Measure setPointTemperature;\n+    private List<Program> programs;\n+    @SerializedName(\"temperatureFormat\")\n+    private String temperatureFormat;\n+    @SerializedName(\"loadState\")\n+    private String loadState;\n+    @SerializedName(\"activationTime\")\n+    private String activationTime;\n+    private String time;\n+    private Sensor thermometer;\n+    private Sensor hygrometer;\n+    private boolean online;\n+    private Sender sender;\n+\n+    /**\n+     * Returns the operational function of this chronothermostat module.\n+     *\n+     * @return a string containing the module operational function\n+     */\n+    public String getFunction() {\n+        return function;\n+    }\n+\n+    /**\n+     * Returns the operational mode of this chronothermostat module.\n+     *\n+     * @return a string containing the module operational mode\n+     */\n+    public String getMode() {\n+        return mode;\n+    }\n+\n+    /**\n+     * Returns the operational setpoint temperature of this chronothermostat module.\n+     *\n+     * @return a {@link Measure} object representing the module operational setpoint temperature\n+     */\n+    public Measure getSetPointTemperature() {\n+        return setPointTemperature;\n+    }\n+\n+    /**\n+     * Returns the list of programs registered on this chronothermostat module.\n+     *\n+     * @return the list of registered programs, or an empty list in case of no programs available\n+     */\n+    public List<Program> getPrograms() {\n+        return (programs != null) ? programs : new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae593650e21d2592486a7e36653f6f7345c1fd40"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY3MDUxMw==", "bodyText": "ThingHandlerService instances should not be osgi components. Osgi components are singletons whereas a new ThingHandlerService instance is created for each handler that uses it as a services. So pick one or the other.", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r437670513", "createdAt": "2020-06-09T19:35:19Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/discovery/SmartherModuleDiscoveryService.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.discovery;\n+\n+import static org.openhab.binding.smarther.internal.SmartherBindingConstants.*;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.openhab.binding.smarther.internal.account.SmartherAccountHandler;\n+import org.openhab.binding.smarther.internal.api.dto.Location;\n+import org.openhab.binding.smarther.internal.api.dto.Module;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@code SmartherModuleDiscoveryService} queries the Smarther API gateway to discover available Chronothermostat\n+ * modules inside existing plants registered under the configured Bridges.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.smarther\")\n+@NonNullByDefault\n+public class SmartherModuleDiscoveryService extends AbstractDiscoveryService implements ThingHandlerService {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae593650e21d2592486a7e36653f6f7345c1fd40"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY3MjUwNA==", "bodyText": "Use of @NonNullByDefault({}) should be avoided wherever possible. I suggest populating these fields in through the SmartherHandlerFactory constructor and then making these fields final.", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r437672504", "createdAt": "2020-06-09T19:39:04Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/factory/SmartherHandlerFactory.java", "diffHunk": "@@ -0,0 +1,122 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.factory;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthFactory;\n+import org.eclipse.smarthome.core.scheduler.CronScheduler;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.eclipse.smarthome.io.net.http.HttpClientFactory;\n+import org.openhab.binding.smarther.internal.SmartherBindingConstants;\n+import org.openhab.binding.smarther.internal.account.SmartherAccountService;\n+import org.openhab.binding.smarther.internal.handler.SmartherBridgeHandler;\n+import org.openhab.binding.smarther.internal.handler.SmartherDynamicStateDescriptionProvider;\n+import org.openhab.binding.smarther.internal.handler.SmartherModuleHandler;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@code SmartherHandlerFactory} class is responsible for creating things and thing handlers.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@Component(service = ThingHandlerFactory.class, configurationPid = \"binding.smarther\")\n+@NonNullByDefault\n+public class SmartherHandlerFactory extends BaseThingHandlerFactory {\n+\n+    private @NonNullByDefault({}) OAuthFactory oAuthFactory;\n+    private @NonNullByDefault({}) SmartherAccountService authService;\n+    private @NonNullByDefault({}) HttpClient httpClient;\n+    private @NonNullByDefault({}) CronScheduler cronScheduler;\n+    private @NonNullByDefault({}) SmartherDynamicStateDescriptionProvider dynamicStateDescriptionProvider;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae593650e21d2592486a7e36653f6f7345c1fd40"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY3NTk2MA==", "bodyText": "unit attribute might be wrong.", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r437675960", "createdAt": "2020-06-09T19:45:26Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.smarther/src/main/resources/ESH-INF/config/config.xml", "diffHunk": "@@ -0,0 +1,141 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<config-description:config-descriptions\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:config-description=\"https://openhab.org/schemas/config-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/config-description/v1.0.0 https://openhab.org/schemas/config-description-1.0.0.xsd\">\n+\n+\t<!-- Config for Smarther Bridge -->\n+\t<config-description uri=\"bridge-type:smarther:bridge\">\n+\n+\t\t<!-- Parameter groups -->\n+\t\t<parameter-group name=\"subscription\">\n+\t\t\t<label>Product Subscription</label>\n+\t\t\t<description>Details of the Smarther product subscription connected to the BTicino/Legrand development account.</description>\n+\t\t</parameter-group>\n+\n+\t\t<parameter-group name=\"application\">\n+\t\t\t<label>Application Details</label>\n+\t\t\t<description>Details of the Smarther application registered on the BTicino/Legrand development portal.</description>\n+\t\t</parameter-group>\n+\n+\t\t<parameter-group name=\"advancedset\">\n+\t\t\t<label>Advanced Settings</label>\n+\t\t\t<description>Advanced settings of this bridge.</description>\n+\t\t</parameter-group>\n+\n+\t\t<!-- Parameters -->\n+\t\t<parameter name=\"subscriptionKey\" groupName=\"subscription\" type=\"text\" pattern=\"[0-9a-f]{32}\">\n+\t\t\t<label>Subscription Key</label>\n+\t\t\t<description>This is the Subscription Key provided by BTicino/Legrand when you subscribe to Smarther - v2.0 product. Go to\n+https://developer.legrand.com/tutorials/getting-started/</description>\n+\t\t\t<required>true</required>\n+\t\t</parameter>\n+\n+\t\t<parameter name=\"clientId\" groupName=\"application\" type=\"text\" pattern=\"[0-9a-f]{8}[-]([0-9a-f]{4}[-]){3}[0-9a-f]{12}\">\n+\t\t\t<label>Client ID</label>\n+\t\t\t<description>This is the Client ID provided by BTicino/Legrand when you add a new Application to your developer account. Go to\n+https://developer.legrand.com/tutorials/create-an-application/</description>\n+\t\t\t<required>true</required>\n+\t\t</parameter>\n+\n+\t\t<parameter name=\"clientSecret\" groupName=\"application\" type=\"text\">\n+\t\t\t<label>Client Secret</label>\n+\t\t\t<description>This is the Client Secret provided by BTicino/Legrand when you add a new Application to your developer account.</description>\n+\t\t\t<required>true</required>\n+\t\t\t<context>password</context>\n+\t\t</parameter>\n+\n+\t\t<parameter name=\"useNotifications\" groupName=\"advancedset\" type=\"boolean\">\n+\t\t\t<label>Use Notifications</label>\n+\t\t\t<description>ON = the bridge subscribes each of its locations to receive C2C notifications upon changes on each of its modules' status or sensors\n+data - temperature, humidity (requires a public https endpoint has been set as \"First Reply Url\" when registering the Application on Legrand's development\n+portal); OFF = for each module connected to this bridge, status+sensors data are requested to Smarther API gateway on a periodical basis and whenever new\n+settings are applied (period can be changed via module's \"Status Refresh Period\" parameter).</description>\n+\t\t\t<required>false</required>\n+\t\t\t<advanced>true</advanced>\n+\t\t\t<default>true</default>\n+\t\t</parameter>\n+\n+\t\t<parameter name=\"statusRefreshPeriod\" groupName=\"advancedset\" type=\"integer\" min=\"1\" unit=\"min\">\n+\t\t\t<label>Bridge Status Refresh Period (minutes)</label>\n+\t\t\t<description>This is the frequency the Smarther API gateway is called to update bridge status. There are limits to the number of\n+requests that can be sent to the Smarther API gateway. The more often you poll, the faster locations are updated - at the risk of running out of your request\n+quota.</description>\n+\t\t\t<required>false</required>\n+\t\t\t<advanced>true</advanced>\n+\t\t\t<unitLabel>Minutes</unitLabel>\n+\t\t\t<default>1440</default>\n+\t\t</parameter>\n+\n+\t</config-description>\n+\n+\t<!-- Config for Smarther Module -->\n+\t<config-description uri=\"thing-type:smarther:module\">\n+\n+\t\t<!-- Parameter groups -->\n+\t\t<parameter-group name=\"topology\">\n+\t\t\t<label>Module Topology</label>\n+\t\t\t<description>Reference to uniquely identify the module towards the BTicino/Legrand API gateway.</description>\n+\t\t</parameter-group>\n+\n+\t\t<parameter-group name=\"advancedset\">\n+\t\t\t<label>Advanced Settings</label>\n+\t\t\t<description>Advanced settings of this module.</description>\n+\t\t</parameter-group>\n+\n+\t\t<!-- Parameters -->\n+\t\t<parameter name=\"plantId\" groupName=\"topology\" type=\"text\" pattern=\"[0-9a-f]{8}[-]([0-9a-f]{4}[-]){3}[0-9a-f]{12}\">\n+\t\t\t<label>Location Plant Id</label>\n+\t\t\t<description>This is the Plant Id of the location the Chronothermostat module is installed in, provided by Smarther API.</description>\n+\t\t\t<required>true</required>\n+\t\t</parameter>\n+\n+\t\t<parameter name=\"moduleId\" groupName=\"topology\" type=\"text\" pattern=\"[0-9a-f]{8}[-]([0-9a-f]{4}[-]){3}[0-9a-f]{12}\">\n+\t\t\t<label>Chronothermostat Module Id</label>\n+\t\t\t<description>This is the Module Id of the Chronothermostat module, provided by Smarther API.</description>\n+\t\t\t<required>true</required>\n+\t\t</parameter>\n+\n+\t\t<parameter name=\"settingsAutoupdate\" groupName=\"advancedset\" type=\"boolean\">\n+\t\t\t<label>Module Settings Auto-Update</label>\n+\t\t\t<description>ON = the module settings are automatically updated according to the module status whenever it changes (e.g. polling, notification,\n+etc.). OFF = the module settings are aligned to the module status only upon module initialization.</description>\n+\t\t\t<required>false</required>\n+\t\t\t<advanced>true</advanced>\n+\t\t\t<default>false</default>\n+\t\t</parameter>\n+\n+\t\t<parameter name=\"programsRefreshPeriod\" groupName=\"advancedset\" type=\"integer\" min=\"1\" unit=\"min\">\n+\t\t\t<label>Programs Refresh Period (hours)</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae593650e21d2592486a7e36653f6f7345c1fd40"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY4MTA4OA==", "bodyText": "Please avoid using @NonNullByDefault({}). Use @Nullable instead. Most of the null checker warnings can be resolved by caching the fields to local variables and performing your logic on those local variables instead.", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r437681088", "createdAt": "2020-06-09T19:55:19Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/handler/SmartherBridgeHandler.java", "diffHunk": "@@ -0,0 +1,699 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.handler;\n+\n+import static org.openhab.binding.smarther.internal.SmartherBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.net.InetAddress;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.UnknownHostException;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.auth.client.oauth2.AccessTokenRefreshListener;\n+import org.eclipse.smarthome.core.auth.client.oauth2.AccessTokenResponse;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthClientService;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthException;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthFactory;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthResponseException;\n+import org.eclipse.smarthome.core.cache.ExpiringCache;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.smarther.internal.account.SmartherAccountHandler;\n+import org.openhab.binding.smarther.internal.account.SmartherNotificationHandler;\n+import org.openhab.binding.smarther.internal.api.SmartherApi;\n+import org.openhab.binding.smarther.internal.api.dto.Location;\n+import org.openhab.binding.smarther.internal.api.dto.Module;\n+import org.openhab.binding.smarther.internal.api.dto.ModuleStatus;\n+import org.openhab.binding.smarther.internal.api.dto.Notification;\n+import org.openhab.binding.smarther.internal.api.dto.Plant;\n+import org.openhab.binding.smarther.internal.api.dto.Program;\n+import org.openhab.binding.smarther.internal.api.dto.Sender;\n+import org.openhab.binding.smarther.internal.api.dto.Subscription;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherAuthorizationException;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherGatewayException;\n+import org.openhab.binding.smarther.internal.config.SmartherBridgeConfiguration;\n+import org.openhab.binding.smarther.internal.discovery.SmartherModuleDiscoveryService;\n+import org.openhab.binding.smarther.internal.model.BridgeStatus;\n+import org.openhab.binding.smarther.internal.model.ModuleSettings;\n+import org.openhab.binding.smarther.internal.util.StringUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@code SmartherBridgeHandler} class is responsible of the handling of a Smarther Bridge thing.\n+ * The Smarther Bridge is used to manage a set of Smarther Chronothermostat Modules registered under the same\n+ * Legrand/Bticino account credentials.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmartherBridgeHandler extends BaseBridgeHandler\n+        implements SmartherAccountHandler, SmartherNotificationHandler, AccessTokenRefreshListener {\n+\n+    private static final long POLL_INITIAL_DELAY = 5;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private final OAuthFactory oAuthFactory;\n+    private final HttpClient httpClient;\n+\n+    // Field members assigned in initialize method\n+    private @NonNullByDefault({}) Future<?> pollFuture;\n+    private @NonNullByDefault({}) OAuthClientService oAuthService;\n+    private @NonNullByDefault({}) SmartherApi smartherApi;\n+    private @NonNullByDefault({}) SmartherBridgeConfiguration config;\n+\n+    // Bridge local status\n+    private @NonNullByDefault({}) ExpiringCache<List<Location>> locationCache;\n+    private @NonNullByDefault({}) BridgeStatus bridgeStatus;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae593650e21d2592486a7e36653f6f7345c1fd40"}, "originalPosition": 105}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI5Mzk0OTIz", "url": "https://github.com/openhab/openhab-addons/pull/7533#pullrequestreview-429394923", "createdAt": "2020-06-12T00:52:43Z", "commit": {"oid": "b76ea0c1193e57298bdea1f8bcae9b3f10b90950"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQwMDo1Mjo0NFrOGizqRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQwMToyNDoyMlrOGi0IMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE1MTE3Mg==", "bodyText": "No need to parse a config you shouldn't use.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    this.config = getConfigAs(SmartherBridgeConfiguration.class);\n          \n          \n            \n                    this.config = new SmartherBridgeConfiguration();", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r439151172", "createdAt": "2020-06-12T00:52:44Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/handler/SmartherBridgeHandler.java", "diffHunk": "@@ -0,0 +1,767 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.handler;\n+\n+import static org.openhab.binding.smarther.internal.SmartherBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.net.InetAddress;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.UnknownHostException;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.auth.client.oauth2.AccessTokenRefreshListener;\n+import org.eclipse.smarthome.core.auth.client.oauth2.AccessTokenResponse;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthClientService;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthException;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthFactory;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthResponseException;\n+import org.eclipse.smarthome.core.cache.ExpiringCache;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.smarther.internal.account.SmartherAccountHandler;\n+import org.openhab.binding.smarther.internal.account.SmartherNotificationHandler;\n+import org.openhab.binding.smarther.internal.api.SmartherApi;\n+import org.openhab.binding.smarther.internal.api.dto.Location;\n+import org.openhab.binding.smarther.internal.api.dto.Module;\n+import org.openhab.binding.smarther.internal.api.dto.ModuleStatus;\n+import org.openhab.binding.smarther.internal.api.dto.Notification;\n+import org.openhab.binding.smarther.internal.api.dto.Plant;\n+import org.openhab.binding.smarther.internal.api.dto.Program;\n+import org.openhab.binding.smarther.internal.api.dto.Sender;\n+import org.openhab.binding.smarther.internal.api.dto.Subscription;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherAuthorizationException;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherGatewayException;\n+import org.openhab.binding.smarther.internal.config.SmartherBridgeConfiguration;\n+import org.openhab.binding.smarther.internal.discovery.SmartherModuleDiscoveryService;\n+import org.openhab.binding.smarther.internal.model.BridgeStatus;\n+import org.openhab.binding.smarther.internal.model.ModuleSettings;\n+import org.openhab.binding.smarther.internal.util.StringUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@code SmartherBridgeHandler} class is responsible of the handling of a Smarther Bridge thing.\n+ * The Smarther Bridge is used to manage a set of Smarther Chronothermostat Modules registered under the same\n+ * Legrand/Bticino account credentials.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmartherBridgeHandler extends BaseBridgeHandler\n+        implements SmartherAccountHandler, SmartherNotificationHandler, AccessTokenRefreshListener {\n+\n+    private static final long POLL_INITIAL_DELAY = 5;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private final OAuthFactory oAuthFactory;\n+    private final HttpClient httpClient;\n+\n+    // Bridge configuration\n+    private SmartherBridgeConfiguration config;\n+\n+    // Field members assigned in initialize method\n+    private @Nullable Future<?> pollFuture;\n+    private @Nullable OAuthClientService oAuthService;\n+    private @Nullable SmartherApi smartherApi;\n+    private @Nullable ExpiringCache<List<Location>> locationCache;\n+    private @Nullable BridgeStatus bridgeStatus;\n+\n+    /**\n+     * Constructs a {@code SmartherBridgeHandler} for the given Bridge thing, authorization factory and http client.\n+     *\n+     * @param bridge\n+     *            the {@link Bridge} thing to be used\n+     * @param oAuthFactory\n+     *            the OAuth2 authorization factory to be used\n+     * @param httpClient\n+     *            the http client to be used\n+     */\n+    public SmartherBridgeHandler(Bridge bridge, OAuthFactory oAuthFactory, HttpClient httpClient) {\n+        super(bridge);\n+        this.oAuthFactory = oAuthFactory;\n+        this.httpClient = httpClient;\n+        this.config = getConfigAs(SmartherBridgeConfiguration.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b76ea0c1193e57298bdea1f8bcae9b3f10b90950"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE1MTc5OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return (locations != null) ? locations : new ArrayList<>();\n          \n          \n            \n                    return (locations != null) ? locations : Collections.emptyList();", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r439151799", "createdAt": "2020-06-12T00:55:22Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/handler/SmartherBridgeHandler.java", "diffHunk": "@@ -0,0 +1,767 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.handler;\n+\n+import static org.openhab.binding.smarther.internal.SmartherBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.net.InetAddress;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.UnknownHostException;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.auth.client.oauth2.AccessTokenRefreshListener;\n+import org.eclipse.smarthome.core.auth.client.oauth2.AccessTokenResponse;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthClientService;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthException;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthFactory;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthResponseException;\n+import org.eclipse.smarthome.core.cache.ExpiringCache;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.smarther.internal.account.SmartherAccountHandler;\n+import org.openhab.binding.smarther.internal.account.SmartherNotificationHandler;\n+import org.openhab.binding.smarther.internal.api.SmartherApi;\n+import org.openhab.binding.smarther.internal.api.dto.Location;\n+import org.openhab.binding.smarther.internal.api.dto.Module;\n+import org.openhab.binding.smarther.internal.api.dto.ModuleStatus;\n+import org.openhab.binding.smarther.internal.api.dto.Notification;\n+import org.openhab.binding.smarther.internal.api.dto.Plant;\n+import org.openhab.binding.smarther.internal.api.dto.Program;\n+import org.openhab.binding.smarther.internal.api.dto.Sender;\n+import org.openhab.binding.smarther.internal.api.dto.Subscription;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherAuthorizationException;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherGatewayException;\n+import org.openhab.binding.smarther.internal.config.SmartherBridgeConfiguration;\n+import org.openhab.binding.smarther.internal.discovery.SmartherModuleDiscoveryService;\n+import org.openhab.binding.smarther.internal.model.BridgeStatus;\n+import org.openhab.binding.smarther.internal.model.ModuleSettings;\n+import org.openhab.binding.smarther.internal.util.StringUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@code SmartherBridgeHandler} class is responsible of the handling of a Smarther Bridge thing.\n+ * The Smarther Bridge is used to manage a set of Smarther Chronothermostat Modules registered under the same\n+ * Legrand/Bticino account credentials.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmartherBridgeHandler extends BaseBridgeHandler\n+        implements SmartherAccountHandler, SmartherNotificationHandler, AccessTokenRefreshListener {\n+\n+    private static final long POLL_INITIAL_DELAY = 5;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private final OAuthFactory oAuthFactory;\n+    private final HttpClient httpClient;\n+\n+    // Bridge configuration\n+    private SmartherBridgeConfiguration config;\n+\n+    // Field members assigned in initialize method\n+    private @Nullable Future<?> pollFuture;\n+    private @Nullable OAuthClientService oAuthService;\n+    private @Nullable SmartherApi smartherApi;\n+    private @Nullable ExpiringCache<List<Location>> locationCache;\n+    private @Nullable BridgeStatus bridgeStatus;\n+\n+    /**\n+     * Constructs a {@code SmartherBridgeHandler} for the given Bridge thing, authorization factory and http client.\n+     *\n+     * @param bridge\n+     *            the {@link Bridge} thing to be used\n+     * @param oAuthFactory\n+     *            the OAuth2 authorization factory to be used\n+     * @param httpClient\n+     *            the http client to be used\n+     */\n+    public SmartherBridgeHandler(Bridge bridge, OAuthFactory oAuthFactory, HttpClient httpClient) {\n+        super(bridge);\n+        this.oAuthFactory = oAuthFactory;\n+        this.httpClient = httpClient;\n+        this.config = getConfigAs(SmartherBridgeConfiguration.class);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(SmartherModuleDiscoveryService.class);\n+    }\n+\n+    // ===========================================================================\n+    //\n+    // Bridge thing lifecycle management methods\n+    //\n+    // ===========================================================================\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Bridge[{}] Initialize handler\", thing.getUID());\n+\n+        this.config = getConfigAs(SmartherBridgeConfiguration.class);\n+        if (StringUtil.isBlank(config.getSubscriptionKey())) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Subscription Key' property is not set or empty. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+        if (StringUtil.isBlank(config.getClientId())) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Client Id' property is not set or empty. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+        if (StringUtil.isBlank(config.getClientSecret())) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Client Secret' property is not set or empty. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+\n+        // Initialize OAuth2 authentication support\n+        final OAuthClientService localOAuthService = oAuthFactory.createOAuthClientService(thing.getUID().getAsString(),\n+                SMARTHER_API_TOKEN_URL, SMARTHER_AUTHORIZE_URL, config.getClientId(), config.getClientSecret(),\n+                SMARTHER_API_SCOPES, false);\n+        localOAuthService.addAccessTokenRefreshListener(SmartherBridgeHandler.this);\n+        this.oAuthService = localOAuthService;\n+\n+        // Initialize Smarther Api\n+        final SmartherApi localSmartherApi = new SmartherApi(localOAuthService, config.getSubscriptionKey(), scheduler,\n+                httpClient);\n+        this.smartherApi = localSmartherApi;\n+\n+        // Initialize locations (plant Ids) local cache\n+        final ExpiringCache<List<Location>> localLocationCache = new ExpiringCache<>(\n+                Duration.ofMinutes(config.getStatusRefreshPeriod()), this::locationCacheAction);\n+        this.locationCache = localLocationCache;\n+\n+        // Initialize bridge local status\n+        final BridgeStatus localBridgeStatus = new BridgeStatus();\n+        this.bridgeStatus = localBridgeStatus;\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        schedulePoll();\n+\n+        logger.debug(\"Bridge[{}] Finished initializing!\", thing.getUID());\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        switch (channelUID.getId()) {\n+            case CHANNEL_FETCH_CONFIG:\n+                if (command instanceof OnOffType) {\n+                    if (OnOffType.ON.equals(command)) {\n+                        logger.debug(\"Bridge[{}] Manually triggered channel to refresh the Bridge config\",\n+                                thing.getUID());\n+                        schedulePoll();\n+                        updateChannelState(CHANNEL_FETCH_CONFIG, OnOffType.OFF);\n+                    }\n+                    return;\n+                }\n+                break;\n+        }\n+\n+        if (command instanceof RefreshType) {\n+            // Avoid logging wrong command when refresh command is sent\n+            return;\n+        }\n+\n+        logger.debug(\"Bridge[{}] Received command {} of wrong type {} on channel {}\", thing.getUID(), command,\n+                command.getClass().getTypeName(), channelUID.getId());\n+    }\n+\n+    @Override\n+    public void handleRemoval() {\n+        super.handleRemoval();\n+        stopPoll(true);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Bridge[{}] Dispose handler\", thing.getUID());\n+        final OAuthClientService localOAuthService = this.oAuthService;\n+        if (localOAuthService != null) {\n+            localOAuthService.removeAccessTokenRefreshListener(this);\n+        }\n+        this.oAuthFactory.ungetOAuthService(thing.getUID().getAsString());\n+        stopPoll(true);\n+        logger.debug(\"Bridge[{}] Finished disposing!\", thing.getUID());\n+    }\n+\n+    // ===========================================================================\n+    //\n+    // Bridge data cache management methods\n+    //\n+    // ===========================================================================\n+\n+    /**\n+     * Returns the available locations to be cached for this Bridge.\n+     *\n+     * @return the available locations to be cached for this Bridge, or {@code null} if the list of available locations\n+     *         cannot be retrieved\n+     */\n+    private @Nullable List<Location> locationCacheAction() {\n+        try {\n+            // Retrieve the plants list from the API Gateway\n+            final List<Plant> plants = getPlants();\n+\n+            List<Location> locations;\n+            if (config.isUseNotifications()) {\n+                // Retrieve the subscriptions list from the API Gateway\n+                final List<Subscription> subscriptions = getSubscriptions();\n+\n+                // Enrich the notifications list with externally registered subscriptions\n+                updateNotifications(subscriptions);\n+\n+                // Get the notifications list from bridge config\n+                final List<String> notifications = config.getNotifications();\n+\n+                locations = plants.stream().map(p -> Location.fromPlant(p, subscriptions.stream()\n+                        .filter(s -> s.getPlantId().equals(p.getId()) && notifications.contains(s.getSubscriptionId()))\n+                        .findFirst())).collect(Collectors.toList());\n+            } else {\n+                locations = plants.stream().map(p -> Location.fromPlant(p)).collect(Collectors.toList());\n+            }\n+            logger.debug(\"Bridge[{}] Available locations: {}\", thing.getUID(), locations);\n+\n+            return locations;\n+\n+        } catch (SmartherGatewayException e) {\n+            logger.warn(\"Bridge[{}] Cannot retrieve available locations: {}\", thing.getUID(), e.getMessage());\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Updates this Bridge local notifications list with externally registered subscriptions.\n+     *\n+     * @param subscriptions\n+     *            the externally registered subscriptions to be added to the local notifications list\n+     */\n+    private void updateNotifications(List<Subscription> subscriptions) {\n+        // Get the notifications list from bridge config\n+        List<String> notifications = config.getNotifications();\n+\n+        for (Subscription s : subscriptions) {\n+            if (s.getEndpointUrl().equalsIgnoreCase(config.getNotificationUrl())\n+                    && !notifications.contains(s.getSubscriptionId())) {\n+                // Add the external subscription to notifications list\n+                notifications = config.addNotification(s.getSubscriptionId());\n+\n+                // Save the updated notifications list back to bridge config\n+                Configuration configuration = editConfiguration();\n+                configuration.put(PROPERTY_NOTIFICATIONS, notifications);\n+                updateConfiguration(configuration);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Sets all the cache to \"expired\" for this Bridge.\n+     */\n+    private void expireCache() {\n+        logger.debug(\"Bridge[{}] Invalidating location cache\", thing.getUID());\n+        final ExpiringCache<List<Location>> localLocationCache = this.locationCache;\n+        if (localLocationCache != null) {\n+            localLocationCache.invalidateValue();\n+        }\n+    }\n+\n+    // ===========================================================================\n+    //\n+    // Bridge status polling mechanism methods\n+    //\n+    // ===========================================================================\n+\n+    /**\n+     * Starts a new scheduler to periodically poll and update this Bridge status.\n+     */\n+    private void schedulePoll() {\n+        stopPoll(false);\n+\n+        // Schedule poll to start after POLL_INITIAL_DELAY sec and run periodically based on status refresh period\n+        final Future<?> localPollFuture = scheduler.scheduleWithFixedDelay(this::poll, POLL_INITIAL_DELAY,\n+                config.getStatusRefreshPeriod() * 60, TimeUnit.SECONDS);\n+        this.pollFuture = localPollFuture;\n+\n+        logger.debug(\"Bridge[{}] Scheduled poll for {} sec out, then every {} min\", thing.getUID(), POLL_INITIAL_DELAY,\n+                config.getStatusRefreshPeriod());\n+    }\n+\n+    /**\n+     * Cancels all running poll schedulers.\n+     *\n+     * @param mayInterruptIfRunning\n+     *            {@code true} if the thread executing this task should be interrupted, {@code false} if the in-progress\n+     *            tasks are allowed to complete\n+     */\n+    private synchronized void stopPoll(boolean mayInterruptIfRunning) {\n+        final Future<?> localPollFuture = this.pollFuture;\n+        if (localPollFuture != null) {\n+            if (!localPollFuture.isCancelled()) {\n+                localPollFuture.cancel(mayInterruptIfRunning);\n+            }\n+            this.pollFuture = null;\n+        }\n+    }\n+\n+    /**\n+     * Polls to update this Bridge status, calling the Smarther API to refresh its plants list.\n+     *\n+     * @return {@code true} if the method completes without errors, {@code false} otherwise\n+     */\n+    private synchronized boolean poll() {\n+        try {\n+            onAccessTokenResponse(getAccessTokenResponse());\n+\n+            expireCache();\n+            locationCacheAction();\n+\n+            updateStatus(ThingStatus.ONLINE);\n+            return true;\n+\n+        } catch (SmartherAuthorizationException e) {\n+            logger.warn(\"Bridge[{}] Authorization error during polling: {}\", thing.getUID(), e.getMessage());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+            schedulePoll();\n+            return false;\n+        } catch (RuntimeException e) {\n+            // All other exceptions apart from Authorization and Gateway issues\n+            logger.warn(\"Bridge[{}] Unexpected error during polling, please report if this keeps occurring: \",\n+                    thing.getUID(), e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, e.getMessage());\n+            schedulePoll();\n+            return false;\n+        }\n+    }\n+\n+    @Override\n+    public void onAccessTokenResponse(@Nullable AccessTokenResponse tokenResponse) {\n+        updateChannelState(CHANNEL_ACCESS_TOKEN,\n+                new StringType((tokenResponse == null) ? null : tokenResponse.getAccessToken()));\n+    }\n+\n+    // ===========================================================================\n+    //\n+    // Bridge convenience methods\n+    //\n+    // ===========================================================================\n+\n+    /**\n+     * Convenience method to get this Bridge configuration.\n+     *\n+     * @return a {@link SmartherBridgeConfiguration} object containing the Bridge configuration\n+     */\n+    public SmartherBridgeConfiguration getSmartherBridgeConfig() {\n+        return config;\n+    }\n+\n+    /**\n+     * Convenience method to get the access token from Smarther API authorization layer.\n+     *\n+     * @return the autorization access token, may be {@code null}\n+     *\n+     * @throws {@link SmartherAuthorizationException}\n+     *             in case of authorization issues with the Smarther API\n+     */\n+    private @Nullable AccessTokenResponse getAccessTokenResponse() throws SmartherAuthorizationException {\n+        try {\n+            final OAuthClientService localOAuthService = this.oAuthService;\n+            if (localOAuthService != null) {\n+                return localOAuthService.getAccessTokenResponse();\n+            }\n+            return null;\n+        } catch (OAuthException | IOException | OAuthResponseException | RuntimeException e) {\n+            throw new SmartherAuthorizationException(e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Convenience method to update the given Channel state \"only\" if the Channel is linked.\n+     *\n+     * @param channelId\n+     *            the identifier of the Channel to be updated\n+     * @param state\n+     *            the new state to be applied to the given Channel\n+     */\n+    private void updateChannelState(String channelId, State state) {\n+        final Channel channel = thing.getChannel(channelId);\n+\n+        if (channel != null && isLinked(channel.getUID())) {\n+            updateState(channel.getUID(), state);\n+        }\n+    }\n+\n+    /**\n+     * Convenience method to update the Smarther API calls counter for this Bridge.\n+     */\n+    private void updateApiCallsCounter() {\n+        final BridgeStatus localBridgeStatus = this.bridgeStatus;\n+        if (localBridgeStatus != null) {\n+            updateChannelState(CHANNEL_API_CALLS_HANDLED,\n+                    new DecimalType(localBridgeStatus.incrementApiCallsHandled()));\n+        }\n+    }\n+\n+    /**\n+     * Convenience method to check and get the Smarther API instance for this Bridge.\n+     *\n+     * @return the Smarther API instance\n+     *\n+     * @throws {@link SmartherGatewayException}\n+     *             in case the Smarther API instance is {@code null}\n+     */\n+    private SmartherApi getSmartherApi() throws SmartherGatewayException {\n+        final SmartherApi localSmartherApi = this.smartherApi;\n+        if (localSmartherApi == null) {\n+            throw new SmartherGatewayException(\"Smarther API instance is null\");\n+        }\n+        return localSmartherApi;\n+    }\n+\n+    // ===========================================================================\n+    //\n+    // Implementation of the SmartherAccountHandler interface\n+    //\n+    // ===========================================================================\n+\n+    @Override\n+    public ThingUID getUID() {\n+        return thing.getUID();\n+    }\n+\n+    @Override\n+    public String getLabel() {\n+        return StringUtil.defaultString(thing.getLabel());\n+    }\n+\n+    @Override\n+    public List<Location> getLocations() {\n+        final ExpiringCache<List<Location>> localLocationCache = this.locationCache;\n+        final List<Location> locations = (localLocationCache != null) ? localLocationCache.getValue() : null;\n+        return (locations != null) ? locations : new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b76ea0c1193e57298bdea1f8bcae9b3f10b90950"}, "originalPosition": 478}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE1MjAwMA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        return \"\";\n          \n          \n            \n                    } catch (OAuthException e) {\n          \n          \n            \n                        logger.warn(\"Bridge[{}] Error constructing AuthorizationUrl: \", thing.getUID());\n          \n          \n            \n                        return \"\";\n          \n          \n            \n                    }\n          \n          \n            \n                    } catch (OAuthException e) {\n          \n          \n            \n                        logger.warn(\"Bridge[{}] Error constructing AuthorizationUrl: \", thing.getUID());\n          \n          \n            \n                    }\n          \n          \n            \n                    return \"\";", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r439152000", "createdAt": "2020-06-12T00:56:06Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/handler/SmartherBridgeHandler.java", "diffHunk": "@@ -0,0 +1,767 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.handler;\n+\n+import static org.openhab.binding.smarther.internal.SmartherBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.net.InetAddress;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.UnknownHostException;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.auth.client.oauth2.AccessTokenRefreshListener;\n+import org.eclipse.smarthome.core.auth.client.oauth2.AccessTokenResponse;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthClientService;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthException;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthFactory;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthResponseException;\n+import org.eclipse.smarthome.core.cache.ExpiringCache;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.smarther.internal.account.SmartherAccountHandler;\n+import org.openhab.binding.smarther.internal.account.SmartherNotificationHandler;\n+import org.openhab.binding.smarther.internal.api.SmartherApi;\n+import org.openhab.binding.smarther.internal.api.dto.Location;\n+import org.openhab.binding.smarther.internal.api.dto.Module;\n+import org.openhab.binding.smarther.internal.api.dto.ModuleStatus;\n+import org.openhab.binding.smarther.internal.api.dto.Notification;\n+import org.openhab.binding.smarther.internal.api.dto.Plant;\n+import org.openhab.binding.smarther.internal.api.dto.Program;\n+import org.openhab.binding.smarther.internal.api.dto.Sender;\n+import org.openhab.binding.smarther.internal.api.dto.Subscription;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherAuthorizationException;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherGatewayException;\n+import org.openhab.binding.smarther.internal.config.SmartherBridgeConfiguration;\n+import org.openhab.binding.smarther.internal.discovery.SmartherModuleDiscoveryService;\n+import org.openhab.binding.smarther.internal.model.BridgeStatus;\n+import org.openhab.binding.smarther.internal.model.ModuleSettings;\n+import org.openhab.binding.smarther.internal.util.StringUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@code SmartherBridgeHandler} class is responsible of the handling of a Smarther Bridge thing.\n+ * The Smarther Bridge is used to manage a set of Smarther Chronothermostat Modules registered under the same\n+ * Legrand/Bticino account credentials.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmartherBridgeHandler extends BaseBridgeHandler\n+        implements SmartherAccountHandler, SmartherNotificationHandler, AccessTokenRefreshListener {\n+\n+    private static final long POLL_INITIAL_DELAY = 5;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private final OAuthFactory oAuthFactory;\n+    private final HttpClient httpClient;\n+\n+    // Bridge configuration\n+    private SmartherBridgeConfiguration config;\n+\n+    // Field members assigned in initialize method\n+    private @Nullable Future<?> pollFuture;\n+    private @Nullable OAuthClientService oAuthService;\n+    private @Nullable SmartherApi smartherApi;\n+    private @Nullable ExpiringCache<List<Location>> locationCache;\n+    private @Nullable BridgeStatus bridgeStatus;\n+\n+    /**\n+     * Constructs a {@code SmartherBridgeHandler} for the given Bridge thing, authorization factory and http client.\n+     *\n+     * @param bridge\n+     *            the {@link Bridge} thing to be used\n+     * @param oAuthFactory\n+     *            the OAuth2 authorization factory to be used\n+     * @param httpClient\n+     *            the http client to be used\n+     */\n+    public SmartherBridgeHandler(Bridge bridge, OAuthFactory oAuthFactory, HttpClient httpClient) {\n+        super(bridge);\n+        this.oAuthFactory = oAuthFactory;\n+        this.httpClient = httpClient;\n+        this.config = getConfigAs(SmartherBridgeConfiguration.class);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(SmartherModuleDiscoveryService.class);\n+    }\n+\n+    // ===========================================================================\n+    //\n+    // Bridge thing lifecycle management methods\n+    //\n+    // ===========================================================================\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Bridge[{}] Initialize handler\", thing.getUID());\n+\n+        this.config = getConfigAs(SmartherBridgeConfiguration.class);\n+        if (StringUtil.isBlank(config.getSubscriptionKey())) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Subscription Key' property is not set or empty. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+        if (StringUtil.isBlank(config.getClientId())) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Client Id' property is not set or empty. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+        if (StringUtil.isBlank(config.getClientSecret())) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Client Secret' property is not set or empty. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+\n+        // Initialize OAuth2 authentication support\n+        final OAuthClientService localOAuthService = oAuthFactory.createOAuthClientService(thing.getUID().getAsString(),\n+                SMARTHER_API_TOKEN_URL, SMARTHER_AUTHORIZE_URL, config.getClientId(), config.getClientSecret(),\n+                SMARTHER_API_SCOPES, false);\n+        localOAuthService.addAccessTokenRefreshListener(SmartherBridgeHandler.this);\n+        this.oAuthService = localOAuthService;\n+\n+        // Initialize Smarther Api\n+        final SmartherApi localSmartherApi = new SmartherApi(localOAuthService, config.getSubscriptionKey(), scheduler,\n+                httpClient);\n+        this.smartherApi = localSmartherApi;\n+\n+        // Initialize locations (plant Ids) local cache\n+        final ExpiringCache<List<Location>> localLocationCache = new ExpiringCache<>(\n+                Duration.ofMinutes(config.getStatusRefreshPeriod()), this::locationCacheAction);\n+        this.locationCache = localLocationCache;\n+\n+        // Initialize bridge local status\n+        final BridgeStatus localBridgeStatus = new BridgeStatus();\n+        this.bridgeStatus = localBridgeStatus;\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        schedulePoll();\n+\n+        logger.debug(\"Bridge[{}] Finished initializing!\", thing.getUID());\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        switch (channelUID.getId()) {\n+            case CHANNEL_FETCH_CONFIG:\n+                if (command instanceof OnOffType) {\n+                    if (OnOffType.ON.equals(command)) {\n+                        logger.debug(\"Bridge[{}] Manually triggered channel to refresh the Bridge config\",\n+                                thing.getUID());\n+                        schedulePoll();\n+                        updateChannelState(CHANNEL_FETCH_CONFIG, OnOffType.OFF);\n+                    }\n+                    return;\n+                }\n+                break;\n+        }\n+\n+        if (command instanceof RefreshType) {\n+            // Avoid logging wrong command when refresh command is sent\n+            return;\n+        }\n+\n+        logger.debug(\"Bridge[{}] Received command {} of wrong type {} on channel {}\", thing.getUID(), command,\n+                command.getClass().getTypeName(), channelUID.getId());\n+    }\n+\n+    @Override\n+    public void handleRemoval() {\n+        super.handleRemoval();\n+        stopPoll(true);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Bridge[{}] Dispose handler\", thing.getUID());\n+        final OAuthClientService localOAuthService = this.oAuthService;\n+        if (localOAuthService != null) {\n+            localOAuthService.removeAccessTokenRefreshListener(this);\n+        }\n+        this.oAuthFactory.ungetOAuthService(thing.getUID().getAsString());\n+        stopPoll(true);\n+        logger.debug(\"Bridge[{}] Finished disposing!\", thing.getUID());\n+    }\n+\n+    // ===========================================================================\n+    //\n+    // Bridge data cache management methods\n+    //\n+    // ===========================================================================\n+\n+    /**\n+     * Returns the available locations to be cached for this Bridge.\n+     *\n+     * @return the available locations to be cached for this Bridge, or {@code null} if the list of available locations\n+     *         cannot be retrieved\n+     */\n+    private @Nullable List<Location> locationCacheAction() {\n+        try {\n+            // Retrieve the plants list from the API Gateway\n+            final List<Plant> plants = getPlants();\n+\n+            List<Location> locations;\n+            if (config.isUseNotifications()) {\n+                // Retrieve the subscriptions list from the API Gateway\n+                final List<Subscription> subscriptions = getSubscriptions();\n+\n+                // Enrich the notifications list with externally registered subscriptions\n+                updateNotifications(subscriptions);\n+\n+                // Get the notifications list from bridge config\n+                final List<String> notifications = config.getNotifications();\n+\n+                locations = plants.stream().map(p -> Location.fromPlant(p, subscriptions.stream()\n+                        .filter(s -> s.getPlantId().equals(p.getId()) && notifications.contains(s.getSubscriptionId()))\n+                        .findFirst())).collect(Collectors.toList());\n+            } else {\n+                locations = plants.stream().map(p -> Location.fromPlant(p)).collect(Collectors.toList());\n+            }\n+            logger.debug(\"Bridge[{}] Available locations: {}\", thing.getUID(), locations);\n+\n+            return locations;\n+\n+        } catch (SmartherGatewayException e) {\n+            logger.warn(\"Bridge[{}] Cannot retrieve available locations: {}\", thing.getUID(), e.getMessage());\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Updates this Bridge local notifications list with externally registered subscriptions.\n+     *\n+     * @param subscriptions\n+     *            the externally registered subscriptions to be added to the local notifications list\n+     */\n+    private void updateNotifications(List<Subscription> subscriptions) {\n+        // Get the notifications list from bridge config\n+        List<String> notifications = config.getNotifications();\n+\n+        for (Subscription s : subscriptions) {\n+            if (s.getEndpointUrl().equalsIgnoreCase(config.getNotificationUrl())\n+                    && !notifications.contains(s.getSubscriptionId())) {\n+                // Add the external subscription to notifications list\n+                notifications = config.addNotification(s.getSubscriptionId());\n+\n+                // Save the updated notifications list back to bridge config\n+                Configuration configuration = editConfiguration();\n+                configuration.put(PROPERTY_NOTIFICATIONS, notifications);\n+                updateConfiguration(configuration);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Sets all the cache to \"expired\" for this Bridge.\n+     */\n+    private void expireCache() {\n+        logger.debug(\"Bridge[{}] Invalidating location cache\", thing.getUID());\n+        final ExpiringCache<List<Location>> localLocationCache = this.locationCache;\n+        if (localLocationCache != null) {\n+            localLocationCache.invalidateValue();\n+        }\n+    }\n+\n+    // ===========================================================================\n+    //\n+    // Bridge status polling mechanism methods\n+    //\n+    // ===========================================================================\n+\n+    /**\n+     * Starts a new scheduler to periodically poll and update this Bridge status.\n+     */\n+    private void schedulePoll() {\n+        stopPoll(false);\n+\n+        // Schedule poll to start after POLL_INITIAL_DELAY sec and run periodically based on status refresh period\n+        final Future<?> localPollFuture = scheduler.scheduleWithFixedDelay(this::poll, POLL_INITIAL_DELAY,\n+                config.getStatusRefreshPeriod() * 60, TimeUnit.SECONDS);\n+        this.pollFuture = localPollFuture;\n+\n+        logger.debug(\"Bridge[{}] Scheduled poll for {} sec out, then every {} min\", thing.getUID(), POLL_INITIAL_DELAY,\n+                config.getStatusRefreshPeriod());\n+    }\n+\n+    /**\n+     * Cancels all running poll schedulers.\n+     *\n+     * @param mayInterruptIfRunning\n+     *            {@code true} if the thread executing this task should be interrupted, {@code false} if the in-progress\n+     *            tasks are allowed to complete\n+     */\n+    private synchronized void stopPoll(boolean mayInterruptIfRunning) {\n+        final Future<?> localPollFuture = this.pollFuture;\n+        if (localPollFuture != null) {\n+            if (!localPollFuture.isCancelled()) {\n+                localPollFuture.cancel(mayInterruptIfRunning);\n+            }\n+            this.pollFuture = null;\n+        }\n+    }\n+\n+    /**\n+     * Polls to update this Bridge status, calling the Smarther API to refresh its plants list.\n+     *\n+     * @return {@code true} if the method completes without errors, {@code false} otherwise\n+     */\n+    private synchronized boolean poll() {\n+        try {\n+            onAccessTokenResponse(getAccessTokenResponse());\n+\n+            expireCache();\n+            locationCacheAction();\n+\n+            updateStatus(ThingStatus.ONLINE);\n+            return true;\n+\n+        } catch (SmartherAuthorizationException e) {\n+            logger.warn(\"Bridge[{}] Authorization error during polling: {}\", thing.getUID(), e.getMessage());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+            schedulePoll();\n+            return false;\n+        } catch (RuntimeException e) {\n+            // All other exceptions apart from Authorization and Gateway issues\n+            logger.warn(\"Bridge[{}] Unexpected error during polling, please report if this keeps occurring: \",\n+                    thing.getUID(), e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, e.getMessage());\n+            schedulePoll();\n+            return false;\n+        }\n+    }\n+\n+    @Override\n+    public void onAccessTokenResponse(@Nullable AccessTokenResponse tokenResponse) {\n+        updateChannelState(CHANNEL_ACCESS_TOKEN,\n+                new StringType((tokenResponse == null) ? null : tokenResponse.getAccessToken()));\n+    }\n+\n+    // ===========================================================================\n+    //\n+    // Bridge convenience methods\n+    //\n+    // ===========================================================================\n+\n+    /**\n+     * Convenience method to get this Bridge configuration.\n+     *\n+     * @return a {@link SmartherBridgeConfiguration} object containing the Bridge configuration\n+     */\n+    public SmartherBridgeConfiguration getSmartherBridgeConfig() {\n+        return config;\n+    }\n+\n+    /**\n+     * Convenience method to get the access token from Smarther API authorization layer.\n+     *\n+     * @return the autorization access token, may be {@code null}\n+     *\n+     * @throws {@link SmartherAuthorizationException}\n+     *             in case of authorization issues with the Smarther API\n+     */\n+    private @Nullable AccessTokenResponse getAccessTokenResponse() throws SmartherAuthorizationException {\n+        try {\n+            final OAuthClientService localOAuthService = this.oAuthService;\n+            if (localOAuthService != null) {\n+                return localOAuthService.getAccessTokenResponse();\n+            }\n+            return null;\n+        } catch (OAuthException | IOException | OAuthResponseException | RuntimeException e) {\n+            throw new SmartherAuthorizationException(e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Convenience method to update the given Channel state \"only\" if the Channel is linked.\n+     *\n+     * @param channelId\n+     *            the identifier of the Channel to be updated\n+     * @param state\n+     *            the new state to be applied to the given Channel\n+     */\n+    private void updateChannelState(String channelId, State state) {\n+        final Channel channel = thing.getChannel(channelId);\n+\n+        if (channel != null && isLinked(channel.getUID())) {\n+            updateState(channel.getUID(), state);\n+        }\n+    }\n+\n+    /**\n+     * Convenience method to update the Smarther API calls counter for this Bridge.\n+     */\n+    private void updateApiCallsCounter() {\n+        final BridgeStatus localBridgeStatus = this.bridgeStatus;\n+        if (localBridgeStatus != null) {\n+            updateChannelState(CHANNEL_API_CALLS_HANDLED,\n+                    new DecimalType(localBridgeStatus.incrementApiCallsHandled()));\n+        }\n+    }\n+\n+    /**\n+     * Convenience method to check and get the Smarther API instance for this Bridge.\n+     *\n+     * @return the Smarther API instance\n+     *\n+     * @throws {@link SmartherGatewayException}\n+     *             in case the Smarther API instance is {@code null}\n+     */\n+    private SmartherApi getSmartherApi() throws SmartherGatewayException {\n+        final SmartherApi localSmartherApi = this.smartherApi;\n+        if (localSmartherApi == null) {\n+            throw new SmartherGatewayException(\"Smarther API instance is null\");\n+        }\n+        return localSmartherApi;\n+    }\n+\n+    // ===========================================================================\n+    //\n+    // Implementation of the SmartherAccountHandler interface\n+    //\n+    // ===========================================================================\n+\n+    @Override\n+    public ThingUID getUID() {\n+        return thing.getUID();\n+    }\n+\n+    @Override\n+    public String getLabel() {\n+        return StringUtil.defaultString(thing.getLabel());\n+    }\n+\n+    @Override\n+    public List<Location> getLocations() {\n+        final ExpiringCache<List<Location>> localLocationCache = this.locationCache;\n+        final List<Location> locations = (localLocationCache != null) ? localLocationCache.getValue() : null;\n+        return (locations != null) ? locations : new ArrayList<>();\n+    }\n+\n+    @Override\n+    public boolean hasLocation(String plantId) {\n+        final ExpiringCache<List<Location>> localLocationCache = this.locationCache;\n+        final List<Location> locations = (localLocationCache != null) ? localLocationCache.getValue() : null;\n+        return (locations != null) ? locations.stream().anyMatch(l -> l.getPlantId().equals(plantId)) : false;\n+    }\n+\n+    @Override\n+    public List<Plant> getPlants() throws SmartherGatewayException {\n+        updateApiCallsCounter();\n+        return getSmartherApi().getPlants();\n+    }\n+\n+    @Override\n+    public List<Subscription> getSubscriptions() throws SmartherGatewayException {\n+        updateApiCallsCounter();\n+        return getSmartherApi().getSubscriptions();\n+    }\n+\n+    @Override\n+    public String subscribePlant(String plantId, String notificationUrl) throws SmartherGatewayException {\n+        updateApiCallsCounter();\n+        return getSmartherApi().subscribePlant(plantId, notificationUrl);\n+    }\n+\n+    @Override\n+    public void unsubscribePlant(String plantId, String subscriptionId) throws SmartherGatewayException {\n+        updateApiCallsCounter();\n+        getSmartherApi().unsubscribePlant(plantId, subscriptionId);\n+    }\n+\n+    @Override\n+    public List<Module> getLocationModules(Location location) {\n+        try {\n+            updateApiCallsCounter();\n+            return getSmartherApi().getPlantModules(location.getPlantId());\n+        } catch (SmartherGatewayException e) {\n+            return new ArrayList<>();\n+        }\n+    }\n+\n+    @Override\n+    public ModuleStatus getModuleStatus(String plantId, String moduleId) throws SmartherGatewayException {\n+        updateApiCallsCounter();\n+        return getSmartherApi().getModuleStatus(plantId, moduleId);\n+    }\n+\n+    @Override\n+    public boolean setModuleStatus(ModuleSettings moduleSettings) throws SmartherGatewayException {\n+        updateApiCallsCounter();\n+        return getSmartherApi().setModuleStatus(moduleSettings);\n+    }\n+\n+    @Override\n+    public List<Program> getModulePrograms(String plantId, String moduleId) throws SmartherGatewayException {\n+        updateApiCallsCounter();\n+        return getSmartherApi().getModulePrograms(plantId, moduleId);\n+    }\n+\n+    @Override\n+    public boolean isAuthorized() {\n+        try {\n+            final AccessTokenResponse tokenResponse = getAccessTokenResponse();\n+            onAccessTokenResponse(tokenResponse);\n+\n+            return (tokenResponse != null && tokenResponse.getAccessToken() != null\n+                    && tokenResponse.getRefreshToken() != null);\n+        } catch (SmartherAuthorizationException e) {\n+            return false;\n+        }\n+    }\n+\n+    @Override\n+    public boolean isOnline() {\n+        return (thing.getStatus() == ThingStatus.ONLINE);\n+    }\n+\n+    @Override\n+    public String authorize(String redirectUrl, String reqCode, String notificationUrl)\n+            throws SmartherGatewayException {\n+        try {\n+            logger.debug(\"Bridge[{}] Call API gateway to get access token. RedirectUri: {}\", thing.getUID(),\n+                    redirectUrl);\n+\n+            final OAuthClientService localOAuthService = this.oAuthService;\n+            if (localOAuthService == null) {\n+                throw new SmartherAuthorizationException(\"Authorization service is null\");\n+            }\n+\n+            // OAuth2 call to get access token from received authorization code\n+            localOAuthService.getAccessTokenResponseByAuthorizationCode(reqCode, redirectUrl);\n+\n+            // Store the notification URL in bridge configuration\n+            Configuration configuration = editConfiguration();\n+            configuration.put(PROPERTY_NOTIFICATION_URL, notificationUrl);\n+            updateConfiguration(configuration);\n+            config.setNotificationUrl(notificationUrl);\n+            logger.debug(\"Bridge[{}] Store notification URL: {}\", thing.getUID(), notificationUrl);\n+\n+            // Reschedule the polling thread\n+            schedulePoll();\n+\n+            return config.getClientId();\n+        } catch (OAuthResponseException e) {\n+            throw new SmartherAuthorizationException(e.toString(), e);\n+        } catch (OAuthException | IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+            throw new SmartherGatewayException(e.getMessage(), e);\n+        }\n+    }\n+\n+    @Override\n+    public boolean equalsThingUID(String thingUID) {\n+        return thing.getUID().getAsString().equals(thingUID);\n+    }\n+\n+    @Override\n+    public String formatAuthorizationUrl(String redirectUri) {\n+        try {\n+            final OAuthClientService localOAuthService = this.oAuthService;\n+            if (localOAuthService != null) {\n+                return localOAuthService.getAuthorizationUrl(redirectUri, null, thing.getUID().getAsString());\n+            }\n+            return \"\";\n+        } catch (OAuthException e) {\n+            logger.warn(\"Bridge[{}] Error constructing AuthorizationUrl: \", thing.getUID());\n+            return \"\";\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b76ea0c1193e57298bdea1f8bcae9b3f10b90950"}, "originalPosition": 608}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE1MzMxMw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    this.config = getConfigAs(SmartherModuleConfiguration.class);\n          \n          \n            \n                    this.config = new SmartherModuleConfiguration();", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r439153313", "createdAt": "2020-06-12T01:01:11Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/handler/SmartherModuleHandler.java", "diffHunk": "@@ -0,0 +1,733 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.handler;\n+\n+import static org.openhab.binding.smarther.internal.SmartherBindingConstants.*;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.cache.ExpiringCache;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.scheduler.CronScheduler;\n+import org.eclipse.smarthome.core.scheduler.ScheduledCompletableFuture;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.smarther.internal.api.dto.Chronothermostat;\n+import org.openhab.binding.smarther.internal.api.dto.Enums.BoostTime;\n+import org.openhab.binding.smarther.internal.api.dto.Enums.Mode;\n+import org.openhab.binding.smarther.internal.api.dto.ModuleStatus;\n+import org.openhab.binding.smarther.internal.api.dto.Notification;\n+import org.openhab.binding.smarther.internal.api.dto.Program;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherGatewayException;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherIllegalPropertyValueException;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherSubscriptionAlreadyExistsException;\n+import org.openhab.binding.smarther.internal.config.SmartherModuleConfiguration;\n+import org.openhab.binding.smarther.internal.model.ModuleSettings;\n+import org.openhab.binding.smarther.internal.util.StringUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@code SmartherModuleHandler} class is responsible of a single Smarther Chronothermostat, handling the commands\n+ * that are sent to one of its channels.\n+ * Each Smarther Chronothermostat communicates with the Smarther API via its assigned {@code SmartherBridgeHandler}.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmartherModuleHandler extends BaseThingHandler {\n+\n+    private static final String DAILY_MIDNIGHT = \"1 0 0 * * ? *\";\n+    private static final long POLL_INITIAL_DELAY = 5;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private final CronScheduler cronScheduler;\n+    private final SmartherDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final ChannelUID programChannelUID;\n+    private final ChannelUID endDateChannelUID;\n+\n+    // Module configuration\n+    private SmartherModuleConfiguration config;\n+\n+    // Field members assigned in initialize method\n+    private @Nullable ScheduledCompletableFuture<Void> jobFuture;\n+    private @Nullable Future<?> pollFuture;\n+    private @Nullable SmartherBridgeHandler bridgeHandler;\n+    private @Nullable ExpiringCache<List<Program>> programCache;\n+    private @Nullable ModuleSettings moduleSettings;\n+\n+    // Chronothermostat local status\n+    private @Nullable Chronothermostat chronothermostat;\n+\n+    /**\n+     * Constructs a {@code SmartherModuleHandler} for the given thing, scheduler and dynamic state description provider.\n+     *\n+     * @param thing\n+     *            the {@link Thing} thing to be used\n+     * @param scheduler\n+     *            the {@link CronScheduler} periodic job scheduler to be used\n+     * @param provider\n+     *            the {@link SmartherDynamicStateDescriptionProvider} dynamic state description provider to be used\n+     */\n+    public SmartherModuleHandler(Thing thing, CronScheduler scheduler,\n+            SmartherDynamicStateDescriptionProvider provider) {\n+        super(thing);\n+        this.cronScheduler = scheduler;\n+        this.dynamicStateDescriptionProvider = provider;\n+        this.programChannelUID = new ChannelUID(thing.getUID(), CHANNEL_SETTINGS_PROGRAM);\n+        this.endDateChannelUID = new ChannelUID(thing.getUID(), CHANNEL_SETTINGS_ENDDATE);\n+        this.config = getConfigAs(SmartherModuleConfiguration.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b76ea0c1193e57298bdea1f8bcae9b3f10b90950"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE1NDYzMw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            updateChannelState(CHANNEL_STATUS_PROGRAM, new StringType(\"\" + localProgram.getNumber()));\n          \n          \n            \n                            updateChannelState(CHANNEL_STATUS_PROGRAM, new StringType(String.valueOf(localProgram.getNumber())));", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r439154633", "createdAt": "2020-06-12T01:06:41Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/handler/SmartherModuleHandler.java", "diffHunk": "@@ -0,0 +1,733 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.handler;\n+\n+import static org.openhab.binding.smarther.internal.SmartherBindingConstants.*;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.cache.ExpiringCache;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.scheduler.CronScheduler;\n+import org.eclipse.smarthome.core.scheduler.ScheduledCompletableFuture;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.smarther.internal.api.dto.Chronothermostat;\n+import org.openhab.binding.smarther.internal.api.dto.Enums.BoostTime;\n+import org.openhab.binding.smarther.internal.api.dto.Enums.Mode;\n+import org.openhab.binding.smarther.internal.api.dto.ModuleStatus;\n+import org.openhab.binding.smarther.internal.api.dto.Notification;\n+import org.openhab.binding.smarther.internal.api.dto.Program;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherGatewayException;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherIllegalPropertyValueException;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherSubscriptionAlreadyExistsException;\n+import org.openhab.binding.smarther.internal.config.SmartherModuleConfiguration;\n+import org.openhab.binding.smarther.internal.model.ModuleSettings;\n+import org.openhab.binding.smarther.internal.util.StringUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@code SmartherModuleHandler} class is responsible of a single Smarther Chronothermostat, handling the commands\n+ * that are sent to one of its channels.\n+ * Each Smarther Chronothermostat communicates with the Smarther API via its assigned {@code SmartherBridgeHandler}.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmartherModuleHandler extends BaseThingHandler {\n+\n+    private static final String DAILY_MIDNIGHT = \"1 0 0 * * ? *\";\n+    private static final long POLL_INITIAL_DELAY = 5;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private final CronScheduler cronScheduler;\n+    private final SmartherDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final ChannelUID programChannelUID;\n+    private final ChannelUID endDateChannelUID;\n+\n+    // Module configuration\n+    private SmartherModuleConfiguration config;\n+\n+    // Field members assigned in initialize method\n+    private @Nullable ScheduledCompletableFuture<Void> jobFuture;\n+    private @Nullable Future<?> pollFuture;\n+    private @Nullable SmartherBridgeHandler bridgeHandler;\n+    private @Nullable ExpiringCache<List<Program>> programCache;\n+    private @Nullable ModuleSettings moduleSettings;\n+\n+    // Chronothermostat local status\n+    private @Nullable Chronothermostat chronothermostat;\n+\n+    /**\n+     * Constructs a {@code SmartherModuleHandler} for the given thing, scheduler and dynamic state description provider.\n+     *\n+     * @param thing\n+     *            the {@link Thing} thing to be used\n+     * @param scheduler\n+     *            the {@link CronScheduler} periodic job scheduler to be used\n+     * @param provider\n+     *            the {@link SmartherDynamicStateDescriptionProvider} dynamic state description provider to be used\n+     */\n+    public SmartherModuleHandler(Thing thing, CronScheduler scheduler,\n+            SmartherDynamicStateDescriptionProvider provider) {\n+        super(thing);\n+        this.cronScheduler = scheduler;\n+        this.dynamicStateDescriptionProvider = provider;\n+        this.programChannelUID = new ChannelUID(thing.getUID(), CHANNEL_SETTINGS_PROGRAM);\n+        this.endDateChannelUID = new ChannelUID(thing.getUID(), CHANNEL_SETTINGS_ENDDATE);\n+        this.config = getConfigAs(SmartherModuleConfiguration.class);\n+    }\n+\n+    // ===========================================================================\n+    //\n+    // Chronothermostat thing lifecycle management methods\n+    //\n+    // ===========================================================================\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Module[{}] Initialize handler\", thing.getUID());\n+\n+        final Bridge localBridge = getBridge();\n+        if (localBridge == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            return;\n+        }\n+\n+        final SmartherBridgeHandler localBridgeHandler = (SmartherBridgeHandler) localBridge.getHandler();\n+        this.bridgeHandler = localBridgeHandler;\n+        if (localBridgeHandler == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, String.format(\n+                    \"Missing configuration from the Smarther Bridge (UID:%s). Fix configuration or report if this problem remains.\",\n+                    localBridge.getBridgeUID()));\n+            return;\n+        }\n+\n+        this.config = getConfigAs(SmartherModuleConfiguration.class);\n+        if (StringUtil.isBlank(config.getPlantId())) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Plant Id' property is not set or empty. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+        if (StringUtil.isBlank(config.getModuleId())) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Module Id' property is not set or empty. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+        if (config.getProgramsRefreshPeriod() <= 0) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Programs Refresh Period' must be > 0. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+        if (config.getStatusRefreshPeriod() <= 0) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Module Status Refresh Period' must be > 0. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+\n+        // Initialize automatic mode programs local cache\n+        final ExpiringCache<List<Program>> localProgramCache = new ExpiringCache<>(\n+                Duration.ofHours(config.getProgramsRefreshPeriod()), this::programCacheAction);\n+        this.programCache = localProgramCache;\n+\n+        // Initialize module local settings\n+        final ModuleSettings localModuleSettings = new ModuleSettings(config.getPlantId(), config.getModuleId());\n+        this.moduleSettings = localModuleSettings;\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduleJob();\n+        schedulePoll();\n+\n+        logger.debug(\"Module[{}] Finished initializing!\", thing.getUID());\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        try {\n+            handleCommandInternal(channelUID, command);\n+            updateModuleStatus();\n+        } catch (SmartherIllegalPropertyValueException e) {\n+            logger.warn(\"Module[{}] Received command {} with illegal value {} on channel {}\", thing.getUID(), command,\n+                    e.getMessage(), channelUID.getId());\n+        } catch (SmartherGatewayException e) {\n+            // catch exceptions and handle it in your binding\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Handles the command sent to a given Channel of this Chronothermostat.\n+     *\n+     * @param channelUID\n+     *            the identifier of the Channel\n+     * @param command\n+     *            the command sent to the given Channel\n+     *\n+     * @throws {@link SmartherIllegalPropertyValueException}\n+     *             if the command contains an illegal value that cannot be mapped to any valid enum value\n+     * @throws {@link SmartherGatewayException}\n+     *             in case of communication issues with the Smarther API\n+     */\n+    private void handleCommandInternal(ChannelUID channelUID, Command command)\n+            throws SmartherIllegalPropertyValueException, SmartherGatewayException {\n+        final ModuleSettings localModuleSettings = this.moduleSettings;\n+        if (localModuleSettings == null) {\n+            return;\n+        }\n+\n+        switch (channelUID.getId()) {\n+            case CHANNEL_SETTINGS_MODE:\n+                if (command instanceof StringType) {\n+                    localModuleSettings.setMode(Mode.fromValue(command.toString()));\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_TEMPERATURE:\n+                if (changeTemperature(command, localModuleSettings)) {\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_PROGRAM:\n+                if (command instanceof DecimalType) {\n+                    localModuleSettings.setProgram(((DecimalType) command).intValue());\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_BOOSTTIME:\n+                if (command instanceof DecimalType) {\n+                    localModuleSettings.setBoostTime(BoostTime.fromValue(((DecimalType) command).intValue()));\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_ENDDATE:\n+                if (command instanceof StringType) {\n+                    localModuleSettings.setEndDate(command.toString());\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_ENDHOUR:\n+                if (changeTimeHour(command, localModuleSettings)) {\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_ENDMINUTE:\n+                if (changeTimeMinute(command, localModuleSettings)) {\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_POWER:\n+                if (command instanceof OnOffType) {\n+                    if (OnOffType.ON.equals(command)) {\n+                        // Apply module settings to the remote module\n+                        if (getBridgeHandler().setModuleStatus(localModuleSettings)) {\n+                            // Change applied, update module status\n+                            logger.debug(\"Module[{}] New settings applied!\", thing.getUID());\n+                        }\n+                        updateChannelState(CHANNEL_SETTINGS_POWER, OnOffType.OFF);\n+                    }\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_FETCH_CONFIG:\n+                if (command instanceof OnOffType) {\n+                    if (OnOffType.ON.equals(command)) {\n+                        logger.debug(\"Module[{}] Manually triggered channel to refresh the Module config\",\n+                                thing.getUID());\n+                        expireCache();\n+                        updateChannelState(CHANNEL_FETCH_CONFIG, OnOffType.OFF);\n+                    }\n+                    return;\n+                }\n+                break;\n+        }\n+\n+        if (command instanceof RefreshType) {\n+            // Avoid logging wrong command when refresh command is sent\n+            return;\n+        }\n+\n+        logger.debug(\"Module[{}] Received command {} of wrong type {} on channel {}\", thing.getUID(), command,\n+                command.getClass().getTypeName(), channelUID.getId());\n+    }\n+\n+    /**\n+     * Changes the \"temperature\" in module settings, based on the received Command.\n+     * The new value is checked against the temperature limits allowed by the device.\n+     *\n+     * @param command\n+     *            the command received on temperature Channel\n+     *\n+     * @return {@code true} if the change succeeded, {@code false} otherwise\n+     */\n+    private boolean changeTemperature(Command command, final ModuleSettings settings) {\n+        if (!(command instanceof QuantityType)) {\n+            return false;\n+        }\n+\n+        QuantityType<?> quantity = (QuantityType<?>) command;\n+        QuantityType<?> newMeasure = quantity.toUnit(SIUnits.CELSIUS);\n+\n+        // Check remote device temperature limits\n+        if (newMeasure != null && newMeasure.doubleValue() >= 7.1 && newMeasure.doubleValue() <= 40.0) {\n+            // Only tenth degree increments are allowed\n+            double newTemperature = Math.round(newMeasure.doubleValue() * 10) / 10.0;\n+\n+            settings.setSetPointTemperature(QuantityType.valueOf(newTemperature, SIUnits.CELSIUS));\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Changes the \"end hour\" for manual mode in module settings, based on the received Command.\n+     * The new value is checked against the 24-hours clock allowed range.\n+     *\n+     * @param command\n+     *            the command received on end hour Channel\n+     *\n+     * @return {@code true} if the change succeeded, {@code false} otherwise\n+     */\n+    private boolean changeTimeHour(Command command, final ModuleSettings settings) {\n+        if (command instanceof DecimalType) {\n+            int endHour = ((DecimalType) command).intValue();\n+            if (endHour >= 0 && endHour <= 23) {\n+                settings.setEndHour(endHour);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Changes the \"end minute\" for manual mode in module settings, based on the received Command.\n+     * The new value is modified to match a 15 min step increment.\n+     *\n+     * @param command\n+     *            the command received on end minute Channel\n+     *\n+     * @return {@code true} if the change succeeded, {@code false} otherwise\n+     */\n+    private boolean changeTimeMinute(Command command, final ModuleSettings settings) {\n+        if (command instanceof DecimalType) {\n+            int endMinute = ((DecimalType) command).intValue();\n+            if (endMinute >= 0 && endMinute <= 59) {\n+                // Only 15 min increments are allowed\n+                endMinute = Math.round(endMinute / 15) * 15;\n+                settings.setEndMinute(endMinute);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Handles the notification dispatched to this Chronothermostat from the reference Smarther Bridge.\n+     *\n+     * @param notification\n+     *            the notification to handle\n+     */\n+    public void handleNotification(Notification notification) {\n+        try {\n+            final Chronothermostat notificationChrono = notification.getChronothermostat();\n+            if (notificationChrono != null) {\n+                this.chronothermostat = notificationChrono;\n+                if (config.isSettingsAutoupdate()) {\n+                    final ModuleSettings localModuleSettings = this.moduleSettings;\n+                    if (localModuleSettings != null) {\n+                        localModuleSettings.updateFromChronothermostat(notificationChrono);\n+                    }\n+                }\n+                logger.debug(\"Module[{}] Handle notification: [{}]\", thing.getUID(), this.chronothermostat);\n+                updateModuleStatus();\n+            }\n+        } catch (SmartherIllegalPropertyValueException e) {\n+            logger.warn(\"Module[{}] Notification has illegal value: [{}]\", thing.getUID(), e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        if (bridgeStatusInfo.getStatus() != ThingStatus.ONLINE) {\n+            // Put module offline when the parent bridge goes offline\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE, \"Smarther Bridge Offline\");\n+            logger.debug(\"Module[{}] Bridge switched {}\", thing.getUID(), bridgeStatusInfo.getStatus());\n+        } else {\n+            // Update the module status when the parent bridge return online\n+            logger.debug(\"Module[{}] Bridge is back ONLINE\", thing.getUID());\n+            // Restart polling to collect module data\n+            schedulePoll();\n+        }\n+    }\n+\n+    @Override\n+    public void handleRemoval() {\n+        super.handleRemoval();\n+        stopPoll(true);\n+        stopJob(true);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Module[{}] Dispose handler\", thing.getUID());\n+        stopPoll(true);\n+        stopJob(true);\n+        try {\n+            getBridgeHandler().unregisterNotification(config.getPlantId());\n+        } catch (SmartherGatewayException e) {\n+            logger.warn(\"Module[{}] API Gateway error during disposing: {}\", thing.getUID(), e.getMessage());\n+        }\n+        logger.debug(\"Module[{}] Finished disposing!\", thing.getUID());\n+    }\n+\n+    // ===========================================================================\n+    //\n+    // Chronothermostat data cache management methods\n+    //\n+    // ===========================================================================\n+\n+    /**\n+     * Returns the available automatic mode programs to be cached for this Chronothermostat.\n+     *\n+     * @return the available programs to be cached for this Chronothermostat, or {@code null} if the list of available\n+     *         programs cannot be retrieved\n+     */\n+    private @Nullable List<Program> programCacheAction() {\n+        try {\n+            final List<Program> programs = getBridgeHandler().getModulePrograms(config.getPlantId(),\n+                    config.getModuleId());\n+            logger.debug(\"Module[{}] Available programs: {}\", thing.getUID(), programs);\n+\n+            return programs;\n+\n+        } catch (SmartherGatewayException e) {\n+            logger.warn(\"Module[{}] Cannot retrieve available programs: {}\", thing.getUID(), e.getMessage());\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Sets all the cache to \"expired\" for this Chronothermostat.\n+     */\n+    private void expireCache() {\n+        logger.debug(\"Module[{}] Invalidating program cache\", thing.getUID());\n+        final ExpiringCache<List<Program>> localProgramCache = this.programCache;\n+        if (localProgramCache != null) {\n+            localProgramCache.invalidateValue();\n+        }\n+    }\n+\n+    // ===========================================================================\n+    //\n+    // Chronothermostat job scheduler methods\n+    //\n+    // ===========================================================================\n+\n+    /**\n+     * Starts a new cron scheduler to execute the internal recurring jobs.\n+     */\n+    private synchronized void scheduleJob() {\n+        stopJob(false);\n+\n+        // Schedule daily job to start daily, at midnight\n+        final ScheduledCompletableFuture<Void> localJobFuture = cronScheduler.schedule(this::dailyJob, DAILY_MIDNIGHT);\n+        this.jobFuture = localJobFuture;\n+\n+        logger.debug(\"Module[{}] Scheduled recurring job {} to start at midnight\", thing.getUID(),\n+                Integer.toHexString(localJobFuture.hashCode()));\n+\n+        // Execute daily job immediately at startup\n+        this.dailyJob();\n+    }\n+\n+    /**\n+     * Cancels all running jobs.\n+     *\n+     * @param mayInterruptIfRunning\n+     *            {@code true} if the thread executing this task should be interrupted, {@code false} if the in-progress\n+     *            tasks are allowed to complete\n+     */\n+    private synchronized void stopJob(boolean mayInterruptIfRunning) {\n+        final ScheduledCompletableFuture<Void> localJobFuture = this.jobFuture;\n+        if (localJobFuture != null) {\n+            if (!localJobFuture.isCancelled()) {\n+                localJobFuture.cancel(mayInterruptIfRunning);\n+            }\n+            this.jobFuture = null;\n+        }\n+    }\n+\n+    /**\n+     * Action to be executed by the daily job: refresh the end dates list for \"manual\" mode.\n+     */\n+    private void dailyJob() {\n+        logger.debug(\"Module[{}] Daily job, refreshing the end dates list for \\\"manual\\\" mode\", thing.getUID());\n+        // Refresh the end dates list for \"manual\" mode\n+        dynamicStateDescriptionProvider.setEndDates(endDateChannelUID, config.getNumberOfEndDays());\n+        // If expired, update EndDate in module settings\n+        final ModuleSettings localModuleSettings = this.moduleSettings;\n+        if (localModuleSettings != null && localModuleSettings.isEndDateExpired()) {\n+            localModuleSettings.refreshEndDate();\n+            updateChannelState(CHANNEL_SETTINGS_ENDDATE, new StringType(localModuleSettings.getEndDate()));\n+        }\n+    }\n+\n+    // ===========================================================================\n+    //\n+    // Chronothermostat status polling mechanism methods\n+    //\n+    // ===========================================================================\n+\n+    /**\n+     * Starts a new scheduler to periodically poll and update this Chronothermostat status.\n+     */\n+    private void schedulePoll() {\n+        stopPoll(false);\n+\n+        // Schedule poll to start after POLL_INITIAL_DELAY sec and run periodically based on status refresh period\n+        final Future<?> localPollFuture = scheduler.scheduleWithFixedDelay(this::poll, POLL_INITIAL_DELAY,\n+                config.getStatusRefreshPeriod() * 60, TimeUnit.SECONDS);\n+        this.pollFuture = localPollFuture;\n+\n+        logger.debug(\"Module[{}] Scheduled poll for {} sec out, then every {} min\", thing.getUID(), POLL_INITIAL_DELAY,\n+                config.getStatusRefreshPeriod());\n+    }\n+\n+    /**\n+     * Cancels all running poll schedulers.\n+     *\n+     * @param mayInterruptIfRunning\n+     *            {@code true} if the thread executing this task should be interrupted, {@code false} if the in-progress\n+     *            tasks are allowed to complete\n+     */\n+    private synchronized void stopPoll(boolean mayInterruptIfRunning) {\n+        final Future<?> localPollFuture = this.pollFuture;\n+        if (localPollFuture != null) {\n+            if (!localPollFuture.isCancelled()) {\n+                localPollFuture.cancel(mayInterruptIfRunning);\n+            }\n+            this.pollFuture = null;\n+        }\n+    }\n+\n+    /**\n+     * Polls to update this Chronothermostat status.\n+     *\n+     * @return {@code true} if the method completes without errors, {@code false} otherwise\n+     */\n+    private synchronized boolean poll() {\n+        try {\n+            final Bridge bridge = getBridge();\n+            if (bridge != null) {\n+                final ThingStatusInfo bridgeStatusInfo = bridge.getStatusInfo();\n+                if (bridgeStatusInfo.getStatus() == ThingStatus.ONLINE) {\n+                    ModuleStatus moduleStatus = getBridgeHandler().getModuleStatus(config.getPlantId(),\n+                            config.getModuleId());\n+\n+                    final Chronothermostat statusChrono = moduleStatus.toChronothermostat();\n+                    if (statusChrono != null) {\n+                        if ((this.chronothermostat == null) || config.isSettingsAutoupdate()) {\n+                            final ModuleSettings localModuleSettings = this.moduleSettings;\n+                            if (localModuleSettings != null) {\n+                                localModuleSettings.updateFromChronothermostat(statusChrono);\n+                            }\n+                        }\n+                        this.chronothermostat = statusChrono;\n+                        logger.debug(\"Module[{}] Status: [{}]\", thing.getUID(), this.chronothermostat);\n+                    } else {\n+                        throw new SmartherGatewayException(\"No chronothermostat data found\");\n+                    }\n+\n+                    // Refresh the programs list for \"automatic\" mode\n+                    final ExpiringCache<List<Program>> localProgramCache = this.programCache;\n+                    if (localProgramCache != null) {\n+                        final List<Program> programs = localProgramCache.getValue();\n+                        if (programs != null) {\n+                            dynamicStateDescriptionProvider.setPrograms(programChannelUID, programs);\n+                        }\n+                    }\n+\n+                    updateModuleStatus();\n+\n+                    getBridgeHandler().registerNotification(config.getPlantId());\n+\n+                    // Everything is ok > set the Thing state to Online\n+                    updateStatus(ThingStatus.ONLINE);\n+                    return true;\n+                } else if (thing.getStatus() != ThingStatus.OFFLINE) {\n+                    logger.debug(\"Module[{}] Switched {} as Bridge is not online\", thing.getUID(),\n+                            bridgeStatusInfo.getStatus());\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE, \"Smarther Bridge Offline\");\n+                }\n+            }\n+            return false;\n+        } catch (SmartherIllegalPropertyValueException e) {\n+            logger.debug(\"Module[{}] Illegal property value error during polling: {}\", thing.getUID(), e.getMessage());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, e.getMessage());\n+            schedulePoll();\n+            return false;\n+        } catch (SmartherSubscriptionAlreadyExistsException e) {\n+            logger.debug(\"Module[{}] Subscription error during polling: {}\", thing.getUID(), e.getMessage());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, e.getMessage());\n+            schedulePoll();\n+            return false;\n+        } catch (SmartherGatewayException e) {\n+            logger.warn(\"Module[{}] API Gateway error during polling: {}\", thing.getUID(), e.getMessage());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            schedulePoll();\n+            return false;\n+        } catch (RuntimeException e) {\n+            // All other exceptions apart from Subscription and Gateway issues\n+            logger.warn(\"Module[{}] Unexpected error during polling, please report if this keeps occurring: \",\n+                    thing.getUID(), e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, e.getMessage());\n+            schedulePoll();\n+            return false;\n+        }\n+    }\n+\n+    // ===========================================================================\n+    //\n+    // Chronothermostat convenience methods\n+    //\n+    // ===========================================================================\n+\n+    /**\n+     * Convenience method to check and get the Smarther Bridge handler instance for this Module.\n+     *\n+     * @return the Smarther Bridge handler instance\n+     *\n+     * @throws {@link SmartherGatewayException}\n+     *             in case the Smarther Bridge handler instance is {@code null}\n+     */\n+    private SmartherBridgeHandler getBridgeHandler() throws SmartherGatewayException {\n+        final SmartherBridgeHandler localBridgeHandler = this.bridgeHandler;\n+        if (localBridgeHandler == null) {\n+            throw new SmartherGatewayException(\"Smarther Bridge handler instance is null\");\n+        }\n+        return localBridgeHandler;\n+    }\n+\n+    /**\n+     * Returns this Chronothermostat plant identifier\n+     *\n+     * @return a string containing the plant identifier\n+     */\n+    public String getPlantId() {\n+        return config.getPlantId();\n+    }\n+\n+    /**\n+     * Returns this Chronothermostat module identifier\n+     *\n+     * @return a string containing the module identifier\n+     */\n+    public String getModuleId() {\n+        return config.getModuleId();\n+    }\n+\n+    /**\n+     * Checks whether this Chronothermostat matches with the given plant and module identifiers.\n+     *\n+     * @param plantId\n+     *            the plant identifier to match to\n+     * @param moduleId\n+     *            the module identifier to match to\n+     *\n+     * @return {@code true} if the Chronothermostat matches the given plant and module identifiers, {@code false}\n+     *         otherwise\n+     */\n+    public boolean isLinkedTo(String plantId, String moduleId) {\n+        return (config.getPlantId().equals(plantId) && config.getModuleId().equals(moduleId));\n+    }\n+\n+    /**\n+     * Convenience method to update the given Channel state \"only\" if the Channel is linked.\n+     *\n+     * @param channelId\n+     *            the identifier of the Channel to be updated\n+     * @param state\n+     *            the new state to be applied to the given Channel\n+     */\n+    private void updateChannelState(String channelId, State state) {\n+        final Channel channel = thing.getChannel(channelId);\n+\n+        if (channel != null && isLinked(channel.getUID())) {\n+            updateState(channel.getUID(), state);\n+        }\n+    }\n+\n+    /**\n+     * Convenience method to update the whole status of the Chronothermostat associated to this handler.\n+     * Channels are updated based on the local {@code chronothermostat} and {@code moduleSettings} objects.\n+     *\n+     * @throws {@link SmartherIllegalPropertyValueException}\n+     *             if at least one of the module properties cannot be mapped to any valid enum value\n+     */\n+    private void updateModuleStatus() throws SmartherIllegalPropertyValueException {\n+        final Chronothermostat localChrono = this.chronothermostat;\n+        if (localChrono != null) {\n+            // Update the Measures channels\n+            updateChannelState(CHANNEL_MEASURES_TEMPERATURE, localChrono.getThermometer().toState());\n+            updateChannelState(CHANNEL_MEASURES_HUMIDITY, localChrono.getHygrometer().toState());\n+            // Update the Status channels\n+            updateChannelState(CHANNEL_STATUS_STATE, (localChrono.isActive() ? OnOffType.ON : OnOffType.OFF));\n+            updateChannelState(CHANNEL_STATUS_FUNCTION,\n+                    new StringType(StringUtil.capitalize(localChrono.getFunction().toLowerCase())));\n+            updateChannelState(CHANNEL_STATUS_MODE,\n+                    new StringType(StringUtil.capitalize(localChrono.getMode().toLowerCase())));\n+            updateChannelState(CHANNEL_STATUS_TEMPERATURE, localChrono.getSetPointTemperature().toState());\n+            updateChannelState(CHANNEL_STATUS_ENDTIME, new StringType(localChrono.getActivationTimeLabel()));\n+            updateChannelState(CHANNEL_STATUS_TEMP_FORMAT, new StringType(localChrono.getTemperatureFormat()));\n+            final Program localProgram = localChrono.getProgram();\n+            if (localProgram != null) {\n+                updateChannelState(CHANNEL_STATUS_PROGRAM, new StringType(\"\" + localProgram.getNumber()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b76ea0c1193e57298bdea1f8bcae9b3f10b90950"}, "originalPosition": 715}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE1NDgxOQ==", "bodyText": "might as well put these two statements to after the catch blocks since all the catch blocks have these two statements.", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r439154819", "createdAt": "2020-06-12T01:07:32Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/handler/SmartherModuleHandler.java", "diffHunk": "@@ -0,0 +1,733 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.handler;\n+\n+import static org.openhab.binding.smarther.internal.SmartherBindingConstants.*;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.time.Duration;\n+import java.util.List;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.cache.ExpiringCache;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.scheduler.CronScheduler;\n+import org.eclipse.smarthome.core.scheduler.ScheduledCompletableFuture;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingStatusInfo;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.smarther.internal.api.dto.Chronothermostat;\n+import org.openhab.binding.smarther.internal.api.dto.Enums.BoostTime;\n+import org.openhab.binding.smarther.internal.api.dto.Enums.Mode;\n+import org.openhab.binding.smarther.internal.api.dto.ModuleStatus;\n+import org.openhab.binding.smarther.internal.api.dto.Notification;\n+import org.openhab.binding.smarther.internal.api.dto.Program;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherGatewayException;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherIllegalPropertyValueException;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherSubscriptionAlreadyExistsException;\n+import org.openhab.binding.smarther.internal.config.SmartherModuleConfiguration;\n+import org.openhab.binding.smarther.internal.model.ModuleSettings;\n+import org.openhab.binding.smarther.internal.util.StringUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@code SmartherModuleHandler} class is responsible of a single Smarther Chronothermostat, handling the commands\n+ * that are sent to one of its channels.\n+ * Each Smarther Chronothermostat communicates with the Smarther API via its assigned {@code SmartherBridgeHandler}.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmartherModuleHandler extends BaseThingHandler {\n+\n+    private static final String DAILY_MIDNIGHT = \"1 0 0 * * ? *\";\n+    private static final long POLL_INITIAL_DELAY = 5;\n+\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private final CronScheduler cronScheduler;\n+    private final SmartherDynamicStateDescriptionProvider dynamicStateDescriptionProvider;\n+    private final ChannelUID programChannelUID;\n+    private final ChannelUID endDateChannelUID;\n+\n+    // Module configuration\n+    private SmartherModuleConfiguration config;\n+\n+    // Field members assigned in initialize method\n+    private @Nullable ScheduledCompletableFuture<Void> jobFuture;\n+    private @Nullable Future<?> pollFuture;\n+    private @Nullable SmartherBridgeHandler bridgeHandler;\n+    private @Nullable ExpiringCache<List<Program>> programCache;\n+    private @Nullable ModuleSettings moduleSettings;\n+\n+    // Chronothermostat local status\n+    private @Nullable Chronothermostat chronothermostat;\n+\n+    /**\n+     * Constructs a {@code SmartherModuleHandler} for the given thing, scheduler and dynamic state description provider.\n+     *\n+     * @param thing\n+     *            the {@link Thing} thing to be used\n+     * @param scheduler\n+     *            the {@link CronScheduler} periodic job scheduler to be used\n+     * @param provider\n+     *            the {@link SmartherDynamicStateDescriptionProvider} dynamic state description provider to be used\n+     */\n+    public SmartherModuleHandler(Thing thing, CronScheduler scheduler,\n+            SmartherDynamicStateDescriptionProvider provider) {\n+        super(thing);\n+        this.cronScheduler = scheduler;\n+        this.dynamicStateDescriptionProvider = provider;\n+        this.programChannelUID = new ChannelUID(thing.getUID(), CHANNEL_SETTINGS_PROGRAM);\n+        this.endDateChannelUID = new ChannelUID(thing.getUID(), CHANNEL_SETTINGS_ENDDATE);\n+        this.config = getConfigAs(SmartherModuleConfiguration.class);\n+    }\n+\n+    // ===========================================================================\n+    //\n+    // Chronothermostat thing lifecycle management methods\n+    //\n+    // ===========================================================================\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Module[{}] Initialize handler\", thing.getUID());\n+\n+        final Bridge localBridge = getBridge();\n+        if (localBridge == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_UNINITIALIZED);\n+            return;\n+        }\n+\n+        final SmartherBridgeHandler localBridgeHandler = (SmartherBridgeHandler) localBridge.getHandler();\n+        this.bridgeHandler = localBridgeHandler;\n+        if (localBridgeHandler == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, String.format(\n+                    \"Missing configuration from the Smarther Bridge (UID:%s). Fix configuration or report if this problem remains.\",\n+                    localBridge.getBridgeUID()));\n+            return;\n+        }\n+\n+        this.config = getConfigAs(SmartherModuleConfiguration.class);\n+        if (StringUtil.isBlank(config.getPlantId())) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Plant Id' property is not set or empty. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+        if (StringUtil.isBlank(config.getModuleId())) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Module Id' property is not set or empty. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+        if (config.getProgramsRefreshPeriod() <= 0) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Programs Refresh Period' must be > 0. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+        if (config.getStatusRefreshPeriod() <= 0) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Module Status Refresh Period' must be > 0. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+\n+        // Initialize automatic mode programs local cache\n+        final ExpiringCache<List<Program>> localProgramCache = new ExpiringCache<>(\n+                Duration.ofHours(config.getProgramsRefreshPeriod()), this::programCacheAction);\n+        this.programCache = localProgramCache;\n+\n+        // Initialize module local settings\n+        final ModuleSettings localModuleSettings = new ModuleSettings(config.getPlantId(), config.getModuleId());\n+        this.moduleSettings = localModuleSettings;\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduleJob();\n+        schedulePoll();\n+\n+        logger.debug(\"Module[{}] Finished initializing!\", thing.getUID());\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        try {\n+            handleCommandInternal(channelUID, command);\n+            updateModuleStatus();\n+        } catch (SmartherIllegalPropertyValueException e) {\n+            logger.warn(\"Module[{}] Received command {} with illegal value {} on channel {}\", thing.getUID(), command,\n+                    e.getMessage(), channelUID.getId());\n+        } catch (SmartherGatewayException e) {\n+            // catch exceptions and handle it in your binding\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Handles the command sent to a given Channel of this Chronothermostat.\n+     *\n+     * @param channelUID\n+     *            the identifier of the Channel\n+     * @param command\n+     *            the command sent to the given Channel\n+     *\n+     * @throws {@link SmartherIllegalPropertyValueException}\n+     *             if the command contains an illegal value that cannot be mapped to any valid enum value\n+     * @throws {@link SmartherGatewayException}\n+     *             in case of communication issues with the Smarther API\n+     */\n+    private void handleCommandInternal(ChannelUID channelUID, Command command)\n+            throws SmartherIllegalPropertyValueException, SmartherGatewayException {\n+        final ModuleSettings localModuleSettings = this.moduleSettings;\n+        if (localModuleSettings == null) {\n+            return;\n+        }\n+\n+        switch (channelUID.getId()) {\n+            case CHANNEL_SETTINGS_MODE:\n+                if (command instanceof StringType) {\n+                    localModuleSettings.setMode(Mode.fromValue(command.toString()));\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_TEMPERATURE:\n+                if (changeTemperature(command, localModuleSettings)) {\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_PROGRAM:\n+                if (command instanceof DecimalType) {\n+                    localModuleSettings.setProgram(((DecimalType) command).intValue());\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_BOOSTTIME:\n+                if (command instanceof DecimalType) {\n+                    localModuleSettings.setBoostTime(BoostTime.fromValue(((DecimalType) command).intValue()));\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_ENDDATE:\n+                if (command instanceof StringType) {\n+                    localModuleSettings.setEndDate(command.toString());\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_ENDHOUR:\n+                if (changeTimeHour(command, localModuleSettings)) {\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_ENDMINUTE:\n+                if (changeTimeMinute(command, localModuleSettings)) {\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_SETTINGS_POWER:\n+                if (command instanceof OnOffType) {\n+                    if (OnOffType.ON.equals(command)) {\n+                        // Apply module settings to the remote module\n+                        if (getBridgeHandler().setModuleStatus(localModuleSettings)) {\n+                            // Change applied, update module status\n+                            logger.debug(\"Module[{}] New settings applied!\", thing.getUID());\n+                        }\n+                        updateChannelState(CHANNEL_SETTINGS_POWER, OnOffType.OFF);\n+                    }\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_FETCH_CONFIG:\n+                if (command instanceof OnOffType) {\n+                    if (OnOffType.ON.equals(command)) {\n+                        logger.debug(\"Module[{}] Manually triggered channel to refresh the Module config\",\n+                                thing.getUID());\n+                        expireCache();\n+                        updateChannelState(CHANNEL_FETCH_CONFIG, OnOffType.OFF);\n+                    }\n+                    return;\n+                }\n+                break;\n+        }\n+\n+        if (command instanceof RefreshType) {\n+            // Avoid logging wrong command when refresh command is sent\n+            return;\n+        }\n+\n+        logger.debug(\"Module[{}] Received command {} of wrong type {} on channel {}\", thing.getUID(), command,\n+                command.getClass().getTypeName(), channelUID.getId());\n+    }\n+\n+    /**\n+     * Changes the \"temperature\" in module settings, based on the received Command.\n+     * The new value is checked against the temperature limits allowed by the device.\n+     *\n+     * @param command\n+     *            the command received on temperature Channel\n+     *\n+     * @return {@code true} if the change succeeded, {@code false} otherwise\n+     */\n+    private boolean changeTemperature(Command command, final ModuleSettings settings) {\n+        if (!(command instanceof QuantityType)) {\n+            return false;\n+        }\n+\n+        QuantityType<?> quantity = (QuantityType<?>) command;\n+        QuantityType<?> newMeasure = quantity.toUnit(SIUnits.CELSIUS);\n+\n+        // Check remote device temperature limits\n+        if (newMeasure != null && newMeasure.doubleValue() >= 7.1 && newMeasure.doubleValue() <= 40.0) {\n+            // Only tenth degree increments are allowed\n+            double newTemperature = Math.round(newMeasure.doubleValue() * 10) / 10.0;\n+\n+            settings.setSetPointTemperature(QuantityType.valueOf(newTemperature, SIUnits.CELSIUS));\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Changes the \"end hour\" for manual mode in module settings, based on the received Command.\n+     * The new value is checked against the 24-hours clock allowed range.\n+     *\n+     * @param command\n+     *            the command received on end hour Channel\n+     *\n+     * @return {@code true} if the change succeeded, {@code false} otherwise\n+     */\n+    private boolean changeTimeHour(Command command, final ModuleSettings settings) {\n+        if (command instanceof DecimalType) {\n+            int endHour = ((DecimalType) command).intValue();\n+            if (endHour >= 0 && endHour <= 23) {\n+                settings.setEndHour(endHour);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Changes the \"end minute\" for manual mode in module settings, based on the received Command.\n+     * The new value is modified to match a 15 min step increment.\n+     *\n+     * @param command\n+     *            the command received on end minute Channel\n+     *\n+     * @return {@code true} if the change succeeded, {@code false} otherwise\n+     */\n+    private boolean changeTimeMinute(Command command, final ModuleSettings settings) {\n+        if (command instanceof DecimalType) {\n+            int endMinute = ((DecimalType) command).intValue();\n+            if (endMinute >= 0 && endMinute <= 59) {\n+                // Only 15 min increments are allowed\n+                endMinute = Math.round(endMinute / 15) * 15;\n+                settings.setEndMinute(endMinute);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Handles the notification dispatched to this Chronothermostat from the reference Smarther Bridge.\n+     *\n+     * @param notification\n+     *            the notification to handle\n+     */\n+    public void handleNotification(Notification notification) {\n+        try {\n+            final Chronothermostat notificationChrono = notification.getChronothermostat();\n+            if (notificationChrono != null) {\n+                this.chronothermostat = notificationChrono;\n+                if (config.isSettingsAutoupdate()) {\n+                    final ModuleSettings localModuleSettings = this.moduleSettings;\n+                    if (localModuleSettings != null) {\n+                        localModuleSettings.updateFromChronothermostat(notificationChrono);\n+                    }\n+                }\n+                logger.debug(\"Module[{}] Handle notification: [{}]\", thing.getUID(), this.chronothermostat);\n+                updateModuleStatus();\n+            }\n+        } catch (SmartherIllegalPropertyValueException e) {\n+            logger.warn(\"Module[{}] Notification has illegal value: [{}]\", thing.getUID(), e.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    public void bridgeStatusChanged(ThingStatusInfo bridgeStatusInfo) {\n+        if (bridgeStatusInfo.getStatus() != ThingStatus.ONLINE) {\n+            // Put module offline when the parent bridge goes offline\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE, \"Smarther Bridge Offline\");\n+            logger.debug(\"Module[{}] Bridge switched {}\", thing.getUID(), bridgeStatusInfo.getStatus());\n+        } else {\n+            // Update the module status when the parent bridge return online\n+            logger.debug(\"Module[{}] Bridge is back ONLINE\", thing.getUID());\n+            // Restart polling to collect module data\n+            schedulePoll();\n+        }\n+    }\n+\n+    @Override\n+    public void handleRemoval() {\n+        super.handleRemoval();\n+        stopPoll(true);\n+        stopJob(true);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Module[{}] Dispose handler\", thing.getUID());\n+        stopPoll(true);\n+        stopJob(true);\n+        try {\n+            getBridgeHandler().unregisterNotification(config.getPlantId());\n+        } catch (SmartherGatewayException e) {\n+            logger.warn(\"Module[{}] API Gateway error during disposing: {}\", thing.getUID(), e.getMessage());\n+        }\n+        logger.debug(\"Module[{}] Finished disposing!\", thing.getUID());\n+    }\n+\n+    // ===========================================================================\n+    //\n+    // Chronothermostat data cache management methods\n+    //\n+    // ===========================================================================\n+\n+    /**\n+     * Returns the available automatic mode programs to be cached for this Chronothermostat.\n+     *\n+     * @return the available programs to be cached for this Chronothermostat, or {@code null} if the list of available\n+     *         programs cannot be retrieved\n+     */\n+    private @Nullable List<Program> programCacheAction() {\n+        try {\n+            final List<Program> programs = getBridgeHandler().getModulePrograms(config.getPlantId(),\n+                    config.getModuleId());\n+            logger.debug(\"Module[{}] Available programs: {}\", thing.getUID(), programs);\n+\n+            return programs;\n+\n+        } catch (SmartherGatewayException e) {\n+            logger.warn(\"Module[{}] Cannot retrieve available programs: {}\", thing.getUID(), e.getMessage());\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Sets all the cache to \"expired\" for this Chronothermostat.\n+     */\n+    private void expireCache() {\n+        logger.debug(\"Module[{}] Invalidating program cache\", thing.getUID());\n+        final ExpiringCache<List<Program>> localProgramCache = this.programCache;\n+        if (localProgramCache != null) {\n+            localProgramCache.invalidateValue();\n+        }\n+    }\n+\n+    // ===========================================================================\n+    //\n+    // Chronothermostat job scheduler methods\n+    //\n+    // ===========================================================================\n+\n+    /**\n+     * Starts a new cron scheduler to execute the internal recurring jobs.\n+     */\n+    private synchronized void scheduleJob() {\n+        stopJob(false);\n+\n+        // Schedule daily job to start daily, at midnight\n+        final ScheduledCompletableFuture<Void> localJobFuture = cronScheduler.schedule(this::dailyJob, DAILY_MIDNIGHT);\n+        this.jobFuture = localJobFuture;\n+\n+        logger.debug(\"Module[{}] Scheduled recurring job {} to start at midnight\", thing.getUID(),\n+                Integer.toHexString(localJobFuture.hashCode()));\n+\n+        // Execute daily job immediately at startup\n+        this.dailyJob();\n+    }\n+\n+    /**\n+     * Cancels all running jobs.\n+     *\n+     * @param mayInterruptIfRunning\n+     *            {@code true} if the thread executing this task should be interrupted, {@code false} if the in-progress\n+     *            tasks are allowed to complete\n+     */\n+    private synchronized void stopJob(boolean mayInterruptIfRunning) {\n+        final ScheduledCompletableFuture<Void> localJobFuture = this.jobFuture;\n+        if (localJobFuture != null) {\n+            if (!localJobFuture.isCancelled()) {\n+                localJobFuture.cancel(mayInterruptIfRunning);\n+            }\n+            this.jobFuture = null;\n+        }\n+    }\n+\n+    /**\n+     * Action to be executed by the daily job: refresh the end dates list for \"manual\" mode.\n+     */\n+    private void dailyJob() {\n+        logger.debug(\"Module[{}] Daily job, refreshing the end dates list for \\\"manual\\\" mode\", thing.getUID());\n+        // Refresh the end dates list for \"manual\" mode\n+        dynamicStateDescriptionProvider.setEndDates(endDateChannelUID, config.getNumberOfEndDays());\n+        // If expired, update EndDate in module settings\n+        final ModuleSettings localModuleSettings = this.moduleSettings;\n+        if (localModuleSettings != null && localModuleSettings.isEndDateExpired()) {\n+            localModuleSettings.refreshEndDate();\n+            updateChannelState(CHANNEL_SETTINGS_ENDDATE, new StringType(localModuleSettings.getEndDate()));\n+        }\n+    }\n+\n+    // ===========================================================================\n+    //\n+    // Chronothermostat status polling mechanism methods\n+    //\n+    // ===========================================================================\n+\n+    /**\n+     * Starts a new scheduler to periodically poll and update this Chronothermostat status.\n+     */\n+    private void schedulePoll() {\n+        stopPoll(false);\n+\n+        // Schedule poll to start after POLL_INITIAL_DELAY sec and run periodically based on status refresh period\n+        final Future<?> localPollFuture = scheduler.scheduleWithFixedDelay(this::poll, POLL_INITIAL_DELAY,\n+                config.getStatusRefreshPeriod() * 60, TimeUnit.SECONDS);\n+        this.pollFuture = localPollFuture;\n+\n+        logger.debug(\"Module[{}] Scheduled poll for {} sec out, then every {} min\", thing.getUID(), POLL_INITIAL_DELAY,\n+                config.getStatusRefreshPeriod());\n+    }\n+\n+    /**\n+     * Cancels all running poll schedulers.\n+     *\n+     * @param mayInterruptIfRunning\n+     *            {@code true} if the thread executing this task should be interrupted, {@code false} if the in-progress\n+     *            tasks are allowed to complete\n+     */\n+    private synchronized void stopPoll(boolean mayInterruptIfRunning) {\n+        final Future<?> localPollFuture = this.pollFuture;\n+        if (localPollFuture != null) {\n+            if (!localPollFuture.isCancelled()) {\n+                localPollFuture.cancel(mayInterruptIfRunning);\n+            }\n+            this.pollFuture = null;\n+        }\n+    }\n+\n+    /**\n+     * Polls to update this Chronothermostat status.\n+     *\n+     * @return {@code true} if the method completes without errors, {@code false} otherwise\n+     */\n+    private synchronized boolean poll() {\n+        try {\n+            final Bridge bridge = getBridge();\n+            if (bridge != null) {\n+                final ThingStatusInfo bridgeStatusInfo = bridge.getStatusInfo();\n+                if (bridgeStatusInfo.getStatus() == ThingStatus.ONLINE) {\n+                    ModuleStatus moduleStatus = getBridgeHandler().getModuleStatus(config.getPlantId(),\n+                            config.getModuleId());\n+\n+                    final Chronothermostat statusChrono = moduleStatus.toChronothermostat();\n+                    if (statusChrono != null) {\n+                        if ((this.chronothermostat == null) || config.isSettingsAutoupdate()) {\n+                            final ModuleSettings localModuleSettings = this.moduleSettings;\n+                            if (localModuleSettings != null) {\n+                                localModuleSettings.updateFromChronothermostat(statusChrono);\n+                            }\n+                        }\n+                        this.chronothermostat = statusChrono;\n+                        logger.debug(\"Module[{}] Status: [{}]\", thing.getUID(), this.chronothermostat);\n+                    } else {\n+                        throw new SmartherGatewayException(\"No chronothermostat data found\");\n+                    }\n+\n+                    // Refresh the programs list for \"automatic\" mode\n+                    final ExpiringCache<List<Program>> localProgramCache = this.programCache;\n+                    if (localProgramCache != null) {\n+                        final List<Program> programs = localProgramCache.getValue();\n+                        if (programs != null) {\n+                            dynamicStateDescriptionProvider.setPrograms(programChannelUID, programs);\n+                        }\n+                    }\n+\n+                    updateModuleStatus();\n+\n+                    getBridgeHandler().registerNotification(config.getPlantId());\n+\n+                    // Everything is ok > set the Thing state to Online\n+                    updateStatus(ThingStatus.ONLINE);\n+                    return true;\n+                } else if (thing.getStatus() != ThingStatus.OFFLINE) {\n+                    logger.debug(\"Module[{}] Switched {} as Bridge is not online\", thing.getUID(),\n+                            bridgeStatusInfo.getStatus());\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.BRIDGE_OFFLINE, \"Smarther Bridge Offline\");\n+                }\n+            }\n+            return false;\n+        } catch (SmartherIllegalPropertyValueException e) {\n+            logger.debug(\"Module[{}] Illegal property value error during polling: {}\", thing.getUID(), e.getMessage());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, e.getMessage());\n+            schedulePoll();\n+            return false;\n+        } catch (SmartherSubscriptionAlreadyExistsException e) {\n+            logger.debug(\"Module[{}] Subscription error during polling: {}\", thing.getUID(), e.getMessage());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, e.getMessage());\n+            schedulePoll();\n+            return false;\n+        } catch (SmartherGatewayException e) {\n+            logger.warn(\"Module[{}] API Gateway error during polling: {}\", thing.getUID(), e.getMessage());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            schedulePoll();\n+            return false;\n+        } catch (RuntimeException e) {\n+            // All other exceptions apart from Subscription and Gateway issues\n+            logger.warn(\"Module[{}] Unexpected error during polling, please report if this keeps occurring: \",\n+                    thing.getUID(), e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, e.getMessage());\n+            schedulePoll();\n+            return false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b76ea0c1193e57298bdea1f8bcae9b3f10b90950"}, "originalPosition": 616}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE1NTMzMg==", "bodyText": "missing implementations?", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r439155332", "createdAt": "2020-06-12T01:09:41Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/api/SmartherApi.java", "diffHunk": "@@ -0,0 +1,481 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.api;\n+\n+import static org.eclipse.jetty.http.HttpMethod.*;\n+import static org.openhab.binding.smarther.internal.SmartherBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.IdentityHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.function.Function;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.eclipse.smarthome.core.auth.client.oauth2.AccessTokenResponse;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthClientService;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthException;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthResponseException;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.openhab.binding.smarther.internal.api.dto.Chronothermostat;\n+import org.openhab.binding.smarther.internal.api.dto.Enums.MeasureUnit;\n+import org.openhab.binding.smarther.internal.api.dto.Module;\n+import org.openhab.binding.smarther.internal.api.dto.ModuleStatus;\n+import org.openhab.binding.smarther.internal.api.dto.Plant;\n+import org.openhab.binding.smarther.internal.api.dto.Plants;\n+import org.openhab.binding.smarther.internal.api.dto.Program;\n+import org.openhab.binding.smarther.internal.api.dto.Subscription;\n+import org.openhab.binding.smarther.internal.api.dto.Topology;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherAuthorizationException;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherGatewayException;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherTokenExpiredException;\n+import org.openhab.binding.smarther.internal.model.ModuleSettings;\n+import org.openhab.binding.smarther.internal.util.ModelUtil;\n+import org.openhab.binding.smarther.internal.util.StringUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.reflect.TypeToken;\n+\n+/**\n+ * The {@code SmartherApi} class is used to communicate with the BTicino/Legrand API gateway.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmartherApi {\n+\n+    private static final String CONTENT_TYPE = \"application/json\";\n+    private static final String BEARER = \"Bearer \";\n+\n+    // API gateway request headers\n+    private static final String HEADER_ACCEPT = \"Accept\";\n+    // API gateway request attributes\n+    private static final String ATTR_FUNCTION = \"function\";\n+    private static final String ATTR_MODE = \"mode\";\n+    private static final String ATTR_PROGRAMS = \"programs\";\n+    private static final String ATTR_NUMBER = \"number\";\n+    private static final String ATTR_SETPOINT = \"setPoint\";\n+    private static final String ATTR_VALUE = \"value\";\n+    private static final String ATTR_UNIT = \"unit\";\n+    private static final String ATTR_ACTIVATION_TIME = \"activationTime\";\n+    private static final String ATTR_ENDPOINT_URL = \"EndPointUrl\";\n+    // API gateway operation paths\n+    private static final String PATH_PLANTS = \"/plants\";\n+    private static final String PATH_TOPOLOGY = PATH_PLANTS + \"/%s/topology\";\n+    private static final String PATH_MODULE = \"/chronothermostat/thermoregulation/addressLocation/plants/%s/modules/parameter/id/value/%s\";\n+    private static final String PATH_PROGRAMS = \"/programlist\";\n+    private static final String PATH_SUBSCRIPTIONS = \"/subscription\";\n+    private static final String PATH_SUBSCRIBE = PATH_PLANTS + \"/%s/subscription\";\n+    private static final String PATH_UNSUBSCRIBE = PATH_SUBSCRIBE + \"/%s\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private final OAuthClientService oAuthClientService;\n+    private final String oAuthSubscriptionKey;\n+    private final SmartherApiConnector connector;\n+\n+    /**\n+     * Constructs a {@code SmartherApi} to the API gateway with the specified OAuth2 attributes (subscription key and\n+     * client service), scheduler service and http client.\n+     *\n+     * @param clientService\n+     *            the OAuth2 authorization client service to be used\n+     * @param subscriptionKey\n+     *            the OAuth2 subscription key to be used with the given client service\n+     * @param scheduler\n+     *            the scheduler to be used to reschedule calls when rate limit exceeded or call not succeeded\n+     * @param httpClient\n+     *            the http client to be used to make http calls to the API gateway\n+     */\n+    public SmartherApi(final OAuthClientService clientService, final String subscriptionKey,\n+            final ScheduledExecutorService scheduler, final HttpClient httpClient) {\n+        this.oAuthClientService = clientService;\n+        this.oAuthSubscriptionKey = subscriptionKey;\n+        this.connector = new SmartherApiConnector(scheduler, httpClient);\n+    }\n+\n+    /**\n+     * Returns the plants registered under the Smarther account the bridge has been configured with.\n+     *\n+     * @return the list of registered plants, or an empty {@link List} in case of no plants found\n+     *\n+     * @throws {@link SmartherGatewayException}\n+     *             in case of communication issues with the API gateway\n+     */\n+    public List<Plant> getPlants() throws SmartherGatewayException {\n+        final ContentResponse response = requestBasic(GET, PATH_PLANTS);\n+        if (response.getStatus() == HttpStatus.NO_CONTENT_204) {\n+            return new ArrayList<>();\n+        } else {\n+            return ModelUtil.gsonInstance().fromJson(response.getContentAsString(), Plants.class).getPlants();\n+        }\n+    }\n+\n+    /**\n+     * Returns the chronothermostat modules registered in the given plant.\n+     *\n+     * @param plantId\n+     *            the identifier of the plant\n+     *\n+     * @return the list of registered modules, or an empty {@link List} in case the plant contains no module\n+     *\n+     * @throws {@link SmartherGatewayException}\n+     *             in case of communication issues with the API gateway\n+     */\n+    public List<Module> getPlantModules(String plantId) throws SmartherGatewayException {\n+        final ContentResponse response = requestBasic(GET, String.format(PATH_TOPOLOGY, plantId));\n+        final Topology topology = ModelUtil.gsonInstance().fromJson(response.getContentAsString(), Topology.class);\n+        return topology.getModules();\n+    }\n+\n+    /**\n+     * Returns the current status of a given chronothermostat module.\n+     *\n+     * @param plantId\n+     *            the identifier of the plant\n+     * @param moduleId\n+     *            the identifier of the chronothermostat module inside the plant\n+     *\n+     * @return the current status of the chronothermostat module\n+     *\n+     * @throws {@link SmartherGatewayException}\n+     *             in case of communication issues with the API gateway\n+     */\n+    public ModuleStatus getModuleStatus(String plantId, String moduleId) throws SmartherGatewayException {\n+        final ContentResponse response = requestModule(GET, plantId, moduleId, null);\n+        return ModelUtil.gsonInstance().fromJson(response.getContentAsString(), ModuleStatus.class);\n+    }\n+\n+    /**\n+     * Sends new settings to be applied to a given chronothermostat module.\n+     *\n+     * @param settings\n+     *            the module settings to be applied\n+     *\n+     * @return {@code true} if the settings have been successfully applied, {@code false} otherwise\n+     *\n+     * @throws {@link SmartherGatewayException}\n+     *             in case of communication issues with the API gateway\n+     */\n+    public boolean setModuleStatus(ModuleSettings settings) throws SmartherGatewayException {\n+        // Prepare request payload\n+        Map<String, Object> rootMap = new IdentityHashMap<String, Object>();\n+        rootMap.put(ATTR_FUNCTION, settings.getFunction().getValue());\n+        rootMap.put(ATTR_MODE, settings.getMode().getValue());\n+        switch (settings.getMode()) {\n+            case AUTOMATIC:\n+                // {\"function\":\"heating\",\"mode\":\"automatic\",\"programs\":[{\"number\":0}]}\n+                Map<String, Integer> programMap = new IdentityHashMap<String, Integer>();\n+                programMap.put(ATTR_NUMBER, Integer.valueOf(settings.getProgram()));\n+                List<Map<String, Integer>> programsList = new ArrayList<>();\n+                programsList.add(programMap);\n+                rootMap.put(ATTR_PROGRAMS, programsList);\n+                break;\n+            case MANUAL:\n+                // {\"function\":\"heating\",\"mode\":\"manual\",\"setPoint\":{\"value\":0.0,\"unit\":\"C\"},\"activationTime\":\"X\"}\n+                QuantityType<Temperature> newTemperature = settings.getSetPointTemperature(SIUnits.CELSIUS);\n+                if (newTemperature == null) {\n+                    throw new SmartherGatewayException(\"Invalid temperature unit transformation\");\n+                }\n+                Map<String, Object> setPointMap = new IdentityHashMap<String, Object>();\n+                setPointMap.put(ATTR_VALUE, newTemperature.doubleValue());\n+                setPointMap.put(ATTR_UNIT, MeasureUnit.CELSIUS.getValue());\n+                rootMap.put(ATTR_SETPOINT, setPointMap);\n+                rootMap.put(ATTR_ACTIVATION_TIME, settings.getActivationTime());\n+                break;\n+            case BOOST:\n+                // {\"function\":\"heating\",\"mode\":\"boost\",\"activationTime\":\"X\"}\n+                rootMap.put(ATTR_ACTIVATION_TIME, settings.getActivationTime());\n+                break;\n+            case OFF:\n+                // {\"function\":\"heating\",\"mode\":\"off\"}\n+                break;\n+            case PROTECTION:\n+                // {\"function\":\"heating\",\"mode\":\"protection\"}\n+                break;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b76ea0c1193e57298bdea1f8bcae9b3f10b90950"}, "originalPosition": 220}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE1NTc5OQ==", "bodyText": "Whats with MethodHandles.lookup().lookupClass()?\nShouldn't this just be SmartherAccountService.class?", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r439155799", "createdAt": "2020-06-12T01:11:35Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/account/SmartherAccountService.java", "diffHunk": "@@ -0,0 +1,296 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.account;\n+\n+import static org.openhab.binding.smarther.internal.SmartherBindingConstants.*;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.lang.invoke.MethodHandles;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Hashtable;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.smarther.internal.api.dto.Notification;\n+import org.openhab.binding.smarther.internal.api.dto.Sender;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherGatewayException;\n+import org.openhab.binding.smarther.internal.util.StringUtil;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.component.ComponentContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.http.HttpService;\n+import org.osgi.service.http.NamespaceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@code SmartherAccountService} class manages the servlets and bind authorization servlet to Bridges.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@Component(service = SmartherAccountService.class, immediate = true, configurationPid = \"binding.smarther.accountService\")\n+@NonNullByDefault\n+public class SmartherAccountService {\n+\n+    private static final String TEMPLATE_PATH = \"templates/\";\n+    private static final String IMAGE_PATH = \"web\";\n+    private static final String TEMPLATE_APPLICATION = TEMPLATE_PATH + \"application.html\";\n+    private static final String TEMPLATE_INDEX = TEMPLATE_PATH + \"index.html\";\n+    private static final String ERROR_UKNOWN_BRIDGE = \"Returned 'state' doesn't match any Bridges. Has the bridge been removed?\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b76ea0c1193e57298bdea1f8bcae9b3f10b90950"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE1NTg5NA==", "bodyText": "here too", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r439155894", "createdAt": "2020-06-12T01:11:59Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/account/SmartherAuthorizationServlet.java", "diffHunk": "@@ -0,0 +1,273 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.account;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.eclipse.jetty.util.MultiMap;\n+import org.eclipse.jetty.util.UrlEncoded;\n+import org.openhab.binding.smarther.internal.api.dto.Location;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherGatewayException;\n+import org.openhab.binding.smarther.internal.util.StringUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@code SmartherAuthorizationServlet} class acts as the registered endpoint for the user to automatically manage\n+ * the BTicino/Legrand API authorization process.\n+ * The servlet follows the OAuth2 Authorization Code flow, saving the resulting refreshToken within the Smarther Bridge.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmartherAuthorizationServlet extends HttpServlet {\n+\n+    private static final long serialVersionUID = 5199173744807168342L;\n+\n+    private static final String CONTENT_TYPE = \"text/html;charset=UTF-8\";\n+    private static final String X_FORWARDED_PROTO = \"X-Forwarded-Proto\";\n+\n+    // Http request parameters\n+    private static final String PARAM_CODE = \"code\";\n+    private static final String PARAM_STATE = \"state\";\n+    private static final String PARAM_ERROR = \"error\";\n+\n+    // Simple HTML templates for inserting messages.\n+    private static final String HTML_EMPTY_APPLICATIONS = \"<p class='block'>Manually add a Smarther Bridge to authorize it here<p>\";\n+    private static final String HTML_BRIDGE_AUTHORIZED = \"<p class='block authorized'>Bridge authorized for Client Id %s</p>\";\n+    private static final String HTML_ERROR = \"<p class='block error'>Call to Smarther API gateway failed with error: %s</p>\";\n+\n+    private static final Pattern MESSAGE_KEY_PATTERN = Pattern.compile(\"\\\\$\\\\{([^\\\\}]+)\\\\}\");\n+\n+    // Keys present in the index.html\n+    private static final String KEY_PAGE_REFRESH = \"pageRefresh\";\n+    private static final String HTML_META_REFRESH_CONTENT = \"<meta http-equiv='refresh' content='10; url=%s'>\";\n+    private static final String KEY_AUTHORIZED_BRIDGE = \"authorizedBridge\";\n+    private static final String KEY_ERROR = \"error\";\n+    private static final String KEY_APPLICATIONS = \"applications\";\n+    private static final String KEY_REDIRECT_URI = \"redirectUri\";\n+    // Keys present in the application.html\n+    private static final String APPLICATION_ID = \"application.id\";\n+    private static final String APPLICATION_NAME = \"application.name\";\n+    private static final String APPLICATION_LOCATIONS = \"application.locations\";\n+    private static final String APPLICATION_AUTHORIZED_CLASS = \"application.authorized\";\n+    private static final String APPLICATION_AUTHORIZE = \"application.authorize\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b76ea0c1193e57298bdea1f8bcae9b3f10b90950"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE1ODgzMw==", "bodyText": "If the contents of this is supposed to be unique, might as well make it a Set instead of a List.", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r439158833", "createdAt": "2020-06-12T01:24:22Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/account/SmartherAccountService.java", "diffHunk": "@@ -0,0 +1,296 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.account;\n+\n+import static org.openhab.binding.smarther.internal.SmartherBindingConstants.*;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.lang.invoke.MethodHandles;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Hashtable;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.smarther.internal.api.dto.Notification;\n+import org.openhab.binding.smarther.internal.api.dto.Sender;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherGatewayException;\n+import org.openhab.binding.smarther.internal.util.StringUtil;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.component.ComponentContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.http.HttpService;\n+import org.osgi.service.http.NamespaceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@code SmartherAccountService} class manages the servlets and bind authorization servlet to Bridges.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@Component(service = SmartherAccountService.class, immediate = true, configurationPid = \"binding.smarther.accountService\")\n+@NonNullByDefault\n+public class SmartherAccountService {\n+\n+    private static final String TEMPLATE_PATH = \"templates/\";\n+    private static final String IMAGE_PATH = \"web\";\n+    private static final String TEMPLATE_APPLICATION = TEMPLATE_PATH + \"application.html\";\n+    private static final String TEMPLATE_INDEX = TEMPLATE_PATH + \"index.html\";\n+    private static final String ERROR_UKNOWN_BRIDGE = \"Returned 'state' doesn't match any Bridges. Has the bridge been removed?\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private final List<SmartherAccountHandler> handlers = new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b76ea0c1193e57298bdea1f8bcae9b3f10b90950"}, "originalPosition": 65}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwMTE4ODYz", "url": "https://github.com/openhab/openhab-addons/pull/7533#pullrequestreview-430118863", "createdAt": "2020-06-13T06:43:46Z", "commit": {"oid": "e1312ca938bfc6de96ce4ebd43c2fc802d824ee0"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QwNjo0Mzo0N1rOGjWFFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QwNzoyMzoxNVrOGjWOEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcxNTA5Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            | temperature       | Number    | Read-only  | Indoor temperature as measured by the sensor                                           | Common   |\n          \n          \n            \n            | temperature       | Number:Temperature    | Read-only  | Indoor temperature as measured by the sensor                                           | Common   |\n          \n      \n    \n    \n  \n\nPlease update the other channels in the readme accordingly.", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r439715092", "createdAt": "2020-06-13T06:43:47Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.smarther/README.md", "diffHunk": "@@ -0,0 +1,328 @@\n+# BTicino Smarther Binding\n+\n+The Smarther binding implements a bridge to the Legrand/Bticino Smarther v2.0 API and allows you to control your BTicino Smarther chronothermostat units with openHAB, making it possible to discover Smarther units connected to your Legrand/BTicino Smarther account.\n+\n+Smarther chronothermostat is produced by Bticino (https://www.bticino.com/products-catalogue/smarther-the-connected-thermostat/), has its own API set and doesn't support the OpenWebNet protocol.\n+\n+Companion HABPanel widget can be found here: [BTicino Smarther HABPanel widget](https://github.com/MrRonfo/openhab-smarther-widget)\n+\n+# Configuring the binding\n+\n+The binding requires you to register an Application with Legrand Developer portal at https://developer.legrand.com\n+This will get you a set of Client ID and Client Secret parameters to be used by your binding configuration.\n+\n+Optionally, if you want to later receive push notifications on the status of your units, consider to make your openHAB installation reachable in https from a public IP or domain (see [Note on notifications](#note-on-notifications)).\n+\n+## Create an account\n+\n+Follow the instructions in the tutorial at https://developer.legrand.com/tutorials/getting-started/, under: \n+\n+* Step 1 : Create an account\n+* Step 2 : Subscribe to a product and get subscription key\n+\n+There's also a Step 3 in this tutorial, you can skip it as not needed to complete this process.\n+Simply write down your \"Primary Key\" as it will be needed later on in the setup.\n+\n+## Create an application\n+\n+Follow the instructions in the tutorial at https://developer.legrand.com/tutorials/create-an-application/, under: \n+\n+* Step 1 : Register your application\n+* Step 2 : Check scopes\n+* Step 3 : Getting application details\n+\n+When registering your new Legrand Application for openHAB Smarther Bridge you have to specify the allowed Reply URL, aka white-listed address.\n+Here you have to specify the URL to the Bridge Authorization page on your server.\n+\n+For example if you run your openHAB server on http://openhabianpi:8080 you should set `http://openhabianpi:8080/smarther/connectsmarther` as the \"First Reply URL\" required field in Step 1.\n+Other Reply URLs (second, third, etc.) you can leave them blank.\n+\n+This is **very important** since the authorize process with Legrand takes place using your client web browser and Legrand will have to know the right URL to your openHAB server for the authorization to be completed.\n+When you have authorized with Legrand, this Redirect URI is where authorization tokens for your openHAB Smarther Brigde will be sent and they have to be received by the servlet on `/smarther/connectsmarther`.\n+\n+![Application 1](doc/images/application-1.png)\n+\n+On Step 2, please make sure to select both `comfort.read` and `comfort.write` scopes, as they're mandatory for the binding to work.\n+\n+![Application 2](doc/images/application-2.png)\n+\n+Usually, Step 3 is then completed by Legrand within 1-2 days and you'll receive an email containing your application's Client ID and Client Secret.\n+\n+### Note on notifications\n+\n+If you want to later receive push notifications (device status) from Legrand for this application, you must have your openHAB server reachable from a public IP/address and use the related public IP/address and public port when filling-in the \"Reply URL\" field in Step 1.\n+\n+## Configure the binding\n+\n+1. Install the binding and make sure the _Smarther Binding_ is listed on your server.\n+2. Complete the _Create an account_ and _Create an application_ steps if you have not already done so (see above).\n+3. Make sure you have your Legrand account _Primary Key_ and your Legrand application _Client ID_ and _Client Secret_ identities available.\n+4. Go to your preferred openHAB admin UI and add a new Thing - select the **\"Smarther Bridge\"**.\n+5. Choose new Id for the bridge, unless you like the generated one.\n+6. Put in your _Primary Key_ (in _Subscription Key_ field), _Client ID_ and _Cliend Secret_ in their respective fields of the bridge configuration.\n+7. Set _Use Notifications_ to `ON` if your openHAB server is reachable from a public https URL (see [Note on notifications](#note-on-notifications)), set `OFF` otherwise.\n+8. You can leave the _Bridge Status Refresh Period_ as is.\n+9. Save the bridge.\n+10. The bridge thing will stay in state _INITIALIZING_ and eventually go _OFFLINE_ - this is fine, as you now have to authorize this bridge with Legrand.\n+11. Go to the authorization page of your server (see [Create an application](#create-an-application)) `http://<your openHAB address>:<your openHAB port>/smarther/connectsmarther`; your newly added bridge should be listed there (along with the available locations).\n+12. Press the _\"Authorize Bridge\"_ button; this will take you either to the login page of Legrand portal or directly to the authorization screen.\n+13. Login and/or authorize the application; if the Reply URL is correct you will be returned and the entry should show your Bridge is authorized with your Client ID; otherwise, go back to your application configuration on Legrand portal and ensure you have set the right Reply URL (see [Troubleshooting](#troubleshooting) below).\n+14. The binding will be updated with a refresh token and go _ONLINE_ (the refresh token is used to re-authorize the bridge with Legrand Smarther API whenever required).\n+\n+![Tutorial 1](doc/images/tutorial-1.png)\n+\n+![Tutorial 2](doc/images/tutorial-2.png)\n+\n+![Tutorial 3](doc/images/tutorial-3.png)\n+\n+Now that you have got your bridge _ONLINE_ it is time to discover your devices! Go to Paper UI Inbox and search for **\"Smarther Chronothermostat\"** things.\n+Any Smarther Chronothermostat device currently available on your account should show up immediately.\n+\n+If no devices show up you may have to trigger the openHAB discovery several times as bridge will only find active devices known by the Smarther API at the time the discovery is triggered.\n+\n+Should the bridge configuration be broken for any reason, the authorization procedure can be reinitiated from step 11 whenever required.\n+You can force reinitialization by authorizing again on the `/smarther/connectsmarther` page, even if the page shows it as already authorized. This will reset the refresh token.\n+\n+The following configuration options are available on the Smarther Bridge thing:\n+\n+| Parameter             | Description                                                                                                                                        | Condition |\n+|-----------------------|----------------------------------------------------------------------------------------------------------------------------------------------------|-----------|\n+| subscriptionKey       | This is the Primary Key provided by Legrand when you create a new Account and subscribe to a product                                               | Required  |\n+| clientId              | This is the Client ID provided by Legrand when you add a new Application for openHAB to your Legrand account                                       | Required  |\n+| clientSecret          | This is the Client Secret provided by Legrand when you add a new Application for openHAB to your Legrand account                                   | Required  |\n+| useNotifications      | ON = the bridge subscribes to receive push notifications on devices status change; OFF = status updates are requested (pull) on a periodical basis |           |\n+| statusRefreshPeriod   | This is the frequency of the polling requests to the Smarther API to update the bridge status (in minutes)                                         |           |\n+\n+The following configuration options are available on the Smarther Chronothermostat thing:\n+\n+| Parameter             | Description                                                                                                                                        | Condition |\n+|-----------------------|----------------------------------------------------------------------------------------------------------------------------------------------------|-----------|\n+| plantId               | This is the Plant Id of the location the Chronothermostat module is installed in, provided by Smarther API                                         | Read-only |\n+| moduleId              | This is the Module Id of the Chronothermostat module, provided by Smarther API                                                                     | Read-only |\n+| settingsAutoupdate    | ON = the thermostat settings are aligned with current status whenever it changes; OFF = settings are aligned to status only upon initialization    |           |\n+| programsRefreshPeriod | This is the frequency the Smarther API gateway is called to refresh Programs list used in \"automatic\" mode (in hours)                              |           |\n+| numberOfEndDays       | This is the number of days to be displayed in module settings, as options list for \"End Date\" field in \"manual\" mode                               |           |\n+| statusRefreshPeriod   | This is the frequency of the polling requests to the Smarther API to update the module status and sensor data (in minutes)                         |           |\n+\n+## Troubleshooting\n+\n+When configuring the binding (see step 13 [here](#configure-the-binding)), you can receive the following error from Legrand portal:\n+\n+```\n+{\n+  \"error\": \"invalid_request\",\n+  \"error_description\": \"The reply url host xxxxx doesn't match with the ones configured on the application\"\n+}\n+```\n+\n+This means you've either opened the `/smarther/connectsmarther` page from the wrong address or set the wrong \"Reply URL\" attribute in your application (see step 1 [here](#create-an-application)).\n+Please remember these two strings must match for authentication process to work.\n+\n+To solve the issue, either:\n+\n+* Correct the address you're accessing the `/smarther/connectsmarther` page from, to match the \"Reply URL\" attribute registered in your application, or\n+* Should you have specified a wrong \"Reply URL\" attribute in your application, go to the Legrand portal and correct it accordingly then resubmit the application for approval.\n+\n+## Supported Things\n+\n+All Smarther Chronothermostat device models should be discoverable through this binding:\n+\n+* Flush mounting installation item (X8000)\n+* Wall installation item (X8000W)\n+\n+If you can control them from BTicino Thermostat mobile app on your iPhone/Android you should be able to add it as a thing.\n+\n+## Discovery\n+\n+As long as Smarther Chronothermostat devices are available in the locations registered on the user account configured with the Bridge they should show up whenever you initiate discovery of things.\n+\n+If no devices are showing up, try to connect to the device(s) from your smartphone to make sure the device(s) are in use by your user account.\n+\n+The discovery of devices in the Smarther API is based on what is known by Legrand.\n+There is difference between e.g. smartphones and computers which can discover devices on the local network and the Smarther API which is not able to do so; it only knows about a device if your account is currently associated with the device.\n+\n+## Channels\n+\n+### Bridge\n+\n+The channels on the bridge are the ones used to get details of current communication with Smarther API on the Legrand account associated with the bridge.\n+\n+**Status Channels:**\n+\n+The following channels represent the current operational status of the bridge and must all be referenced with the `status#` prefix.\n+\n+| Channel Type ID   | Item Type | Read/Write | Description                                                                            | Type     |\n+|-------------------|-----------|------------|----------------------------------------------------------------------------------------|----------|\n+| apiCallsHandled   | Number    | Read-only  | The total number of API calls handled by the bridge                                    | Common   |\n+| notifsReceived    | Number    | Read-only  | The total number of push notifications received by the bridge                          | Common   |\n+| notifsRejected    | Number    | Read-only  | The total number of push notifications rejected by the bridge                          | Common   |\n+\n+**Configuration Channels:**\n+\n+The following channels represent convenience configuration channels for the bridge and must all be referenced with the `config#` prefix.\n+\n+| Channel Type ID   | Item Type | Read/Write | Description                                                                            | Type     |\n+|-------------------|-----------|------------|----------------------------------------------------------------------------------------|----------|\n+| fetchConfig       | Switch    | Read-write | Trigger to manually fetch updated bridge configuration from Smarther API               | Advanced |\n+| accessToken       | String    | Read-only  | The current accessToken used in communication with Smarther API                        | Advanced |\n+\n+### Devices\n+\n+The temperature channels have dimension `Number:Temperature` and a precision of one tenth degree Celsius.\n+\n+**Measures Channels:**\n+\n+The following channels represent the measures taken from the module on-board sensors and must all be referenced with the `measures#` prefix.\n+\n+| Channel Type ID   | Item Type | Read/Write | Description                                                                            | Type     |\n+|-------------------|-----------|------------|----------------------------------------------------------------------------------------|----------|\n+| temperature       | Number    | Read-only  | Indoor temperature as measured by the sensor                                           | Common   |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1312ca938bfc6de96ce4ebd43c2fc802d824ee0"}, "originalPosition": 179}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcxNTE5MQ==", "bodyText": "handlers is a set so you don't need to bother checking if it already contains it or not.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (!handlers.contains(handler)) {\n          \n          \n            \n                        handlers.add(handler);\n          \n          \n            \n                    }\n          \n          \n            \n                    handlers.add(handler);", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r439715191", "createdAt": "2020-06-13T06:45:21Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/account/SmartherAccountService.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.account;\n+\n+import static org.openhab.binding.smarther.internal.SmartherBindingConstants.*;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URL;\n+import java.util.HashSet;\n+import java.util.Hashtable;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.smarther.internal.api.dto.Notification;\n+import org.openhab.binding.smarther.internal.api.dto.Sender;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherGatewayException;\n+import org.openhab.binding.smarther.internal.util.StringUtil;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.component.ComponentContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.http.HttpService;\n+import org.osgi.service.http.NamespaceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@code SmartherAccountService} class manages the servlets and bind authorization servlet to Bridges.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@Component(service = SmartherAccountService.class, immediate = true, configurationPid = \"binding.smarther.accountService\")\n+@NonNullByDefault\n+public class SmartherAccountService {\n+\n+    private static final String TEMPLATE_PATH = \"templates/\";\n+    private static final String IMAGE_PATH = \"web\";\n+    private static final String TEMPLATE_APPLICATION = TEMPLATE_PATH + \"application.html\";\n+    private static final String TEMPLATE_INDEX = TEMPLATE_PATH + \"index.html\";\n+    private static final String ERROR_UKNOWN_BRIDGE = \"Returned 'state' doesn't match any Bridges. Has the bridge been removed?\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(SmartherAccountService.class);\n+\n+    private final Set<SmartherAccountHandler> handlers = new HashSet<>();\n+\n+    private @Nullable HttpService httpService;\n+    private @Nullable BundleContext bundleContext;\n+\n+    @Activate\n+    protected void activate(ComponentContext componentContext, Map<String, Object> properties) {\n+        try {\n+            this.bundleContext = componentContext.getBundleContext();\n+\n+            final HttpService localHttpService = this.httpService;\n+            if (localHttpService != null) {\n+                // Register the authorization servlet\n+                localHttpService.registerServlet(AUTH_SERVLET_ALIAS, createAuthorizationServlet(), new Hashtable<>(),\n+                        localHttpService.createDefaultHttpContext());\n+                localHttpService.registerResources(AUTH_SERVLET_ALIAS + IMG_SERVLET_ALIAS, IMAGE_PATH, null);\n+\n+                // Register the notification servlet\n+                localHttpService.registerServlet(NOTIFY_SERVLET_ALIAS, createNotificationServlet(), new Hashtable<>(),\n+                        localHttpService.createDefaultHttpContext());\n+            }\n+        } catch (NamespaceException | ServletException | IOException e) {\n+            logger.warn(\"Error during Smarther servlet startup\", e);\n+        }\n+    }\n+\n+    @Deactivate\n+    protected void deactivate(ComponentContext componentContext) {\n+        final HttpService localHttpService = this.httpService;\n+        if (localHttpService != null) {\n+            // Unregister the authorization servlet\n+            localHttpService.unregister(AUTH_SERVLET_ALIAS);\n+            localHttpService.unregister(AUTH_SERVLET_ALIAS + IMG_SERVLET_ALIAS);\n+\n+            // Unregister the notification servlet\n+            localHttpService.unregister(NOTIFY_SERVLET_ALIAS);\n+        }\n+    }\n+\n+    /**\n+     * Constructs a {@code SmartherAuthorizationServlet}.\n+     *\n+     * @return the newly created servlet\n+     *\n+     * @throws {@link IOException}\n+     *             in case of issues reading one of the internal html templates\n+     */\n+    private HttpServlet createAuthorizationServlet() throws IOException {\n+        return new SmartherAuthorizationServlet(this, readTemplate(TEMPLATE_INDEX), readTemplate(TEMPLATE_APPLICATION));\n+    }\n+\n+    /**\n+     * Constructs a {@code SmartherNotificationServlet}.\n+     *\n+     * @return the newly created servlet\n+     */\n+    private HttpServlet createNotificationServlet() {\n+        return new SmartherNotificationServlet(this);\n+    }\n+\n+    /**\n+     * Reads a template from file and returns its content as string.\n+     *\n+     * @param templateName\n+     *            the name of the template file to read\n+     *\n+     * @return a string representing the content of the template file\n+     *\n+     * @throws {@link IOException}\n+     *             in case of issues reading the template from file\n+     */\n+    private String readTemplate(String templateName) throws IOException {\n+        final BundleContext localBundleContext = this.bundleContext;\n+        if (localBundleContext != null) {\n+            final URL index = localBundleContext.getBundle().getEntry(templateName);\n+\n+            if (index == null) {\n+                throw new FileNotFoundException(String\n+                        .format(\"Cannot find template '%s' - failed to initialize Smarther servlet\", templateName));\n+            } else {\n+                try (InputStream input = index.openStream()) {\n+                    return StringUtil.streamToString(input);\n+                }\n+            }\n+        } else {\n+            throw new IOException(\"Cannot get template, bundle context is null\");\n+        }\n+    }\n+\n+    /**\n+     * Dispatches the received Smarther API authorization response to the proper Smarther account handler.\n+     * Part of the Legrand/Bticino OAuth2 authorization process.\n+     *\n+     * @param servletBaseURL\n+     *            the authorization servlet url needed to derive the notification endpoint url\n+     * @param state\n+     *            the authorization state needed to match the correct Smarther account handler to authorize\n+     * @param code The BTicino/Legrand API returned code value\n+     *            the authorization code to authorize with the account handler\n+     *\n+     * @return a string containing the name of the authorized BTicino/Legrand portal user\n+     *\n+     * @throws {@link SmartherGatewayException}\n+     *             in case of communication issues with the Smarther API or no account handler found\n+     */\n+    public String dispatchAuthorization(String servletBaseURL, String state, String code)\n+            throws SmartherGatewayException {\n+        // Searches the SmartherAccountHandler instance that matches the given state\n+        final SmartherAccountHandler listener = getAccountListenerByUID(state);\n+        if (listener == null) {\n+            logger.debug(\n+                    \"BTicino/Legrand API redirected with state '{}' but no matching bridge was found. Possible bridge has been removed.\",\n+                    state);\n+            throw new SmartherGatewayException(ERROR_UKNOWN_BRIDGE);\n+        }\n+\n+        // Generates the notification URL from servletBaseURL\n+        final String notificationUrl = servletBaseURL.replace(AUTH_SERVLET_ALIAS, NOTIFY_SERVLET_ALIAS);\n+\n+        logger.debug(\"Calling authorize on {}\", listener.getUID());\n+\n+        // Passes the authorization to the handler\n+        return listener.authorize(servletBaseURL, code, notificationUrl);\n+    }\n+\n+    /**\n+     * Dispatches the received C2C Webhook notification to the proper Smarther notification handler.\n+     *\n+     * @param notification\n+     *            the received notification to handle\n+     *\n+     * @throws {@link SmartherGatewayException}\n+     *             in case of communication issues with the Smarther API or no notification handler found\n+     */\n+    public void dispatchNotification(Notification notification) throws SmartherGatewayException {\n+        // Searches the SmartherAccountHandler instance that matches the given location\n+        final Sender sender = notification.getSender();\n+        if (sender != null) {\n+            final SmartherAccountHandler listener = getAccountListenerByLocation(sender.getPlant().getId());\n+            if (listener == null) {\n+                logger.warn(\"C2C notification [{}]: no matching bridge was found. Possible bridge has been removed.\",\n+                        notification.getId());\n+                throw new SmartherGatewayException(ERROR_UKNOWN_BRIDGE);\n+            } else if (listener.isOnline()) {\n+                final SmartherNotificationHandler handler = (SmartherNotificationHandler) listener;\n+\n+                if (handler.useNotifications()) {\n+                    // Passes the notification to the handler\n+                    handler.handleNotification(notification);\n+                } else {\n+                    logger.debug(\n+                            \"C2C notification [{}]: notification discarded as bridge does not handle notifications.\",\n+                            notification.getId());\n+                }\n+            } else {\n+                logger.debug(\"C2C notification [{}]: notification discarded as bridge is offline.\",\n+                        notification.getId());\n+            }\n+        } else {\n+            logger.debug(\"C2C notification [{}]: notification discarded as payload is invalid.\", notification.getId());\n+        }\n+    }\n+\n+    /**\n+     * Adds a {@link SmartherAccountHandler} handler to the set of account service handlers.\n+     *\n+     * @param handler\n+     *            the handler to add to the handlers set\n+     */\n+    public void addSmartherAccountHandler(SmartherAccountHandler handler) {\n+        if (!handlers.contains(handler)) {\n+            handlers.add(handler);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1312ca938bfc6de96ce4ebd43c2fc802d824ee0"}, "originalPosition": 236}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcxNTI3Mw==", "bodyText": "No idea if it needs to be thread-safe or not, but lets just make it thread-safe just to be safe.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private final Set<SmartherAccountHandler> handlers = new HashSet<>();\n          \n          \n            \n                private final Set<SmartherAccountHandler> handlers = new ConcurrentHashSet<>();", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r439715273", "createdAt": "2020-06-13T06:46:34Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/account/SmartherAccountService.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.account;\n+\n+import static org.openhab.binding.smarther.internal.SmartherBindingConstants.*;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URL;\n+import java.util.HashSet;\n+import java.util.Hashtable;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.smarther.internal.api.dto.Notification;\n+import org.openhab.binding.smarther.internal.api.dto.Sender;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherGatewayException;\n+import org.openhab.binding.smarther.internal.util.StringUtil;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.component.ComponentContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.http.HttpService;\n+import org.osgi.service.http.NamespaceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@code SmartherAccountService} class manages the servlets and bind authorization servlet to Bridges.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@Component(service = SmartherAccountService.class, immediate = true, configurationPid = \"binding.smarther.accountService\")\n+@NonNullByDefault\n+public class SmartherAccountService {\n+\n+    private static final String TEMPLATE_PATH = \"templates/\";\n+    private static final String IMAGE_PATH = \"web\";\n+    private static final String TEMPLATE_APPLICATION = TEMPLATE_PATH + \"application.html\";\n+    private static final String TEMPLATE_INDEX = TEMPLATE_PATH + \"index.html\";\n+    private static final String ERROR_UKNOWN_BRIDGE = \"Returned 'state' doesn't match any Bridges. Has the bridge been removed?\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(SmartherAccountService.class);\n+\n+    private final Set<SmartherAccountHandler> handlers = new HashSet<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1312ca938bfc6de96ce4ebd43c2fc802d824ee0"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcxNTQwNw==", "bodyText": "This should work I think...\nBut the null checker and generic types might also collide in spectacular fashion so lets cross our finger.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    final Optional<SmartherAccountHandler> maybeListener = handlers.stream().filter(l -> l.equalsThingUID(thingUID))\n          \n          \n            \n                            .findFirst();\n          \n          \n            \n                    return (maybeListener.isPresent()) ? maybeListener.get() : null;\n          \n          \n            \n                    handlers.stream().filter(l -> l.equalsThingUID(thingUID)).findFirst().orElse(null);", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r439715407", "createdAt": "2020-06-13T06:48:47Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/account/SmartherAccountService.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.account;\n+\n+import static org.openhab.binding.smarther.internal.SmartherBindingConstants.*;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URL;\n+import java.util.HashSet;\n+import java.util.Hashtable;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.smarther.internal.api.dto.Notification;\n+import org.openhab.binding.smarther.internal.api.dto.Sender;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherGatewayException;\n+import org.openhab.binding.smarther.internal.util.StringUtil;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.component.ComponentContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.http.HttpService;\n+import org.osgi.service.http.NamespaceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@code SmartherAccountService} class manages the servlets and bind authorization servlet to Bridges.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@Component(service = SmartherAccountService.class, immediate = true, configurationPid = \"binding.smarther.accountService\")\n+@NonNullByDefault\n+public class SmartherAccountService {\n+\n+    private static final String TEMPLATE_PATH = \"templates/\";\n+    private static final String IMAGE_PATH = \"web\";\n+    private static final String TEMPLATE_APPLICATION = TEMPLATE_PATH + \"application.html\";\n+    private static final String TEMPLATE_INDEX = TEMPLATE_PATH + \"index.html\";\n+    private static final String ERROR_UKNOWN_BRIDGE = \"Returned 'state' doesn't match any Bridges. Has the bridge been removed?\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(SmartherAccountService.class);\n+\n+    private final Set<SmartherAccountHandler> handlers = new HashSet<>();\n+\n+    private @Nullable HttpService httpService;\n+    private @Nullable BundleContext bundleContext;\n+\n+    @Activate\n+    protected void activate(ComponentContext componentContext, Map<String, Object> properties) {\n+        try {\n+            this.bundleContext = componentContext.getBundleContext();\n+\n+            final HttpService localHttpService = this.httpService;\n+            if (localHttpService != null) {\n+                // Register the authorization servlet\n+                localHttpService.registerServlet(AUTH_SERVLET_ALIAS, createAuthorizationServlet(), new Hashtable<>(),\n+                        localHttpService.createDefaultHttpContext());\n+                localHttpService.registerResources(AUTH_SERVLET_ALIAS + IMG_SERVLET_ALIAS, IMAGE_PATH, null);\n+\n+                // Register the notification servlet\n+                localHttpService.registerServlet(NOTIFY_SERVLET_ALIAS, createNotificationServlet(), new Hashtable<>(),\n+                        localHttpService.createDefaultHttpContext());\n+            }\n+        } catch (NamespaceException | ServletException | IOException e) {\n+            logger.warn(\"Error during Smarther servlet startup\", e);\n+        }\n+    }\n+\n+    @Deactivate\n+    protected void deactivate(ComponentContext componentContext) {\n+        final HttpService localHttpService = this.httpService;\n+        if (localHttpService != null) {\n+            // Unregister the authorization servlet\n+            localHttpService.unregister(AUTH_SERVLET_ALIAS);\n+            localHttpService.unregister(AUTH_SERVLET_ALIAS + IMG_SERVLET_ALIAS);\n+\n+            // Unregister the notification servlet\n+            localHttpService.unregister(NOTIFY_SERVLET_ALIAS);\n+        }\n+    }\n+\n+    /**\n+     * Constructs a {@code SmartherAuthorizationServlet}.\n+     *\n+     * @return the newly created servlet\n+     *\n+     * @throws {@link IOException}\n+     *             in case of issues reading one of the internal html templates\n+     */\n+    private HttpServlet createAuthorizationServlet() throws IOException {\n+        return new SmartherAuthorizationServlet(this, readTemplate(TEMPLATE_INDEX), readTemplate(TEMPLATE_APPLICATION));\n+    }\n+\n+    /**\n+     * Constructs a {@code SmartherNotificationServlet}.\n+     *\n+     * @return the newly created servlet\n+     */\n+    private HttpServlet createNotificationServlet() {\n+        return new SmartherNotificationServlet(this);\n+    }\n+\n+    /**\n+     * Reads a template from file and returns its content as string.\n+     *\n+     * @param templateName\n+     *            the name of the template file to read\n+     *\n+     * @return a string representing the content of the template file\n+     *\n+     * @throws {@link IOException}\n+     *             in case of issues reading the template from file\n+     */\n+    private String readTemplate(String templateName) throws IOException {\n+        final BundleContext localBundleContext = this.bundleContext;\n+        if (localBundleContext != null) {\n+            final URL index = localBundleContext.getBundle().getEntry(templateName);\n+\n+            if (index == null) {\n+                throw new FileNotFoundException(String\n+                        .format(\"Cannot find template '%s' - failed to initialize Smarther servlet\", templateName));\n+            } else {\n+                try (InputStream input = index.openStream()) {\n+                    return StringUtil.streamToString(input);\n+                }\n+            }\n+        } else {\n+            throw new IOException(\"Cannot get template, bundle context is null\");\n+        }\n+    }\n+\n+    /**\n+     * Dispatches the received Smarther API authorization response to the proper Smarther account handler.\n+     * Part of the Legrand/Bticino OAuth2 authorization process.\n+     *\n+     * @param servletBaseURL\n+     *            the authorization servlet url needed to derive the notification endpoint url\n+     * @param state\n+     *            the authorization state needed to match the correct Smarther account handler to authorize\n+     * @param code The BTicino/Legrand API returned code value\n+     *            the authorization code to authorize with the account handler\n+     *\n+     * @return a string containing the name of the authorized BTicino/Legrand portal user\n+     *\n+     * @throws {@link SmartherGatewayException}\n+     *             in case of communication issues with the Smarther API or no account handler found\n+     */\n+    public String dispatchAuthorization(String servletBaseURL, String state, String code)\n+            throws SmartherGatewayException {\n+        // Searches the SmartherAccountHandler instance that matches the given state\n+        final SmartherAccountHandler listener = getAccountListenerByUID(state);\n+        if (listener == null) {\n+            logger.debug(\n+                    \"BTicino/Legrand API redirected with state '{}' but no matching bridge was found. Possible bridge has been removed.\",\n+                    state);\n+            throw new SmartherGatewayException(ERROR_UKNOWN_BRIDGE);\n+        }\n+\n+        // Generates the notification URL from servletBaseURL\n+        final String notificationUrl = servletBaseURL.replace(AUTH_SERVLET_ALIAS, NOTIFY_SERVLET_ALIAS);\n+\n+        logger.debug(\"Calling authorize on {}\", listener.getUID());\n+\n+        // Passes the authorization to the handler\n+        return listener.authorize(servletBaseURL, code, notificationUrl);\n+    }\n+\n+    /**\n+     * Dispatches the received C2C Webhook notification to the proper Smarther notification handler.\n+     *\n+     * @param notification\n+     *            the received notification to handle\n+     *\n+     * @throws {@link SmartherGatewayException}\n+     *             in case of communication issues with the Smarther API or no notification handler found\n+     */\n+    public void dispatchNotification(Notification notification) throws SmartherGatewayException {\n+        // Searches the SmartherAccountHandler instance that matches the given location\n+        final Sender sender = notification.getSender();\n+        if (sender != null) {\n+            final SmartherAccountHandler listener = getAccountListenerByLocation(sender.getPlant().getId());\n+            if (listener == null) {\n+                logger.warn(\"C2C notification [{}]: no matching bridge was found. Possible bridge has been removed.\",\n+                        notification.getId());\n+                throw new SmartherGatewayException(ERROR_UKNOWN_BRIDGE);\n+            } else if (listener.isOnline()) {\n+                final SmartherNotificationHandler handler = (SmartherNotificationHandler) listener;\n+\n+                if (handler.useNotifications()) {\n+                    // Passes the notification to the handler\n+                    handler.handleNotification(notification);\n+                } else {\n+                    logger.debug(\n+                            \"C2C notification [{}]: notification discarded as bridge does not handle notifications.\",\n+                            notification.getId());\n+                }\n+            } else {\n+                logger.debug(\"C2C notification [{}]: notification discarded as bridge is offline.\",\n+                        notification.getId());\n+            }\n+        } else {\n+            logger.debug(\"C2C notification [{}]: notification discarded as payload is invalid.\", notification.getId());\n+        }\n+    }\n+\n+    /**\n+     * Adds a {@link SmartherAccountHandler} handler to the set of account service handlers.\n+     *\n+     * @param handler\n+     *            the handler to add to the handlers set\n+     */\n+    public void addSmartherAccountHandler(SmartherAccountHandler handler) {\n+        if (!handlers.contains(handler)) {\n+            handlers.add(handler);\n+        }\n+    }\n+\n+    /**\n+     * Removes a {@link SmartherAccountHandler} handler from the set of account service handlers.\n+     *\n+     * @param handler\n+     *            the handler to remove from the handlers set\n+     */\n+    public void removeSmartherAccountHandler(SmartherAccountHandler handler) {\n+        handlers.remove(handler);\n+    }\n+\n+    /**\n+     * Returns all the {@link SmartherAccountHandler} account service handlers.\n+     *\n+     * @return a set containing all the account service handlers\n+     */\n+    public Set<SmartherAccountHandler> getSmartherAccountHandlers() {\n+        return handlers;\n+    }\n+\n+    /**\n+     * Searches the {@link SmartherAccountHandler} handler that matches the given Thing UID.\n+     *\n+     * @param thingUID\n+     *            the UID of the Thing to match the handler with\n+     *\n+     * @return the handler matching the given Thing UID, or {@code null} if none matches\n+     */\n+    private @Nullable SmartherAccountHandler getAccountListenerByUID(String thingUID) {\n+        final Optional<SmartherAccountHandler> maybeListener = handlers.stream().filter(l -> l.equalsThingUID(thingUID))\n+                .findFirst();\n+        return (maybeListener.isPresent()) ? maybeListener.get() : null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1312ca938bfc6de96ce4ebd43c2fc802d824ee0"}, "originalPosition": 269}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcxNTQ4Ng==", "bodyText": "Should this method be renamed?", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r439715486", "createdAt": "2020-06-13T06:50:08Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/account/SmartherAccountService.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.account;\n+\n+import static org.openhab.binding.smarther.internal.SmartherBindingConstants.*;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URL;\n+import java.util.HashSet;\n+import java.util.Hashtable;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.smarther.internal.api.dto.Notification;\n+import org.openhab.binding.smarther.internal.api.dto.Sender;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherGatewayException;\n+import org.openhab.binding.smarther.internal.util.StringUtil;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.component.ComponentContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.http.HttpService;\n+import org.osgi.service.http.NamespaceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@code SmartherAccountService} class manages the servlets and bind authorization servlet to Bridges.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@Component(service = SmartherAccountService.class, immediate = true, configurationPid = \"binding.smarther.accountService\")\n+@NonNullByDefault\n+public class SmartherAccountService {\n+\n+    private static final String TEMPLATE_PATH = \"templates/\";\n+    private static final String IMAGE_PATH = \"web\";\n+    private static final String TEMPLATE_APPLICATION = TEMPLATE_PATH + \"application.html\";\n+    private static final String TEMPLATE_INDEX = TEMPLATE_PATH + \"index.html\";\n+    private static final String ERROR_UKNOWN_BRIDGE = \"Returned 'state' doesn't match any Bridges. Has the bridge been removed?\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(SmartherAccountService.class);\n+\n+    private final Set<SmartherAccountHandler> handlers = new HashSet<>();\n+\n+    private @Nullable HttpService httpService;\n+    private @Nullable BundleContext bundleContext;\n+\n+    @Activate\n+    protected void activate(ComponentContext componentContext, Map<String, Object> properties) {\n+        try {\n+            this.bundleContext = componentContext.getBundleContext();\n+\n+            final HttpService localHttpService = this.httpService;\n+            if (localHttpService != null) {\n+                // Register the authorization servlet\n+                localHttpService.registerServlet(AUTH_SERVLET_ALIAS, createAuthorizationServlet(), new Hashtable<>(),\n+                        localHttpService.createDefaultHttpContext());\n+                localHttpService.registerResources(AUTH_SERVLET_ALIAS + IMG_SERVLET_ALIAS, IMAGE_PATH, null);\n+\n+                // Register the notification servlet\n+                localHttpService.registerServlet(NOTIFY_SERVLET_ALIAS, createNotificationServlet(), new Hashtable<>(),\n+                        localHttpService.createDefaultHttpContext());\n+            }\n+        } catch (NamespaceException | ServletException | IOException e) {\n+            logger.warn(\"Error during Smarther servlet startup\", e);\n+        }\n+    }\n+\n+    @Deactivate\n+    protected void deactivate(ComponentContext componentContext) {\n+        final HttpService localHttpService = this.httpService;\n+        if (localHttpService != null) {\n+            // Unregister the authorization servlet\n+            localHttpService.unregister(AUTH_SERVLET_ALIAS);\n+            localHttpService.unregister(AUTH_SERVLET_ALIAS + IMG_SERVLET_ALIAS);\n+\n+            // Unregister the notification servlet\n+            localHttpService.unregister(NOTIFY_SERVLET_ALIAS);\n+        }\n+    }\n+\n+    /**\n+     * Constructs a {@code SmartherAuthorizationServlet}.\n+     *\n+     * @return the newly created servlet\n+     *\n+     * @throws {@link IOException}\n+     *             in case of issues reading one of the internal html templates\n+     */\n+    private HttpServlet createAuthorizationServlet() throws IOException {\n+        return new SmartherAuthorizationServlet(this, readTemplate(TEMPLATE_INDEX), readTemplate(TEMPLATE_APPLICATION));\n+    }\n+\n+    /**\n+     * Constructs a {@code SmartherNotificationServlet}.\n+     *\n+     * @return the newly created servlet\n+     */\n+    private HttpServlet createNotificationServlet() {\n+        return new SmartherNotificationServlet(this);\n+    }\n+\n+    /**\n+     * Reads a template from file and returns its content as string.\n+     *\n+     * @param templateName\n+     *            the name of the template file to read\n+     *\n+     * @return a string representing the content of the template file\n+     *\n+     * @throws {@link IOException}\n+     *             in case of issues reading the template from file\n+     */\n+    private String readTemplate(String templateName) throws IOException {\n+        final BundleContext localBundleContext = this.bundleContext;\n+        if (localBundleContext != null) {\n+            final URL index = localBundleContext.getBundle().getEntry(templateName);\n+\n+            if (index == null) {\n+                throw new FileNotFoundException(String\n+                        .format(\"Cannot find template '%s' - failed to initialize Smarther servlet\", templateName));\n+            } else {\n+                try (InputStream input = index.openStream()) {\n+                    return StringUtil.streamToString(input);\n+                }\n+            }\n+        } else {\n+            throw new IOException(\"Cannot get template, bundle context is null\");\n+        }\n+    }\n+\n+    /**\n+     * Dispatches the received Smarther API authorization response to the proper Smarther account handler.\n+     * Part of the Legrand/Bticino OAuth2 authorization process.\n+     *\n+     * @param servletBaseURL\n+     *            the authorization servlet url needed to derive the notification endpoint url\n+     * @param state\n+     *            the authorization state needed to match the correct Smarther account handler to authorize\n+     * @param code The BTicino/Legrand API returned code value\n+     *            the authorization code to authorize with the account handler\n+     *\n+     * @return a string containing the name of the authorized BTicino/Legrand portal user\n+     *\n+     * @throws {@link SmartherGatewayException}\n+     *             in case of communication issues with the Smarther API or no account handler found\n+     */\n+    public String dispatchAuthorization(String servletBaseURL, String state, String code)\n+            throws SmartherGatewayException {\n+        // Searches the SmartherAccountHandler instance that matches the given state\n+        final SmartherAccountHandler listener = getAccountListenerByUID(state);\n+        if (listener == null) {\n+            logger.debug(\n+                    \"BTicino/Legrand API redirected with state '{}' but no matching bridge was found. Possible bridge has been removed.\",\n+                    state);\n+            throw new SmartherGatewayException(ERROR_UKNOWN_BRIDGE);\n+        }\n+\n+        // Generates the notification URL from servletBaseURL\n+        final String notificationUrl = servletBaseURL.replace(AUTH_SERVLET_ALIAS, NOTIFY_SERVLET_ALIAS);\n+\n+        logger.debug(\"Calling authorize on {}\", listener.getUID());\n+\n+        // Passes the authorization to the handler\n+        return listener.authorize(servletBaseURL, code, notificationUrl);\n+    }\n+\n+    /**\n+     * Dispatches the received C2C Webhook notification to the proper Smarther notification handler.\n+     *\n+     * @param notification\n+     *            the received notification to handle\n+     *\n+     * @throws {@link SmartherGatewayException}\n+     *             in case of communication issues with the Smarther API or no notification handler found\n+     */\n+    public void dispatchNotification(Notification notification) throws SmartherGatewayException {\n+        // Searches the SmartherAccountHandler instance that matches the given location\n+        final Sender sender = notification.getSender();\n+        if (sender != null) {\n+            final SmartherAccountHandler listener = getAccountListenerByLocation(sender.getPlant().getId());\n+            if (listener == null) {\n+                logger.warn(\"C2C notification [{}]: no matching bridge was found. Possible bridge has been removed.\",\n+                        notification.getId());\n+                throw new SmartherGatewayException(ERROR_UKNOWN_BRIDGE);\n+            } else if (listener.isOnline()) {\n+                final SmartherNotificationHandler handler = (SmartherNotificationHandler) listener;\n+\n+                if (handler.useNotifications()) {\n+                    // Passes the notification to the handler\n+                    handler.handleNotification(notification);\n+                } else {\n+                    logger.debug(\n+                            \"C2C notification [{}]: notification discarded as bridge does not handle notifications.\",\n+                            notification.getId());\n+                }\n+            } else {\n+                logger.debug(\"C2C notification [{}]: notification discarded as bridge is offline.\",\n+                        notification.getId());\n+            }\n+        } else {\n+            logger.debug(\"C2C notification [{}]: notification discarded as payload is invalid.\", notification.getId());\n+        }\n+    }\n+\n+    /**\n+     * Adds a {@link SmartherAccountHandler} handler to the set of account service handlers.\n+     *\n+     * @param handler\n+     *            the handler to add to the handlers set\n+     */\n+    public void addSmartherAccountHandler(SmartherAccountHandler handler) {\n+        if (!handlers.contains(handler)) {\n+            handlers.add(handler);\n+        }\n+    }\n+\n+    /**\n+     * Removes a {@link SmartherAccountHandler} handler from the set of account service handlers.\n+     *\n+     * @param handler\n+     *            the handler to remove from the handlers set\n+     */\n+    public void removeSmartherAccountHandler(SmartherAccountHandler handler) {\n+        handlers.remove(handler);\n+    }\n+\n+    /**\n+     * Returns all the {@link SmartherAccountHandler} account service handlers.\n+     *\n+     * @return a set containing all the account service handlers\n+     */\n+    public Set<SmartherAccountHandler> getSmartherAccountHandlers() {\n+        return handlers;\n+    }\n+\n+    /**\n+     * Searches the {@link SmartherAccountHandler} handler that matches the given Thing UID.\n+     *\n+     * @param thingUID\n+     *            the UID of the Thing to match the handler with\n+     *\n+     * @return the handler matching the given Thing UID, or {@code null} if none matches\n+     */\n+    private @Nullable SmartherAccountHandler getAccountListenerByUID(String thingUID) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1312ca938bfc6de96ce4ebd43c2fc802d824ee0"}, "originalPosition": 266}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcxNTUwMA==", "bodyText": "same question", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r439715500", "createdAt": "2020-06-13T06:50:21Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/account/SmartherAccountService.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.account;\n+\n+import static org.openhab.binding.smarther.internal.SmartherBindingConstants.*;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URL;\n+import java.util.HashSet;\n+import java.util.Hashtable;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.smarther.internal.api.dto.Notification;\n+import org.openhab.binding.smarther.internal.api.dto.Sender;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherGatewayException;\n+import org.openhab.binding.smarther.internal.util.StringUtil;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.component.ComponentContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.http.HttpService;\n+import org.osgi.service.http.NamespaceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@code SmartherAccountService} class manages the servlets and bind authorization servlet to Bridges.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@Component(service = SmartherAccountService.class, immediate = true, configurationPid = \"binding.smarther.accountService\")\n+@NonNullByDefault\n+public class SmartherAccountService {\n+\n+    private static final String TEMPLATE_PATH = \"templates/\";\n+    private static final String IMAGE_PATH = \"web\";\n+    private static final String TEMPLATE_APPLICATION = TEMPLATE_PATH + \"application.html\";\n+    private static final String TEMPLATE_INDEX = TEMPLATE_PATH + \"index.html\";\n+    private static final String ERROR_UKNOWN_BRIDGE = \"Returned 'state' doesn't match any Bridges. Has the bridge been removed?\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(SmartherAccountService.class);\n+\n+    private final Set<SmartherAccountHandler> handlers = new HashSet<>();\n+\n+    private @Nullable HttpService httpService;\n+    private @Nullable BundleContext bundleContext;\n+\n+    @Activate\n+    protected void activate(ComponentContext componentContext, Map<String, Object> properties) {\n+        try {\n+            this.bundleContext = componentContext.getBundleContext();\n+\n+            final HttpService localHttpService = this.httpService;\n+            if (localHttpService != null) {\n+                // Register the authorization servlet\n+                localHttpService.registerServlet(AUTH_SERVLET_ALIAS, createAuthorizationServlet(), new Hashtable<>(),\n+                        localHttpService.createDefaultHttpContext());\n+                localHttpService.registerResources(AUTH_SERVLET_ALIAS + IMG_SERVLET_ALIAS, IMAGE_PATH, null);\n+\n+                // Register the notification servlet\n+                localHttpService.registerServlet(NOTIFY_SERVLET_ALIAS, createNotificationServlet(), new Hashtable<>(),\n+                        localHttpService.createDefaultHttpContext());\n+            }\n+        } catch (NamespaceException | ServletException | IOException e) {\n+            logger.warn(\"Error during Smarther servlet startup\", e);\n+        }\n+    }\n+\n+    @Deactivate\n+    protected void deactivate(ComponentContext componentContext) {\n+        final HttpService localHttpService = this.httpService;\n+        if (localHttpService != null) {\n+            // Unregister the authorization servlet\n+            localHttpService.unregister(AUTH_SERVLET_ALIAS);\n+            localHttpService.unregister(AUTH_SERVLET_ALIAS + IMG_SERVLET_ALIAS);\n+\n+            // Unregister the notification servlet\n+            localHttpService.unregister(NOTIFY_SERVLET_ALIAS);\n+        }\n+    }\n+\n+    /**\n+     * Constructs a {@code SmartherAuthorizationServlet}.\n+     *\n+     * @return the newly created servlet\n+     *\n+     * @throws {@link IOException}\n+     *             in case of issues reading one of the internal html templates\n+     */\n+    private HttpServlet createAuthorizationServlet() throws IOException {\n+        return new SmartherAuthorizationServlet(this, readTemplate(TEMPLATE_INDEX), readTemplate(TEMPLATE_APPLICATION));\n+    }\n+\n+    /**\n+     * Constructs a {@code SmartherNotificationServlet}.\n+     *\n+     * @return the newly created servlet\n+     */\n+    private HttpServlet createNotificationServlet() {\n+        return new SmartherNotificationServlet(this);\n+    }\n+\n+    /**\n+     * Reads a template from file and returns its content as string.\n+     *\n+     * @param templateName\n+     *            the name of the template file to read\n+     *\n+     * @return a string representing the content of the template file\n+     *\n+     * @throws {@link IOException}\n+     *             in case of issues reading the template from file\n+     */\n+    private String readTemplate(String templateName) throws IOException {\n+        final BundleContext localBundleContext = this.bundleContext;\n+        if (localBundleContext != null) {\n+            final URL index = localBundleContext.getBundle().getEntry(templateName);\n+\n+            if (index == null) {\n+                throw new FileNotFoundException(String\n+                        .format(\"Cannot find template '%s' - failed to initialize Smarther servlet\", templateName));\n+            } else {\n+                try (InputStream input = index.openStream()) {\n+                    return StringUtil.streamToString(input);\n+                }\n+            }\n+        } else {\n+            throw new IOException(\"Cannot get template, bundle context is null\");\n+        }\n+    }\n+\n+    /**\n+     * Dispatches the received Smarther API authorization response to the proper Smarther account handler.\n+     * Part of the Legrand/Bticino OAuth2 authorization process.\n+     *\n+     * @param servletBaseURL\n+     *            the authorization servlet url needed to derive the notification endpoint url\n+     * @param state\n+     *            the authorization state needed to match the correct Smarther account handler to authorize\n+     * @param code The BTicino/Legrand API returned code value\n+     *            the authorization code to authorize with the account handler\n+     *\n+     * @return a string containing the name of the authorized BTicino/Legrand portal user\n+     *\n+     * @throws {@link SmartherGatewayException}\n+     *             in case of communication issues with the Smarther API or no account handler found\n+     */\n+    public String dispatchAuthorization(String servletBaseURL, String state, String code)\n+            throws SmartherGatewayException {\n+        // Searches the SmartherAccountHandler instance that matches the given state\n+        final SmartherAccountHandler listener = getAccountListenerByUID(state);\n+        if (listener == null) {\n+            logger.debug(\n+                    \"BTicino/Legrand API redirected with state '{}' but no matching bridge was found. Possible bridge has been removed.\",\n+                    state);\n+            throw new SmartherGatewayException(ERROR_UKNOWN_BRIDGE);\n+        }\n+\n+        // Generates the notification URL from servletBaseURL\n+        final String notificationUrl = servletBaseURL.replace(AUTH_SERVLET_ALIAS, NOTIFY_SERVLET_ALIAS);\n+\n+        logger.debug(\"Calling authorize on {}\", listener.getUID());\n+\n+        // Passes the authorization to the handler\n+        return listener.authorize(servletBaseURL, code, notificationUrl);\n+    }\n+\n+    /**\n+     * Dispatches the received C2C Webhook notification to the proper Smarther notification handler.\n+     *\n+     * @param notification\n+     *            the received notification to handle\n+     *\n+     * @throws {@link SmartherGatewayException}\n+     *             in case of communication issues with the Smarther API or no notification handler found\n+     */\n+    public void dispatchNotification(Notification notification) throws SmartherGatewayException {\n+        // Searches the SmartherAccountHandler instance that matches the given location\n+        final Sender sender = notification.getSender();\n+        if (sender != null) {\n+            final SmartherAccountHandler listener = getAccountListenerByLocation(sender.getPlant().getId());\n+            if (listener == null) {\n+                logger.warn(\"C2C notification [{}]: no matching bridge was found. Possible bridge has been removed.\",\n+                        notification.getId());\n+                throw new SmartherGatewayException(ERROR_UKNOWN_BRIDGE);\n+            } else if (listener.isOnline()) {\n+                final SmartherNotificationHandler handler = (SmartherNotificationHandler) listener;\n+\n+                if (handler.useNotifications()) {\n+                    // Passes the notification to the handler\n+                    handler.handleNotification(notification);\n+                } else {\n+                    logger.debug(\n+                            \"C2C notification [{}]: notification discarded as bridge does not handle notifications.\",\n+                            notification.getId());\n+                }\n+            } else {\n+                logger.debug(\"C2C notification [{}]: notification discarded as bridge is offline.\",\n+                        notification.getId());\n+            }\n+        } else {\n+            logger.debug(\"C2C notification [{}]: notification discarded as payload is invalid.\", notification.getId());\n+        }\n+    }\n+\n+    /**\n+     * Adds a {@link SmartherAccountHandler} handler to the set of account service handlers.\n+     *\n+     * @param handler\n+     *            the handler to add to the handlers set\n+     */\n+    public void addSmartherAccountHandler(SmartherAccountHandler handler) {\n+        if (!handlers.contains(handler)) {\n+            handlers.add(handler);\n+        }\n+    }\n+\n+    /**\n+     * Removes a {@link SmartherAccountHandler} handler from the set of account service handlers.\n+     *\n+     * @param handler\n+     *            the handler to remove from the handlers set\n+     */\n+    public void removeSmartherAccountHandler(SmartherAccountHandler handler) {\n+        handlers.remove(handler);\n+    }\n+\n+    /**\n+     * Returns all the {@link SmartherAccountHandler} account service handlers.\n+     *\n+     * @return a set containing all the account service handlers\n+     */\n+    public Set<SmartherAccountHandler> getSmartherAccountHandlers() {\n+        return handlers;\n+    }\n+\n+    /**\n+     * Searches the {@link SmartherAccountHandler} handler that matches the given Thing UID.\n+     *\n+     * @param thingUID\n+     *            the UID of the Thing to match the handler with\n+     *\n+     * @return the handler matching the given Thing UID, or {@code null} if none matches\n+     */\n+    private @Nullable SmartherAccountHandler getAccountListenerByUID(String thingUID) {\n+        final Optional<SmartherAccountHandler> maybeListener = handlers.stream().filter(l -> l.equalsThingUID(thingUID))\n+                .findFirst();\n+        return (maybeListener.isPresent()) ? maybeListener.get() : null;\n+    }\n+\n+    /**\n+     * Searches the {@link SmartherAccountHandler} handler that matches the given location plant.\n+     *\n+     * @param plantId\n+     *            the identifier of the plant to match the handler with\n+     *\n+     * @return the handler matching the given location plant, or {@code null} if none matches\n+     */\n+    private @Nullable SmartherAccountHandler getAccountListenerByLocation(String plantId) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1312ca938bfc6de96ce4ebd43c2fc802d824ee0"}, "originalPosition": 280}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcxNTUxNA==", "bodyText": "same attempted optimization as earlier.", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r439715514", "createdAt": "2020-06-13T06:50:41Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/account/SmartherAccountService.java", "diffHunk": "@@ -0,0 +1,295 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.account;\n+\n+import static org.openhab.binding.smarther.internal.SmartherBindingConstants.*;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URL;\n+import java.util.HashSet;\n+import java.util.Hashtable;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.smarther.internal.api.dto.Notification;\n+import org.openhab.binding.smarther.internal.api.dto.Sender;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherGatewayException;\n+import org.openhab.binding.smarther.internal.util.StringUtil;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.service.component.ComponentContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.osgi.service.component.annotations.Reference;\n+import org.osgi.service.http.HttpService;\n+import org.osgi.service.http.NamespaceException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@code SmartherAccountService} class manages the servlets and bind authorization servlet to Bridges.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@Component(service = SmartherAccountService.class, immediate = true, configurationPid = \"binding.smarther.accountService\")\n+@NonNullByDefault\n+public class SmartherAccountService {\n+\n+    private static final String TEMPLATE_PATH = \"templates/\";\n+    private static final String IMAGE_PATH = \"web\";\n+    private static final String TEMPLATE_APPLICATION = TEMPLATE_PATH + \"application.html\";\n+    private static final String TEMPLATE_INDEX = TEMPLATE_PATH + \"index.html\";\n+    private static final String ERROR_UKNOWN_BRIDGE = \"Returned 'state' doesn't match any Bridges. Has the bridge been removed?\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(SmartherAccountService.class);\n+\n+    private final Set<SmartherAccountHandler> handlers = new HashSet<>();\n+\n+    private @Nullable HttpService httpService;\n+    private @Nullable BundleContext bundleContext;\n+\n+    @Activate\n+    protected void activate(ComponentContext componentContext, Map<String, Object> properties) {\n+        try {\n+            this.bundleContext = componentContext.getBundleContext();\n+\n+            final HttpService localHttpService = this.httpService;\n+            if (localHttpService != null) {\n+                // Register the authorization servlet\n+                localHttpService.registerServlet(AUTH_SERVLET_ALIAS, createAuthorizationServlet(), new Hashtable<>(),\n+                        localHttpService.createDefaultHttpContext());\n+                localHttpService.registerResources(AUTH_SERVLET_ALIAS + IMG_SERVLET_ALIAS, IMAGE_PATH, null);\n+\n+                // Register the notification servlet\n+                localHttpService.registerServlet(NOTIFY_SERVLET_ALIAS, createNotificationServlet(), new Hashtable<>(),\n+                        localHttpService.createDefaultHttpContext());\n+            }\n+        } catch (NamespaceException | ServletException | IOException e) {\n+            logger.warn(\"Error during Smarther servlet startup\", e);\n+        }\n+    }\n+\n+    @Deactivate\n+    protected void deactivate(ComponentContext componentContext) {\n+        final HttpService localHttpService = this.httpService;\n+        if (localHttpService != null) {\n+            // Unregister the authorization servlet\n+            localHttpService.unregister(AUTH_SERVLET_ALIAS);\n+            localHttpService.unregister(AUTH_SERVLET_ALIAS + IMG_SERVLET_ALIAS);\n+\n+            // Unregister the notification servlet\n+            localHttpService.unregister(NOTIFY_SERVLET_ALIAS);\n+        }\n+    }\n+\n+    /**\n+     * Constructs a {@code SmartherAuthorizationServlet}.\n+     *\n+     * @return the newly created servlet\n+     *\n+     * @throws {@link IOException}\n+     *             in case of issues reading one of the internal html templates\n+     */\n+    private HttpServlet createAuthorizationServlet() throws IOException {\n+        return new SmartherAuthorizationServlet(this, readTemplate(TEMPLATE_INDEX), readTemplate(TEMPLATE_APPLICATION));\n+    }\n+\n+    /**\n+     * Constructs a {@code SmartherNotificationServlet}.\n+     *\n+     * @return the newly created servlet\n+     */\n+    private HttpServlet createNotificationServlet() {\n+        return new SmartherNotificationServlet(this);\n+    }\n+\n+    /**\n+     * Reads a template from file and returns its content as string.\n+     *\n+     * @param templateName\n+     *            the name of the template file to read\n+     *\n+     * @return a string representing the content of the template file\n+     *\n+     * @throws {@link IOException}\n+     *             in case of issues reading the template from file\n+     */\n+    private String readTemplate(String templateName) throws IOException {\n+        final BundleContext localBundleContext = this.bundleContext;\n+        if (localBundleContext != null) {\n+            final URL index = localBundleContext.getBundle().getEntry(templateName);\n+\n+            if (index == null) {\n+                throw new FileNotFoundException(String\n+                        .format(\"Cannot find template '%s' - failed to initialize Smarther servlet\", templateName));\n+            } else {\n+                try (InputStream input = index.openStream()) {\n+                    return StringUtil.streamToString(input);\n+                }\n+            }\n+        } else {\n+            throw new IOException(\"Cannot get template, bundle context is null\");\n+        }\n+    }\n+\n+    /**\n+     * Dispatches the received Smarther API authorization response to the proper Smarther account handler.\n+     * Part of the Legrand/Bticino OAuth2 authorization process.\n+     *\n+     * @param servletBaseURL\n+     *            the authorization servlet url needed to derive the notification endpoint url\n+     * @param state\n+     *            the authorization state needed to match the correct Smarther account handler to authorize\n+     * @param code The BTicino/Legrand API returned code value\n+     *            the authorization code to authorize with the account handler\n+     *\n+     * @return a string containing the name of the authorized BTicino/Legrand portal user\n+     *\n+     * @throws {@link SmartherGatewayException}\n+     *             in case of communication issues with the Smarther API or no account handler found\n+     */\n+    public String dispatchAuthorization(String servletBaseURL, String state, String code)\n+            throws SmartherGatewayException {\n+        // Searches the SmartherAccountHandler instance that matches the given state\n+        final SmartherAccountHandler listener = getAccountListenerByUID(state);\n+        if (listener == null) {\n+            logger.debug(\n+                    \"BTicino/Legrand API redirected with state '{}' but no matching bridge was found. Possible bridge has been removed.\",\n+                    state);\n+            throw new SmartherGatewayException(ERROR_UKNOWN_BRIDGE);\n+        }\n+\n+        // Generates the notification URL from servletBaseURL\n+        final String notificationUrl = servletBaseURL.replace(AUTH_SERVLET_ALIAS, NOTIFY_SERVLET_ALIAS);\n+\n+        logger.debug(\"Calling authorize on {}\", listener.getUID());\n+\n+        // Passes the authorization to the handler\n+        return listener.authorize(servletBaseURL, code, notificationUrl);\n+    }\n+\n+    /**\n+     * Dispatches the received C2C Webhook notification to the proper Smarther notification handler.\n+     *\n+     * @param notification\n+     *            the received notification to handle\n+     *\n+     * @throws {@link SmartherGatewayException}\n+     *             in case of communication issues with the Smarther API or no notification handler found\n+     */\n+    public void dispatchNotification(Notification notification) throws SmartherGatewayException {\n+        // Searches the SmartherAccountHandler instance that matches the given location\n+        final Sender sender = notification.getSender();\n+        if (sender != null) {\n+            final SmartherAccountHandler listener = getAccountListenerByLocation(sender.getPlant().getId());\n+            if (listener == null) {\n+                logger.warn(\"C2C notification [{}]: no matching bridge was found. Possible bridge has been removed.\",\n+                        notification.getId());\n+                throw new SmartherGatewayException(ERROR_UKNOWN_BRIDGE);\n+            } else if (listener.isOnline()) {\n+                final SmartherNotificationHandler handler = (SmartherNotificationHandler) listener;\n+\n+                if (handler.useNotifications()) {\n+                    // Passes the notification to the handler\n+                    handler.handleNotification(notification);\n+                } else {\n+                    logger.debug(\n+                            \"C2C notification [{}]: notification discarded as bridge does not handle notifications.\",\n+                            notification.getId());\n+                }\n+            } else {\n+                logger.debug(\"C2C notification [{}]: notification discarded as bridge is offline.\",\n+                        notification.getId());\n+            }\n+        } else {\n+            logger.debug(\"C2C notification [{}]: notification discarded as payload is invalid.\", notification.getId());\n+        }\n+    }\n+\n+    /**\n+     * Adds a {@link SmartherAccountHandler} handler to the set of account service handlers.\n+     *\n+     * @param handler\n+     *            the handler to add to the handlers set\n+     */\n+    public void addSmartherAccountHandler(SmartherAccountHandler handler) {\n+        if (!handlers.contains(handler)) {\n+            handlers.add(handler);\n+        }\n+    }\n+\n+    /**\n+     * Removes a {@link SmartherAccountHandler} handler from the set of account service handlers.\n+     *\n+     * @param handler\n+     *            the handler to remove from the handlers set\n+     */\n+    public void removeSmartherAccountHandler(SmartherAccountHandler handler) {\n+        handlers.remove(handler);\n+    }\n+\n+    /**\n+     * Returns all the {@link SmartherAccountHandler} account service handlers.\n+     *\n+     * @return a set containing all the account service handlers\n+     */\n+    public Set<SmartherAccountHandler> getSmartherAccountHandlers() {\n+        return handlers;\n+    }\n+\n+    /**\n+     * Searches the {@link SmartherAccountHandler} handler that matches the given Thing UID.\n+     *\n+     * @param thingUID\n+     *            the UID of the Thing to match the handler with\n+     *\n+     * @return the handler matching the given Thing UID, or {@code null} if none matches\n+     */\n+    private @Nullable SmartherAccountHandler getAccountListenerByUID(String thingUID) {\n+        final Optional<SmartherAccountHandler> maybeListener = handlers.stream().filter(l -> l.equalsThingUID(thingUID))\n+                .findFirst();\n+        return (maybeListener.isPresent()) ? maybeListener.get() : null;\n+    }\n+\n+    /**\n+     * Searches the {@link SmartherAccountHandler} handler that matches the given location plant.\n+     *\n+     * @param plantId\n+     *            the identifier of the plant to match the handler with\n+     *\n+     * @return the handler matching the given location plant, or {@code null} if none matches\n+     */\n+    private @Nullable SmartherAccountHandler getAccountListenerByLocation(String plantId) {\n+        final Optional<SmartherAccountHandler> maybeListener = handlers.stream().filter(l -> l.hasLocation(plantId))\n+                .findFirst();\n+        return (maybeListener.isPresent()) ? maybeListener.get() : null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1312ca938bfc6de96ce4ebd43c2fc802d824ee0"}, "originalPosition": 283}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcxNjU2OA==", "bodyText": "Using BufferedReader.lines() does not result in the closing of the reader after the operation is complete, the Reader would still need to be closed manually.\nAlthough less concise than what you've written, I feel that the following code would be more correct and more performant.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        final String requestBody = request.getReader().lines().collect(Collectors.joining(System.lineSeparator()));\n          \n          \n            \n                        final String requestBody; \n          \n          \n            \n                        try(Reader reader = request.getReader()){\n          \n          \n            \n                            StringWriter writer = new StringWriter();\n          \n          \n            \n                            int c;\n          \n          \n            \n                            while((c = reader.read()) != -1){\n          \n          \n            \n                                writer.write(c);\n          \n          \n            \n                            }\n          \n          \n            \n                            requestBody = writer.toString();\n          \n          \n            \n                        }\n          \n      \n    \n    \n  \n\nWDYT?", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r439716568", "createdAt": "2020-06-13T07:07:56Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/account/SmartherNotificationServlet.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.account;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.smarther.internal.api.dto.Notification;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherGatewayException;\n+import org.openhab.binding.smarther.internal.util.ModelUtil;\n+import org.openhab.binding.smarther.internal.util.StringUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.reflect.TypeToken;\n+\n+/**\n+ * The {@code SmartherNotificationServlet} class acts as the registered endpoint to receive module status notifications\n+ * from the Legrand/Bticino C2C Webhook notification service.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmartherNotificationServlet extends HttpServlet {\n+\n+    private static final long serialVersionUID = -2474355132186048438L;\n+\n+    private static final String CONTENT_TYPE = \"application/json;charset=UTF-8\";\n+    private static final String OK_RESULT_MSG = \"{\\\"result\\\":0}\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(SmartherNotificationServlet.class);\n+\n+    private final SmartherAccountService accountService;\n+\n+    /**\n+     * Constructs a {@code SmartherNotificationServlet} associated to the given {@link SmartherAccountService} service.\n+     *\n+     * @param accountService\n+     *            the account service to associate to the servlet\n+     */\n+    public SmartherNotificationServlet(SmartherAccountService accountService) {\n+        this.accountService = accountService;\n+    }\n+\n+    @Override\n+    protected void doPost(@Nullable HttpServletRequest request, @Nullable HttpServletResponse response)\n+            throws ServletException, IOException {\n+        if (request != null && response != null) {\n+            logger.debug(\"Notification callback servlet received POST request {}\", request.getRequestURI());\n+\n+            // Handle the received data\n+            final String requestBody = request.getReader().lines().collect(Collectors.joining(System.lineSeparator()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1312ca938bfc6de96ce4ebd43c2fc802d824ee0"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcxNjgxNQ==", "bodyText": "You should probably catch the json parsing exception that is thrown here.", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r439716815", "createdAt": "2020-06-13T07:12:53Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/account/SmartherNotificationServlet.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.account;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.smarther.internal.api.dto.Notification;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherGatewayException;\n+import org.openhab.binding.smarther.internal.util.ModelUtil;\n+import org.openhab.binding.smarther.internal.util.StringUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.reflect.TypeToken;\n+\n+/**\n+ * The {@code SmartherNotificationServlet} class acts as the registered endpoint to receive module status notifications\n+ * from the Legrand/Bticino C2C Webhook notification service.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmartherNotificationServlet extends HttpServlet {\n+\n+    private static final long serialVersionUID = -2474355132186048438L;\n+\n+    private static final String CONTENT_TYPE = \"application/json;charset=UTF-8\";\n+    private static final String OK_RESULT_MSG = \"{\\\"result\\\":0}\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(SmartherNotificationServlet.class);\n+\n+    private final SmartherAccountService accountService;\n+\n+    /**\n+     * Constructs a {@code SmartherNotificationServlet} associated to the given {@link SmartherAccountService} service.\n+     *\n+     * @param accountService\n+     *            the account service to associate to the servlet\n+     */\n+    public SmartherNotificationServlet(SmartherAccountService accountService) {\n+        this.accountService = accountService;\n+    }\n+\n+    @Override\n+    protected void doPost(@Nullable HttpServletRequest request, @Nullable HttpServletResponse response)\n+            throws ServletException, IOException {\n+        if (request != null && response != null) {\n+            logger.debug(\"Notification callback servlet received POST request {}\", request.getRequestURI());\n+\n+            // Handle the received data\n+            final String requestBody = request.getReader().lines().collect(Collectors.joining(System.lineSeparator()));\n+            final String responseBody = dispatchNotifications(requestBody);\n+\n+            // Build a http 200 (Success) response for the caller\n+            response.setContentType(CONTENT_TYPE);\n+            response.setStatus(HttpStatus.OK_200);\n+            response.getWriter().append(responseBody);\n+            response.getWriter().close();\n+        } else if (response != null) {\n+            // Build a http 400 (Bad Request) error response for the caller\n+            response.setContentType(CONTENT_TYPE);\n+            response.setStatus(HttpStatus.BAD_REQUEST_400);\n+            response.getWriter().close();\n+        } else {\n+            throw new ServletException(\"Notification callback with null request/response\");\n+        }\n+    }\n+\n+    /**\n+     * Dispatches all the notifications contained in the received payload to the proper notification handlers.\n+     * The response to the notification service is generated based on the different outcomes.\n+     *\n+     * @param payload\n+     *            the received servlet payload to process, may be {@code null}\n+     *\n+     * @return a string containing the response to the notification service\n+     */\n+    private String dispatchNotifications(@Nullable String payload) {\n+        logger.trace(\"C2C listener received payload: {}\", payload);\n+        if (!StringUtil.isBlank(payload)) {\n+            List<Notification> notifications = ModelUtil.gsonInstance().fromJson(payload,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1312ca938bfc6de96ce4ebd43c2fc802d824ee0"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcxNjg1OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Map<String, Object> rootMap = new IdentityHashMap<String, Object>();\n          \n          \n            \n                    Map<String, Object> rootMap = new IdentityHashMap<>();", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r439716858", "createdAt": "2020-06-13T07:13:36Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/api/SmartherApi.java", "diffHunk": "@@ -0,0 +1,480 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.api;\n+\n+import static org.eclipse.jetty.http.HttpMethod.*;\n+import static org.openhab.binding.smarther.internal.SmartherBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.IdentityHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.function.Function;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.eclipse.smarthome.core.auth.client.oauth2.AccessTokenResponse;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthClientService;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthException;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthResponseException;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.openhab.binding.smarther.internal.api.dto.Chronothermostat;\n+import org.openhab.binding.smarther.internal.api.dto.Enums.MeasureUnit;\n+import org.openhab.binding.smarther.internal.api.dto.Module;\n+import org.openhab.binding.smarther.internal.api.dto.ModuleStatus;\n+import org.openhab.binding.smarther.internal.api.dto.Plant;\n+import org.openhab.binding.smarther.internal.api.dto.Plants;\n+import org.openhab.binding.smarther.internal.api.dto.Program;\n+import org.openhab.binding.smarther.internal.api.dto.Subscription;\n+import org.openhab.binding.smarther.internal.api.dto.Topology;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherAuthorizationException;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherGatewayException;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherTokenExpiredException;\n+import org.openhab.binding.smarther.internal.model.ModuleSettings;\n+import org.openhab.binding.smarther.internal.util.ModelUtil;\n+import org.openhab.binding.smarther.internal.util.StringUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.reflect.TypeToken;\n+\n+/**\n+ * The {@code SmartherApi} class is used to communicate with the BTicino/Legrand API gateway.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmartherApi {\n+\n+    private static final String CONTENT_TYPE = \"application/json\";\n+    private static final String BEARER = \"Bearer \";\n+\n+    // API gateway request headers\n+    private static final String HEADER_ACCEPT = \"Accept\";\n+    // API gateway request attributes\n+    private static final String ATTR_FUNCTION = \"function\";\n+    private static final String ATTR_MODE = \"mode\";\n+    private static final String ATTR_PROGRAMS = \"programs\";\n+    private static final String ATTR_NUMBER = \"number\";\n+    private static final String ATTR_SETPOINT = \"setPoint\";\n+    private static final String ATTR_VALUE = \"value\";\n+    private static final String ATTR_UNIT = \"unit\";\n+    private static final String ATTR_ACTIVATION_TIME = \"activationTime\";\n+    private static final String ATTR_ENDPOINT_URL = \"EndPointUrl\";\n+    // API gateway operation paths\n+    private static final String PATH_PLANTS = \"/plants\";\n+    private static final String PATH_TOPOLOGY = PATH_PLANTS + \"/%s/topology\";\n+    private static final String PATH_MODULE = \"/chronothermostat/thermoregulation/addressLocation/plants/%s/modules/parameter/id/value/%s\";\n+    private static final String PATH_PROGRAMS = \"/programlist\";\n+    private static final String PATH_SUBSCRIPTIONS = \"/subscription\";\n+    private static final String PATH_SUBSCRIBE = PATH_PLANTS + \"/%s/subscription\";\n+    private static final String PATH_UNSUBSCRIBE = PATH_SUBSCRIBE + \"/%s\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(SmartherApi.class);\n+\n+    private final OAuthClientService oAuthClientService;\n+    private final String oAuthSubscriptionKey;\n+    private final SmartherApiConnector connector;\n+\n+    /**\n+     * Constructs a {@code SmartherApi} to the API gateway with the specified OAuth2 attributes (subscription key and\n+     * client service), scheduler service and http client.\n+     *\n+     * @param clientService\n+     *            the OAuth2 authorization client service to be used\n+     * @param subscriptionKey\n+     *            the OAuth2 subscription key to be used with the given client service\n+     * @param scheduler\n+     *            the scheduler to be used to reschedule calls when rate limit exceeded or call not succeeded\n+     * @param httpClient\n+     *            the http client to be used to make http calls to the API gateway\n+     */\n+    public SmartherApi(final OAuthClientService clientService, final String subscriptionKey,\n+            final ScheduledExecutorService scheduler, final HttpClient httpClient) {\n+        this.oAuthClientService = clientService;\n+        this.oAuthSubscriptionKey = subscriptionKey;\n+        this.connector = new SmartherApiConnector(scheduler, httpClient);\n+    }\n+\n+    /**\n+     * Returns the plants registered under the Smarther account the bridge has been configured with.\n+     *\n+     * @return the list of registered plants, or an empty {@link List} in case of no plants found\n+     *\n+     * @throws {@link SmartherGatewayException}\n+     *             in case of communication issues with the API gateway\n+     */\n+    public List<Plant> getPlants() throws SmartherGatewayException {\n+        final ContentResponse response = requestBasic(GET, PATH_PLANTS);\n+        if (response.getStatus() == HttpStatus.NO_CONTENT_204) {\n+            return new ArrayList<>();\n+        } else {\n+            return ModelUtil.gsonInstance().fromJson(response.getContentAsString(), Plants.class).getPlants();\n+        }\n+    }\n+\n+    /**\n+     * Returns the chronothermostat modules registered in the given plant.\n+     *\n+     * @param plantId\n+     *            the identifier of the plant\n+     *\n+     * @return the list of registered modules, or an empty {@link List} in case the plant contains no module\n+     *\n+     * @throws {@link SmartherGatewayException}\n+     *             in case of communication issues with the API gateway\n+     */\n+    public List<Module> getPlantModules(String plantId) throws SmartherGatewayException {\n+        final ContentResponse response = requestBasic(GET, String.format(PATH_TOPOLOGY, plantId));\n+        final Topology topology = ModelUtil.gsonInstance().fromJson(response.getContentAsString(), Topology.class);\n+        return topology.getModules();\n+    }\n+\n+    /**\n+     * Returns the current status of a given chronothermostat module.\n+     *\n+     * @param plantId\n+     *            the identifier of the plant\n+     * @param moduleId\n+     *            the identifier of the chronothermostat module inside the plant\n+     *\n+     * @return the current status of the chronothermostat module\n+     *\n+     * @throws {@link SmartherGatewayException}\n+     *             in case of communication issues with the API gateway\n+     */\n+    public ModuleStatus getModuleStatus(String plantId, String moduleId) throws SmartherGatewayException {\n+        final ContentResponse response = requestModule(GET, plantId, moduleId, null);\n+        return ModelUtil.gsonInstance().fromJson(response.getContentAsString(), ModuleStatus.class);\n+    }\n+\n+    /**\n+     * Sends new settings to be applied to a given chronothermostat module.\n+     *\n+     * @param settings\n+     *            the module settings to be applied\n+     *\n+     * @return {@code true} if the settings have been successfully applied, {@code false} otherwise\n+     *\n+     * @throws {@link SmartherGatewayException}\n+     *             in case of communication issues with the API gateway\n+     */\n+    public boolean setModuleStatus(ModuleSettings settings) throws SmartherGatewayException {\n+        // Prepare request payload\n+        Map<String, Object> rootMap = new IdentityHashMap<String, Object>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1312ca938bfc6de96ce4ebd43c2fc802d824ee0"}, "originalPosition": 186}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcxNjkyNA==", "bodyText": "You should catch the json syntax exception anywhere you are using gson.", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r439716924", "createdAt": "2020-06-13T07:14:56Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/api/SmartherApi.java", "diffHunk": "@@ -0,0 +1,480 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.api;\n+\n+import static org.eclipse.jetty.http.HttpMethod.*;\n+import static org.openhab.binding.smarther.internal.SmartherBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.IdentityHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.function.Function;\n+\n+import javax.measure.quantity.Temperature;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.eclipse.smarthome.core.auth.client.oauth2.AccessTokenResponse;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthClientService;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthException;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthResponseException;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.openhab.binding.smarther.internal.api.dto.Chronothermostat;\n+import org.openhab.binding.smarther.internal.api.dto.Enums.MeasureUnit;\n+import org.openhab.binding.smarther.internal.api.dto.Module;\n+import org.openhab.binding.smarther.internal.api.dto.ModuleStatus;\n+import org.openhab.binding.smarther.internal.api.dto.Plant;\n+import org.openhab.binding.smarther.internal.api.dto.Plants;\n+import org.openhab.binding.smarther.internal.api.dto.Program;\n+import org.openhab.binding.smarther.internal.api.dto.Subscription;\n+import org.openhab.binding.smarther.internal.api.dto.Topology;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherAuthorizationException;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherGatewayException;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherTokenExpiredException;\n+import org.openhab.binding.smarther.internal.model.ModuleSettings;\n+import org.openhab.binding.smarther.internal.util.ModelUtil;\n+import org.openhab.binding.smarther.internal.util.StringUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.reflect.TypeToken;\n+\n+/**\n+ * The {@code SmartherApi} class is used to communicate with the BTicino/Legrand API gateway.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmartherApi {\n+\n+    private static final String CONTENT_TYPE = \"application/json\";\n+    private static final String BEARER = \"Bearer \";\n+\n+    // API gateway request headers\n+    private static final String HEADER_ACCEPT = \"Accept\";\n+    // API gateway request attributes\n+    private static final String ATTR_FUNCTION = \"function\";\n+    private static final String ATTR_MODE = \"mode\";\n+    private static final String ATTR_PROGRAMS = \"programs\";\n+    private static final String ATTR_NUMBER = \"number\";\n+    private static final String ATTR_SETPOINT = \"setPoint\";\n+    private static final String ATTR_VALUE = \"value\";\n+    private static final String ATTR_UNIT = \"unit\";\n+    private static final String ATTR_ACTIVATION_TIME = \"activationTime\";\n+    private static final String ATTR_ENDPOINT_URL = \"EndPointUrl\";\n+    // API gateway operation paths\n+    private static final String PATH_PLANTS = \"/plants\";\n+    private static final String PATH_TOPOLOGY = PATH_PLANTS + \"/%s/topology\";\n+    private static final String PATH_MODULE = \"/chronothermostat/thermoregulation/addressLocation/plants/%s/modules/parameter/id/value/%s\";\n+    private static final String PATH_PROGRAMS = \"/programlist\";\n+    private static final String PATH_SUBSCRIPTIONS = \"/subscription\";\n+    private static final String PATH_SUBSCRIBE = PATH_PLANTS + \"/%s/subscription\";\n+    private static final String PATH_UNSUBSCRIBE = PATH_SUBSCRIBE + \"/%s\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(SmartherApi.class);\n+\n+    private final OAuthClientService oAuthClientService;\n+    private final String oAuthSubscriptionKey;\n+    private final SmartherApiConnector connector;\n+\n+    /**\n+     * Constructs a {@code SmartherApi} to the API gateway with the specified OAuth2 attributes (subscription key and\n+     * client service), scheduler service and http client.\n+     *\n+     * @param clientService\n+     *            the OAuth2 authorization client service to be used\n+     * @param subscriptionKey\n+     *            the OAuth2 subscription key to be used with the given client service\n+     * @param scheduler\n+     *            the scheduler to be used to reschedule calls when rate limit exceeded or call not succeeded\n+     * @param httpClient\n+     *            the http client to be used to make http calls to the API gateway\n+     */\n+    public SmartherApi(final OAuthClientService clientService, final String subscriptionKey,\n+            final ScheduledExecutorService scheduler, final HttpClient httpClient) {\n+        this.oAuthClientService = clientService;\n+        this.oAuthSubscriptionKey = subscriptionKey;\n+        this.connector = new SmartherApiConnector(scheduler, httpClient);\n+    }\n+\n+    /**\n+     * Returns the plants registered under the Smarther account the bridge has been configured with.\n+     *\n+     * @return the list of registered plants, or an empty {@link List} in case of no plants found\n+     *\n+     * @throws {@link SmartherGatewayException}\n+     *             in case of communication issues with the API gateway\n+     */\n+    public List<Plant> getPlants() throws SmartherGatewayException {\n+        final ContentResponse response = requestBasic(GET, PATH_PLANTS);\n+        if (response.getStatus() == HttpStatus.NO_CONTENT_204) {\n+            return new ArrayList<>();\n+        } else {\n+            return ModelUtil.gsonInstance().fromJson(response.getContentAsString(), Plants.class).getPlants();\n+        }\n+    }\n+\n+    /**\n+     * Returns the chronothermostat modules registered in the given plant.\n+     *\n+     * @param plantId\n+     *            the identifier of the plant\n+     *\n+     * @return the list of registered modules, or an empty {@link List} in case the plant contains no module\n+     *\n+     * @throws {@link SmartherGatewayException}\n+     *             in case of communication issues with the API gateway\n+     */\n+    public List<Module> getPlantModules(String plantId) throws SmartherGatewayException {\n+        final ContentResponse response = requestBasic(GET, String.format(PATH_TOPOLOGY, plantId));\n+        final Topology topology = ModelUtil.gsonInstance().fromJson(response.getContentAsString(), Topology.class);\n+        return topology.getModules();\n+    }\n+\n+    /**\n+     * Returns the current status of a given chronothermostat module.\n+     *\n+     * @param plantId\n+     *            the identifier of the plant\n+     * @param moduleId\n+     *            the identifier of the chronothermostat module inside the plant\n+     *\n+     * @return the current status of the chronothermostat module\n+     *\n+     * @throws {@link SmartherGatewayException}\n+     *             in case of communication issues with the API gateway\n+     */\n+    public ModuleStatus getModuleStatus(String plantId, String moduleId) throws SmartherGatewayException {\n+        final ContentResponse response = requestModule(GET, plantId, moduleId, null);\n+        return ModelUtil.gsonInstance().fromJson(response.getContentAsString(), ModuleStatus.class);\n+    }\n+\n+    /**\n+     * Sends new settings to be applied to a given chronothermostat module.\n+     *\n+     * @param settings\n+     *            the module settings to be applied\n+     *\n+     * @return {@code true} if the settings have been successfully applied, {@code false} otherwise\n+     *\n+     * @throws {@link SmartherGatewayException}\n+     *             in case of communication issues with the API gateway\n+     */\n+    public boolean setModuleStatus(ModuleSettings settings) throws SmartherGatewayException {\n+        // Prepare request payload\n+        Map<String, Object> rootMap = new IdentityHashMap<String, Object>();\n+        rootMap.put(ATTR_FUNCTION, settings.getFunction().getValue());\n+        rootMap.put(ATTR_MODE, settings.getMode().getValue());\n+        switch (settings.getMode()) {\n+            case AUTOMATIC:\n+                // {\"function\":\"heating\",\"mode\":\"automatic\",\"programs\":[{\"number\":0}]}\n+                Map<String, Integer> programMap = new IdentityHashMap<String, Integer>();\n+                programMap.put(ATTR_NUMBER, Integer.valueOf(settings.getProgram()));\n+                List<Map<String, Integer>> programsList = new ArrayList<>();\n+                programsList.add(programMap);\n+                rootMap.put(ATTR_PROGRAMS, programsList);\n+                break;\n+            case MANUAL:\n+                // {\"function\":\"heating\",\"mode\":\"manual\",\"setPoint\":{\"value\":0.0,\"unit\":\"C\"},\"activationTime\":\"X\"}\n+                QuantityType<Temperature> newTemperature = settings.getSetPointTemperature(SIUnits.CELSIUS);\n+                if (newTemperature == null) {\n+                    throw new SmartherGatewayException(\"Invalid temperature unit transformation\");\n+                }\n+                Map<String, Object> setPointMap = new IdentityHashMap<String, Object>();\n+                setPointMap.put(ATTR_VALUE, newTemperature.doubleValue());\n+                setPointMap.put(ATTR_UNIT, MeasureUnit.CELSIUS.getValue());\n+                rootMap.put(ATTR_SETPOINT, setPointMap);\n+                rootMap.put(ATTR_ACTIVATION_TIME, settings.getActivationTime());\n+                break;\n+            case BOOST:\n+                // {\"function\":\"heating\",\"mode\":\"boost\",\"activationTime\":\"X\"}\n+                rootMap.put(ATTR_ACTIVATION_TIME, settings.getActivationTime());\n+                break;\n+            case OFF:\n+                // {\"function\":\"heating\",\"mode\":\"off\"}\n+                break;\n+            case PROTECTION:\n+                // {\"function\":\"heating\",\"mode\":\"protection\"}\n+                break;\n+        }\n+        final String jsonPayload = ModelUtil.gsonInstance().toJson(rootMap);\n+\n+        // Send request to server\n+        final ContentResponse response = requestModule(POST, settings.getPlantId(), settings.getModuleId(),\n+                jsonPayload);\n+        return (response.getStatus() == HttpStatus.OK_200);\n+    }\n+\n+    /**\n+     * Returns the automatic mode programs registered for the given chronothermostat module.\n+     *\n+     * @param plantId\n+     *            the identifier of the plant\n+     * @param moduleId\n+     *            the identifier of the chronothermostat module inside the plant\n+     *\n+     * @return the list of registered programs, or an empty {@link List} in case of no programs found\n+     *\n+     * @throws {@link SmartherGatewayException}\n+     *             in case of communication issues with the API gateway\n+     */\n+    public List<Program> getModulePrograms(String plantId, String moduleId) throws SmartherGatewayException {\n+        final ContentResponse response = requestModule(GET, plantId, moduleId, PATH_PROGRAMS, null);\n+        final ModuleStatus moduleStatus = ModelUtil.gsonInstance().fromJson(response.getContentAsString(),\n+                ModuleStatus.class);\n+\n+        final Chronothermostat chronothermostat = moduleStatus.toChronothermostat();\n+        return (chronothermostat != null) ? chronothermostat.getPrograms() : Collections.emptyList();\n+    }\n+\n+    /**\n+     * Returns the subscriptions registered to the C2C Webhook, where modules status notifications are currently sent\n+     * for all the plants.\n+     *\n+     * @return the list of registered subscriptions, or an empty {@link List} in case of no subscriptions found\n+     *\n+     * @throws {@link SmartherGatewayException}\n+     *             in case of communication issues with the API gateway\n+     */\n+    public List<Subscription> getSubscriptions() throws SmartherGatewayException {\n+        final ContentResponse response = requestBasic(GET, PATH_SUBSCRIPTIONS);\n+        if (response.getStatus() == HttpStatus.NO_CONTENT_204) {\n+            return new ArrayList<>();\n+        } else {\n+            return ModelUtil.gsonInstance().fromJson(response.getContentAsString(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1312ca938bfc6de96ce4ebd43c2fc802d824ee0"}, "originalPosition": 265}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcxNzE3Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Map<String, Object> properties = new HashMap<String, Object>();\n          \n          \n            \n                    Map<String, Object> properties = new HashMap<>();", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r439717173", "createdAt": "2020-06-13T07:19:55Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/discovery/SmartherModuleDiscoveryService.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.discovery;\n+\n+import static org.openhab.binding.smarther.internal.SmartherBindingConstants.*;\n+\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.openhab.binding.smarther.internal.account.SmartherAccountHandler;\n+import org.openhab.binding.smarther.internal.api.dto.Location;\n+import org.openhab.binding.smarther.internal.api.dto.Module;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@code SmartherModuleDiscoveryService} queries the Smarther API gateway to discover available Chronothermostat\n+ * modules inside existing plants registered under the configured Bridges.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmartherModuleDiscoveryService extends AbstractDiscoveryService implements ThingHandlerService {\n+\n+    // Only modules can be discovered. A bridge must be manually added.\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections.singleton(THING_TYPE_MODULE);\n+    // The call to listModules is fast\n+    private static final int DISCOVERY_TIME_SECONDS = 10;\n+\n+    // Handling of the background scan for new devices\n+    private static final boolean BACKGROUND_SCAN_ENABLED = false;\n+    private static final long BACKGROUND_SCAN_REFRESH_MINUTES = 1;\n+\n+    private static final String ID_SEPARATOR = \"-\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(SmartherModuleDiscoveryService.class);\n+\n+    private @Nullable SmartherAccountHandler bridgeHandler;\n+    private @Nullable ThingUID bridgeUID;\n+    private @Nullable ScheduledFuture<?> backgroundFuture;\n+\n+    /**\n+     * Constructs a {@code SmartherModuleDiscoveryService}.\n+     */\n+    public SmartherModuleDiscoveryService() {\n+        super(SUPPORTED_THING_TYPES_UIDS, DISCOVERY_TIME_SECONDS);\n+    }\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypes() {\n+        return SUPPORTED_THING_TYPES_UIDS;\n+    }\n+\n+    @Override\n+    public void activate() {\n+        Map<String, @Nullable Object> properties = new HashMap<>();\n+        properties.put(DiscoveryService.CONFIG_PROPERTY_BACKGROUND_DISCOVERY, Boolean.TRUE);\n+        super.activate(properties);\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        removeOlderResults(new Date().getTime());\n+    }\n+\n+    @Override\n+    public void setThingHandler(@Nullable ThingHandler handler) {\n+        if (handler instanceof SmartherAccountHandler) {\n+            final SmartherAccountHandler localBridgeHandler = (SmartherAccountHandler) handler;\n+            this.bridgeHandler = localBridgeHandler;\n+            this.bridgeUID = localBridgeHandler.getUID();\n+        }\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return this.bridgeHandler;\n+    }\n+\n+    @Override\n+    protected synchronized void startBackgroundDiscovery() {\n+        stopBackgroundDiscovery();\n+        if (BACKGROUND_SCAN_ENABLED) {\n+            this.backgroundFuture = scheduler.scheduleWithFixedDelay(this::startScan, BACKGROUND_SCAN_REFRESH_MINUTES,\n+                    BACKGROUND_SCAN_REFRESH_MINUTES, TimeUnit.MINUTES);\n+        }\n+    }\n+\n+    @Override\n+    protected synchronized void stopBackgroundDiscovery() {\n+        final ScheduledFuture<?> localBackgroundFuture = this.backgroundFuture;\n+        if (localBackgroundFuture != null) {\n+            if (!localBackgroundFuture.isCancelled()) {\n+                localBackgroundFuture.cancel(true);\n+            }\n+            this.backgroundFuture = null;\n+        }\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        final SmartherAccountHandler localBridgeHandler = this.bridgeHandler;\n+        if (localBridgeHandler != null) {\n+            // If the bridge is not online no other thing devices can be found, so no reason to scan at this moment\n+            if (localBridgeHandler.isOnline()) {\n+                logger.debug(\"Starting modules discovery for bridge {}\", this.bridgeUID);\n+                localBridgeHandler.getLocations()\n+                        .forEach(l -> localBridgeHandler.getLocationModules(l).forEach(m -> thingDiscovered(l, m)));\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected synchronized void stopScan() {\n+        super.stopScan();\n+        removeOlderResults(getTimestampOfLastScan());\n+    }\n+\n+    /**\n+     * Creates a Chronothermostat module Thing based on the remotely discovered location and module.\n+     *\n+     * @param location\n+     *            the location containing the discovered module\n+     * @param module\n+     *            the discovered module\n+     */\n+    private void thingDiscovered(Location location, Module module) {\n+        Map<String, Object> properties = new HashMap<String, Object>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1312ca938bfc6de96ce4ebd43c2fc802d824ee0"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcxNzM5NA==", "bodyText": "Was the AuthorizationUrl supposed to be  included in this message?\nYou should also include the exception or at least the exception's message in the log as well.", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r439717394", "createdAt": "2020-06-13T07:23:15Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.smarther/src/main/java/org/openhab/binding/smarther/internal/handler/SmartherBridgeHandler.java", "diffHunk": "@@ -0,0 +1,762 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smarther.internal.handler;\n+\n+import static org.openhab.binding.smarther.internal.SmartherBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.UnknownHostException;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.auth.client.oauth2.AccessTokenRefreshListener;\n+import org.eclipse.smarthome.core.auth.client.oauth2.AccessTokenResponse;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthClientService;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthException;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthFactory;\n+import org.eclipse.smarthome.core.auth.client.oauth2.OAuthResponseException;\n+import org.eclipse.smarthome.core.cache.ExpiringCache;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.Bridge;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseBridgeHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.smarther.internal.account.SmartherAccountHandler;\n+import org.openhab.binding.smarther.internal.account.SmartherNotificationHandler;\n+import org.openhab.binding.smarther.internal.api.SmartherApi;\n+import org.openhab.binding.smarther.internal.api.dto.Location;\n+import org.openhab.binding.smarther.internal.api.dto.Module;\n+import org.openhab.binding.smarther.internal.api.dto.ModuleStatus;\n+import org.openhab.binding.smarther.internal.api.dto.Notification;\n+import org.openhab.binding.smarther.internal.api.dto.Plant;\n+import org.openhab.binding.smarther.internal.api.dto.Program;\n+import org.openhab.binding.smarther.internal.api.dto.Sender;\n+import org.openhab.binding.smarther.internal.api.dto.Subscription;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherAuthorizationException;\n+import org.openhab.binding.smarther.internal.api.exception.SmartherGatewayException;\n+import org.openhab.binding.smarther.internal.config.SmartherBridgeConfiguration;\n+import org.openhab.binding.smarther.internal.discovery.SmartherModuleDiscoveryService;\n+import org.openhab.binding.smarther.internal.model.BridgeStatus;\n+import org.openhab.binding.smarther.internal.model.ModuleSettings;\n+import org.openhab.binding.smarther.internal.util.StringUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@code SmartherBridgeHandler} class is responsible of the handling of a Smarther Bridge thing.\n+ * The Smarther Bridge is used to manage a set of Smarther Chronothermostat Modules registered under the same\n+ * Legrand/Bticino account credentials.\n+ *\n+ * @author Fabio Possieri - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmartherBridgeHandler extends BaseBridgeHandler\n+        implements SmartherAccountHandler, SmartherNotificationHandler, AccessTokenRefreshListener {\n+\n+    private static final long POLL_INITIAL_DELAY = 5;\n+\n+    private final Logger logger = LoggerFactory.getLogger(SmartherBridgeHandler.class);\n+\n+    private final OAuthFactory oAuthFactory;\n+    private final HttpClient httpClient;\n+\n+    // Bridge configuration\n+    private SmartherBridgeConfiguration config;\n+\n+    // Field members assigned in initialize method\n+    private @Nullable Future<?> pollFuture;\n+    private @Nullable OAuthClientService oAuthService;\n+    private @Nullable SmartherApi smartherApi;\n+    private @Nullable ExpiringCache<List<Location>> locationCache;\n+    private @Nullable BridgeStatus bridgeStatus;\n+\n+    /**\n+     * Constructs a {@code SmartherBridgeHandler} for the given Bridge thing, authorization factory and http client.\n+     *\n+     * @param bridge\n+     *            the {@link Bridge} thing to be used\n+     * @param oAuthFactory\n+     *            the OAuth2 authorization factory to be used\n+     * @param httpClient\n+     *            the http client to be used\n+     */\n+    public SmartherBridgeHandler(Bridge bridge, OAuthFactory oAuthFactory, HttpClient httpClient) {\n+        super(bridge);\n+        this.oAuthFactory = oAuthFactory;\n+        this.httpClient = httpClient;\n+        this.config = new SmartherBridgeConfiguration();\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(SmartherModuleDiscoveryService.class);\n+    }\n+\n+    // ===========================================================================\n+    //\n+    // Bridge thing lifecycle management methods\n+    //\n+    // ===========================================================================\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Bridge[{}] Initialize handler\", thing.getUID());\n+\n+        this.config = getConfigAs(SmartherBridgeConfiguration.class);\n+        if (StringUtil.isBlank(config.getSubscriptionKey())) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Subscription Key' property is not set or empty. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+        if (StringUtil.isBlank(config.getClientId())) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Client Id' property is not set or empty. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+        if (StringUtil.isBlank(config.getClientSecret())) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"The 'Client Secret' property is not set or empty. If you have an older thing please recreate it.\");\n+            return;\n+        }\n+\n+        // Initialize OAuth2 authentication support\n+        final OAuthClientService localOAuthService = oAuthFactory.createOAuthClientService(thing.getUID().getAsString(),\n+                SMARTHER_API_TOKEN_URL, SMARTHER_AUTHORIZE_URL, config.getClientId(), config.getClientSecret(),\n+                SMARTHER_API_SCOPES, false);\n+        localOAuthService.addAccessTokenRefreshListener(SmartherBridgeHandler.this);\n+        this.oAuthService = localOAuthService;\n+\n+        // Initialize Smarther Api\n+        final SmartherApi localSmartherApi = new SmartherApi(localOAuthService, config.getSubscriptionKey(), scheduler,\n+                httpClient);\n+        this.smartherApi = localSmartherApi;\n+\n+        // Initialize locations (plant Ids) local cache\n+        final ExpiringCache<List<Location>> localLocationCache = new ExpiringCache<>(\n+                Duration.ofMinutes(config.getStatusRefreshPeriod()), this::locationCacheAction);\n+        this.locationCache = localLocationCache;\n+\n+        // Initialize bridge local status\n+        final BridgeStatus localBridgeStatus = new BridgeStatus();\n+        this.bridgeStatus = localBridgeStatus;\n+\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        schedulePoll();\n+\n+        logger.debug(\"Bridge[{}] Finished initializing!\", thing.getUID());\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        switch (channelUID.getId()) {\n+            case CHANNEL_FETCH_CONFIG:\n+                if (command instanceof OnOffType) {\n+                    if (OnOffType.ON.equals(command)) {\n+                        logger.debug(\"Bridge[{}] Manually triggered channel to refresh the Bridge config\",\n+                                thing.getUID());\n+                        schedulePoll();\n+                        updateChannelState(CHANNEL_FETCH_CONFIG, OnOffType.OFF);\n+                    }\n+                    return;\n+                }\n+                break;\n+        }\n+\n+        if (command instanceof RefreshType) {\n+            // Avoid logging wrong command when refresh command is sent\n+            return;\n+        }\n+\n+        logger.debug(\"Bridge[{}] Received command {} of wrong type {} on channel {}\", thing.getUID(), command,\n+                command.getClass().getTypeName(), channelUID.getId());\n+    }\n+\n+    @Override\n+    public void handleRemoval() {\n+        super.handleRemoval();\n+        stopPoll(true);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.debug(\"Bridge[{}] Dispose handler\", thing.getUID());\n+        final OAuthClientService localOAuthService = this.oAuthService;\n+        if (localOAuthService != null) {\n+            localOAuthService.removeAccessTokenRefreshListener(this);\n+        }\n+        this.oAuthFactory.ungetOAuthService(thing.getUID().getAsString());\n+        stopPoll(true);\n+        logger.debug(\"Bridge[{}] Finished disposing!\", thing.getUID());\n+    }\n+\n+    // ===========================================================================\n+    //\n+    // Bridge data cache management methods\n+    //\n+    // ===========================================================================\n+\n+    /**\n+     * Returns the available locations to be cached for this Bridge.\n+     *\n+     * @return the available locations to be cached for this Bridge, or {@code null} if the list of available locations\n+     *         cannot be retrieved\n+     */\n+    private @Nullable List<Location> locationCacheAction() {\n+        try {\n+            // Retrieve the plants list from the API Gateway\n+            final List<Plant> plants = getPlants();\n+\n+            List<Location> locations;\n+            if (config.isUseNotifications()) {\n+                // Retrieve the subscriptions list from the API Gateway\n+                final List<Subscription> subscriptions = getSubscriptions();\n+\n+                // Enrich the notifications list with externally registered subscriptions\n+                updateNotifications(subscriptions);\n+\n+                // Get the notifications list from bridge config\n+                final List<String> notifications = config.getNotifications();\n+\n+                locations = plants.stream().map(p -> Location.fromPlant(p, subscriptions.stream()\n+                        .filter(s -> s.getPlantId().equals(p.getId()) && notifications.contains(s.getSubscriptionId()))\n+                        .findFirst())).collect(Collectors.toList());\n+            } else {\n+                locations = plants.stream().map(p -> Location.fromPlant(p)).collect(Collectors.toList());\n+            }\n+            logger.debug(\"Bridge[{}] Available locations: {}\", thing.getUID(), locations);\n+\n+            return locations;\n+\n+        } catch (SmartherGatewayException e) {\n+            logger.warn(\"Bridge[{}] Cannot retrieve available locations: {}\", thing.getUID(), e.getMessage());\n+            return null;\n+        }\n+    }\n+\n+    /**\n+     * Updates this Bridge local notifications list with externally registered subscriptions.\n+     *\n+     * @param subscriptions\n+     *            the externally registered subscriptions to be added to the local notifications list\n+     */\n+    private void updateNotifications(List<Subscription> subscriptions) {\n+        // Get the notifications list from bridge config\n+        List<String> notifications = config.getNotifications();\n+\n+        for (Subscription s : subscriptions) {\n+            if (s.getEndpointUrl().equalsIgnoreCase(config.getNotificationUrl())\n+                    && !notifications.contains(s.getSubscriptionId())) {\n+                // Add the external subscription to notifications list\n+                notifications = config.addNotification(s.getSubscriptionId());\n+\n+                // Save the updated notifications list back to bridge config\n+                Configuration configuration = editConfiguration();\n+                configuration.put(PROPERTY_NOTIFICATIONS, notifications);\n+                updateConfiguration(configuration);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Sets all the cache to \"expired\" for this Bridge.\n+     */\n+    private void expireCache() {\n+        logger.debug(\"Bridge[{}] Invalidating location cache\", thing.getUID());\n+        final ExpiringCache<List<Location>> localLocationCache = this.locationCache;\n+        if (localLocationCache != null) {\n+            localLocationCache.invalidateValue();\n+        }\n+    }\n+\n+    // ===========================================================================\n+    //\n+    // Bridge status polling mechanism methods\n+    //\n+    // ===========================================================================\n+\n+    /**\n+     * Starts a new scheduler to periodically poll and update this Bridge status.\n+     */\n+    private void schedulePoll() {\n+        stopPoll(false);\n+\n+        // Schedule poll to start after POLL_INITIAL_DELAY sec and run periodically based on status refresh period\n+        final Future<?> localPollFuture = scheduler.scheduleWithFixedDelay(this::poll, POLL_INITIAL_DELAY,\n+                config.getStatusRefreshPeriod() * 60, TimeUnit.SECONDS);\n+        this.pollFuture = localPollFuture;\n+\n+        logger.debug(\"Bridge[{}] Scheduled poll for {} sec out, then every {} min\", thing.getUID(), POLL_INITIAL_DELAY,\n+                config.getStatusRefreshPeriod());\n+    }\n+\n+    /**\n+     * Cancels all running poll schedulers.\n+     *\n+     * @param mayInterruptIfRunning\n+     *            {@code true} if the thread executing this task should be interrupted, {@code false} if the in-progress\n+     *            tasks are allowed to complete\n+     */\n+    private synchronized void stopPoll(boolean mayInterruptIfRunning) {\n+        final Future<?> localPollFuture = this.pollFuture;\n+        if (localPollFuture != null) {\n+            if (!localPollFuture.isCancelled()) {\n+                localPollFuture.cancel(mayInterruptIfRunning);\n+            }\n+            this.pollFuture = null;\n+        }\n+    }\n+\n+    /**\n+     * Polls to update this Bridge status, calling the Smarther API to refresh its plants list.\n+     *\n+     * @return {@code true} if the method completes without errors, {@code false} otherwise\n+     */\n+    private synchronized boolean poll() {\n+        try {\n+            onAccessTokenResponse(getAccessTokenResponse());\n+\n+            expireCache();\n+            locationCacheAction();\n+\n+            updateStatus(ThingStatus.ONLINE);\n+            return true;\n+        } catch (SmartherAuthorizationException e) {\n+            logger.warn(\"Bridge[{}] Authorization error during polling: {}\", thing.getUID(), e.getMessage());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+        } catch (RuntimeException e) {\n+            // All other exceptions apart from Authorization and Gateway issues\n+            logger.warn(\"Bridge[{}] Unexpected error during polling, please report if this keeps occurring: \",\n+                    thing.getUID(), e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, e.getMessage());\n+        }\n+        schedulePoll();\n+        return false;\n+    }\n+\n+    @Override\n+    public void onAccessTokenResponse(@Nullable AccessTokenResponse tokenResponse) {\n+        updateChannelState(CHANNEL_ACCESS_TOKEN,\n+                new StringType((tokenResponse == null) ? null : tokenResponse.getAccessToken()));\n+    }\n+\n+    // ===========================================================================\n+    //\n+    // Bridge convenience methods\n+    //\n+    // ===========================================================================\n+\n+    /**\n+     * Convenience method to get this Bridge configuration.\n+     *\n+     * @return a {@link SmartherBridgeConfiguration} object containing the Bridge configuration\n+     */\n+    public SmartherBridgeConfiguration getSmartherBridgeConfig() {\n+        return config;\n+    }\n+\n+    /**\n+     * Convenience method to get the access token from Smarther API authorization layer.\n+     *\n+     * @return the autorization access token, may be {@code null}\n+     *\n+     * @throws {@link SmartherAuthorizationException}\n+     *             in case of authorization issues with the Smarther API\n+     */\n+    private @Nullable AccessTokenResponse getAccessTokenResponse() throws SmartherAuthorizationException {\n+        try {\n+            final OAuthClientService localOAuthService = this.oAuthService;\n+            if (localOAuthService != null) {\n+                return localOAuthService.getAccessTokenResponse();\n+            }\n+            return null;\n+        } catch (OAuthException | IOException | OAuthResponseException | RuntimeException e) {\n+            throw new SmartherAuthorizationException(e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * Convenience method to update the given Channel state \"only\" if the Channel is linked.\n+     *\n+     * @param channelId\n+     *            the identifier of the Channel to be updated\n+     * @param state\n+     *            the new state to be applied to the given Channel\n+     */\n+    private void updateChannelState(String channelId, State state) {\n+        final Channel channel = thing.getChannel(channelId);\n+\n+        if (channel != null && isLinked(channel.getUID())) {\n+            updateState(channel.getUID(), state);\n+        }\n+    }\n+\n+    /**\n+     * Convenience method to update the Smarther API calls counter for this Bridge.\n+     */\n+    private void updateApiCallsCounter() {\n+        final BridgeStatus localBridgeStatus = this.bridgeStatus;\n+        if (localBridgeStatus != null) {\n+            updateChannelState(CHANNEL_API_CALLS_HANDLED,\n+                    new DecimalType(localBridgeStatus.incrementApiCallsHandled()));\n+        }\n+    }\n+\n+    /**\n+     * Convenience method to check and get the Smarther API instance for this Bridge.\n+     *\n+     * @return the Smarther API instance\n+     *\n+     * @throws {@link SmartherGatewayException}\n+     *             in case the Smarther API instance is {@code null}\n+     */\n+    private SmartherApi getSmartherApi() throws SmartherGatewayException {\n+        final SmartherApi localSmartherApi = this.smartherApi;\n+        if (localSmartherApi == null) {\n+            throw new SmartherGatewayException(\"Smarther API instance is null\");\n+        }\n+        return localSmartherApi;\n+    }\n+\n+    // ===========================================================================\n+    //\n+    // Implementation of the SmartherAccountHandler interface\n+    //\n+    // ===========================================================================\n+\n+    @Override\n+    public ThingUID getUID() {\n+        return thing.getUID();\n+    }\n+\n+    @Override\n+    public String getLabel() {\n+        return StringUtil.defaultString(thing.getLabel());\n+    }\n+\n+    @Override\n+    public List<Location> getLocations() {\n+        final ExpiringCache<List<Location>> localLocationCache = this.locationCache;\n+        final List<Location> locations = (localLocationCache != null) ? localLocationCache.getValue() : null;\n+        return (locations != null) ? locations : Collections.emptyList();\n+    }\n+\n+    @Override\n+    public boolean hasLocation(String plantId) {\n+        final ExpiringCache<List<Location>> localLocationCache = this.locationCache;\n+        final List<Location> locations = (localLocationCache != null) ? localLocationCache.getValue() : null;\n+        return (locations != null) ? locations.stream().anyMatch(l -> l.getPlantId().equals(plantId)) : false;\n+    }\n+\n+    @Override\n+    public List<Plant> getPlants() throws SmartherGatewayException {\n+        updateApiCallsCounter();\n+        return getSmartherApi().getPlants();\n+    }\n+\n+    @Override\n+    public List<Subscription> getSubscriptions() throws SmartherGatewayException {\n+        updateApiCallsCounter();\n+        return getSmartherApi().getSubscriptions();\n+    }\n+\n+    @Override\n+    public String subscribePlant(String plantId, String notificationUrl) throws SmartherGatewayException {\n+        updateApiCallsCounter();\n+        return getSmartherApi().subscribePlant(plantId, notificationUrl);\n+    }\n+\n+    @Override\n+    public void unsubscribePlant(String plantId, String subscriptionId) throws SmartherGatewayException {\n+        updateApiCallsCounter();\n+        getSmartherApi().unsubscribePlant(plantId, subscriptionId);\n+    }\n+\n+    @Override\n+    public List<Module> getLocationModules(Location location) {\n+        try {\n+            updateApiCallsCounter();\n+            return getSmartherApi().getPlantModules(location.getPlantId());\n+        } catch (SmartherGatewayException e) {\n+            return new ArrayList<>();\n+        }\n+    }\n+\n+    @Override\n+    public ModuleStatus getModuleStatus(String plantId, String moduleId) throws SmartherGatewayException {\n+        updateApiCallsCounter();\n+        return getSmartherApi().getModuleStatus(plantId, moduleId);\n+    }\n+\n+    @Override\n+    public boolean setModuleStatus(ModuleSettings moduleSettings) throws SmartherGatewayException {\n+        updateApiCallsCounter();\n+        return getSmartherApi().setModuleStatus(moduleSettings);\n+    }\n+\n+    @Override\n+    public List<Program> getModulePrograms(String plantId, String moduleId) throws SmartherGatewayException {\n+        updateApiCallsCounter();\n+        return getSmartherApi().getModulePrograms(plantId, moduleId);\n+    }\n+\n+    @Override\n+    public boolean isAuthorized() {\n+        try {\n+            final AccessTokenResponse tokenResponse = getAccessTokenResponse();\n+            onAccessTokenResponse(tokenResponse);\n+\n+            return (tokenResponse != null && tokenResponse.getAccessToken() != null\n+                    && tokenResponse.getRefreshToken() != null);\n+        } catch (SmartherAuthorizationException e) {\n+            return false;\n+        }\n+    }\n+\n+    @Override\n+    public boolean isOnline() {\n+        return (thing.getStatus() == ThingStatus.ONLINE);\n+    }\n+\n+    @Override\n+    public String authorize(String redirectUrl, String reqCode, String notificationUrl)\n+            throws SmartherGatewayException {\n+        try {\n+            logger.debug(\"Bridge[{}] Call API gateway to get access token. RedirectUri: {}\", thing.getUID(),\n+                    redirectUrl);\n+\n+            final OAuthClientService localOAuthService = this.oAuthService;\n+            if (localOAuthService == null) {\n+                throw new SmartherAuthorizationException(\"Authorization service is null\");\n+            }\n+\n+            // OAuth2 call to get access token from received authorization code\n+            localOAuthService.getAccessTokenResponseByAuthorizationCode(reqCode, redirectUrl);\n+\n+            // Store the notification URL in bridge configuration\n+            Configuration configuration = editConfiguration();\n+            configuration.put(PROPERTY_NOTIFICATION_URL, notificationUrl);\n+            updateConfiguration(configuration);\n+            config.setNotificationUrl(notificationUrl);\n+            logger.debug(\"Bridge[{}] Store notification URL: {}\", thing.getUID(), notificationUrl);\n+\n+            // Reschedule the polling thread\n+            schedulePoll();\n+\n+            return config.getClientId();\n+        } catch (OAuthResponseException e) {\n+            throw new SmartherAuthorizationException(e.toString(), e);\n+        } catch (OAuthException | IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+            throw new SmartherGatewayException(e.getMessage(), e);\n+        }\n+    }\n+\n+    @Override\n+    public boolean equalsThingUID(String thingUID) {\n+        return thing.getUID().getAsString().equals(thingUID);\n+    }\n+\n+    @Override\n+    public String formatAuthorizationUrl(String redirectUri) {\n+        try {\n+            final OAuthClientService localOAuthService = this.oAuthService;\n+            if (localOAuthService != null) {\n+                return localOAuthService.getAuthorizationUrl(redirectUri, null, thing.getUID().getAsString());\n+            }\n+        } catch (OAuthException e) {\n+            logger.warn(\"Bridge[{}] Error constructing AuthorizationUrl: \", thing.getUID());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1312ca938bfc6de96ce4ebd43c2fc802d824ee0"}, "originalPosition": 601}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwMjM0MDM1", "url": "https://github.com/openhab/openhab-addons/pull/7533#pullrequestreview-430234035", "createdAt": "2020-06-14T16:38:27Z", "commit": {"oid": "2042da64493ed1125a128d58fd78a94f6fee6890"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "87295d9d1935ee21b16e175838a8b8e1ebe63dc4", "author": {"user": {"login": "MrRonfo", "name": "Fabio Possieri"}}, "url": "https://github.com/openhab/openhab-addons/commit/87295d9d1935ee21b16e175838a8b8e1ebe63dc4", "committedDate": "2020-06-23T18:39:45Z", "message": "[smarther] Initial contribution\n\nSigned-off-by: Fabio Possieri <fabio.possieri@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a6af3df4ece4fffe5b97d040d4a9cd49ad88ef2a", "author": {"user": {"login": "MrRonfo", "name": "Fabio Possieri"}}, "url": "https://github.com/openhab/openhab-addons/commit/a6af3df4ece4fffe5b97d040d4a9cd49ad88ef2a", "committedDate": "2020-06-23T18:39:47Z", "message": "Added link to companion HABPanel widget in README.md\n\nSigned-off-by: Fabio Possieri <fabio.possieri@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e9e7f137037113f705e17293d1d98eadf8d9e01b", "author": {"user": {"login": "MrRonfo", "name": "Fabio Possieri"}}, "url": "https://github.com/openhab/openhab-addons/commit/e9e7f137037113f705e17293d1d98eadf8d9e01b", "committedDate": "2020-06-23T18:39:50Z", "message": "Fixed: Authorization Url calculation for local address, formal check of\nNotification Url. Improved: logging and application tutorial in\nREADME.md.\n\nSigned-off-by: Fabio Possieri <fabio.possieri@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "83835abadf1021ab62aedf7954d285e2a02e0667", "author": {"user": {"login": "MrRonfo", "name": "Fabio Possieri"}}, "url": "https://github.com/openhab/openhab-addons/commit/83835abadf1021ab62aedf7954d285e2a02e0667", "committedDate": "2020-06-23T18:39:52Z", "message": "Fixed: rare use case of Legrand API temporary failure in name resolution\n\nSigned-off-by: Fabio Possieri <fabio.possieri@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7237714656aab68387c47a5e5eb37ffac83cc473", "author": {"user": {"login": "MrRonfo", "name": "Fabio Possieri"}}, "url": "https://github.com/openhab/openhab-addons/commit/7237714656aab68387c47a5e5eb37ffac83cc473", "committedDate": "2020-06-23T18:39:55Z", "message": "Update bundles/org.openhab.binding.smarther/README.md\n\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>\nSigned-off-by: Fabio Possieri <fabio.possieri@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5ddcc8a2eb2f400070d74295e8f93360116efa9d", "author": {"user": {"login": "MrRonfo", "name": "Fabio Possieri"}}, "url": "https://github.com/openhab/openhab-addons/commit/5ddcc8a2eb2f400070d74295e8f93360116efa9d", "committedDate": "2020-06-23T18:39:57Z", "message": "Update bundles/org.openhab.binding.smarther/README.md\r\n\r\nSigned-off-by: Fabio Possieri <fabio.possieri@gmail.com>\n\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>\nSigned-off-by: Fabio Possieri <fabio.possieri@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0df609f27cc5df8ef3c0ac2a506b30c97ac5fb09", "author": {"user": {"login": "MrRonfo", "name": "Fabio Possieri"}}, "url": "https://github.com/openhab/openhab-addons/commit/0df609f27cc5df8ef3c0ac2a506b30c97ac5fb09", "committedDate": "2020-06-23T18:40:00Z", "message": "Update bundles/org.openhab.binding.smarther/README.md\r\n\r\nSigned-off-by: Fabio Possieri <fabio.possieri@gmail.com>\n\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>\nSigned-off-by: Fabio Possieri <fabio.possieri@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "99309f8f06f9d5aa9182078a3a9ef0749e46d744", "author": {"user": {"login": "MrRonfo", "name": "Fabio Possieri"}}, "url": "https://github.com/openhab/openhab-addons/commit/99309f8f06f9d5aa9182078a3a9ef0749e46d744", "committedDate": "2020-06-23T18:40:03Z", "message": "Some fixes applied following PR Review from fwolter.\n\nConverted from Joda DateTime to equivalent standard Java DateUtil,\nconverted from Apache Commons to equivalent standard Java StringUtil,\nfixed Temperature conversion to SIUnit, removed unneeded items\n(suppressed annotations, RuntimeException catches, stacktrace print).\n\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>\nSigned-off-by: Fabio Possieri <fabio.possieri@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e598b1483d8c61914caedf47021320e542b38796", "author": {"user": {"login": "MrRonfo", "name": "Fabio Possieri"}}, "url": "https://github.com/openhab/openhab-addons/commit/e598b1483d8c61914caedf47021320e542b38796", "committedDate": "2020-06-23T18:40:05Z", "message": "FIxed reference to bridge authorization process.\n\nSigned-off-by: Fabio Possieri <fabio.possieri@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b8d62de75887e7398e1328eb7e849cdc3dd2432f", "author": {"user": {"login": "MrRonfo", "name": "Fabio Possieri"}}, "url": "https://github.com/openhab/openhab-addons/commit/b8d62de75887e7398e1328eb7e849cdc3dd2432f", "committedDate": "2020-06-23T18:40:08Z", "message": "Some fixes applied following PR Review from fwolter.\n\nMoved API model classes to dto package, upgraded from old Date classes\nto LocalDate and LocalDateTime, optimized StringUtil methods.\n\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>\nSigned-off-by: Fabio Possieri <fabio.possieri@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bb844d820791caed15d34b311438eea3a83ae193", "author": {"user": {"login": "MrRonfo", "name": "Fabio Possieri"}}, "url": "https://github.com/openhab/openhab-addons/commit/bb844d820791caed15d34b311438eea3a83ae193", "committedDate": "2020-06-23T18:40:10Z", "message": "Review of DateUtil parse usage and ZonedDateTime vs LocalDateTime.\n\nSigned-off-by: Fabio Possieri <fabio.possieri@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3213258abbbc78ec1b50751dceb0e7865b0fa459", "author": {"user": {"login": "MrRonfo", "name": "Fabio Possieri"}}, "url": "https://github.com/openhab/openhab-addons/commit/3213258abbbc78ec1b50751dceb0e7865b0fa459", "committedDate": "2020-06-23T18:40:13Z", "message": "Aligned pom.xml to OH 2.5.6 snapshot\n\nSigned-off-by: Fabio Possieri <fabio.possieri@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d22a03203636f6b97dc552710aae45f5d800b592", "author": {"user": {"login": "MrRonfo", "name": "Fabio Possieri"}}, "url": "https://github.com/openhab/openhab-addons/commit/d22a03203636f6b97dc552710aae45f5d800b592", "committedDate": "2020-06-23T18:40:16Z", "message": "Review of unchecked exceptions and code comments\n\nMoved from unchecked to checked exceptions (reorganized the custom\nexceptions tree and reviewed all the exception handling flows in code),\nfixed remaining dependencies to Apache Commons, enhanced classes and\nmethod comments where available.\n\nSigned-off-by: Fabio Possieri <fabio.possieri@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "06643c37cb85d9148a765604dbcb04dd85a9da83", "author": {"user": {"login": "MrRonfo", "name": "Fabio Possieri"}}, "url": "https://github.com/openhab/openhab-addons/commit/06643c37cb85d9148a765604dbcb04dd85a9da83", "committedDate": "2020-06-23T18:40:19Z", "message": "Review of exceptions, nullable items and servlet response\n\nMoved SmartherIllegalPropertyValueException to checked exception and\nhandled it where needed, converted chronothermostat variable to Nullable\nin module handler, fixed servlet response in error cases, completed\ncomments on all dto classes.\n\nSigned-off-by: Fabio Possieri <fabio.possieri@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "67300fbe8483c170a4f1e1cb89a17294b18849b2", "author": {"user": {"login": "MrRonfo", "name": "Fabio Possieri"}}, "url": "https://github.com/openhab/openhab-addons/commit/67300fbe8483c170a4f1e1cb89a17294b18849b2", "committedDate": "2020-06-23T18:40:21Z", "message": "Fixed transition to Unknown status on Bridge thing\n\nFixed the Bridge thing transition to Unknown status in initialize\nmethod, moving it after variables initialization so that handleCommand()\nis eventually called only after.\n\nSigned-off-by: Fabio Possieri <fabio.possieri@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d8631aebf8e0b632245f096d8d58b67b32d382cc", "author": {"user": {"login": "MrRonfo", "name": "Fabio Possieri"}}, "url": "https://github.com/openhab/openhab-addons/commit/d8631aebf8e0b632245f096d8d58b67b32d382cc", "committedDate": "2020-06-23T18:40:23Z", "message": "Some fixes applied following PR Review from cpmeister.\n\nChanged wrong use of NonNullByDefault with Nullable wherever found,\nremoved OSGI component declaration in ThingHandlerService, fixed unit\nattribute in config.xml\n\nSigned-off-by: Fabio Possieri <fabio.possieri@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "295553076105ce78c917b1b9a6fa8f129d239b76", "author": {"user": {"login": "MrRonfo", "name": "Fabio Possieri"}}, "url": "https://github.com/openhab/openhab-addons/commit/295553076105ce78c917b1b9a6fa8f129d239b76", "committedDate": "2020-06-23T18:40:26Z", "message": "Some fixes applied following PR Review from cpmeister.\n\nSigned-off-by: Fabio Possieri <fabio.possieri@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0d8ef84d04a0743256f0974e106fd719b73fbedf", "author": {"user": {"login": "MrRonfo", "name": "Fabio Possieri"}}, "url": "https://github.com/openhab/openhab-addons/commit/0d8ef84d04a0743256f0974e106fd719b73fbedf", "committedDate": "2020-06-23T18:40:28Z", "message": "Some fixes applied following PR Review from cpmeister.\n\nAdded syntax exception handling to Json parsing calls, optimized reading\nnew notification from servlet request, fixed module discovery service.\n\nSigned-off-by: Fabio Possieri <fabio.possieri@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1813b1e2848a074831e735e0a27d6c8f56e9a6e0", "author": {"user": {"login": "MrRonfo", "name": "Fabio Possieri"}}, "url": "https://github.com/openhab/openhab-addons/commit/1813b1e2848a074831e735e0a27d6c8f56e9a6e0", "committedDate": "2020-06-23T18:40:32Z", "message": "Refactored binding naming from smarther to bticinosmarther\n\nJust refactored the binding naming to bticinosmarther (smarther alone\nwas too generic), as BTicino also provides other protocols that can be\nintegrated over time in OH by other developers\n\nSigned-off-by: Fabio Possieri <fabio.possieri@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "38395cba890e2eb208eed727d45802bdb7eaaacf", "author": {"user": {"login": "MrRonfo", "name": "Fabio Possieri"}}, "url": "https://github.com/openhab/openhab-addons/commit/38395cba890e2eb208eed727d45802bdb7eaaacf", "committedDate": "2020-06-23T06:58:52Z", "message": "Refactored binding naming from smarther to bticinosmarther\n\nJust refactored the binding naming to bticinosmarther (smarther alone\nwas too generic), as BTicino also provides other protocols that can be\nintegrated over time in OH by other developers\n\nSigned-off-by: Fabio Possieri <fabio.possieri@gmail.com>"}, "afterCommit": {"oid": "1813b1e2848a074831e735e0a27d6c8f56e9a6e0", "author": {"user": {"login": "MrRonfo", "name": "Fabio Possieri"}}, "url": "https://github.com/openhab/openhab-addons/commit/1813b1e2848a074831e735e0a27d6c8f56e9a6e0", "committedDate": "2020-06-23T18:40:32Z", "message": "Refactored binding naming from smarther to bticinosmarther\n\nJust refactored the binding naming to bticinosmarther (smarther alone\nwas too generic), as BTicino also provides other protocols that can be\nintegrated over time in OH by other developers\n\nSigned-off-by: Fabio Possieri <fabio.possieri@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8bf252fdee587dc75178246537db8bfe456faba2", "author": {"user": {"login": "MrRonfo", "name": "Fabio Possieri"}}, "url": "https://github.com/openhab/openhab-addons/commit/8bf252fdee587dc75178246537db8bfe456faba2", "committedDate": "2020-06-23T20:58:03Z", "message": "Aligned pom.xml to OH 2.5.7 snapshot\n\nSigned-off-by: Fabio Possieri <fabio.possieri@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM3MDE5MDA4", "url": "https://github.com/openhab/openhab-addons/pull/7533#pullrequestreview-437019008", "createdAt": "2020-06-24T21:27:24Z", "commit": {"oid": "8bf252fdee587dc75178246537db8bfe456faba2"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQyMToyNzoyNFrOGojuaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQyMTo0NTozOVrOGokOVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE4MTU0NQ==", "bodyText": "There should not be specific references to a UI in this README, especially not from external sources.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Companion HABPanel widget can be found here: [BTicino Smarther HABPanel widget](https://github.com/MrRonfo/openhab-smarther-widget)", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r445181545", "createdAt": "2020-06-24T21:27:24Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.bticinosmarther/README.md", "diffHunk": "@@ -0,0 +1,328 @@\n+# BTicino Smarther Binding\n+\n+The Smarther binding implements a bridge to the Legrand/BTicino Smarther v2.0 API and allows you to control your BTicino Smarther chronothermostat units with openHAB, making it possible to discover Smarther units connected to your Legrand/BTicino Smarther account.\n+\n+Smarther chronothermostat is produced by BTicino (https://www.bticino.com/products-catalogue/smarther-the-connected-thermostat/), has its own API set and doesn't support the OpenWebNet protocol.\n+\n+Companion HABPanel widget can be found here: [BTicino Smarther HABPanel widget](https://github.com/MrRonfo/openhab-smarther-widget)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8bf252fdee587dc75178246537db8bfe456faba2"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE4MjA1MQ==", "bodyText": "Avoid having long urls as plain text - better provide them as links.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Smarther chronothermostat is produced by BTicino (https://www.bticino.com/products-catalogue/smarther-the-connected-thermostat/), has its own API set and doesn't support the OpenWebNet protocol.\n          \n          \n            \n            Smarther chronothermostat is produced by [BTicino](https://www.bticino.com/products-catalogue/smarther-the-connected-thermostat/), has its own API set and does not support the OpenWebNet protocol.", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r445182051", "createdAt": "2020-06-24T21:28:29Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.bticinosmarther/README.md", "diffHunk": "@@ -0,0 +1,328 @@\n+# BTicino Smarther Binding\n+\n+The Smarther binding implements a bridge to the Legrand/BTicino Smarther v2.0 API and allows you to control your BTicino Smarther chronothermostat units with openHAB, making it possible to discover Smarther units connected to your Legrand/BTicino Smarther account.\n+\n+Smarther chronothermostat is produced by BTicino (https://www.bticino.com/products-catalogue/smarther-the-connected-thermostat/), has its own API set and doesn't support the OpenWebNet protocol.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8bf252fdee587dc75178246537db8bfe456faba2"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE4MzIxOQ==", "bodyText": "Please structure the README along our template and use the same headers, if possible - also make sure to capitalize all headers.", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r445183219", "createdAt": "2020-06-24T21:31:10Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.bticinosmarther/README.md", "diffHunk": "@@ -0,0 +1,328 @@\n+# BTicino Smarther Binding\n+\n+The Smarther binding implements a bridge to the Legrand/BTicino Smarther v2.0 API and allows you to control your BTicino Smarther chronothermostat units with openHAB, making it possible to discover Smarther units connected to your Legrand/BTicino Smarther account.\n+\n+Smarther chronothermostat is produced by BTicino (https://www.bticino.com/products-catalogue/smarther-the-connected-thermostat/), has its own API set and doesn't support the OpenWebNet protocol.\n+\n+Companion HABPanel widget can be found here: [BTicino Smarther HABPanel widget](https://github.com/MrRonfo/openhab-smarther-widget)\n+\n+# Configuring the binding", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8bf252fdee587dc75178246537db8bfe456faba2"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE4NDMzMA==", "bodyText": "This is not really correct. The binding itself does not have ANY configuration in your case.\nAll you describe here is required for configuring a BTicino Smarther Bridge. Theoretically, you can have users with multiple applications registered at Legrand and using different bridges for them.", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r445184330", "createdAt": "2020-06-24T21:33:18Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.bticinosmarther/README.md", "diffHunk": "@@ -0,0 +1,328 @@\n+# BTicino Smarther Binding\n+\n+The Smarther binding implements a bridge to the Legrand/BTicino Smarther v2.0 API and allows you to control your BTicino Smarther chronothermostat units with openHAB, making it possible to discover Smarther units connected to your Legrand/BTicino Smarther account.\n+\n+Smarther chronothermostat is produced by BTicino (https://www.bticino.com/products-catalogue/smarther-the-connected-thermostat/), has its own API set and doesn't support the OpenWebNet protocol.\n+\n+Companion HABPanel widget can be found here: [BTicino Smarther HABPanel widget](https://github.com/MrRonfo/openhab-smarther-widget)\n+\n+# Configuring the binding\n+\n+The binding requires you to register an Application with Legrand Developer portal at https://developer.legrand.com\n+This will get you a set of Client ID and Client Secret parameters to be used by your binding configuration.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8bf252fdee587dc75178246537db8bfe456faba2"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE4Njc3Mw==", "bodyText": "This is not clear to me. What is the \"bridge configuration\" that is mentioned here? The bridge configuration should be set by the user, not by the external device.", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r445186773", "createdAt": "2020-06-24T21:38:49Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.bticinosmarther/README.md", "diffHunk": "@@ -0,0 +1,328 @@\n+# BTicino Smarther Binding\n+\n+The Smarther binding implements a bridge to the Legrand/BTicino Smarther v2.0 API and allows you to control your BTicino Smarther chronothermostat units with openHAB, making it possible to discover Smarther units connected to your Legrand/BTicino Smarther account.\n+\n+Smarther chronothermostat is produced by BTicino (https://www.bticino.com/products-catalogue/smarther-the-connected-thermostat/), has its own API set and doesn't support the OpenWebNet protocol.\n+\n+Companion HABPanel widget can be found here: [BTicino Smarther HABPanel widget](https://github.com/MrRonfo/openhab-smarther-widget)\n+\n+# Configuring the binding\n+\n+The binding requires you to register an Application with Legrand Developer portal at https://developer.legrand.com\n+This will get you a set of Client ID and Client Secret parameters to be used by your binding configuration.\n+\n+Optionally, if you want to later receive push notifications on the status of your units, consider to make your openHAB installation reachable in https from a public IP or domain (see [Note on notifications](#note-on-notifications)).\n+\n+## Create an account\n+\n+Follow the instructions in the tutorial at https://developer.legrand.com/tutorials/getting-started/, under: \n+\n+* Step 1 : Create an account\n+* Step 2 : Subscribe to a product and get subscription key\n+\n+There's also a Step 3 in this tutorial, you can skip it as not needed to complete this process.\n+Simply write down your \"Primary Key\" as it will be needed later on in the setup.\n+\n+## Create an application\n+\n+Follow the instructions in the tutorial at https://developer.legrand.com/tutorials/create-an-application/, under: \n+\n+* Step 1 : Register your application\n+* Step 2 : Check scopes\n+* Step 3 : Getting application details\n+\n+When registering your new Legrand Application for openHAB BTicino Smarther Bridge you have to specify the allowed Reply URL, aka white-listed address.\n+Here you have to specify the URL to the Bridge Authorization page on your server.\n+\n+For example if you run your openHAB server on http://openhabianpi:8080 you should set `http://openhabianpi:8080/bticinosmarther/connectsmarther` as the \"First Reply URL\" required field in Step 1.\n+Other Reply URLs (second, third, etc.) you can leave them blank.\n+\n+This is **very important** since the authorize process with Legrand takes place using your client web browser and Legrand will have to know the right URL to your openHAB server for the authorization to be completed.\n+When you have authorized with Legrand, this Redirect URI is where authorization tokens for your openHAB BTicino Smarther Brigde will be sent and they have to be received by the servlet on `/bticinosmarther/connectsmarther`.\n+\n+![Application 1](doc/images/application-1.png)\n+\n+On Step 2, please make sure to select both `comfort.read` and `comfort.write` scopes, as they're mandatory for the binding to work.\n+\n+![Application 2](doc/images/application-2.png)\n+\n+Usually, Step 3 is then completed by Legrand within 1-2 days and you'll receive an email containing your application's Client ID and Client Secret.\n+\n+### Note on notifications\n+\n+If you want to later receive push notifications (device status) from Legrand for this application, you must have your openHAB server reachable from a public IP/address and use the related public IP/address and public port when filling-in the \"Reply URL\" field in Step 1.\n+\n+## Configure the binding\n+\n+1. Install the binding and make sure the _BTicino Smarther Binding_ is listed on your server.\n+2. Complete the _Create an account_ and _Create an application_ steps if you have not already done so (see above).\n+3. Make sure you have your Legrand account _Primary Key_ and your Legrand application _Client ID_ and _Client Secret_ identities available.\n+4. Go to your preferred openHAB admin UI and add a new Thing - select the **\"BTicino Smarther Bridge\"**.\n+5. Choose new Id for the bridge, unless you like the generated one.\n+6. Put in your _Primary Key_ (in _Subscription Key_ field), _Client ID_ and _Cliend Secret_ in their respective fields of the bridge configuration.\n+7. Set _Use Notifications_ to `ON` if your openHAB server is reachable from a public https URL (see [Note on notifications](#note-on-notifications)), set `OFF` otherwise.\n+8. You can leave the _Bridge Status Refresh Period_ as is.\n+9. Save the bridge.\n+10. The bridge thing will stay in state _INITIALIZING_ and eventually go _OFFLINE_ - this is fine, as you now have to authorize this bridge with Legrand.\n+11. Go to the authorization page of your server (see [Create an application](#create-an-application)) `http://<your openHAB address>:<your openHAB port>/bticinosmarther/connectsmarther`; your newly added bridge should be listed there (along with the available locations).\n+12. Press the _\"Authorize Bridge\"_ button; this will take you either to the login page of Legrand portal or directly to the authorization screen.\n+13. Login and/or authorize the application; if the Reply URL is correct you will be returned and the entry should show your bridge is authorized with your Client ID; otherwise, go back to your application configuration on Legrand portal and ensure you have set the right Reply URL (see [Troubleshooting](#troubleshooting) below).\n+14. The binding will be updated with a refresh token and go _ONLINE_ (the refresh token is used to re-authorize the bridge with Legrand Smarther API whenever required).\n+\n+![Tutorial 1](doc/images/tutorial-1.png)\n+\n+![Tutorial 2](doc/images/tutorial-2.png)\n+\n+![Tutorial 3](doc/images/tutorial-3.png)\n+\n+Now that you have got your bridge _ONLINE_ it is time to discover your devices! Go to Paper UI Inbox and search for **\"BTicino Smarther Chronothermostat\"** things.\n+Any BTicino Smarther Chronothermostat device currently available on your account should show up immediately.\n+\n+If no devices show up you may have to trigger the openHAB discovery several times as bridge will only find active devices known by the Smarther API at the time the discovery is triggered.\n+\n+Should the bridge configuration be broken for any reason, the authorization procedure can be reinitiated from step 11 whenever required.\n+You can force reinitialization by authorizing again on the `/bticinosmarther/connectsmarther` page, even if the page shows it as already authorized. This will reset the refresh token.\n+\n+The following configuration options are available on the BTicino Smarther Bridge thing:\n+\n+| Parameter             | Description                                                                                                                                        | Condition |\n+|-----------------------|----------------------------------------------------------------------------------------------------------------------------------------------------|-----------|\n+| subscriptionKey       | This is the Primary Key provided by Legrand when you create a new Account and subscribe to a product                                               | Required  |\n+| clientId              | This is the Client ID provided by Legrand when you add a new Application for openHAB to your Legrand account                                       | Required  |\n+| clientSecret          | This is the Client Secret provided by Legrand when you add a new Application for openHAB to your Legrand account                                   | Required  |\n+| useNotifications      | ON = the bridge subscribes to receive push notifications on devices status change; OFF = status updates are requested (pull) on a periodical basis |           |\n+| statusRefreshPeriod   | This is the frequency of the polling requests to the Smarther API to update the bridge status (in minutes)                                         |           |\n+\n+The following configuration options are available on the BTicino Smarther Chronothermostat thing:\n+\n+| Parameter             | Description                                                                                                                                        | Condition |\n+|-----------------------|----------------------------------------------------------------------------------------------------------------------------------------------------|-----------|\n+| plantId               | This is the Plant Id of the location the Chronothermostat module is installed in, provided by Smarther API                                         | Read-only |\n+| moduleId              | This is the Module Id of the Chronothermostat module, provided by Smarther API                                                                     | Read-only |\n+| settingsAutoupdate    | ON = the thermostat settings are aligned with current status whenever it changes; OFF = settings are aligned to status only upon initialization    |           |\n+| programsRefreshPeriod | This is the frequency the Smarther API gateway is called to refresh Programs list used in \"automatic\" mode (in hours)                              |           |\n+| numberOfEndDays       | This is the number of days to be displayed in module settings, as options list for \"End Date\" field in \"manual\" mode                               |           |\n+| statusRefreshPeriod   | This is the frequency of the polling requests to the Smarther API to update the module status and sensor data (in minutes)                         |           |\n+\n+## Troubleshooting\n+\n+When configuring the binding (see step 13 [here](#configure-the-binding)), you can receive the following error from Legrand portal:\n+\n+```\n+{\n+  \"error\": \"invalid_request\",\n+  \"error_description\": \"The reply url host xxxxx doesn't match with the ones configured on the application\"\n+}\n+```\n+\n+This means you've either opened the `/bticinosmarther/connectsmarther` page from the wrong address or set the wrong \"Reply URL\" attribute in your application (see step 1 [here](#create-an-application)).\n+Please remember these two strings must match for authentication process to work.\n+\n+To solve the issue, either:\n+\n+* Correct the address you're accessing the `/bticinosmarther/connectsmarther` page from, to match the \"Reply URL\" attribute registered in your application, or\n+* Should you have specified a wrong \"Reply URL\" attribute in your application, go to the Legrand portal and correct it accordingly then resubmit the application for approval.\n+\n+## Supported Things\n+\n+All BTicino Smarther Chronothermostat device models should be discoverable through this binding:\n+\n+* Flush mounting installation item (X8000)\n+* Wall installation item (X8000W)\n+\n+If you can control them from BTicino Thermostat mobile app on your iPhone/Android you should be able to add it as a thing.\n+\n+## Discovery\n+\n+As long as BTicino Smarther Chronothermostat devices are available in the locations registered on the user account configured with the bridge they should show up whenever you initiate discovery of things.\n+\n+If no devices are showing up, try to connect to the device(s) from your smartphone to make sure the device(s) are in use by your user account.\n+\n+The discovery of devices in the Smarther API is based on what is known by Legrand.\n+There is difference between e.g. smartphones and computers which can discover devices on the local network and the Smarther API which is not able to do so; it only knows about a device if your account is currently associated with the device.\n+\n+## Channels\n+\n+### Bridge\n+\n+The channels on the bridge are the ones used to get details of current communication with Smarther API on the Legrand account associated with the bridge.\n+\n+**Status Channels:**\n+\n+The following channels represent the current operational status of the bridge and must all be referenced with the `status#` prefix.\n+\n+| Channel Type ID   | Item Type            | Read/Write | Description                                                                            | Type     |\n+|-------------------|----------------------|------------|----------------------------------------------------------------------------------------|----------|\n+| apiCallsHandled   | Number               | Read-only  | The total number of API calls handled by the bridge                                    | Common   |\n+| notifsReceived    | Number               | Read-only  | The total number of push notifications received by the bridge                          | Common   |\n+| notifsRejected    | Number               | Read-only  | The total number of push notifications rejected by the bridge                          | Common   |\n+\n+**Configuration Channels:**\n+\n+The following channels represent convenience configuration channels for the bridge and must all be referenced with the `config#` prefix.\n+\n+| Channel Type ID   | Item Type            | Read/Write | Description                                                                            | Type     |\n+|-------------------|----------------------|------------|----------------------------------------------------------------------------------------|----------|\n+| fetchConfig       | Switch               | Read-write | Trigger to manually fetch updated bridge configuration from Smarther API               | Advanced |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8bf252fdee587dc75178246537db8bfe456faba2"}, "originalPosition": 166}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE4NjgzNg==", "bodyText": "accessTokens should never be a channel. What's the idea here?", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r445186836", "createdAt": "2020-06-24T21:38:59Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.bticinosmarther/README.md", "diffHunk": "@@ -0,0 +1,328 @@\n+# BTicino Smarther Binding\n+\n+The Smarther binding implements a bridge to the Legrand/BTicino Smarther v2.0 API and allows you to control your BTicino Smarther chronothermostat units with openHAB, making it possible to discover Smarther units connected to your Legrand/BTicino Smarther account.\n+\n+Smarther chronothermostat is produced by BTicino (https://www.bticino.com/products-catalogue/smarther-the-connected-thermostat/), has its own API set and doesn't support the OpenWebNet protocol.\n+\n+Companion HABPanel widget can be found here: [BTicino Smarther HABPanel widget](https://github.com/MrRonfo/openhab-smarther-widget)\n+\n+# Configuring the binding\n+\n+The binding requires you to register an Application with Legrand Developer portal at https://developer.legrand.com\n+This will get you a set of Client ID and Client Secret parameters to be used by your binding configuration.\n+\n+Optionally, if you want to later receive push notifications on the status of your units, consider to make your openHAB installation reachable in https from a public IP or domain (see [Note on notifications](#note-on-notifications)).\n+\n+## Create an account\n+\n+Follow the instructions in the tutorial at https://developer.legrand.com/tutorials/getting-started/, under: \n+\n+* Step 1 : Create an account\n+* Step 2 : Subscribe to a product and get subscription key\n+\n+There's also a Step 3 in this tutorial, you can skip it as not needed to complete this process.\n+Simply write down your \"Primary Key\" as it will be needed later on in the setup.\n+\n+## Create an application\n+\n+Follow the instructions in the tutorial at https://developer.legrand.com/tutorials/create-an-application/, under: \n+\n+* Step 1 : Register your application\n+* Step 2 : Check scopes\n+* Step 3 : Getting application details\n+\n+When registering your new Legrand Application for openHAB BTicino Smarther Bridge you have to specify the allowed Reply URL, aka white-listed address.\n+Here you have to specify the URL to the Bridge Authorization page on your server.\n+\n+For example if you run your openHAB server on http://openhabianpi:8080 you should set `http://openhabianpi:8080/bticinosmarther/connectsmarther` as the \"First Reply URL\" required field in Step 1.\n+Other Reply URLs (second, third, etc.) you can leave them blank.\n+\n+This is **very important** since the authorize process with Legrand takes place using your client web browser and Legrand will have to know the right URL to your openHAB server for the authorization to be completed.\n+When you have authorized with Legrand, this Redirect URI is where authorization tokens for your openHAB BTicino Smarther Brigde will be sent and they have to be received by the servlet on `/bticinosmarther/connectsmarther`.\n+\n+![Application 1](doc/images/application-1.png)\n+\n+On Step 2, please make sure to select both `comfort.read` and `comfort.write` scopes, as they're mandatory for the binding to work.\n+\n+![Application 2](doc/images/application-2.png)\n+\n+Usually, Step 3 is then completed by Legrand within 1-2 days and you'll receive an email containing your application's Client ID and Client Secret.\n+\n+### Note on notifications\n+\n+If you want to later receive push notifications (device status) from Legrand for this application, you must have your openHAB server reachable from a public IP/address and use the related public IP/address and public port when filling-in the \"Reply URL\" field in Step 1.\n+\n+## Configure the binding\n+\n+1. Install the binding and make sure the _BTicino Smarther Binding_ is listed on your server.\n+2. Complete the _Create an account_ and _Create an application_ steps if you have not already done so (see above).\n+3. Make sure you have your Legrand account _Primary Key_ and your Legrand application _Client ID_ and _Client Secret_ identities available.\n+4. Go to your preferred openHAB admin UI and add a new Thing - select the **\"BTicino Smarther Bridge\"**.\n+5. Choose new Id for the bridge, unless you like the generated one.\n+6. Put in your _Primary Key_ (in _Subscription Key_ field), _Client ID_ and _Cliend Secret_ in their respective fields of the bridge configuration.\n+7. Set _Use Notifications_ to `ON` if your openHAB server is reachable from a public https URL (see [Note on notifications](#note-on-notifications)), set `OFF` otherwise.\n+8. You can leave the _Bridge Status Refresh Period_ as is.\n+9. Save the bridge.\n+10. The bridge thing will stay in state _INITIALIZING_ and eventually go _OFFLINE_ - this is fine, as you now have to authorize this bridge with Legrand.\n+11. Go to the authorization page of your server (see [Create an application](#create-an-application)) `http://<your openHAB address>:<your openHAB port>/bticinosmarther/connectsmarther`; your newly added bridge should be listed there (along with the available locations).\n+12. Press the _\"Authorize Bridge\"_ button; this will take you either to the login page of Legrand portal or directly to the authorization screen.\n+13. Login and/or authorize the application; if the Reply URL is correct you will be returned and the entry should show your bridge is authorized with your Client ID; otherwise, go back to your application configuration on Legrand portal and ensure you have set the right Reply URL (see [Troubleshooting](#troubleshooting) below).\n+14. The binding will be updated with a refresh token and go _ONLINE_ (the refresh token is used to re-authorize the bridge with Legrand Smarther API whenever required).\n+\n+![Tutorial 1](doc/images/tutorial-1.png)\n+\n+![Tutorial 2](doc/images/tutorial-2.png)\n+\n+![Tutorial 3](doc/images/tutorial-3.png)\n+\n+Now that you have got your bridge _ONLINE_ it is time to discover your devices! Go to Paper UI Inbox and search for **\"BTicino Smarther Chronothermostat\"** things.\n+Any BTicino Smarther Chronothermostat device currently available on your account should show up immediately.\n+\n+If no devices show up you may have to trigger the openHAB discovery several times as bridge will only find active devices known by the Smarther API at the time the discovery is triggered.\n+\n+Should the bridge configuration be broken for any reason, the authorization procedure can be reinitiated from step 11 whenever required.\n+You can force reinitialization by authorizing again on the `/bticinosmarther/connectsmarther` page, even if the page shows it as already authorized. This will reset the refresh token.\n+\n+The following configuration options are available on the BTicino Smarther Bridge thing:\n+\n+| Parameter             | Description                                                                                                                                        | Condition |\n+|-----------------------|----------------------------------------------------------------------------------------------------------------------------------------------------|-----------|\n+| subscriptionKey       | This is the Primary Key provided by Legrand when you create a new Account and subscribe to a product                                               | Required  |\n+| clientId              | This is the Client ID provided by Legrand when you add a new Application for openHAB to your Legrand account                                       | Required  |\n+| clientSecret          | This is the Client Secret provided by Legrand when you add a new Application for openHAB to your Legrand account                                   | Required  |\n+| useNotifications      | ON = the bridge subscribes to receive push notifications on devices status change; OFF = status updates are requested (pull) on a periodical basis |           |\n+| statusRefreshPeriod   | This is the frequency of the polling requests to the Smarther API to update the bridge status (in minutes)                                         |           |\n+\n+The following configuration options are available on the BTicino Smarther Chronothermostat thing:\n+\n+| Parameter             | Description                                                                                                                                        | Condition |\n+|-----------------------|----------------------------------------------------------------------------------------------------------------------------------------------------|-----------|\n+| plantId               | This is the Plant Id of the location the Chronothermostat module is installed in, provided by Smarther API                                         | Read-only |\n+| moduleId              | This is the Module Id of the Chronothermostat module, provided by Smarther API                                                                     | Read-only |\n+| settingsAutoupdate    | ON = the thermostat settings are aligned with current status whenever it changes; OFF = settings are aligned to status only upon initialization    |           |\n+| programsRefreshPeriod | This is the frequency the Smarther API gateway is called to refresh Programs list used in \"automatic\" mode (in hours)                              |           |\n+| numberOfEndDays       | This is the number of days to be displayed in module settings, as options list for \"End Date\" field in \"manual\" mode                               |           |\n+| statusRefreshPeriod   | This is the frequency of the polling requests to the Smarther API to update the module status and sensor data (in minutes)                         |           |\n+\n+## Troubleshooting\n+\n+When configuring the binding (see step 13 [here](#configure-the-binding)), you can receive the following error from Legrand portal:\n+\n+```\n+{\n+  \"error\": \"invalid_request\",\n+  \"error_description\": \"The reply url host xxxxx doesn't match with the ones configured on the application\"\n+}\n+```\n+\n+This means you've either opened the `/bticinosmarther/connectsmarther` page from the wrong address or set the wrong \"Reply URL\" attribute in your application (see step 1 [here](#create-an-application)).\n+Please remember these two strings must match for authentication process to work.\n+\n+To solve the issue, either:\n+\n+* Correct the address you're accessing the `/bticinosmarther/connectsmarther` page from, to match the \"Reply URL\" attribute registered in your application, or\n+* Should you have specified a wrong \"Reply URL\" attribute in your application, go to the Legrand portal and correct it accordingly then resubmit the application for approval.\n+\n+## Supported Things\n+\n+All BTicino Smarther Chronothermostat device models should be discoverable through this binding:\n+\n+* Flush mounting installation item (X8000)\n+* Wall installation item (X8000W)\n+\n+If you can control them from BTicino Thermostat mobile app on your iPhone/Android you should be able to add it as a thing.\n+\n+## Discovery\n+\n+As long as BTicino Smarther Chronothermostat devices are available in the locations registered on the user account configured with the bridge they should show up whenever you initiate discovery of things.\n+\n+If no devices are showing up, try to connect to the device(s) from your smartphone to make sure the device(s) are in use by your user account.\n+\n+The discovery of devices in the Smarther API is based on what is known by Legrand.\n+There is difference between e.g. smartphones and computers which can discover devices on the local network and the Smarther API which is not able to do so; it only knows about a device if your account is currently associated with the device.\n+\n+## Channels\n+\n+### Bridge\n+\n+The channels on the bridge are the ones used to get details of current communication with Smarther API on the Legrand account associated with the bridge.\n+\n+**Status Channels:**\n+\n+The following channels represent the current operational status of the bridge and must all be referenced with the `status#` prefix.\n+\n+| Channel Type ID   | Item Type            | Read/Write | Description                                                                            | Type     |\n+|-------------------|----------------------|------------|----------------------------------------------------------------------------------------|----------|\n+| apiCallsHandled   | Number               | Read-only  | The total number of API calls handled by the bridge                                    | Common   |\n+| notifsReceived    | Number               | Read-only  | The total number of push notifications received by the bridge                          | Common   |\n+| notifsRejected    | Number               | Read-only  | The total number of push notifications rejected by the bridge                          | Common   |\n+\n+**Configuration Channels:**\n+\n+The following channels represent convenience configuration channels for the bridge and must all be referenced with the `config#` prefix.\n+\n+| Channel Type ID   | Item Type            | Read/Write | Description                                                                            | Type     |\n+|-------------------|----------------------|------------|----------------------------------------------------------------------------------------|----------|\n+| fetchConfig       | Switch               | Read-write | Trigger to manually fetch updated bridge configuration from Smarther API               | Advanced |\n+| accessToken       | String               | Read-only  | The current accessToken used in communication with Smarther API                        | Advanced |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8bf252fdee587dc75178246537db8bfe456faba2"}, "originalPosition": 167}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE4NzI1NQ==", "bodyText": "This is given in the table below - can this sentence here thus be removed?", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r445187255", "createdAt": "2020-06-24T21:39:57Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.bticinosmarther/README.md", "diffHunk": "@@ -0,0 +1,328 @@\n+# BTicino Smarther Binding\n+\n+The Smarther binding implements a bridge to the Legrand/BTicino Smarther v2.0 API and allows you to control your BTicino Smarther chronothermostat units with openHAB, making it possible to discover Smarther units connected to your Legrand/BTicino Smarther account.\n+\n+Smarther chronothermostat is produced by BTicino (https://www.bticino.com/products-catalogue/smarther-the-connected-thermostat/), has its own API set and doesn't support the OpenWebNet protocol.\n+\n+Companion HABPanel widget can be found here: [BTicino Smarther HABPanel widget](https://github.com/MrRonfo/openhab-smarther-widget)\n+\n+# Configuring the binding\n+\n+The binding requires you to register an Application with Legrand Developer portal at https://developer.legrand.com\n+This will get you a set of Client ID and Client Secret parameters to be used by your binding configuration.\n+\n+Optionally, if you want to later receive push notifications on the status of your units, consider to make your openHAB installation reachable in https from a public IP or domain (see [Note on notifications](#note-on-notifications)).\n+\n+## Create an account\n+\n+Follow the instructions in the tutorial at https://developer.legrand.com/tutorials/getting-started/, under: \n+\n+* Step 1 : Create an account\n+* Step 2 : Subscribe to a product and get subscription key\n+\n+There's also a Step 3 in this tutorial, you can skip it as not needed to complete this process.\n+Simply write down your \"Primary Key\" as it will be needed later on in the setup.\n+\n+## Create an application\n+\n+Follow the instructions in the tutorial at https://developer.legrand.com/tutorials/create-an-application/, under: \n+\n+* Step 1 : Register your application\n+* Step 2 : Check scopes\n+* Step 3 : Getting application details\n+\n+When registering your new Legrand Application for openHAB BTicino Smarther Bridge you have to specify the allowed Reply URL, aka white-listed address.\n+Here you have to specify the URL to the Bridge Authorization page on your server.\n+\n+For example if you run your openHAB server on http://openhabianpi:8080 you should set `http://openhabianpi:8080/bticinosmarther/connectsmarther` as the \"First Reply URL\" required field in Step 1.\n+Other Reply URLs (second, third, etc.) you can leave them blank.\n+\n+This is **very important** since the authorize process with Legrand takes place using your client web browser and Legrand will have to know the right URL to your openHAB server for the authorization to be completed.\n+When you have authorized with Legrand, this Redirect URI is where authorization tokens for your openHAB BTicino Smarther Brigde will be sent and they have to be received by the servlet on `/bticinosmarther/connectsmarther`.\n+\n+![Application 1](doc/images/application-1.png)\n+\n+On Step 2, please make sure to select both `comfort.read` and `comfort.write` scopes, as they're mandatory for the binding to work.\n+\n+![Application 2](doc/images/application-2.png)\n+\n+Usually, Step 3 is then completed by Legrand within 1-2 days and you'll receive an email containing your application's Client ID and Client Secret.\n+\n+### Note on notifications\n+\n+If you want to later receive push notifications (device status) from Legrand for this application, you must have your openHAB server reachable from a public IP/address and use the related public IP/address and public port when filling-in the \"Reply URL\" field in Step 1.\n+\n+## Configure the binding\n+\n+1. Install the binding and make sure the _BTicino Smarther Binding_ is listed on your server.\n+2. Complete the _Create an account_ and _Create an application_ steps if you have not already done so (see above).\n+3. Make sure you have your Legrand account _Primary Key_ and your Legrand application _Client ID_ and _Client Secret_ identities available.\n+4. Go to your preferred openHAB admin UI and add a new Thing - select the **\"BTicino Smarther Bridge\"**.\n+5. Choose new Id for the bridge, unless you like the generated one.\n+6. Put in your _Primary Key_ (in _Subscription Key_ field), _Client ID_ and _Cliend Secret_ in their respective fields of the bridge configuration.\n+7. Set _Use Notifications_ to `ON` if your openHAB server is reachable from a public https URL (see [Note on notifications](#note-on-notifications)), set `OFF` otherwise.\n+8. You can leave the _Bridge Status Refresh Period_ as is.\n+9. Save the bridge.\n+10. The bridge thing will stay in state _INITIALIZING_ and eventually go _OFFLINE_ - this is fine, as you now have to authorize this bridge with Legrand.\n+11. Go to the authorization page of your server (see [Create an application](#create-an-application)) `http://<your openHAB address>:<your openHAB port>/bticinosmarther/connectsmarther`; your newly added bridge should be listed there (along with the available locations).\n+12. Press the _\"Authorize Bridge\"_ button; this will take you either to the login page of Legrand portal or directly to the authorization screen.\n+13. Login and/or authorize the application; if the Reply URL is correct you will be returned and the entry should show your bridge is authorized with your Client ID; otherwise, go back to your application configuration on Legrand portal and ensure you have set the right Reply URL (see [Troubleshooting](#troubleshooting) below).\n+14. The binding will be updated with a refresh token and go _ONLINE_ (the refresh token is used to re-authorize the bridge with Legrand Smarther API whenever required).\n+\n+![Tutorial 1](doc/images/tutorial-1.png)\n+\n+![Tutorial 2](doc/images/tutorial-2.png)\n+\n+![Tutorial 3](doc/images/tutorial-3.png)\n+\n+Now that you have got your bridge _ONLINE_ it is time to discover your devices! Go to Paper UI Inbox and search for **\"BTicino Smarther Chronothermostat\"** things.\n+Any BTicino Smarther Chronothermostat device currently available on your account should show up immediately.\n+\n+If no devices show up you may have to trigger the openHAB discovery several times as bridge will only find active devices known by the Smarther API at the time the discovery is triggered.\n+\n+Should the bridge configuration be broken for any reason, the authorization procedure can be reinitiated from step 11 whenever required.\n+You can force reinitialization by authorizing again on the `/bticinosmarther/connectsmarther` page, even if the page shows it as already authorized. This will reset the refresh token.\n+\n+The following configuration options are available on the BTicino Smarther Bridge thing:\n+\n+| Parameter             | Description                                                                                                                                        | Condition |\n+|-----------------------|----------------------------------------------------------------------------------------------------------------------------------------------------|-----------|\n+| subscriptionKey       | This is the Primary Key provided by Legrand when you create a new Account and subscribe to a product                                               | Required  |\n+| clientId              | This is the Client ID provided by Legrand when you add a new Application for openHAB to your Legrand account                                       | Required  |\n+| clientSecret          | This is the Client Secret provided by Legrand when you add a new Application for openHAB to your Legrand account                                   | Required  |\n+| useNotifications      | ON = the bridge subscribes to receive push notifications on devices status change; OFF = status updates are requested (pull) on a periodical basis |           |\n+| statusRefreshPeriod   | This is the frequency of the polling requests to the Smarther API to update the bridge status (in minutes)                                         |           |\n+\n+The following configuration options are available on the BTicino Smarther Chronothermostat thing:\n+\n+| Parameter             | Description                                                                                                                                        | Condition |\n+|-----------------------|----------------------------------------------------------------------------------------------------------------------------------------------------|-----------|\n+| plantId               | This is the Plant Id of the location the Chronothermostat module is installed in, provided by Smarther API                                         | Read-only |\n+| moduleId              | This is the Module Id of the Chronothermostat module, provided by Smarther API                                                                     | Read-only |\n+| settingsAutoupdate    | ON = the thermostat settings are aligned with current status whenever it changes; OFF = settings are aligned to status only upon initialization    |           |\n+| programsRefreshPeriod | This is the frequency the Smarther API gateway is called to refresh Programs list used in \"automatic\" mode (in hours)                              |           |\n+| numberOfEndDays       | This is the number of days to be displayed in module settings, as options list for \"End Date\" field in \"manual\" mode                               |           |\n+| statusRefreshPeriod   | This is the frequency of the polling requests to the Smarther API to update the module status and sensor data (in minutes)                         |           |\n+\n+## Troubleshooting\n+\n+When configuring the binding (see step 13 [here](#configure-the-binding)), you can receive the following error from Legrand portal:\n+\n+```\n+{\n+  \"error\": \"invalid_request\",\n+  \"error_description\": \"The reply url host xxxxx doesn't match with the ones configured on the application\"\n+}\n+```\n+\n+This means you've either opened the `/bticinosmarther/connectsmarther` page from the wrong address or set the wrong \"Reply URL\" attribute in your application (see step 1 [here](#create-an-application)).\n+Please remember these two strings must match for authentication process to work.\n+\n+To solve the issue, either:\n+\n+* Correct the address you're accessing the `/bticinosmarther/connectsmarther` page from, to match the \"Reply URL\" attribute registered in your application, or\n+* Should you have specified a wrong \"Reply URL\" attribute in your application, go to the Legrand portal and correct it accordingly then resubmit the application for approval.\n+\n+## Supported Things\n+\n+All BTicino Smarther Chronothermostat device models should be discoverable through this binding:\n+\n+* Flush mounting installation item (X8000)\n+* Wall installation item (X8000W)\n+\n+If you can control them from BTicino Thermostat mobile app on your iPhone/Android you should be able to add it as a thing.\n+\n+## Discovery\n+\n+As long as BTicino Smarther Chronothermostat devices are available in the locations registered on the user account configured with the bridge they should show up whenever you initiate discovery of things.\n+\n+If no devices are showing up, try to connect to the device(s) from your smartphone to make sure the device(s) are in use by your user account.\n+\n+The discovery of devices in the Smarther API is based on what is known by Legrand.\n+There is difference between e.g. smartphones and computers which can discover devices on the local network and the Smarther API which is not able to do so; it only knows about a device if your account is currently associated with the device.\n+\n+## Channels\n+\n+### Bridge\n+\n+The channels on the bridge are the ones used to get details of current communication with Smarther API on the Legrand account associated with the bridge.\n+\n+**Status Channels:**\n+\n+The following channels represent the current operational status of the bridge and must all be referenced with the `status#` prefix.\n+\n+| Channel Type ID   | Item Type            | Read/Write | Description                                                                            | Type     |\n+|-------------------|----------------------|------------|----------------------------------------------------------------------------------------|----------|\n+| apiCallsHandled   | Number               | Read-only  | The total number of API calls handled by the bridge                                    | Common   |\n+| notifsReceived    | Number               | Read-only  | The total number of push notifications received by the bridge                          | Common   |\n+| notifsRejected    | Number               | Read-only  | The total number of push notifications rejected by the bridge                          | Common   |\n+\n+**Configuration Channels:**\n+\n+The following channels represent convenience configuration channels for the bridge and must all be referenced with the `config#` prefix.\n+\n+| Channel Type ID   | Item Type            | Read/Write | Description                                                                            | Type     |\n+|-------------------|----------------------|------------|----------------------------------------------------------------------------------------|----------|\n+| fetchConfig       | Switch               | Read-write | Trigger to manually fetch updated bridge configuration from Smarther API               | Advanced |\n+| accessToken       | String               | Read-only  | The current accessToken used in communication with Smarther API                        | Advanced |\n+\n+### Devices\n+\n+The temperature channels have dimension `Number:Temperature` and a precision of one tenth degree Celsius.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8bf252fdee587dc75178246537db8bfe456faba2"}, "originalPosition": 171}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE4ODc5Ng==", "bodyText": "bridge configuration?", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r445188796", "createdAt": "2020-06-24T21:43:23Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.bticinosmarther/README.md", "diffHunk": "@@ -0,0 +1,328 @@\n+# BTicino Smarther Binding\n+\n+The Smarther binding implements a bridge to the Legrand/BTicino Smarther v2.0 API and allows you to control your BTicino Smarther chronothermostat units with openHAB, making it possible to discover Smarther units connected to your Legrand/BTicino Smarther account.\n+\n+Smarther chronothermostat is produced by BTicino (https://www.bticino.com/products-catalogue/smarther-the-connected-thermostat/), has its own API set and doesn't support the OpenWebNet protocol.\n+\n+Companion HABPanel widget can be found here: [BTicino Smarther HABPanel widget](https://github.com/MrRonfo/openhab-smarther-widget)\n+\n+# Configuring the binding\n+\n+The binding requires you to register an Application with Legrand Developer portal at https://developer.legrand.com\n+This will get you a set of Client ID and Client Secret parameters to be used by your binding configuration.\n+\n+Optionally, if you want to later receive push notifications on the status of your units, consider to make your openHAB installation reachable in https from a public IP or domain (see [Note on notifications](#note-on-notifications)).\n+\n+## Create an account\n+\n+Follow the instructions in the tutorial at https://developer.legrand.com/tutorials/getting-started/, under: \n+\n+* Step 1 : Create an account\n+* Step 2 : Subscribe to a product and get subscription key\n+\n+There's also a Step 3 in this tutorial, you can skip it as not needed to complete this process.\n+Simply write down your \"Primary Key\" as it will be needed later on in the setup.\n+\n+## Create an application\n+\n+Follow the instructions in the tutorial at https://developer.legrand.com/tutorials/create-an-application/, under: \n+\n+* Step 1 : Register your application\n+* Step 2 : Check scopes\n+* Step 3 : Getting application details\n+\n+When registering your new Legrand Application for openHAB BTicino Smarther Bridge you have to specify the allowed Reply URL, aka white-listed address.\n+Here you have to specify the URL to the Bridge Authorization page on your server.\n+\n+For example if you run your openHAB server on http://openhabianpi:8080 you should set `http://openhabianpi:8080/bticinosmarther/connectsmarther` as the \"First Reply URL\" required field in Step 1.\n+Other Reply URLs (second, third, etc.) you can leave them blank.\n+\n+This is **very important** since the authorize process with Legrand takes place using your client web browser and Legrand will have to know the right URL to your openHAB server for the authorization to be completed.\n+When you have authorized with Legrand, this Redirect URI is where authorization tokens for your openHAB BTicino Smarther Brigde will be sent and they have to be received by the servlet on `/bticinosmarther/connectsmarther`.\n+\n+![Application 1](doc/images/application-1.png)\n+\n+On Step 2, please make sure to select both `comfort.read` and `comfort.write` scopes, as they're mandatory for the binding to work.\n+\n+![Application 2](doc/images/application-2.png)\n+\n+Usually, Step 3 is then completed by Legrand within 1-2 days and you'll receive an email containing your application's Client ID and Client Secret.\n+\n+### Note on notifications\n+\n+If you want to later receive push notifications (device status) from Legrand for this application, you must have your openHAB server reachable from a public IP/address and use the related public IP/address and public port when filling-in the \"Reply URL\" field in Step 1.\n+\n+## Configure the binding\n+\n+1. Install the binding and make sure the _BTicino Smarther Binding_ is listed on your server.\n+2. Complete the _Create an account_ and _Create an application_ steps if you have not already done so (see above).\n+3. Make sure you have your Legrand account _Primary Key_ and your Legrand application _Client ID_ and _Client Secret_ identities available.\n+4. Go to your preferred openHAB admin UI and add a new Thing - select the **\"BTicino Smarther Bridge\"**.\n+5. Choose new Id for the bridge, unless you like the generated one.\n+6. Put in your _Primary Key_ (in _Subscription Key_ field), _Client ID_ and _Cliend Secret_ in their respective fields of the bridge configuration.\n+7. Set _Use Notifications_ to `ON` if your openHAB server is reachable from a public https URL (see [Note on notifications](#note-on-notifications)), set `OFF` otherwise.\n+8. You can leave the _Bridge Status Refresh Period_ as is.\n+9. Save the bridge.\n+10. The bridge thing will stay in state _INITIALIZING_ and eventually go _OFFLINE_ - this is fine, as you now have to authorize this bridge with Legrand.\n+11. Go to the authorization page of your server (see [Create an application](#create-an-application)) `http://<your openHAB address>:<your openHAB port>/bticinosmarther/connectsmarther`; your newly added bridge should be listed there (along with the available locations).\n+12. Press the _\"Authorize Bridge\"_ button; this will take you either to the login page of Legrand portal or directly to the authorization screen.\n+13. Login and/or authorize the application; if the Reply URL is correct you will be returned and the entry should show your bridge is authorized with your Client ID; otherwise, go back to your application configuration on Legrand portal and ensure you have set the right Reply URL (see [Troubleshooting](#troubleshooting) below).\n+14. The binding will be updated with a refresh token and go _ONLINE_ (the refresh token is used to re-authorize the bridge with Legrand Smarther API whenever required).\n+\n+![Tutorial 1](doc/images/tutorial-1.png)\n+\n+![Tutorial 2](doc/images/tutorial-2.png)\n+\n+![Tutorial 3](doc/images/tutorial-3.png)\n+\n+Now that you have got your bridge _ONLINE_ it is time to discover your devices! Go to Paper UI Inbox and search for **\"BTicino Smarther Chronothermostat\"** things.\n+Any BTicino Smarther Chronothermostat device currently available on your account should show up immediately.\n+\n+If no devices show up you may have to trigger the openHAB discovery several times as bridge will only find active devices known by the Smarther API at the time the discovery is triggered.\n+\n+Should the bridge configuration be broken for any reason, the authorization procedure can be reinitiated from step 11 whenever required.\n+You can force reinitialization by authorizing again on the `/bticinosmarther/connectsmarther` page, even if the page shows it as already authorized. This will reset the refresh token.\n+\n+The following configuration options are available on the BTicino Smarther Bridge thing:\n+\n+| Parameter             | Description                                                                                                                                        | Condition |\n+|-----------------------|----------------------------------------------------------------------------------------------------------------------------------------------------|-----------|\n+| subscriptionKey       | This is the Primary Key provided by Legrand when you create a new Account and subscribe to a product                                               | Required  |\n+| clientId              | This is the Client ID provided by Legrand when you add a new Application for openHAB to your Legrand account                                       | Required  |\n+| clientSecret          | This is the Client Secret provided by Legrand when you add a new Application for openHAB to your Legrand account                                   | Required  |\n+| useNotifications      | ON = the bridge subscribes to receive push notifications on devices status change; OFF = status updates are requested (pull) on a periodical basis |           |\n+| statusRefreshPeriod   | This is the frequency of the polling requests to the Smarther API to update the bridge status (in minutes)                                         |           |\n+\n+The following configuration options are available on the BTicino Smarther Chronothermostat thing:\n+\n+| Parameter             | Description                                                                                                                                        | Condition |\n+|-----------------------|----------------------------------------------------------------------------------------------------------------------------------------------------|-----------|\n+| plantId               | This is the Plant Id of the location the Chronothermostat module is installed in, provided by Smarther API                                         | Read-only |\n+| moduleId              | This is the Module Id of the Chronothermostat module, provided by Smarther API                                                                     | Read-only |\n+| settingsAutoupdate    | ON = the thermostat settings are aligned with current status whenever it changes; OFF = settings are aligned to status only upon initialization    |           |\n+| programsRefreshPeriod | This is the frequency the Smarther API gateway is called to refresh Programs list used in \"automatic\" mode (in hours)                              |           |\n+| numberOfEndDays       | This is the number of days to be displayed in module settings, as options list for \"End Date\" field in \"manual\" mode                               |           |\n+| statusRefreshPeriod   | This is the frequency of the polling requests to the Smarther API to update the module status and sensor data (in minutes)                         |           |\n+\n+## Troubleshooting\n+\n+When configuring the binding (see step 13 [here](#configure-the-binding)), you can receive the following error from Legrand portal:\n+\n+```\n+{\n+  \"error\": \"invalid_request\",\n+  \"error_description\": \"The reply url host xxxxx doesn't match with the ones configured on the application\"\n+}\n+```\n+\n+This means you've either opened the `/bticinosmarther/connectsmarther` page from the wrong address or set the wrong \"Reply URL\" attribute in your application (see step 1 [here](#create-an-application)).\n+Please remember these two strings must match for authentication process to work.\n+\n+To solve the issue, either:\n+\n+* Correct the address you're accessing the `/bticinosmarther/connectsmarther` page from, to match the \"Reply URL\" attribute registered in your application, or\n+* Should you have specified a wrong \"Reply URL\" attribute in your application, go to the Legrand portal and correct it accordingly then resubmit the application for approval.\n+\n+## Supported Things\n+\n+All BTicino Smarther Chronothermostat device models should be discoverable through this binding:\n+\n+* Flush mounting installation item (X8000)\n+* Wall installation item (X8000W)\n+\n+If you can control them from BTicino Thermostat mobile app on your iPhone/Android you should be able to add it as a thing.\n+\n+## Discovery\n+\n+As long as BTicino Smarther Chronothermostat devices are available in the locations registered on the user account configured with the bridge they should show up whenever you initiate discovery of things.\n+\n+If no devices are showing up, try to connect to the device(s) from your smartphone to make sure the device(s) are in use by your user account.\n+\n+The discovery of devices in the Smarther API is based on what is known by Legrand.\n+There is difference between e.g. smartphones and computers which can discover devices on the local network and the Smarther API which is not able to do so; it only knows about a device if your account is currently associated with the device.\n+\n+## Channels\n+\n+### Bridge\n+\n+The channels on the bridge are the ones used to get details of current communication with Smarther API on the Legrand account associated with the bridge.\n+\n+**Status Channels:**\n+\n+The following channels represent the current operational status of the bridge and must all be referenced with the `status#` prefix.\n+\n+| Channel Type ID   | Item Type            | Read/Write | Description                                                                            | Type     |\n+|-------------------|----------------------|------------|----------------------------------------------------------------------------------------|----------|\n+| apiCallsHandled   | Number               | Read-only  | The total number of API calls handled by the bridge                                    | Common   |\n+| notifsReceived    | Number               | Read-only  | The total number of push notifications received by the bridge                          | Common   |\n+| notifsRejected    | Number               | Read-only  | The total number of push notifications rejected by the bridge                          | Common   |\n+\n+**Configuration Channels:**\n+\n+The following channels represent convenience configuration channels for the bridge and must all be referenced with the `config#` prefix.\n+\n+| Channel Type ID   | Item Type            | Read/Write | Description                                                                            | Type     |\n+|-------------------|----------------------|------------|----------------------------------------------------------------------------------------|----------|\n+| fetchConfig       | Switch               | Read-write | Trigger to manually fetch updated bridge configuration from Smarther API               | Advanced |\n+| accessToken       | String               | Read-only  | The current accessToken used in communication with Smarther API                        | Advanced |\n+\n+### Devices\n+\n+The temperature channels have dimension `Number:Temperature` and a precision of one tenth degree Celsius.\n+\n+**Measures Channels:**\n+\n+The following channels represent the measures taken from the module on-board sensors and must all be referenced with the `measures#` prefix.\n+\n+| Channel Type ID   | Item Type            | Read/Write | Description                                                                            | Type     |\n+|-------------------|----------------------|------------|----------------------------------------------------------------------------------------|----------|\n+| temperature       | Number:Temperature   | Read-only  | Indoor temperature as measured by the sensor                                           | Common   |\n+| humidity          | Number:Dimensionless | Read-only  | Indoor humidity as measured by the sensor (in percentage)                              | Common   |\n+\n+**Status Channels:**\n+\n+The following channels represent the current operational status of the module and must all be referenced with the `status#` prefix.\n+\n+| Channel Type ID   | Item Type            | Read/Write | Description                                                                            | Type     |\n+|-------------------|----------------------|------------|----------------------------------------------------------------------------------------|----------|\n+| state             | Switch               | Read-only  | Current operational state of the module                                                | Common   |\n+| function          | String               | Read-only  | Current operational function set on the module (HEATING, COOLING)                      | Advanced |\n+| mode              | String               | Read-only  | Current operational mode set on the module (AUTOMATIC, MANUAL, BOOST, OFF, PROTECTION) | Common   |\n+| temperature       | Number:Temperature   | Read-only  | Current operational target temperature set on the module                               | Common   |\n+| program           | String               | Read-only  | Current operational program set on the module (valid only for \"Automatic\" mode)        | Common   |\n+| endTime           | String               | Read-only  | Current operational end time set on the module                                         | Common   |\n+| temperatureFormat | String               | Read-only  | Current operational temperature format of the module                                   | Advanced |\n+\n+**Settings Channels:**\n+\n+The following channels represent the new operational settings to be applied to the module and must all be referenced with the `settings#` prefix.\n+\n+| Channel Type ID   | Item Type            | Read/Write | Description                                                                            | Type     |\n+|-------------------|----------------------|------------|----------------------------------------------------------------------------------------|----------|\n+| mode              | String               | Read-write | New operational mode to be set (AUTOMATIC, MANUAL, BOOST, OFF, PROTECTION)             | Common   |\n+| temperature       | Number:Temperature   | Read-write | New operational set-point temperature to be set (valid only for \"Manual\" mode)         | Common   |\n+| program           | Number               | Read-write | New operational program to be set (valid only for \"Automatic\" mode)                    | Common   |\n+| boostTime         | Number               | Read-write | New operational boost time to be set (valid only for \"Boost\" mode)                     | Common   |\n+| endDate           | String               | Read-write | New operational end date to be set (valid only for \"Manual\" mode)                      | Common   |\n+| endHour           | Number               | Read-write | New operational end hour to be set (valid only for \"Manual\" mode)                      | Common   |\n+| endMinute         | Number               | Read-write | New operational end minute to be set (valid only for \"Manual\" mode)                    | Common   |\n+| power             | Switch               | Read-write | Power on, send new operational settings to the module                                  | Common   |\n+\n+_**Note:**_ The `program` and `endDate` channels are Selection channels.\n+They are dynamically populated by the binding, respectively with the module specific set programs and the next N days (starting from _\"Today\"_, N driven by the `numberOfEndDays` device configuration option).\n+\n+**Configuration Channels:**\n+\n+The following channels represent convenience configuration channels for the module and must all be referenced with the `config#` prefix.\n+\n+| Channel Type ID   | Item Type            | Read/Write | Description                                                                            | Type     |\n+|-------------------|----------------------|------------|----------------------------------------------------------------------------------------|----------|\n+| fetchConfig       | Switch               | Read-write | Trigger to manually fetch updated bridge configuration from Smarther API               | Advanced |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8bf252fdee587dc75178246537db8bfe456faba2"}, "originalPosition": 220}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE4OTEzNA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Each bridge registers himself to the queue, takes care of incoming notifications on behalf of its managed devices and dispatches each payload to the related device.\n          \n          \n            \n            Each bridge registers itself to the queue, takes care of incoming notifications on behalf of its managed devices and dispatches each payload to the related device.", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r445189134", "createdAt": "2020-06-24T21:44:17Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.bticinosmarther/README.md", "diffHunk": "@@ -0,0 +1,328 @@\n+# BTicino Smarther Binding\n+\n+The Smarther binding implements a bridge to the Legrand/BTicino Smarther v2.0 API and allows you to control your BTicino Smarther chronothermostat units with openHAB, making it possible to discover Smarther units connected to your Legrand/BTicino Smarther account.\n+\n+Smarther chronothermostat is produced by BTicino (https://www.bticino.com/products-catalogue/smarther-the-connected-thermostat/), has its own API set and doesn't support the OpenWebNet protocol.\n+\n+Companion HABPanel widget can be found here: [BTicino Smarther HABPanel widget](https://github.com/MrRonfo/openhab-smarther-widget)\n+\n+# Configuring the binding\n+\n+The binding requires you to register an Application with Legrand Developer portal at https://developer.legrand.com\n+This will get you a set of Client ID and Client Secret parameters to be used by your binding configuration.\n+\n+Optionally, if you want to later receive push notifications on the status of your units, consider to make your openHAB installation reachable in https from a public IP or domain (see [Note on notifications](#note-on-notifications)).\n+\n+## Create an account\n+\n+Follow the instructions in the tutorial at https://developer.legrand.com/tutorials/getting-started/, under: \n+\n+* Step 1 : Create an account\n+* Step 2 : Subscribe to a product and get subscription key\n+\n+There's also a Step 3 in this tutorial, you can skip it as not needed to complete this process.\n+Simply write down your \"Primary Key\" as it will be needed later on in the setup.\n+\n+## Create an application\n+\n+Follow the instructions in the tutorial at https://developer.legrand.com/tutorials/create-an-application/, under: \n+\n+* Step 1 : Register your application\n+* Step 2 : Check scopes\n+* Step 3 : Getting application details\n+\n+When registering your new Legrand Application for openHAB BTicino Smarther Bridge you have to specify the allowed Reply URL, aka white-listed address.\n+Here you have to specify the URL to the Bridge Authorization page on your server.\n+\n+For example if you run your openHAB server on http://openhabianpi:8080 you should set `http://openhabianpi:8080/bticinosmarther/connectsmarther` as the \"First Reply URL\" required field in Step 1.\n+Other Reply URLs (second, third, etc.) you can leave them blank.\n+\n+This is **very important** since the authorize process with Legrand takes place using your client web browser and Legrand will have to know the right URL to your openHAB server for the authorization to be completed.\n+When you have authorized with Legrand, this Redirect URI is where authorization tokens for your openHAB BTicino Smarther Brigde will be sent and they have to be received by the servlet on `/bticinosmarther/connectsmarther`.\n+\n+![Application 1](doc/images/application-1.png)\n+\n+On Step 2, please make sure to select both `comfort.read` and `comfort.write` scopes, as they're mandatory for the binding to work.\n+\n+![Application 2](doc/images/application-2.png)\n+\n+Usually, Step 3 is then completed by Legrand within 1-2 days and you'll receive an email containing your application's Client ID and Client Secret.\n+\n+### Note on notifications\n+\n+If you want to later receive push notifications (device status) from Legrand for this application, you must have your openHAB server reachable from a public IP/address and use the related public IP/address and public port when filling-in the \"Reply URL\" field in Step 1.\n+\n+## Configure the binding\n+\n+1. Install the binding and make sure the _BTicino Smarther Binding_ is listed on your server.\n+2. Complete the _Create an account_ and _Create an application_ steps if you have not already done so (see above).\n+3. Make sure you have your Legrand account _Primary Key_ and your Legrand application _Client ID_ and _Client Secret_ identities available.\n+4. Go to your preferred openHAB admin UI and add a new Thing - select the **\"BTicino Smarther Bridge\"**.\n+5. Choose new Id for the bridge, unless you like the generated one.\n+6. Put in your _Primary Key_ (in _Subscription Key_ field), _Client ID_ and _Cliend Secret_ in their respective fields of the bridge configuration.\n+7. Set _Use Notifications_ to `ON` if your openHAB server is reachable from a public https URL (see [Note on notifications](#note-on-notifications)), set `OFF` otherwise.\n+8. You can leave the _Bridge Status Refresh Period_ as is.\n+9. Save the bridge.\n+10. The bridge thing will stay in state _INITIALIZING_ and eventually go _OFFLINE_ - this is fine, as you now have to authorize this bridge with Legrand.\n+11. Go to the authorization page of your server (see [Create an application](#create-an-application)) `http://<your openHAB address>:<your openHAB port>/bticinosmarther/connectsmarther`; your newly added bridge should be listed there (along with the available locations).\n+12. Press the _\"Authorize Bridge\"_ button; this will take you either to the login page of Legrand portal or directly to the authorization screen.\n+13. Login and/or authorize the application; if the Reply URL is correct you will be returned and the entry should show your bridge is authorized with your Client ID; otherwise, go back to your application configuration on Legrand portal and ensure you have set the right Reply URL (see [Troubleshooting](#troubleshooting) below).\n+14. The binding will be updated with a refresh token and go _ONLINE_ (the refresh token is used to re-authorize the bridge with Legrand Smarther API whenever required).\n+\n+![Tutorial 1](doc/images/tutorial-1.png)\n+\n+![Tutorial 2](doc/images/tutorial-2.png)\n+\n+![Tutorial 3](doc/images/tutorial-3.png)\n+\n+Now that you have got your bridge _ONLINE_ it is time to discover your devices! Go to Paper UI Inbox and search for **\"BTicino Smarther Chronothermostat\"** things.\n+Any BTicino Smarther Chronothermostat device currently available on your account should show up immediately.\n+\n+If no devices show up you may have to trigger the openHAB discovery several times as bridge will only find active devices known by the Smarther API at the time the discovery is triggered.\n+\n+Should the bridge configuration be broken for any reason, the authorization procedure can be reinitiated from step 11 whenever required.\n+You can force reinitialization by authorizing again on the `/bticinosmarther/connectsmarther` page, even if the page shows it as already authorized. This will reset the refresh token.\n+\n+The following configuration options are available on the BTicino Smarther Bridge thing:\n+\n+| Parameter             | Description                                                                                                                                        | Condition |\n+|-----------------------|----------------------------------------------------------------------------------------------------------------------------------------------------|-----------|\n+| subscriptionKey       | This is the Primary Key provided by Legrand when you create a new Account and subscribe to a product                                               | Required  |\n+| clientId              | This is the Client ID provided by Legrand when you add a new Application for openHAB to your Legrand account                                       | Required  |\n+| clientSecret          | This is the Client Secret provided by Legrand when you add a new Application for openHAB to your Legrand account                                   | Required  |\n+| useNotifications      | ON = the bridge subscribes to receive push notifications on devices status change; OFF = status updates are requested (pull) on a periodical basis |           |\n+| statusRefreshPeriod   | This is the frequency of the polling requests to the Smarther API to update the bridge status (in minutes)                                         |           |\n+\n+The following configuration options are available on the BTicino Smarther Chronothermostat thing:\n+\n+| Parameter             | Description                                                                                                                                        | Condition |\n+|-----------------------|----------------------------------------------------------------------------------------------------------------------------------------------------|-----------|\n+| plantId               | This is the Plant Id of the location the Chronothermostat module is installed in, provided by Smarther API                                         | Read-only |\n+| moduleId              | This is the Module Id of the Chronothermostat module, provided by Smarther API                                                                     | Read-only |\n+| settingsAutoupdate    | ON = the thermostat settings are aligned with current status whenever it changes; OFF = settings are aligned to status only upon initialization    |           |\n+| programsRefreshPeriod | This is the frequency the Smarther API gateway is called to refresh Programs list used in \"automatic\" mode (in hours)                              |           |\n+| numberOfEndDays       | This is the number of days to be displayed in module settings, as options list for \"End Date\" field in \"manual\" mode                               |           |\n+| statusRefreshPeriod   | This is the frequency of the polling requests to the Smarther API to update the module status and sensor data (in minutes)                         |           |\n+\n+## Troubleshooting\n+\n+When configuring the binding (see step 13 [here](#configure-the-binding)), you can receive the following error from Legrand portal:\n+\n+```\n+{\n+  \"error\": \"invalid_request\",\n+  \"error_description\": \"The reply url host xxxxx doesn't match with the ones configured on the application\"\n+}\n+```\n+\n+This means you've either opened the `/bticinosmarther/connectsmarther` page from the wrong address or set the wrong \"Reply URL\" attribute in your application (see step 1 [here](#create-an-application)).\n+Please remember these two strings must match for authentication process to work.\n+\n+To solve the issue, either:\n+\n+* Correct the address you're accessing the `/bticinosmarther/connectsmarther` page from, to match the \"Reply URL\" attribute registered in your application, or\n+* Should you have specified a wrong \"Reply URL\" attribute in your application, go to the Legrand portal and correct it accordingly then resubmit the application for approval.\n+\n+## Supported Things\n+\n+All BTicino Smarther Chronothermostat device models should be discoverable through this binding:\n+\n+* Flush mounting installation item (X8000)\n+* Wall installation item (X8000W)\n+\n+If you can control them from BTicino Thermostat mobile app on your iPhone/Android you should be able to add it as a thing.\n+\n+## Discovery\n+\n+As long as BTicino Smarther Chronothermostat devices are available in the locations registered on the user account configured with the bridge they should show up whenever you initiate discovery of things.\n+\n+If no devices are showing up, try to connect to the device(s) from your smartphone to make sure the device(s) are in use by your user account.\n+\n+The discovery of devices in the Smarther API is based on what is known by Legrand.\n+There is difference between e.g. smartphones and computers which can discover devices on the local network and the Smarther API which is not able to do so; it only knows about a device if your account is currently associated with the device.\n+\n+## Channels\n+\n+### Bridge\n+\n+The channels on the bridge are the ones used to get details of current communication with Smarther API on the Legrand account associated with the bridge.\n+\n+**Status Channels:**\n+\n+The following channels represent the current operational status of the bridge and must all be referenced with the `status#` prefix.\n+\n+| Channel Type ID   | Item Type            | Read/Write | Description                                                                            | Type     |\n+|-------------------|----------------------|------------|----------------------------------------------------------------------------------------|----------|\n+| apiCallsHandled   | Number               | Read-only  | The total number of API calls handled by the bridge                                    | Common   |\n+| notifsReceived    | Number               | Read-only  | The total number of push notifications received by the bridge                          | Common   |\n+| notifsRejected    | Number               | Read-only  | The total number of push notifications rejected by the bridge                          | Common   |\n+\n+**Configuration Channels:**\n+\n+The following channels represent convenience configuration channels for the bridge and must all be referenced with the `config#` prefix.\n+\n+| Channel Type ID   | Item Type            | Read/Write | Description                                                                            | Type     |\n+|-------------------|----------------------|------------|----------------------------------------------------------------------------------------|----------|\n+| fetchConfig       | Switch               | Read-write | Trigger to manually fetch updated bridge configuration from Smarther API               | Advanced |\n+| accessToken       | String               | Read-only  | The current accessToken used in communication with Smarther API                        | Advanced |\n+\n+### Devices\n+\n+The temperature channels have dimension `Number:Temperature` and a precision of one tenth degree Celsius.\n+\n+**Measures Channels:**\n+\n+The following channels represent the measures taken from the module on-board sensors and must all be referenced with the `measures#` prefix.\n+\n+| Channel Type ID   | Item Type            | Read/Write | Description                                                                            | Type     |\n+|-------------------|----------------------|------------|----------------------------------------------------------------------------------------|----------|\n+| temperature       | Number:Temperature   | Read-only  | Indoor temperature as measured by the sensor                                           | Common   |\n+| humidity          | Number:Dimensionless | Read-only  | Indoor humidity as measured by the sensor (in percentage)                              | Common   |\n+\n+**Status Channels:**\n+\n+The following channels represent the current operational status of the module and must all be referenced with the `status#` prefix.\n+\n+| Channel Type ID   | Item Type            | Read/Write | Description                                                                            | Type     |\n+|-------------------|----------------------|------------|----------------------------------------------------------------------------------------|----------|\n+| state             | Switch               | Read-only  | Current operational state of the module                                                | Common   |\n+| function          | String               | Read-only  | Current operational function set on the module (HEATING, COOLING)                      | Advanced |\n+| mode              | String               | Read-only  | Current operational mode set on the module (AUTOMATIC, MANUAL, BOOST, OFF, PROTECTION) | Common   |\n+| temperature       | Number:Temperature   | Read-only  | Current operational target temperature set on the module                               | Common   |\n+| program           | String               | Read-only  | Current operational program set on the module (valid only for \"Automatic\" mode)        | Common   |\n+| endTime           | String               | Read-only  | Current operational end time set on the module                                         | Common   |\n+| temperatureFormat | String               | Read-only  | Current operational temperature format of the module                                   | Advanced |\n+\n+**Settings Channels:**\n+\n+The following channels represent the new operational settings to be applied to the module and must all be referenced with the `settings#` prefix.\n+\n+| Channel Type ID   | Item Type            | Read/Write | Description                                                                            | Type     |\n+|-------------------|----------------------|------------|----------------------------------------------------------------------------------------|----------|\n+| mode              | String               | Read-write | New operational mode to be set (AUTOMATIC, MANUAL, BOOST, OFF, PROTECTION)             | Common   |\n+| temperature       | Number:Temperature   | Read-write | New operational set-point temperature to be set (valid only for \"Manual\" mode)         | Common   |\n+| program           | Number               | Read-write | New operational program to be set (valid only for \"Automatic\" mode)                    | Common   |\n+| boostTime         | Number               | Read-write | New operational boost time to be set (valid only for \"Boost\" mode)                     | Common   |\n+| endDate           | String               | Read-write | New operational end date to be set (valid only for \"Manual\" mode)                      | Common   |\n+| endHour           | Number               | Read-write | New operational end hour to be set (valid only for \"Manual\" mode)                      | Common   |\n+| endMinute         | Number               | Read-write | New operational end minute to be set (valid only for \"Manual\" mode)                    | Common   |\n+| power             | Switch               | Read-write | Power on, send new operational settings to the module                                  | Common   |\n+\n+_**Note:**_ The `program` and `endDate` channels are Selection channels.\n+They are dynamically populated by the binding, respectively with the module specific set programs and the next N days (starting from _\"Today\"_, N driven by the `numberOfEndDays` device configuration option).\n+\n+**Configuration Channels:**\n+\n+The following channels represent convenience configuration channels for the module and must all be referenced with the `config#` prefix.\n+\n+| Channel Type ID   | Item Type            | Read/Write | Description                                                                            | Type     |\n+|-------------------|----------------------|------------|----------------------------------------------------------------------------------------|----------|\n+| fetchConfig       | Switch               | Read-write | Trigger to manually fetch updated bridge configuration from Smarther API               | Advanced |\n+\n+## Full Example\n+\n+In this example there is a bridge configured with Thing ID **mybridge**:\n+\n+bticinosmarther.things:\n+\n+```\n+Bridge bticinosmarther:bridge:mybridge \"BTicino Smarther Bridge\" [subscriptionKey=\"<your primary key>\" clientId=\"<your client id>\", clientSecret=\"<your client secret>\"] {\n+  Thing module thermo1 \"Thermo 1\" [plantId=\"<location plant id>\" moduleId=\"<chronothermostat module id>\"]\n+  Thing module thermo2 \"Thermo 2\" [plantId=\"<location plant id>\" moduleId=\"<chronothermostat module id>\"]\n+}\n+```\n+\n+bticinosmarther.items:\n+\n+```\n+// Measures items\n+Number:Temperature   smaTemperature \"In Temperature [%.1f %unit%]\"  { channel=\"bticinosmarther:module:mybridge:thermo1:measures#temperature\" }\n+Number:Dimensionless smaHumidity    \"In Humidity [%.1f %unit%]\"     { channel=\"bticinosmarther:module:mybridge:thermo1:measures#humidity\" }\n+\n+// Status items\n+Switch               smaCurState    \"Cur State [%s]\"                { channel=\"bticinosmarther:module:mybridge:thermo1:status#state\" }\n+String               smaCurMode     \"Cur Mode [%s]\"                 { channel=\"bticinosmarther:module:mybridge:thermo1:status#mode\" }\n+Number:Temperature   smaCurPoint    \"Cur Temperature [%.1f %unit%]\" { channel=\"bticinosmarther:module:mybridge:thermo1:status#temperature\" }\n+String               smaCurProgram  \"Cur Program [%s]\"              { channel=\"bticinosmarther:module:mybridge:thermo1:status#program\" }\n+String               smaCurTime     \"Cur Timer [%s]\"                { channel=\"bticinosmarther:module:mybridge:thermo1:status#endTime\" }\n+\n+// Settings items\n+String               smaSetMode     \"Set Mode [%s]\"                 { channel=\"bticinosmarther:module:mybridge:thermo1:settings#mode\" }\n+Number:Temperature   smaSetPoint    \"Set Temperature [%.0f %unit%]\" { channel=\"bticinosmarther:module:mybridge:thermo1:settings#temperature\" }\n+Number               smaSetProgram  \"Set Program [%s]\"              { channel=\"bticinosmarther:module:mybridge:thermo1:settings#program\" }\n+Number               smaSetBoost    \"Set Boost Time []\"             { channel=\"bticinosmarther:module:mybridge:thermo1:settings#boostTime\" }\n+String               smaSetDate     \"Set End Date [%s]\"             { channel=\"bticinosmarther:module:mybridge:thermo1:settings#endDate\" }\n+Number               smaSetHour     \"Set End Hour [%02d:00]\"        { channel=\"bticinosmarther:module:mybridge:thermo1:settings#endHour\" }\n+Number               smaSetMinute   \"Set End Minute [hh:%02d]\"      { channel=\"bticinosmarther:module:mybridge:thermo1:settings#endMinute\" }\n+Switch               smaSetPower    \"Apply Changes\"                 { channel=\"bticinosmarther:module:mybridge:thermo1:settings#power\" }\n+\n+// Convenience items\n+Switch               smaDisplayTime\n+```\n+\n+bticinosmarther.sitemap:\n+\n+```\n+sitemap bticinosmarther label=\"BTicino Smarther Sitemap\" {\n+\n+  Frame label=\"Smarther Measures\" {\n+    Text item=smaTemperature\n+    Text item=smaHumidity\n+  }\n+\n+  Frame label=\"Smarther Status\" {\n+    Text item=smaCurState\n+    Text item=smaCurMode\n+    Text item=smaCurPoint\n+    Text item=smaCurProgram\n+    Text item=smaCurTime\n+  }\n+\n+  Frame label=\"Smarther Settings\" {\n+    Selection item=smaSetMode\n+    Selection item=smaSetProgram visibility=[smaSetMode==\"AUTOMATIC\"]\n+    Setpoint  item=smaSetPoint   minValue=7 maxValue=24 step=1 visibility=[smaSetMode==\"MANUAL\"]\n+    Selection item=smaSetDate    visibility=[smaSetMode==\"MANUAL\"]\n+    Setpoint  item=smaSetHour    minValue=0 maxValue=23 step=1 visibility=[smaDisplayTime==ON]\n+    Setpoint  item=smaSetMinute  minValue=0 maxValue=45 step=15 visibility=[smaDisplayTime==ON]\n+    Switch    item=smaSetBoost   mappings=[30=\"30'\", 60=\"60'\", 90=\"90'\"] visibility=[smaSetMode==\"BOOST\"]\n+    Switch    item=smaSetPower   mappings=[\"ON\"=\"Start\"]\n+  }\n+}\n+```\n+\n+bticinosmarther.rules:\n+\n+```\n+rule \"BTicino Smarther - Set time visibility flag\"\n+when\n+    Item smaSetMode received update or Item smaSetDate received update\n+then\n+    if (smaSetMode.state == \"MANUAL\" && smaSetDate.state != \"\") {\n+        smaDisplayTime.sendCommand(ON)\n+    }\n+    else {\n+        smaDisplayTime.sendCommand(OFF)\n+    }\n+end\n+```\n+\n+## Binding model and Smarther API\n+\n+The model of the binding is such that the bridge takes care of all the remote communications with the Smarther API in the context of a specific user.\n+All devices (chronothermostats modules) currently associated with the user account are available to control.\n+\n+Legrand/BTicino Smarther topology considers the following dimensions:\n+\n+* topology : is the whole network of devices associated with a user account\n+* plant    : is the location where a module is installed (0..N plants per topology)\n+* module   : is the chronothermostat installed in a location (0..N modules per location)\n+\n+You can add multiple bridges to allow controlling devices in the context of multiple Legrand user accounts.\n+\n+Legrand manages the push notifications on device status via MS Azure C2C queues.\n+Each bridge registers himself to the queue, takes care of incoming notifications on behalf of its managed devices and dispatches each payload to the related device.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8bf252fdee587dc75178246537db8bfe456faba2"}, "originalPosition": 324}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE4OTYxNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            At the time of writing, the binding supports Smarther API v2.0, the last version released by Legrand.\n          \n          \n            \n            The binding uses the [Smarther API v2.0](https://portal.developer.legrand.com/docs/services/smartherV2/operations/Chronothermostat-Measures).", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r445189615", "createdAt": "2020-06-24T21:45:25Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.bticinosmarther/README.md", "diffHunk": "@@ -0,0 +1,328 @@\n+# BTicino Smarther Binding\n+\n+The Smarther binding implements a bridge to the Legrand/BTicino Smarther v2.0 API and allows you to control your BTicino Smarther chronothermostat units with openHAB, making it possible to discover Smarther units connected to your Legrand/BTicino Smarther account.\n+\n+Smarther chronothermostat is produced by BTicino (https://www.bticino.com/products-catalogue/smarther-the-connected-thermostat/), has its own API set and doesn't support the OpenWebNet protocol.\n+\n+Companion HABPanel widget can be found here: [BTicino Smarther HABPanel widget](https://github.com/MrRonfo/openhab-smarther-widget)\n+\n+# Configuring the binding\n+\n+The binding requires you to register an Application with Legrand Developer portal at https://developer.legrand.com\n+This will get you a set of Client ID and Client Secret parameters to be used by your binding configuration.\n+\n+Optionally, if you want to later receive push notifications on the status of your units, consider to make your openHAB installation reachable in https from a public IP or domain (see [Note on notifications](#note-on-notifications)).\n+\n+## Create an account\n+\n+Follow the instructions in the tutorial at https://developer.legrand.com/tutorials/getting-started/, under: \n+\n+* Step 1 : Create an account\n+* Step 2 : Subscribe to a product and get subscription key\n+\n+There's also a Step 3 in this tutorial, you can skip it as not needed to complete this process.\n+Simply write down your \"Primary Key\" as it will be needed later on in the setup.\n+\n+## Create an application\n+\n+Follow the instructions in the tutorial at https://developer.legrand.com/tutorials/create-an-application/, under: \n+\n+* Step 1 : Register your application\n+* Step 2 : Check scopes\n+* Step 3 : Getting application details\n+\n+When registering your new Legrand Application for openHAB BTicino Smarther Bridge you have to specify the allowed Reply URL, aka white-listed address.\n+Here you have to specify the URL to the Bridge Authorization page on your server.\n+\n+For example if you run your openHAB server on http://openhabianpi:8080 you should set `http://openhabianpi:8080/bticinosmarther/connectsmarther` as the \"First Reply URL\" required field in Step 1.\n+Other Reply URLs (second, third, etc.) you can leave them blank.\n+\n+This is **very important** since the authorize process with Legrand takes place using your client web browser and Legrand will have to know the right URL to your openHAB server for the authorization to be completed.\n+When you have authorized with Legrand, this Redirect URI is where authorization tokens for your openHAB BTicino Smarther Brigde will be sent and they have to be received by the servlet on `/bticinosmarther/connectsmarther`.\n+\n+![Application 1](doc/images/application-1.png)\n+\n+On Step 2, please make sure to select both `comfort.read` and `comfort.write` scopes, as they're mandatory for the binding to work.\n+\n+![Application 2](doc/images/application-2.png)\n+\n+Usually, Step 3 is then completed by Legrand within 1-2 days and you'll receive an email containing your application's Client ID and Client Secret.\n+\n+### Note on notifications\n+\n+If you want to later receive push notifications (device status) from Legrand for this application, you must have your openHAB server reachable from a public IP/address and use the related public IP/address and public port when filling-in the \"Reply URL\" field in Step 1.\n+\n+## Configure the binding\n+\n+1. Install the binding and make sure the _BTicino Smarther Binding_ is listed on your server.\n+2. Complete the _Create an account_ and _Create an application_ steps if you have not already done so (see above).\n+3. Make sure you have your Legrand account _Primary Key_ and your Legrand application _Client ID_ and _Client Secret_ identities available.\n+4. Go to your preferred openHAB admin UI and add a new Thing - select the **\"BTicino Smarther Bridge\"**.\n+5. Choose new Id for the bridge, unless you like the generated one.\n+6. Put in your _Primary Key_ (in _Subscription Key_ field), _Client ID_ and _Cliend Secret_ in their respective fields of the bridge configuration.\n+7. Set _Use Notifications_ to `ON` if your openHAB server is reachable from a public https URL (see [Note on notifications](#note-on-notifications)), set `OFF` otherwise.\n+8. You can leave the _Bridge Status Refresh Period_ as is.\n+9. Save the bridge.\n+10. The bridge thing will stay in state _INITIALIZING_ and eventually go _OFFLINE_ - this is fine, as you now have to authorize this bridge with Legrand.\n+11. Go to the authorization page of your server (see [Create an application](#create-an-application)) `http://<your openHAB address>:<your openHAB port>/bticinosmarther/connectsmarther`; your newly added bridge should be listed there (along with the available locations).\n+12. Press the _\"Authorize Bridge\"_ button; this will take you either to the login page of Legrand portal or directly to the authorization screen.\n+13. Login and/or authorize the application; if the Reply URL is correct you will be returned and the entry should show your bridge is authorized with your Client ID; otherwise, go back to your application configuration on Legrand portal and ensure you have set the right Reply URL (see [Troubleshooting](#troubleshooting) below).\n+14. The binding will be updated with a refresh token and go _ONLINE_ (the refresh token is used to re-authorize the bridge with Legrand Smarther API whenever required).\n+\n+![Tutorial 1](doc/images/tutorial-1.png)\n+\n+![Tutorial 2](doc/images/tutorial-2.png)\n+\n+![Tutorial 3](doc/images/tutorial-3.png)\n+\n+Now that you have got your bridge _ONLINE_ it is time to discover your devices! Go to Paper UI Inbox and search for **\"BTicino Smarther Chronothermostat\"** things.\n+Any BTicino Smarther Chronothermostat device currently available on your account should show up immediately.\n+\n+If no devices show up you may have to trigger the openHAB discovery several times as bridge will only find active devices known by the Smarther API at the time the discovery is triggered.\n+\n+Should the bridge configuration be broken for any reason, the authorization procedure can be reinitiated from step 11 whenever required.\n+You can force reinitialization by authorizing again on the `/bticinosmarther/connectsmarther` page, even if the page shows it as already authorized. This will reset the refresh token.\n+\n+The following configuration options are available on the BTicino Smarther Bridge thing:\n+\n+| Parameter             | Description                                                                                                                                        | Condition |\n+|-----------------------|----------------------------------------------------------------------------------------------------------------------------------------------------|-----------|\n+| subscriptionKey       | This is the Primary Key provided by Legrand when you create a new Account and subscribe to a product                                               | Required  |\n+| clientId              | This is the Client ID provided by Legrand when you add a new Application for openHAB to your Legrand account                                       | Required  |\n+| clientSecret          | This is the Client Secret provided by Legrand when you add a new Application for openHAB to your Legrand account                                   | Required  |\n+| useNotifications      | ON = the bridge subscribes to receive push notifications on devices status change; OFF = status updates are requested (pull) on a periodical basis |           |\n+| statusRefreshPeriod   | This is the frequency of the polling requests to the Smarther API to update the bridge status (in minutes)                                         |           |\n+\n+The following configuration options are available on the BTicino Smarther Chronothermostat thing:\n+\n+| Parameter             | Description                                                                                                                                        | Condition |\n+|-----------------------|----------------------------------------------------------------------------------------------------------------------------------------------------|-----------|\n+| plantId               | This is the Plant Id of the location the Chronothermostat module is installed in, provided by Smarther API                                         | Read-only |\n+| moduleId              | This is the Module Id of the Chronothermostat module, provided by Smarther API                                                                     | Read-only |\n+| settingsAutoupdate    | ON = the thermostat settings are aligned with current status whenever it changes; OFF = settings are aligned to status only upon initialization    |           |\n+| programsRefreshPeriod | This is the frequency the Smarther API gateway is called to refresh Programs list used in \"automatic\" mode (in hours)                              |           |\n+| numberOfEndDays       | This is the number of days to be displayed in module settings, as options list for \"End Date\" field in \"manual\" mode                               |           |\n+| statusRefreshPeriod   | This is the frequency of the polling requests to the Smarther API to update the module status and sensor data (in minutes)                         |           |\n+\n+## Troubleshooting\n+\n+When configuring the binding (see step 13 [here](#configure-the-binding)), you can receive the following error from Legrand portal:\n+\n+```\n+{\n+  \"error\": \"invalid_request\",\n+  \"error_description\": \"The reply url host xxxxx doesn't match with the ones configured on the application\"\n+}\n+```\n+\n+This means you've either opened the `/bticinosmarther/connectsmarther` page from the wrong address or set the wrong \"Reply URL\" attribute in your application (see step 1 [here](#create-an-application)).\n+Please remember these two strings must match for authentication process to work.\n+\n+To solve the issue, either:\n+\n+* Correct the address you're accessing the `/bticinosmarther/connectsmarther` page from, to match the \"Reply URL\" attribute registered in your application, or\n+* Should you have specified a wrong \"Reply URL\" attribute in your application, go to the Legrand portal and correct it accordingly then resubmit the application for approval.\n+\n+## Supported Things\n+\n+All BTicino Smarther Chronothermostat device models should be discoverable through this binding:\n+\n+* Flush mounting installation item (X8000)\n+* Wall installation item (X8000W)\n+\n+If you can control them from BTicino Thermostat mobile app on your iPhone/Android you should be able to add it as a thing.\n+\n+## Discovery\n+\n+As long as BTicino Smarther Chronothermostat devices are available in the locations registered on the user account configured with the bridge they should show up whenever you initiate discovery of things.\n+\n+If no devices are showing up, try to connect to the device(s) from your smartphone to make sure the device(s) are in use by your user account.\n+\n+The discovery of devices in the Smarther API is based on what is known by Legrand.\n+There is difference between e.g. smartphones and computers which can discover devices on the local network and the Smarther API which is not able to do so; it only knows about a device if your account is currently associated with the device.\n+\n+## Channels\n+\n+### Bridge\n+\n+The channels on the bridge are the ones used to get details of current communication with Smarther API on the Legrand account associated with the bridge.\n+\n+**Status Channels:**\n+\n+The following channels represent the current operational status of the bridge and must all be referenced with the `status#` prefix.\n+\n+| Channel Type ID   | Item Type            | Read/Write | Description                                                                            | Type     |\n+|-------------------|----------------------|------------|----------------------------------------------------------------------------------------|----------|\n+| apiCallsHandled   | Number               | Read-only  | The total number of API calls handled by the bridge                                    | Common   |\n+| notifsReceived    | Number               | Read-only  | The total number of push notifications received by the bridge                          | Common   |\n+| notifsRejected    | Number               | Read-only  | The total number of push notifications rejected by the bridge                          | Common   |\n+\n+**Configuration Channels:**\n+\n+The following channels represent convenience configuration channels for the bridge and must all be referenced with the `config#` prefix.\n+\n+| Channel Type ID   | Item Type            | Read/Write | Description                                                                            | Type     |\n+|-------------------|----------------------|------------|----------------------------------------------------------------------------------------|----------|\n+| fetchConfig       | Switch               | Read-write | Trigger to manually fetch updated bridge configuration from Smarther API               | Advanced |\n+| accessToken       | String               | Read-only  | The current accessToken used in communication with Smarther API                        | Advanced |\n+\n+### Devices\n+\n+The temperature channels have dimension `Number:Temperature` and a precision of one tenth degree Celsius.\n+\n+**Measures Channels:**\n+\n+The following channels represent the measures taken from the module on-board sensors and must all be referenced with the `measures#` prefix.\n+\n+| Channel Type ID   | Item Type            | Read/Write | Description                                                                            | Type     |\n+|-------------------|----------------------|------------|----------------------------------------------------------------------------------------|----------|\n+| temperature       | Number:Temperature   | Read-only  | Indoor temperature as measured by the sensor                                           | Common   |\n+| humidity          | Number:Dimensionless | Read-only  | Indoor humidity as measured by the sensor (in percentage)                              | Common   |\n+\n+**Status Channels:**\n+\n+The following channels represent the current operational status of the module and must all be referenced with the `status#` prefix.\n+\n+| Channel Type ID   | Item Type            | Read/Write | Description                                                                            | Type     |\n+|-------------------|----------------------|------------|----------------------------------------------------------------------------------------|----------|\n+| state             | Switch               | Read-only  | Current operational state of the module                                                | Common   |\n+| function          | String               | Read-only  | Current operational function set on the module (HEATING, COOLING)                      | Advanced |\n+| mode              | String               | Read-only  | Current operational mode set on the module (AUTOMATIC, MANUAL, BOOST, OFF, PROTECTION) | Common   |\n+| temperature       | Number:Temperature   | Read-only  | Current operational target temperature set on the module                               | Common   |\n+| program           | String               | Read-only  | Current operational program set on the module (valid only for \"Automatic\" mode)        | Common   |\n+| endTime           | String               | Read-only  | Current operational end time set on the module                                         | Common   |\n+| temperatureFormat | String               | Read-only  | Current operational temperature format of the module                                   | Advanced |\n+\n+**Settings Channels:**\n+\n+The following channels represent the new operational settings to be applied to the module and must all be referenced with the `settings#` prefix.\n+\n+| Channel Type ID   | Item Type            | Read/Write | Description                                                                            | Type     |\n+|-------------------|----------------------|------------|----------------------------------------------------------------------------------------|----------|\n+| mode              | String               | Read-write | New operational mode to be set (AUTOMATIC, MANUAL, BOOST, OFF, PROTECTION)             | Common   |\n+| temperature       | Number:Temperature   | Read-write | New operational set-point temperature to be set (valid only for \"Manual\" mode)         | Common   |\n+| program           | Number               | Read-write | New operational program to be set (valid only for \"Automatic\" mode)                    | Common   |\n+| boostTime         | Number               | Read-write | New operational boost time to be set (valid only for \"Boost\" mode)                     | Common   |\n+| endDate           | String               | Read-write | New operational end date to be set (valid only for \"Manual\" mode)                      | Common   |\n+| endHour           | Number               | Read-write | New operational end hour to be set (valid only for \"Manual\" mode)                      | Common   |\n+| endMinute         | Number               | Read-write | New operational end minute to be set (valid only for \"Manual\" mode)                    | Common   |\n+| power             | Switch               | Read-write | Power on, send new operational settings to the module                                  | Common   |\n+\n+_**Note:**_ The `program` and `endDate` channels are Selection channels.\n+They are dynamically populated by the binding, respectively with the module specific set programs and the next N days (starting from _\"Today\"_, N driven by the `numberOfEndDays` device configuration option).\n+\n+**Configuration Channels:**\n+\n+The following channels represent convenience configuration channels for the module and must all be referenced with the `config#` prefix.\n+\n+| Channel Type ID   | Item Type            | Read/Write | Description                                                                            | Type     |\n+|-------------------|----------------------|------------|----------------------------------------------------------------------------------------|----------|\n+| fetchConfig       | Switch               | Read-write | Trigger to manually fetch updated bridge configuration from Smarther API               | Advanced |\n+\n+## Full Example\n+\n+In this example there is a bridge configured with Thing ID **mybridge**:\n+\n+bticinosmarther.things:\n+\n+```\n+Bridge bticinosmarther:bridge:mybridge \"BTicino Smarther Bridge\" [subscriptionKey=\"<your primary key>\" clientId=\"<your client id>\", clientSecret=\"<your client secret>\"] {\n+  Thing module thermo1 \"Thermo 1\" [plantId=\"<location plant id>\" moduleId=\"<chronothermostat module id>\"]\n+  Thing module thermo2 \"Thermo 2\" [plantId=\"<location plant id>\" moduleId=\"<chronothermostat module id>\"]\n+}\n+```\n+\n+bticinosmarther.items:\n+\n+```\n+// Measures items\n+Number:Temperature   smaTemperature \"In Temperature [%.1f %unit%]\"  { channel=\"bticinosmarther:module:mybridge:thermo1:measures#temperature\" }\n+Number:Dimensionless smaHumidity    \"In Humidity [%.1f %unit%]\"     { channel=\"bticinosmarther:module:mybridge:thermo1:measures#humidity\" }\n+\n+// Status items\n+Switch               smaCurState    \"Cur State [%s]\"                { channel=\"bticinosmarther:module:mybridge:thermo1:status#state\" }\n+String               smaCurMode     \"Cur Mode [%s]\"                 { channel=\"bticinosmarther:module:mybridge:thermo1:status#mode\" }\n+Number:Temperature   smaCurPoint    \"Cur Temperature [%.1f %unit%]\" { channel=\"bticinosmarther:module:mybridge:thermo1:status#temperature\" }\n+String               smaCurProgram  \"Cur Program [%s]\"              { channel=\"bticinosmarther:module:mybridge:thermo1:status#program\" }\n+String               smaCurTime     \"Cur Timer [%s]\"                { channel=\"bticinosmarther:module:mybridge:thermo1:status#endTime\" }\n+\n+// Settings items\n+String               smaSetMode     \"Set Mode [%s]\"                 { channel=\"bticinosmarther:module:mybridge:thermo1:settings#mode\" }\n+Number:Temperature   smaSetPoint    \"Set Temperature [%.0f %unit%]\" { channel=\"bticinosmarther:module:mybridge:thermo1:settings#temperature\" }\n+Number               smaSetProgram  \"Set Program [%s]\"              { channel=\"bticinosmarther:module:mybridge:thermo1:settings#program\" }\n+Number               smaSetBoost    \"Set Boost Time []\"             { channel=\"bticinosmarther:module:mybridge:thermo1:settings#boostTime\" }\n+String               smaSetDate     \"Set End Date [%s]\"             { channel=\"bticinosmarther:module:mybridge:thermo1:settings#endDate\" }\n+Number               smaSetHour     \"Set End Hour [%02d:00]\"        { channel=\"bticinosmarther:module:mybridge:thermo1:settings#endHour\" }\n+Number               smaSetMinute   \"Set End Minute [hh:%02d]\"      { channel=\"bticinosmarther:module:mybridge:thermo1:settings#endMinute\" }\n+Switch               smaSetPower    \"Apply Changes\"                 { channel=\"bticinosmarther:module:mybridge:thermo1:settings#power\" }\n+\n+// Convenience items\n+Switch               smaDisplayTime\n+```\n+\n+bticinosmarther.sitemap:\n+\n+```\n+sitemap bticinosmarther label=\"BTicino Smarther Sitemap\" {\n+\n+  Frame label=\"Smarther Measures\" {\n+    Text item=smaTemperature\n+    Text item=smaHumidity\n+  }\n+\n+  Frame label=\"Smarther Status\" {\n+    Text item=smaCurState\n+    Text item=smaCurMode\n+    Text item=smaCurPoint\n+    Text item=smaCurProgram\n+    Text item=smaCurTime\n+  }\n+\n+  Frame label=\"Smarther Settings\" {\n+    Selection item=smaSetMode\n+    Selection item=smaSetProgram visibility=[smaSetMode==\"AUTOMATIC\"]\n+    Setpoint  item=smaSetPoint   minValue=7 maxValue=24 step=1 visibility=[smaSetMode==\"MANUAL\"]\n+    Selection item=smaSetDate    visibility=[smaSetMode==\"MANUAL\"]\n+    Setpoint  item=smaSetHour    minValue=0 maxValue=23 step=1 visibility=[smaDisplayTime==ON]\n+    Setpoint  item=smaSetMinute  minValue=0 maxValue=45 step=15 visibility=[smaDisplayTime==ON]\n+    Switch    item=smaSetBoost   mappings=[30=\"30'\", 60=\"60'\", 90=\"90'\"] visibility=[smaSetMode==\"BOOST\"]\n+    Switch    item=smaSetPower   mappings=[\"ON\"=\"Start\"]\n+  }\n+}\n+```\n+\n+bticinosmarther.rules:\n+\n+```\n+rule \"BTicino Smarther - Set time visibility flag\"\n+when\n+    Item smaSetMode received update or Item smaSetDate received update\n+then\n+    if (smaSetMode.state == \"MANUAL\" && smaSetDate.state != \"\") {\n+        smaDisplayTime.sendCommand(ON)\n+    }\n+    else {\n+        smaDisplayTime.sendCommand(OFF)\n+    }\n+end\n+```\n+\n+## Binding model and Smarther API\n+\n+The model of the binding is such that the bridge takes care of all the remote communications with the Smarther API in the context of a specific user.\n+All devices (chronothermostats modules) currently associated with the user account are available to control.\n+\n+Legrand/BTicino Smarther topology considers the following dimensions:\n+\n+* topology : is the whole network of devices associated with a user account\n+* plant    : is the location where a module is installed (0..N plants per topology)\n+* module   : is the chronothermostat installed in a location (0..N modules per location)\n+\n+You can add multiple bridges to allow controlling devices in the context of multiple Legrand user accounts.\n+\n+Legrand manages the push notifications on device status via MS Azure C2C queues.\n+Each bridge registers himself to the queue, takes care of incoming notifications on behalf of its managed devices and dispatches each payload to the related device.\n+\n+At the time of writing, the binding supports Smarther API v2.0, the last version released by Legrand.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8bf252fdee587dc75178246537db8bfe456faba2"}, "originalPosition": 326}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE4OTcxOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The Smarther API and its documentation can be found at https://portal.developer.legrand.com/docs/services/smartherV2/operations/Chronothermostat-Measures.", "url": "https://github.com/openhab/openhab-addons/pull/7533#discussion_r445189719", "createdAt": "2020-06-24T21:45:39Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.bticinosmarther/README.md", "diffHunk": "@@ -0,0 +1,328 @@\n+# BTicino Smarther Binding\n+\n+The Smarther binding implements a bridge to the Legrand/BTicino Smarther v2.0 API and allows you to control your BTicino Smarther chronothermostat units with openHAB, making it possible to discover Smarther units connected to your Legrand/BTicino Smarther account.\n+\n+Smarther chronothermostat is produced by BTicino (https://www.bticino.com/products-catalogue/smarther-the-connected-thermostat/), has its own API set and doesn't support the OpenWebNet protocol.\n+\n+Companion HABPanel widget can be found here: [BTicino Smarther HABPanel widget](https://github.com/MrRonfo/openhab-smarther-widget)\n+\n+# Configuring the binding\n+\n+The binding requires you to register an Application with Legrand Developer portal at https://developer.legrand.com\n+This will get you a set of Client ID and Client Secret parameters to be used by your binding configuration.\n+\n+Optionally, if you want to later receive push notifications on the status of your units, consider to make your openHAB installation reachable in https from a public IP or domain (see [Note on notifications](#note-on-notifications)).\n+\n+## Create an account\n+\n+Follow the instructions in the tutorial at https://developer.legrand.com/tutorials/getting-started/, under: \n+\n+* Step 1 : Create an account\n+* Step 2 : Subscribe to a product and get subscription key\n+\n+There's also a Step 3 in this tutorial, you can skip it as not needed to complete this process.\n+Simply write down your \"Primary Key\" as it will be needed later on in the setup.\n+\n+## Create an application\n+\n+Follow the instructions in the tutorial at https://developer.legrand.com/tutorials/create-an-application/, under: \n+\n+* Step 1 : Register your application\n+* Step 2 : Check scopes\n+* Step 3 : Getting application details\n+\n+When registering your new Legrand Application for openHAB BTicino Smarther Bridge you have to specify the allowed Reply URL, aka white-listed address.\n+Here you have to specify the URL to the Bridge Authorization page on your server.\n+\n+For example if you run your openHAB server on http://openhabianpi:8080 you should set `http://openhabianpi:8080/bticinosmarther/connectsmarther` as the \"First Reply URL\" required field in Step 1.\n+Other Reply URLs (second, third, etc.) you can leave them blank.\n+\n+This is **very important** since the authorize process with Legrand takes place using your client web browser and Legrand will have to know the right URL to your openHAB server for the authorization to be completed.\n+When you have authorized with Legrand, this Redirect URI is where authorization tokens for your openHAB BTicino Smarther Brigde will be sent and they have to be received by the servlet on `/bticinosmarther/connectsmarther`.\n+\n+![Application 1](doc/images/application-1.png)\n+\n+On Step 2, please make sure to select both `comfort.read` and `comfort.write` scopes, as they're mandatory for the binding to work.\n+\n+![Application 2](doc/images/application-2.png)\n+\n+Usually, Step 3 is then completed by Legrand within 1-2 days and you'll receive an email containing your application's Client ID and Client Secret.\n+\n+### Note on notifications\n+\n+If you want to later receive push notifications (device status) from Legrand for this application, you must have your openHAB server reachable from a public IP/address and use the related public IP/address and public port when filling-in the \"Reply URL\" field in Step 1.\n+\n+## Configure the binding\n+\n+1. Install the binding and make sure the _BTicino Smarther Binding_ is listed on your server.\n+2. Complete the _Create an account_ and _Create an application_ steps if you have not already done so (see above).\n+3. Make sure you have your Legrand account _Primary Key_ and your Legrand application _Client ID_ and _Client Secret_ identities available.\n+4. Go to your preferred openHAB admin UI and add a new Thing - select the **\"BTicino Smarther Bridge\"**.\n+5. Choose new Id for the bridge, unless you like the generated one.\n+6. Put in your _Primary Key_ (in _Subscription Key_ field), _Client ID_ and _Cliend Secret_ in their respective fields of the bridge configuration.\n+7. Set _Use Notifications_ to `ON` if your openHAB server is reachable from a public https URL (see [Note on notifications](#note-on-notifications)), set `OFF` otherwise.\n+8. You can leave the _Bridge Status Refresh Period_ as is.\n+9. Save the bridge.\n+10. The bridge thing will stay in state _INITIALIZING_ and eventually go _OFFLINE_ - this is fine, as you now have to authorize this bridge with Legrand.\n+11. Go to the authorization page of your server (see [Create an application](#create-an-application)) `http://<your openHAB address>:<your openHAB port>/bticinosmarther/connectsmarther`; your newly added bridge should be listed there (along with the available locations).\n+12. Press the _\"Authorize Bridge\"_ button; this will take you either to the login page of Legrand portal or directly to the authorization screen.\n+13. Login and/or authorize the application; if the Reply URL is correct you will be returned and the entry should show your bridge is authorized with your Client ID; otherwise, go back to your application configuration on Legrand portal and ensure you have set the right Reply URL (see [Troubleshooting](#troubleshooting) below).\n+14. The binding will be updated with a refresh token and go _ONLINE_ (the refresh token is used to re-authorize the bridge with Legrand Smarther API whenever required).\n+\n+![Tutorial 1](doc/images/tutorial-1.png)\n+\n+![Tutorial 2](doc/images/tutorial-2.png)\n+\n+![Tutorial 3](doc/images/tutorial-3.png)\n+\n+Now that you have got your bridge _ONLINE_ it is time to discover your devices! Go to Paper UI Inbox and search for **\"BTicino Smarther Chronothermostat\"** things.\n+Any BTicino Smarther Chronothermostat device currently available on your account should show up immediately.\n+\n+If no devices show up you may have to trigger the openHAB discovery several times as bridge will only find active devices known by the Smarther API at the time the discovery is triggered.\n+\n+Should the bridge configuration be broken for any reason, the authorization procedure can be reinitiated from step 11 whenever required.\n+You can force reinitialization by authorizing again on the `/bticinosmarther/connectsmarther` page, even if the page shows it as already authorized. This will reset the refresh token.\n+\n+The following configuration options are available on the BTicino Smarther Bridge thing:\n+\n+| Parameter             | Description                                                                                                                                        | Condition |\n+|-----------------------|----------------------------------------------------------------------------------------------------------------------------------------------------|-----------|\n+| subscriptionKey       | This is the Primary Key provided by Legrand when you create a new Account and subscribe to a product                                               | Required  |\n+| clientId              | This is the Client ID provided by Legrand when you add a new Application for openHAB to your Legrand account                                       | Required  |\n+| clientSecret          | This is the Client Secret provided by Legrand when you add a new Application for openHAB to your Legrand account                                   | Required  |\n+| useNotifications      | ON = the bridge subscribes to receive push notifications on devices status change; OFF = status updates are requested (pull) on a periodical basis |           |\n+| statusRefreshPeriod   | This is the frequency of the polling requests to the Smarther API to update the bridge status (in minutes)                                         |           |\n+\n+The following configuration options are available on the BTicino Smarther Chronothermostat thing:\n+\n+| Parameter             | Description                                                                                                                                        | Condition |\n+|-----------------------|----------------------------------------------------------------------------------------------------------------------------------------------------|-----------|\n+| plantId               | This is the Plant Id of the location the Chronothermostat module is installed in, provided by Smarther API                                         | Read-only |\n+| moduleId              | This is the Module Id of the Chronothermostat module, provided by Smarther API                                                                     | Read-only |\n+| settingsAutoupdate    | ON = the thermostat settings are aligned with current status whenever it changes; OFF = settings are aligned to status only upon initialization    |           |\n+| programsRefreshPeriod | This is the frequency the Smarther API gateway is called to refresh Programs list used in \"automatic\" mode (in hours)                              |           |\n+| numberOfEndDays       | This is the number of days to be displayed in module settings, as options list for \"End Date\" field in \"manual\" mode                               |           |\n+| statusRefreshPeriod   | This is the frequency of the polling requests to the Smarther API to update the module status and sensor data (in minutes)                         |           |\n+\n+## Troubleshooting\n+\n+When configuring the binding (see step 13 [here](#configure-the-binding)), you can receive the following error from Legrand portal:\n+\n+```\n+{\n+  \"error\": \"invalid_request\",\n+  \"error_description\": \"The reply url host xxxxx doesn't match with the ones configured on the application\"\n+}\n+```\n+\n+This means you've either opened the `/bticinosmarther/connectsmarther` page from the wrong address or set the wrong \"Reply URL\" attribute in your application (see step 1 [here](#create-an-application)).\n+Please remember these two strings must match for authentication process to work.\n+\n+To solve the issue, either:\n+\n+* Correct the address you're accessing the `/bticinosmarther/connectsmarther` page from, to match the \"Reply URL\" attribute registered in your application, or\n+* Should you have specified a wrong \"Reply URL\" attribute in your application, go to the Legrand portal and correct it accordingly then resubmit the application for approval.\n+\n+## Supported Things\n+\n+All BTicino Smarther Chronothermostat device models should be discoverable through this binding:\n+\n+* Flush mounting installation item (X8000)\n+* Wall installation item (X8000W)\n+\n+If you can control them from BTicino Thermostat mobile app on your iPhone/Android you should be able to add it as a thing.\n+\n+## Discovery\n+\n+As long as BTicino Smarther Chronothermostat devices are available in the locations registered on the user account configured with the bridge they should show up whenever you initiate discovery of things.\n+\n+If no devices are showing up, try to connect to the device(s) from your smartphone to make sure the device(s) are in use by your user account.\n+\n+The discovery of devices in the Smarther API is based on what is known by Legrand.\n+There is difference between e.g. smartphones and computers which can discover devices on the local network and the Smarther API which is not able to do so; it only knows about a device if your account is currently associated with the device.\n+\n+## Channels\n+\n+### Bridge\n+\n+The channels on the bridge are the ones used to get details of current communication with Smarther API on the Legrand account associated with the bridge.\n+\n+**Status Channels:**\n+\n+The following channels represent the current operational status of the bridge and must all be referenced with the `status#` prefix.\n+\n+| Channel Type ID   | Item Type            | Read/Write | Description                                                                            | Type     |\n+|-------------------|----------------------|------------|----------------------------------------------------------------------------------------|----------|\n+| apiCallsHandled   | Number               | Read-only  | The total number of API calls handled by the bridge                                    | Common   |\n+| notifsReceived    | Number               | Read-only  | The total number of push notifications received by the bridge                          | Common   |\n+| notifsRejected    | Number               | Read-only  | The total number of push notifications rejected by the bridge                          | Common   |\n+\n+**Configuration Channels:**\n+\n+The following channels represent convenience configuration channels for the bridge and must all be referenced with the `config#` prefix.\n+\n+| Channel Type ID   | Item Type            | Read/Write | Description                                                                            | Type     |\n+|-------------------|----------------------|------------|----------------------------------------------------------------------------------------|----------|\n+| fetchConfig       | Switch               | Read-write | Trigger to manually fetch updated bridge configuration from Smarther API               | Advanced |\n+| accessToken       | String               | Read-only  | The current accessToken used in communication with Smarther API                        | Advanced |\n+\n+### Devices\n+\n+The temperature channels have dimension `Number:Temperature` and a precision of one tenth degree Celsius.\n+\n+**Measures Channels:**\n+\n+The following channels represent the measures taken from the module on-board sensors and must all be referenced with the `measures#` prefix.\n+\n+| Channel Type ID   | Item Type            | Read/Write | Description                                                                            | Type     |\n+|-------------------|----------------------|------------|----------------------------------------------------------------------------------------|----------|\n+| temperature       | Number:Temperature   | Read-only  | Indoor temperature as measured by the sensor                                           | Common   |\n+| humidity          | Number:Dimensionless | Read-only  | Indoor humidity as measured by the sensor (in percentage)                              | Common   |\n+\n+**Status Channels:**\n+\n+The following channels represent the current operational status of the module and must all be referenced with the `status#` prefix.\n+\n+| Channel Type ID   | Item Type            | Read/Write | Description                                                                            | Type     |\n+|-------------------|----------------------|------------|----------------------------------------------------------------------------------------|----------|\n+| state             | Switch               | Read-only  | Current operational state of the module                                                | Common   |\n+| function          | String               | Read-only  | Current operational function set on the module (HEATING, COOLING)                      | Advanced |\n+| mode              | String               | Read-only  | Current operational mode set on the module (AUTOMATIC, MANUAL, BOOST, OFF, PROTECTION) | Common   |\n+| temperature       | Number:Temperature   | Read-only  | Current operational target temperature set on the module                               | Common   |\n+| program           | String               | Read-only  | Current operational program set on the module (valid only for \"Automatic\" mode)        | Common   |\n+| endTime           | String               | Read-only  | Current operational end time set on the module                                         | Common   |\n+| temperatureFormat | String               | Read-only  | Current operational temperature format of the module                                   | Advanced |\n+\n+**Settings Channels:**\n+\n+The following channels represent the new operational settings to be applied to the module and must all be referenced with the `settings#` prefix.\n+\n+| Channel Type ID   | Item Type            | Read/Write | Description                                                                            | Type     |\n+|-------------------|----------------------|------------|----------------------------------------------------------------------------------------|----------|\n+| mode              | String               | Read-write | New operational mode to be set (AUTOMATIC, MANUAL, BOOST, OFF, PROTECTION)             | Common   |\n+| temperature       | Number:Temperature   | Read-write | New operational set-point temperature to be set (valid only for \"Manual\" mode)         | Common   |\n+| program           | Number               | Read-write | New operational program to be set (valid only for \"Automatic\" mode)                    | Common   |\n+| boostTime         | Number               | Read-write | New operational boost time to be set (valid only for \"Boost\" mode)                     | Common   |\n+| endDate           | String               | Read-write | New operational end date to be set (valid only for \"Manual\" mode)                      | Common   |\n+| endHour           | Number               | Read-write | New operational end hour to be set (valid only for \"Manual\" mode)                      | Common   |\n+| endMinute         | Number               | Read-write | New operational end minute to be set (valid only for \"Manual\" mode)                    | Common   |\n+| power             | Switch               | Read-write | Power on, send new operational settings to the module                                  | Common   |\n+\n+_**Note:**_ The `program` and `endDate` channels are Selection channels.\n+They are dynamically populated by the binding, respectively with the module specific set programs and the next N days (starting from _\"Today\"_, N driven by the `numberOfEndDays` device configuration option).\n+\n+**Configuration Channels:**\n+\n+The following channels represent convenience configuration channels for the module and must all be referenced with the `config#` prefix.\n+\n+| Channel Type ID   | Item Type            | Read/Write | Description                                                                            | Type     |\n+|-------------------|----------------------|------------|----------------------------------------------------------------------------------------|----------|\n+| fetchConfig       | Switch               | Read-write | Trigger to manually fetch updated bridge configuration from Smarther API               | Advanced |\n+\n+## Full Example\n+\n+In this example there is a bridge configured with Thing ID **mybridge**:\n+\n+bticinosmarther.things:\n+\n+```\n+Bridge bticinosmarther:bridge:mybridge \"BTicino Smarther Bridge\" [subscriptionKey=\"<your primary key>\" clientId=\"<your client id>\", clientSecret=\"<your client secret>\"] {\n+  Thing module thermo1 \"Thermo 1\" [plantId=\"<location plant id>\" moduleId=\"<chronothermostat module id>\"]\n+  Thing module thermo2 \"Thermo 2\" [plantId=\"<location plant id>\" moduleId=\"<chronothermostat module id>\"]\n+}\n+```\n+\n+bticinosmarther.items:\n+\n+```\n+// Measures items\n+Number:Temperature   smaTemperature \"In Temperature [%.1f %unit%]\"  { channel=\"bticinosmarther:module:mybridge:thermo1:measures#temperature\" }\n+Number:Dimensionless smaHumidity    \"In Humidity [%.1f %unit%]\"     { channel=\"bticinosmarther:module:mybridge:thermo1:measures#humidity\" }\n+\n+// Status items\n+Switch               smaCurState    \"Cur State [%s]\"                { channel=\"bticinosmarther:module:mybridge:thermo1:status#state\" }\n+String               smaCurMode     \"Cur Mode [%s]\"                 { channel=\"bticinosmarther:module:mybridge:thermo1:status#mode\" }\n+Number:Temperature   smaCurPoint    \"Cur Temperature [%.1f %unit%]\" { channel=\"bticinosmarther:module:mybridge:thermo1:status#temperature\" }\n+String               smaCurProgram  \"Cur Program [%s]\"              { channel=\"bticinosmarther:module:mybridge:thermo1:status#program\" }\n+String               smaCurTime     \"Cur Timer [%s]\"                { channel=\"bticinosmarther:module:mybridge:thermo1:status#endTime\" }\n+\n+// Settings items\n+String               smaSetMode     \"Set Mode [%s]\"                 { channel=\"bticinosmarther:module:mybridge:thermo1:settings#mode\" }\n+Number:Temperature   smaSetPoint    \"Set Temperature [%.0f %unit%]\" { channel=\"bticinosmarther:module:mybridge:thermo1:settings#temperature\" }\n+Number               smaSetProgram  \"Set Program [%s]\"              { channel=\"bticinosmarther:module:mybridge:thermo1:settings#program\" }\n+Number               smaSetBoost    \"Set Boost Time []\"             { channel=\"bticinosmarther:module:mybridge:thermo1:settings#boostTime\" }\n+String               smaSetDate     \"Set End Date [%s]\"             { channel=\"bticinosmarther:module:mybridge:thermo1:settings#endDate\" }\n+Number               smaSetHour     \"Set End Hour [%02d:00]\"        { channel=\"bticinosmarther:module:mybridge:thermo1:settings#endHour\" }\n+Number               smaSetMinute   \"Set End Minute [hh:%02d]\"      { channel=\"bticinosmarther:module:mybridge:thermo1:settings#endMinute\" }\n+Switch               smaSetPower    \"Apply Changes\"                 { channel=\"bticinosmarther:module:mybridge:thermo1:settings#power\" }\n+\n+// Convenience items\n+Switch               smaDisplayTime\n+```\n+\n+bticinosmarther.sitemap:\n+\n+```\n+sitemap bticinosmarther label=\"BTicino Smarther Sitemap\" {\n+\n+  Frame label=\"Smarther Measures\" {\n+    Text item=smaTemperature\n+    Text item=smaHumidity\n+  }\n+\n+  Frame label=\"Smarther Status\" {\n+    Text item=smaCurState\n+    Text item=smaCurMode\n+    Text item=smaCurPoint\n+    Text item=smaCurProgram\n+    Text item=smaCurTime\n+  }\n+\n+  Frame label=\"Smarther Settings\" {\n+    Selection item=smaSetMode\n+    Selection item=smaSetProgram visibility=[smaSetMode==\"AUTOMATIC\"]\n+    Setpoint  item=smaSetPoint   minValue=7 maxValue=24 step=1 visibility=[smaSetMode==\"MANUAL\"]\n+    Selection item=smaSetDate    visibility=[smaSetMode==\"MANUAL\"]\n+    Setpoint  item=smaSetHour    minValue=0 maxValue=23 step=1 visibility=[smaDisplayTime==ON]\n+    Setpoint  item=smaSetMinute  minValue=0 maxValue=45 step=15 visibility=[smaDisplayTime==ON]\n+    Switch    item=smaSetBoost   mappings=[30=\"30'\", 60=\"60'\", 90=\"90'\"] visibility=[smaSetMode==\"BOOST\"]\n+    Switch    item=smaSetPower   mappings=[\"ON\"=\"Start\"]\n+  }\n+}\n+```\n+\n+bticinosmarther.rules:\n+\n+```\n+rule \"BTicino Smarther - Set time visibility flag\"\n+when\n+    Item smaSetMode received update or Item smaSetDate received update\n+then\n+    if (smaSetMode.state == \"MANUAL\" && smaSetDate.state != \"\") {\n+        smaDisplayTime.sendCommand(ON)\n+    }\n+    else {\n+        smaDisplayTime.sendCommand(OFF)\n+    }\n+end\n+```\n+\n+## Binding model and Smarther API\n+\n+The model of the binding is such that the bridge takes care of all the remote communications with the Smarther API in the context of a specific user.\n+All devices (chronothermostats modules) currently associated with the user account are available to control.\n+\n+Legrand/BTicino Smarther topology considers the following dimensions:\n+\n+* topology : is the whole network of devices associated with a user account\n+* plant    : is the location where a module is installed (0..N plants per topology)\n+* module   : is the chronothermostat installed in a location (0..N modules per location)\n+\n+You can add multiple bridges to allow controlling devices in the context of multiple Legrand user accounts.\n+\n+Legrand manages the push notifications on device status via MS Azure C2C queues.\n+Each bridge registers himself to the queue, takes care of incoming notifications on behalf of its managed devices and dispatches each payload to the related device.\n+\n+At the time of writing, the binding supports Smarther API v2.0, the last version released by Legrand.\n+The Smarther API and its documentation can be found at https://portal.developer.legrand.com/docs/services/smartherV2/operations/Chronothermostat-Measures.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8bf252fdee587dc75178246537db8bfe456faba2"}, "originalPosition": 327}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c8440b6b00c1af6d83180be648749aec3d3e446d", "author": {"user": {"login": "MrRonfo", "name": "Fabio Possieri"}}, "url": "https://github.com/openhab/openhab-addons/commit/c8440b6b00c1af6d83180be648749aec3d3e446d", "committedDate": "2020-06-27T16:22:21Z", "message": "Some fixes applied following PR Review from kaikreuzer.\n\nAligned README to OH template, fixed config locations fetch channel for\nBridge thing and config programs fetch channel for Module thing, moved\naccessToken info from channel to log at trace level.\n\nSigned-off-by: Fabio Possieri <fabio.possieri@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4ODEyODQz", "url": "https://github.com/openhab/openhab-addons/pull/7533#pullrequestreview-438812843", "createdAt": "2020-06-28T21:00:44Z", "commit": {"oid": "c8440b6b00c1af6d83180be648749aec3d3e446d"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 714, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}