{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEwOTA2MDYz", "number": 7504, "title": "[gree] Initial contribution", "bodyText": "This  binding integrates GREE air conditioners using the WiFi remote control interface. Depending on the model it provides are functions of the regular remote (air control, temp, power, swing etc.)\nI took over this binding from John Cunha, who stopped supporting the binding. Code has been re-factored, discovery and localization added. README is also updated.\nCommunity discussions: https://community.openhab.org/t/new-gree-air-conditioner-binding/36429/123?u=markus7017", "createdAt": "2020-04-29T19:24:24Z", "url": "https://github.com/openhab/openhab-addons/pull/7504", "merged": true, "mergeCommit": {"oid": "25671d4cf270e7f168bf055fda584c5ac8112d61"}, "closed": true, "closedAt": "2020-07-08T05:06:11Z", "author": {"login": "markus7017"}, "timelineItems": {"totalCount": 71, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABccdxuHgBqjMyODYxODY5MzI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcyzOZpgFqTQ0NDQxNDgyOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4d61138cad9245dcd7ac35710e2bd682c77806ae", "author": {"user": {"login": "markus7017", "name": "Markus Michels"}}, "url": "https://github.com/openhab/openhab-addons/commit/4d61138cad9245dcd7ac35710e2bd682c77806ae", "committedDate": "2020-04-29T18:52:15Z", "message": "ignore SocketTimeoutException on background status refresh\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>"}, "afterCommit": {"oid": "15f2e7894ec1eb4b8751bb9f700e61b9ad064564", "author": {"user": {"login": "markus7017", "name": "Markus Michels"}}, "url": "https://github.com/openhab/openhab-addons/commit/15f2e7894ec1eb4b8751bb9f700e61b9ad064564", "committedDate": "2020-04-29T19:37:01Z", "message": "ignore SocketTimeoutException on background status refresh\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAzNDA1NTA0", "url": "https://github.com/openhab/openhab-addons/pull/7504#pullrequestreview-403405504", "createdAt": "2020-04-30T10:45:39Z", "commit": {"oid": "00967f38a5cd39ebe849516fbce526c40c51096f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxMDo0NTozOVrOGOj2TA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxMDo0NTozOVrOGOj2TA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzkyMDU4OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Number AirconMode                   { channel=\"gree:airconditioner:a1234561:modec\" }\n          \n          \n            \n            Number AirconMode                   { channel=\"gree:airconditioner:a1234561:mode\" }", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r417920588", "createdAt": "2020-04-30T10:45:39Z", "author": {"login": "alexander-po"}, "path": "bundles/org.openhab.binding.gree/README.md", "diffHunk": "@@ -0,0 +1,108 @@\n+# GREE Binding\n+\n+This binding integrates GREE Air Conditioners.\n+\n+Note : The GREE Air Conditioner must already be setup on the WiFi network and must have a fixed IP Address.\n+\n+## Supported Things\n+\n+This binding supports one Thing type `airconditioner`.\n+\n+## Discovery\n+\n+Once the GREE is on the network (WiFi active) it could be discovery automatically.\n+An IP broadcast message is sent and every responding units gets added to the Inbox. \n+\n+## Binding Configuration\n+\n+No binding configuration is required.\n+\n+#### Manual Thing Creation\n+\n+Fans can be manually created in the *PaperUI* or *HABmin*, or by placing a *.things* file in the *conf/things* directory.  See example below.\n+\n+\n+## Thing Configuration\n+\n+The Air Conditioner's IP address is mandantory, all other parameters are optional. \n+If the broadcast is not set (default) it will be derived from openHAB's network setting (PaperUI:Configuration:System:Network Settings). \n+Change this only for good reasons.\n+\n+## Channels\n+\n+The following channels are supported for fans:\n+\n+| Channel Name  | Item Type | Description                                                                                       |\n+|---------------|-----------|---------------------------------------------------------------------------------------------------|\n+| power         | Switch    | Power on/off the Air Conditioner                                                                  |\n+| mode          | Number    | Sets the operating mode of the Air Conditioner                                                    |\n+|               |           | Mode: Auto: 0, Cool: 1, Dry: 2, Fan: 3, Heat: 4                                                   |\n+|               |           | For more details see the Air Conditioner's operating manual.                                      |\n+| turbo         | Switch    | Set on/off the Air Conditioner's Turbo mode.                                                      |\n+|               |           | For more details see the Air Conditioner's operating manual.                                      |\n+| light         | Switch    | Enable/disable the front display on the Air Conditioner if applicable to the Air Conditioner model|\n+| temperature   | Number    | Sets the desired room temperature                                                                 |\n+| swingvertical | Number    | Sets the vertical swing action on the Air Conditioner                                             |\n+|               |           | Full Swing: 1, Up: 2, MidUp: 3, Mid: 4, Mid Down: 5, Down : 6                                     |\n+| windspeed     | Number    | Sets the fan speed on the Air conditioner Auto:0, Low:1, MidLow:2, Mid:3, MidHigh:4, High:5       |\n+|               |           | The number of speeds depends on the Air Conditioner model.                                        |\n+| air           | Switch    | Set on/off the Air Conditioner's Air function if applicable to the Air Conditioner model          |\n+| dry           | Switch    | Set on/off the Air Conditioner's Dry function if applicable to the Air Conditioner model          |\n+| health        | Switch    | Set on/off the Air Conditioner's Health function if applicable to the Air Conditioner model       |\n+| powersave     | Switch    | Set on/off the Air Conditioner's Power Saving function if applicable to the Air Conditioner model |\n+\n+\n+## Full Example\n+\n+Things:\n+\n+```\n+Thing gree:airconditioner:a1234561 [ ipAddress=\"192.168.1.111\", refresh=2 ]\n+```\n+\n+Items:\n+\n+```\n+Switch AirconPower                  { channel=\"gree:airconditioner:a1234561:power\" }\n+Number AirconMode                   { channel=\"gree:airconditioner:a1234561:modec\" }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00967f38a5cd39ebe849516fbce526c40c51096f"}, "originalPosition": 67}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAzNDY0MTU0", "url": "https://github.com/openhab/openhab-addons/pull/7504#pullrequestreview-403464154", "createdAt": "2020-04-30T12:18:36Z", "commit": {"oid": "00967f38a5cd39ebe849516fbce526c40c51096f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxMjoxODozN1rOGOmq7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxMjoxODozN1rOGOmq7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzk2NjgyOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            logger.debug(\"Thing not properlyx initialized, abort command\");\n          \n          \n            \n                            logger.debug(\"Thing not properly initialized, abort command\");", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r417966829", "createdAt": "2020-04-30T12:18:37Z", "author": {"login": "alexander-po"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeHandler.java", "diffHunk": "@@ -0,0 +1,327 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.net.DatagramSocket;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.gree.internal.GreeConfiguration;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.discovery.GreeAirDevice;\n+import org.openhab.binding.gree.internal.discovery.GreeDeviceFinder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link GreeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(GreeHandler.class);\n+    private final GreeTranslationProvider messages;\n+    private GreeConfiguration config = new GreeConfiguration();\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+    private GreeAirDevice device = new GreeAirDevice();\n+    private Optional<DatagramSocket> clientSocket = Optional.empty();\n+\n+    private @Nullable ScheduledFuture<?> refreshTask;\n+    private long lastRefreshTime = 0;\n+\n+    public GreeHandler(Thing thing, GreeTranslationProvider messages) {\n+        super(thing);\n+        this.messages = messages;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // logger.debug(\"Start initializing!\");\n+        config = getConfigAs(GreeConfiguration.class);\n+        logger.debug(\"Config for {} is {}\", thing.getUID(), config.toString());\n+        if (config.ipAddress.isEmpty() || (config.refresh < 0)) {\n+            logger.debug(\"Config of {} is invalid. Check configuration\", thing.getUID());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid configuration. Check thing configuration.\");\n+            return;\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.execute(() -> {\n+            initializeThing();\n+        });\n+    }\n+\n+    private void initializeThing() {\n+        logger.debug(\"Thing {} is initializing\", thing.getUID());\n+\n+        try {\n+            // Create a new Datagram socket with a specified timeout\n+            clientSocket = Optional.of(new DatagramSocket());\n+            if (!clientSocket.isPresent()) {\n+                logger.debug(\"Unable to create datagram socket, discovery aborted!\");\n+                return;\n+            }\n+            clientSocket.get().setSoTimeout(DATAGRAM_SOCKET_TIMEOUT);\n+\n+            // Find the GREE device\n+            deviceFinder = new GreeDeviceFinder(config.ipAddress);\n+            deviceFinder.scan(clientSocket, false);\n+            logger.debug(\"{} units found matching IP address\", deviceFinder.getScannedDeviceCount());\n+\n+            // Now check that this one is amongst the air conditioners that responded.\n+            GreeAirDevice newDevice = deviceFinder.getDeviceByIPAddress(config.ipAddress);\n+            if (newDevice != null) {\n+                // Ok, our device responded, now let's Bind with it\n+                device = newDevice;\n+                device.bindWithDevice(clientSocket);\n+                if (device.getIsBound()) {\n+                    logger.debug(\"GREE AirConditioner {} bound successful\", thing.getUID());\n+                    updateStatus(ThingStatus.ONLINE);\n+\n+                    // Start the automatic refresh cycles\n+                    startAutomaticRefresh();\n+                    return;\n+                }\n+            }\n+            logger.debug(\"GREE unit is not responding\");\n+        } catch (GreeException e) {\n+            logger.debug(\"Initialization failed: {}\", messages.get(\"thinginit.exception\", e.toString()));\n+        } catch (IOException | RuntimeException e) {\n+            logger.debug(\"Exception on inituialization\", e);\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            // The thing is updated by the scheduled automatic refresh so do nothing here.\n+        } else {\n+            if (!clientSocket.isPresent()) {\n+                logger.debug(\"Thing not properlyx initialized, abort command\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00967f38a5cd39ebe849516fbce526c40c51096f"}, "originalPosition": 142}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAzNTI0MzYy", "url": "https://github.com/openhab/openhab-addons/pull/7504#pullrequestreview-403524362", "createdAt": "2020-04-30T13:34:54Z", "commit": {"oid": "00967f38a5cd39ebe849516fbce526c40c51096f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxMzozNDo1NVrOGOphAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxMzozNDo1NVrOGOphAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODAxMzQ0MQ==", "bodyText": "I think we should update channels when we don't have the previous value (set initial state of items).\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        return false;\n          \n          \n            \n                        return true;", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r418013441", "createdAt": "2020-04-30T13:34:55Z", "author": {"login": "alexander-po"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,687 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal.discovery;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.StringReader;\r\n+import java.net.DatagramPacket;\r\n+import java.net.DatagramSocket;\r\n+import java.net.InetAddress;\r\n+import java.nio.charset.Charset;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Objects;\r\n+import java.util.Optional;\r\n+\r\n+import org.apache.commons.lang.Validate;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\r\n+import org.openhab.binding.gree.internal.GreeException;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.stream.JsonReader;\r\n+\r\n+/**\r\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\r\n+ * device specific attributes as well a the functionality for the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+// @NonNullByDefault\r\n+public class GreeAirDevice {\r\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\r\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\r\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\r\n+    private boolean isBound = false;\r\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\r\n+    private int port = 0;\r\n+    private String encKey = \"\";\r\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\r\n+    private GreeBindResponse4GsonDTO bindResponseGson;\r\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\r\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\r\n+\r\n+    public Boolean getIsBound() {\r\n+        return isBound;\r\n+    }\r\n+\r\n+    public void setIsBound(boolean isBound) {\r\n+        this.isBound = isBound;\r\n+    }\r\n+\r\n+    public InetAddress getAddress() {\r\n+        return ipAddress;\r\n+    }\r\n+\r\n+    public void setAddress(InetAddress address) {\r\n+        this.ipAddress = address;\r\n+    }\r\n+\r\n+    public int getPort() {\r\n+        return port;\r\n+    }\r\n+\r\n+    public void setPort(int port) {\r\n+        this.port = port;\r\n+    }\r\n+\r\n+    public String getKey() {\r\n+        return encKey;\r\n+    }\r\n+\r\n+    public String getId() {\r\n+        return mScanResponseGson.packJson.mac;\r\n+    }\r\n+\r\n+    public String getName() {\r\n+        return mScanResponseGson.packJson.name;\r\n+    }\r\n+\r\n+    public String getVendor() {\r\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\r\n+    }\r\n+\r\n+    public String getModel() {\r\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\r\n+    }\r\n+\r\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\r\n+        return mScanResponseGson;\r\n+    }\r\n+\r\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\r\n+        mScanResponseGson = gson;\r\n+    }\r\n+\r\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\r\n+        return bindResponseGson;\r\n+    }\r\n+\r\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\r\n+        return statusResponseGson;\r\n+    }\r\n+\r\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\r\n+        Validate.isTrue(socket.isPresent());\r\n+        byte[] sendData = new byte[1024];\r\n+        byte[] receiveData = new byte[347];\r\n+        Gson gson = new Gson();\r\n+\r\n+        try {\r\n+            // Prep the Binding Request pack\r\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\r\n+            bindReqPackGson.mac = getId();\r\n+            bindReqPackGson.t = \"bind\";\r\n+            bindReqPackGson.uid = 0;\r\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\r\n+\r\n+            // Now Encrypt the Binding Request pack\r\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindReqPackStr);\r\n+\r\n+            // Prep the Binding Request\r\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\r\n+            bindReqGson.cid = \"app\";\r\n+            bindReqGson.i = 1;\r\n+            bindReqGson.t = \"pack\";\r\n+            bindReqGson.uid = 0;\r\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\r\n+            String bindReqStr = gson.toJson(bindReqGson);\r\n+            sendData = bindReqStr.getBytes();\r\n+\r\n+            // Now Send the request\r\n+            DatagramSocket clientSocket = socket.get();\r\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\r\n+            clientSocket.send(sendPacket);\r\n+\r\n+            // Recieve a response\r\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\r\n+            clientSocket.receive(receivePacket);\r\n+            String modifiedSentence = new String(receivePacket.getData());\r\n+\r\n+            // Read the response\r\n+            StringReader stringReader = new StringReader(modifiedSentence);\r\n+            bindResponseGson = gson.fromJson(new JsonReader(stringReader), GreeBindResponse4GsonDTO.class);\r\n+            bindResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindResponseGson.pack);\r\n+\r\n+            // Create the JSON to hold the response values\r\n+            stringReader = new StringReader(bindResponseGson.decryptedPack);\r\n+            bindResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePack4GsonDTO.class);\r\n+\r\n+            // Now set the key and flag to indicate the bind was succesful\r\n+            encKey = bindResponseGson.packJson.key;\r\n+            setIsBound(true);\r\n+        } catch (IOException e) {\r\n+            throw new GreeException(e, \"failed\");\r\n+        }\r\n+    }\r\n+\r\n+    public void setDevicePower(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Pow\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void SetDeviceMode(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 4)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Mod\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceSwingVertical(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 11)\r\n+                || (value.intValue() > 6 && value.intValue() < 10)) {\r\n+            return;\r\n+        }\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"SwUpDn\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Only allow this to happen if this device has been bound and values are valid\r\n+     * Possible values are :\r\n+     * 0 : Auto\r\n+     * 1 : Low\r\n+     * 2 : Medium Low\r\n+     * 3 : Medium\r\n+     * 4 : Medium High\r\n+     * 5 : High\r\n+     */\r\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 5)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"WdSpd\", value);\r\n+        parameters.put(\"Quiet\", 0);\r\n+        parameters.put(\"Tur\", 0);\r\n+        parameters.put(\"NoiseSet\", 0);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceTurbo(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Tur\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public int getDeviceTurbo() {\r\n+        return getIntStatusVal(\"Tur\");\r\n+    }\r\n+\r\n+    public void setDeviceLight(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Lig\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create Hash Look Up for C and F\r\n+     * Temperature Ranges for gree A/C units (f_range = {86,61}, c_range={16,30}\r\n+     */\r\n+    private static HashMap<String, HashMap<String, Integer>> createTempRangeMap() {\r\n+        HashMap<String, HashMap<String, Integer>> tempRanges = new HashMap<>();\r\n+        HashMap<String, Integer> hmf = new HashMap<>();\r\n+        HashMap<String, Integer> hmc = new HashMap<>();\r\n+\r\n+        hmf.put(\"min\", new Integer(61)); // F\r\n+        hmf.put(\"max\", new Integer(86));\r\n+        tempRanges.put(\"F\", hmf);\r\n+\r\n+        hmc.put(\"min\", new Integer(16)); // C\r\n+        hmc.put(\"max\", new Integer(30));\r\n+        tempRanges.put(\"C\", hmc);\r\n+\r\n+        return tempRanges;\r\n+    }\r\n+\r\n+    /**\r\n+     * Checks input ranges for validity and TempUn for validity\r\n+     * Uses newVal as priority and tries to validate and determine intent\r\n+     * For example if value is 75 and TempUn says Celsius, change TempUn to Fahrenheit\r\n+     */\r\n+    private Integer[] validateTemperatureRangeForTempSet(Integer newValIn, @Nullable Integer CorFIn) {\r\n+        final String[] minMaxLUT = { \"max\", \"min\" }; // looks up 0 = C = max, 1 = F = min\r\n+        final String[] tempScaleLUT = { \"C\", \"F\" }; // Look Up Table used to convert TempUn integer 0,1 to \"C\" to \"F\"\r\n+                                                    // string for hashmap\r\n+        HashMap<String, Integer> nullCorFLUT = new HashMap<>(); // simple look up table for logic\r\n+        nullCorFLUT.put(\"C\", new Integer(0));\r\n+        nullCorFLUT.put(\"F\", new Integer(1));\r\n+        nullCorFLUT.put(\"INVALID\", new Integer(0));\r\n+\r\n+        String validRangeCorF; // stores if the input range is a valid C or F temperature\r\n+\r\n+        // force to global min/max\r\n+        Integer newVal = Math.max(newValIn, Math.min(tempRanges.get(\"C\").get(\"min\"), tempRanges.get(\"F\").get(\"min\")));\r\n+        newVal = Math.min(newVal, Math.max(tempRanges.get(\"C\").get(\"max\"), tempRanges.get(\"F\").get(\"max\")));\r\n+\r\n+        if ((newVal >= tempRanges.get(\"C\").get(\"min\")) && (newVal <= tempRanges.get(\"C\").get(\"max\"))) {\r\n+            validRangeCorF = \"C\";\r\n+        } else if ((newVal >= tempRanges.get(\"F\").get(\"min\")) && (newVal <= tempRanges.get(\"F\").get(\"max\"))) {\r\n+            validRangeCorF = \"F\";\r\n+        } else {\r\n+            logger.warn(\"Input Temp request {} is invalid\", newVal);\r\n+            validRangeCorF = \"INVALID\";\r\n+        }\r\n+\r\n+        // if CorF wasnt initialized or is null set it from lookup\r\n+        Integer CorF = CorFIn != null ? CorFIn : nullCorFLUT.get(validRangeCorF);\r\n+\r\n+        if ((CorF == 1) && (validRangeCorF == \"C\")) {\r\n+            CorF = 0; // input temp takes priority\r\n+        } else if ((CorF == 0) && (validRangeCorF == \"F\")) {\r\n+            CorF = 1; // input temp takes priority\r\n+        } else if (validRangeCorF == \"INVALID\") {\r\n+            // force min or max temp based on CorF scale to be used\r\n+            newVal = tempRanges.get(tempScaleLUT[CorF]).get(minMaxLUT[CorF]);\r\n+        }\r\n+\r\n+        return new Integer[] { newVal, CorF };\r\n+    }\r\n+\r\n+    public void setDeviceTempSet(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // **value** : set temperature in degrees celsius or Fahrenheit\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+        Integer[] retList;\r\n+        Integer newVal = new Integer(value);\r\n+        Integer outVal = new Integer(value);\r\n+        // Get Celsius or Fahrenheit from status message\r\n+        Integer CorF = getIntStatusVal(\"TemUn\");\r\n+        // TODO put a param in openhab to allow setting this from the config\r\n+\r\n+        // If commanding Fahrenheit set halfStep to 1 or 0 to tell the A/C which F integer\r\n+        // temperature to use as celsius alone is ambigious\r\n+        Integer halfStep = new Integer(0); // default to C\r\n+\r\n+        retList = validateTemperatureRangeForTempSet(newVal, CorF);\r\n+        newVal = retList[0];\r\n+        CorF = retList[1];\r\n+\r\n+        if (CorF == 1) { // If Fahrenheit,\r\n+            // value argument is degrees F, convert Fahrenheit to Celsius,\r\n+            // SetTem input to A/C always in Celsius despite passing in 1 to TemUn\r\n+            outVal = new Integer((int) Math.round((newVal - 32.) * 5.0 / 9.0)); // Integer Truncated\r\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\r\n+            // F = [68. , 69. , 70. , 71. , 72. , 73. , 74. , 75. , 76. , 77. , 78. , 79. , 80. , 81. , 82. , 83. ,\r\n+            // 84. , 85. , 86. ]\r\n+            // C = [20.0, 20.5, 21.1, 21.6, 22.2, 22.7, 23.3, 23.8, 24.4, 25.0, 25.5, 26.1, 26.6, 27.2, 27.7, 28.3,\r\n+            // 28.8, 29.4, 30.0]\r\n+            // TemSet = [20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 30, 30]\r\n+            // TemRec = [ 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]\r\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\r\n+            // subtract the float verison - the int version to get the fractional difference\r\n+            // if the difference is positive set halfStep to 1, negative to 0\r\n+            halfStep = ((((newVal - 32.) * 5.0 / 9.0) - outVal) > 0) ? 1 : 0;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"TemUn\", CorF);\r\n+        parameters.put(\"SetTem\", outVal);\r\n+        parameters.put(\"TemRec\", halfStep);\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceAir(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Air\", value);\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceDry(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Blo\", value);\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceHealth(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Health\", value);\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDevicePwrSaving(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"SvSt\", value);\r\n+        parameters.put(\"WdSpd\", new Integer(0));\r\n+        parameters.put(\"Quiet\", new Integer(0));\r\n+        parameters.put(\"Tur\", new Integer(0));\r\n+        parameters.put(\"SwhSlp\", new Integer(0));\r\n+        parameters.put(\"SlpMod\", new Integer(0));\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public int getIntStatusVal(String valueName) {\r\n+        /*\r\n+         * Note : Values can be:\r\n+         * \"Pow\": Power (0 or 1)\r\n+         * \"Mod\": Mode: Auto: 0, Cool: 1, Dry: 2, Fan: 3, Heat: 4\r\n+         * \"SetTem\": Requested Temperature\r\n+         * \"WdSpd\": Fan Speed : Low:1, Medium Low:2, Medium :3, Medium High :4, High :5\r\n+         * \"Air\": Air Mode Enabled\r\n+         * \"Blo\": Dry\r\n+         * \"Health\": Health\r\n+         * \"SwhSlp\": Sleep\r\n+         * \"SlpMod\": ???\r\n+         * \"Lig\": Light On\r\n+         * \"SwingLfRig\": Swing Left Right\r\n+         * \"SwUpDn\": Swing Up Down: // Ceiling:0, Upwards : 10, Downwards : 11, Full range : 1\r\n+         * \"Quiet\": Quiet mode\r\n+         * \"Tur\": Turbo\r\n+         * \"StHt\": 0,\r\n+         * \"TemUn\": Temperature unit, 0 for Celsius, 1 for Fahrenheit\r\n+         * \"HeatCoolType\"\r\n+         * \"TemRec\": (0 or 1), Send with SetTem, when TemUn==1, distinguishes between upper and lower integer Fahrenheit\r\n+         * temp\r\n+         * \"SvSt\": Power Saving\r\n+         */\r\n+        // Find the valueName in the Returned Status object\r\n+        String columns[] = statusResponseGson.packJson.cols;\r\n+        Integer values[] = statusResponseGson.packJson.dat;\r\n+        List<String> colList = new ArrayList<>(Arrays.asList(columns));\r\n+        List<Integer> valList = new ArrayList<>(Arrays.asList(values));\r\n+        int valueArrayposition = colList.indexOf(valueName);\r\n+        if (valueArrayposition == -1) {\r\n+            return -1;\r\n+        }\r\n+\r\n+        // Now get the Corresponding value\r\n+        Integer value = valList.get(valueArrayposition);\r\n+        return value;\r\n+    }\r\n+\r\n+    public boolean hasStatusValChanged(String valueName) throws GreeException {\r\n+        if (prevStatusResponsePackGson == null) {\r\n+            return false;\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00967f38a5cd39ebe849516fbce526c40c51096f"}, "originalPosition": 486}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0NzYzODA3", "url": "https://github.com/openhab/openhab-addons/pull/7504#pullrequestreview-404763807", "createdAt": "2020-05-04T07:39:24Z", "commit": {"oid": "cb1f85ed07c7e1850348022201e00eb4af95f5e4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQwNzozOToyNFrOGP1hSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQwNzozOToyNFrOGP1hSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTI1ODY5OA==", "bodyText": "Looks like here (and below) should change the channel name to a new format.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                Switch   GreeAirConditioner_Powerchannel           \"Aircon\"                                        {channel=\"greeair:greeairthing:a1234561:powerchannel\", ga=\"Switch\"}\n          \n          \n            \n                Switch   GreeAirConditioner_Powerchannel           \"Aircon\"                                        {channel=\"gree:airconditioner:a1234561:power\", ga=\"Switch\"}", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r419258698", "createdAt": "2020-05-04T07:39:24Z", "author": {"login": "alexander-po"}, "path": "bundles/org.openhab.binding.gree/README.md", "diffHunk": "@@ -0,0 +1,157 @@\n+# GREE Binding\n+\n+This binding integrates GREE Air Conditioners.\n+\n+Note : The GREE Air Conditioner must already be setup on the WiFi network and must have a fixed IP Address.\n+\n+## Supported Things\n+\n+This binding supports one Thing type `airconditioner`.\n+\n+## Discovery\n+\n+Once the GREE is on the network (WiFi active) it could be discovery automatically.\n+An IP broadcast message is sent and every responding units gets added to the Inbox. \n+\n+## Binding Configuration\n+\n+No binding configuration is required.\n+\n+#### Manual Thing Creation\n+\n+Fans can be manually created in the *PaperUI* or *HABmin*, or by placing a *.things* file in the *conf/things* directory.  See example below.\n+\n+\n+## Thing Configuration\n+\n+The Air Conditioner's IP address is mandantory, all other parameters are optional. \n+If the broadcast is not set (default) it will be derived from openHAB's network setting (PaperUI:Configuration:System:Network Settings). \n+Change this only for good reasons.\n+\n+## Channels\n+\n+The following channels are supported for fans:\n+\n+| Channel Name  | Item Type | Description                                                                                       |\n+|---------------|-----------|---------------------------------------------------------------------------------------------------|\n+| power         | Switch    | Power on/off the Air Conditioner                                                                  |\n+| mode          | String    | Sets the operating mode of the Air Conditioner                                                    |\n+|               |           | Mode can be one of auto/cool/eco/dry/fan/turboheat or on/off                                      |||               |\u00a0          | You could also send \"0\"..\"4\", which will be send transparent to the device:                       |\n+|               |           | those map to: \"0\"=Auto, \"1\"=Cool, \"2\"=Dry, \"3\"=Fan only, \"4\"=heat                                 | \n+|               |           | Check the Air Conditioner's operating manual for supported modes.                                 |\n+| temperature   | Number    | Sets the desired room temperature                                                                 |\n+| swingvertical | Number    | Sets the vertical swing action on the Air Conditioner                                             |\n+|\u00a0air           | Switch    | Set on/off the Air Conditioner's Air function if applicable to the Air Conditioner model          |\n+| dry           | Switch    | Set on/off the Air Conditioner's Dry function if applicable to the Air Conditioner model          |\n+|\u00a0health        | Switch    | Set on/off the Air Conditioner's Health function if applicable to the Air Conditioner model       |\n+|\u00a0powersave     | Switch    | Set on/off the Air Conditioner's Power Saving function if applicable to the Air Conditioner model |\n+| turbo         | Switch    | Set on/off the Air Conditioner's Turbo mode.                                                      |\n+| light         | Switch    | Enable/disable the front display on the Air Conditioner if applicable to the Air Conditioner model|\n+|               |           | Full Swing: 1, Up: 2, MidUp: 3, Mid: 4, Mid Down: 5, Down : 6                                     |\n+|\u00a0windspeed     | Number    | Sets the fan speed on the Air conditioner Auto:0, Low:1, MidLow:2, Mid:3, MidHigh:4, High:5       |\n+|               |           |\u00a0The number of speeds depends on the Air Conditioner model.                                        |\n+\n+\n+When changing the mode the air conditioner will be turned on (unless is off is selected).\n+\n+## Full Example\n+\n+### Generic\n+\n+Things:\n+\n+```\n+Thing gree:airconditioner:a1234561 [ ipAddress=\"192.168.1.111\", refresh=2 ]\n+```\n+\n+Items:\n+\n+```\n+Switch AirconPower                  { channel=\"gree:airconditioner:a1234561:power\" }\n+Number AirconMode                   { channel=\"gree:airconditioner:a1234561:mode\" }\n+Switch AirconTurbo                  { channel=\"gree:airconditioner:a1234561:turbo\" }\n+Switch AirconLight                  { channel=\"gree:airconditioner:a1234561:light\" }\n+Number AirconTemp \"Temperature [%.1f \u00b0C]\" {channel=\"gree:airconditioner:a1234561:temperature\" }\n+Number AirconTempSet                { channel=\"gree:airconditioner:a1234561:temperature\" }\n+Number AirconSwingVertical          { channel=\"gree:airconditioner:a1234561:swingvertical\" }\n+Number AirconFanSpeed               { channel=\"gree:airconditioner:a1234561:windspeed\" }\n+Switch AirconAir                    { channel=\"gree:airconditioner:a1234561:air\" }\n+Switch AirconDry                    { channel=\"gree:airconditioner:a1234561:dry\" }\n+Switch AirconHealth                 { channel=\"gree:airconditioner:a1234561:health\" }\n+Switch AirconPowerSaving            { channel=\"gree:airconditioner:a1234561:powersave\" }\n+```\n+\n+Sitemap:\n+\n+This is an example of how to set up your sitemap.\n+\n+```\n+Frame label=\"Controls\"\n+{\n+   Switch item=AirconPower label=\"Power\" icon=switch\n+   Switch item=AirconMode label=\"Mode\" mappings=[0=\"Auto\", 1=\"Cool\", 2=\"Dry\", 3=\"Fan\", 4=\"Heat\"]\n+   Setpoint item=AirconTemp label=\"Set temperature\" icon=temperature minValue=16 maxValue=30 step=1\n+}\n+Frame label=\"Fan Speed\"\n+{\n+   Switch item=AirconFanSpeed label=\"Fan Speed\" mappings=[0=\"Auto\", 1=\"Low\", 2=\"Medium Low\", 3=\"Medium\", 4=\"Medium High\", 5=\"High\"] icon=fan\n+}\n+Frame label=\"Fan-Swing Direction\"\n+{\n+   Switch item=AirconSwingVertical label=\"Direction\" mappings=[0=\"Off\", 1=\"Full\", 2=\"Up\", 3=\"Mid-up\", 4=\"Mid\", 5=\"Mid-low\", 6=\"Down\"] icon=flow\n+}\n+Frame label=\"Options\"\n+{\n+   Switch item=AirconTurbo label=\"Turbo\" icon=fan\n+   Switch item=AirconLight label=\"Light\" icon=light\n+   Switch item=AirconAir label=\"Air\" icon=flow\n+   Switch item=AirconDry label=\"Dry\" icon=rain\n+   Switch item=AirconHealth label=\"Health\" icon=smiley\n+   Switch item=AirconPowerSaving label=\"Power Saving\" icon=poweroutlet\n+}\n+```\n+\n+### Google Home Assistant\n+\n+This example shows who to make the GREE Air Conditioner controllable by Google HA (A/C mode + temperature)\n+\n+Items:\n+\n+```\n+Group Gree_Modechannel                 \"Gree\"        { ga=\"Thermostat\" } // \u00faj Gree bindinggal\n+// Gree Kl\u00edma\n+    Switch   GreeAirConditioner_Powerchannel           \"Aircon\"                                        {channel=\"greeair:greeairthing:a1234561:powerchannel\", ga=\"Switch\"}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cb1f85ed07c7e1850348022201e00eb4af95f5e4"}, "originalPosition": 123}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA3MjU0MjE4", "url": "https://github.com/openhab/openhab-addons/pull/7504#pullrequestreview-407254218", "createdAt": "2020-05-07T08:26:36Z", "commit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxNDMxNDIz", "url": "https://github.com/openhab/openhab-addons/pull/7504#pullrequestreview-421431423", "createdAt": "2020-05-30T17:56:41Z", "commit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 90, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQxNzo1Njo0MVrOGc0ihQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQyMDozNDowN1rOGc1OMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3NDExNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Note : The GREE Air Conditioner must already be setup on the WiFi network and must have a fixed IP Address.\n          \n          \n            \n            Note: The GREE Air Conditioner must already be setup on the WiFi network and must have a fixed IP Address.", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432874117", "createdAt": "2020-05-30T17:56:41Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/README.md", "diffHunk": "@@ -0,0 +1,139 @@\n+# GREE Binding\n+\n+This binding integrates GREE Air Conditioners.\n+\n+Note : The GREE Air Conditioner must already be setup on the WiFi network and must have a fixed IP Address.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3NDMzOA==", "bodyText": "Can you specify the applicable range?", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432874338", "createdAt": "2020-05-30T17:59:31Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/README.md", "diffHunk": "@@ -0,0 +1,139 @@\n+# GREE Binding\n+\n+This binding integrates GREE Air Conditioners.\n+\n+Note : The GREE Air Conditioner must already be setup on the WiFi network and must have a fixed IP Address.\n+\n+## Supported Things\n+\n+This binding supports one Thing type `airconditioner`.\n+\n+## Discovery\n+\n+Once the GREE is on the network (WiFi active) it could be discovery automatically.\n+An IP broadcast message is sent and every responding units gets added to the Inbox. \n+\n+## Binding Configuration\n+\n+No binding configuration is required.\n+\n+#### Manual Thing Creation\n+\n+Fans can be manually created in the *PaperUI* or *HABmin*, or by placing a *.things* file in the *conf/things* directory.  See example below.\n+\n+\n+## Thing Configuration\n+\n+The Air Conditioner's IP address is mandantory, all other parameters are optional. \n+If the broadcast is not set (default) it will be derived from openHAB's network setting (PaperUI:Configuration:System:Network Settings). \n+Change this only for good reasons.\n+\n+## Channels\n+\n+The following channels are supported for fans:\n+\n+| Channel Name  | Item Type | Description                                                                                       |\n+|---------------|-----------|---------------------------------------------------------------------------------------------------|\n+| power         | Switch    | Power on/off the Air Conditioner                                                                  |\n+| mode          | String    | Sets the operating mode of the Air Conditioner                                                    |\n+|               |           | Mode can be one of auto/cool/eco/dry/fan/turboheat or on/off                                      |\n+|               |\u00a0          | You could also send \"0\"..\"4\", which will be send transparent to the device:                       |\n+|               |           | those map to: \"0\"=Auto, \"1\"=Cool, \"2\"=Dry, \"3\"=Fan only, \"4\"=heat                                 | \n+|               |           | Check the Air Conditioner's operating manual for supported modes.                                 |\n+| temperature   | Number    | Sets the desired room temperature                                                                 |\n+|\u00a0air           | Switch    | Set on/off the Air Conditioner's Air function if applicable to the Air Conditioner model          |\n+| dry           | Switch    | Set on/off the Air Conditioner's Dry function if applicable to the Air Conditioner model          |\n+|\u00a0health        | Switch    | Set on/off the Air Conditioner's Health function if applicable to the Air Conditioner model       |\n+| turbo         | Switch    | Set on/off the Air Conditioner's Turbo mode.                                                      |\n+| swingvertical | Number    | Sets the vertical swing action on the Air Conditioner                                             |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3NDQ4OA==", "bodyText": "Can you specify the other parameters here?", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432874488", "createdAt": "2020-05-30T18:01:16Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/README.md", "diffHunk": "@@ -0,0 +1,139 @@\n+# GREE Binding\n+\n+This binding integrates GREE Air Conditioners.\n+\n+Note : The GREE Air Conditioner must already be setup on the WiFi network and must have a fixed IP Address.\n+\n+## Supported Things\n+\n+This binding supports one Thing type `airconditioner`.\n+\n+## Discovery\n+\n+Once the GREE is on the network (WiFi active) it could be discovery automatically.\n+An IP broadcast message is sent and every responding units gets added to the Inbox. \n+\n+## Binding Configuration\n+\n+No binding configuration is required.\n+\n+#### Manual Thing Creation\n+\n+Fans can be manually created in the *PaperUI* or *HABmin*, or by placing a *.things* file in the *conf/things* directory.  See example below.\n+\n+\n+## Thing Configuration\n+\n+The Air Conditioner's IP address is mandantory, all other parameters are optional. ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3NDcxMw==", "bodyText": "Is \"bindinggal\" a typo?", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432874713", "createdAt": "2020-05-30T18:04:02Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/README.md", "diffHunk": "@@ -0,0 +1,139 @@\n+# GREE Binding\n+\n+This binding integrates GREE Air Conditioners.\n+\n+Note : The GREE Air Conditioner must already be setup on the WiFi network and must have a fixed IP Address.\n+\n+## Supported Things\n+\n+This binding supports one Thing type `airconditioner`.\n+\n+## Discovery\n+\n+Once the GREE is on the network (WiFi active) it could be discovery automatically.\n+An IP broadcast message is sent and every responding units gets added to the Inbox. \n+\n+## Binding Configuration\n+\n+No binding configuration is required.\n+\n+#### Manual Thing Creation\n+\n+Fans can be manually created in the *PaperUI* or *HABmin*, or by placing a *.things* file in the *conf/things* directory.  See example below.\n+\n+\n+## Thing Configuration\n+\n+The Air Conditioner's IP address is mandantory, all other parameters are optional. \n+If the broadcast is not set (default) it will be derived from openHAB's network setting (PaperUI:Configuration:System:Network Settings). \n+Change this only for good reasons.\n+\n+## Channels\n+\n+The following channels are supported for fans:\n+\n+| Channel Name  | Item Type | Description                                                                                       |\n+|---------------|-----------|---------------------------------------------------------------------------------------------------|\n+| power         | Switch    | Power on/off the Air Conditioner                                                                  |\n+| mode          | String    | Sets the operating mode of the Air Conditioner                                                    |\n+|               |           | Mode can be one of auto/cool/eco/dry/fan/turboheat or on/off                                      |\n+|               |\u00a0          | You could also send \"0\"..\"4\", which will be send transparent to the device:                       |\n+|               |           | those map to: \"0\"=Auto, \"1\"=Cool, \"2\"=Dry, \"3\"=Fan only, \"4\"=heat                                 | \n+|               |           | Check the Air Conditioner's operating manual for supported modes.                                 |\n+| temperature   | Number    | Sets the desired room temperature                                                                 |\n+|\u00a0air           | Switch    | Set on/off the Air Conditioner's Air function if applicable to the Air Conditioner model          |\n+| dry           | Switch    | Set on/off the Air Conditioner's Dry function if applicable to the Air Conditioner model          |\n+|\u00a0health        | Switch    | Set on/off the Air Conditioner's Health function if applicable to the Air Conditioner model       |\n+| turbo         | Switch    | Set on/off the Air Conditioner's Turbo mode.                                                      |\n+| swingvertical | Number    | Sets the vertical swing action on the Air Conditioner                                             |\n+|\u00a0windspeed     | Number    | Sets the fan speed on the Air conditioner Auto:0, Low:1, MidLow:2, Mid:3, MidHigh:4, High:5       |\n+|               |           |\u00a0The number of speeds depends on the Air Conditioner model.                                        |\n+|\u00a0powersave     | Switch    | Set on/off the Air Conditioner's Power Saving function if applicable to the Air Conditioner model |\n+| light         | Switch    | Enable/disable the front display on the Air Conditioner if applicable to the Air Conditioner model|\n+|               |           | Full Swing: 1, Up: 2, MidUp: 3, Mid: 4, Mid Down: 5, Down : 6                                     |\n+\n+\n+When changing the mode the air conditioner will be turned on (unless is off is selected).\n+\n+## Full Example\n+\n+### Generic\n+\n+Things:\n+\n+```\n+Thing gree:airconditioner:a1234561 [ ipAddress=\"192.168.1.111\", refresh=2 ]\n+```\n+\n+Items:\n+\n+```\n+Switch AirconPower                  { channel=\"gree:airconditioner:a1234561:power\" }\n+Number AirconMode                   { channel=\"gree:airconditioner:a1234561:mode\" }\n+Switch AirconTurbo                  { channel=\"gree:airconditioner:a1234561:turbo\" }\n+Switch AirconLight                  { channel=\"gree:airconditioner:a1234561:light\" }\n+Number AirconTemp \"Temperature [%.1f \u00b0C]\" {channel=\"gree:airconditioner:a1234561:temperature\" }\n+Number AirconTempSet                { channel=\"gree:airconditioner:a1234561:temperature\" }\n+Number AirconSwingVertical          { channel=\"gree:airconditioner:a1234561:swingvertical\" }\n+Number AirconFanSpeed               { channel=\"gree:airconditioner:a1234561:windspeed\" }\n+Switch AirconAir                    { channel=\"gree:airconditioner:a1234561:air\" }\n+Switch AirconDry                    { channel=\"gree:airconditioner:a1234561:dry\" }\n+Switch AirconHealth                 { channel=\"gree:airconditioner:a1234561:health\" }\n+Switch AirconPowerSaving            { channel=\"gree:airconditioner:a1234561:powersave\" }\n+```\n+\n+Sitemap:\n+\n+This is an example of how to set up your sitemap.\n+\n+```\n+Frame label=\"Controls\"\n+{\n+   Switch item=AirconMode label=\"Mode\" mappings=[\"auto\"=\"Auto\", \"cool\"=\"Cool\", \"eco\"=\"Eco\", \"dry\"=\"Dry\", \"fan\"=\"Fan\", \"turbo\"=\"Turbo\", \"heat\"=\"Heat\", \"on\"=\"ON\", \"off\"=\"OFF\"]\n+   Setpoint item=AirconTemp label=\"Set temperature\" icon=temperature minValue=16 maxValue=30 step=1\n+}\n+Frame label=\"Fan Speed\"\n+{\n+   Switch item=AirconFanSpeed label=\"Fan Speed\" mappings=[0=\"Auto\", 1=\"Low\", 2=\"Medium Low\", 3=\"Medium\", 4=\"Medium High\", 5=\"High\"] icon=fan\n+}\n+Frame label=\"Fan-Swing Direction\"\n+{\n+   Switch item=AirconSwingVertical label=\"Direction\" mappings=[0=\"Off\", 1=\"Full\", 2=\"Up\", 3=\"Mid-up\", 4=\"Mid\", 5=\"Mid-low\", 6=\"Down\"] icon=flow\n+}\n+Frame label=\"Options\"\n+{\n+   Switch item=AirconTurbo label=\"Turbo\" icon=fan\n+   Switch item=AirconLight label=\"Light\" icon=light\n+   Switch item=AirconAir label=\"Air\" icon=flow\n+   Switch item=AirconDry label=\"Dry\" icon=rain\n+   Switch item=AirconHealth label=\"Health\" icon=smiley\n+   Switch item=AirconPowerSaving label=\"Power Saving\" icon=poweroutlet\n+}\n+```\n+\n+### Google Home Assistant\n+\n+This example shows who to make the GREE Air Conditioner controllable by Google HA (A/C mode + temperature)\n+\n+Items:\n+\n+```\n+Group Gree_Modechannel                 \"Gree\"        { ga=\"Thermostat\" } // Gree bindinggal", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3NDgxOQ==", "bodyText": "Does this file have a special meaning with the \"-e\" suffix in the filename?", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432874819", "createdAt": "2020-05-30T18:05:11Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/feature/feature.xml-e", "diffHunk": "@@ -0,0 +1,9 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3NDkwMg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            + String.valueOf(refresh);\n          \n          \n            \n                            + refresh;", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432874902", "createdAt": "2020-05-30T18:06:04Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/GreeConfiguration.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The {@link GreeConfiguration} class contains fields mapping thing configuration parameters.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeConfiguration {\n+    public String ipAddress = \"\";\n+    public String broadcastAddress = \"\";\n+    public int refresh = 60;\n+\n+    @Override\n+    public String toString() {\n+        return \"Config: ipAddress=\" + ipAddress + \", broadcastAddress=\" + broadcastAddress + \", refresh=\"\n+                + String.valueOf(refresh);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3NTM5MQ==", "bodyText": "[WARNING] .binding.gree\\README.md:[130]\nThe line before code formatting section must be empty.", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432875391", "createdAt": "2020-05-30T18:12:58Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/README.md", "diffHunk": "@@ -0,0 +1,139 @@\n+# GREE Binding\n+\n+This binding integrates GREE Air Conditioners.\n+\n+Note : The GREE Air Conditioner must already be setup on the WiFi network and must have a fixed IP Address.\n+\n+## Supported Things\n+\n+This binding supports one Thing type `airconditioner`.\n+\n+## Discovery\n+\n+Once the GREE is on the network (WiFi active) it could be discovery automatically.\n+An IP broadcast message is sent and every responding units gets added to the Inbox. \n+\n+## Binding Configuration\n+\n+No binding configuration is required.\n+\n+#### Manual Thing Creation\n+\n+Fans can be manually created in the *PaperUI* or *HABmin*, or by placing a *.things* file in the *conf/things* directory.  See example below.\n+\n+\n+## Thing Configuration\n+\n+The Air Conditioner's IP address is mandantory, all other parameters are optional. \n+If the broadcast is not set (default) it will be derived from openHAB's network setting (PaperUI:Configuration:System:Network Settings). \n+Change this only for good reasons.\n+\n+## Channels\n+\n+The following channels are supported for fans:\n+\n+| Channel Name  | Item Type | Description                                                                                       |\n+|---------------|-----------|---------------------------------------------------------------------------------------------------|\n+| power         | Switch    | Power on/off the Air Conditioner                                                                  |\n+| mode          | String    | Sets the operating mode of the Air Conditioner                                                    |\n+|               |           | Mode can be one of auto/cool/eco/dry/fan/turboheat or on/off                                      |\n+|               |\u00a0          | You could also send \"0\"..\"4\", which will be send transparent to the device:                       |\n+|               |           | those map to: \"0\"=Auto, \"1\"=Cool, \"2\"=Dry, \"3\"=Fan only, \"4\"=heat                                 | \n+|               |           | Check the Air Conditioner's operating manual for supported modes.                                 |\n+| temperature   | Number    | Sets the desired room temperature                                                                 |\n+|\u00a0air           | Switch    | Set on/off the Air Conditioner's Air function if applicable to the Air Conditioner model          |\n+| dry           | Switch    | Set on/off the Air Conditioner's Dry function if applicable to the Air Conditioner model          |\n+|\u00a0health        | Switch    | Set on/off the Air Conditioner's Health function if applicable to the Air Conditioner model       |\n+| turbo         | Switch    | Set on/off the Air Conditioner's Turbo mode.                                                      |\n+| swingvertical | Number    | Sets the vertical swing action on the Air Conditioner                                             |\n+|\u00a0windspeed     | Number    | Sets the fan speed on the Air conditioner Auto:0, Low:1, MidLow:2, Mid:3, MidHigh:4, High:5       |\n+|               |           |\u00a0The number of speeds depends on the Air Conditioner model.                                        |\n+|\u00a0powersave     | Switch    | Set on/off the Air Conditioner's Power Saving function if applicable to the Air Conditioner model |\n+| light         | Switch    | Enable/disable the front display on the Air Conditioner if applicable to the Air Conditioner model|\n+|               |           | Full Swing: 1, Up: 2, MidUp: 3, Mid: 4, Mid Down: 5, Down : 6                                     |\n+\n+\n+When changing the mode the air conditioner will be turned on (unless is off is selected).\n+\n+## Full Example\n+\n+### Generic\n+\n+Things:\n+\n+```\n+Thing gree:airconditioner:a1234561 [ ipAddress=\"192.168.1.111\", refresh=2 ]\n+```\n+\n+Items:\n+\n+```\n+Switch AirconPower                  { channel=\"gree:airconditioner:a1234561:power\" }\n+Number AirconMode                   { channel=\"gree:airconditioner:a1234561:mode\" }\n+Switch AirconTurbo                  { channel=\"gree:airconditioner:a1234561:turbo\" }\n+Switch AirconLight                  { channel=\"gree:airconditioner:a1234561:light\" }\n+Number AirconTemp \"Temperature [%.1f \u00b0C]\" {channel=\"gree:airconditioner:a1234561:temperature\" }\n+Number AirconTempSet                { channel=\"gree:airconditioner:a1234561:temperature\" }\n+Number AirconSwingVertical          { channel=\"gree:airconditioner:a1234561:swingvertical\" }\n+Number AirconFanSpeed               { channel=\"gree:airconditioner:a1234561:windspeed\" }\n+Switch AirconAir                    { channel=\"gree:airconditioner:a1234561:air\" }\n+Switch AirconDry                    { channel=\"gree:airconditioner:a1234561:dry\" }\n+Switch AirconHealth                 { channel=\"gree:airconditioner:a1234561:health\" }\n+Switch AirconPowerSaving            { channel=\"gree:airconditioner:a1234561:powersave\" }\n+```\n+\n+Sitemap:\n+\n+This is an example of how to set up your sitemap.\n+\n+```\n+Frame label=\"Controls\"\n+{\n+   Switch item=AirconMode label=\"Mode\" mappings=[\"auto\"=\"Auto\", \"cool\"=\"Cool\", \"eco\"=\"Eco\", \"dry\"=\"Dry\", \"fan\"=\"Fan\", \"turbo\"=\"Turbo\", \"heat\"=\"Heat\", \"on\"=\"ON\", \"off\"=\"OFF\"]\n+   Setpoint item=AirconTemp label=\"Set temperature\" icon=temperature minValue=16 maxValue=30 step=1\n+}\n+Frame label=\"Fan Speed\"\n+{\n+   Switch item=AirconFanSpeed label=\"Fan Speed\" mappings=[0=\"Auto\", 1=\"Low\", 2=\"Medium Low\", 3=\"Medium\", 4=\"Medium High\", 5=\"High\"] icon=fan\n+}\n+Frame label=\"Fan-Swing Direction\"\n+{\n+   Switch item=AirconSwingVertical label=\"Direction\" mappings=[0=\"Off\", 1=\"Full\", 2=\"Up\", 3=\"Mid-up\", 4=\"Mid\", 5=\"Mid-low\", 6=\"Down\"] icon=flow\n+}\n+Frame label=\"Options\"\n+{\n+   Switch item=AirconTurbo label=\"Turbo\" icon=fan\n+   Switch item=AirconLight label=\"Light\" icon=light\n+   Switch item=AirconAir label=\"Air\" icon=flow\n+   Switch item=AirconDry label=\"Dry\" icon=rain\n+   Switch item=AirconHealth label=\"Health\" icon=smiley\n+   Switch item=AirconPowerSaving label=\"Power Saving\" icon=poweroutlet\n+}\n+```\n+\n+### Google Home Assistant\n+\n+This example shows who to make the GREE Air Conditioner controllable by Google HA (A/C mode + temperature)\n+\n+Items:\n+\n+```\n+Group Gree_Modechannel                 \"Gree\"        { ga=\"Thermostat\" } // Gree bindinggal\n+// GREE A/C\n+    Switch   GreeAirConditioner_Power   \"Aircon\"              {channel=\"gree:airconditioner:a1234561:power\", ga=\"Switch\"}\n+    Number   GreeAirConditioner_Mode    \"Aircon Mode\"         {channel=\"gree:airconditioner:a1234561:mode\", ga=\"thermostatMode\"}\n+    Number   GreeAirConditioner_Temp    \"Aircon Temperature\"  {channel=\"gree:airconditioner:a1234561:temperature}\n+    Switch   GreeAirConditioner_Lightl  \"Light\"               {channel=\"gree:airconditioner:a1234561:light\"}\n+```\n+\n+Rule:\n+```", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3NTUwMg==", "bodyText": "This should be private static final and the name uppercase.", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432875502", "createdAt": "2020-05-30T18:14:32Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/GreeCryptoUtil.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal;\r\n+\r\n+import java.security.Key;\r\n+import java.util.Base64;\r\n+\r\n+import javax.crypto.Cipher;\r\n+import javax.crypto.spec.SecretKeySpec;\r\n+\r\n+import org.eclipse.jdt.annotation.NonNullByDefault;\r\n+\r\n+/**\r\n+ * The CryptoUtil class provides functionality for encrypting and decrypting\r\n+ * messages sent to and from the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+@NonNullByDefault\r\n+public class GreeCryptoUtil {\r\n+    static String AES_General_Key = \"a3K8Bx%2r8Y7#xDh\";\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3NTU2MA==", "bodyText": "Methods should start with a lowercase character.", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432875560", "createdAt": "2020-05-30T18:15:09Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/GreeCryptoUtil.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal;\r\n+\r\n+import java.security.Key;\r\n+import java.util.Base64;\r\n+\r\n+import javax.crypto.Cipher;\r\n+import javax.crypto.spec.SecretKeySpec;\r\n+\r\n+import org.eclipse.jdt.annotation.NonNullByDefault;\r\n+\r\n+/**\r\n+ * The CryptoUtil class provides functionality for encrypting and decrypting\r\n+ * messages sent to and from the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+@NonNullByDefault\r\n+public class GreeCryptoUtil {\r\n+    static String AES_General_Key = \"a3K8Bx%2r8Y7#xDh\";\r\n+\r\n+    public static String GetAESGeneralKey() {\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3NTU3Mw==", "bodyText": "See above.", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432875573", "createdAt": "2020-05-30T18:15:17Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/GreeCryptoUtil.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal;\r\n+\r\n+import java.security.Key;\r\n+import java.util.Base64;\r\n+\r\n+import javax.crypto.Cipher;\r\n+import javax.crypto.spec.SecretKeySpec;\r\n+\r\n+import org.eclipse.jdt.annotation.NonNullByDefault;\r\n+\r\n+/**\r\n+ * The CryptoUtil class provides functionality for encrypting and decrypting\r\n+ * messages sent to and from the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+@NonNullByDefault\r\n+public class GreeCryptoUtil {\r\n+    static String AES_General_Key = \"a3K8Bx%2r8Y7#xDh\";\r\n+\r\n+    public static String GetAESGeneralKey() {\r\n+        return AES_General_Key;\r\n+    }\r\n+\r\n+    public static byte[] GetAESGeneralKeyByteArray() {\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3NTY3Nw==", "bodyText": "Is the commented-out code necessary?", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432875677", "createdAt": "2020-05-30T18:16:52Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/GreeCryptoUtil.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal;\r\n+\r\n+import java.security.Key;\r\n+import java.util.Base64;\r\n+\r\n+import javax.crypto.Cipher;\r\n+import javax.crypto.spec.SecretKeySpec;\r\n+\r\n+import org.eclipse.jdt.annotation.NonNullByDefault;\r\n+\r\n+/**\r\n+ * The CryptoUtil class provides functionality for encrypting and decrypting\r\n+ * messages sent to and from the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+@NonNullByDefault\r\n+public class GreeCryptoUtil {\r\n+    static String AES_General_Key = \"a3K8Bx%2r8Y7#xDh\";\r\n+\r\n+    public static String GetAESGeneralKey() {\r\n+        return AES_General_Key;\r\n+    }\r\n+\r\n+    public static byte[] GetAESGeneralKeyByteArray() {\r\n+        return AES_General_Key.getBytes();\r\n+    }\r\n+\r\n+    public static String decryptPack(byte[] keyarray, String message) throws GreeException {\r\n+        try {\r\n+            Key key = new SecretKeySpec(keyarray, \"AES\");\r\n+            // BASE64Decoder decoder = new BASE64Decoder();\r\n+            Base64.Decoder decoder = Base64.getDecoder();\r\n+            // Decoder decoder = new Decoder();\r\n+            byte[] imageByte = decoder.decode(message);\r\n+            // byte[] imageByte = decoder.decodeBuffer(message);\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3NTk1OQ==", "bodyText": "You should specify the expected charset in the constructor, to not rely on the system charset.", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432875959", "createdAt": "2020-05-30T18:20:40Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/GreeCryptoUtil.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal;\r\n+\r\n+import java.security.Key;\r\n+import java.util.Base64;\r\n+\r\n+import javax.crypto.Cipher;\r\n+import javax.crypto.spec.SecretKeySpec;\r\n+\r\n+import org.eclipse.jdt.annotation.NonNullByDefault;\r\n+\r\n+/**\r\n+ * The CryptoUtil class provides functionality for encrypting and decrypting\r\n+ * messages sent to and from the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+@NonNullByDefault\r\n+public class GreeCryptoUtil {\r\n+    static String AES_General_Key = \"a3K8Bx%2r8Y7#xDh\";\r\n+\r\n+    public static String GetAESGeneralKey() {\r\n+        return AES_General_Key;\r\n+    }\r\n+\r\n+    public static byte[] GetAESGeneralKeyByteArray() {\r\n+        return AES_General_Key.getBytes();\r\n+    }\r\n+\r\n+    public static String decryptPack(byte[] keyarray, String message) throws GreeException {\r\n+        try {\r\n+            Key key = new SecretKeySpec(keyarray, \"AES\");\r\n+            // BASE64Decoder decoder = new BASE64Decoder();\r\n+            Base64.Decoder decoder = Base64.getDecoder();\r\n+            // Decoder decoder = new Decoder();\r\n+            byte[] imageByte = decoder.decode(message);\r\n+            // byte[] imageByte = decoder.decodeBuffer(message);\r\n+\r\n+            Cipher aesCipher = Cipher.getInstance(\"AES\");\r\n+            aesCipher.init(Cipher.DECRYPT_MODE, key);\r\n+            byte[] bytePlainText = aesCipher.doFinal(imageByte);\r\n+\r\n+            return new String(bytePlainText);\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3NjA0Mw==", "bodyText": "Better catch the exceptions you expect explicitly.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    } catch (Exception ex) {\n          \n          \n            \n                    } catch (NoSuchAlgorithmException | NoSuchPaddingException e) {", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432876043", "createdAt": "2020-05-30T18:22:01Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/GreeCryptoUtil.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal;\r\n+\r\n+import java.security.Key;\r\n+import java.util.Base64;\r\n+\r\n+import javax.crypto.Cipher;\r\n+import javax.crypto.spec.SecretKeySpec;\r\n+\r\n+import org.eclipse.jdt.annotation.NonNullByDefault;\r\n+\r\n+/**\r\n+ * The CryptoUtil class provides functionality for encrypting and decrypting\r\n+ * messages sent to and from the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+@NonNullByDefault\r\n+public class GreeCryptoUtil {\r\n+    static String AES_General_Key = \"a3K8Bx%2r8Y7#xDh\";\r\n+\r\n+    public static String GetAESGeneralKey() {\r\n+        return AES_General_Key;\r\n+    }\r\n+\r\n+    public static byte[] GetAESGeneralKeyByteArray() {\r\n+        return AES_General_Key.getBytes();\r\n+    }\r\n+\r\n+    public static String decryptPack(byte[] keyarray, String message) throws GreeException {\r\n+        try {\r\n+            Key key = new SecretKeySpec(keyarray, \"AES\");\r\n+            // BASE64Decoder decoder = new BASE64Decoder();\r\n+            Base64.Decoder decoder = Base64.getDecoder();\r\n+            // Decoder decoder = new Decoder();\r\n+            byte[] imageByte = decoder.decode(message);\r\n+            // byte[] imageByte = decoder.decodeBuffer(message);\r\n+\r\n+            Cipher aesCipher = Cipher.getInstance(\"AES\");\r\n+            aesCipher.init(Cipher.DECRYPT_MODE, key);\r\n+            byte[] bytePlainText = aesCipher.doFinal(imageByte);\r\n+\r\n+            return new String(bytePlainText);\r\n+        } catch (Exception ex) {\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3NjgzOA==", "bodyText": "See above", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432876838", "createdAt": "2020-05-30T18:32:43Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/GreeCryptoUtil.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal;\r\n+\r\n+import java.security.Key;\r\n+import java.util.Base64;\r\n+\r\n+import javax.crypto.Cipher;\r\n+import javax.crypto.spec.SecretKeySpec;\r\n+\r\n+import org.eclipse.jdt.annotation.NonNullByDefault;\r\n+\r\n+/**\r\n+ * The CryptoUtil class provides functionality for encrypting and decrypting\r\n+ * messages sent to and from the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+@NonNullByDefault\r\n+public class GreeCryptoUtil {\r\n+    static String AES_General_Key = \"a3K8Bx%2r8Y7#xDh\";\r\n+\r\n+    public static String GetAESGeneralKey() {\r\n+        return AES_General_Key;\r\n+    }\r\n+\r\n+    public static byte[] GetAESGeneralKeyByteArray() {\r\n+        return AES_General_Key.getBytes();\r\n+    }\r\n+\r\n+    public static String decryptPack(byte[] keyarray, String message) throws GreeException {\r\n+        try {\r\n+            Key key = new SecretKeySpec(keyarray, \"AES\");\r\n+            // BASE64Decoder decoder = new BASE64Decoder();\r\n+            Base64.Decoder decoder = Base64.getDecoder();\r\n+            // Decoder decoder = new Decoder();\r\n+            byte[] imageByte = decoder.decode(message);\r\n+            // byte[] imageByte = decoder.decodeBuffer(message);\r\n+\r\n+            Cipher aesCipher = Cipher.getInstance(\"AES\");\r\n+            aesCipher.init(Cipher.DECRYPT_MODE, key);\r\n+            byte[] bytePlainText = aesCipher.doFinal(imageByte);\r\n+\r\n+            return new String(bytePlainText);\r\n+        } catch (Exception ex) {\r\n+            throw new GreeException(ex, \"Decryption of recieved data failed\");\r\n+        }\r\n+    }\r\n+\r\n+    public static String encryptPack(byte[] keyarray, String message) throws GreeException {\r\n+        try {\r\n+            Key key = new SecretKeySpec(keyarray, \"AES\");\r\n+            Cipher aesCipher = Cipher.getInstance(\"AES\");\r\n+            aesCipher.init(Cipher.ENCRYPT_MODE, key);\r\n+            byte[] bytePlainText = aesCipher.doFinal(message.getBytes());\r\n+\r\n+            Base64.Encoder newencoder = Base64.getEncoder();\r\n+            String encrytpedMessage = new String(newencoder.encode(bytePlainText));\r\n+            return encrytpedMessage.substring(0, encrytpedMessage.length());\r\n+        } catch (Exception ex) {\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3NzM5NA==", "bodyText": "This method is never called.", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432877394", "createdAt": "2020-05-30T18:39:26Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/GreeHandlerFactory.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.util.Hashtable;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.i18n.LocaleProvider;\n+import org.eclipse.smarthome.core.i18n.TranslationProvider;\n+import org.eclipse.smarthome.core.net.NetworkAddressService;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.openhab.binding.gree.internal.discovery.GreeDiscoveryService;\n+import org.openhab.binding.gree.internal.handler.GreeHandler;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.service.component.ComponentContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link GreeHandlerFactory} is responsible for creating things and thing handlers.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+@Component(configurationPid = \"binding.\" + BINDING_ID, service = ThingHandlerFactory.class)\n+public class GreeHandlerFactory extends BaseThingHandlerFactory {\n+    private @Nullable ServiceRegistration<?> serviceRegistration;\n+    private final GreeTranslationProvider messages;\n+\n+    @Activate\n+    public GreeHandlerFactory(@Reference NetworkAddressService networkAddressService,\n+            @Reference LocaleProvider localeProvider, @Reference TranslationProvider i18nProvider,\n+            ComponentContext componentContext, Map<String, Object> configProperties) {\n+        super.activate(componentContext);\n+\n+        messages = new GreeTranslationProvider(bundleContext.getBundle(), i18nProvider, localeProvider);\n+\n+        String broadcastAddress = networkAddressService.getConfiguredBroadcastAddress();\n+        String defBroadcastIp = broadcastAddress != null ? broadcastAddress : \"\";\n+        GreeDiscoveryService discoveryService = new GreeDiscoveryService(bundleContext.getBundle(), messages,\n+                defBroadcastIp);\n+        this.serviceRegistration = bundleContext.registerService(DiscoveryService.class.getName(), discoveryService,\n+                new Hashtable<String, Object>());\n+        discoveryService.activate();\n+    }\n+\n+    @Override\n+    public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n+        return SUPPORTED_THING_TYPES_UIDS.contains(thingTypeUID);\n+    }\n+\n+    @Override\n+    protected @Nullable ThingHandler createHandler(Thing thing) {\n+        if (THING_TYPE_GREEAIRCON.equals(thing.getThingTypeUID())) {\n+            return new GreeHandler(thing, messages);\n+        }\n+        return null;\n+    }\n+\n+    private synchronized void unregisterDeviceDiscoveryService() {\n+        if (serviceRegistration != null) {\n+            serviceRegistration.unregister();\n+            GreeDiscoveryService discoveryService = (GreeDiscoveryService) bundleContext\n+                    .getService(serviceRegistration.getReference());\n+            if (discoveryService != null) {\n+                discoveryService.deactivate();\n+            }\n+        }\n+    }\n+\n+    public void dispose() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3ODI5MA==", "bodyText": "Is it commented out by intention?", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432878290", "createdAt": "2020-05-30T18:51:06Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,690 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal.discovery;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.StringReader;\r\n+import java.net.DatagramPacket;\r\n+import java.net.DatagramSocket;\r\n+import java.net.InetAddress;\r\n+import java.nio.charset.Charset;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Objects;\r\n+import java.util.Optional;\r\n+\r\n+import org.apache.commons.lang.Validate;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\r\n+import org.openhab.binding.gree.internal.GreeException;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.stream.JsonReader;\r\n+\r\n+/**\r\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\r\n+ * device specific attributes as well a the functionality for the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+// @NonNullByDefault\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3ODUwMA==", "bodyText": "Since we want to get rid of the Apache Commons dependency. Could you replace it by native Java code? See #7722", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432878500", "createdAt": "2020-05-30T18:53:58Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,690 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal.discovery;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.StringReader;\r\n+import java.net.DatagramPacket;\r\n+import java.net.DatagramSocket;\r\n+import java.net.InetAddress;\r\n+import java.nio.charset.Charset;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Objects;\r\n+import java.util.Optional;\r\n+\r\n+import org.apache.commons.lang.Validate;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\r\n+import org.openhab.binding.gree.internal.GreeException;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.stream.JsonReader;\r\n+\r\n+/**\r\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\r\n+ * device specific attributes as well a the functionality for the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+// @NonNullByDefault\r\n+public class GreeAirDevice {\r\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\r\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\r\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\r\n+    private boolean isBound = false;\r\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\r\n+    private int port = 0;\r\n+    private String encKey = \"\";\r\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\r\n+    private GreeBindResponse4GsonDTO bindResponseGson;\r\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\r\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\r\n+\r\n+    public Boolean getIsBound() {\r\n+        return isBound;\r\n+    }\r\n+\r\n+    public void setIsBound(boolean isBound) {\r\n+        this.isBound = isBound;\r\n+    }\r\n+\r\n+    public InetAddress getAddress() {\r\n+        return ipAddress;\r\n+    }\r\n+\r\n+    public void setAddress(InetAddress address) {\r\n+        this.ipAddress = address;\r\n+    }\r\n+\r\n+    public int getPort() {\r\n+        return port;\r\n+    }\r\n+\r\n+    public void setPort(int port) {\r\n+        this.port = port;\r\n+    }\r\n+\r\n+    public String getKey() {\r\n+        return encKey;\r\n+    }\r\n+\r\n+    public String getId() {\r\n+        return mScanResponseGson.packJson.mac;\r\n+    }\r\n+\r\n+    public String getName() {\r\n+        return mScanResponseGson.packJson.name;\r\n+    }\r\n+\r\n+    public String getVendor() {\r\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\r\n+    }\r\n+\r\n+    public String getModel() {\r\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\r\n+    }\r\n+\r\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\r\n+        return mScanResponseGson;\r\n+    }\r\n+\r\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\r\n+        mScanResponseGson = gson;\r\n+    }\r\n+\r\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\r\n+        return bindResponseGson;\r\n+    }\r\n+\r\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\r\n+        return statusResponseGson;\r\n+    }\r\n+\r\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\r\n+        Validate.isTrue(socket.isPresent());\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3OTIxNg==", "bodyText": "Better specify the expected charset.", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432879216", "createdAt": "2020-05-30T19:04:50Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,690 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal.discovery;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.StringReader;\r\n+import java.net.DatagramPacket;\r\n+import java.net.DatagramSocket;\r\n+import java.net.InetAddress;\r\n+import java.nio.charset.Charset;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Objects;\r\n+import java.util.Optional;\r\n+\r\n+import org.apache.commons.lang.Validate;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\r\n+import org.openhab.binding.gree.internal.GreeException;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.stream.JsonReader;\r\n+\r\n+/**\r\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\r\n+ * device specific attributes as well a the functionality for the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+// @NonNullByDefault\r\n+public class GreeAirDevice {\r\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\r\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\r\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\r\n+    private boolean isBound = false;\r\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\r\n+    private int port = 0;\r\n+    private String encKey = \"\";\r\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\r\n+    private GreeBindResponse4GsonDTO bindResponseGson;\r\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\r\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\r\n+\r\n+    public Boolean getIsBound() {\r\n+        return isBound;\r\n+    }\r\n+\r\n+    public void setIsBound(boolean isBound) {\r\n+        this.isBound = isBound;\r\n+    }\r\n+\r\n+    public InetAddress getAddress() {\r\n+        return ipAddress;\r\n+    }\r\n+\r\n+    public void setAddress(InetAddress address) {\r\n+        this.ipAddress = address;\r\n+    }\r\n+\r\n+    public int getPort() {\r\n+        return port;\r\n+    }\r\n+\r\n+    public void setPort(int port) {\r\n+        this.port = port;\r\n+    }\r\n+\r\n+    public String getKey() {\r\n+        return encKey;\r\n+    }\r\n+\r\n+    public String getId() {\r\n+        return mScanResponseGson.packJson.mac;\r\n+    }\r\n+\r\n+    public String getName() {\r\n+        return mScanResponseGson.packJson.name;\r\n+    }\r\n+\r\n+    public String getVendor() {\r\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\r\n+    }\r\n+\r\n+    public String getModel() {\r\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\r\n+    }\r\n+\r\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\r\n+        return mScanResponseGson;\r\n+    }\r\n+\r\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\r\n+        mScanResponseGson = gson;\r\n+    }\r\n+\r\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\r\n+        return bindResponseGson;\r\n+    }\r\n+\r\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\r\n+        return statusResponseGson;\r\n+    }\r\n+\r\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\r\n+        Validate.isTrue(socket.isPresent());\r\n+        byte[] sendData = new byte[1024];\r\n+        byte[] receiveData = new byte[347];\r\n+        Gson gson = new Gson();\r\n+\r\n+        try {\r\n+            // Prep the Binding Request pack\r\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\r\n+            bindReqPackGson.mac = getId();\r\n+            bindReqPackGson.t = \"bind\";\r\n+            bindReqPackGson.uid = 0;\r\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\r\n+\r\n+            // Now Encrypt the Binding Request pack\r\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindReqPackStr);\r\n+\r\n+            // Prep the Binding Request\r\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\r\n+            bindReqGson.cid = \"app\";\r\n+            bindReqGson.i = 1;\r\n+            bindReqGson.t = \"pack\";\r\n+            bindReqGson.uid = 0;\r\n+            bindReqGson.tcid = getId();\r\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\r\n+            String bindReqStr = gson.toJson(bindReqGson);\r\n+            sendData = bindReqStr.getBytes();\r\n+\r\n+            // Now Send the request\r\n+            DatagramSocket clientSocket = socket.get();\r\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\r\n+            clientSocket.send(sendPacket);\r\n+\r\n+            // Recieve a response\r\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\r\n+            clientSocket.receive(receivePacket);\r\n+            String modifiedSentence = new String(receivePacket.getData());\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 169}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3OTM0Nw==", "bodyText": "Can the return type be a primitive boolean?", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432879347", "createdAt": "2020-05-30T19:06:33Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,690 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal.discovery;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.StringReader;\r\n+import java.net.DatagramPacket;\r\n+import java.net.DatagramSocket;\r\n+import java.net.InetAddress;\r\n+import java.nio.charset.Charset;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Objects;\r\n+import java.util.Optional;\r\n+\r\n+import org.apache.commons.lang.Validate;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\r\n+import org.openhab.binding.gree.internal.GreeException;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.stream.JsonReader;\r\n+\r\n+/**\r\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\r\n+ * device specific attributes as well a the functionality for the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+// @NonNullByDefault\r\n+public class GreeAirDevice {\r\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\r\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\r\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\r\n+    private boolean isBound = false;\r\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\r\n+    private int port = 0;\r\n+    private String encKey = \"\";\r\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\r\n+    private GreeBindResponse4GsonDTO bindResponseGson;\r\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\r\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\r\n+\r\n+    public Boolean getIsBound() {\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3OTQ1MQ==", "bodyText": "This could be simplified regardless of using primitve or complex types. Java will auto box it.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\n          \n          \n            \n                    if (!getIsBound() || value < 0 || value > 1) {", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432879451", "createdAt": "2020-05-30T19:07:53Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,690 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal.discovery;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.StringReader;\r\n+import java.net.DatagramPacket;\r\n+import java.net.DatagramSocket;\r\n+import java.net.InetAddress;\r\n+import java.nio.charset.Charset;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Objects;\r\n+import java.util.Optional;\r\n+\r\n+import org.apache.commons.lang.Validate;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\r\n+import org.openhab.binding.gree.internal.GreeException;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.stream.JsonReader;\r\n+\r\n+/**\r\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\r\n+ * device specific attributes as well a the functionality for the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+// @NonNullByDefault\r\n+public class GreeAirDevice {\r\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\r\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\r\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\r\n+    private boolean isBound = false;\r\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\r\n+    private int port = 0;\r\n+    private String encKey = \"\";\r\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\r\n+    private GreeBindResponse4GsonDTO bindResponseGson;\r\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\r\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\r\n+\r\n+    public Boolean getIsBound() {\r\n+        return isBound;\r\n+    }\r\n+\r\n+    public void setIsBound(boolean isBound) {\r\n+        this.isBound = isBound;\r\n+    }\r\n+\r\n+    public InetAddress getAddress() {\r\n+        return ipAddress;\r\n+    }\r\n+\r\n+    public void setAddress(InetAddress address) {\r\n+        this.ipAddress = address;\r\n+    }\r\n+\r\n+    public int getPort() {\r\n+        return port;\r\n+    }\r\n+\r\n+    public void setPort(int port) {\r\n+        this.port = port;\r\n+    }\r\n+\r\n+    public String getKey() {\r\n+        return encKey;\r\n+    }\r\n+\r\n+    public String getId() {\r\n+        return mScanResponseGson.packJson.mac;\r\n+    }\r\n+\r\n+    public String getName() {\r\n+        return mScanResponseGson.packJson.name;\r\n+    }\r\n+\r\n+    public String getVendor() {\r\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\r\n+    }\r\n+\r\n+    public String getModel() {\r\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\r\n+    }\r\n+\r\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\r\n+        return mScanResponseGson;\r\n+    }\r\n+\r\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\r\n+        mScanResponseGson = gson;\r\n+    }\r\n+\r\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\r\n+        return bindResponseGson;\r\n+    }\r\n+\r\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\r\n+        return statusResponseGson;\r\n+    }\r\n+\r\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\r\n+        Validate.isTrue(socket.isPresent());\r\n+        byte[] sendData = new byte[1024];\r\n+        byte[] receiveData = new byte[347];\r\n+        Gson gson = new Gson();\r\n+\r\n+        try {\r\n+            // Prep the Binding Request pack\r\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\r\n+            bindReqPackGson.mac = getId();\r\n+            bindReqPackGson.t = \"bind\";\r\n+            bindReqPackGson.uid = 0;\r\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\r\n+\r\n+            // Now Encrypt the Binding Request pack\r\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindReqPackStr);\r\n+\r\n+            // Prep the Binding Request\r\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\r\n+            bindReqGson.cid = \"app\";\r\n+            bindReqGson.i = 1;\r\n+            bindReqGson.t = \"pack\";\r\n+            bindReqGson.uid = 0;\r\n+            bindReqGson.tcid = getId();\r\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\r\n+            String bindReqStr = gson.toJson(bindReqGson);\r\n+            sendData = bindReqStr.getBytes();\r\n+\r\n+            // Now Send the request\r\n+            DatagramSocket clientSocket = socket.get();\r\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\r\n+            clientSocket.send(sendPacket);\r\n+\r\n+            // Recieve a response\r\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\r\n+            clientSocket.receive(receivePacket);\r\n+            String modifiedSentence = new String(receivePacket.getData());\r\n+\r\n+            // Read the response\r\n+            StringReader stringReader = new StringReader(modifiedSentence);\r\n+            bindResponseGson = gson.fromJson(new JsonReader(stringReader), GreeBindResponse4GsonDTO.class);\r\n+            bindResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindResponseGson.pack);\r\n+\r\n+            // Create the JSON to hold the response values\r\n+            stringReader = new StringReader(bindResponseGson.decryptedPack);\r\n+            bindResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePack4GsonDTO.class);\r\n+\r\n+            // Now set the key and flag to indicate the bind was succesful\r\n+            encKey = bindResponseGson.packJson.key;\r\n+            setIsBound(true);\r\n+        } catch (IOException e) {\r\n+            throw new GreeException(e, \"failed\");\r\n+        }\r\n+    }\r\n+\r\n+    public void setDevicePower(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 191}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3OTU2MQ==", "bodyText": "See above", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432879561", "createdAt": "2020-05-30T19:09:50Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,690 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal.discovery;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.StringReader;\r\n+import java.net.DatagramPacket;\r\n+import java.net.DatagramSocket;\r\n+import java.net.InetAddress;\r\n+import java.nio.charset.Charset;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Objects;\r\n+import java.util.Optional;\r\n+\r\n+import org.apache.commons.lang.Validate;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\r\n+import org.openhab.binding.gree.internal.GreeException;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.stream.JsonReader;\r\n+\r\n+/**\r\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\r\n+ * device specific attributes as well a the functionality for the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+// @NonNullByDefault\r\n+public class GreeAirDevice {\r\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\r\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\r\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\r\n+    private boolean isBound = false;\r\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\r\n+    private int port = 0;\r\n+    private String encKey = \"\";\r\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\r\n+    private GreeBindResponse4GsonDTO bindResponseGson;\r\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\r\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\r\n+\r\n+    public Boolean getIsBound() {\r\n+        return isBound;\r\n+    }\r\n+\r\n+    public void setIsBound(boolean isBound) {\r\n+        this.isBound = isBound;\r\n+    }\r\n+\r\n+    public InetAddress getAddress() {\r\n+        return ipAddress;\r\n+    }\r\n+\r\n+    public void setAddress(InetAddress address) {\r\n+        this.ipAddress = address;\r\n+    }\r\n+\r\n+    public int getPort() {\r\n+        return port;\r\n+    }\r\n+\r\n+    public void setPort(int port) {\r\n+        this.port = port;\r\n+    }\r\n+\r\n+    public String getKey() {\r\n+        return encKey;\r\n+    }\r\n+\r\n+    public String getId() {\r\n+        return mScanResponseGson.packJson.mac;\r\n+    }\r\n+\r\n+    public String getName() {\r\n+        return mScanResponseGson.packJson.name;\r\n+    }\r\n+\r\n+    public String getVendor() {\r\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\r\n+    }\r\n+\r\n+    public String getModel() {\r\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\r\n+    }\r\n+\r\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\r\n+        return mScanResponseGson;\r\n+    }\r\n+\r\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\r\n+        mScanResponseGson = gson;\r\n+    }\r\n+\r\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\r\n+        return bindResponseGson;\r\n+    }\r\n+\r\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\r\n+        return statusResponseGson;\r\n+    }\r\n+\r\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\r\n+        Validate.isTrue(socket.isPresent());\r\n+        byte[] sendData = new byte[1024];\r\n+        byte[] receiveData = new byte[347];\r\n+        Gson gson = new Gson();\r\n+\r\n+        try {\r\n+            // Prep the Binding Request pack\r\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\r\n+            bindReqPackGson.mac = getId();\r\n+            bindReqPackGson.t = \"bind\";\r\n+            bindReqPackGson.uid = 0;\r\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\r\n+\r\n+            // Now Encrypt the Binding Request pack\r\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindReqPackStr);\r\n+\r\n+            // Prep the Binding Request\r\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\r\n+            bindReqGson.cid = \"app\";\r\n+            bindReqGson.i = 1;\r\n+            bindReqGson.t = \"pack\";\r\n+            bindReqGson.uid = 0;\r\n+            bindReqGson.tcid = getId();\r\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\r\n+            String bindReqStr = gson.toJson(bindReqGson);\r\n+            sendData = bindReqStr.getBytes();\r\n+\r\n+            // Now Send the request\r\n+            DatagramSocket clientSocket = socket.get();\r\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\r\n+            clientSocket.send(sendPacket);\r\n+\r\n+            // Recieve a response\r\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\r\n+            clientSocket.receive(receivePacket);\r\n+            String modifiedSentence = new String(receivePacket.getData());\r\n+\r\n+            // Read the response\r\n+            StringReader stringReader = new StringReader(modifiedSentence);\r\n+            bindResponseGson = gson.fromJson(new JsonReader(stringReader), GreeBindResponse4GsonDTO.class);\r\n+            bindResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindResponseGson.pack);\r\n+\r\n+            // Create the JSON to hold the response values\r\n+            stringReader = new StringReader(bindResponseGson.decryptedPack);\r\n+            bindResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePack4GsonDTO.class);\r\n+\r\n+            // Now set the key and flag to indicate the bind was succesful\r\n+            encKey = bindResponseGson.packJson.key;\r\n+            setIsBound(true);\r\n+        } catch (IOException e) {\r\n+            throw new GreeException(e, \"failed\");\r\n+        }\r\n+    }\r\n+\r\n+    public void setDevicePower(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Pow\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void SetDeviceMode(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 4)) {\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 203}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3OTY0MA==", "bodyText": "See above", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432879640", "createdAt": "2020-05-30T19:11:09Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,690 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal.discovery;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.StringReader;\r\n+import java.net.DatagramPacket;\r\n+import java.net.DatagramSocket;\r\n+import java.net.InetAddress;\r\n+import java.nio.charset.Charset;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Objects;\r\n+import java.util.Optional;\r\n+\r\n+import org.apache.commons.lang.Validate;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\r\n+import org.openhab.binding.gree.internal.GreeException;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.stream.JsonReader;\r\n+\r\n+/**\r\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\r\n+ * device specific attributes as well a the functionality for the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+// @NonNullByDefault\r\n+public class GreeAirDevice {\r\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\r\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\r\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\r\n+    private boolean isBound = false;\r\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\r\n+    private int port = 0;\r\n+    private String encKey = \"\";\r\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\r\n+    private GreeBindResponse4GsonDTO bindResponseGson;\r\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\r\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\r\n+\r\n+    public Boolean getIsBound() {\r\n+        return isBound;\r\n+    }\r\n+\r\n+    public void setIsBound(boolean isBound) {\r\n+        this.isBound = isBound;\r\n+    }\r\n+\r\n+    public InetAddress getAddress() {\r\n+        return ipAddress;\r\n+    }\r\n+\r\n+    public void setAddress(InetAddress address) {\r\n+        this.ipAddress = address;\r\n+    }\r\n+\r\n+    public int getPort() {\r\n+        return port;\r\n+    }\r\n+\r\n+    public void setPort(int port) {\r\n+        this.port = port;\r\n+    }\r\n+\r\n+    public String getKey() {\r\n+        return encKey;\r\n+    }\r\n+\r\n+    public String getId() {\r\n+        return mScanResponseGson.packJson.mac;\r\n+    }\r\n+\r\n+    public String getName() {\r\n+        return mScanResponseGson.packJson.name;\r\n+    }\r\n+\r\n+    public String getVendor() {\r\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\r\n+    }\r\n+\r\n+    public String getModel() {\r\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\r\n+    }\r\n+\r\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\r\n+        return mScanResponseGson;\r\n+    }\r\n+\r\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\r\n+        mScanResponseGson = gson;\r\n+    }\r\n+\r\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\r\n+        return bindResponseGson;\r\n+    }\r\n+\r\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\r\n+        return statusResponseGson;\r\n+    }\r\n+\r\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\r\n+        Validate.isTrue(socket.isPresent());\r\n+        byte[] sendData = new byte[1024];\r\n+        byte[] receiveData = new byte[347];\r\n+        Gson gson = new Gson();\r\n+\r\n+        try {\r\n+            // Prep the Binding Request pack\r\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\r\n+            bindReqPackGson.mac = getId();\r\n+            bindReqPackGson.t = \"bind\";\r\n+            bindReqPackGson.uid = 0;\r\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\r\n+\r\n+            // Now Encrypt the Binding Request pack\r\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindReqPackStr);\r\n+\r\n+            // Prep the Binding Request\r\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\r\n+            bindReqGson.cid = \"app\";\r\n+            bindReqGson.i = 1;\r\n+            bindReqGson.t = \"pack\";\r\n+            bindReqGson.uid = 0;\r\n+            bindReqGson.tcid = getId();\r\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\r\n+            String bindReqStr = gson.toJson(bindReqGson);\r\n+            sendData = bindReqStr.getBytes();\r\n+\r\n+            // Now Send the request\r\n+            DatagramSocket clientSocket = socket.get();\r\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\r\n+            clientSocket.send(sendPacket);\r\n+\r\n+            // Recieve a response\r\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\r\n+            clientSocket.receive(receivePacket);\r\n+            String modifiedSentence = new String(receivePacket.getData());\r\n+\r\n+            // Read the response\r\n+            StringReader stringReader = new StringReader(modifiedSentence);\r\n+            bindResponseGson = gson.fromJson(new JsonReader(stringReader), GreeBindResponse4GsonDTO.class);\r\n+            bindResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindResponseGson.pack);\r\n+\r\n+            // Create the JSON to hold the response values\r\n+            stringReader = new StringReader(bindResponseGson.decryptedPack);\r\n+            bindResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePack4GsonDTO.class);\r\n+\r\n+            // Now set the key and flag to indicate the bind was succesful\r\n+            encKey = bindResponseGson.packJson.key;\r\n+            setIsBound(true);\r\n+        } catch (IOException e) {\r\n+            throw new GreeException(e, \"failed\");\r\n+        }\r\n+    }\r\n+\r\n+    public void setDevicePower(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Pow\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void SetDeviceMode(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 4)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Mod\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceSwingVertical(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 11)\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 216}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3OTcyMw==", "bodyText": "It's better to use primitive types than complex ones.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void setDevicePower(DatagramSocket clientSocket, Integer value) throws GreeException {\n          \n          \n            \n                public void setDevicePower(DatagramSocket clientSocket, int value) throws GreeException {", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432879723", "createdAt": "2020-05-30T19:12:26Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,690 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal.discovery;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.StringReader;\r\n+import java.net.DatagramPacket;\r\n+import java.net.DatagramSocket;\r\n+import java.net.InetAddress;\r\n+import java.nio.charset.Charset;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Objects;\r\n+import java.util.Optional;\r\n+\r\n+import org.apache.commons.lang.Validate;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\r\n+import org.openhab.binding.gree.internal.GreeException;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.stream.JsonReader;\r\n+\r\n+/**\r\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\r\n+ * device specific attributes as well a the functionality for the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+// @NonNullByDefault\r\n+public class GreeAirDevice {\r\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\r\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\r\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\r\n+    private boolean isBound = false;\r\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\r\n+    private int port = 0;\r\n+    private String encKey = \"\";\r\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\r\n+    private GreeBindResponse4GsonDTO bindResponseGson;\r\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\r\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\r\n+\r\n+    public Boolean getIsBound() {\r\n+        return isBound;\r\n+    }\r\n+\r\n+    public void setIsBound(boolean isBound) {\r\n+        this.isBound = isBound;\r\n+    }\r\n+\r\n+    public InetAddress getAddress() {\r\n+        return ipAddress;\r\n+    }\r\n+\r\n+    public void setAddress(InetAddress address) {\r\n+        this.ipAddress = address;\r\n+    }\r\n+\r\n+    public int getPort() {\r\n+        return port;\r\n+    }\r\n+\r\n+    public void setPort(int port) {\r\n+        this.port = port;\r\n+    }\r\n+\r\n+    public String getKey() {\r\n+        return encKey;\r\n+    }\r\n+\r\n+    public String getId() {\r\n+        return mScanResponseGson.packJson.mac;\r\n+    }\r\n+\r\n+    public String getName() {\r\n+        return mScanResponseGson.packJson.name;\r\n+    }\r\n+\r\n+    public String getVendor() {\r\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\r\n+    }\r\n+\r\n+    public String getModel() {\r\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\r\n+    }\r\n+\r\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\r\n+        return mScanResponseGson;\r\n+    }\r\n+\r\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\r\n+        mScanResponseGson = gson;\r\n+    }\r\n+\r\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\r\n+        return bindResponseGson;\r\n+    }\r\n+\r\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\r\n+        return statusResponseGson;\r\n+    }\r\n+\r\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\r\n+        Validate.isTrue(socket.isPresent());\r\n+        byte[] sendData = new byte[1024];\r\n+        byte[] receiveData = new byte[347];\r\n+        Gson gson = new Gson();\r\n+\r\n+        try {\r\n+            // Prep the Binding Request pack\r\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\r\n+            bindReqPackGson.mac = getId();\r\n+            bindReqPackGson.t = \"bind\";\r\n+            bindReqPackGson.uid = 0;\r\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\r\n+\r\n+            // Now Encrypt the Binding Request pack\r\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindReqPackStr);\r\n+\r\n+            // Prep the Binding Request\r\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\r\n+            bindReqGson.cid = \"app\";\r\n+            bindReqGson.i = 1;\r\n+            bindReqGson.t = \"pack\";\r\n+            bindReqGson.uid = 0;\r\n+            bindReqGson.tcid = getId();\r\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\r\n+            String bindReqStr = gson.toJson(bindReqGson);\r\n+            sendData = bindReqStr.getBytes();\r\n+\r\n+            // Now Send the request\r\n+            DatagramSocket clientSocket = socket.get();\r\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\r\n+            clientSocket.send(sendPacket);\r\n+\r\n+            // Recieve a response\r\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\r\n+            clientSocket.receive(receivePacket);\r\n+            String modifiedSentence = new String(receivePacket.getData());\r\n+\r\n+            // Read the response\r\n+            StringReader stringReader = new StringReader(modifiedSentence);\r\n+            bindResponseGson = gson.fromJson(new JsonReader(stringReader), GreeBindResponse4GsonDTO.class);\r\n+            bindResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindResponseGson.pack);\r\n+\r\n+            // Create the JSON to hold the response values\r\n+            stringReader = new StringReader(bindResponseGson.decryptedPack);\r\n+            bindResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePack4GsonDTO.class);\r\n+\r\n+            // Now set the key and flag to indicate the bind was succesful\r\n+            encKey = bindResponseGson.packJson.key;\r\n+            setIsBound(true);\r\n+        } catch (IOException e) {\r\n+            throw new GreeException(e, \"failed\");\r\n+        }\r\n+    }\r\n+\r\n+    public void setDevicePower(DatagramSocket clientSocket, Integer value) throws GreeException {\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 189}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3OTg0Nw==", "bodyText": "See above", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432879847", "createdAt": "2020-05-30T19:14:13Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,690 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal.discovery;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.StringReader;\r\n+import java.net.DatagramPacket;\r\n+import java.net.DatagramSocket;\r\n+import java.net.InetAddress;\r\n+import java.nio.charset.Charset;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Objects;\r\n+import java.util.Optional;\r\n+\r\n+import org.apache.commons.lang.Validate;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\r\n+import org.openhab.binding.gree.internal.GreeException;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.stream.JsonReader;\r\n+\r\n+/**\r\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\r\n+ * device specific attributes as well a the functionality for the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+// @NonNullByDefault\r\n+public class GreeAirDevice {\r\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\r\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\r\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\r\n+    private boolean isBound = false;\r\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\r\n+    private int port = 0;\r\n+    private String encKey = \"\";\r\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\r\n+    private GreeBindResponse4GsonDTO bindResponseGson;\r\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\r\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\r\n+\r\n+    public Boolean getIsBound() {\r\n+        return isBound;\r\n+    }\r\n+\r\n+    public void setIsBound(boolean isBound) {\r\n+        this.isBound = isBound;\r\n+    }\r\n+\r\n+    public InetAddress getAddress() {\r\n+        return ipAddress;\r\n+    }\r\n+\r\n+    public void setAddress(InetAddress address) {\r\n+        this.ipAddress = address;\r\n+    }\r\n+\r\n+    public int getPort() {\r\n+        return port;\r\n+    }\r\n+\r\n+    public void setPort(int port) {\r\n+        this.port = port;\r\n+    }\r\n+\r\n+    public String getKey() {\r\n+        return encKey;\r\n+    }\r\n+\r\n+    public String getId() {\r\n+        return mScanResponseGson.packJson.mac;\r\n+    }\r\n+\r\n+    public String getName() {\r\n+        return mScanResponseGson.packJson.name;\r\n+    }\r\n+\r\n+    public String getVendor() {\r\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\r\n+    }\r\n+\r\n+    public String getModel() {\r\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\r\n+    }\r\n+\r\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\r\n+        return mScanResponseGson;\r\n+    }\r\n+\r\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\r\n+        mScanResponseGson = gson;\r\n+    }\r\n+\r\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\r\n+        return bindResponseGson;\r\n+    }\r\n+\r\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\r\n+        return statusResponseGson;\r\n+    }\r\n+\r\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\r\n+        Validate.isTrue(socket.isPresent());\r\n+        byte[] sendData = new byte[1024];\r\n+        byte[] receiveData = new byte[347];\r\n+        Gson gson = new Gson();\r\n+\r\n+        try {\r\n+            // Prep the Binding Request pack\r\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\r\n+            bindReqPackGson.mac = getId();\r\n+            bindReqPackGson.t = \"bind\";\r\n+            bindReqPackGson.uid = 0;\r\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\r\n+\r\n+            // Now Encrypt the Binding Request pack\r\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindReqPackStr);\r\n+\r\n+            // Prep the Binding Request\r\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\r\n+            bindReqGson.cid = \"app\";\r\n+            bindReqGson.i = 1;\r\n+            bindReqGson.t = \"pack\";\r\n+            bindReqGson.uid = 0;\r\n+            bindReqGson.tcid = getId();\r\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\r\n+            String bindReqStr = gson.toJson(bindReqGson);\r\n+            sendData = bindReqStr.getBytes();\r\n+\r\n+            // Now Send the request\r\n+            DatagramSocket clientSocket = socket.get();\r\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\r\n+            clientSocket.send(sendPacket);\r\n+\r\n+            // Recieve a response\r\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\r\n+            clientSocket.receive(receivePacket);\r\n+            String modifiedSentence = new String(receivePacket.getData());\r\n+\r\n+            // Read the response\r\n+            StringReader stringReader = new StringReader(modifiedSentence);\r\n+            bindResponseGson = gson.fromJson(new JsonReader(stringReader), GreeBindResponse4GsonDTO.class);\r\n+            bindResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindResponseGson.pack);\r\n+\r\n+            // Create the JSON to hold the response values\r\n+            stringReader = new StringReader(bindResponseGson.decryptedPack);\r\n+            bindResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePack4GsonDTO.class);\r\n+\r\n+            // Now set the key and flag to indicate the bind was succesful\r\n+            encKey = bindResponseGson.packJson.key;\r\n+            setIsBound(true);\r\n+        } catch (IOException e) {\r\n+            throw new GreeException(e, \"failed\");\r\n+        }\r\n+    }\r\n+\r\n+    public void setDevicePower(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Pow\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void SetDeviceMode(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 4)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Mod\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceSwingVertical(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 11)\r\n+                || (value.intValue() > 6 && value.intValue() < 10)) {\r\n+            return;\r\n+        }\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"SwUpDn\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Only allow this to happen if this device has been bound and values are valid\r\n+     * Possible values are :\r\n+     * 0 : Auto\r\n+     * 1 : Low\r\n+     * 2 : Medium Low\r\n+     * 3 : Medium\r\n+     * 4 : Medium High\r\n+     * 5 : High\r\n+     */\r\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 5)) {\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 237}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3OTg1Ng==", "bodyText": "See above", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432879856", "createdAt": "2020-05-30T19:14:30Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,690 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal.discovery;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.StringReader;\r\n+import java.net.DatagramPacket;\r\n+import java.net.DatagramSocket;\r\n+import java.net.InetAddress;\r\n+import java.nio.charset.Charset;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Objects;\r\n+import java.util.Optional;\r\n+\r\n+import org.apache.commons.lang.Validate;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\r\n+import org.openhab.binding.gree.internal.GreeException;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.stream.JsonReader;\r\n+\r\n+/**\r\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\r\n+ * device specific attributes as well a the functionality for the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+// @NonNullByDefault\r\n+public class GreeAirDevice {\r\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\r\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\r\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\r\n+    private boolean isBound = false;\r\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\r\n+    private int port = 0;\r\n+    private String encKey = \"\";\r\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\r\n+    private GreeBindResponse4GsonDTO bindResponseGson;\r\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\r\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\r\n+\r\n+    public Boolean getIsBound() {\r\n+        return isBound;\r\n+    }\r\n+\r\n+    public void setIsBound(boolean isBound) {\r\n+        this.isBound = isBound;\r\n+    }\r\n+\r\n+    public InetAddress getAddress() {\r\n+        return ipAddress;\r\n+    }\r\n+\r\n+    public void setAddress(InetAddress address) {\r\n+        this.ipAddress = address;\r\n+    }\r\n+\r\n+    public int getPort() {\r\n+        return port;\r\n+    }\r\n+\r\n+    public void setPort(int port) {\r\n+        this.port = port;\r\n+    }\r\n+\r\n+    public String getKey() {\r\n+        return encKey;\r\n+    }\r\n+\r\n+    public String getId() {\r\n+        return mScanResponseGson.packJson.mac;\r\n+    }\r\n+\r\n+    public String getName() {\r\n+        return mScanResponseGson.packJson.name;\r\n+    }\r\n+\r\n+    public String getVendor() {\r\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\r\n+    }\r\n+\r\n+    public String getModel() {\r\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\r\n+    }\r\n+\r\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\r\n+        return mScanResponseGson;\r\n+    }\r\n+\r\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\r\n+        mScanResponseGson = gson;\r\n+    }\r\n+\r\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\r\n+        return bindResponseGson;\r\n+    }\r\n+\r\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\r\n+        return statusResponseGson;\r\n+    }\r\n+\r\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\r\n+        Validate.isTrue(socket.isPresent());\r\n+        byte[] sendData = new byte[1024];\r\n+        byte[] receiveData = new byte[347];\r\n+        Gson gson = new Gson();\r\n+\r\n+        try {\r\n+            // Prep the Binding Request pack\r\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\r\n+            bindReqPackGson.mac = getId();\r\n+            bindReqPackGson.t = \"bind\";\r\n+            bindReqPackGson.uid = 0;\r\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\r\n+\r\n+            // Now Encrypt the Binding Request pack\r\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindReqPackStr);\r\n+\r\n+            // Prep the Binding Request\r\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\r\n+            bindReqGson.cid = \"app\";\r\n+            bindReqGson.i = 1;\r\n+            bindReqGson.t = \"pack\";\r\n+            bindReqGson.uid = 0;\r\n+            bindReqGson.tcid = getId();\r\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\r\n+            String bindReqStr = gson.toJson(bindReqGson);\r\n+            sendData = bindReqStr.getBytes();\r\n+\r\n+            // Now Send the request\r\n+            DatagramSocket clientSocket = socket.get();\r\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\r\n+            clientSocket.send(sendPacket);\r\n+\r\n+            // Recieve a response\r\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\r\n+            clientSocket.receive(receivePacket);\r\n+            String modifiedSentence = new String(receivePacket.getData());\r\n+\r\n+            // Read the response\r\n+            StringReader stringReader = new StringReader(modifiedSentence);\r\n+            bindResponseGson = gson.fromJson(new JsonReader(stringReader), GreeBindResponse4GsonDTO.class);\r\n+            bindResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindResponseGson.pack);\r\n+\r\n+            // Create the JSON to hold the response values\r\n+            stringReader = new StringReader(bindResponseGson.decryptedPack);\r\n+            bindResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePack4GsonDTO.class);\r\n+\r\n+            // Now set the key and flag to indicate the bind was succesful\r\n+            encKey = bindResponseGson.packJson.key;\r\n+            setIsBound(true);\r\n+        } catch (IOException e) {\r\n+            throw new GreeException(e, \"failed\");\r\n+        }\r\n+    }\r\n+\r\n+    public void setDevicePower(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Pow\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void SetDeviceMode(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 4)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Mod\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceSwingVertical(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 11)\r\n+                || (value.intValue() > 6 && value.intValue() < 10)) {\r\n+            return;\r\n+        }\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"SwUpDn\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Only allow this to happen if this device has been bound and values are valid\r\n+     * Possible values are :\r\n+     * 0 : Auto\r\n+     * 1 : Low\r\n+     * 2 : Medium Low\r\n+     * 3 : Medium\r\n+     * 4 : Medium High\r\n+     * 5 : High\r\n+     */\r\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 5)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"WdSpd\", value);\r\n+        parameters.put(\"Quiet\", 0);\r\n+        parameters.put(\"Tur\", 0);\r\n+        parameters.put(\"NoiseSet\", 0);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceTurbo(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 252}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3OTg2Nw==", "bodyText": "See above", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432879867", "createdAt": "2020-05-30T19:14:45Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,690 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal.discovery;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.StringReader;\r\n+import java.net.DatagramPacket;\r\n+import java.net.DatagramSocket;\r\n+import java.net.InetAddress;\r\n+import java.nio.charset.Charset;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Objects;\r\n+import java.util.Optional;\r\n+\r\n+import org.apache.commons.lang.Validate;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\r\n+import org.openhab.binding.gree.internal.GreeException;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.stream.JsonReader;\r\n+\r\n+/**\r\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\r\n+ * device specific attributes as well a the functionality for the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+// @NonNullByDefault\r\n+public class GreeAirDevice {\r\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\r\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\r\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\r\n+    private boolean isBound = false;\r\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\r\n+    private int port = 0;\r\n+    private String encKey = \"\";\r\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\r\n+    private GreeBindResponse4GsonDTO bindResponseGson;\r\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\r\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\r\n+\r\n+    public Boolean getIsBound() {\r\n+        return isBound;\r\n+    }\r\n+\r\n+    public void setIsBound(boolean isBound) {\r\n+        this.isBound = isBound;\r\n+    }\r\n+\r\n+    public InetAddress getAddress() {\r\n+        return ipAddress;\r\n+    }\r\n+\r\n+    public void setAddress(InetAddress address) {\r\n+        this.ipAddress = address;\r\n+    }\r\n+\r\n+    public int getPort() {\r\n+        return port;\r\n+    }\r\n+\r\n+    public void setPort(int port) {\r\n+        this.port = port;\r\n+    }\r\n+\r\n+    public String getKey() {\r\n+        return encKey;\r\n+    }\r\n+\r\n+    public String getId() {\r\n+        return mScanResponseGson.packJson.mac;\r\n+    }\r\n+\r\n+    public String getName() {\r\n+        return mScanResponseGson.packJson.name;\r\n+    }\r\n+\r\n+    public String getVendor() {\r\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\r\n+    }\r\n+\r\n+    public String getModel() {\r\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\r\n+    }\r\n+\r\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\r\n+        return mScanResponseGson;\r\n+    }\r\n+\r\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\r\n+        mScanResponseGson = gson;\r\n+    }\r\n+\r\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\r\n+        return bindResponseGson;\r\n+    }\r\n+\r\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\r\n+        return statusResponseGson;\r\n+    }\r\n+\r\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\r\n+        Validate.isTrue(socket.isPresent());\r\n+        byte[] sendData = new byte[1024];\r\n+        byte[] receiveData = new byte[347];\r\n+        Gson gson = new Gson();\r\n+\r\n+        try {\r\n+            // Prep the Binding Request pack\r\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\r\n+            bindReqPackGson.mac = getId();\r\n+            bindReqPackGson.t = \"bind\";\r\n+            bindReqPackGson.uid = 0;\r\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\r\n+\r\n+            // Now Encrypt the Binding Request pack\r\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindReqPackStr);\r\n+\r\n+            // Prep the Binding Request\r\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\r\n+            bindReqGson.cid = \"app\";\r\n+            bindReqGson.i = 1;\r\n+            bindReqGson.t = \"pack\";\r\n+            bindReqGson.uid = 0;\r\n+            bindReqGson.tcid = getId();\r\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\r\n+            String bindReqStr = gson.toJson(bindReqGson);\r\n+            sendData = bindReqStr.getBytes();\r\n+\r\n+            // Now Send the request\r\n+            DatagramSocket clientSocket = socket.get();\r\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\r\n+            clientSocket.send(sendPacket);\r\n+\r\n+            // Recieve a response\r\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\r\n+            clientSocket.receive(receivePacket);\r\n+            String modifiedSentence = new String(receivePacket.getData());\r\n+\r\n+            // Read the response\r\n+            StringReader stringReader = new StringReader(modifiedSentence);\r\n+            bindResponseGson = gson.fromJson(new JsonReader(stringReader), GreeBindResponse4GsonDTO.class);\r\n+            bindResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindResponseGson.pack);\r\n+\r\n+            // Create the JSON to hold the response values\r\n+            stringReader = new StringReader(bindResponseGson.decryptedPack);\r\n+            bindResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePack4GsonDTO.class);\r\n+\r\n+            // Now set the key and flag to indicate the bind was succesful\r\n+            encKey = bindResponseGson.packJson.key;\r\n+            setIsBound(true);\r\n+        } catch (IOException e) {\r\n+            throw new GreeException(e, \"failed\");\r\n+        }\r\n+    }\r\n+\r\n+    public void setDevicePower(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Pow\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void SetDeviceMode(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 4)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Mod\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceSwingVertical(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 11)\r\n+                || (value.intValue() > 6 && value.intValue() < 10)) {\r\n+            return;\r\n+        }\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"SwUpDn\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Only allow this to happen if this device has been bound and values are valid\r\n+     * Possible values are :\r\n+     * 0 : Auto\r\n+     * 1 : Low\r\n+     * 2 : Medium Low\r\n+     * 3 : Medium\r\n+     * 4 : Medium High\r\n+     * 5 : High\r\n+     */\r\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 5)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"WdSpd\", value);\r\n+        parameters.put(\"Quiet\", 0);\r\n+        parameters.put(\"Tur\", 0);\r\n+        parameters.put(\"NoiseSet\", 0);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceTurbo(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Tur\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public int getDeviceTurbo() {\r\n+        return getIntStatusVal(\"Tur\");\r\n+    }\r\n+\r\n+    public void setDeviceLight(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 268}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg3OTk4Mw==", "bodyText": "Auto-boxing\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    hmf.put(\"min\", new Integer(61)); // F\n          \n          \n            \n                    hmf.put(\"min\", 61); // F", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432879983", "createdAt": "2020-05-30T19:16:00Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,690 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal.discovery;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.StringReader;\r\n+import java.net.DatagramPacket;\r\n+import java.net.DatagramSocket;\r\n+import java.net.InetAddress;\r\n+import java.nio.charset.Charset;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Objects;\r\n+import java.util.Optional;\r\n+\r\n+import org.apache.commons.lang.Validate;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\r\n+import org.openhab.binding.gree.internal.GreeException;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.stream.JsonReader;\r\n+\r\n+/**\r\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\r\n+ * device specific attributes as well a the functionality for the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+// @NonNullByDefault\r\n+public class GreeAirDevice {\r\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\r\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\r\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\r\n+    private boolean isBound = false;\r\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\r\n+    private int port = 0;\r\n+    private String encKey = \"\";\r\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\r\n+    private GreeBindResponse4GsonDTO bindResponseGson;\r\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\r\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\r\n+\r\n+    public Boolean getIsBound() {\r\n+        return isBound;\r\n+    }\r\n+\r\n+    public void setIsBound(boolean isBound) {\r\n+        this.isBound = isBound;\r\n+    }\r\n+\r\n+    public InetAddress getAddress() {\r\n+        return ipAddress;\r\n+    }\r\n+\r\n+    public void setAddress(InetAddress address) {\r\n+        this.ipAddress = address;\r\n+    }\r\n+\r\n+    public int getPort() {\r\n+        return port;\r\n+    }\r\n+\r\n+    public void setPort(int port) {\r\n+        this.port = port;\r\n+    }\r\n+\r\n+    public String getKey() {\r\n+        return encKey;\r\n+    }\r\n+\r\n+    public String getId() {\r\n+        return mScanResponseGson.packJson.mac;\r\n+    }\r\n+\r\n+    public String getName() {\r\n+        return mScanResponseGson.packJson.name;\r\n+    }\r\n+\r\n+    public String getVendor() {\r\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\r\n+    }\r\n+\r\n+    public String getModel() {\r\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\r\n+    }\r\n+\r\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\r\n+        return mScanResponseGson;\r\n+    }\r\n+\r\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\r\n+        mScanResponseGson = gson;\r\n+    }\r\n+\r\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\r\n+        return bindResponseGson;\r\n+    }\r\n+\r\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\r\n+        return statusResponseGson;\r\n+    }\r\n+\r\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\r\n+        Validate.isTrue(socket.isPresent());\r\n+        byte[] sendData = new byte[1024];\r\n+        byte[] receiveData = new byte[347];\r\n+        Gson gson = new Gson();\r\n+\r\n+        try {\r\n+            // Prep the Binding Request pack\r\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\r\n+            bindReqPackGson.mac = getId();\r\n+            bindReqPackGson.t = \"bind\";\r\n+            bindReqPackGson.uid = 0;\r\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\r\n+\r\n+            // Now Encrypt the Binding Request pack\r\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindReqPackStr);\r\n+\r\n+            // Prep the Binding Request\r\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\r\n+            bindReqGson.cid = \"app\";\r\n+            bindReqGson.i = 1;\r\n+            bindReqGson.t = \"pack\";\r\n+            bindReqGson.uid = 0;\r\n+            bindReqGson.tcid = getId();\r\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\r\n+            String bindReqStr = gson.toJson(bindReqGson);\r\n+            sendData = bindReqStr.getBytes();\r\n+\r\n+            // Now Send the request\r\n+            DatagramSocket clientSocket = socket.get();\r\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\r\n+            clientSocket.send(sendPacket);\r\n+\r\n+            // Recieve a response\r\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\r\n+            clientSocket.receive(receivePacket);\r\n+            String modifiedSentence = new String(receivePacket.getData());\r\n+\r\n+            // Read the response\r\n+            StringReader stringReader = new StringReader(modifiedSentence);\r\n+            bindResponseGson = gson.fromJson(new JsonReader(stringReader), GreeBindResponse4GsonDTO.class);\r\n+            bindResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindResponseGson.pack);\r\n+\r\n+            // Create the JSON to hold the response values\r\n+            stringReader = new StringReader(bindResponseGson.decryptedPack);\r\n+            bindResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePack4GsonDTO.class);\r\n+\r\n+            // Now set the key and flag to indicate the bind was succesful\r\n+            encKey = bindResponseGson.packJson.key;\r\n+            setIsBound(true);\r\n+        } catch (IOException e) {\r\n+            throw new GreeException(e, \"failed\");\r\n+        }\r\n+    }\r\n+\r\n+    public void setDevicePower(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Pow\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void SetDeviceMode(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 4)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Mod\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceSwingVertical(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 11)\r\n+                || (value.intValue() > 6 && value.intValue() < 10)) {\r\n+            return;\r\n+        }\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"SwUpDn\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Only allow this to happen if this device has been bound and values are valid\r\n+     * Possible values are :\r\n+     * 0 : Auto\r\n+     * 1 : Low\r\n+     * 2 : Medium Low\r\n+     * 3 : Medium\r\n+     * 4 : Medium High\r\n+     * 5 : High\r\n+     */\r\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 5)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"WdSpd\", value);\r\n+        parameters.put(\"Quiet\", 0);\r\n+        parameters.put(\"Tur\", 0);\r\n+        parameters.put(\"NoiseSet\", 0);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceTurbo(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Tur\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public int getDeviceTurbo() {\r\n+        return getIntStatusVal(\"Tur\");\r\n+    }\r\n+\r\n+    public void setDeviceLight(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Lig\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create Hash Look Up for C and F\r\n+     * Temperature Ranges for gree A/C units (f_range = {86,61}, c_range={16,30}\r\n+     */\r\n+    private static HashMap<String, HashMap<String, Integer>> createTempRangeMap() {\r\n+        HashMap<String, HashMap<String, Integer>> tempRanges = new HashMap<>();\r\n+        HashMap<String, Integer> hmf = new HashMap<>();\r\n+        HashMap<String, Integer> hmc = new HashMap<>();\r\n+\r\n+        hmf.put(\"min\", new Integer(61)); // F\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 287}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MDA3MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Integer[] validateTemperatureRangeForTempSet(Integer newValIn, @Nullable Integer CorFIn) {\n          \n          \n            \n                private Integer[] validateTemperatureRangeForTempSet(int newValIn, @Nullable Integer CorFIn) {", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432880070", "createdAt": "2020-05-30T19:17:28Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,690 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal.discovery;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.StringReader;\r\n+import java.net.DatagramPacket;\r\n+import java.net.DatagramSocket;\r\n+import java.net.InetAddress;\r\n+import java.nio.charset.Charset;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Objects;\r\n+import java.util.Optional;\r\n+\r\n+import org.apache.commons.lang.Validate;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\r\n+import org.openhab.binding.gree.internal.GreeException;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.stream.JsonReader;\r\n+\r\n+/**\r\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\r\n+ * device specific attributes as well a the functionality for the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+// @NonNullByDefault\r\n+public class GreeAirDevice {\r\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\r\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\r\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\r\n+    private boolean isBound = false;\r\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\r\n+    private int port = 0;\r\n+    private String encKey = \"\";\r\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\r\n+    private GreeBindResponse4GsonDTO bindResponseGson;\r\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\r\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\r\n+\r\n+    public Boolean getIsBound() {\r\n+        return isBound;\r\n+    }\r\n+\r\n+    public void setIsBound(boolean isBound) {\r\n+        this.isBound = isBound;\r\n+    }\r\n+\r\n+    public InetAddress getAddress() {\r\n+        return ipAddress;\r\n+    }\r\n+\r\n+    public void setAddress(InetAddress address) {\r\n+        this.ipAddress = address;\r\n+    }\r\n+\r\n+    public int getPort() {\r\n+        return port;\r\n+    }\r\n+\r\n+    public void setPort(int port) {\r\n+        this.port = port;\r\n+    }\r\n+\r\n+    public String getKey() {\r\n+        return encKey;\r\n+    }\r\n+\r\n+    public String getId() {\r\n+        return mScanResponseGson.packJson.mac;\r\n+    }\r\n+\r\n+    public String getName() {\r\n+        return mScanResponseGson.packJson.name;\r\n+    }\r\n+\r\n+    public String getVendor() {\r\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\r\n+    }\r\n+\r\n+    public String getModel() {\r\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\r\n+    }\r\n+\r\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\r\n+        return mScanResponseGson;\r\n+    }\r\n+\r\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\r\n+        mScanResponseGson = gson;\r\n+    }\r\n+\r\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\r\n+        return bindResponseGson;\r\n+    }\r\n+\r\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\r\n+        return statusResponseGson;\r\n+    }\r\n+\r\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\r\n+        Validate.isTrue(socket.isPresent());\r\n+        byte[] sendData = new byte[1024];\r\n+        byte[] receiveData = new byte[347];\r\n+        Gson gson = new Gson();\r\n+\r\n+        try {\r\n+            // Prep the Binding Request pack\r\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\r\n+            bindReqPackGson.mac = getId();\r\n+            bindReqPackGson.t = \"bind\";\r\n+            bindReqPackGson.uid = 0;\r\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\r\n+\r\n+            // Now Encrypt the Binding Request pack\r\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindReqPackStr);\r\n+\r\n+            // Prep the Binding Request\r\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\r\n+            bindReqGson.cid = \"app\";\r\n+            bindReqGson.i = 1;\r\n+            bindReqGson.t = \"pack\";\r\n+            bindReqGson.uid = 0;\r\n+            bindReqGson.tcid = getId();\r\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\r\n+            String bindReqStr = gson.toJson(bindReqGson);\r\n+            sendData = bindReqStr.getBytes();\r\n+\r\n+            // Now Send the request\r\n+            DatagramSocket clientSocket = socket.get();\r\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\r\n+            clientSocket.send(sendPacket);\r\n+\r\n+            // Recieve a response\r\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\r\n+            clientSocket.receive(receivePacket);\r\n+            String modifiedSentence = new String(receivePacket.getData());\r\n+\r\n+            // Read the response\r\n+            StringReader stringReader = new StringReader(modifiedSentence);\r\n+            bindResponseGson = gson.fromJson(new JsonReader(stringReader), GreeBindResponse4GsonDTO.class);\r\n+            bindResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindResponseGson.pack);\r\n+\r\n+            // Create the JSON to hold the response values\r\n+            stringReader = new StringReader(bindResponseGson.decryptedPack);\r\n+            bindResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePack4GsonDTO.class);\r\n+\r\n+            // Now set the key and flag to indicate the bind was succesful\r\n+            encKey = bindResponseGson.packJson.key;\r\n+            setIsBound(true);\r\n+        } catch (IOException e) {\r\n+            throw new GreeException(e, \"failed\");\r\n+        }\r\n+    }\r\n+\r\n+    public void setDevicePower(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Pow\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void SetDeviceMode(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 4)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Mod\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceSwingVertical(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 11)\r\n+                || (value.intValue() > 6 && value.intValue() < 10)) {\r\n+            return;\r\n+        }\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"SwUpDn\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Only allow this to happen if this device has been bound and values are valid\r\n+     * Possible values are :\r\n+     * 0 : Auto\r\n+     * 1 : Low\r\n+     * 2 : Medium Low\r\n+     * 3 : Medium\r\n+     * 4 : Medium High\r\n+     * 5 : High\r\n+     */\r\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 5)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"WdSpd\", value);\r\n+        parameters.put(\"Quiet\", 0);\r\n+        parameters.put(\"Tur\", 0);\r\n+        parameters.put(\"NoiseSet\", 0);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceTurbo(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Tur\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public int getDeviceTurbo() {\r\n+        return getIntStatusVal(\"Tur\");\r\n+    }\r\n+\r\n+    public void setDeviceLight(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Lig\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create Hash Look Up for C and F\r\n+     * Temperature Ranges for gree A/C units (f_range = {86,61}, c_range={16,30}\r\n+     */\r\n+    private static HashMap<String, HashMap<String, Integer>> createTempRangeMap() {\r\n+        HashMap<String, HashMap<String, Integer>> tempRanges = new HashMap<>();\r\n+        HashMap<String, Integer> hmf = new HashMap<>();\r\n+        HashMap<String, Integer> hmc = new HashMap<>();\r\n+\r\n+        hmf.put(\"min\", new Integer(61)); // F\r\n+        hmf.put(\"max\", new Integer(86));\r\n+        tempRanges.put(\"F\", hmf);\r\n+\r\n+        hmc.put(\"min\", new Integer(16)); // C\r\n+        hmc.put(\"max\", new Integer(30));\r\n+        tempRanges.put(\"C\", hmc);\r\n+\r\n+        return tempRanges;\r\n+    }\r\n+\r\n+    /**\r\n+     * Checks input ranges for validity and TempUn for validity\r\n+     * Uses newVal as priority and tries to validate and determine intent\r\n+     * For example if value is 75 and TempUn says Celsius, change TempUn to Fahrenheit\r\n+     */\r\n+    private Integer[] validateTemperatureRangeForTempSet(Integer newValIn, @Nullable Integer CorFIn) {\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 303}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MDE0OA==", "bodyText": "See above", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432880148", "createdAt": "2020-05-30T19:18:25Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,690 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal.discovery;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.StringReader;\r\n+import java.net.DatagramPacket;\r\n+import java.net.DatagramSocket;\r\n+import java.net.InetAddress;\r\n+import java.nio.charset.Charset;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Objects;\r\n+import java.util.Optional;\r\n+\r\n+import org.apache.commons.lang.Validate;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\r\n+import org.openhab.binding.gree.internal.GreeException;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.stream.JsonReader;\r\n+\r\n+/**\r\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\r\n+ * device specific attributes as well a the functionality for the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+// @NonNullByDefault\r\n+public class GreeAirDevice {\r\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\r\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\r\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\r\n+    private boolean isBound = false;\r\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\r\n+    private int port = 0;\r\n+    private String encKey = \"\";\r\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\r\n+    private GreeBindResponse4GsonDTO bindResponseGson;\r\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\r\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\r\n+\r\n+    public Boolean getIsBound() {\r\n+        return isBound;\r\n+    }\r\n+\r\n+    public void setIsBound(boolean isBound) {\r\n+        this.isBound = isBound;\r\n+    }\r\n+\r\n+    public InetAddress getAddress() {\r\n+        return ipAddress;\r\n+    }\r\n+\r\n+    public void setAddress(InetAddress address) {\r\n+        this.ipAddress = address;\r\n+    }\r\n+\r\n+    public int getPort() {\r\n+        return port;\r\n+    }\r\n+\r\n+    public void setPort(int port) {\r\n+        this.port = port;\r\n+    }\r\n+\r\n+    public String getKey() {\r\n+        return encKey;\r\n+    }\r\n+\r\n+    public String getId() {\r\n+        return mScanResponseGson.packJson.mac;\r\n+    }\r\n+\r\n+    public String getName() {\r\n+        return mScanResponseGson.packJson.name;\r\n+    }\r\n+\r\n+    public String getVendor() {\r\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\r\n+    }\r\n+\r\n+    public String getModel() {\r\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\r\n+    }\r\n+\r\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\r\n+        return mScanResponseGson;\r\n+    }\r\n+\r\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\r\n+        mScanResponseGson = gson;\r\n+    }\r\n+\r\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\r\n+        return bindResponseGson;\r\n+    }\r\n+\r\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\r\n+        return statusResponseGson;\r\n+    }\r\n+\r\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\r\n+        Validate.isTrue(socket.isPresent());\r\n+        byte[] sendData = new byte[1024];\r\n+        byte[] receiveData = new byte[347];\r\n+        Gson gson = new Gson();\r\n+\r\n+        try {\r\n+            // Prep the Binding Request pack\r\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\r\n+            bindReqPackGson.mac = getId();\r\n+            bindReqPackGson.t = \"bind\";\r\n+            bindReqPackGson.uid = 0;\r\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\r\n+\r\n+            // Now Encrypt the Binding Request pack\r\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindReqPackStr);\r\n+\r\n+            // Prep the Binding Request\r\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\r\n+            bindReqGson.cid = \"app\";\r\n+            bindReqGson.i = 1;\r\n+            bindReqGson.t = \"pack\";\r\n+            bindReqGson.uid = 0;\r\n+            bindReqGson.tcid = getId();\r\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\r\n+            String bindReqStr = gson.toJson(bindReqGson);\r\n+            sendData = bindReqStr.getBytes();\r\n+\r\n+            // Now Send the request\r\n+            DatagramSocket clientSocket = socket.get();\r\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\r\n+            clientSocket.send(sendPacket);\r\n+\r\n+            // Recieve a response\r\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\r\n+            clientSocket.receive(receivePacket);\r\n+            String modifiedSentence = new String(receivePacket.getData());\r\n+\r\n+            // Read the response\r\n+            StringReader stringReader = new StringReader(modifiedSentence);\r\n+            bindResponseGson = gson.fromJson(new JsonReader(stringReader), GreeBindResponse4GsonDTO.class);\r\n+            bindResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindResponseGson.pack);\r\n+\r\n+            // Create the JSON to hold the response values\r\n+            stringReader = new StringReader(bindResponseGson.decryptedPack);\r\n+            bindResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePack4GsonDTO.class);\r\n+\r\n+            // Now set the key and flag to indicate the bind was succesful\r\n+            encKey = bindResponseGson.packJson.key;\r\n+            setIsBound(true);\r\n+        } catch (IOException e) {\r\n+            throw new GreeException(e, \"failed\");\r\n+        }\r\n+    }\r\n+\r\n+    public void setDevicePower(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Pow\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void SetDeviceMode(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 4)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Mod\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceSwingVertical(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 11)\r\n+                || (value.intValue() > 6 && value.intValue() < 10)) {\r\n+            return;\r\n+        }\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"SwUpDn\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Only allow this to happen if this device has been bound and values are valid\r\n+     * Possible values are :\r\n+     * 0 : Auto\r\n+     * 1 : Low\r\n+     * 2 : Medium Low\r\n+     * 3 : Medium\r\n+     * 4 : Medium High\r\n+     * 5 : High\r\n+     */\r\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 5)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"WdSpd\", value);\r\n+        parameters.put(\"Quiet\", 0);\r\n+        parameters.put(\"Tur\", 0);\r\n+        parameters.put(\"NoiseSet\", 0);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceTurbo(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Tur\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public int getDeviceTurbo() {\r\n+        return getIntStatusVal(\"Tur\");\r\n+    }\r\n+\r\n+    public void setDeviceLight(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Lig\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create Hash Look Up for C and F\r\n+     * Temperature Ranges for gree A/C units (f_range = {86,61}, c_range={16,30}\r\n+     */\r\n+    private static HashMap<String, HashMap<String, Integer>> createTempRangeMap() {\r\n+        HashMap<String, HashMap<String, Integer>> tempRanges = new HashMap<>();\r\n+        HashMap<String, Integer> hmf = new HashMap<>();\r\n+        HashMap<String, Integer> hmc = new HashMap<>();\r\n+\r\n+        hmf.put(\"min\", new Integer(61)); // F\r\n+        hmf.put(\"max\", new Integer(86));\r\n+        tempRanges.put(\"F\", hmf);\r\n+\r\n+        hmc.put(\"min\", new Integer(16)); // C\r\n+        hmc.put(\"max\", new Integer(30));\r\n+        tempRanges.put(\"C\", hmc);\r\n+\r\n+        return tempRanges;\r\n+    }\r\n+\r\n+    /**\r\n+     * Checks input ranges for validity and TempUn for validity\r\n+     * Uses newVal as priority and tries to validate and determine intent\r\n+     * For example if value is 75 and TempUn says Celsius, change TempUn to Fahrenheit\r\n+     */\r\n+    private Integer[] validateTemperatureRangeForTempSet(Integer newValIn, @Nullable Integer CorFIn) {\r\n+        final String[] minMaxLUT = { \"max\", \"min\" }; // looks up 0 = C = max, 1 = F = min\r\n+        final String[] tempScaleLUT = { \"C\", \"F\" }; // Look Up Table used to convert TempUn integer 0,1 to \"C\" to \"F\"\r\n+                                                    // string for hashmap\r\n+        HashMap<String, Integer> nullCorFLUT = new HashMap<>(); // simple look up table for logic\r\n+        nullCorFLUT.put(\"C\", new Integer(0));\r\n+        nullCorFLUT.put(\"F\", new Integer(1));\r\n+        nullCorFLUT.put(\"INVALID\", new Integer(0));\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 310}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MDIyMg==", "bodyText": "This will check for object identity. Use validRangeCorF.equals(\"C\") to check for equality. Are you sure this code works under all conditions? This would be a good candidate for a unit test. See https://www.openhab.org/docs/developer/tests.html", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432880222", "createdAt": "2020-05-30T19:19:55Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,690 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal.discovery;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.StringReader;\r\n+import java.net.DatagramPacket;\r\n+import java.net.DatagramSocket;\r\n+import java.net.InetAddress;\r\n+import java.nio.charset.Charset;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Objects;\r\n+import java.util.Optional;\r\n+\r\n+import org.apache.commons.lang.Validate;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\r\n+import org.openhab.binding.gree.internal.GreeException;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.stream.JsonReader;\r\n+\r\n+/**\r\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\r\n+ * device specific attributes as well a the functionality for the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+// @NonNullByDefault\r\n+public class GreeAirDevice {\r\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\r\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\r\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\r\n+    private boolean isBound = false;\r\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\r\n+    private int port = 0;\r\n+    private String encKey = \"\";\r\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\r\n+    private GreeBindResponse4GsonDTO bindResponseGson;\r\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\r\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\r\n+\r\n+    public Boolean getIsBound() {\r\n+        return isBound;\r\n+    }\r\n+\r\n+    public void setIsBound(boolean isBound) {\r\n+        this.isBound = isBound;\r\n+    }\r\n+\r\n+    public InetAddress getAddress() {\r\n+        return ipAddress;\r\n+    }\r\n+\r\n+    public void setAddress(InetAddress address) {\r\n+        this.ipAddress = address;\r\n+    }\r\n+\r\n+    public int getPort() {\r\n+        return port;\r\n+    }\r\n+\r\n+    public void setPort(int port) {\r\n+        this.port = port;\r\n+    }\r\n+\r\n+    public String getKey() {\r\n+        return encKey;\r\n+    }\r\n+\r\n+    public String getId() {\r\n+        return mScanResponseGson.packJson.mac;\r\n+    }\r\n+\r\n+    public String getName() {\r\n+        return mScanResponseGson.packJson.name;\r\n+    }\r\n+\r\n+    public String getVendor() {\r\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\r\n+    }\r\n+\r\n+    public String getModel() {\r\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\r\n+    }\r\n+\r\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\r\n+        return mScanResponseGson;\r\n+    }\r\n+\r\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\r\n+        mScanResponseGson = gson;\r\n+    }\r\n+\r\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\r\n+        return bindResponseGson;\r\n+    }\r\n+\r\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\r\n+        return statusResponseGson;\r\n+    }\r\n+\r\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\r\n+        Validate.isTrue(socket.isPresent());\r\n+        byte[] sendData = new byte[1024];\r\n+        byte[] receiveData = new byte[347];\r\n+        Gson gson = new Gson();\r\n+\r\n+        try {\r\n+            // Prep the Binding Request pack\r\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\r\n+            bindReqPackGson.mac = getId();\r\n+            bindReqPackGson.t = \"bind\";\r\n+            bindReqPackGson.uid = 0;\r\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\r\n+\r\n+            // Now Encrypt the Binding Request pack\r\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindReqPackStr);\r\n+\r\n+            // Prep the Binding Request\r\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\r\n+            bindReqGson.cid = \"app\";\r\n+            bindReqGson.i = 1;\r\n+            bindReqGson.t = \"pack\";\r\n+            bindReqGson.uid = 0;\r\n+            bindReqGson.tcid = getId();\r\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\r\n+            String bindReqStr = gson.toJson(bindReqGson);\r\n+            sendData = bindReqStr.getBytes();\r\n+\r\n+            // Now Send the request\r\n+            DatagramSocket clientSocket = socket.get();\r\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\r\n+            clientSocket.send(sendPacket);\r\n+\r\n+            // Recieve a response\r\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\r\n+            clientSocket.receive(receivePacket);\r\n+            String modifiedSentence = new String(receivePacket.getData());\r\n+\r\n+            // Read the response\r\n+            StringReader stringReader = new StringReader(modifiedSentence);\r\n+            bindResponseGson = gson.fromJson(new JsonReader(stringReader), GreeBindResponse4GsonDTO.class);\r\n+            bindResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindResponseGson.pack);\r\n+\r\n+            // Create the JSON to hold the response values\r\n+            stringReader = new StringReader(bindResponseGson.decryptedPack);\r\n+            bindResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePack4GsonDTO.class);\r\n+\r\n+            // Now set the key and flag to indicate the bind was succesful\r\n+            encKey = bindResponseGson.packJson.key;\r\n+            setIsBound(true);\r\n+        } catch (IOException e) {\r\n+            throw new GreeException(e, \"failed\");\r\n+        }\r\n+    }\r\n+\r\n+    public void setDevicePower(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Pow\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void SetDeviceMode(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 4)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Mod\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceSwingVertical(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 11)\r\n+                || (value.intValue() > 6 && value.intValue() < 10)) {\r\n+            return;\r\n+        }\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"SwUpDn\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Only allow this to happen if this device has been bound and values are valid\r\n+     * Possible values are :\r\n+     * 0 : Auto\r\n+     * 1 : Low\r\n+     * 2 : Medium Low\r\n+     * 3 : Medium\r\n+     * 4 : Medium High\r\n+     * 5 : High\r\n+     */\r\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 5)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"WdSpd\", value);\r\n+        parameters.put(\"Quiet\", 0);\r\n+        parameters.put(\"Tur\", 0);\r\n+        parameters.put(\"NoiseSet\", 0);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceTurbo(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Tur\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public int getDeviceTurbo() {\r\n+        return getIntStatusVal(\"Tur\");\r\n+    }\r\n+\r\n+    public void setDeviceLight(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Lig\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create Hash Look Up for C and F\r\n+     * Temperature Ranges for gree A/C units (f_range = {86,61}, c_range={16,30}\r\n+     */\r\n+    private static HashMap<String, HashMap<String, Integer>> createTempRangeMap() {\r\n+        HashMap<String, HashMap<String, Integer>> tempRanges = new HashMap<>();\r\n+        HashMap<String, Integer> hmf = new HashMap<>();\r\n+        HashMap<String, Integer> hmc = new HashMap<>();\r\n+\r\n+        hmf.put(\"min\", new Integer(61)); // F\r\n+        hmf.put(\"max\", new Integer(86));\r\n+        tempRanges.put(\"F\", hmf);\r\n+\r\n+        hmc.put(\"min\", new Integer(16)); // C\r\n+        hmc.put(\"max\", new Integer(30));\r\n+        tempRanges.put(\"C\", hmc);\r\n+\r\n+        return tempRanges;\r\n+    }\r\n+\r\n+    /**\r\n+     * Checks input ranges for validity and TempUn for validity\r\n+     * Uses newVal as priority and tries to validate and determine intent\r\n+     * For example if value is 75 and TempUn says Celsius, change TempUn to Fahrenheit\r\n+     */\r\n+    private Integer[] validateTemperatureRangeForTempSet(Integer newValIn, @Nullable Integer CorFIn) {\r\n+        final String[] minMaxLUT = { \"max\", \"min\" }; // looks up 0 = C = max, 1 = F = min\r\n+        final String[] tempScaleLUT = { \"C\", \"F\" }; // Look Up Table used to convert TempUn integer 0,1 to \"C\" to \"F\"\r\n+                                                    // string for hashmap\r\n+        HashMap<String, Integer> nullCorFLUT = new HashMap<>(); // simple look up table for logic\r\n+        nullCorFLUT.put(\"C\", new Integer(0));\r\n+        nullCorFLUT.put(\"F\", new Integer(1));\r\n+        nullCorFLUT.put(\"INVALID\", new Integer(0));\r\n+\r\n+        String validRangeCorF; // stores if the input range is a valid C or F temperature\r\n+\r\n+        // force to global min/max\r\n+        Integer newVal = Math.max(newValIn, Math.min(tempRanges.get(\"C\").get(\"min\"), tempRanges.get(\"F\").get(\"min\")));\r\n+        newVal = Math.min(newVal, Math.max(tempRanges.get(\"C\").get(\"max\"), tempRanges.get(\"F\").get(\"max\")));\r\n+\r\n+        if ((newVal >= tempRanges.get(\"C\").get(\"min\")) && (newVal <= tempRanges.get(\"C\").get(\"max\"))) {\r\n+            validRangeCorF = \"C\";\r\n+        } else if ((newVal >= tempRanges.get(\"F\").get(\"min\")) && (newVal <= tempRanges.get(\"F\").get(\"max\"))) {\r\n+            validRangeCorF = \"F\";\r\n+        } else {\r\n+            logger.warn(\"Input Temp request {} is invalid\", newVal);\r\n+            validRangeCorF = \"INVALID\";\r\n+        }\r\n+\r\n+        // if CorF wasnt initialized or is null set it from lookup\r\n+        Integer CorF = CorFIn != null ? CorFIn : nullCorFLUT.get(validRangeCorF);\r\n+\r\n+        if ((CorF == 1) && (validRangeCorF == \"C\")) {\r\n+            CorF = 0; // input temp takes priority\r\n+        } else if ((CorF == 0) && (validRangeCorF == \"F\")) {\r\n+            CorF = 1; // input temp takes priority\r\n+        } else if (validRangeCorF == \"INVALID\") {\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 334}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MDQ5OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return new Integer[] { newVal, CorF };\n          \n          \n            \n                    return new int[] { newVal, CorF };", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432880499", "createdAt": "2020-05-30T19:24:52Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,690 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal.discovery;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.StringReader;\r\n+import java.net.DatagramPacket;\r\n+import java.net.DatagramSocket;\r\n+import java.net.InetAddress;\r\n+import java.nio.charset.Charset;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Objects;\r\n+import java.util.Optional;\r\n+\r\n+import org.apache.commons.lang.Validate;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\r\n+import org.openhab.binding.gree.internal.GreeException;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.stream.JsonReader;\r\n+\r\n+/**\r\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\r\n+ * device specific attributes as well a the functionality for the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+// @NonNullByDefault\r\n+public class GreeAirDevice {\r\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\r\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\r\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\r\n+    private boolean isBound = false;\r\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\r\n+    private int port = 0;\r\n+    private String encKey = \"\";\r\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\r\n+    private GreeBindResponse4GsonDTO bindResponseGson;\r\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\r\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\r\n+\r\n+    public Boolean getIsBound() {\r\n+        return isBound;\r\n+    }\r\n+\r\n+    public void setIsBound(boolean isBound) {\r\n+        this.isBound = isBound;\r\n+    }\r\n+\r\n+    public InetAddress getAddress() {\r\n+        return ipAddress;\r\n+    }\r\n+\r\n+    public void setAddress(InetAddress address) {\r\n+        this.ipAddress = address;\r\n+    }\r\n+\r\n+    public int getPort() {\r\n+        return port;\r\n+    }\r\n+\r\n+    public void setPort(int port) {\r\n+        this.port = port;\r\n+    }\r\n+\r\n+    public String getKey() {\r\n+        return encKey;\r\n+    }\r\n+\r\n+    public String getId() {\r\n+        return mScanResponseGson.packJson.mac;\r\n+    }\r\n+\r\n+    public String getName() {\r\n+        return mScanResponseGson.packJson.name;\r\n+    }\r\n+\r\n+    public String getVendor() {\r\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\r\n+    }\r\n+\r\n+    public String getModel() {\r\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\r\n+    }\r\n+\r\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\r\n+        return mScanResponseGson;\r\n+    }\r\n+\r\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\r\n+        mScanResponseGson = gson;\r\n+    }\r\n+\r\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\r\n+        return bindResponseGson;\r\n+    }\r\n+\r\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\r\n+        return statusResponseGson;\r\n+    }\r\n+\r\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\r\n+        Validate.isTrue(socket.isPresent());\r\n+        byte[] sendData = new byte[1024];\r\n+        byte[] receiveData = new byte[347];\r\n+        Gson gson = new Gson();\r\n+\r\n+        try {\r\n+            // Prep the Binding Request pack\r\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\r\n+            bindReqPackGson.mac = getId();\r\n+            bindReqPackGson.t = \"bind\";\r\n+            bindReqPackGson.uid = 0;\r\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\r\n+\r\n+            // Now Encrypt the Binding Request pack\r\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindReqPackStr);\r\n+\r\n+            // Prep the Binding Request\r\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\r\n+            bindReqGson.cid = \"app\";\r\n+            bindReqGson.i = 1;\r\n+            bindReqGson.t = \"pack\";\r\n+            bindReqGson.uid = 0;\r\n+            bindReqGson.tcid = getId();\r\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\r\n+            String bindReqStr = gson.toJson(bindReqGson);\r\n+            sendData = bindReqStr.getBytes();\r\n+\r\n+            // Now Send the request\r\n+            DatagramSocket clientSocket = socket.get();\r\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\r\n+            clientSocket.send(sendPacket);\r\n+\r\n+            // Recieve a response\r\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\r\n+            clientSocket.receive(receivePacket);\r\n+            String modifiedSentence = new String(receivePacket.getData());\r\n+\r\n+            // Read the response\r\n+            StringReader stringReader = new StringReader(modifiedSentence);\r\n+            bindResponseGson = gson.fromJson(new JsonReader(stringReader), GreeBindResponse4GsonDTO.class);\r\n+            bindResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindResponseGson.pack);\r\n+\r\n+            // Create the JSON to hold the response values\r\n+            stringReader = new StringReader(bindResponseGson.decryptedPack);\r\n+            bindResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePack4GsonDTO.class);\r\n+\r\n+            // Now set the key and flag to indicate the bind was succesful\r\n+            encKey = bindResponseGson.packJson.key;\r\n+            setIsBound(true);\r\n+        } catch (IOException e) {\r\n+            throw new GreeException(e, \"failed\");\r\n+        }\r\n+    }\r\n+\r\n+    public void setDevicePower(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Pow\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void SetDeviceMode(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 4)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Mod\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceSwingVertical(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 11)\r\n+                || (value.intValue() > 6 && value.intValue() < 10)) {\r\n+            return;\r\n+        }\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"SwUpDn\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Only allow this to happen if this device has been bound and values are valid\r\n+     * Possible values are :\r\n+     * 0 : Auto\r\n+     * 1 : Low\r\n+     * 2 : Medium Low\r\n+     * 3 : Medium\r\n+     * 4 : Medium High\r\n+     * 5 : High\r\n+     */\r\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 5)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"WdSpd\", value);\r\n+        parameters.put(\"Quiet\", 0);\r\n+        parameters.put(\"Tur\", 0);\r\n+        parameters.put(\"NoiseSet\", 0);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceTurbo(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Tur\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public int getDeviceTurbo() {\r\n+        return getIntStatusVal(\"Tur\");\r\n+    }\r\n+\r\n+    public void setDeviceLight(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Lig\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create Hash Look Up for C and F\r\n+     * Temperature Ranges for gree A/C units (f_range = {86,61}, c_range={16,30}\r\n+     */\r\n+    private static HashMap<String, HashMap<String, Integer>> createTempRangeMap() {\r\n+        HashMap<String, HashMap<String, Integer>> tempRanges = new HashMap<>();\r\n+        HashMap<String, Integer> hmf = new HashMap<>();\r\n+        HashMap<String, Integer> hmc = new HashMap<>();\r\n+\r\n+        hmf.put(\"min\", new Integer(61)); // F\r\n+        hmf.put(\"max\", new Integer(86));\r\n+        tempRanges.put(\"F\", hmf);\r\n+\r\n+        hmc.put(\"min\", new Integer(16)); // C\r\n+        hmc.put(\"max\", new Integer(30));\r\n+        tempRanges.put(\"C\", hmc);\r\n+\r\n+        return tempRanges;\r\n+    }\r\n+\r\n+    /**\r\n+     * Checks input ranges for validity and TempUn for validity\r\n+     * Uses newVal as priority and tries to validate and determine intent\r\n+     * For example if value is 75 and TempUn says Celsius, change TempUn to Fahrenheit\r\n+     */\r\n+    private Integer[] validateTemperatureRangeForTempSet(Integer newValIn, @Nullable Integer CorFIn) {\r\n+        final String[] minMaxLUT = { \"max\", \"min\" }; // looks up 0 = C = max, 1 = F = min\r\n+        final String[] tempScaleLUT = { \"C\", \"F\" }; // Look Up Table used to convert TempUn integer 0,1 to \"C\" to \"F\"\r\n+                                                    // string for hashmap\r\n+        HashMap<String, Integer> nullCorFLUT = new HashMap<>(); // simple look up table for logic\r\n+        nullCorFLUT.put(\"C\", new Integer(0));\r\n+        nullCorFLUT.put(\"F\", new Integer(1));\r\n+        nullCorFLUT.put(\"INVALID\", new Integer(0));\r\n+\r\n+        String validRangeCorF; // stores if the input range is a valid C or F temperature\r\n+\r\n+        // force to global min/max\r\n+        Integer newVal = Math.max(newValIn, Math.min(tempRanges.get(\"C\").get(\"min\"), tempRanges.get(\"F\").get(\"min\")));\r\n+        newVal = Math.min(newVal, Math.max(tempRanges.get(\"C\").get(\"max\"), tempRanges.get(\"F\").get(\"max\")));\r\n+\r\n+        if ((newVal >= tempRanges.get(\"C\").get(\"min\")) && (newVal <= tempRanges.get(\"C\").get(\"max\"))) {\r\n+            validRangeCorF = \"C\";\r\n+        } else if ((newVal >= tempRanges.get(\"F\").get(\"min\")) && (newVal <= tempRanges.get(\"F\").get(\"max\"))) {\r\n+            validRangeCorF = \"F\";\r\n+        } else {\r\n+            logger.warn(\"Input Temp request {} is invalid\", newVal);\r\n+            validRangeCorF = \"INVALID\";\r\n+        }\r\n+\r\n+        // if CorF wasnt initialized or is null set it from lookup\r\n+        Integer CorF = CorFIn != null ? CorFIn : nullCorFLUT.get(validRangeCorF);\r\n+\r\n+        if ((CorF == 1) && (validRangeCorF == \"C\")) {\r\n+            CorF = 0; // input temp takes priority\r\n+        } else if ((CorF == 0) && (validRangeCorF == \"F\")) {\r\n+            CorF = 1; // input temp takes priority\r\n+        } else if (validRangeCorF == \"INVALID\") {\r\n+            // force min or max temp based on CorF scale to be used\r\n+            newVal = tempRanges.get(tempScaleLUT[CorF]).get(minMaxLUT[CorF]);\r\n+        }\r\n+\r\n+        return new Integer[] { newVal, CorF };\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 339}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MDU3MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (getIsBound() != Boolean.TRUE) {\n          \n          \n            \n                    if (!getIsBound()) {", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432880570", "createdAt": "2020-05-30T19:25:58Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,690 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal.discovery;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.StringReader;\r\n+import java.net.DatagramPacket;\r\n+import java.net.DatagramSocket;\r\n+import java.net.InetAddress;\r\n+import java.nio.charset.Charset;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Objects;\r\n+import java.util.Optional;\r\n+\r\n+import org.apache.commons.lang.Validate;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\r\n+import org.openhab.binding.gree.internal.GreeException;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.stream.JsonReader;\r\n+\r\n+/**\r\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\r\n+ * device specific attributes as well a the functionality for the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+// @NonNullByDefault\r\n+public class GreeAirDevice {\r\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\r\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\r\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\r\n+    private boolean isBound = false;\r\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\r\n+    private int port = 0;\r\n+    private String encKey = \"\";\r\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\r\n+    private GreeBindResponse4GsonDTO bindResponseGson;\r\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\r\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\r\n+\r\n+    public Boolean getIsBound() {\r\n+        return isBound;\r\n+    }\r\n+\r\n+    public void setIsBound(boolean isBound) {\r\n+        this.isBound = isBound;\r\n+    }\r\n+\r\n+    public InetAddress getAddress() {\r\n+        return ipAddress;\r\n+    }\r\n+\r\n+    public void setAddress(InetAddress address) {\r\n+        this.ipAddress = address;\r\n+    }\r\n+\r\n+    public int getPort() {\r\n+        return port;\r\n+    }\r\n+\r\n+    public void setPort(int port) {\r\n+        this.port = port;\r\n+    }\r\n+\r\n+    public String getKey() {\r\n+        return encKey;\r\n+    }\r\n+\r\n+    public String getId() {\r\n+        return mScanResponseGson.packJson.mac;\r\n+    }\r\n+\r\n+    public String getName() {\r\n+        return mScanResponseGson.packJson.name;\r\n+    }\r\n+\r\n+    public String getVendor() {\r\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\r\n+    }\r\n+\r\n+    public String getModel() {\r\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\r\n+    }\r\n+\r\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\r\n+        return mScanResponseGson;\r\n+    }\r\n+\r\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\r\n+        mScanResponseGson = gson;\r\n+    }\r\n+\r\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\r\n+        return bindResponseGson;\r\n+    }\r\n+\r\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\r\n+        return statusResponseGson;\r\n+    }\r\n+\r\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\r\n+        Validate.isTrue(socket.isPresent());\r\n+        byte[] sendData = new byte[1024];\r\n+        byte[] receiveData = new byte[347];\r\n+        Gson gson = new Gson();\r\n+\r\n+        try {\r\n+            // Prep the Binding Request pack\r\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\r\n+            bindReqPackGson.mac = getId();\r\n+            bindReqPackGson.t = \"bind\";\r\n+            bindReqPackGson.uid = 0;\r\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\r\n+\r\n+            // Now Encrypt the Binding Request pack\r\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindReqPackStr);\r\n+\r\n+            // Prep the Binding Request\r\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\r\n+            bindReqGson.cid = \"app\";\r\n+            bindReqGson.i = 1;\r\n+            bindReqGson.t = \"pack\";\r\n+            bindReqGson.uid = 0;\r\n+            bindReqGson.tcid = getId();\r\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\r\n+            String bindReqStr = gson.toJson(bindReqGson);\r\n+            sendData = bindReqStr.getBytes();\r\n+\r\n+            // Now Send the request\r\n+            DatagramSocket clientSocket = socket.get();\r\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\r\n+            clientSocket.send(sendPacket);\r\n+\r\n+            // Recieve a response\r\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\r\n+            clientSocket.receive(receivePacket);\r\n+            String modifiedSentence = new String(receivePacket.getData());\r\n+\r\n+            // Read the response\r\n+            StringReader stringReader = new StringReader(modifiedSentence);\r\n+            bindResponseGson = gson.fromJson(new JsonReader(stringReader), GreeBindResponse4GsonDTO.class);\r\n+            bindResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindResponseGson.pack);\r\n+\r\n+            // Create the JSON to hold the response values\r\n+            stringReader = new StringReader(bindResponseGson.decryptedPack);\r\n+            bindResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePack4GsonDTO.class);\r\n+\r\n+            // Now set the key and flag to indicate the bind was succesful\r\n+            encKey = bindResponseGson.packJson.key;\r\n+            setIsBound(true);\r\n+        } catch (IOException e) {\r\n+            throw new GreeException(e, \"failed\");\r\n+        }\r\n+    }\r\n+\r\n+    public void setDevicePower(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Pow\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void SetDeviceMode(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 4)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Mod\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceSwingVertical(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 11)\r\n+                || (value.intValue() > 6 && value.intValue() < 10)) {\r\n+            return;\r\n+        }\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"SwUpDn\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Only allow this to happen if this device has been bound and values are valid\r\n+     * Possible values are :\r\n+     * 0 : Auto\r\n+     * 1 : Low\r\n+     * 2 : Medium Low\r\n+     * 3 : Medium\r\n+     * 4 : Medium High\r\n+     * 5 : High\r\n+     */\r\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 5)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"WdSpd\", value);\r\n+        parameters.put(\"Quiet\", 0);\r\n+        parameters.put(\"Tur\", 0);\r\n+        parameters.put(\"NoiseSet\", 0);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceTurbo(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Tur\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public int getDeviceTurbo() {\r\n+        return getIntStatusVal(\"Tur\");\r\n+    }\r\n+\r\n+    public void setDeviceLight(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Lig\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create Hash Look Up for C and F\r\n+     * Temperature Ranges for gree A/C units (f_range = {86,61}, c_range={16,30}\r\n+     */\r\n+    private static HashMap<String, HashMap<String, Integer>> createTempRangeMap() {\r\n+        HashMap<String, HashMap<String, Integer>> tempRanges = new HashMap<>();\r\n+        HashMap<String, Integer> hmf = new HashMap<>();\r\n+        HashMap<String, Integer> hmc = new HashMap<>();\r\n+\r\n+        hmf.put(\"min\", new Integer(61)); // F\r\n+        hmf.put(\"max\", new Integer(86));\r\n+        tempRanges.put(\"F\", hmf);\r\n+\r\n+        hmc.put(\"min\", new Integer(16)); // C\r\n+        hmc.put(\"max\", new Integer(30));\r\n+        tempRanges.put(\"C\", hmc);\r\n+\r\n+        return tempRanges;\r\n+    }\r\n+\r\n+    /**\r\n+     * Checks input ranges for validity and TempUn for validity\r\n+     * Uses newVal as priority and tries to validate and determine intent\r\n+     * For example if value is 75 and TempUn says Celsius, change TempUn to Fahrenheit\r\n+     */\r\n+    private Integer[] validateTemperatureRangeForTempSet(Integer newValIn, @Nullable Integer CorFIn) {\r\n+        final String[] minMaxLUT = { \"max\", \"min\" }; // looks up 0 = C = max, 1 = F = min\r\n+        final String[] tempScaleLUT = { \"C\", \"F\" }; // Look Up Table used to convert TempUn integer 0,1 to \"C\" to \"F\"\r\n+                                                    // string for hashmap\r\n+        HashMap<String, Integer> nullCorFLUT = new HashMap<>(); // simple look up table for logic\r\n+        nullCorFLUT.put(\"C\", new Integer(0));\r\n+        nullCorFLUT.put(\"F\", new Integer(1));\r\n+        nullCorFLUT.put(\"INVALID\", new Integer(0));\r\n+\r\n+        String validRangeCorF; // stores if the input range is a valid C or F temperature\r\n+\r\n+        // force to global min/max\r\n+        Integer newVal = Math.max(newValIn, Math.min(tempRanges.get(\"C\").get(\"min\"), tempRanges.get(\"F\").get(\"min\")));\r\n+        newVal = Math.min(newVal, Math.max(tempRanges.get(\"C\").get(\"max\"), tempRanges.get(\"F\").get(\"max\")));\r\n+\r\n+        if ((newVal >= tempRanges.get(\"C\").get(\"min\")) && (newVal <= tempRanges.get(\"C\").get(\"max\"))) {\r\n+            validRangeCorF = \"C\";\r\n+        } else if ((newVal >= tempRanges.get(\"F\").get(\"min\")) && (newVal <= tempRanges.get(\"F\").get(\"max\"))) {\r\n+            validRangeCorF = \"F\";\r\n+        } else {\r\n+            logger.warn(\"Input Temp request {} is invalid\", newVal);\r\n+            validRangeCorF = \"INVALID\";\r\n+        }\r\n+\r\n+        // if CorF wasnt initialized or is null set it from lookup\r\n+        Integer CorF = CorFIn != null ? CorFIn : nullCorFLUT.get(validRangeCorF);\r\n+\r\n+        if ((CorF == 1) && (validRangeCorF == \"C\")) {\r\n+            CorF = 0; // input temp takes priority\r\n+        } else if ((CorF == 0) && (validRangeCorF == \"F\")) {\r\n+            CorF = 1; // input temp takes priority\r\n+        } else if (validRangeCorF == \"INVALID\") {\r\n+            // force min or max temp based on CorF scale to be used\r\n+            newVal = tempRanges.get(tempScaleLUT[CorF]).get(minMaxLUT[CorF]);\r\n+        }\r\n+\r\n+        return new Integer[] { newVal, CorF };\r\n+    }\r\n+\r\n+    public void setDeviceTempSet(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // **value** : set temperature in degrees celsius or Fahrenheit\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 345}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MDU4MA==", "bodyText": "Primitive types", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432880580", "createdAt": "2020-05-30T19:26:15Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,690 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal.discovery;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.StringReader;\r\n+import java.net.DatagramPacket;\r\n+import java.net.DatagramSocket;\r\n+import java.net.InetAddress;\r\n+import java.nio.charset.Charset;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Objects;\r\n+import java.util.Optional;\r\n+\r\n+import org.apache.commons.lang.Validate;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\r\n+import org.openhab.binding.gree.internal.GreeException;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.stream.JsonReader;\r\n+\r\n+/**\r\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\r\n+ * device specific attributes as well a the functionality for the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+// @NonNullByDefault\r\n+public class GreeAirDevice {\r\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\r\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\r\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\r\n+    private boolean isBound = false;\r\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\r\n+    private int port = 0;\r\n+    private String encKey = \"\";\r\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\r\n+    private GreeBindResponse4GsonDTO bindResponseGson;\r\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\r\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\r\n+\r\n+    public Boolean getIsBound() {\r\n+        return isBound;\r\n+    }\r\n+\r\n+    public void setIsBound(boolean isBound) {\r\n+        this.isBound = isBound;\r\n+    }\r\n+\r\n+    public InetAddress getAddress() {\r\n+        return ipAddress;\r\n+    }\r\n+\r\n+    public void setAddress(InetAddress address) {\r\n+        this.ipAddress = address;\r\n+    }\r\n+\r\n+    public int getPort() {\r\n+        return port;\r\n+    }\r\n+\r\n+    public void setPort(int port) {\r\n+        this.port = port;\r\n+    }\r\n+\r\n+    public String getKey() {\r\n+        return encKey;\r\n+    }\r\n+\r\n+    public String getId() {\r\n+        return mScanResponseGson.packJson.mac;\r\n+    }\r\n+\r\n+    public String getName() {\r\n+        return mScanResponseGson.packJson.name;\r\n+    }\r\n+\r\n+    public String getVendor() {\r\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\r\n+    }\r\n+\r\n+    public String getModel() {\r\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\r\n+    }\r\n+\r\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\r\n+        return mScanResponseGson;\r\n+    }\r\n+\r\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\r\n+        mScanResponseGson = gson;\r\n+    }\r\n+\r\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\r\n+        return bindResponseGson;\r\n+    }\r\n+\r\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\r\n+        return statusResponseGson;\r\n+    }\r\n+\r\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\r\n+        Validate.isTrue(socket.isPresent());\r\n+        byte[] sendData = new byte[1024];\r\n+        byte[] receiveData = new byte[347];\r\n+        Gson gson = new Gson();\r\n+\r\n+        try {\r\n+            // Prep the Binding Request pack\r\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\r\n+            bindReqPackGson.mac = getId();\r\n+            bindReqPackGson.t = \"bind\";\r\n+            bindReqPackGson.uid = 0;\r\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\r\n+\r\n+            // Now Encrypt the Binding Request pack\r\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindReqPackStr);\r\n+\r\n+            // Prep the Binding Request\r\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\r\n+            bindReqGson.cid = \"app\";\r\n+            bindReqGson.i = 1;\r\n+            bindReqGson.t = \"pack\";\r\n+            bindReqGson.uid = 0;\r\n+            bindReqGson.tcid = getId();\r\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\r\n+            String bindReqStr = gson.toJson(bindReqGson);\r\n+            sendData = bindReqStr.getBytes();\r\n+\r\n+            // Now Send the request\r\n+            DatagramSocket clientSocket = socket.get();\r\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\r\n+            clientSocket.send(sendPacket);\r\n+\r\n+            // Recieve a response\r\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\r\n+            clientSocket.receive(receivePacket);\r\n+            String modifiedSentence = new String(receivePacket.getData());\r\n+\r\n+            // Read the response\r\n+            StringReader stringReader = new StringReader(modifiedSentence);\r\n+            bindResponseGson = gson.fromJson(new JsonReader(stringReader), GreeBindResponse4GsonDTO.class);\r\n+            bindResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindResponseGson.pack);\r\n+\r\n+            // Create the JSON to hold the response values\r\n+            stringReader = new StringReader(bindResponseGson.decryptedPack);\r\n+            bindResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePack4GsonDTO.class);\r\n+\r\n+            // Now set the key and flag to indicate the bind was succesful\r\n+            encKey = bindResponseGson.packJson.key;\r\n+            setIsBound(true);\r\n+        } catch (IOException e) {\r\n+            throw new GreeException(e, \"failed\");\r\n+        }\r\n+    }\r\n+\r\n+    public void setDevicePower(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Pow\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void SetDeviceMode(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 4)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Mod\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceSwingVertical(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 11)\r\n+                || (value.intValue() > 6 && value.intValue() < 10)) {\r\n+            return;\r\n+        }\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"SwUpDn\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Only allow this to happen if this device has been bound and values are valid\r\n+     * Possible values are :\r\n+     * 0 : Auto\r\n+     * 1 : Low\r\n+     * 2 : Medium Low\r\n+     * 3 : Medium\r\n+     * 4 : Medium High\r\n+     * 5 : High\r\n+     */\r\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 5)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"WdSpd\", value);\r\n+        parameters.put(\"Quiet\", 0);\r\n+        parameters.put(\"Tur\", 0);\r\n+        parameters.put(\"NoiseSet\", 0);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceTurbo(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Tur\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public int getDeviceTurbo() {\r\n+        return getIntStatusVal(\"Tur\");\r\n+    }\r\n+\r\n+    public void setDeviceLight(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Lig\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create Hash Look Up for C and F\r\n+     * Temperature Ranges for gree A/C units (f_range = {86,61}, c_range={16,30}\r\n+     */\r\n+    private static HashMap<String, HashMap<String, Integer>> createTempRangeMap() {\r\n+        HashMap<String, HashMap<String, Integer>> tempRanges = new HashMap<>();\r\n+        HashMap<String, Integer> hmf = new HashMap<>();\r\n+        HashMap<String, Integer> hmc = new HashMap<>();\r\n+\r\n+        hmf.put(\"min\", new Integer(61)); // F\r\n+        hmf.put(\"max\", new Integer(86));\r\n+        tempRanges.put(\"F\", hmf);\r\n+\r\n+        hmc.put(\"min\", new Integer(16)); // C\r\n+        hmc.put(\"max\", new Integer(30));\r\n+        tempRanges.put(\"C\", hmc);\r\n+\r\n+        return tempRanges;\r\n+    }\r\n+\r\n+    /**\r\n+     * Checks input ranges for validity and TempUn for validity\r\n+     * Uses newVal as priority and tries to validate and determine intent\r\n+     * For example if value is 75 and TempUn says Celsius, change TempUn to Fahrenheit\r\n+     */\r\n+    private Integer[] validateTemperatureRangeForTempSet(Integer newValIn, @Nullable Integer CorFIn) {\r\n+        final String[] minMaxLUT = { \"max\", \"min\" }; // looks up 0 = C = max, 1 = F = min\r\n+        final String[] tempScaleLUT = { \"C\", \"F\" }; // Look Up Table used to convert TempUn integer 0,1 to \"C\" to \"F\"\r\n+                                                    // string for hashmap\r\n+        HashMap<String, Integer> nullCorFLUT = new HashMap<>(); // simple look up table for logic\r\n+        nullCorFLUT.put(\"C\", new Integer(0));\r\n+        nullCorFLUT.put(\"F\", new Integer(1));\r\n+        nullCorFLUT.put(\"INVALID\", new Integer(0));\r\n+\r\n+        String validRangeCorF; // stores if the input range is a valid C or F temperature\r\n+\r\n+        // force to global min/max\r\n+        Integer newVal = Math.max(newValIn, Math.min(tempRanges.get(\"C\").get(\"min\"), tempRanges.get(\"F\").get(\"min\")));\r\n+        newVal = Math.min(newVal, Math.max(tempRanges.get(\"C\").get(\"max\"), tempRanges.get(\"F\").get(\"max\")));\r\n+\r\n+        if ((newVal >= tempRanges.get(\"C\").get(\"min\")) && (newVal <= tempRanges.get(\"C\").get(\"max\"))) {\r\n+            validRangeCorF = \"C\";\r\n+        } else if ((newVal >= tempRanges.get(\"F\").get(\"min\")) && (newVal <= tempRanges.get(\"F\").get(\"max\"))) {\r\n+            validRangeCorF = \"F\";\r\n+        } else {\r\n+            logger.warn(\"Input Temp request {} is invalid\", newVal);\r\n+            validRangeCorF = \"INVALID\";\r\n+        }\r\n+\r\n+        // if CorF wasnt initialized or is null set it from lookup\r\n+        Integer CorF = CorFIn != null ? CorFIn : nullCorFLUT.get(validRangeCorF);\r\n+\r\n+        if ((CorF == 1) && (validRangeCorF == \"C\")) {\r\n+            CorF = 0; // input temp takes priority\r\n+        } else if ((CorF == 0) && (validRangeCorF == \"F\")) {\r\n+            CorF = 1; // input temp takes priority\r\n+        } else if (validRangeCorF == \"INVALID\") {\r\n+            // force min or max temp based on CorF scale to be used\r\n+            newVal = tempRanges.get(tempScaleLUT[CorF]).get(minMaxLUT[CorF]);\r\n+        }\r\n+\r\n+        return new Integer[] { newVal, CorF };\r\n+    }\r\n+\r\n+    public void setDeviceTempSet(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // **value** : set temperature in degrees celsius or Fahrenheit\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+        Integer[] retList;\r\n+        Integer newVal = new Integer(value);\r\n+        Integer outVal = new Integer(value);\r\n+        // Get Celsius or Fahrenheit from status message\r\n+        Integer CorF = getIntStatusVal(\"TemUn\");\r\n+        // TODO put a param in openhab to allow setting this from the config\r\n+\r\n+        // If commanding Fahrenheit set halfStep to 1 or 0 to tell the A/C which F integer\r\n+        // temperature to use as celsius alone is ambigious\r\n+        Integer halfStep = new Integer(0); // default to C\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 357}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MDU5NQ==", "bodyText": "Primitive types", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432880595", "createdAt": "2020-05-30T19:26:44Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,690 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal.discovery;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.StringReader;\r\n+import java.net.DatagramPacket;\r\n+import java.net.DatagramSocket;\r\n+import java.net.InetAddress;\r\n+import java.nio.charset.Charset;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Objects;\r\n+import java.util.Optional;\r\n+\r\n+import org.apache.commons.lang.Validate;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\r\n+import org.openhab.binding.gree.internal.GreeException;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.stream.JsonReader;\r\n+\r\n+/**\r\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\r\n+ * device specific attributes as well a the functionality for the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+// @NonNullByDefault\r\n+public class GreeAirDevice {\r\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\r\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\r\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\r\n+    private boolean isBound = false;\r\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\r\n+    private int port = 0;\r\n+    private String encKey = \"\";\r\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\r\n+    private GreeBindResponse4GsonDTO bindResponseGson;\r\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\r\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\r\n+\r\n+    public Boolean getIsBound() {\r\n+        return isBound;\r\n+    }\r\n+\r\n+    public void setIsBound(boolean isBound) {\r\n+        this.isBound = isBound;\r\n+    }\r\n+\r\n+    public InetAddress getAddress() {\r\n+        return ipAddress;\r\n+    }\r\n+\r\n+    public void setAddress(InetAddress address) {\r\n+        this.ipAddress = address;\r\n+    }\r\n+\r\n+    public int getPort() {\r\n+        return port;\r\n+    }\r\n+\r\n+    public void setPort(int port) {\r\n+        this.port = port;\r\n+    }\r\n+\r\n+    public String getKey() {\r\n+        return encKey;\r\n+    }\r\n+\r\n+    public String getId() {\r\n+        return mScanResponseGson.packJson.mac;\r\n+    }\r\n+\r\n+    public String getName() {\r\n+        return mScanResponseGson.packJson.name;\r\n+    }\r\n+\r\n+    public String getVendor() {\r\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\r\n+    }\r\n+\r\n+    public String getModel() {\r\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\r\n+    }\r\n+\r\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\r\n+        return mScanResponseGson;\r\n+    }\r\n+\r\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\r\n+        mScanResponseGson = gson;\r\n+    }\r\n+\r\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\r\n+        return bindResponseGson;\r\n+    }\r\n+\r\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\r\n+        return statusResponseGson;\r\n+    }\r\n+\r\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\r\n+        Validate.isTrue(socket.isPresent());\r\n+        byte[] sendData = new byte[1024];\r\n+        byte[] receiveData = new byte[347];\r\n+        Gson gson = new Gson();\r\n+\r\n+        try {\r\n+            // Prep the Binding Request pack\r\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\r\n+            bindReqPackGson.mac = getId();\r\n+            bindReqPackGson.t = \"bind\";\r\n+            bindReqPackGson.uid = 0;\r\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\r\n+\r\n+            // Now Encrypt the Binding Request pack\r\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindReqPackStr);\r\n+\r\n+            // Prep the Binding Request\r\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\r\n+            bindReqGson.cid = \"app\";\r\n+            bindReqGson.i = 1;\r\n+            bindReqGson.t = \"pack\";\r\n+            bindReqGson.uid = 0;\r\n+            bindReqGson.tcid = getId();\r\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\r\n+            String bindReqStr = gson.toJson(bindReqGson);\r\n+            sendData = bindReqStr.getBytes();\r\n+\r\n+            // Now Send the request\r\n+            DatagramSocket clientSocket = socket.get();\r\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\r\n+            clientSocket.send(sendPacket);\r\n+\r\n+            // Recieve a response\r\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\r\n+            clientSocket.receive(receivePacket);\r\n+            String modifiedSentence = new String(receivePacket.getData());\r\n+\r\n+            // Read the response\r\n+            StringReader stringReader = new StringReader(modifiedSentence);\r\n+            bindResponseGson = gson.fromJson(new JsonReader(stringReader), GreeBindResponse4GsonDTO.class);\r\n+            bindResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindResponseGson.pack);\r\n+\r\n+            // Create the JSON to hold the response values\r\n+            stringReader = new StringReader(bindResponseGson.decryptedPack);\r\n+            bindResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePack4GsonDTO.class);\r\n+\r\n+            // Now set the key and flag to indicate the bind was succesful\r\n+            encKey = bindResponseGson.packJson.key;\r\n+            setIsBound(true);\r\n+        } catch (IOException e) {\r\n+            throw new GreeException(e, \"failed\");\r\n+        }\r\n+    }\r\n+\r\n+    public void setDevicePower(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Pow\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void SetDeviceMode(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 4)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Mod\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceSwingVertical(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 11)\r\n+                || (value.intValue() > 6 && value.intValue() < 10)) {\r\n+            return;\r\n+        }\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"SwUpDn\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Only allow this to happen if this device has been bound and values are valid\r\n+     * Possible values are :\r\n+     * 0 : Auto\r\n+     * 1 : Low\r\n+     * 2 : Medium Low\r\n+     * 3 : Medium\r\n+     * 4 : Medium High\r\n+     * 5 : High\r\n+     */\r\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 5)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"WdSpd\", value);\r\n+        parameters.put(\"Quiet\", 0);\r\n+        parameters.put(\"Tur\", 0);\r\n+        parameters.put(\"NoiseSet\", 0);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceTurbo(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Tur\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public int getDeviceTurbo() {\r\n+        return getIntStatusVal(\"Tur\");\r\n+    }\r\n+\r\n+    public void setDeviceLight(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Lig\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create Hash Look Up for C and F\r\n+     * Temperature Ranges for gree A/C units (f_range = {86,61}, c_range={16,30}\r\n+     */\r\n+    private static HashMap<String, HashMap<String, Integer>> createTempRangeMap() {\r\n+        HashMap<String, HashMap<String, Integer>> tempRanges = new HashMap<>();\r\n+        HashMap<String, Integer> hmf = new HashMap<>();\r\n+        HashMap<String, Integer> hmc = new HashMap<>();\r\n+\r\n+        hmf.put(\"min\", new Integer(61)); // F\r\n+        hmf.put(\"max\", new Integer(86));\r\n+        tempRanges.put(\"F\", hmf);\r\n+\r\n+        hmc.put(\"min\", new Integer(16)); // C\r\n+        hmc.put(\"max\", new Integer(30));\r\n+        tempRanges.put(\"C\", hmc);\r\n+\r\n+        return tempRanges;\r\n+    }\r\n+\r\n+    /**\r\n+     * Checks input ranges for validity and TempUn for validity\r\n+     * Uses newVal as priority and tries to validate and determine intent\r\n+     * For example if value is 75 and TempUn says Celsius, change TempUn to Fahrenheit\r\n+     */\r\n+    private Integer[] validateTemperatureRangeForTempSet(Integer newValIn, @Nullable Integer CorFIn) {\r\n+        final String[] minMaxLUT = { \"max\", \"min\" }; // looks up 0 = C = max, 1 = F = min\r\n+        final String[] tempScaleLUT = { \"C\", \"F\" }; // Look Up Table used to convert TempUn integer 0,1 to \"C\" to \"F\"\r\n+                                                    // string for hashmap\r\n+        HashMap<String, Integer> nullCorFLUT = new HashMap<>(); // simple look up table for logic\r\n+        nullCorFLUT.put(\"C\", new Integer(0));\r\n+        nullCorFLUT.put(\"F\", new Integer(1));\r\n+        nullCorFLUT.put(\"INVALID\", new Integer(0));\r\n+\r\n+        String validRangeCorF; // stores if the input range is a valid C or F temperature\r\n+\r\n+        // force to global min/max\r\n+        Integer newVal = Math.max(newValIn, Math.min(tempRanges.get(\"C\").get(\"min\"), tempRanges.get(\"F\").get(\"min\")));\r\n+        newVal = Math.min(newVal, Math.max(tempRanges.get(\"C\").get(\"max\"), tempRanges.get(\"F\").get(\"max\")));\r\n+\r\n+        if ((newVal >= tempRanges.get(\"C\").get(\"min\")) && (newVal <= tempRanges.get(\"C\").get(\"max\"))) {\r\n+            validRangeCorF = \"C\";\r\n+        } else if ((newVal >= tempRanges.get(\"F\").get(\"min\")) && (newVal <= tempRanges.get(\"F\").get(\"max\"))) {\r\n+            validRangeCorF = \"F\";\r\n+        } else {\r\n+            logger.warn(\"Input Temp request {} is invalid\", newVal);\r\n+            validRangeCorF = \"INVALID\";\r\n+        }\r\n+\r\n+        // if CorF wasnt initialized or is null set it from lookup\r\n+        Integer CorF = CorFIn != null ? CorFIn : nullCorFLUT.get(validRangeCorF);\r\n+\r\n+        if ((CorF == 1) && (validRangeCorF == \"C\")) {\r\n+            CorF = 0; // input temp takes priority\r\n+        } else if ((CorF == 0) && (validRangeCorF == \"F\")) {\r\n+            CorF = 1; // input temp takes priority\r\n+        } else if (validRangeCorF == \"INVALID\") {\r\n+            // force min or max temp based on CorF scale to be used\r\n+            newVal = tempRanges.get(tempScaleLUT[CorF]).get(minMaxLUT[CorF]);\r\n+        }\r\n+\r\n+        return new Integer[] { newVal, CorF };\r\n+    }\r\n+\r\n+    public void setDeviceTempSet(DatagramSocket clientSocket, Integer value) throws GreeException {\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 342}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MDcwNg==", "bodyText": "Primitive types", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432880706", "createdAt": "2020-05-30T19:28:20Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,690 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal.discovery;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.StringReader;\r\n+import java.net.DatagramPacket;\r\n+import java.net.DatagramSocket;\r\n+import java.net.InetAddress;\r\n+import java.nio.charset.Charset;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Objects;\r\n+import java.util.Optional;\r\n+\r\n+import org.apache.commons.lang.Validate;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\r\n+import org.openhab.binding.gree.internal.GreeException;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.stream.JsonReader;\r\n+\r\n+/**\r\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\r\n+ * device specific attributes as well a the functionality for the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+// @NonNullByDefault\r\n+public class GreeAirDevice {\r\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\r\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\r\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\r\n+    private boolean isBound = false;\r\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\r\n+    private int port = 0;\r\n+    private String encKey = \"\";\r\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\r\n+    private GreeBindResponse4GsonDTO bindResponseGson;\r\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\r\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\r\n+\r\n+    public Boolean getIsBound() {\r\n+        return isBound;\r\n+    }\r\n+\r\n+    public void setIsBound(boolean isBound) {\r\n+        this.isBound = isBound;\r\n+    }\r\n+\r\n+    public InetAddress getAddress() {\r\n+        return ipAddress;\r\n+    }\r\n+\r\n+    public void setAddress(InetAddress address) {\r\n+        this.ipAddress = address;\r\n+    }\r\n+\r\n+    public int getPort() {\r\n+        return port;\r\n+    }\r\n+\r\n+    public void setPort(int port) {\r\n+        this.port = port;\r\n+    }\r\n+\r\n+    public String getKey() {\r\n+        return encKey;\r\n+    }\r\n+\r\n+    public String getId() {\r\n+        return mScanResponseGson.packJson.mac;\r\n+    }\r\n+\r\n+    public String getName() {\r\n+        return mScanResponseGson.packJson.name;\r\n+    }\r\n+\r\n+    public String getVendor() {\r\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\r\n+    }\r\n+\r\n+    public String getModel() {\r\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\r\n+    }\r\n+\r\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\r\n+        return mScanResponseGson;\r\n+    }\r\n+\r\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\r\n+        mScanResponseGson = gson;\r\n+    }\r\n+\r\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\r\n+        return bindResponseGson;\r\n+    }\r\n+\r\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\r\n+        return statusResponseGson;\r\n+    }\r\n+\r\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\r\n+        Validate.isTrue(socket.isPresent());\r\n+        byte[] sendData = new byte[1024];\r\n+        byte[] receiveData = new byte[347];\r\n+        Gson gson = new Gson();\r\n+\r\n+        try {\r\n+            // Prep the Binding Request pack\r\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\r\n+            bindReqPackGson.mac = getId();\r\n+            bindReqPackGson.t = \"bind\";\r\n+            bindReqPackGson.uid = 0;\r\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\r\n+\r\n+            // Now Encrypt the Binding Request pack\r\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindReqPackStr);\r\n+\r\n+            // Prep the Binding Request\r\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\r\n+            bindReqGson.cid = \"app\";\r\n+            bindReqGson.i = 1;\r\n+            bindReqGson.t = \"pack\";\r\n+            bindReqGson.uid = 0;\r\n+            bindReqGson.tcid = getId();\r\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\r\n+            String bindReqStr = gson.toJson(bindReqGson);\r\n+            sendData = bindReqStr.getBytes();\r\n+\r\n+            // Now Send the request\r\n+            DatagramSocket clientSocket = socket.get();\r\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\r\n+            clientSocket.send(sendPacket);\r\n+\r\n+            // Recieve a response\r\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\r\n+            clientSocket.receive(receivePacket);\r\n+            String modifiedSentence = new String(receivePacket.getData());\r\n+\r\n+            // Read the response\r\n+            StringReader stringReader = new StringReader(modifiedSentence);\r\n+            bindResponseGson = gson.fromJson(new JsonReader(stringReader), GreeBindResponse4GsonDTO.class);\r\n+            bindResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindResponseGson.pack);\r\n+\r\n+            // Create the JSON to hold the response values\r\n+            stringReader = new StringReader(bindResponseGson.decryptedPack);\r\n+            bindResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePack4GsonDTO.class);\r\n+\r\n+            // Now set the key and flag to indicate the bind was succesful\r\n+            encKey = bindResponseGson.packJson.key;\r\n+            setIsBound(true);\r\n+        } catch (IOException e) {\r\n+            throw new GreeException(e, \"failed\");\r\n+        }\r\n+    }\r\n+\r\n+    public void setDevicePower(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Pow\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void SetDeviceMode(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 4)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Mod\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceSwingVertical(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 11)\r\n+                || (value.intValue() > 6 && value.intValue() < 10)) {\r\n+            return;\r\n+        }\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"SwUpDn\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Only allow this to happen if this device has been bound and values are valid\r\n+     * Possible values are :\r\n+     * 0 : Auto\r\n+     * 1 : Low\r\n+     * 2 : Medium Low\r\n+     * 3 : Medium\r\n+     * 4 : Medium High\r\n+     * 5 : High\r\n+     */\r\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 5)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"WdSpd\", value);\r\n+        parameters.put(\"Quiet\", 0);\r\n+        parameters.put(\"Tur\", 0);\r\n+        parameters.put(\"NoiseSet\", 0);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceTurbo(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Tur\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public int getDeviceTurbo() {\r\n+        return getIntStatusVal(\"Tur\");\r\n+    }\r\n+\r\n+    public void setDeviceLight(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Lig\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create Hash Look Up for C and F\r\n+     * Temperature Ranges for gree A/C units (f_range = {86,61}, c_range={16,30}\r\n+     */\r\n+    private static HashMap<String, HashMap<String, Integer>> createTempRangeMap() {\r\n+        HashMap<String, HashMap<String, Integer>> tempRanges = new HashMap<>();\r\n+        HashMap<String, Integer> hmf = new HashMap<>();\r\n+        HashMap<String, Integer> hmc = new HashMap<>();\r\n+\r\n+        hmf.put(\"min\", new Integer(61)); // F\r\n+        hmf.put(\"max\", new Integer(86));\r\n+        tempRanges.put(\"F\", hmf);\r\n+\r\n+        hmc.put(\"min\", new Integer(16)); // C\r\n+        hmc.put(\"max\", new Integer(30));\r\n+        tempRanges.put(\"C\", hmc);\r\n+\r\n+        return tempRanges;\r\n+    }\r\n+\r\n+    /**\r\n+     * Checks input ranges for validity and TempUn for validity\r\n+     * Uses newVal as priority and tries to validate and determine intent\r\n+     * For example if value is 75 and TempUn says Celsius, change TempUn to Fahrenheit\r\n+     */\r\n+    private Integer[] validateTemperatureRangeForTempSet(Integer newValIn, @Nullable Integer CorFIn) {\r\n+        final String[] minMaxLUT = { \"max\", \"min\" }; // looks up 0 = C = max, 1 = F = min\r\n+        final String[] tempScaleLUT = { \"C\", \"F\" }; // Look Up Table used to convert TempUn integer 0,1 to \"C\" to \"F\"\r\n+                                                    // string for hashmap\r\n+        HashMap<String, Integer> nullCorFLUT = new HashMap<>(); // simple look up table for logic\r\n+        nullCorFLUT.put(\"C\", new Integer(0));\r\n+        nullCorFLUT.put(\"F\", new Integer(1));\r\n+        nullCorFLUT.put(\"INVALID\", new Integer(0));\r\n+\r\n+        String validRangeCorF; // stores if the input range is a valid C or F temperature\r\n+\r\n+        // force to global min/max\r\n+        Integer newVal = Math.max(newValIn, Math.min(tempRanges.get(\"C\").get(\"min\"), tempRanges.get(\"F\").get(\"min\")));\r\n+        newVal = Math.min(newVal, Math.max(tempRanges.get(\"C\").get(\"max\"), tempRanges.get(\"F\").get(\"max\")));\r\n+\r\n+        if ((newVal >= tempRanges.get(\"C\").get(\"min\")) && (newVal <= tempRanges.get(\"C\").get(\"max\"))) {\r\n+            validRangeCorF = \"C\";\r\n+        } else if ((newVal >= tempRanges.get(\"F\").get(\"min\")) && (newVal <= tempRanges.get(\"F\").get(\"max\"))) {\r\n+            validRangeCorF = \"F\";\r\n+        } else {\r\n+            logger.warn(\"Input Temp request {} is invalid\", newVal);\r\n+            validRangeCorF = \"INVALID\";\r\n+        }\r\n+\r\n+        // if CorF wasnt initialized or is null set it from lookup\r\n+        Integer CorF = CorFIn != null ? CorFIn : nullCorFLUT.get(validRangeCorF);\r\n+\r\n+        if ((CorF == 1) && (validRangeCorF == \"C\")) {\r\n+            CorF = 0; // input temp takes priority\r\n+        } else if ((CorF == 0) && (validRangeCorF == \"F\")) {\r\n+            CorF = 1; // input temp takes priority\r\n+        } else if (validRangeCorF == \"INVALID\") {\r\n+            // force min or max temp based on CorF scale to be used\r\n+            newVal = tempRanges.get(tempScaleLUT[CorF]).get(minMaxLUT[CorF]);\r\n+        }\r\n+\r\n+        return new Integer[] { newVal, CorF };\r\n+    }\r\n+\r\n+    public void setDeviceTempSet(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // **value** : set temperature in degrees celsius or Fahrenheit\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+        Integer[] retList;\r\n+        Integer newVal = new Integer(value);\r\n+        Integer outVal = new Integer(value);\r\n+        // Get Celsius or Fahrenheit from status message\r\n+        Integer CorF = getIntStatusVal(\"TemUn\");\r\n+        // TODO put a param in openhab to allow setting this from the config\r\n+\r\n+        // If commanding Fahrenheit set halfStep to 1 or 0 to tell the A/C which F integer\r\n+        // temperature to use as celsius alone is ambigious\r\n+        Integer halfStep = new Integer(0); // default to C\r\n+\r\n+        retList = validateTemperatureRangeForTempSet(newVal, CorF);\r\n+        newVal = retList[0];\r\n+        CorF = retList[1];\r\n+\r\n+        if (CorF == 1) { // If Fahrenheit,\r\n+            // value argument is degrees F, convert Fahrenheit to Celsius,\r\n+            // SetTem input to A/C always in Celsius despite passing in 1 to TemUn\r\n+            outVal = new Integer((int) Math.round((newVal - 32.) * 5.0 / 9.0)); // Integer Truncated\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 366}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MDczMQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        // subtract the float verison - the int version to get the fractional difference\n          \n          \n            \n                        // subtract the float version - the int version to get the fractional difference", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432880731", "createdAt": "2020-05-30T19:28:48Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,690 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal.discovery;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.StringReader;\r\n+import java.net.DatagramPacket;\r\n+import java.net.DatagramSocket;\r\n+import java.net.InetAddress;\r\n+import java.nio.charset.Charset;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Objects;\r\n+import java.util.Optional;\r\n+\r\n+import org.apache.commons.lang.Validate;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\r\n+import org.openhab.binding.gree.internal.GreeException;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.stream.JsonReader;\r\n+\r\n+/**\r\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\r\n+ * device specific attributes as well a the functionality for the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+// @NonNullByDefault\r\n+public class GreeAirDevice {\r\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\r\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\r\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\r\n+    private boolean isBound = false;\r\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\r\n+    private int port = 0;\r\n+    private String encKey = \"\";\r\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\r\n+    private GreeBindResponse4GsonDTO bindResponseGson;\r\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\r\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\r\n+\r\n+    public Boolean getIsBound() {\r\n+        return isBound;\r\n+    }\r\n+\r\n+    public void setIsBound(boolean isBound) {\r\n+        this.isBound = isBound;\r\n+    }\r\n+\r\n+    public InetAddress getAddress() {\r\n+        return ipAddress;\r\n+    }\r\n+\r\n+    public void setAddress(InetAddress address) {\r\n+        this.ipAddress = address;\r\n+    }\r\n+\r\n+    public int getPort() {\r\n+        return port;\r\n+    }\r\n+\r\n+    public void setPort(int port) {\r\n+        this.port = port;\r\n+    }\r\n+\r\n+    public String getKey() {\r\n+        return encKey;\r\n+    }\r\n+\r\n+    public String getId() {\r\n+        return mScanResponseGson.packJson.mac;\r\n+    }\r\n+\r\n+    public String getName() {\r\n+        return mScanResponseGson.packJson.name;\r\n+    }\r\n+\r\n+    public String getVendor() {\r\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\r\n+    }\r\n+\r\n+    public String getModel() {\r\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\r\n+    }\r\n+\r\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\r\n+        return mScanResponseGson;\r\n+    }\r\n+\r\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\r\n+        mScanResponseGson = gson;\r\n+    }\r\n+\r\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\r\n+        return bindResponseGson;\r\n+    }\r\n+\r\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\r\n+        return statusResponseGson;\r\n+    }\r\n+\r\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\r\n+        Validate.isTrue(socket.isPresent());\r\n+        byte[] sendData = new byte[1024];\r\n+        byte[] receiveData = new byte[347];\r\n+        Gson gson = new Gson();\r\n+\r\n+        try {\r\n+            // Prep the Binding Request pack\r\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\r\n+            bindReqPackGson.mac = getId();\r\n+            bindReqPackGson.t = \"bind\";\r\n+            bindReqPackGson.uid = 0;\r\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\r\n+\r\n+            // Now Encrypt the Binding Request pack\r\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindReqPackStr);\r\n+\r\n+            // Prep the Binding Request\r\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\r\n+            bindReqGson.cid = \"app\";\r\n+            bindReqGson.i = 1;\r\n+            bindReqGson.t = \"pack\";\r\n+            bindReqGson.uid = 0;\r\n+            bindReqGson.tcid = getId();\r\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\r\n+            String bindReqStr = gson.toJson(bindReqGson);\r\n+            sendData = bindReqStr.getBytes();\r\n+\r\n+            // Now Send the request\r\n+            DatagramSocket clientSocket = socket.get();\r\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\r\n+            clientSocket.send(sendPacket);\r\n+\r\n+            // Recieve a response\r\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\r\n+            clientSocket.receive(receivePacket);\r\n+            String modifiedSentence = new String(receivePacket.getData());\r\n+\r\n+            // Read the response\r\n+            StringReader stringReader = new StringReader(modifiedSentence);\r\n+            bindResponseGson = gson.fromJson(new JsonReader(stringReader), GreeBindResponse4GsonDTO.class);\r\n+            bindResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindResponseGson.pack);\r\n+\r\n+            // Create the JSON to hold the response values\r\n+            stringReader = new StringReader(bindResponseGson.decryptedPack);\r\n+            bindResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePack4GsonDTO.class);\r\n+\r\n+            // Now set the key and flag to indicate the bind was succesful\r\n+            encKey = bindResponseGson.packJson.key;\r\n+            setIsBound(true);\r\n+        } catch (IOException e) {\r\n+            throw new GreeException(e, \"failed\");\r\n+        }\r\n+    }\r\n+\r\n+    public void setDevicePower(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Pow\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void SetDeviceMode(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 4)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Mod\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceSwingVertical(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 11)\r\n+                || (value.intValue() > 6 && value.intValue() < 10)) {\r\n+            return;\r\n+        }\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"SwUpDn\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Only allow this to happen if this device has been bound and values are valid\r\n+     * Possible values are :\r\n+     * 0 : Auto\r\n+     * 1 : Low\r\n+     * 2 : Medium Low\r\n+     * 3 : Medium\r\n+     * 4 : Medium High\r\n+     * 5 : High\r\n+     */\r\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 5)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"WdSpd\", value);\r\n+        parameters.put(\"Quiet\", 0);\r\n+        parameters.put(\"Tur\", 0);\r\n+        parameters.put(\"NoiseSet\", 0);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceTurbo(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Tur\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public int getDeviceTurbo() {\r\n+        return getIntStatusVal(\"Tur\");\r\n+    }\r\n+\r\n+    public void setDeviceLight(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Lig\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create Hash Look Up for C and F\r\n+     * Temperature Ranges for gree A/C units (f_range = {86,61}, c_range={16,30}\r\n+     */\r\n+    private static HashMap<String, HashMap<String, Integer>> createTempRangeMap() {\r\n+        HashMap<String, HashMap<String, Integer>> tempRanges = new HashMap<>();\r\n+        HashMap<String, Integer> hmf = new HashMap<>();\r\n+        HashMap<String, Integer> hmc = new HashMap<>();\r\n+\r\n+        hmf.put(\"min\", new Integer(61)); // F\r\n+        hmf.put(\"max\", new Integer(86));\r\n+        tempRanges.put(\"F\", hmf);\r\n+\r\n+        hmc.put(\"min\", new Integer(16)); // C\r\n+        hmc.put(\"max\", new Integer(30));\r\n+        tempRanges.put(\"C\", hmc);\r\n+\r\n+        return tempRanges;\r\n+    }\r\n+\r\n+    /**\r\n+     * Checks input ranges for validity and TempUn for validity\r\n+     * Uses newVal as priority and tries to validate and determine intent\r\n+     * For example if value is 75 and TempUn says Celsius, change TempUn to Fahrenheit\r\n+     */\r\n+    private Integer[] validateTemperatureRangeForTempSet(Integer newValIn, @Nullable Integer CorFIn) {\r\n+        final String[] minMaxLUT = { \"max\", \"min\" }; // looks up 0 = C = max, 1 = F = min\r\n+        final String[] tempScaleLUT = { \"C\", \"F\" }; // Look Up Table used to convert TempUn integer 0,1 to \"C\" to \"F\"\r\n+                                                    // string for hashmap\r\n+        HashMap<String, Integer> nullCorFLUT = new HashMap<>(); // simple look up table for logic\r\n+        nullCorFLUT.put(\"C\", new Integer(0));\r\n+        nullCorFLUT.put(\"F\", new Integer(1));\r\n+        nullCorFLUT.put(\"INVALID\", new Integer(0));\r\n+\r\n+        String validRangeCorF; // stores if the input range is a valid C or F temperature\r\n+\r\n+        // force to global min/max\r\n+        Integer newVal = Math.max(newValIn, Math.min(tempRanges.get(\"C\").get(\"min\"), tempRanges.get(\"F\").get(\"min\")));\r\n+        newVal = Math.min(newVal, Math.max(tempRanges.get(\"C\").get(\"max\"), tempRanges.get(\"F\").get(\"max\")));\r\n+\r\n+        if ((newVal >= tempRanges.get(\"C\").get(\"min\")) && (newVal <= tempRanges.get(\"C\").get(\"max\"))) {\r\n+            validRangeCorF = \"C\";\r\n+        } else if ((newVal >= tempRanges.get(\"F\").get(\"min\")) && (newVal <= tempRanges.get(\"F\").get(\"max\"))) {\r\n+            validRangeCorF = \"F\";\r\n+        } else {\r\n+            logger.warn(\"Input Temp request {} is invalid\", newVal);\r\n+            validRangeCorF = \"INVALID\";\r\n+        }\r\n+\r\n+        // if CorF wasnt initialized or is null set it from lookup\r\n+        Integer CorF = CorFIn != null ? CorFIn : nullCorFLUT.get(validRangeCorF);\r\n+\r\n+        if ((CorF == 1) && (validRangeCorF == \"C\")) {\r\n+            CorF = 0; // input temp takes priority\r\n+        } else if ((CorF == 0) && (validRangeCorF == \"F\")) {\r\n+            CorF = 1; // input temp takes priority\r\n+        } else if (validRangeCorF == \"INVALID\") {\r\n+            // force min or max temp based on CorF scale to be used\r\n+            newVal = tempRanges.get(tempScaleLUT[CorF]).get(minMaxLUT[CorF]);\r\n+        }\r\n+\r\n+        return new Integer[] { newVal, CorF };\r\n+    }\r\n+\r\n+    public void setDeviceTempSet(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // **value** : set temperature in degrees celsius or Fahrenheit\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+        Integer[] retList;\r\n+        Integer newVal = new Integer(value);\r\n+        Integer outVal = new Integer(value);\r\n+        // Get Celsius or Fahrenheit from status message\r\n+        Integer CorF = getIntStatusVal(\"TemUn\");\r\n+        // TODO put a param in openhab to allow setting this from the config\r\n+\r\n+        // If commanding Fahrenheit set halfStep to 1 or 0 to tell the A/C which F integer\r\n+        // temperature to use as celsius alone is ambigious\r\n+        Integer halfStep = new Integer(0); // default to C\r\n+\r\n+        retList = validateTemperatureRangeForTempSet(newVal, CorF);\r\n+        newVal = retList[0];\r\n+        CorF = retList[1];\r\n+\r\n+        if (CorF == 1) { // If Fahrenheit,\r\n+            // value argument is degrees F, convert Fahrenheit to Celsius,\r\n+            // SetTem input to A/C always in Celsius despite passing in 1 to TemUn\r\n+            outVal = new Integer((int) Math.round((newVal - 32.) * 5.0 / 9.0)); // Integer Truncated\r\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\r\n+            // F = [68. , 69. , 70. , 71. , 72. , 73. , 74. , 75. , 76. , 77. , 78. , 79. , 80. , 81. , 82. , 83. ,\r\n+            // 84. , 85. , 86. ]\r\n+            // C = [20.0, 20.5, 21.1, 21.6, 22.2, 22.7, 23.3, 23.8, 24.4, 25.0, 25.5, 26.1, 26.6, 27.2, 27.7, 28.3,\r\n+            // 28.8, 29.4, 30.0]\r\n+            // TemSet = [20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 30, 30]\r\n+            // TemRec = [ 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]\r\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\r\n+            // subtract the float verison - the int version to get the fractional difference\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 375}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MDc0NQ==", "bodyText": "Primitive types", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432880745", "createdAt": "2020-05-30T19:29:14Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,690 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal.discovery;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.StringReader;\r\n+import java.net.DatagramPacket;\r\n+import java.net.DatagramSocket;\r\n+import java.net.InetAddress;\r\n+import java.nio.charset.Charset;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Objects;\r\n+import java.util.Optional;\r\n+\r\n+import org.apache.commons.lang.Validate;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\r\n+import org.openhab.binding.gree.internal.GreeException;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.stream.JsonReader;\r\n+\r\n+/**\r\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\r\n+ * device specific attributes as well a the functionality for the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+// @NonNullByDefault\r\n+public class GreeAirDevice {\r\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\r\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\r\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\r\n+    private boolean isBound = false;\r\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\r\n+    private int port = 0;\r\n+    private String encKey = \"\";\r\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\r\n+    private GreeBindResponse4GsonDTO bindResponseGson;\r\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\r\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\r\n+\r\n+    public Boolean getIsBound() {\r\n+        return isBound;\r\n+    }\r\n+\r\n+    public void setIsBound(boolean isBound) {\r\n+        this.isBound = isBound;\r\n+    }\r\n+\r\n+    public InetAddress getAddress() {\r\n+        return ipAddress;\r\n+    }\r\n+\r\n+    public void setAddress(InetAddress address) {\r\n+        this.ipAddress = address;\r\n+    }\r\n+\r\n+    public int getPort() {\r\n+        return port;\r\n+    }\r\n+\r\n+    public void setPort(int port) {\r\n+        this.port = port;\r\n+    }\r\n+\r\n+    public String getKey() {\r\n+        return encKey;\r\n+    }\r\n+\r\n+    public String getId() {\r\n+        return mScanResponseGson.packJson.mac;\r\n+    }\r\n+\r\n+    public String getName() {\r\n+        return mScanResponseGson.packJson.name;\r\n+    }\r\n+\r\n+    public String getVendor() {\r\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\r\n+    }\r\n+\r\n+    public String getModel() {\r\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\r\n+    }\r\n+\r\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\r\n+        return mScanResponseGson;\r\n+    }\r\n+\r\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\r\n+        mScanResponseGson = gson;\r\n+    }\r\n+\r\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\r\n+        return bindResponseGson;\r\n+    }\r\n+\r\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\r\n+        return statusResponseGson;\r\n+    }\r\n+\r\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\r\n+        Validate.isTrue(socket.isPresent());\r\n+        byte[] sendData = new byte[1024];\r\n+        byte[] receiveData = new byte[347];\r\n+        Gson gson = new Gson();\r\n+\r\n+        try {\r\n+            // Prep the Binding Request pack\r\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\r\n+            bindReqPackGson.mac = getId();\r\n+            bindReqPackGson.t = \"bind\";\r\n+            bindReqPackGson.uid = 0;\r\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\r\n+\r\n+            // Now Encrypt the Binding Request pack\r\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindReqPackStr);\r\n+\r\n+            // Prep the Binding Request\r\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\r\n+            bindReqGson.cid = \"app\";\r\n+            bindReqGson.i = 1;\r\n+            bindReqGson.t = \"pack\";\r\n+            bindReqGson.uid = 0;\r\n+            bindReqGson.tcid = getId();\r\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\r\n+            String bindReqStr = gson.toJson(bindReqGson);\r\n+            sendData = bindReqStr.getBytes();\r\n+\r\n+            // Now Send the request\r\n+            DatagramSocket clientSocket = socket.get();\r\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\r\n+            clientSocket.send(sendPacket);\r\n+\r\n+            // Recieve a response\r\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\r\n+            clientSocket.receive(receivePacket);\r\n+            String modifiedSentence = new String(receivePacket.getData());\r\n+\r\n+            // Read the response\r\n+            StringReader stringReader = new StringReader(modifiedSentence);\r\n+            bindResponseGson = gson.fromJson(new JsonReader(stringReader), GreeBindResponse4GsonDTO.class);\r\n+            bindResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindResponseGson.pack);\r\n+\r\n+            // Create the JSON to hold the response values\r\n+            stringReader = new StringReader(bindResponseGson.decryptedPack);\r\n+            bindResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePack4GsonDTO.class);\r\n+\r\n+            // Now set the key and flag to indicate the bind was succesful\r\n+            encKey = bindResponseGson.packJson.key;\r\n+            setIsBound(true);\r\n+        } catch (IOException e) {\r\n+            throw new GreeException(e, \"failed\");\r\n+        }\r\n+    }\r\n+\r\n+    public void setDevicePower(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Pow\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void SetDeviceMode(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 4)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Mod\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceSwingVertical(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 11)\r\n+                || (value.intValue() > 6 && value.intValue() < 10)) {\r\n+            return;\r\n+        }\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"SwUpDn\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Only allow this to happen if this device has been bound and values are valid\r\n+     * Possible values are :\r\n+     * 0 : Auto\r\n+     * 1 : Low\r\n+     * 2 : Medium Low\r\n+     * 3 : Medium\r\n+     * 4 : Medium High\r\n+     * 5 : High\r\n+     */\r\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 5)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"WdSpd\", value);\r\n+        parameters.put(\"Quiet\", 0);\r\n+        parameters.put(\"Tur\", 0);\r\n+        parameters.put(\"NoiseSet\", 0);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceTurbo(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Tur\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public int getDeviceTurbo() {\r\n+        return getIntStatusVal(\"Tur\");\r\n+    }\r\n+\r\n+    public void setDeviceLight(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Lig\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create Hash Look Up for C and F\r\n+     * Temperature Ranges for gree A/C units (f_range = {86,61}, c_range={16,30}\r\n+     */\r\n+    private static HashMap<String, HashMap<String, Integer>> createTempRangeMap() {\r\n+        HashMap<String, HashMap<String, Integer>> tempRanges = new HashMap<>();\r\n+        HashMap<String, Integer> hmf = new HashMap<>();\r\n+        HashMap<String, Integer> hmc = new HashMap<>();\r\n+\r\n+        hmf.put(\"min\", new Integer(61)); // F\r\n+        hmf.put(\"max\", new Integer(86));\r\n+        tempRanges.put(\"F\", hmf);\r\n+\r\n+        hmc.put(\"min\", new Integer(16)); // C\r\n+        hmc.put(\"max\", new Integer(30));\r\n+        tempRanges.put(\"C\", hmc);\r\n+\r\n+        return tempRanges;\r\n+    }\r\n+\r\n+    /**\r\n+     * Checks input ranges for validity and TempUn for validity\r\n+     * Uses newVal as priority and tries to validate and determine intent\r\n+     * For example if value is 75 and TempUn says Celsius, change TempUn to Fahrenheit\r\n+     */\r\n+    private Integer[] validateTemperatureRangeForTempSet(Integer newValIn, @Nullable Integer CorFIn) {\r\n+        final String[] minMaxLUT = { \"max\", \"min\" }; // looks up 0 = C = max, 1 = F = min\r\n+        final String[] tempScaleLUT = { \"C\", \"F\" }; // Look Up Table used to convert TempUn integer 0,1 to \"C\" to \"F\"\r\n+                                                    // string for hashmap\r\n+        HashMap<String, Integer> nullCorFLUT = new HashMap<>(); // simple look up table for logic\r\n+        nullCorFLUT.put(\"C\", new Integer(0));\r\n+        nullCorFLUT.put(\"F\", new Integer(1));\r\n+        nullCorFLUT.put(\"INVALID\", new Integer(0));\r\n+\r\n+        String validRangeCorF; // stores if the input range is a valid C or F temperature\r\n+\r\n+        // force to global min/max\r\n+        Integer newVal = Math.max(newValIn, Math.min(tempRanges.get(\"C\").get(\"min\"), tempRanges.get(\"F\").get(\"min\")));\r\n+        newVal = Math.min(newVal, Math.max(tempRanges.get(\"C\").get(\"max\"), tempRanges.get(\"F\").get(\"max\")));\r\n+\r\n+        if ((newVal >= tempRanges.get(\"C\").get(\"min\")) && (newVal <= tempRanges.get(\"C\").get(\"max\"))) {\r\n+            validRangeCorF = \"C\";\r\n+        } else if ((newVal >= tempRanges.get(\"F\").get(\"min\")) && (newVal <= tempRanges.get(\"F\").get(\"max\"))) {\r\n+            validRangeCorF = \"F\";\r\n+        } else {\r\n+            logger.warn(\"Input Temp request {} is invalid\", newVal);\r\n+            validRangeCorF = \"INVALID\";\r\n+        }\r\n+\r\n+        // if CorF wasnt initialized or is null set it from lookup\r\n+        Integer CorF = CorFIn != null ? CorFIn : nullCorFLUT.get(validRangeCorF);\r\n+\r\n+        if ((CorF == 1) && (validRangeCorF == \"C\")) {\r\n+            CorF = 0; // input temp takes priority\r\n+        } else if ((CorF == 0) && (validRangeCorF == \"F\")) {\r\n+            CorF = 1; // input temp takes priority\r\n+        } else if (validRangeCorF == \"INVALID\") {\r\n+            // force min or max temp based on CorF scale to be used\r\n+            newVal = tempRanges.get(tempScaleLUT[CorF]).get(minMaxLUT[CorF]);\r\n+        }\r\n+\r\n+        return new Integer[] { newVal, CorF };\r\n+    }\r\n+\r\n+    public void setDeviceTempSet(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // **value** : set temperature in degrees celsius or Fahrenheit\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+        Integer[] retList;\r\n+        Integer newVal = new Integer(value);\r\n+        Integer outVal = new Integer(value);\r\n+        // Get Celsius or Fahrenheit from status message\r\n+        Integer CorF = getIntStatusVal(\"TemUn\");\r\n+        // TODO put a param in openhab to allow setting this from the config\r\n+\r\n+        // If commanding Fahrenheit set halfStep to 1 or 0 to tell the A/C which F integer\r\n+        // temperature to use as celsius alone is ambigious\r\n+        Integer halfStep = new Integer(0); // default to C\r\n+\r\n+        retList = validateTemperatureRangeForTempSet(newVal, CorF);\r\n+        newVal = retList[0];\r\n+        CorF = retList[1];\r\n+\r\n+        if (CorF == 1) { // If Fahrenheit,\r\n+            // value argument is degrees F, convert Fahrenheit to Celsius,\r\n+            // SetTem input to A/C always in Celsius despite passing in 1 to TemUn\r\n+            outVal = new Integer((int) Math.round((newVal - 32.) * 5.0 / 9.0)); // Integer Truncated\r\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\r\n+            // F = [68. , 69. , 70. , 71. , 72. , 73. , 74. , 75. , 76. , 77. , 78. , 79. , 80. , 81. , 82. , 83. ,\r\n+            // 84. , 85. , 86. ]\r\n+            // C = [20.0, 20.5, 21.1, 21.6, 22.2, 22.7, 23.3, 23.8, 24.4, 25.0, 25.5, 26.1, 26.6, 27.2, 27.7, 28.3,\r\n+            // 28.8, 29.4, 30.0]\r\n+            // TemSet = [20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 30, 30]\r\n+            // TemRec = [ 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]\r\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\r\n+            // subtract the float verison - the int version to get the fractional difference\r\n+            // if the difference is positive set halfStep to 1, negative to 0\r\n+            halfStep = ((((newVal - 32.) * 5.0 / 9.0) - outVal) > 0) ? 1 : 0;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"TemUn\", CorF);\r\n+        parameters.put(\"SetTem\", outVal);\r\n+        parameters.put(\"TemRec\", halfStep);\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceAir(DatagramSocket clientSocket, Integer value) throws GreeException {\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 389}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MDc1NA==", "bodyText": "See above", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432880754", "createdAt": "2020-05-30T19:29:20Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,690 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal.discovery;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.StringReader;\r\n+import java.net.DatagramPacket;\r\n+import java.net.DatagramSocket;\r\n+import java.net.InetAddress;\r\n+import java.nio.charset.Charset;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Objects;\r\n+import java.util.Optional;\r\n+\r\n+import org.apache.commons.lang.Validate;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\r\n+import org.openhab.binding.gree.internal.GreeException;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.stream.JsonReader;\r\n+\r\n+/**\r\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\r\n+ * device specific attributes as well a the functionality for the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+// @NonNullByDefault\r\n+public class GreeAirDevice {\r\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\r\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\r\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\r\n+    private boolean isBound = false;\r\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\r\n+    private int port = 0;\r\n+    private String encKey = \"\";\r\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\r\n+    private GreeBindResponse4GsonDTO bindResponseGson;\r\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\r\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\r\n+\r\n+    public Boolean getIsBound() {\r\n+        return isBound;\r\n+    }\r\n+\r\n+    public void setIsBound(boolean isBound) {\r\n+        this.isBound = isBound;\r\n+    }\r\n+\r\n+    public InetAddress getAddress() {\r\n+        return ipAddress;\r\n+    }\r\n+\r\n+    public void setAddress(InetAddress address) {\r\n+        this.ipAddress = address;\r\n+    }\r\n+\r\n+    public int getPort() {\r\n+        return port;\r\n+    }\r\n+\r\n+    public void setPort(int port) {\r\n+        this.port = port;\r\n+    }\r\n+\r\n+    public String getKey() {\r\n+        return encKey;\r\n+    }\r\n+\r\n+    public String getId() {\r\n+        return mScanResponseGson.packJson.mac;\r\n+    }\r\n+\r\n+    public String getName() {\r\n+        return mScanResponseGson.packJson.name;\r\n+    }\r\n+\r\n+    public String getVendor() {\r\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\r\n+    }\r\n+\r\n+    public String getModel() {\r\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\r\n+    }\r\n+\r\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\r\n+        return mScanResponseGson;\r\n+    }\r\n+\r\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\r\n+        mScanResponseGson = gson;\r\n+    }\r\n+\r\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\r\n+        return bindResponseGson;\r\n+    }\r\n+\r\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\r\n+        return statusResponseGson;\r\n+    }\r\n+\r\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\r\n+        Validate.isTrue(socket.isPresent());\r\n+        byte[] sendData = new byte[1024];\r\n+        byte[] receiveData = new byte[347];\r\n+        Gson gson = new Gson();\r\n+\r\n+        try {\r\n+            // Prep the Binding Request pack\r\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\r\n+            bindReqPackGson.mac = getId();\r\n+            bindReqPackGson.t = \"bind\";\r\n+            bindReqPackGson.uid = 0;\r\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\r\n+\r\n+            // Now Encrypt the Binding Request pack\r\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindReqPackStr);\r\n+\r\n+            // Prep the Binding Request\r\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\r\n+            bindReqGson.cid = \"app\";\r\n+            bindReqGson.i = 1;\r\n+            bindReqGson.t = \"pack\";\r\n+            bindReqGson.uid = 0;\r\n+            bindReqGson.tcid = getId();\r\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\r\n+            String bindReqStr = gson.toJson(bindReqGson);\r\n+            sendData = bindReqStr.getBytes();\r\n+\r\n+            // Now Send the request\r\n+            DatagramSocket clientSocket = socket.get();\r\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\r\n+            clientSocket.send(sendPacket);\r\n+\r\n+            // Recieve a response\r\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\r\n+            clientSocket.receive(receivePacket);\r\n+            String modifiedSentence = new String(receivePacket.getData());\r\n+\r\n+            // Read the response\r\n+            StringReader stringReader = new StringReader(modifiedSentence);\r\n+            bindResponseGson = gson.fromJson(new JsonReader(stringReader), GreeBindResponse4GsonDTO.class);\r\n+            bindResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindResponseGson.pack);\r\n+\r\n+            // Create the JSON to hold the response values\r\n+            stringReader = new StringReader(bindResponseGson.decryptedPack);\r\n+            bindResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePack4GsonDTO.class);\r\n+\r\n+            // Now set the key and flag to indicate the bind was succesful\r\n+            encKey = bindResponseGson.packJson.key;\r\n+            setIsBound(true);\r\n+        } catch (IOException e) {\r\n+            throw new GreeException(e, \"failed\");\r\n+        }\r\n+    }\r\n+\r\n+    public void setDevicePower(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Pow\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void SetDeviceMode(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 4)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Mod\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceSwingVertical(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 11)\r\n+                || (value.intValue() > 6 && value.intValue() < 10)) {\r\n+            return;\r\n+        }\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"SwUpDn\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Only allow this to happen if this device has been bound and values are valid\r\n+     * Possible values are :\r\n+     * 0 : Auto\r\n+     * 1 : Low\r\n+     * 2 : Medium Low\r\n+     * 3 : Medium\r\n+     * 4 : Medium High\r\n+     * 5 : High\r\n+     */\r\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 5)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"WdSpd\", value);\r\n+        parameters.put(\"Quiet\", 0);\r\n+        parameters.put(\"Tur\", 0);\r\n+        parameters.put(\"NoiseSet\", 0);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceTurbo(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Tur\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public int getDeviceTurbo() {\r\n+        return getIntStatusVal(\"Tur\");\r\n+    }\r\n+\r\n+    public void setDeviceLight(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Lig\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create Hash Look Up for C and F\r\n+     * Temperature Ranges for gree A/C units (f_range = {86,61}, c_range={16,30}\r\n+     */\r\n+    private static HashMap<String, HashMap<String, Integer>> createTempRangeMap() {\r\n+        HashMap<String, HashMap<String, Integer>> tempRanges = new HashMap<>();\r\n+        HashMap<String, Integer> hmf = new HashMap<>();\r\n+        HashMap<String, Integer> hmc = new HashMap<>();\r\n+\r\n+        hmf.put(\"min\", new Integer(61)); // F\r\n+        hmf.put(\"max\", new Integer(86));\r\n+        tempRanges.put(\"F\", hmf);\r\n+\r\n+        hmc.put(\"min\", new Integer(16)); // C\r\n+        hmc.put(\"max\", new Integer(30));\r\n+        tempRanges.put(\"C\", hmc);\r\n+\r\n+        return tempRanges;\r\n+    }\r\n+\r\n+    /**\r\n+     * Checks input ranges for validity and TempUn for validity\r\n+     * Uses newVal as priority and tries to validate and determine intent\r\n+     * For example if value is 75 and TempUn says Celsius, change TempUn to Fahrenheit\r\n+     */\r\n+    private Integer[] validateTemperatureRangeForTempSet(Integer newValIn, @Nullable Integer CorFIn) {\r\n+        final String[] minMaxLUT = { \"max\", \"min\" }; // looks up 0 = C = max, 1 = F = min\r\n+        final String[] tempScaleLUT = { \"C\", \"F\" }; // Look Up Table used to convert TempUn integer 0,1 to \"C\" to \"F\"\r\n+                                                    // string for hashmap\r\n+        HashMap<String, Integer> nullCorFLUT = new HashMap<>(); // simple look up table for logic\r\n+        nullCorFLUT.put(\"C\", new Integer(0));\r\n+        nullCorFLUT.put(\"F\", new Integer(1));\r\n+        nullCorFLUT.put(\"INVALID\", new Integer(0));\r\n+\r\n+        String validRangeCorF; // stores if the input range is a valid C or F temperature\r\n+\r\n+        // force to global min/max\r\n+        Integer newVal = Math.max(newValIn, Math.min(tempRanges.get(\"C\").get(\"min\"), tempRanges.get(\"F\").get(\"min\")));\r\n+        newVal = Math.min(newVal, Math.max(tempRanges.get(\"C\").get(\"max\"), tempRanges.get(\"F\").get(\"max\")));\r\n+\r\n+        if ((newVal >= tempRanges.get(\"C\").get(\"min\")) && (newVal <= tempRanges.get(\"C\").get(\"max\"))) {\r\n+            validRangeCorF = \"C\";\r\n+        } else if ((newVal >= tempRanges.get(\"F\").get(\"min\")) && (newVal <= tempRanges.get(\"F\").get(\"max\"))) {\r\n+            validRangeCorF = \"F\";\r\n+        } else {\r\n+            logger.warn(\"Input Temp request {} is invalid\", newVal);\r\n+            validRangeCorF = \"INVALID\";\r\n+        }\r\n+\r\n+        // if CorF wasnt initialized or is null set it from lookup\r\n+        Integer CorF = CorFIn != null ? CorFIn : nullCorFLUT.get(validRangeCorF);\r\n+\r\n+        if ((CorF == 1) && (validRangeCorF == \"C\")) {\r\n+            CorF = 0; // input temp takes priority\r\n+        } else if ((CorF == 0) && (validRangeCorF == \"F\")) {\r\n+            CorF = 1; // input temp takes priority\r\n+        } else if (validRangeCorF == \"INVALID\") {\r\n+            // force min or max temp based on CorF scale to be used\r\n+            newVal = tempRanges.get(tempScaleLUT[CorF]).get(minMaxLUT[CorF]);\r\n+        }\r\n+\r\n+        return new Integer[] { newVal, CorF };\r\n+    }\r\n+\r\n+    public void setDeviceTempSet(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // **value** : set temperature in degrees celsius or Fahrenheit\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+        Integer[] retList;\r\n+        Integer newVal = new Integer(value);\r\n+        Integer outVal = new Integer(value);\r\n+        // Get Celsius or Fahrenheit from status message\r\n+        Integer CorF = getIntStatusVal(\"TemUn\");\r\n+        // TODO put a param in openhab to allow setting this from the config\r\n+\r\n+        // If commanding Fahrenheit set halfStep to 1 or 0 to tell the A/C which F integer\r\n+        // temperature to use as celsius alone is ambigious\r\n+        Integer halfStep = new Integer(0); // default to C\r\n+\r\n+        retList = validateTemperatureRangeForTempSet(newVal, CorF);\r\n+        newVal = retList[0];\r\n+        CorF = retList[1];\r\n+\r\n+        if (CorF == 1) { // If Fahrenheit,\r\n+            // value argument is degrees F, convert Fahrenheit to Celsius,\r\n+            // SetTem input to A/C always in Celsius despite passing in 1 to TemUn\r\n+            outVal = new Integer((int) Math.round((newVal - 32.) * 5.0 / 9.0)); // Integer Truncated\r\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\r\n+            // F = [68. , 69. , 70. , 71. , 72. , 73. , 74. , 75. , 76. , 77. , 78. , 79. , 80. , 81. , 82. , 83. ,\r\n+            // 84. , 85. , 86. ]\r\n+            // C = [20.0, 20.5, 21.1, 21.6, 22.2, 22.7, 23.3, 23.8, 24.4, 25.0, 25.5, 26.1, 26.6, 27.2, 27.7, 28.3,\r\n+            // 28.8, 29.4, 30.0]\r\n+            // TemSet = [20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 30, 30]\r\n+            // TemRec = [ 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]\r\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\r\n+            // subtract the float verison - the int version to get the fractional difference\r\n+            // if the difference is positive set halfStep to 1, negative to 0\r\n+            halfStep = ((((newVal - 32.) * 5.0 / 9.0) - outVal) > 0) ? 1 : 0;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"TemUn\", CorF);\r\n+        parameters.put(\"SetTem\", outVal);\r\n+        parameters.put(\"TemRec\", halfStep);\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceAir(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 391}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MDc2NA==", "bodyText": "Primitive types", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432880764", "createdAt": "2020-05-30T19:29:31Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,690 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal.discovery;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.StringReader;\r\n+import java.net.DatagramPacket;\r\n+import java.net.DatagramSocket;\r\n+import java.net.InetAddress;\r\n+import java.nio.charset.Charset;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Objects;\r\n+import java.util.Optional;\r\n+\r\n+import org.apache.commons.lang.Validate;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\r\n+import org.openhab.binding.gree.internal.GreeException;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.stream.JsonReader;\r\n+\r\n+/**\r\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\r\n+ * device specific attributes as well a the functionality for the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+// @NonNullByDefault\r\n+public class GreeAirDevice {\r\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\r\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\r\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\r\n+    private boolean isBound = false;\r\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\r\n+    private int port = 0;\r\n+    private String encKey = \"\";\r\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\r\n+    private GreeBindResponse4GsonDTO bindResponseGson;\r\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\r\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\r\n+\r\n+    public Boolean getIsBound() {\r\n+        return isBound;\r\n+    }\r\n+\r\n+    public void setIsBound(boolean isBound) {\r\n+        this.isBound = isBound;\r\n+    }\r\n+\r\n+    public InetAddress getAddress() {\r\n+        return ipAddress;\r\n+    }\r\n+\r\n+    public void setAddress(InetAddress address) {\r\n+        this.ipAddress = address;\r\n+    }\r\n+\r\n+    public int getPort() {\r\n+        return port;\r\n+    }\r\n+\r\n+    public void setPort(int port) {\r\n+        this.port = port;\r\n+    }\r\n+\r\n+    public String getKey() {\r\n+        return encKey;\r\n+    }\r\n+\r\n+    public String getId() {\r\n+        return mScanResponseGson.packJson.mac;\r\n+    }\r\n+\r\n+    public String getName() {\r\n+        return mScanResponseGson.packJson.name;\r\n+    }\r\n+\r\n+    public String getVendor() {\r\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\r\n+    }\r\n+\r\n+    public String getModel() {\r\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\r\n+    }\r\n+\r\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\r\n+        return mScanResponseGson;\r\n+    }\r\n+\r\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\r\n+        mScanResponseGson = gson;\r\n+    }\r\n+\r\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\r\n+        return bindResponseGson;\r\n+    }\r\n+\r\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\r\n+        return statusResponseGson;\r\n+    }\r\n+\r\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\r\n+        Validate.isTrue(socket.isPresent());\r\n+        byte[] sendData = new byte[1024];\r\n+        byte[] receiveData = new byte[347];\r\n+        Gson gson = new Gson();\r\n+\r\n+        try {\r\n+            // Prep the Binding Request pack\r\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\r\n+            bindReqPackGson.mac = getId();\r\n+            bindReqPackGson.t = \"bind\";\r\n+            bindReqPackGson.uid = 0;\r\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\r\n+\r\n+            // Now Encrypt the Binding Request pack\r\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindReqPackStr);\r\n+\r\n+            // Prep the Binding Request\r\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\r\n+            bindReqGson.cid = \"app\";\r\n+            bindReqGson.i = 1;\r\n+            bindReqGson.t = \"pack\";\r\n+            bindReqGson.uid = 0;\r\n+            bindReqGson.tcid = getId();\r\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\r\n+            String bindReqStr = gson.toJson(bindReqGson);\r\n+            sendData = bindReqStr.getBytes();\r\n+\r\n+            // Now Send the request\r\n+            DatagramSocket clientSocket = socket.get();\r\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\r\n+            clientSocket.send(sendPacket);\r\n+\r\n+            // Recieve a response\r\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\r\n+            clientSocket.receive(receivePacket);\r\n+            String modifiedSentence = new String(receivePacket.getData());\r\n+\r\n+            // Read the response\r\n+            StringReader stringReader = new StringReader(modifiedSentence);\r\n+            bindResponseGson = gson.fromJson(new JsonReader(stringReader), GreeBindResponse4GsonDTO.class);\r\n+            bindResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindResponseGson.pack);\r\n+\r\n+            // Create the JSON to hold the response values\r\n+            stringReader = new StringReader(bindResponseGson.decryptedPack);\r\n+            bindResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePack4GsonDTO.class);\r\n+\r\n+            // Now set the key and flag to indicate the bind was succesful\r\n+            encKey = bindResponseGson.packJson.key;\r\n+            setIsBound(true);\r\n+        } catch (IOException e) {\r\n+            throw new GreeException(e, \"failed\");\r\n+        }\r\n+    }\r\n+\r\n+    public void setDevicePower(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Pow\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void SetDeviceMode(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 4)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Mod\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceSwingVertical(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 11)\r\n+                || (value.intValue() > 6 && value.intValue() < 10)) {\r\n+            return;\r\n+        }\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"SwUpDn\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Only allow this to happen if this device has been bound and values are valid\r\n+     * Possible values are :\r\n+     * 0 : Auto\r\n+     * 1 : Low\r\n+     * 2 : Medium Low\r\n+     * 3 : Medium\r\n+     * 4 : Medium High\r\n+     * 5 : High\r\n+     */\r\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 5)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"WdSpd\", value);\r\n+        parameters.put(\"Quiet\", 0);\r\n+        parameters.put(\"Tur\", 0);\r\n+        parameters.put(\"NoiseSet\", 0);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceTurbo(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Tur\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public int getDeviceTurbo() {\r\n+        return getIntStatusVal(\"Tur\");\r\n+    }\r\n+\r\n+    public void setDeviceLight(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Lig\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create Hash Look Up for C and F\r\n+     * Temperature Ranges for gree A/C units (f_range = {86,61}, c_range={16,30}\r\n+     */\r\n+    private static HashMap<String, HashMap<String, Integer>> createTempRangeMap() {\r\n+        HashMap<String, HashMap<String, Integer>> tempRanges = new HashMap<>();\r\n+        HashMap<String, Integer> hmf = new HashMap<>();\r\n+        HashMap<String, Integer> hmc = new HashMap<>();\r\n+\r\n+        hmf.put(\"min\", new Integer(61)); // F\r\n+        hmf.put(\"max\", new Integer(86));\r\n+        tempRanges.put(\"F\", hmf);\r\n+\r\n+        hmc.put(\"min\", new Integer(16)); // C\r\n+        hmc.put(\"max\", new Integer(30));\r\n+        tempRanges.put(\"C\", hmc);\r\n+\r\n+        return tempRanges;\r\n+    }\r\n+\r\n+    /**\r\n+     * Checks input ranges for validity and TempUn for validity\r\n+     * Uses newVal as priority and tries to validate and determine intent\r\n+     * For example if value is 75 and TempUn says Celsius, change TempUn to Fahrenheit\r\n+     */\r\n+    private Integer[] validateTemperatureRangeForTempSet(Integer newValIn, @Nullable Integer CorFIn) {\r\n+        final String[] minMaxLUT = { \"max\", \"min\" }; // looks up 0 = C = max, 1 = F = min\r\n+        final String[] tempScaleLUT = { \"C\", \"F\" }; // Look Up Table used to convert TempUn integer 0,1 to \"C\" to \"F\"\r\n+                                                    // string for hashmap\r\n+        HashMap<String, Integer> nullCorFLUT = new HashMap<>(); // simple look up table for logic\r\n+        nullCorFLUT.put(\"C\", new Integer(0));\r\n+        nullCorFLUT.put(\"F\", new Integer(1));\r\n+        nullCorFLUT.put(\"INVALID\", new Integer(0));\r\n+\r\n+        String validRangeCorF; // stores if the input range is a valid C or F temperature\r\n+\r\n+        // force to global min/max\r\n+        Integer newVal = Math.max(newValIn, Math.min(tempRanges.get(\"C\").get(\"min\"), tempRanges.get(\"F\").get(\"min\")));\r\n+        newVal = Math.min(newVal, Math.max(tempRanges.get(\"C\").get(\"max\"), tempRanges.get(\"F\").get(\"max\")));\r\n+\r\n+        if ((newVal >= tempRanges.get(\"C\").get(\"min\")) && (newVal <= tempRanges.get(\"C\").get(\"max\"))) {\r\n+            validRangeCorF = \"C\";\r\n+        } else if ((newVal >= tempRanges.get(\"F\").get(\"min\")) && (newVal <= tempRanges.get(\"F\").get(\"max\"))) {\r\n+            validRangeCorF = \"F\";\r\n+        } else {\r\n+            logger.warn(\"Input Temp request {} is invalid\", newVal);\r\n+            validRangeCorF = \"INVALID\";\r\n+        }\r\n+\r\n+        // if CorF wasnt initialized or is null set it from lookup\r\n+        Integer CorF = CorFIn != null ? CorFIn : nullCorFLUT.get(validRangeCorF);\r\n+\r\n+        if ((CorF == 1) && (validRangeCorF == \"C\")) {\r\n+            CorF = 0; // input temp takes priority\r\n+        } else if ((CorF == 0) && (validRangeCorF == \"F\")) {\r\n+            CorF = 1; // input temp takes priority\r\n+        } else if (validRangeCorF == \"INVALID\") {\r\n+            // force min or max temp based on CorF scale to be used\r\n+            newVal = tempRanges.get(tempScaleLUT[CorF]).get(minMaxLUT[CorF]);\r\n+        }\r\n+\r\n+        return new Integer[] { newVal, CorF };\r\n+    }\r\n+\r\n+    public void setDeviceTempSet(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // **value** : set temperature in degrees celsius or Fahrenheit\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+        Integer[] retList;\r\n+        Integer newVal = new Integer(value);\r\n+        Integer outVal = new Integer(value);\r\n+        // Get Celsius or Fahrenheit from status message\r\n+        Integer CorF = getIntStatusVal(\"TemUn\");\r\n+        // TODO put a param in openhab to allow setting this from the config\r\n+\r\n+        // If commanding Fahrenheit set halfStep to 1 or 0 to tell the A/C which F integer\r\n+        // temperature to use as celsius alone is ambigious\r\n+        Integer halfStep = new Integer(0); // default to C\r\n+\r\n+        retList = validateTemperatureRangeForTempSet(newVal, CorF);\r\n+        newVal = retList[0];\r\n+        CorF = retList[1];\r\n+\r\n+        if (CorF == 1) { // If Fahrenheit,\r\n+            // value argument is degrees F, convert Fahrenheit to Celsius,\r\n+            // SetTem input to A/C always in Celsius despite passing in 1 to TemUn\r\n+            outVal = new Integer((int) Math.round((newVal - 32.) * 5.0 / 9.0)); // Integer Truncated\r\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\r\n+            // F = [68. , 69. , 70. , 71. , 72. , 73. , 74. , 75. , 76. , 77. , 78. , 79. , 80. , 81. , 82. , 83. ,\r\n+            // 84. , 85. , 86. ]\r\n+            // C = [20.0, 20.5, 21.1, 21.6, 22.2, 22.7, 23.3, 23.8, 24.4, 25.0, 25.5, 26.1, 26.6, 27.2, 27.7, 28.3,\r\n+            // 28.8, 29.4, 30.0]\r\n+            // TemSet = [20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 30, 30]\r\n+            // TemRec = [ 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]\r\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\r\n+            // subtract the float verison - the int version to get the fractional difference\r\n+            // if the difference is positive set halfStep to 1, negative to 0\r\n+            halfStep = ((((newVal - 32.) * 5.0 / 9.0) - outVal) > 0) ? 1 : 0;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"TemUn\", CorF);\r\n+        parameters.put(\"SetTem\", outVal);\r\n+        parameters.put(\"TemRec\", halfStep);\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceAir(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Air\", value);\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceDry(DatagramSocket clientSocket, Integer value) throws GreeException {\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 402}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MDc3Ng==", "bodyText": "See above", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432880776", "createdAt": "2020-05-30T19:29:37Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,690 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal.discovery;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.StringReader;\r\n+import java.net.DatagramPacket;\r\n+import java.net.DatagramSocket;\r\n+import java.net.InetAddress;\r\n+import java.nio.charset.Charset;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Objects;\r\n+import java.util.Optional;\r\n+\r\n+import org.apache.commons.lang.Validate;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\r\n+import org.openhab.binding.gree.internal.GreeException;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.stream.JsonReader;\r\n+\r\n+/**\r\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\r\n+ * device specific attributes as well a the functionality for the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+// @NonNullByDefault\r\n+public class GreeAirDevice {\r\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\r\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\r\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\r\n+    private boolean isBound = false;\r\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\r\n+    private int port = 0;\r\n+    private String encKey = \"\";\r\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\r\n+    private GreeBindResponse4GsonDTO bindResponseGson;\r\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\r\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\r\n+\r\n+    public Boolean getIsBound() {\r\n+        return isBound;\r\n+    }\r\n+\r\n+    public void setIsBound(boolean isBound) {\r\n+        this.isBound = isBound;\r\n+    }\r\n+\r\n+    public InetAddress getAddress() {\r\n+        return ipAddress;\r\n+    }\r\n+\r\n+    public void setAddress(InetAddress address) {\r\n+        this.ipAddress = address;\r\n+    }\r\n+\r\n+    public int getPort() {\r\n+        return port;\r\n+    }\r\n+\r\n+    public void setPort(int port) {\r\n+        this.port = port;\r\n+    }\r\n+\r\n+    public String getKey() {\r\n+        return encKey;\r\n+    }\r\n+\r\n+    public String getId() {\r\n+        return mScanResponseGson.packJson.mac;\r\n+    }\r\n+\r\n+    public String getName() {\r\n+        return mScanResponseGson.packJson.name;\r\n+    }\r\n+\r\n+    public String getVendor() {\r\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\r\n+    }\r\n+\r\n+    public String getModel() {\r\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\r\n+    }\r\n+\r\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\r\n+        return mScanResponseGson;\r\n+    }\r\n+\r\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\r\n+        mScanResponseGson = gson;\r\n+    }\r\n+\r\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\r\n+        return bindResponseGson;\r\n+    }\r\n+\r\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\r\n+        return statusResponseGson;\r\n+    }\r\n+\r\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\r\n+        Validate.isTrue(socket.isPresent());\r\n+        byte[] sendData = new byte[1024];\r\n+        byte[] receiveData = new byte[347];\r\n+        Gson gson = new Gson();\r\n+\r\n+        try {\r\n+            // Prep the Binding Request pack\r\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\r\n+            bindReqPackGson.mac = getId();\r\n+            bindReqPackGson.t = \"bind\";\r\n+            bindReqPackGson.uid = 0;\r\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\r\n+\r\n+            // Now Encrypt the Binding Request pack\r\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindReqPackStr);\r\n+\r\n+            // Prep the Binding Request\r\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\r\n+            bindReqGson.cid = \"app\";\r\n+            bindReqGson.i = 1;\r\n+            bindReqGson.t = \"pack\";\r\n+            bindReqGson.uid = 0;\r\n+            bindReqGson.tcid = getId();\r\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\r\n+            String bindReqStr = gson.toJson(bindReqGson);\r\n+            sendData = bindReqStr.getBytes();\r\n+\r\n+            // Now Send the request\r\n+            DatagramSocket clientSocket = socket.get();\r\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\r\n+            clientSocket.send(sendPacket);\r\n+\r\n+            // Recieve a response\r\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\r\n+            clientSocket.receive(receivePacket);\r\n+            String modifiedSentence = new String(receivePacket.getData());\r\n+\r\n+            // Read the response\r\n+            StringReader stringReader = new StringReader(modifiedSentence);\r\n+            bindResponseGson = gson.fromJson(new JsonReader(stringReader), GreeBindResponse4GsonDTO.class);\r\n+            bindResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindResponseGson.pack);\r\n+\r\n+            // Create the JSON to hold the response values\r\n+            stringReader = new StringReader(bindResponseGson.decryptedPack);\r\n+            bindResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePack4GsonDTO.class);\r\n+\r\n+            // Now set the key and flag to indicate the bind was succesful\r\n+            encKey = bindResponseGson.packJson.key;\r\n+            setIsBound(true);\r\n+        } catch (IOException e) {\r\n+            throw new GreeException(e, \"failed\");\r\n+        }\r\n+    }\r\n+\r\n+    public void setDevicePower(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Pow\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void SetDeviceMode(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 4)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Mod\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceSwingVertical(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 11)\r\n+                || (value.intValue() > 6 && value.intValue() < 10)) {\r\n+            return;\r\n+        }\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"SwUpDn\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Only allow this to happen if this device has been bound and values are valid\r\n+     * Possible values are :\r\n+     * 0 : Auto\r\n+     * 1 : Low\r\n+     * 2 : Medium Low\r\n+     * 3 : Medium\r\n+     * 4 : Medium High\r\n+     * 5 : High\r\n+     */\r\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 5)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"WdSpd\", value);\r\n+        parameters.put(\"Quiet\", 0);\r\n+        parameters.put(\"Tur\", 0);\r\n+        parameters.put(\"NoiseSet\", 0);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceTurbo(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Tur\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public int getDeviceTurbo() {\r\n+        return getIntStatusVal(\"Tur\");\r\n+    }\r\n+\r\n+    public void setDeviceLight(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Lig\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create Hash Look Up for C and F\r\n+     * Temperature Ranges for gree A/C units (f_range = {86,61}, c_range={16,30}\r\n+     */\r\n+    private static HashMap<String, HashMap<String, Integer>> createTempRangeMap() {\r\n+        HashMap<String, HashMap<String, Integer>> tempRanges = new HashMap<>();\r\n+        HashMap<String, Integer> hmf = new HashMap<>();\r\n+        HashMap<String, Integer> hmc = new HashMap<>();\r\n+\r\n+        hmf.put(\"min\", new Integer(61)); // F\r\n+        hmf.put(\"max\", new Integer(86));\r\n+        tempRanges.put(\"F\", hmf);\r\n+\r\n+        hmc.put(\"min\", new Integer(16)); // C\r\n+        hmc.put(\"max\", new Integer(30));\r\n+        tempRanges.put(\"C\", hmc);\r\n+\r\n+        return tempRanges;\r\n+    }\r\n+\r\n+    /**\r\n+     * Checks input ranges for validity and TempUn for validity\r\n+     * Uses newVal as priority and tries to validate and determine intent\r\n+     * For example if value is 75 and TempUn says Celsius, change TempUn to Fahrenheit\r\n+     */\r\n+    private Integer[] validateTemperatureRangeForTempSet(Integer newValIn, @Nullable Integer CorFIn) {\r\n+        final String[] minMaxLUT = { \"max\", \"min\" }; // looks up 0 = C = max, 1 = F = min\r\n+        final String[] tempScaleLUT = { \"C\", \"F\" }; // Look Up Table used to convert TempUn integer 0,1 to \"C\" to \"F\"\r\n+                                                    // string for hashmap\r\n+        HashMap<String, Integer> nullCorFLUT = new HashMap<>(); // simple look up table for logic\r\n+        nullCorFLUT.put(\"C\", new Integer(0));\r\n+        nullCorFLUT.put(\"F\", new Integer(1));\r\n+        nullCorFLUT.put(\"INVALID\", new Integer(0));\r\n+\r\n+        String validRangeCorF; // stores if the input range is a valid C or F temperature\r\n+\r\n+        // force to global min/max\r\n+        Integer newVal = Math.max(newValIn, Math.min(tempRanges.get(\"C\").get(\"min\"), tempRanges.get(\"F\").get(\"min\")));\r\n+        newVal = Math.min(newVal, Math.max(tempRanges.get(\"C\").get(\"max\"), tempRanges.get(\"F\").get(\"max\")));\r\n+\r\n+        if ((newVal >= tempRanges.get(\"C\").get(\"min\")) && (newVal <= tempRanges.get(\"C\").get(\"max\"))) {\r\n+            validRangeCorF = \"C\";\r\n+        } else if ((newVal >= tempRanges.get(\"F\").get(\"min\")) && (newVal <= tempRanges.get(\"F\").get(\"max\"))) {\r\n+            validRangeCorF = \"F\";\r\n+        } else {\r\n+            logger.warn(\"Input Temp request {} is invalid\", newVal);\r\n+            validRangeCorF = \"INVALID\";\r\n+        }\r\n+\r\n+        // if CorF wasnt initialized or is null set it from lookup\r\n+        Integer CorF = CorFIn != null ? CorFIn : nullCorFLUT.get(validRangeCorF);\r\n+\r\n+        if ((CorF == 1) && (validRangeCorF == \"C\")) {\r\n+            CorF = 0; // input temp takes priority\r\n+        } else if ((CorF == 0) && (validRangeCorF == \"F\")) {\r\n+            CorF = 1; // input temp takes priority\r\n+        } else if (validRangeCorF == \"INVALID\") {\r\n+            // force min or max temp based on CorF scale to be used\r\n+            newVal = tempRanges.get(tempScaleLUT[CorF]).get(minMaxLUT[CorF]);\r\n+        }\r\n+\r\n+        return new Integer[] { newVal, CorF };\r\n+    }\r\n+\r\n+    public void setDeviceTempSet(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // **value** : set temperature in degrees celsius or Fahrenheit\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+        Integer[] retList;\r\n+        Integer newVal = new Integer(value);\r\n+        Integer outVal = new Integer(value);\r\n+        // Get Celsius or Fahrenheit from status message\r\n+        Integer CorF = getIntStatusVal(\"TemUn\");\r\n+        // TODO put a param in openhab to allow setting this from the config\r\n+\r\n+        // If commanding Fahrenheit set halfStep to 1 or 0 to tell the A/C which F integer\r\n+        // temperature to use as celsius alone is ambigious\r\n+        Integer halfStep = new Integer(0); // default to C\r\n+\r\n+        retList = validateTemperatureRangeForTempSet(newVal, CorF);\r\n+        newVal = retList[0];\r\n+        CorF = retList[1];\r\n+\r\n+        if (CorF == 1) { // If Fahrenheit,\r\n+            // value argument is degrees F, convert Fahrenheit to Celsius,\r\n+            // SetTem input to A/C always in Celsius despite passing in 1 to TemUn\r\n+            outVal = new Integer((int) Math.round((newVal - 32.) * 5.0 / 9.0)); // Integer Truncated\r\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\r\n+            // F = [68. , 69. , 70. , 71. , 72. , 73. , 74. , 75. , 76. , 77. , 78. , 79. , 80. , 81. , 82. , 83. ,\r\n+            // 84. , 85. , 86. ]\r\n+            // C = [20.0, 20.5, 21.1, 21.6, 22.2, 22.7, 23.3, 23.8, 24.4, 25.0, 25.5, 26.1, 26.6, 27.2, 27.7, 28.3,\r\n+            // 28.8, 29.4, 30.0]\r\n+            // TemSet = [20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 30, 30]\r\n+            // TemRec = [ 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]\r\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\r\n+            // subtract the float verison - the int version to get the fractional difference\r\n+            // if the difference is positive set halfStep to 1, negative to 0\r\n+            halfStep = ((((newVal - 32.) * 5.0 / 9.0) - outVal) > 0) ? 1 : 0;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"TemUn\", CorF);\r\n+        parameters.put(\"SetTem\", outVal);\r\n+        parameters.put(\"TemRec\", halfStep);\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceAir(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Air\", value);\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceDry(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 404}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MDc4Ng==", "bodyText": "Primitive types", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432880786", "createdAt": "2020-05-30T19:29:47Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,690 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal.discovery;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.StringReader;\r\n+import java.net.DatagramPacket;\r\n+import java.net.DatagramSocket;\r\n+import java.net.InetAddress;\r\n+import java.nio.charset.Charset;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Objects;\r\n+import java.util.Optional;\r\n+\r\n+import org.apache.commons.lang.Validate;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\r\n+import org.openhab.binding.gree.internal.GreeException;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.stream.JsonReader;\r\n+\r\n+/**\r\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\r\n+ * device specific attributes as well a the functionality for the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+// @NonNullByDefault\r\n+public class GreeAirDevice {\r\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\r\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\r\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\r\n+    private boolean isBound = false;\r\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\r\n+    private int port = 0;\r\n+    private String encKey = \"\";\r\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\r\n+    private GreeBindResponse4GsonDTO bindResponseGson;\r\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\r\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\r\n+\r\n+    public Boolean getIsBound() {\r\n+        return isBound;\r\n+    }\r\n+\r\n+    public void setIsBound(boolean isBound) {\r\n+        this.isBound = isBound;\r\n+    }\r\n+\r\n+    public InetAddress getAddress() {\r\n+        return ipAddress;\r\n+    }\r\n+\r\n+    public void setAddress(InetAddress address) {\r\n+        this.ipAddress = address;\r\n+    }\r\n+\r\n+    public int getPort() {\r\n+        return port;\r\n+    }\r\n+\r\n+    public void setPort(int port) {\r\n+        this.port = port;\r\n+    }\r\n+\r\n+    public String getKey() {\r\n+        return encKey;\r\n+    }\r\n+\r\n+    public String getId() {\r\n+        return mScanResponseGson.packJson.mac;\r\n+    }\r\n+\r\n+    public String getName() {\r\n+        return mScanResponseGson.packJson.name;\r\n+    }\r\n+\r\n+    public String getVendor() {\r\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\r\n+    }\r\n+\r\n+    public String getModel() {\r\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\r\n+    }\r\n+\r\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\r\n+        return mScanResponseGson;\r\n+    }\r\n+\r\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\r\n+        mScanResponseGson = gson;\r\n+    }\r\n+\r\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\r\n+        return bindResponseGson;\r\n+    }\r\n+\r\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\r\n+        return statusResponseGson;\r\n+    }\r\n+\r\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\r\n+        Validate.isTrue(socket.isPresent());\r\n+        byte[] sendData = new byte[1024];\r\n+        byte[] receiveData = new byte[347];\r\n+        Gson gson = new Gson();\r\n+\r\n+        try {\r\n+            // Prep the Binding Request pack\r\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\r\n+            bindReqPackGson.mac = getId();\r\n+            bindReqPackGson.t = \"bind\";\r\n+            bindReqPackGson.uid = 0;\r\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\r\n+\r\n+            // Now Encrypt the Binding Request pack\r\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindReqPackStr);\r\n+\r\n+            // Prep the Binding Request\r\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\r\n+            bindReqGson.cid = \"app\";\r\n+            bindReqGson.i = 1;\r\n+            bindReqGson.t = \"pack\";\r\n+            bindReqGson.uid = 0;\r\n+            bindReqGson.tcid = getId();\r\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\r\n+            String bindReqStr = gson.toJson(bindReqGson);\r\n+            sendData = bindReqStr.getBytes();\r\n+\r\n+            // Now Send the request\r\n+            DatagramSocket clientSocket = socket.get();\r\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\r\n+            clientSocket.send(sendPacket);\r\n+\r\n+            // Recieve a response\r\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\r\n+            clientSocket.receive(receivePacket);\r\n+            String modifiedSentence = new String(receivePacket.getData());\r\n+\r\n+            // Read the response\r\n+            StringReader stringReader = new StringReader(modifiedSentence);\r\n+            bindResponseGson = gson.fromJson(new JsonReader(stringReader), GreeBindResponse4GsonDTO.class);\r\n+            bindResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindResponseGson.pack);\r\n+\r\n+            // Create the JSON to hold the response values\r\n+            stringReader = new StringReader(bindResponseGson.decryptedPack);\r\n+            bindResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePack4GsonDTO.class);\r\n+\r\n+            // Now set the key and flag to indicate the bind was succesful\r\n+            encKey = bindResponseGson.packJson.key;\r\n+            setIsBound(true);\r\n+        } catch (IOException e) {\r\n+            throw new GreeException(e, \"failed\");\r\n+        }\r\n+    }\r\n+\r\n+    public void setDevicePower(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Pow\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void SetDeviceMode(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 4)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Mod\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceSwingVertical(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 11)\r\n+                || (value.intValue() > 6 && value.intValue() < 10)) {\r\n+            return;\r\n+        }\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"SwUpDn\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Only allow this to happen if this device has been bound and values are valid\r\n+     * Possible values are :\r\n+     * 0 : Auto\r\n+     * 1 : Low\r\n+     * 2 : Medium Low\r\n+     * 3 : Medium\r\n+     * 4 : Medium High\r\n+     * 5 : High\r\n+     */\r\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 5)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"WdSpd\", value);\r\n+        parameters.put(\"Quiet\", 0);\r\n+        parameters.put(\"Tur\", 0);\r\n+        parameters.put(\"NoiseSet\", 0);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceTurbo(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Tur\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public int getDeviceTurbo() {\r\n+        return getIntStatusVal(\"Tur\");\r\n+    }\r\n+\r\n+    public void setDeviceLight(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Lig\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create Hash Look Up for C and F\r\n+     * Temperature Ranges for gree A/C units (f_range = {86,61}, c_range={16,30}\r\n+     */\r\n+    private static HashMap<String, HashMap<String, Integer>> createTempRangeMap() {\r\n+        HashMap<String, HashMap<String, Integer>> tempRanges = new HashMap<>();\r\n+        HashMap<String, Integer> hmf = new HashMap<>();\r\n+        HashMap<String, Integer> hmc = new HashMap<>();\r\n+\r\n+        hmf.put(\"min\", new Integer(61)); // F\r\n+        hmf.put(\"max\", new Integer(86));\r\n+        tempRanges.put(\"F\", hmf);\r\n+\r\n+        hmc.put(\"min\", new Integer(16)); // C\r\n+        hmc.put(\"max\", new Integer(30));\r\n+        tempRanges.put(\"C\", hmc);\r\n+\r\n+        return tempRanges;\r\n+    }\r\n+\r\n+    /**\r\n+     * Checks input ranges for validity and TempUn for validity\r\n+     * Uses newVal as priority and tries to validate and determine intent\r\n+     * For example if value is 75 and TempUn says Celsius, change TempUn to Fahrenheit\r\n+     */\r\n+    private Integer[] validateTemperatureRangeForTempSet(Integer newValIn, @Nullable Integer CorFIn) {\r\n+        final String[] minMaxLUT = { \"max\", \"min\" }; // looks up 0 = C = max, 1 = F = min\r\n+        final String[] tempScaleLUT = { \"C\", \"F\" }; // Look Up Table used to convert TempUn integer 0,1 to \"C\" to \"F\"\r\n+                                                    // string for hashmap\r\n+        HashMap<String, Integer> nullCorFLUT = new HashMap<>(); // simple look up table for logic\r\n+        nullCorFLUT.put(\"C\", new Integer(0));\r\n+        nullCorFLUT.put(\"F\", new Integer(1));\r\n+        nullCorFLUT.put(\"INVALID\", new Integer(0));\r\n+\r\n+        String validRangeCorF; // stores if the input range is a valid C or F temperature\r\n+\r\n+        // force to global min/max\r\n+        Integer newVal = Math.max(newValIn, Math.min(tempRanges.get(\"C\").get(\"min\"), tempRanges.get(\"F\").get(\"min\")));\r\n+        newVal = Math.min(newVal, Math.max(tempRanges.get(\"C\").get(\"max\"), tempRanges.get(\"F\").get(\"max\")));\r\n+\r\n+        if ((newVal >= tempRanges.get(\"C\").get(\"min\")) && (newVal <= tempRanges.get(\"C\").get(\"max\"))) {\r\n+            validRangeCorF = \"C\";\r\n+        } else if ((newVal >= tempRanges.get(\"F\").get(\"min\")) && (newVal <= tempRanges.get(\"F\").get(\"max\"))) {\r\n+            validRangeCorF = \"F\";\r\n+        } else {\r\n+            logger.warn(\"Input Temp request {} is invalid\", newVal);\r\n+            validRangeCorF = \"INVALID\";\r\n+        }\r\n+\r\n+        // if CorF wasnt initialized or is null set it from lookup\r\n+        Integer CorF = CorFIn != null ? CorFIn : nullCorFLUT.get(validRangeCorF);\r\n+\r\n+        if ((CorF == 1) && (validRangeCorF == \"C\")) {\r\n+            CorF = 0; // input temp takes priority\r\n+        } else if ((CorF == 0) && (validRangeCorF == \"F\")) {\r\n+            CorF = 1; // input temp takes priority\r\n+        } else if (validRangeCorF == \"INVALID\") {\r\n+            // force min or max temp based on CorF scale to be used\r\n+            newVal = tempRanges.get(tempScaleLUT[CorF]).get(minMaxLUT[CorF]);\r\n+        }\r\n+\r\n+        return new Integer[] { newVal, CorF };\r\n+    }\r\n+\r\n+    public void setDeviceTempSet(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // **value** : set temperature in degrees celsius or Fahrenheit\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+        Integer[] retList;\r\n+        Integer newVal = new Integer(value);\r\n+        Integer outVal = new Integer(value);\r\n+        // Get Celsius or Fahrenheit from status message\r\n+        Integer CorF = getIntStatusVal(\"TemUn\");\r\n+        // TODO put a param in openhab to allow setting this from the config\r\n+\r\n+        // If commanding Fahrenheit set halfStep to 1 or 0 to tell the A/C which F integer\r\n+        // temperature to use as celsius alone is ambigious\r\n+        Integer halfStep = new Integer(0); // default to C\r\n+\r\n+        retList = validateTemperatureRangeForTempSet(newVal, CorF);\r\n+        newVal = retList[0];\r\n+        CorF = retList[1];\r\n+\r\n+        if (CorF == 1) { // If Fahrenheit,\r\n+            // value argument is degrees F, convert Fahrenheit to Celsius,\r\n+            // SetTem input to A/C always in Celsius despite passing in 1 to TemUn\r\n+            outVal = new Integer((int) Math.round((newVal - 32.) * 5.0 / 9.0)); // Integer Truncated\r\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\r\n+            // F = [68. , 69. , 70. , 71. , 72. , 73. , 74. , 75. , 76. , 77. , 78. , 79. , 80. , 81. , 82. , 83. ,\r\n+            // 84. , 85. , 86. ]\r\n+            // C = [20.0, 20.5, 21.1, 21.6, 22.2, 22.7, 23.3, 23.8, 24.4, 25.0, 25.5, 26.1, 26.6, 27.2, 27.7, 28.3,\r\n+            // 28.8, 29.4, 30.0]\r\n+            // TemSet = [20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 30, 30]\r\n+            // TemRec = [ 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]\r\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\r\n+            // subtract the float verison - the int version to get the fractional difference\r\n+            // if the difference is positive set halfStep to 1, negative to 0\r\n+            halfStep = ((((newVal - 32.) * 5.0 / 9.0) - outVal) > 0) ? 1 : 0;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"TemUn\", CorF);\r\n+        parameters.put(\"SetTem\", outVal);\r\n+        parameters.put(\"TemRec\", halfStep);\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceAir(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Air\", value);\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceDry(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Blo\", value);\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceHealth(DatagramSocket clientSocket, Integer value) throws GreeException {\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 415}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MDc5MQ==", "bodyText": "See above", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432880791", "createdAt": "2020-05-30T19:29:52Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,690 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal.discovery;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.StringReader;\r\n+import java.net.DatagramPacket;\r\n+import java.net.DatagramSocket;\r\n+import java.net.InetAddress;\r\n+import java.nio.charset.Charset;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Objects;\r\n+import java.util.Optional;\r\n+\r\n+import org.apache.commons.lang.Validate;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\r\n+import org.openhab.binding.gree.internal.GreeException;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.stream.JsonReader;\r\n+\r\n+/**\r\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\r\n+ * device specific attributes as well a the functionality for the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+// @NonNullByDefault\r\n+public class GreeAirDevice {\r\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\r\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\r\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\r\n+    private boolean isBound = false;\r\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\r\n+    private int port = 0;\r\n+    private String encKey = \"\";\r\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\r\n+    private GreeBindResponse4GsonDTO bindResponseGson;\r\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\r\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\r\n+\r\n+    public Boolean getIsBound() {\r\n+        return isBound;\r\n+    }\r\n+\r\n+    public void setIsBound(boolean isBound) {\r\n+        this.isBound = isBound;\r\n+    }\r\n+\r\n+    public InetAddress getAddress() {\r\n+        return ipAddress;\r\n+    }\r\n+\r\n+    public void setAddress(InetAddress address) {\r\n+        this.ipAddress = address;\r\n+    }\r\n+\r\n+    public int getPort() {\r\n+        return port;\r\n+    }\r\n+\r\n+    public void setPort(int port) {\r\n+        this.port = port;\r\n+    }\r\n+\r\n+    public String getKey() {\r\n+        return encKey;\r\n+    }\r\n+\r\n+    public String getId() {\r\n+        return mScanResponseGson.packJson.mac;\r\n+    }\r\n+\r\n+    public String getName() {\r\n+        return mScanResponseGson.packJson.name;\r\n+    }\r\n+\r\n+    public String getVendor() {\r\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\r\n+    }\r\n+\r\n+    public String getModel() {\r\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\r\n+    }\r\n+\r\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\r\n+        return mScanResponseGson;\r\n+    }\r\n+\r\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\r\n+        mScanResponseGson = gson;\r\n+    }\r\n+\r\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\r\n+        return bindResponseGson;\r\n+    }\r\n+\r\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\r\n+        return statusResponseGson;\r\n+    }\r\n+\r\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\r\n+        Validate.isTrue(socket.isPresent());\r\n+        byte[] sendData = new byte[1024];\r\n+        byte[] receiveData = new byte[347];\r\n+        Gson gson = new Gson();\r\n+\r\n+        try {\r\n+            // Prep the Binding Request pack\r\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\r\n+            bindReqPackGson.mac = getId();\r\n+            bindReqPackGson.t = \"bind\";\r\n+            bindReqPackGson.uid = 0;\r\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\r\n+\r\n+            // Now Encrypt the Binding Request pack\r\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindReqPackStr);\r\n+\r\n+            // Prep the Binding Request\r\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\r\n+            bindReqGson.cid = \"app\";\r\n+            bindReqGson.i = 1;\r\n+            bindReqGson.t = \"pack\";\r\n+            bindReqGson.uid = 0;\r\n+            bindReqGson.tcid = getId();\r\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\r\n+            String bindReqStr = gson.toJson(bindReqGson);\r\n+            sendData = bindReqStr.getBytes();\r\n+\r\n+            // Now Send the request\r\n+            DatagramSocket clientSocket = socket.get();\r\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\r\n+            clientSocket.send(sendPacket);\r\n+\r\n+            // Recieve a response\r\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\r\n+            clientSocket.receive(receivePacket);\r\n+            String modifiedSentence = new String(receivePacket.getData());\r\n+\r\n+            // Read the response\r\n+            StringReader stringReader = new StringReader(modifiedSentence);\r\n+            bindResponseGson = gson.fromJson(new JsonReader(stringReader), GreeBindResponse4GsonDTO.class);\r\n+            bindResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindResponseGson.pack);\r\n+\r\n+            // Create the JSON to hold the response values\r\n+            stringReader = new StringReader(bindResponseGson.decryptedPack);\r\n+            bindResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePack4GsonDTO.class);\r\n+\r\n+            // Now set the key and flag to indicate the bind was succesful\r\n+            encKey = bindResponseGson.packJson.key;\r\n+            setIsBound(true);\r\n+        } catch (IOException e) {\r\n+            throw new GreeException(e, \"failed\");\r\n+        }\r\n+    }\r\n+\r\n+    public void setDevicePower(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Pow\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void SetDeviceMode(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 4)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Mod\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceSwingVertical(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 11)\r\n+                || (value.intValue() > 6 && value.intValue() < 10)) {\r\n+            return;\r\n+        }\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"SwUpDn\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Only allow this to happen if this device has been bound and values are valid\r\n+     * Possible values are :\r\n+     * 0 : Auto\r\n+     * 1 : Low\r\n+     * 2 : Medium Low\r\n+     * 3 : Medium\r\n+     * 4 : Medium High\r\n+     * 5 : High\r\n+     */\r\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 5)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"WdSpd\", value);\r\n+        parameters.put(\"Quiet\", 0);\r\n+        parameters.put(\"Tur\", 0);\r\n+        parameters.put(\"NoiseSet\", 0);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceTurbo(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Tur\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public int getDeviceTurbo() {\r\n+        return getIntStatusVal(\"Tur\");\r\n+    }\r\n+\r\n+    public void setDeviceLight(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Lig\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create Hash Look Up for C and F\r\n+     * Temperature Ranges for gree A/C units (f_range = {86,61}, c_range={16,30}\r\n+     */\r\n+    private static HashMap<String, HashMap<String, Integer>> createTempRangeMap() {\r\n+        HashMap<String, HashMap<String, Integer>> tempRanges = new HashMap<>();\r\n+        HashMap<String, Integer> hmf = new HashMap<>();\r\n+        HashMap<String, Integer> hmc = new HashMap<>();\r\n+\r\n+        hmf.put(\"min\", new Integer(61)); // F\r\n+        hmf.put(\"max\", new Integer(86));\r\n+        tempRanges.put(\"F\", hmf);\r\n+\r\n+        hmc.put(\"min\", new Integer(16)); // C\r\n+        hmc.put(\"max\", new Integer(30));\r\n+        tempRanges.put(\"C\", hmc);\r\n+\r\n+        return tempRanges;\r\n+    }\r\n+\r\n+    /**\r\n+     * Checks input ranges for validity and TempUn for validity\r\n+     * Uses newVal as priority and tries to validate and determine intent\r\n+     * For example if value is 75 and TempUn says Celsius, change TempUn to Fahrenheit\r\n+     */\r\n+    private Integer[] validateTemperatureRangeForTempSet(Integer newValIn, @Nullable Integer CorFIn) {\r\n+        final String[] minMaxLUT = { \"max\", \"min\" }; // looks up 0 = C = max, 1 = F = min\r\n+        final String[] tempScaleLUT = { \"C\", \"F\" }; // Look Up Table used to convert TempUn integer 0,1 to \"C\" to \"F\"\r\n+                                                    // string for hashmap\r\n+        HashMap<String, Integer> nullCorFLUT = new HashMap<>(); // simple look up table for logic\r\n+        nullCorFLUT.put(\"C\", new Integer(0));\r\n+        nullCorFLUT.put(\"F\", new Integer(1));\r\n+        nullCorFLUT.put(\"INVALID\", new Integer(0));\r\n+\r\n+        String validRangeCorF; // stores if the input range is a valid C or F temperature\r\n+\r\n+        // force to global min/max\r\n+        Integer newVal = Math.max(newValIn, Math.min(tempRanges.get(\"C\").get(\"min\"), tempRanges.get(\"F\").get(\"min\")));\r\n+        newVal = Math.min(newVal, Math.max(tempRanges.get(\"C\").get(\"max\"), tempRanges.get(\"F\").get(\"max\")));\r\n+\r\n+        if ((newVal >= tempRanges.get(\"C\").get(\"min\")) && (newVal <= tempRanges.get(\"C\").get(\"max\"))) {\r\n+            validRangeCorF = \"C\";\r\n+        } else if ((newVal >= tempRanges.get(\"F\").get(\"min\")) && (newVal <= tempRanges.get(\"F\").get(\"max\"))) {\r\n+            validRangeCorF = \"F\";\r\n+        } else {\r\n+            logger.warn(\"Input Temp request {} is invalid\", newVal);\r\n+            validRangeCorF = \"INVALID\";\r\n+        }\r\n+\r\n+        // if CorF wasnt initialized or is null set it from lookup\r\n+        Integer CorF = CorFIn != null ? CorFIn : nullCorFLUT.get(validRangeCorF);\r\n+\r\n+        if ((CorF == 1) && (validRangeCorF == \"C\")) {\r\n+            CorF = 0; // input temp takes priority\r\n+        } else if ((CorF == 0) && (validRangeCorF == \"F\")) {\r\n+            CorF = 1; // input temp takes priority\r\n+        } else if (validRangeCorF == \"INVALID\") {\r\n+            // force min or max temp based on CorF scale to be used\r\n+            newVal = tempRanges.get(tempScaleLUT[CorF]).get(minMaxLUT[CorF]);\r\n+        }\r\n+\r\n+        return new Integer[] { newVal, CorF };\r\n+    }\r\n+\r\n+    public void setDeviceTempSet(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // **value** : set temperature in degrees celsius or Fahrenheit\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+        Integer[] retList;\r\n+        Integer newVal = new Integer(value);\r\n+        Integer outVal = new Integer(value);\r\n+        // Get Celsius or Fahrenheit from status message\r\n+        Integer CorF = getIntStatusVal(\"TemUn\");\r\n+        // TODO put a param in openhab to allow setting this from the config\r\n+\r\n+        // If commanding Fahrenheit set halfStep to 1 or 0 to tell the A/C which F integer\r\n+        // temperature to use as celsius alone is ambigious\r\n+        Integer halfStep = new Integer(0); // default to C\r\n+\r\n+        retList = validateTemperatureRangeForTempSet(newVal, CorF);\r\n+        newVal = retList[0];\r\n+        CorF = retList[1];\r\n+\r\n+        if (CorF == 1) { // If Fahrenheit,\r\n+            // value argument is degrees F, convert Fahrenheit to Celsius,\r\n+            // SetTem input to A/C always in Celsius despite passing in 1 to TemUn\r\n+            outVal = new Integer((int) Math.round((newVal - 32.) * 5.0 / 9.0)); // Integer Truncated\r\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\r\n+            // F = [68. , 69. , 70. , 71. , 72. , 73. , 74. , 75. , 76. , 77. , 78. , 79. , 80. , 81. , 82. , 83. ,\r\n+            // 84. , 85. , 86. ]\r\n+            // C = [20.0, 20.5, 21.1, 21.6, 22.2, 22.7, 23.3, 23.8, 24.4, 25.0, 25.5, 26.1, 26.6, 27.2, 27.7, 28.3,\r\n+            // 28.8, 29.4, 30.0]\r\n+            // TemSet = [20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 30, 30]\r\n+            // TemRec = [ 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]\r\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\r\n+            // subtract the float verison - the int version to get the fractional difference\r\n+            // if the difference is positive set halfStep to 1, negative to 0\r\n+            halfStep = ((((newVal - 32.) * 5.0 / 9.0) - outVal) > 0) ? 1 : 0;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"TemUn\", CorF);\r\n+        parameters.put(\"SetTem\", outVal);\r\n+        parameters.put(\"TemRec\", halfStep);\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceAir(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Air\", value);\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceDry(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Blo\", value);\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceHealth(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 417}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MDgxNQ==", "bodyText": "Primitive types", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432880815", "createdAt": "2020-05-30T19:30:05Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,690 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal.discovery;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.StringReader;\r\n+import java.net.DatagramPacket;\r\n+import java.net.DatagramSocket;\r\n+import java.net.InetAddress;\r\n+import java.nio.charset.Charset;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Objects;\r\n+import java.util.Optional;\r\n+\r\n+import org.apache.commons.lang.Validate;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\r\n+import org.openhab.binding.gree.internal.GreeException;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.stream.JsonReader;\r\n+\r\n+/**\r\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\r\n+ * device specific attributes as well a the functionality for the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+// @NonNullByDefault\r\n+public class GreeAirDevice {\r\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\r\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\r\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\r\n+    private boolean isBound = false;\r\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\r\n+    private int port = 0;\r\n+    private String encKey = \"\";\r\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\r\n+    private GreeBindResponse4GsonDTO bindResponseGson;\r\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\r\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\r\n+\r\n+    public Boolean getIsBound() {\r\n+        return isBound;\r\n+    }\r\n+\r\n+    public void setIsBound(boolean isBound) {\r\n+        this.isBound = isBound;\r\n+    }\r\n+\r\n+    public InetAddress getAddress() {\r\n+        return ipAddress;\r\n+    }\r\n+\r\n+    public void setAddress(InetAddress address) {\r\n+        this.ipAddress = address;\r\n+    }\r\n+\r\n+    public int getPort() {\r\n+        return port;\r\n+    }\r\n+\r\n+    public void setPort(int port) {\r\n+        this.port = port;\r\n+    }\r\n+\r\n+    public String getKey() {\r\n+        return encKey;\r\n+    }\r\n+\r\n+    public String getId() {\r\n+        return mScanResponseGson.packJson.mac;\r\n+    }\r\n+\r\n+    public String getName() {\r\n+        return mScanResponseGson.packJson.name;\r\n+    }\r\n+\r\n+    public String getVendor() {\r\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\r\n+    }\r\n+\r\n+    public String getModel() {\r\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\r\n+    }\r\n+\r\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\r\n+        return mScanResponseGson;\r\n+    }\r\n+\r\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\r\n+        mScanResponseGson = gson;\r\n+    }\r\n+\r\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\r\n+        return bindResponseGson;\r\n+    }\r\n+\r\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\r\n+        return statusResponseGson;\r\n+    }\r\n+\r\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\r\n+        Validate.isTrue(socket.isPresent());\r\n+        byte[] sendData = new byte[1024];\r\n+        byte[] receiveData = new byte[347];\r\n+        Gson gson = new Gson();\r\n+\r\n+        try {\r\n+            // Prep the Binding Request pack\r\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\r\n+            bindReqPackGson.mac = getId();\r\n+            bindReqPackGson.t = \"bind\";\r\n+            bindReqPackGson.uid = 0;\r\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\r\n+\r\n+            // Now Encrypt the Binding Request pack\r\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindReqPackStr);\r\n+\r\n+            // Prep the Binding Request\r\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\r\n+            bindReqGson.cid = \"app\";\r\n+            bindReqGson.i = 1;\r\n+            bindReqGson.t = \"pack\";\r\n+            bindReqGson.uid = 0;\r\n+            bindReqGson.tcid = getId();\r\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\r\n+            String bindReqStr = gson.toJson(bindReqGson);\r\n+            sendData = bindReqStr.getBytes();\r\n+\r\n+            // Now Send the request\r\n+            DatagramSocket clientSocket = socket.get();\r\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\r\n+            clientSocket.send(sendPacket);\r\n+\r\n+            // Recieve a response\r\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\r\n+            clientSocket.receive(receivePacket);\r\n+            String modifiedSentence = new String(receivePacket.getData());\r\n+\r\n+            // Read the response\r\n+            StringReader stringReader = new StringReader(modifiedSentence);\r\n+            bindResponseGson = gson.fromJson(new JsonReader(stringReader), GreeBindResponse4GsonDTO.class);\r\n+            bindResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindResponseGson.pack);\r\n+\r\n+            // Create the JSON to hold the response values\r\n+            stringReader = new StringReader(bindResponseGson.decryptedPack);\r\n+            bindResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePack4GsonDTO.class);\r\n+\r\n+            // Now set the key and flag to indicate the bind was succesful\r\n+            encKey = bindResponseGson.packJson.key;\r\n+            setIsBound(true);\r\n+        } catch (IOException e) {\r\n+            throw new GreeException(e, \"failed\");\r\n+        }\r\n+    }\r\n+\r\n+    public void setDevicePower(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Pow\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void SetDeviceMode(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 4)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Mod\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceSwingVertical(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 11)\r\n+                || (value.intValue() > 6 && value.intValue() < 10)) {\r\n+            return;\r\n+        }\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"SwUpDn\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Only allow this to happen if this device has been bound and values are valid\r\n+     * Possible values are :\r\n+     * 0 : Auto\r\n+     * 1 : Low\r\n+     * 2 : Medium Low\r\n+     * 3 : Medium\r\n+     * 4 : Medium High\r\n+     * 5 : High\r\n+     */\r\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 5)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"WdSpd\", value);\r\n+        parameters.put(\"Quiet\", 0);\r\n+        parameters.put(\"Tur\", 0);\r\n+        parameters.put(\"NoiseSet\", 0);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceTurbo(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Tur\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public int getDeviceTurbo() {\r\n+        return getIntStatusVal(\"Tur\");\r\n+    }\r\n+\r\n+    public void setDeviceLight(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Lig\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create Hash Look Up for C and F\r\n+     * Temperature Ranges for gree A/C units (f_range = {86,61}, c_range={16,30}\r\n+     */\r\n+    private static HashMap<String, HashMap<String, Integer>> createTempRangeMap() {\r\n+        HashMap<String, HashMap<String, Integer>> tempRanges = new HashMap<>();\r\n+        HashMap<String, Integer> hmf = new HashMap<>();\r\n+        HashMap<String, Integer> hmc = new HashMap<>();\r\n+\r\n+        hmf.put(\"min\", new Integer(61)); // F\r\n+        hmf.put(\"max\", new Integer(86));\r\n+        tempRanges.put(\"F\", hmf);\r\n+\r\n+        hmc.put(\"min\", new Integer(16)); // C\r\n+        hmc.put(\"max\", new Integer(30));\r\n+        tempRanges.put(\"C\", hmc);\r\n+\r\n+        return tempRanges;\r\n+    }\r\n+\r\n+    /**\r\n+     * Checks input ranges for validity and TempUn for validity\r\n+     * Uses newVal as priority and tries to validate and determine intent\r\n+     * For example if value is 75 and TempUn says Celsius, change TempUn to Fahrenheit\r\n+     */\r\n+    private Integer[] validateTemperatureRangeForTempSet(Integer newValIn, @Nullable Integer CorFIn) {\r\n+        final String[] minMaxLUT = { \"max\", \"min\" }; // looks up 0 = C = max, 1 = F = min\r\n+        final String[] tempScaleLUT = { \"C\", \"F\" }; // Look Up Table used to convert TempUn integer 0,1 to \"C\" to \"F\"\r\n+                                                    // string for hashmap\r\n+        HashMap<String, Integer> nullCorFLUT = new HashMap<>(); // simple look up table for logic\r\n+        nullCorFLUT.put(\"C\", new Integer(0));\r\n+        nullCorFLUT.put(\"F\", new Integer(1));\r\n+        nullCorFLUT.put(\"INVALID\", new Integer(0));\r\n+\r\n+        String validRangeCorF; // stores if the input range is a valid C or F temperature\r\n+\r\n+        // force to global min/max\r\n+        Integer newVal = Math.max(newValIn, Math.min(tempRanges.get(\"C\").get(\"min\"), tempRanges.get(\"F\").get(\"min\")));\r\n+        newVal = Math.min(newVal, Math.max(tempRanges.get(\"C\").get(\"max\"), tempRanges.get(\"F\").get(\"max\")));\r\n+\r\n+        if ((newVal >= tempRanges.get(\"C\").get(\"min\")) && (newVal <= tempRanges.get(\"C\").get(\"max\"))) {\r\n+            validRangeCorF = \"C\";\r\n+        } else if ((newVal >= tempRanges.get(\"F\").get(\"min\")) && (newVal <= tempRanges.get(\"F\").get(\"max\"))) {\r\n+            validRangeCorF = \"F\";\r\n+        } else {\r\n+            logger.warn(\"Input Temp request {} is invalid\", newVal);\r\n+            validRangeCorF = \"INVALID\";\r\n+        }\r\n+\r\n+        // if CorF wasnt initialized or is null set it from lookup\r\n+        Integer CorF = CorFIn != null ? CorFIn : nullCorFLUT.get(validRangeCorF);\r\n+\r\n+        if ((CorF == 1) && (validRangeCorF == \"C\")) {\r\n+            CorF = 0; // input temp takes priority\r\n+        } else if ((CorF == 0) && (validRangeCorF == \"F\")) {\r\n+            CorF = 1; // input temp takes priority\r\n+        } else if (validRangeCorF == \"INVALID\") {\r\n+            // force min or max temp based on CorF scale to be used\r\n+            newVal = tempRanges.get(tempScaleLUT[CorF]).get(minMaxLUT[CorF]);\r\n+        }\r\n+\r\n+        return new Integer[] { newVal, CorF };\r\n+    }\r\n+\r\n+    public void setDeviceTempSet(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // **value** : set temperature in degrees celsius or Fahrenheit\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+        Integer[] retList;\r\n+        Integer newVal = new Integer(value);\r\n+        Integer outVal = new Integer(value);\r\n+        // Get Celsius or Fahrenheit from status message\r\n+        Integer CorF = getIntStatusVal(\"TemUn\");\r\n+        // TODO put a param in openhab to allow setting this from the config\r\n+\r\n+        // If commanding Fahrenheit set halfStep to 1 or 0 to tell the A/C which F integer\r\n+        // temperature to use as celsius alone is ambigious\r\n+        Integer halfStep = new Integer(0); // default to C\r\n+\r\n+        retList = validateTemperatureRangeForTempSet(newVal, CorF);\r\n+        newVal = retList[0];\r\n+        CorF = retList[1];\r\n+\r\n+        if (CorF == 1) { // If Fahrenheit,\r\n+            // value argument is degrees F, convert Fahrenheit to Celsius,\r\n+            // SetTem input to A/C always in Celsius despite passing in 1 to TemUn\r\n+            outVal = new Integer((int) Math.round((newVal - 32.) * 5.0 / 9.0)); // Integer Truncated\r\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\r\n+            // F = [68. , 69. , 70. , 71. , 72. , 73. , 74. , 75. , 76. , 77. , 78. , 79. , 80. , 81. , 82. , 83. ,\r\n+            // 84. , 85. , 86. ]\r\n+            // C = [20.0, 20.5, 21.1, 21.6, 22.2, 22.7, 23.3, 23.8, 24.4, 25.0, 25.5, 26.1, 26.6, 27.2, 27.7, 28.3,\r\n+            // 28.8, 29.4, 30.0]\r\n+            // TemSet = [20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 30, 30]\r\n+            // TemRec = [ 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]\r\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\r\n+            // subtract the float verison - the int version to get the fractional difference\r\n+            // if the difference is positive set halfStep to 1, negative to 0\r\n+            halfStep = ((((newVal - 32.) * 5.0 / 9.0) - outVal) > 0) ? 1 : 0;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"TemUn\", CorF);\r\n+        parameters.put(\"SetTem\", outVal);\r\n+        parameters.put(\"TemRec\", halfStep);\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceAir(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Air\", value);\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceDry(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Blo\", value);\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceHealth(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Health\", value);\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDevicePwrSaving(DatagramSocket clientSocket, Integer value) throws GreeException {\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 428}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MDgyMA==", "bodyText": "See above", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432880820", "createdAt": "2020-05-30T19:30:11Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,690 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal.discovery;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.StringReader;\r\n+import java.net.DatagramPacket;\r\n+import java.net.DatagramSocket;\r\n+import java.net.InetAddress;\r\n+import java.nio.charset.Charset;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Objects;\r\n+import java.util.Optional;\r\n+\r\n+import org.apache.commons.lang.Validate;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\r\n+import org.openhab.binding.gree.internal.GreeException;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.stream.JsonReader;\r\n+\r\n+/**\r\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\r\n+ * device specific attributes as well a the functionality for the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+// @NonNullByDefault\r\n+public class GreeAirDevice {\r\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\r\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\r\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\r\n+    private boolean isBound = false;\r\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\r\n+    private int port = 0;\r\n+    private String encKey = \"\";\r\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\r\n+    private GreeBindResponse4GsonDTO bindResponseGson;\r\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\r\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\r\n+\r\n+    public Boolean getIsBound() {\r\n+        return isBound;\r\n+    }\r\n+\r\n+    public void setIsBound(boolean isBound) {\r\n+        this.isBound = isBound;\r\n+    }\r\n+\r\n+    public InetAddress getAddress() {\r\n+        return ipAddress;\r\n+    }\r\n+\r\n+    public void setAddress(InetAddress address) {\r\n+        this.ipAddress = address;\r\n+    }\r\n+\r\n+    public int getPort() {\r\n+        return port;\r\n+    }\r\n+\r\n+    public void setPort(int port) {\r\n+        this.port = port;\r\n+    }\r\n+\r\n+    public String getKey() {\r\n+        return encKey;\r\n+    }\r\n+\r\n+    public String getId() {\r\n+        return mScanResponseGson.packJson.mac;\r\n+    }\r\n+\r\n+    public String getName() {\r\n+        return mScanResponseGson.packJson.name;\r\n+    }\r\n+\r\n+    public String getVendor() {\r\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\r\n+    }\r\n+\r\n+    public String getModel() {\r\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\r\n+    }\r\n+\r\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\r\n+        return mScanResponseGson;\r\n+    }\r\n+\r\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\r\n+        mScanResponseGson = gson;\r\n+    }\r\n+\r\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\r\n+        return bindResponseGson;\r\n+    }\r\n+\r\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\r\n+        return statusResponseGson;\r\n+    }\r\n+\r\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\r\n+        Validate.isTrue(socket.isPresent());\r\n+        byte[] sendData = new byte[1024];\r\n+        byte[] receiveData = new byte[347];\r\n+        Gson gson = new Gson();\r\n+\r\n+        try {\r\n+            // Prep the Binding Request pack\r\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\r\n+            bindReqPackGson.mac = getId();\r\n+            bindReqPackGson.t = \"bind\";\r\n+            bindReqPackGson.uid = 0;\r\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\r\n+\r\n+            // Now Encrypt the Binding Request pack\r\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindReqPackStr);\r\n+\r\n+            // Prep the Binding Request\r\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\r\n+            bindReqGson.cid = \"app\";\r\n+            bindReqGson.i = 1;\r\n+            bindReqGson.t = \"pack\";\r\n+            bindReqGson.uid = 0;\r\n+            bindReqGson.tcid = getId();\r\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\r\n+            String bindReqStr = gson.toJson(bindReqGson);\r\n+            sendData = bindReqStr.getBytes();\r\n+\r\n+            // Now Send the request\r\n+            DatagramSocket clientSocket = socket.get();\r\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\r\n+            clientSocket.send(sendPacket);\r\n+\r\n+            // Recieve a response\r\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\r\n+            clientSocket.receive(receivePacket);\r\n+            String modifiedSentence = new String(receivePacket.getData());\r\n+\r\n+            // Read the response\r\n+            StringReader stringReader = new StringReader(modifiedSentence);\r\n+            bindResponseGson = gson.fromJson(new JsonReader(stringReader), GreeBindResponse4GsonDTO.class);\r\n+            bindResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindResponseGson.pack);\r\n+\r\n+            // Create the JSON to hold the response values\r\n+            stringReader = new StringReader(bindResponseGson.decryptedPack);\r\n+            bindResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePack4GsonDTO.class);\r\n+\r\n+            // Now set the key and flag to indicate the bind was succesful\r\n+            encKey = bindResponseGson.packJson.key;\r\n+            setIsBound(true);\r\n+        } catch (IOException e) {\r\n+            throw new GreeException(e, \"failed\");\r\n+        }\r\n+    }\r\n+\r\n+    public void setDevicePower(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Pow\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void SetDeviceMode(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 4)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Mod\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceSwingVertical(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 11)\r\n+                || (value.intValue() > 6 && value.intValue() < 10)) {\r\n+            return;\r\n+        }\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"SwUpDn\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Only allow this to happen if this device has been bound and values are valid\r\n+     * Possible values are :\r\n+     * 0 : Auto\r\n+     * 1 : Low\r\n+     * 2 : Medium Low\r\n+     * 3 : Medium\r\n+     * 4 : Medium High\r\n+     * 5 : High\r\n+     */\r\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 5)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"WdSpd\", value);\r\n+        parameters.put(\"Quiet\", 0);\r\n+        parameters.put(\"Tur\", 0);\r\n+        parameters.put(\"NoiseSet\", 0);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceTurbo(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Tur\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public int getDeviceTurbo() {\r\n+        return getIntStatusVal(\"Tur\");\r\n+    }\r\n+\r\n+    public void setDeviceLight(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Lig\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create Hash Look Up for C and F\r\n+     * Temperature Ranges for gree A/C units (f_range = {86,61}, c_range={16,30}\r\n+     */\r\n+    private static HashMap<String, HashMap<String, Integer>> createTempRangeMap() {\r\n+        HashMap<String, HashMap<String, Integer>> tempRanges = new HashMap<>();\r\n+        HashMap<String, Integer> hmf = new HashMap<>();\r\n+        HashMap<String, Integer> hmc = new HashMap<>();\r\n+\r\n+        hmf.put(\"min\", new Integer(61)); // F\r\n+        hmf.put(\"max\", new Integer(86));\r\n+        tempRanges.put(\"F\", hmf);\r\n+\r\n+        hmc.put(\"min\", new Integer(16)); // C\r\n+        hmc.put(\"max\", new Integer(30));\r\n+        tempRanges.put(\"C\", hmc);\r\n+\r\n+        return tempRanges;\r\n+    }\r\n+\r\n+    /**\r\n+     * Checks input ranges for validity and TempUn for validity\r\n+     * Uses newVal as priority and tries to validate and determine intent\r\n+     * For example if value is 75 and TempUn says Celsius, change TempUn to Fahrenheit\r\n+     */\r\n+    private Integer[] validateTemperatureRangeForTempSet(Integer newValIn, @Nullable Integer CorFIn) {\r\n+        final String[] minMaxLUT = { \"max\", \"min\" }; // looks up 0 = C = max, 1 = F = min\r\n+        final String[] tempScaleLUT = { \"C\", \"F\" }; // Look Up Table used to convert TempUn integer 0,1 to \"C\" to \"F\"\r\n+                                                    // string for hashmap\r\n+        HashMap<String, Integer> nullCorFLUT = new HashMap<>(); // simple look up table for logic\r\n+        nullCorFLUT.put(\"C\", new Integer(0));\r\n+        nullCorFLUT.put(\"F\", new Integer(1));\r\n+        nullCorFLUT.put(\"INVALID\", new Integer(0));\r\n+\r\n+        String validRangeCorF; // stores if the input range is a valid C or F temperature\r\n+\r\n+        // force to global min/max\r\n+        Integer newVal = Math.max(newValIn, Math.min(tempRanges.get(\"C\").get(\"min\"), tempRanges.get(\"F\").get(\"min\")));\r\n+        newVal = Math.min(newVal, Math.max(tempRanges.get(\"C\").get(\"max\"), tempRanges.get(\"F\").get(\"max\")));\r\n+\r\n+        if ((newVal >= tempRanges.get(\"C\").get(\"min\")) && (newVal <= tempRanges.get(\"C\").get(\"max\"))) {\r\n+            validRangeCorF = \"C\";\r\n+        } else if ((newVal >= tempRanges.get(\"F\").get(\"min\")) && (newVal <= tempRanges.get(\"F\").get(\"max\"))) {\r\n+            validRangeCorF = \"F\";\r\n+        } else {\r\n+            logger.warn(\"Input Temp request {} is invalid\", newVal);\r\n+            validRangeCorF = \"INVALID\";\r\n+        }\r\n+\r\n+        // if CorF wasnt initialized or is null set it from lookup\r\n+        Integer CorF = CorFIn != null ? CorFIn : nullCorFLUT.get(validRangeCorF);\r\n+\r\n+        if ((CorF == 1) && (validRangeCorF == \"C\")) {\r\n+            CorF = 0; // input temp takes priority\r\n+        } else if ((CorF == 0) && (validRangeCorF == \"F\")) {\r\n+            CorF = 1; // input temp takes priority\r\n+        } else if (validRangeCorF == \"INVALID\") {\r\n+            // force min or max temp based on CorF scale to be used\r\n+            newVal = tempRanges.get(tempScaleLUT[CorF]).get(minMaxLUT[CorF]);\r\n+        }\r\n+\r\n+        return new Integer[] { newVal, CorF };\r\n+    }\r\n+\r\n+    public void setDeviceTempSet(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // **value** : set temperature in degrees celsius or Fahrenheit\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+        Integer[] retList;\r\n+        Integer newVal = new Integer(value);\r\n+        Integer outVal = new Integer(value);\r\n+        // Get Celsius or Fahrenheit from status message\r\n+        Integer CorF = getIntStatusVal(\"TemUn\");\r\n+        // TODO put a param in openhab to allow setting this from the config\r\n+\r\n+        // If commanding Fahrenheit set halfStep to 1 or 0 to tell the A/C which F integer\r\n+        // temperature to use as celsius alone is ambigious\r\n+        Integer halfStep = new Integer(0); // default to C\r\n+\r\n+        retList = validateTemperatureRangeForTempSet(newVal, CorF);\r\n+        newVal = retList[0];\r\n+        CorF = retList[1];\r\n+\r\n+        if (CorF == 1) { // If Fahrenheit,\r\n+            // value argument is degrees F, convert Fahrenheit to Celsius,\r\n+            // SetTem input to A/C always in Celsius despite passing in 1 to TemUn\r\n+            outVal = new Integer((int) Math.round((newVal - 32.) * 5.0 / 9.0)); // Integer Truncated\r\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\r\n+            // F = [68. , 69. , 70. , 71. , 72. , 73. , 74. , 75. , 76. , 77. , 78. , 79. , 80. , 81. , 82. , 83. ,\r\n+            // 84. , 85. , 86. ]\r\n+            // C = [20.0, 20.5, 21.1, 21.6, 22.2, 22.7, 23.3, 23.8, 24.4, 25.0, 25.5, 26.1, 26.6, 27.2, 27.7, 28.3,\r\n+            // 28.8, 29.4, 30.0]\r\n+            // TemSet = [20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 30, 30]\r\n+            // TemRec = [ 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]\r\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\r\n+            // subtract the float verison - the int version to get the fractional difference\r\n+            // if the difference is positive set halfStep to 1, negative to 0\r\n+            halfStep = ((((newVal - 32.) * 5.0 / 9.0) - outVal) > 0) ? 1 : 0;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"TemUn\", CorF);\r\n+        parameters.put(\"SetTem\", outVal);\r\n+        parameters.put(\"TemRec\", halfStep);\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceAir(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Air\", value);\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceDry(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Blo\", value);\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceHealth(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Health\", value);\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDevicePwrSaving(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 430}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MDgzMg==", "bodyText": "Primitive types", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432880832", "createdAt": "2020-05-30T19:30:19Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,690 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal.discovery;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.StringReader;\r\n+import java.net.DatagramPacket;\r\n+import java.net.DatagramSocket;\r\n+import java.net.InetAddress;\r\n+import java.nio.charset.Charset;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Objects;\r\n+import java.util.Optional;\r\n+\r\n+import org.apache.commons.lang.Validate;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\r\n+import org.openhab.binding.gree.internal.GreeException;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.stream.JsonReader;\r\n+\r\n+/**\r\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\r\n+ * device specific attributes as well a the functionality for the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+// @NonNullByDefault\r\n+public class GreeAirDevice {\r\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\r\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\r\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\r\n+    private boolean isBound = false;\r\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\r\n+    private int port = 0;\r\n+    private String encKey = \"\";\r\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\r\n+    private GreeBindResponse4GsonDTO bindResponseGson;\r\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\r\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\r\n+\r\n+    public Boolean getIsBound() {\r\n+        return isBound;\r\n+    }\r\n+\r\n+    public void setIsBound(boolean isBound) {\r\n+        this.isBound = isBound;\r\n+    }\r\n+\r\n+    public InetAddress getAddress() {\r\n+        return ipAddress;\r\n+    }\r\n+\r\n+    public void setAddress(InetAddress address) {\r\n+        this.ipAddress = address;\r\n+    }\r\n+\r\n+    public int getPort() {\r\n+        return port;\r\n+    }\r\n+\r\n+    public void setPort(int port) {\r\n+        this.port = port;\r\n+    }\r\n+\r\n+    public String getKey() {\r\n+        return encKey;\r\n+    }\r\n+\r\n+    public String getId() {\r\n+        return mScanResponseGson.packJson.mac;\r\n+    }\r\n+\r\n+    public String getName() {\r\n+        return mScanResponseGson.packJson.name;\r\n+    }\r\n+\r\n+    public String getVendor() {\r\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\r\n+    }\r\n+\r\n+    public String getModel() {\r\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\r\n+    }\r\n+\r\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\r\n+        return mScanResponseGson;\r\n+    }\r\n+\r\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\r\n+        mScanResponseGson = gson;\r\n+    }\r\n+\r\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\r\n+        return bindResponseGson;\r\n+    }\r\n+\r\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\r\n+        return statusResponseGson;\r\n+    }\r\n+\r\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\r\n+        Validate.isTrue(socket.isPresent());\r\n+        byte[] sendData = new byte[1024];\r\n+        byte[] receiveData = new byte[347];\r\n+        Gson gson = new Gson();\r\n+\r\n+        try {\r\n+            // Prep the Binding Request pack\r\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\r\n+            bindReqPackGson.mac = getId();\r\n+            bindReqPackGson.t = \"bind\";\r\n+            bindReqPackGson.uid = 0;\r\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\r\n+\r\n+            // Now Encrypt the Binding Request pack\r\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindReqPackStr);\r\n+\r\n+            // Prep the Binding Request\r\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\r\n+            bindReqGson.cid = \"app\";\r\n+            bindReqGson.i = 1;\r\n+            bindReqGson.t = \"pack\";\r\n+            bindReqGson.uid = 0;\r\n+            bindReqGson.tcid = getId();\r\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\r\n+            String bindReqStr = gson.toJson(bindReqGson);\r\n+            sendData = bindReqStr.getBytes();\r\n+\r\n+            // Now Send the request\r\n+            DatagramSocket clientSocket = socket.get();\r\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\r\n+            clientSocket.send(sendPacket);\r\n+\r\n+            // Recieve a response\r\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\r\n+            clientSocket.receive(receivePacket);\r\n+            String modifiedSentence = new String(receivePacket.getData());\r\n+\r\n+            // Read the response\r\n+            StringReader stringReader = new StringReader(modifiedSentence);\r\n+            bindResponseGson = gson.fromJson(new JsonReader(stringReader), GreeBindResponse4GsonDTO.class);\r\n+            bindResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindResponseGson.pack);\r\n+\r\n+            // Create the JSON to hold the response values\r\n+            stringReader = new StringReader(bindResponseGson.decryptedPack);\r\n+            bindResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePack4GsonDTO.class);\r\n+\r\n+            // Now set the key and flag to indicate the bind was succesful\r\n+            encKey = bindResponseGson.packJson.key;\r\n+            setIsBound(true);\r\n+        } catch (IOException e) {\r\n+            throw new GreeException(e, \"failed\");\r\n+        }\r\n+    }\r\n+\r\n+    public void setDevicePower(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Pow\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void SetDeviceMode(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 4)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Mod\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceSwingVertical(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 11)\r\n+                || (value.intValue() > 6 && value.intValue() < 10)) {\r\n+            return;\r\n+        }\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"SwUpDn\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Only allow this to happen if this device has been bound and values are valid\r\n+     * Possible values are :\r\n+     * 0 : Auto\r\n+     * 1 : Low\r\n+     * 2 : Medium Low\r\n+     * 3 : Medium\r\n+     * 4 : Medium High\r\n+     * 5 : High\r\n+     */\r\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 5)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"WdSpd\", value);\r\n+        parameters.put(\"Quiet\", 0);\r\n+        parameters.put(\"Tur\", 0);\r\n+        parameters.put(\"NoiseSet\", 0);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceTurbo(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Tur\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public int getDeviceTurbo() {\r\n+        return getIntStatusVal(\"Tur\");\r\n+    }\r\n+\r\n+    public void setDeviceLight(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Lig\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create Hash Look Up for C and F\r\n+     * Temperature Ranges for gree A/C units (f_range = {86,61}, c_range={16,30}\r\n+     */\r\n+    private static HashMap<String, HashMap<String, Integer>> createTempRangeMap() {\r\n+        HashMap<String, HashMap<String, Integer>> tempRanges = new HashMap<>();\r\n+        HashMap<String, Integer> hmf = new HashMap<>();\r\n+        HashMap<String, Integer> hmc = new HashMap<>();\r\n+\r\n+        hmf.put(\"min\", new Integer(61)); // F\r\n+        hmf.put(\"max\", new Integer(86));\r\n+        tempRanges.put(\"F\", hmf);\r\n+\r\n+        hmc.put(\"min\", new Integer(16)); // C\r\n+        hmc.put(\"max\", new Integer(30));\r\n+        tempRanges.put(\"C\", hmc);\r\n+\r\n+        return tempRanges;\r\n+    }\r\n+\r\n+    /**\r\n+     * Checks input ranges for validity and TempUn for validity\r\n+     * Uses newVal as priority and tries to validate and determine intent\r\n+     * For example if value is 75 and TempUn says Celsius, change TempUn to Fahrenheit\r\n+     */\r\n+    private Integer[] validateTemperatureRangeForTempSet(Integer newValIn, @Nullable Integer CorFIn) {\r\n+        final String[] minMaxLUT = { \"max\", \"min\" }; // looks up 0 = C = max, 1 = F = min\r\n+        final String[] tempScaleLUT = { \"C\", \"F\" }; // Look Up Table used to convert TempUn integer 0,1 to \"C\" to \"F\"\r\n+                                                    // string for hashmap\r\n+        HashMap<String, Integer> nullCorFLUT = new HashMap<>(); // simple look up table for logic\r\n+        nullCorFLUT.put(\"C\", new Integer(0));\r\n+        nullCorFLUT.put(\"F\", new Integer(1));\r\n+        nullCorFLUT.put(\"INVALID\", new Integer(0));\r\n+\r\n+        String validRangeCorF; // stores if the input range is a valid C or F temperature\r\n+\r\n+        // force to global min/max\r\n+        Integer newVal = Math.max(newValIn, Math.min(tempRanges.get(\"C\").get(\"min\"), tempRanges.get(\"F\").get(\"min\")));\r\n+        newVal = Math.min(newVal, Math.max(tempRanges.get(\"C\").get(\"max\"), tempRanges.get(\"F\").get(\"max\")));\r\n+\r\n+        if ((newVal >= tempRanges.get(\"C\").get(\"min\")) && (newVal <= tempRanges.get(\"C\").get(\"max\"))) {\r\n+            validRangeCorF = \"C\";\r\n+        } else if ((newVal >= tempRanges.get(\"F\").get(\"min\")) && (newVal <= tempRanges.get(\"F\").get(\"max\"))) {\r\n+            validRangeCorF = \"F\";\r\n+        } else {\r\n+            logger.warn(\"Input Temp request {} is invalid\", newVal);\r\n+            validRangeCorF = \"INVALID\";\r\n+        }\r\n+\r\n+        // if CorF wasnt initialized or is null set it from lookup\r\n+        Integer CorF = CorFIn != null ? CorFIn : nullCorFLUT.get(validRangeCorF);\r\n+\r\n+        if ((CorF == 1) && (validRangeCorF == \"C\")) {\r\n+            CorF = 0; // input temp takes priority\r\n+        } else if ((CorF == 0) && (validRangeCorF == \"F\")) {\r\n+            CorF = 1; // input temp takes priority\r\n+        } else if (validRangeCorF == \"INVALID\") {\r\n+            // force min or max temp based on CorF scale to be used\r\n+            newVal = tempRanges.get(tempScaleLUT[CorF]).get(minMaxLUT[CorF]);\r\n+        }\r\n+\r\n+        return new Integer[] { newVal, CorF };\r\n+    }\r\n+\r\n+    public void setDeviceTempSet(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // **value** : set temperature in degrees celsius or Fahrenheit\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+        Integer[] retList;\r\n+        Integer newVal = new Integer(value);\r\n+        Integer outVal = new Integer(value);\r\n+        // Get Celsius or Fahrenheit from status message\r\n+        Integer CorF = getIntStatusVal(\"TemUn\");\r\n+        // TODO put a param in openhab to allow setting this from the config\r\n+\r\n+        // If commanding Fahrenheit set halfStep to 1 or 0 to tell the A/C which F integer\r\n+        // temperature to use as celsius alone is ambigious\r\n+        Integer halfStep = new Integer(0); // default to C\r\n+\r\n+        retList = validateTemperatureRangeForTempSet(newVal, CorF);\r\n+        newVal = retList[0];\r\n+        CorF = retList[1];\r\n+\r\n+        if (CorF == 1) { // If Fahrenheit,\r\n+            // value argument is degrees F, convert Fahrenheit to Celsius,\r\n+            // SetTem input to A/C always in Celsius despite passing in 1 to TemUn\r\n+            outVal = new Integer((int) Math.round((newVal - 32.) * 5.0 / 9.0)); // Integer Truncated\r\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\r\n+            // F = [68. , 69. , 70. , 71. , 72. , 73. , 74. , 75. , 76. , 77. , 78. , 79. , 80. , 81. , 82. , 83. ,\r\n+            // 84. , 85. , 86. ]\r\n+            // C = [20.0, 20.5, 21.1, 21.6, 22.2, 22.7, 23.3, 23.8, 24.4, 25.0, 25.5, 26.1, 26.6, 27.2, 27.7, 28.3,\r\n+            // 28.8, 29.4, 30.0]\r\n+            // TemSet = [20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 30, 30]\r\n+            // TemRec = [ 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]\r\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\r\n+            // subtract the float verison - the int version to get the fractional difference\r\n+            // if the difference is positive set halfStep to 1, negative to 0\r\n+            halfStep = ((((newVal - 32.) * 5.0 / 9.0) - outVal) > 0) ? 1 : 0;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"TemUn\", CorF);\r\n+        parameters.put(\"SetTem\", outVal);\r\n+        parameters.put(\"TemRec\", halfStep);\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceAir(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Air\", value);\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceDry(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Blo\", value);\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceHealth(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Health\", value);\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDevicePwrSaving(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"SvSt\", value);\r\n+        parameters.put(\"WdSpd\", new Integer(0));\r\n+        parameters.put(\"Quiet\", new Integer(0));\r\n+        parameters.put(\"Tur\", new Integer(0));\r\n+        parameters.put(\"SwhSlp\", new Integer(0));\r\n+        parameters.put(\"SlpMod\", new Integer(0));\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 441}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MDk5NA==", "bodyText": "Can these be deleted?", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432880994", "createdAt": "2020-05-30T19:33:06Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,690 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal.discovery;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.StringReader;\r\n+import java.net.DatagramPacket;\r\n+import java.net.DatagramSocket;\r\n+import java.net.InetAddress;\r\n+import java.nio.charset.Charset;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Objects;\r\n+import java.util.Optional;\r\n+\r\n+import org.apache.commons.lang.Validate;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\r\n+import org.openhab.binding.gree.internal.GreeException;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.stream.JsonReader;\r\n+\r\n+/**\r\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\r\n+ * device specific attributes as well a the functionality for the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+// @NonNullByDefault\r\n+public class GreeAirDevice {\r\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\r\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\r\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\r\n+    private boolean isBound = false;\r\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\r\n+    private int port = 0;\r\n+    private String encKey = \"\";\r\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\r\n+    private GreeBindResponse4GsonDTO bindResponseGson;\r\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\r\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\r\n+\r\n+    public Boolean getIsBound() {\r\n+        return isBound;\r\n+    }\r\n+\r\n+    public void setIsBound(boolean isBound) {\r\n+        this.isBound = isBound;\r\n+    }\r\n+\r\n+    public InetAddress getAddress() {\r\n+        return ipAddress;\r\n+    }\r\n+\r\n+    public void setAddress(InetAddress address) {\r\n+        this.ipAddress = address;\r\n+    }\r\n+\r\n+    public int getPort() {\r\n+        return port;\r\n+    }\r\n+\r\n+    public void setPort(int port) {\r\n+        this.port = port;\r\n+    }\r\n+\r\n+    public String getKey() {\r\n+        return encKey;\r\n+    }\r\n+\r\n+    public String getId() {\r\n+        return mScanResponseGson.packJson.mac;\r\n+    }\r\n+\r\n+    public String getName() {\r\n+        return mScanResponseGson.packJson.name;\r\n+    }\r\n+\r\n+    public String getVendor() {\r\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\r\n+    }\r\n+\r\n+    public String getModel() {\r\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\r\n+    }\r\n+\r\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\r\n+        return mScanResponseGson;\r\n+    }\r\n+\r\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\r\n+        mScanResponseGson = gson;\r\n+    }\r\n+\r\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\r\n+        return bindResponseGson;\r\n+    }\r\n+\r\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\r\n+        return statusResponseGson;\r\n+    }\r\n+\r\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\r\n+        Validate.isTrue(socket.isPresent());\r\n+        byte[] sendData = new byte[1024];\r\n+        byte[] receiveData = new byte[347];\r\n+        Gson gson = new Gson();\r\n+\r\n+        try {\r\n+            // Prep the Binding Request pack\r\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\r\n+            bindReqPackGson.mac = getId();\r\n+            bindReqPackGson.t = \"bind\";\r\n+            bindReqPackGson.uid = 0;\r\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\r\n+\r\n+            // Now Encrypt the Binding Request pack\r\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindReqPackStr);\r\n+\r\n+            // Prep the Binding Request\r\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\r\n+            bindReqGson.cid = \"app\";\r\n+            bindReqGson.i = 1;\r\n+            bindReqGson.t = \"pack\";\r\n+            bindReqGson.uid = 0;\r\n+            bindReqGson.tcid = getId();\r\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\r\n+            String bindReqStr = gson.toJson(bindReqGson);\r\n+            sendData = bindReqStr.getBytes();\r\n+\r\n+            // Now Send the request\r\n+            DatagramSocket clientSocket = socket.get();\r\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\r\n+            clientSocket.send(sendPacket);\r\n+\r\n+            // Recieve a response\r\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\r\n+            clientSocket.receive(receivePacket);\r\n+            String modifiedSentence = new String(receivePacket.getData());\r\n+\r\n+            // Read the response\r\n+            StringReader stringReader = new StringReader(modifiedSentence);\r\n+            bindResponseGson = gson.fromJson(new JsonReader(stringReader), GreeBindResponse4GsonDTO.class);\r\n+            bindResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindResponseGson.pack);\r\n+\r\n+            // Create the JSON to hold the response values\r\n+            stringReader = new StringReader(bindResponseGson.decryptedPack);\r\n+            bindResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePack4GsonDTO.class);\r\n+\r\n+            // Now set the key and flag to indicate the bind was succesful\r\n+            encKey = bindResponseGson.packJson.key;\r\n+            setIsBound(true);\r\n+        } catch (IOException e) {\r\n+            throw new GreeException(e, \"failed\");\r\n+        }\r\n+    }\r\n+\r\n+    public void setDevicePower(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Pow\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void SetDeviceMode(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 4)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Mod\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceSwingVertical(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 11)\r\n+                || (value.intValue() > 6 && value.intValue() < 10)) {\r\n+            return;\r\n+        }\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"SwUpDn\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Only allow this to happen if this device has been bound and values are valid\r\n+     * Possible values are :\r\n+     * 0 : Auto\r\n+     * 1 : Low\r\n+     * 2 : Medium Low\r\n+     * 3 : Medium\r\n+     * 4 : Medium High\r\n+     * 5 : High\r\n+     */\r\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 5)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"WdSpd\", value);\r\n+        parameters.put(\"Quiet\", 0);\r\n+        parameters.put(\"Tur\", 0);\r\n+        parameters.put(\"NoiseSet\", 0);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceTurbo(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Tur\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public int getDeviceTurbo() {\r\n+        return getIntStatusVal(\"Tur\");\r\n+    }\r\n+\r\n+    public void setDeviceLight(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Lig\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create Hash Look Up for C and F\r\n+     * Temperature Ranges for gree A/C units (f_range = {86,61}, c_range={16,30}\r\n+     */\r\n+    private static HashMap<String, HashMap<String, Integer>> createTempRangeMap() {\r\n+        HashMap<String, HashMap<String, Integer>> tempRanges = new HashMap<>();\r\n+        HashMap<String, Integer> hmf = new HashMap<>();\r\n+        HashMap<String, Integer> hmc = new HashMap<>();\r\n+\r\n+        hmf.put(\"min\", new Integer(61)); // F\r\n+        hmf.put(\"max\", new Integer(86));\r\n+        tempRanges.put(\"F\", hmf);\r\n+\r\n+        hmc.put(\"min\", new Integer(16)); // C\r\n+        hmc.put(\"max\", new Integer(30));\r\n+        tempRanges.put(\"C\", hmc);\r\n+\r\n+        return tempRanges;\r\n+    }\r\n+\r\n+    /**\r\n+     * Checks input ranges for validity and TempUn for validity\r\n+     * Uses newVal as priority and tries to validate and determine intent\r\n+     * For example if value is 75 and TempUn says Celsius, change TempUn to Fahrenheit\r\n+     */\r\n+    private Integer[] validateTemperatureRangeForTempSet(Integer newValIn, @Nullable Integer CorFIn) {\r\n+        final String[] minMaxLUT = { \"max\", \"min\" }; // looks up 0 = C = max, 1 = F = min\r\n+        final String[] tempScaleLUT = { \"C\", \"F\" }; // Look Up Table used to convert TempUn integer 0,1 to \"C\" to \"F\"\r\n+                                                    // string for hashmap\r\n+        HashMap<String, Integer> nullCorFLUT = new HashMap<>(); // simple look up table for logic\r\n+        nullCorFLUT.put(\"C\", new Integer(0));\r\n+        nullCorFLUT.put(\"F\", new Integer(1));\r\n+        nullCorFLUT.put(\"INVALID\", new Integer(0));\r\n+\r\n+        String validRangeCorF; // stores if the input range is a valid C or F temperature\r\n+\r\n+        // force to global min/max\r\n+        Integer newVal = Math.max(newValIn, Math.min(tempRanges.get(\"C\").get(\"min\"), tempRanges.get(\"F\").get(\"min\")));\r\n+        newVal = Math.min(newVal, Math.max(tempRanges.get(\"C\").get(\"max\"), tempRanges.get(\"F\").get(\"max\")));\r\n+\r\n+        if ((newVal >= tempRanges.get(\"C\").get(\"min\")) && (newVal <= tempRanges.get(\"C\").get(\"max\"))) {\r\n+            validRangeCorF = \"C\";\r\n+        } else if ((newVal >= tempRanges.get(\"F\").get(\"min\")) && (newVal <= tempRanges.get(\"F\").get(\"max\"))) {\r\n+            validRangeCorF = \"F\";\r\n+        } else {\r\n+            logger.warn(\"Input Temp request {} is invalid\", newVal);\r\n+            validRangeCorF = \"INVALID\";\r\n+        }\r\n+\r\n+        // if CorF wasnt initialized or is null set it from lookup\r\n+        Integer CorF = CorFIn != null ? CorFIn : nullCorFLUT.get(validRangeCorF);\r\n+\r\n+        if ((CorF == 1) && (validRangeCorF == \"C\")) {\r\n+            CorF = 0; // input temp takes priority\r\n+        } else if ((CorF == 0) && (validRangeCorF == \"F\")) {\r\n+            CorF = 1; // input temp takes priority\r\n+        } else if (validRangeCorF == \"INVALID\") {\r\n+            // force min or max temp based on CorF scale to be used\r\n+            newVal = tempRanges.get(tempScaleLUT[CorF]).get(minMaxLUT[CorF]);\r\n+        }\r\n+\r\n+        return new Integer[] { newVal, CorF };\r\n+    }\r\n+\r\n+    public void setDeviceTempSet(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // **value** : set temperature in degrees celsius or Fahrenheit\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+        Integer[] retList;\r\n+        Integer newVal = new Integer(value);\r\n+        Integer outVal = new Integer(value);\r\n+        // Get Celsius or Fahrenheit from status message\r\n+        Integer CorF = getIntStatusVal(\"TemUn\");\r\n+        // TODO put a param in openhab to allow setting this from the config\r\n+\r\n+        // If commanding Fahrenheit set halfStep to 1 or 0 to tell the A/C which F integer\r\n+        // temperature to use as celsius alone is ambigious\r\n+        Integer halfStep = new Integer(0); // default to C\r\n+\r\n+        retList = validateTemperatureRangeForTempSet(newVal, CorF);\r\n+        newVal = retList[0];\r\n+        CorF = retList[1];\r\n+\r\n+        if (CorF == 1) { // If Fahrenheit,\r\n+            // value argument is degrees F, convert Fahrenheit to Celsius,\r\n+            // SetTem input to A/C always in Celsius despite passing in 1 to TemUn\r\n+            outVal = new Integer((int) Math.round((newVal - 32.) * 5.0 / 9.0)); // Integer Truncated\r\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\r\n+            // F = [68. , 69. , 70. , 71. , 72. , 73. , 74. , 75. , 76. , 77. , 78. , 79. , 80. , 81. , 82. , 83. ,\r\n+            // 84. , 85. , 86. ]\r\n+            // C = [20.0, 20.5, 21.1, 21.6, 22.2, 22.7, 23.3, 23.8, 24.4, 25.0, 25.5, 26.1, 26.6, 27.2, 27.7, 28.3,\r\n+            // 28.8, 29.4, 30.0]\r\n+            // TemSet = [20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 30, 30]\r\n+            // TemRec = [ 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]\r\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\r\n+            // subtract the float verison - the int version to get the fractional difference\r\n+            // if the difference is positive set halfStep to 1, negative to 0\r\n+            halfStep = ((((newVal - 32.) * 5.0 / 9.0) - outVal) > 0) ? 1 : 0;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"TemUn\", CorF);\r\n+        parameters.put(\"SetTem\", outVal);\r\n+        parameters.put(\"TemRec\", halfStep);\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceAir(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Air\", value);\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceDry(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Blo\", value);\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceHealth(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Health\", value);\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDevicePwrSaving(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"SvSt\", value);\r\n+        parameters.put(\"WdSpd\", new Integer(0));\r\n+        parameters.put(\"Quiet\", new Integer(0));\r\n+        parameters.put(\"Tur\", new Integer(0));\r\n+        parameters.put(\"SwhSlp\", new Integer(0));\r\n+        parameters.put(\"SlpMod\", new Integer(0));\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public int getIntStatusVal(String valueName) {\r\n+        /*\r\n+         * Note : Values can be:\r\n+         * \"Pow\": Power (0 or 1)\r\n+         * \"Mod\": Mode: Auto: 0, Cool: 1, Dry: 2, Fan: 3, Heat: 4\r\n+         * \"SetTem\": Requested Temperature\r\n+         * \"WdSpd\": Fan Speed : Low:1, Medium Low:2, Medium :3, Medium High :4, High :5\r\n+         * \"Air\": Air Mode Enabled\r\n+         * \"Blo\": Dry\r\n+         * \"Health\": Health\r\n+         * \"SwhSlp\": Sleep\r\n+         * \"SlpMod\": ???\r\n+         * \"Lig\": Light On\r\n+         * \"SwingLfRig\": Swing Left Right\r\n+         * \"SwUpDn\": Swing Up Down: // Ceiling:0, Upwards : 10, Downwards : 11, Full range : 1\r\n+         * \"Quiet\": Quiet mode\r\n+         * \"Tur\": Turbo\r\n+         * \"StHt\": 0,\r\n+         * \"TemUn\": Temperature unit, 0 for Celsius, 1 for Fahrenheit\r\n+         * \"HeatCoolType\"\r\n+         * \"TemRec\": (0 or 1), Send with SetTem, when TemUn==1, distinguishes between upper and lower integer Fahrenheit\r\n+         * temp\r\n+         * \"SvSt\": Power Saving\r\n+         */\r\n+        // Find the valueName in the Returned Status object\r\n+        String columns[] = statusResponseGson.packJson.cols;\r\n+        Integer values[] = statusResponseGson.packJson.dat;\r\n+        List<String> colList = new ArrayList<>(Arrays.asList(columns));\r\n+        List<Integer> valList = new ArrayList<>(Arrays.asList(values));\r\n+        int valueArrayposition = colList.indexOf(valueName);\r\n+        if (valueArrayposition == -1) {\r\n+            return -1;\r\n+        }\r\n+\r\n+        // Now get the Corresponding value\r\n+        Integer value = valList.get(valueArrayposition);\r\n+        return value;\r\n+    }\r\n+\r\n+    public boolean hasStatusValChanged(String valueName) throws GreeException {\r\n+        if (prevStatusResponsePackGson == null) {\r\n+            return true; // update value if there is no previous one\r\n+        }\r\n+        // Find the valueName in the Current Status object\r\n+        String currcolumns[] = statusResponseGson.packJson.cols;\r\n+        Integer currvalues[] = statusResponseGson.packJson.dat;\r\n+        List<String> currcolList = new ArrayList<>(Arrays.asList(currcolumns));\r\n+        List<Integer> currvalList = new ArrayList<>(Arrays.asList(currvalues));\r\n+        int currvalueArrayposition = currcolList.indexOf(valueName);\r\n+        if (currvalueArrayposition == -1) {\r\n+            throw new GreeException(\"Unable to decode device status\");\r\n+        }\r\n+        // Now get the Corresponding value\r\n+        int currvalue = currvalList.get(currvalueArrayposition);\r\n+\r\n+        // Find the valueName in the Previous Status object\r\n+        String prevcolumns[] = prevStatusResponsePackGson.cols;\r\n+        Integer prevvalues[] = prevStatusResponsePackGson.dat;\r\n+        List<String> prevcolList = new ArrayList<>(Arrays.asList(prevcolumns));\r\n+        List<Integer> prevvalList = new ArrayList<>(Arrays.asList(prevvalues));\r\n+        int prevvalueArrayposition = prevcolList.indexOf(valueName);\r\n+        if (prevvalueArrayposition == -1) {\r\n+            throw new GreeException(\"Unable to get status value\");\r\n+        }\r\n+        // Now get the Corresponding value\r\n+        int prevvalue = prevvalList.get(prevvalueArrayposition);\r\n+\r\n+        // Finally Compare the values\r\n+        return currvalue != prevvalue;\r\n+    }\r\n+\r\n+    protected void executeCommand(DatagramSocket clientSocket, HashMap<String, Integer> parameters)\r\n+            throws GreeException {\r\n+        byte[] sendData = new byte[1024];\r\n+        byte[] receiveData = new byte[1024];\r\n+        Gson gson = new Gson();\r\n+\r\n+        try {\r\n+            // Convert the parameter map values to arrays\r\n+            String[] keyArray = parameters.keySet().toArray(new String[0]);\r\n+            Integer[] valueArray = parameters.values().toArray(new Integer[0]);\r\n+\r\n+            // Prep the Command Request pack\r\n+            GreeExecuteCommandPack4GsonDTO execCmdPackGson = new GreeExecuteCommandPack4GsonDTO();\r\n+            execCmdPackGson.opt = keyArray;\r\n+            execCmdPackGson.p = valueArray;\r\n+            execCmdPackGson.t = \"cmd\";\r\n+            String execCmdPackStr = gson.toJson(execCmdPackGson);\r\n+\r\n+            // Now Encrypt the Binding Request pack\r\n+            String encryptedCommandReqPacket = GreeCryptoUtil.encryptPack(getKey().getBytes(), execCmdPackStr);\r\n+            // String unencryptedCommandReqPacket = CryptoUtil.decryptPack(device.getKey().getBytes(),\r\n+            // encryptedCommandReqPacket);\r\n+\r\n+            // Prep the Command Request\r\n+            GreeExecCommand4GsonDTO execCmdGson = new GreeExecCommand4GsonDTO();\r\n+            execCmdGson.cid = \"app\";\r\n+            execCmdGson.i = 0;\r\n+            execCmdGson.t = \"pack\";\r\n+            execCmdGson.uid = 0;\r\n+            execCmdGson.tcid = getId();\r\n+            execCmdGson.pack = new String(encryptedCommandReqPacket.getBytes(), UTF8_CHARSET);\r\n+            String execCmdStr = gson.toJson(execCmdGson);\r\n+            sendData = execCmdStr.getBytes();\r\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\r\n+            clientSocket.send(sendPacket);\r\n+\r\n+            // Recieve a response\r\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\r\n+            clientSocket.receive(receivePacket);\r\n+            String modifiedSentence = new String(receivePacket.getData());\r\n+            // System.out.println(\"FROM SERVER:\" + modifiedSentence);\r\n+            // byte[] modifiedSentenceArray = receivePacket.getData();\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 558}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MTAwMg==", "bodyText": "Encoding", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432881002", "createdAt": "2020-05-30T19:33:18Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,690 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal.discovery;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.StringReader;\r\n+import java.net.DatagramPacket;\r\n+import java.net.DatagramSocket;\r\n+import java.net.InetAddress;\r\n+import java.nio.charset.Charset;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Objects;\r\n+import java.util.Optional;\r\n+\r\n+import org.apache.commons.lang.Validate;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\r\n+import org.openhab.binding.gree.internal.GreeException;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.stream.JsonReader;\r\n+\r\n+/**\r\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\r\n+ * device specific attributes as well a the functionality for the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+// @NonNullByDefault\r\n+public class GreeAirDevice {\r\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\r\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\r\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\r\n+    private boolean isBound = false;\r\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\r\n+    private int port = 0;\r\n+    private String encKey = \"\";\r\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\r\n+    private GreeBindResponse4GsonDTO bindResponseGson;\r\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\r\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\r\n+\r\n+    public Boolean getIsBound() {\r\n+        return isBound;\r\n+    }\r\n+\r\n+    public void setIsBound(boolean isBound) {\r\n+        this.isBound = isBound;\r\n+    }\r\n+\r\n+    public InetAddress getAddress() {\r\n+        return ipAddress;\r\n+    }\r\n+\r\n+    public void setAddress(InetAddress address) {\r\n+        this.ipAddress = address;\r\n+    }\r\n+\r\n+    public int getPort() {\r\n+        return port;\r\n+    }\r\n+\r\n+    public void setPort(int port) {\r\n+        this.port = port;\r\n+    }\r\n+\r\n+    public String getKey() {\r\n+        return encKey;\r\n+    }\r\n+\r\n+    public String getId() {\r\n+        return mScanResponseGson.packJson.mac;\r\n+    }\r\n+\r\n+    public String getName() {\r\n+        return mScanResponseGson.packJson.name;\r\n+    }\r\n+\r\n+    public String getVendor() {\r\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\r\n+    }\r\n+\r\n+    public String getModel() {\r\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\r\n+    }\r\n+\r\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\r\n+        return mScanResponseGson;\r\n+    }\r\n+\r\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\r\n+        mScanResponseGson = gson;\r\n+    }\r\n+\r\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\r\n+        return bindResponseGson;\r\n+    }\r\n+\r\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\r\n+        return statusResponseGson;\r\n+    }\r\n+\r\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\r\n+        Validate.isTrue(socket.isPresent());\r\n+        byte[] sendData = new byte[1024];\r\n+        byte[] receiveData = new byte[347];\r\n+        Gson gson = new Gson();\r\n+\r\n+        try {\r\n+            // Prep the Binding Request pack\r\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\r\n+            bindReqPackGson.mac = getId();\r\n+            bindReqPackGson.t = \"bind\";\r\n+            bindReqPackGson.uid = 0;\r\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\r\n+\r\n+            // Now Encrypt the Binding Request pack\r\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindReqPackStr);\r\n+\r\n+            // Prep the Binding Request\r\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\r\n+            bindReqGson.cid = \"app\";\r\n+            bindReqGson.i = 1;\r\n+            bindReqGson.t = \"pack\";\r\n+            bindReqGson.uid = 0;\r\n+            bindReqGson.tcid = getId();\r\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\r\n+            String bindReqStr = gson.toJson(bindReqGson);\r\n+            sendData = bindReqStr.getBytes();\r\n+\r\n+            // Now Send the request\r\n+            DatagramSocket clientSocket = socket.get();\r\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\r\n+            clientSocket.send(sendPacket);\r\n+\r\n+            // Recieve a response\r\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\r\n+            clientSocket.receive(receivePacket);\r\n+            String modifiedSentence = new String(receivePacket.getData());\r\n+\r\n+            // Read the response\r\n+            StringReader stringReader = new StringReader(modifiedSentence);\r\n+            bindResponseGson = gson.fromJson(new JsonReader(stringReader), GreeBindResponse4GsonDTO.class);\r\n+            bindResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindResponseGson.pack);\r\n+\r\n+            // Create the JSON to hold the response values\r\n+            stringReader = new StringReader(bindResponseGson.decryptedPack);\r\n+            bindResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePack4GsonDTO.class);\r\n+\r\n+            // Now set the key and flag to indicate the bind was succesful\r\n+            encKey = bindResponseGson.packJson.key;\r\n+            setIsBound(true);\r\n+        } catch (IOException e) {\r\n+            throw new GreeException(e, \"failed\");\r\n+        }\r\n+    }\r\n+\r\n+    public void setDevicePower(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Pow\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void SetDeviceMode(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 4)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Mod\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceSwingVertical(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 11)\r\n+                || (value.intValue() > 6 && value.intValue() < 10)) {\r\n+            return;\r\n+        }\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"SwUpDn\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Only allow this to happen if this device has been bound and values are valid\r\n+     * Possible values are :\r\n+     * 0 : Auto\r\n+     * 1 : Low\r\n+     * 2 : Medium Low\r\n+     * 3 : Medium\r\n+     * 4 : Medium High\r\n+     * 5 : High\r\n+     */\r\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 5)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"WdSpd\", value);\r\n+        parameters.put(\"Quiet\", 0);\r\n+        parameters.put(\"Tur\", 0);\r\n+        parameters.put(\"NoiseSet\", 0);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceTurbo(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Tur\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public int getDeviceTurbo() {\r\n+        return getIntStatusVal(\"Tur\");\r\n+    }\r\n+\r\n+    public void setDeviceLight(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Lig\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create Hash Look Up for C and F\r\n+     * Temperature Ranges for gree A/C units (f_range = {86,61}, c_range={16,30}\r\n+     */\r\n+    private static HashMap<String, HashMap<String, Integer>> createTempRangeMap() {\r\n+        HashMap<String, HashMap<String, Integer>> tempRanges = new HashMap<>();\r\n+        HashMap<String, Integer> hmf = new HashMap<>();\r\n+        HashMap<String, Integer> hmc = new HashMap<>();\r\n+\r\n+        hmf.put(\"min\", new Integer(61)); // F\r\n+        hmf.put(\"max\", new Integer(86));\r\n+        tempRanges.put(\"F\", hmf);\r\n+\r\n+        hmc.put(\"min\", new Integer(16)); // C\r\n+        hmc.put(\"max\", new Integer(30));\r\n+        tempRanges.put(\"C\", hmc);\r\n+\r\n+        return tempRanges;\r\n+    }\r\n+\r\n+    /**\r\n+     * Checks input ranges for validity and TempUn for validity\r\n+     * Uses newVal as priority and tries to validate and determine intent\r\n+     * For example if value is 75 and TempUn says Celsius, change TempUn to Fahrenheit\r\n+     */\r\n+    private Integer[] validateTemperatureRangeForTempSet(Integer newValIn, @Nullable Integer CorFIn) {\r\n+        final String[] minMaxLUT = { \"max\", \"min\" }; // looks up 0 = C = max, 1 = F = min\r\n+        final String[] tempScaleLUT = { \"C\", \"F\" }; // Look Up Table used to convert TempUn integer 0,1 to \"C\" to \"F\"\r\n+                                                    // string for hashmap\r\n+        HashMap<String, Integer> nullCorFLUT = new HashMap<>(); // simple look up table for logic\r\n+        nullCorFLUT.put(\"C\", new Integer(0));\r\n+        nullCorFLUT.put(\"F\", new Integer(1));\r\n+        nullCorFLUT.put(\"INVALID\", new Integer(0));\r\n+\r\n+        String validRangeCorF; // stores if the input range is a valid C or F temperature\r\n+\r\n+        // force to global min/max\r\n+        Integer newVal = Math.max(newValIn, Math.min(tempRanges.get(\"C\").get(\"min\"), tempRanges.get(\"F\").get(\"min\")));\r\n+        newVal = Math.min(newVal, Math.max(tempRanges.get(\"C\").get(\"max\"), tempRanges.get(\"F\").get(\"max\")));\r\n+\r\n+        if ((newVal >= tempRanges.get(\"C\").get(\"min\")) && (newVal <= tempRanges.get(\"C\").get(\"max\"))) {\r\n+            validRangeCorF = \"C\";\r\n+        } else if ((newVal >= tempRanges.get(\"F\").get(\"min\")) && (newVal <= tempRanges.get(\"F\").get(\"max\"))) {\r\n+            validRangeCorF = \"F\";\r\n+        } else {\r\n+            logger.warn(\"Input Temp request {} is invalid\", newVal);\r\n+            validRangeCorF = \"INVALID\";\r\n+        }\r\n+\r\n+        // if CorF wasnt initialized or is null set it from lookup\r\n+        Integer CorF = CorFIn != null ? CorFIn : nullCorFLUT.get(validRangeCorF);\r\n+\r\n+        if ((CorF == 1) && (validRangeCorF == \"C\")) {\r\n+            CorF = 0; // input temp takes priority\r\n+        } else if ((CorF == 0) && (validRangeCorF == \"F\")) {\r\n+            CorF = 1; // input temp takes priority\r\n+        } else if (validRangeCorF == \"INVALID\") {\r\n+            // force min or max temp based on CorF scale to be used\r\n+            newVal = tempRanges.get(tempScaleLUT[CorF]).get(minMaxLUT[CorF]);\r\n+        }\r\n+\r\n+        return new Integer[] { newVal, CorF };\r\n+    }\r\n+\r\n+    public void setDeviceTempSet(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // **value** : set temperature in degrees celsius or Fahrenheit\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+        Integer[] retList;\r\n+        Integer newVal = new Integer(value);\r\n+        Integer outVal = new Integer(value);\r\n+        // Get Celsius or Fahrenheit from status message\r\n+        Integer CorF = getIntStatusVal(\"TemUn\");\r\n+        // TODO put a param in openhab to allow setting this from the config\r\n+\r\n+        // If commanding Fahrenheit set halfStep to 1 or 0 to tell the A/C which F integer\r\n+        // temperature to use as celsius alone is ambigious\r\n+        Integer halfStep = new Integer(0); // default to C\r\n+\r\n+        retList = validateTemperatureRangeForTempSet(newVal, CorF);\r\n+        newVal = retList[0];\r\n+        CorF = retList[1];\r\n+\r\n+        if (CorF == 1) { // If Fahrenheit,\r\n+            // value argument is degrees F, convert Fahrenheit to Celsius,\r\n+            // SetTem input to A/C always in Celsius despite passing in 1 to TemUn\r\n+            outVal = new Integer((int) Math.round((newVal - 32.) * 5.0 / 9.0)); // Integer Truncated\r\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\r\n+            // F = [68. , 69. , 70. , 71. , 72. , 73. , 74. , 75. , 76. , 77. , 78. , 79. , 80. , 81. , 82. , 83. ,\r\n+            // 84. , 85. , 86. ]\r\n+            // C = [20.0, 20.5, 21.1, 21.6, 22.2, 22.7, 23.3, 23.8, 24.4, 25.0, 25.5, 26.1, 26.6, 27.2, 27.7, 28.3,\r\n+            // 28.8, 29.4, 30.0]\r\n+            // TemSet = [20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 30, 30]\r\n+            // TemRec = [ 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]\r\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\r\n+            // subtract the float verison - the int version to get the fractional difference\r\n+            // if the difference is positive set halfStep to 1, negative to 0\r\n+            halfStep = ((((newVal - 32.) * 5.0 / 9.0) - outVal) > 0) ? 1 : 0;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"TemUn\", CorF);\r\n+        parameters.put(\"SetTem\", outVal);\r\n+        parameters.put(\"TemRec\", halfStep);\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceAir(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Air\", value);\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceDry(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Blo\", value);\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceHealth(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Health\", value);\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDevicePwrSaving(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"SvSt\", value);\r\n+        parameters.put(\"WdSpd\", new Integer(0));\r\n+        parameters.put(\"Quiet\", new Integer(0));\r\n+        parameters.put(\"Tur\", new Integer(0));\r\n+        parameters.put(\"SwhSlp\", new Integer(0));\r\n+        parameters.put(\"SlpMod\", new Integer(0));\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public int getIntStatusVal(String valueName) {\r\n+        /*\r\n+         * Note : Values can be:\r\n+         * \"Pow\": Power (0 or 1)\r\n+         * \"Mod\": Mode: Auto: 0, Cool: 1, Dry: 2, Fan: 3, Heat: 4\r\n+         * \"SetTem\": Requested Temperature\r\n+         * \"WdSpd\": Fan Speed : Low:1, Medium Low:2, Medium :3, Medium High :4, High :5\r\n+         * \"Air\": Air Mode Enabled\r\n+         * \"Blo\": Dry\r\n+         * \"Health\": Health\r\n+         * \"SwhSlp\": Sleep\r\n+         * \"SlpMod\": ???\r\n+         * \"Lig\": Light On\r\n+         * \"SwingLfRig\": Swing Left Right\r\n+         * \"SwUpDn\": Swing Up Down: // Ceiling:0, Upwards : 10, Downwards : 11, Full range : 1\r\n+         * \"Quiet\": Quiet mode\r\n+         * \"Tur\": Turbo\r\n+         * \"StHt\": 0,\r\n+         * \"TemUn\": Temperature unit, 0 for Celsius, 1 for Fahrenheit\r\n+         * \"HeatCoolType\"\r\n+         * \"TemRec\": (0 or 1), Send with SetTem, when TemUn==1, distinguishes between upper and lower integer Fahrenheit\r\n+         * temp\r\n+         * \"SvSt\": Power Saving\r\n+         */\r\n+        // Find the valueName in the Returned Status object\r\n+        String columns[] = statusResponseGson.packJson.cols;\r\n+        Integer values[] = statusResponseGson.packJson.dat;\r\n+        List<String> colList = new ArrayList<>(Arrays.asList(columns));\r\n+        List<Integer> valList = new ArrayList<>(Arrays.asList(values));\r\n+        int valueArrayposition = colList.indexOf(valueName);\r\n+        if (valueArrayposition == -1) {\r\n+            return -1;\r\n+        }\r\n+\r\n+        // Now get the Corresponding value\r\n+        Integer value = valList.get(valueArrayposition);\r\n+        return value;\r\n+    }\r\n+\r\n+    public boolean hasStatusValChanged(String valueName) throws GreeException {\r\n+        if (prevStatusResponsePackGson == null) {\r\n+            return true; // update value if there is no previous one\r\n+        }\r\n+        // Find the valueName in the Current Status object\r\n+        String currcolumns[] = statusResponseGson.packJson.cols;\r\n+        Integer currvalues[] = statusResponseGson.packJson.dat;\r\n+        List<String> currcolList = new ArrayList<>(Arrays.asList(currcolumns));\r\n+        List<Integer> currvalList = new ArrayList<>(Arrays.asList(currvalues));\r\n+        int currvalueArrayposition = currcolList.indexOf(valueName);\r\n+        if (currvalueArrayposition == -1) {\r\n+            throw new GreeException(\"Unable to decode device status\");\r\n+        }\r\n+        // Now get the Corresponding value\r\n+        int currvalue = currvalList.get(currvalueArrayposition);\r\n+\r\n+        // Find the valueName in the Previous Status object\r\n+        String prevcolumns[] = prevStatusResponsePackGson.cols;\r\n+        Integer prevvalues[] = prevStatusResponsePackGson.dat;\r\n+        List<String> prevcolList = new ArrayList<>(Arrays.asList(prevcolumns));\r\n+        List<Integer> prevvalList = new ArrayList<>(Arrays.asList(prevvalues));\r\n+        int prevvalueArrayposition = prevcolList.indexOf(valueName);\r\n+        if (prevvalueArrayposition == -1) {\r\n+            throw new GreeException(\"Unable to get status value\");\r\n+        }\r\n+        // Now get the Corresponding value\r\n+        int prevvalue = prevvalList.get(prevvalueArrayposition);\r\n+\r\n+        // Finally Compare the values\r\n+        return currvalue != prevvalue;\r\n+    }\r\n+\r\n+    protected void executeCommand(DatagramSocket clientSocket, HashMap<String, Integer> parameters)\r\n+            throws GreeException {\r\n+        byte[] sendData = new byte[1024];\r\n+        byte[] receiveData = new byte[1024];\r\n+        Gson gson = new Gson();\r\n+\r\n+        try {\r\n+            // Convert the parameter map values to arrays\r\n+            String[] keyArray = parameters.keySet().toArray(new String[0]);\r\n+            Integer[] valueArray = parameters.values().toArray(new Integer[0]);\r\n+\r\n+            // Prep the Command Request pack\r\n+            GreeExecuteCommandPack4GsonDTO execCmdPackGson = new GreeExecuteCommandPack4GsonDTO();\r\n+            execCmdPackGson.opt = keyArray;\r\n+            execCmdPackGson.p = valueArray;\r\n+            execCmdPackGson.t = \"cmd\";\r\n+            String execCmdPackStr = gson.toJson(execCmdPackGson);\r\n+\r\n+            // Now Encrypt the Binding Request pack\r\n+            String encryptedCommandReqPacket = GreeCryptoUtil.encryptPack(getKey().getBytes(), execCmdPackStr);\r\n+            // String unencryptedCommandReqPacket = CryptoUtil.decryptPack(device.getKey().getBytes(),\r\n+            // encryptedCommandReqPacket);\r\n+\r\n+            // Prep the Command Request\r\n+            GreeExecCommand4GsonDTO execCmdGson = new GreeExecCommand4GsonDTO();\r\n+            execCmdGson.cid = \"app\";\r\n+            execCmdGson.i = 0;\r\n+            execCmdGson.t = \"pack\";\r\n+            execCmdGson.uid = 0;\r\n+            execCmdGson.tcid = getId();\r\n+            execCmdGson.pack = new String(encryptedCommandReqPacket.getBytes(), UTF8_CHARSET);\r\n+            String execCmdStr = gson.toJson(execCmdGson);\r\n+            sendData = execCmdStr.getBytes();\r\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\r\n+            clientSocket.send(sendPacket);\r\n+\r\n+            // Recieve a response\r\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\r\n+            clientSocket.receive(receivePacket);\r\n+            String modifiedSentence = new String(receivePacket.getData());\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 556}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MTA5Mw==", "bodyText": "Encoding", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432881093", "createdAt": "2020-05-30T19:35:09Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,690 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal.discovery;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.StringReader;\r\n+import java.net.DatagramPacket;\r\n+import java.net.DatagramSocket;\r\n+import java.net.InetAddress;\r\n+import java.nio.charset.Charset;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Objects;\r\n+import java.util.Optional;\r\n+\r\n+import org.apache.commons.lang.Validate;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\r\n+import org.openhab.binding.gree.internal.GreeException;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.stream.JsonReader;\r\n+\r\n+/**\r\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\r\n+ * device specific attributes as well a the functionality for the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+// @NonNullByDefault\r\n+public class GreeAirDevice {\r\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\r\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\r\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\r\n+    private boolean isBound = false;\r\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\r\n+    private int port = 0;\r\n+    private String encKey = \"\";\r\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\r\n+    private GreeBindResponse4GsonDTO bindResponseGson;\r\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\r\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\r\n+\r\n+    public Boolean getIsBound() {\r\n+        return isBound;\r\n+    }\r\n+\r\n+    public void setIsBound(boolean isBound) {\r\n+        this.isBound = isBound;\r\n+    }\r\n+\r\n+    public InetAddress getAddress() {\r\n+        return ipAddress;\r\n+    }\r\n+\r\n+    public void setAddress(InetAddress address) {\r\n+        this.ipAddress = address;\r\n+    }\r\n+\r\n+    public int getPort() {\r\n+        return port;\r\n+    }\r\n+\r\n+    public void setPort(int port) {\r\n+        this.port = port;\r\n+    }\r\n+\r\n+    public String getKey() {\r\n+        return encKey;\r\n+    }\r\n+\r\n+    public String getId() {\r\n+        return mScanResponseGson.packJson.mac;\r\n+    }\r\n+\r\n+    public String getName() {\r\n+        return mScanResponseGson.packJson.name;\r\n+    }\r\n+\r\n+    public String getVendor() {\r\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\r\n+    }\r\n+\r\n+    public String getModel() {\r\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\r\n+    }\r\n+\r\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\r\n+        return mScanResponseGson;\r\n+    }\r\n+\r\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\r\n+        mScanResponseGson = gson;\r\n+    }\r\n+\r\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\r\n+        return bindResponseGson;\r\n+    }\r\n+\r\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\r\n+        return statusResponseGson;\r\n+    }\r\n+\r\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\r\n+        Validate.isTrue(socket.isPresent());\r\n+        byte[] sendData = new byte[1024];\r\n+        byte[] receiveData = new byte[347];\r\n+        Gson gson = new Gson();\r\n+\r\n+        try {\r\n+            // Prep the Binding Request pack\r\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\r\n+            bindReqPackGson.mac = getId();\r\n+            bindReqPackGson.t = \"bind\";\r\n+            bindReqPackGson.uid = 0;\r\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\r\n+\r\n+            // Now Encrypt the Binding Request pack\r\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindReqPackStr);\r\n+\r\n+            // Prep the Binding Request\r\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\r\n+            bindReqGson.cid = \"app\";\r\n+            bindReqGson.i = 1;\r\n+            bindReqGson.t = \"pack\";\r\n+            bindReqGson.uid = 0;\r\n+            bindReqGson.tcid = getId();\r\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\r\n+            String bindReqStr = gson.toJson(bindReqGson);\r\n+            sendData = bindReqStr.getBytes();\r\n+\r\n+            // Now Send the request\r\n+            DatagramSocket clientSocket = socket.get();\r\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\r\n+            clientSocket.send(sendPacket);\r\n+\r\n+            // Recieve a response\r\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\r\n+            clientSocket.receive(receivePacket);\r\n+            String modifiedSentence = new String(receivePacket.getData());\r\n+\r\n+            // Read the response\r\n+            StringReader stringReader = new StringReader(modifiedSentence);\r\n+            bindResponseGson = gson.fromJson(new JsonReader(stringReader), GreeBindResponse4GsonDTO.class);\r\n+            bindResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.GetAESGeneralKeyByteArray(),\r\n+                    bindResponseGson.pack);\r\n+\r\n+            // Create the JSON to hold the response values\r\n+            stringReader = new StringReader(bindResponseGson.decryptedPack);\r\n+            bindResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePack4GsonDTO.class);\r\n+\r\n+            // Now set the key and flag to indicate the bind was succesful\r\n+            encKey = bindResponseGson.packJson.key;\r\n+            setIsBound(true);\r\n+        } catch (IOException e) {\r\n+            throw new GreeException(e, \"failed\");\r\n+        }\r\n+    }\r\n+\r\n+    public void setDevicePower(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Pow\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void SetDeviceMode(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 4)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Mod\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceSwingVertical(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 11)\r\n+                || (value.intValue() > 6 && value.intValue() < 10)) {\r\n+            return;\r\n+        }\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"SwUpDn\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Only allow this to happen if this device has been bound and values are valid\r\n+     * Possible values are :\r\n+     * 0 : Auto\r\n+     * 1 : Low\r\n+     * 2 : Medium Low\r\n+     * 3 : Medium\r\n+     * 4 : Medium High\r\n+     * 5 : High\r\n+     */\r\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 5)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"WdSpd\", value);\r\n+        parameters.put(\"Quiet\", 0);\r\n+        parameters.put(\"Tur\", 0);\r\n+        parameters.put(\"NoiseSet\", 0);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceTurbo(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Tur\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public int getDeviceTurbo() {\r\n+        return getIntStatusVal(\"Tur\");\r\n+    }\r\n+\r\n+    public void setDeviceLight(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if ((!Objects.equals(getIsBound(), Boolean.TRUE)) || (value.intValue() < 0 || value.intValue() > 1)) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Lig\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create Hash Look Up for C and F\r\n+     * Temperature Ranges for gree A/C units (f_range = {86,61}, c_range={16,30}\r\n+     */\r\n+    private static HashMap<String, HashMap<String, Integer>> createTempRangeMap() {\r\n+        HashMap<String, HashMap<String, Integer>> tempRanges = new HashMap<>();\r\n+        HashMap<String, Integer> hmf = new HashMap<>();\r\n+        HashMap<String, Integer> hmc = new HashMap<>();\r\n+\r\n+        hmf.put(\"min\", new Integer(61)); // F\r\n+        hmf.put(\"max\", new Integer(86));\r\n+        tempRanges.put(\"F\", hmf);\r\n+\r\n+        hmc.put(\"min\", new Integer(16)); // C\r\n+        hmc.put(\"max\", new Integer(30));\r\n+        tempRanges.put(\"C\", hmc);\r\n+\r\n+        return tempRanges;\r\n+    }\r\n+\r\n+    /**\r\n+     * Checks input ranges for validity and TempUn for validity\r\n+     * Uses newVal as priority and tries to validate and determine intent\r\n+     * For example if value is 75 and TempUn says Celsius, change TempUn to Fahrenheit\r\n+     */\r\n+    private Integer[] validateTemperatureRangeForTempSet(Integer newValIn, @Nullable Integer CorFIn) {\r\n+        final String[] minMaxLUT = { \"max\", \"min\" }; // looks up 0 = C = max, 1 = F = min\r\n+        final String[] tempScaleLUT = { \"C\", \"F\" }; // Look Up Table used to convert TempUn integer 0,1 to \"C\" to \"F\"\r\n+                                                    // string for hashmap\r\n+        HashMap<String, Integer> nullCorFLUT = new HashMap<>(); // simple look up table for logic\r\n+        nullCorFLUT.put(\"C\", new Integer(0));\r\n+        nullCorFLUT.put(\"F\", new Integer(1));\r\n+        nullCorFLUT.put(\"INVALID\", new Integer(0));\r\n+\r\n+        String validRangeCorF; // stores if the input range is a valid C or F temperature\r\n+\r\n+        // force to global min/max\r\n+        Integer newVal = Math.max(newValIn, Math.min(tempRanges.get(\"C\").get(\"min\"), tempRanges.get(\"F\").get(\"min\")));\r\n+        newVal = Math.min(newVal, Math.max(tempRanges.get(\"C\").get(\"max\"), tempRanges.get(\"F\").get(\"max\")));\r\n+\r\n+        if ((newVal >= tempRanges.get(\"C\").get(\"min\")) && (newVal <= tempRanges.get(\"C\").get(\"max\"))) {\r\n+            validRangeCorF = \"C\";\r\n+        } else if ((newVal >= tempRanges.get(\"F\").get(\"min\")) && (newVal <= tempRanges.get(\"F\").get(\"max\"))) {\r\n+            validRangeCorF = \"F\";\r\n+        } else {\r\n+            logger.warn(\"Input Temp request {} is invalid\", newVal);\r\n+            validRangeCorF = \"INVALID\";\r\n+        }\r\n+\r\n+        // if CorF wasnt initialized or is null set it from lookup\r\n+        Integer CorF = CorFIn != null ? CorFIn : nullCorFLUT.get(validRangeCorF);\r\n+\r\n+        if ((CorF == 1) && (validRangeCorF == \"C\")) {\r\n+            CorF = 0; // input temp takes priority\r\n+        } else if ((CorF == 0) && (validRangeCorF == \"F\")) {\r\n+            CorF = 1; // input temp takes priority\r\n+        } else if (validRangeCorF == \"INVALID\") {\r\n+            // force min or max temp based on CorF scale to be used\r\n+            newVal = tempRanges.get(tempScaleLUT[CorF]).get(minMaxLUT[CorF]);\r\n+        }\r\n+\r\n+        return new Integer[] { newVal, CorF };\r\n+    }\r\n+\r\n+    public void setDeviceTempSet(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // **value** : set temperature in degrees celsius or Fahrenheit\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+        Integer[] retList;\r\n+        Integer newVal = new Integer(value);\r\n+        Integer outVal = new Integer(value);\r\n+        // Get Celsius or Fahrenheit from status message\r\n+        Integer CorF = getIntStatusVal(\"TemUn\");\r\n+        // TODO put a param in openhab to allow setting this from the config\r\n+\r\n+        // If commanding Fahrenheit set halfStep to 1 or 0 to tell the A/C which F integer\r\n+        // temperature to use as celsius alone is ambigious\r\n+        Integer halfStep = new Integer(0); // default to C\r\n+\r\n+        retList = validateTemperatureRangeForTempSet(newVal, CorF);\r\n+        newVal = retList[0];\r\n+        CorF = retList[1];\r\n+\r\n+        if (CorF == 1) { // If Fahrenheit,\r\n+            // value argument is degrees F, convert Fahrenheit to Celsius,\r\n+            // SetTem input to A/C always in Celsius despite passing in 1 to TemUn\r\n+            outVal = new Integer((int) Math.round((newVal - 32.) * 5.0 / 9.0)); // Integer Truncated\r\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\r\n+            // F = [68. , 69. , 70. , 71. , 72. , 73. , 74. , 75. , 76. , 77. , 78. , 79. , 80. , 81. , 82. , 83. ,\r\n+            // 84. , 85. , 86. ]\r\n+            // C = [20.0, 20.5, 21.1, 21.6, 22.2, 22.7, 23.3, 23.8, 24.4, 25.0, 25.5, 26.1, 26.6, 27.2, 27.7, 28.3,\r\n+            // 28.8, 29.4, 30.0]\r\n+            // TemSet = [20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 30, 30]\r\n+            // TemRec = [ 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]\r\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\r\n+            // subtract the float verison - the int version to get the fractional difference\r\n+            // if the difference is positive set halfStep to 1, negative to 0\r\n+            halfStep = ((((newVal - 32.) * 5.0 / 9.0) - outVal) > 0) ? 1 : 0;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"TemUn\", CorF);\r\n+        parameters.put(\"SetTem\", outVal);\r\n+        parameters.put(\"TemRec\", halfStep);\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceAir(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Air\", value);\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceDry(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Blo\", value);\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceHealth(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Health\", value);\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDevicePwrSaving(DatagramSocket clientSocket, Integer value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound\r\n+        if (getIsBound() != Boolean.TRUE) {\r\n+            return;\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"SvSt\", value);\r\n+        parameters.put(\"WdSpd\", new Integer(0));\r\n+        parameters.put(\"Quiet\", new Integer(0));\r\n+        parameters.put(\"Tur\", new Integer(0));\r\n+        parameters.put(\"SwhSlp\", new Integer(0));\r\n+        parameters.put(\"SlpMod\", new Integer(0));\r\n+\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public int getIntStatusVal(String valueName) {\r\n+        /*\r\n+         * Note : Values can be:\r\n+         * \"Pow\": Power (0 or 1)\r\n+         * \"Mod\": Mode: Auto: 0, Cool: 1, Dry: 2, Fan: 3, Heat: 4\r\n+         * \"SetTem\": Requested Temperature\r\n+         * \"WdSpd\": Fan Speed : Low:1, Medium Low:2, Medium :3, Medium High :4, High :5\r\n+         * \"Air\": Air Mode Enabled\r\n+         * \"Blo\": Dry\r\n+         * \"Health\": Health\r\n+         * \"SwhSlp\": Sleep\r\n+         * \"SlpMod\": ???\r\n+         * \"Lig\": Light On\r\n+         * \"SwingLfRig\": Swing Left Right\r\n+         * \"SwUpDn\": Swing Up Down: // Ceiling:0, Upwards : 10, Downwards : 11, Full range : 1\r\n+         * \"Quiet\": Quiet mode\r\n+         * \"Tur\": Turbo\r\n+         * \"StHt\": 0,\r\n+         * \"TemUn\": Temperature unit, 0 for Celsius, 1 for Fahrenheit\r\n+         * \"HeatCoolType\"\r\n+         * \"TemRec\": (0 or 1), Send with SetTem, when TemUn==1, distinguishes between upper and lower integer Fahrenheit\r\n+         * temp\r\n+         * \"SvSt\": Power Saving\r\n+         */\r\n+        // Find the valueName in the Returned Status object\r\n+        String columns[] = statusResponseGson.packJson.cols;\r\n+        Integer values[] = statusResponseGson.packJson.dat;\r\n+        List<String> colList = new ArrayList<>(Arrays.asList(columns));\r\n+        List<Integer> valList = new ArrayList<>(Arrays.asList(values));\r\n+        int valueArrayposition = colList.indexOf(valueName);\r\n+        if (valueArrayposition == -1) {\r\n+            return -1;\r\n+        }\r\n+\r\n+        // Now get the Corresponding value\r\n+        Integer value = valList.get(valueArrayposition);\r\n+        return value;\r\n+    }\r\n+\r\n+    public boolean hasStatusValChanged(String valueName) throws GreeException {\r\n+        if (prevStatusResponsePackGson == null) {\r\n+            return true; // update value if there is no previous one\r\n+        }\r\n+        // Find the valueName in the Current Status object\r\n+        String currcolumns[] = statusResponseGson.packJson.cols;\r\n+        Integer currvalues[] = statusResponseGson.packJson.dat;\r\n+        List<String> currcolList = new ArrayList<>(Arrays.asList(currcolumns));\r\n+        List<Integer> currvalList = new ArrayList<>(Arrays.asList(currvalues));\r\n+        int currvalueArrayposition = currcolList.indexOf(valueName);\r\n+        if (currvalueArrayposition == -1) {\r\n+            throw new GreeException(\"Unable to decode device status\");\r\n+        }\r\n+        // Now get the Corresponding value\r\n+        int currvalue = currvalList.get(currvalueArrayposition);\r\n+\r\n+        // Find the valueName in the Previous Status object\r\n+        String prevcolumns[] = prevStatusResponsePackGson.cols;\r\n+        Integer prevvalues[] = prevStatusResponsePackGson.dat;\r\n+        List<String> prevcolList = new ArrayList<>(Arrays.asList(prevcolumns));\r\n+        List<Integer> prevvalList = new ArrayList<>(Arrays.asList(prevvalues));\r\n+        int prevvalueArrayposition = prevcolList.indexOf(valueName);\r\n+        if (prevvalueArrayposition == -1) {\r\n+            throw new GreeException(\"Unable to get status value\");\r\n+        }\r\n+        // Now get the Corresponding value\r\n+        int prevvalue = prevvalList.get(prevvalueArrayposition);\r\n+\r\n+        // Finally Compare the values\r\n+        return currvalue != prevvalue;\r\n+    }\r\n+\r\n+    protected void executeCommand(DatagramSocket clientSocket, HashMap<String, Integer> parameters)\r\n+            throws GreeException {\r\n+        byte[] sendData = new byte[1024];\r\n+        byte[] receiveData = new byte[1024];\r\n+        Gson gson = new Gson();\r\n+\r\n+        try {\r\n+            // Convert the parameter map values to arrays\r\n+            String[] keyArray = parameters.keySet().toArray(new String[0]);\r\n+            Integer[] valueArray = parameters.values().toArray(new Integer[0]);\r\n+\r\n+            // Prep the Command Request pack\r\n+            GreeExecuteCommandPack4GsonDTO execCmdPackGson = new GreeExecuteCommandPack4GsonDTO();\r\n+            execCmdPackGson.opt = keyArray;\r\n+            execCmdPackGson.p = valueArray;\r\n+            execCmdPackGson.t = \"cmd\";\r\n+            String execCmdPackStr = gson.toJson(execCmdPackGson);\r\n+\r\n+            // Now Encrypt the Binding Request pack\r\n+            String encryptedCommandReqPacket = GreeCryptoUtil.encryptPack(getKey().getBytes(), execCmdPackStr);\r\n+            // String unencryptedCommandReqPacket = CryptoUtil.decryptPack(device.getKey().getBytes(),\r\n+            // encryptedCommandReqPacket);\r\n+\r\n+            // Prep the Command Request\r\n+            GreeExecCommand4GsonDTO execCmdGson = new GreeExecCommand4GsonDTO();\r\n+            execCmdGson.cid = \"app\";\r\n+            execCmdGson.i = 0;\r\n+            execCmdGson.t = \"pack\";\r\n+            execCmdGson.uid = 0;\r\n+            execCmdGson.tcid = getId();\r\n+            execCmdGson.pack = new String(encryptedCommandReqPacket.getBytes(), UTF8_CHARSET);\r\n+            String execCmdStr = gson.toJson(execCmdGson);\r\n+            sendData = execCmdStr.getBytes();\r\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\r\n+            clientSocket.send(sendPacket);\r\n+\r\n+            // Recieve a response\r\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\r\n+            clientSocket.receive(receivePacket);\r\n+            String modifiedSentence = new String(receivePacket.getData());\r\n+            // System.out.println(\"FROM SERVER:\" + modifiedSentence);\r\n+            // byte[] modifiedSentenceArray = receivePacket.getData();\r\n+\r\n+            // Read the response\r\n+            StringReader stringReader = new StringReader(modifiedSentence);\r\n+            GreeExecResponse4GsonDTO execResponseGson = gson.fromJson(new JsonReader(stringReader),\r\n+                    GreeExecResponse4GsonDTO.class);\r\n+            execResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(this.getKey().getBytes(),\r\n+                    execResponseGson.pack);\r\n+\r\n+            // Create the JSON to hold the response values\r\n+            stringReader = new StringReader(execResponseGson.decryptedPack);\r\n+            execResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeExecResponsePack4GsonDTO.class);\r\n+        } catch (IOException e) {\r\n+            throw new GreeException(e, \"Exception on command execution\");\r\n+        }\r\n+\r\n+    }\r\n+\r\n+    public void getDeviceStatus(DatagramSocket clientSocket) throws GreeException {\r\n+        Gson gson = new Gson();\r\n+        byte[] sendData = new byte[1024];\r\n+        byte[] receiveData = new byte[1024];\r\n+\r\n+        try {\r\n+            // Set the values in the HashMap\r\n+            ArrayList<String> columns = new ArrayList<>();\r\n+            columns.add(\"Pow\");\r\n+            columns.add(\"Mod\");\r\n+            columns.add(\"SetTem\");\r\n+            columns.add(\"WdSpd\");\r\n+            columns.add(\"Air\");\r\n+            columns.add(\"Blo\");\r\n+            columns.add(\"Health\");\r\n+            columns.add(\"SwhSlp\");\r\n+            columns.add(\"Lig\");\r\n+            columns.add(\"SwingLfRig\");\r\n+            columns.add(\"SwUpDn\");\r\n+            columns.add(\"Quiet\");\r\n+            columns.add(\"Tur\");\r\n+            columns.add(\"StHt\");\r\n+            columns.add(\"TemUn\");\r\n+            columns.add(\"HeatCoolType\");\r\n+            columns.add(\"TemRec\");\r\n+            columns.add(\"SvSt\");\r\n+            columns.add(\"NoiseSet\");\r\n+\r\n+            // Convert the parameter map values to arrays\r\n+            String[] colArray = columns.toArray(new String[0]);\r\n+\r\n+            // Prep the Command Request pack\r\n+            GreeReqStatusPack4GsonDTO reqStatusPackGson = new GreeReqStatusPack4GsonDTO();\r\n+            reqStatusPackGson.t = \"status\";\r\n+            reqStatusPackGson.cols = colArray;\r\n+            reqStatusPackGson.mac = getId();\r\n+            String reqStatusPackStr = gson.toJson(reqStatusPackGson);\r\n+\r\n+            // Now Encrypt the Binding Request pack\r\n+            String encryptedStatusReqPacket = GreeCryptoUtil.encryptPack(getKey().getBytes(), reqStatusPackStr);\r\n+\r\n+            // Prep the Status Request\r\n+            GreeReqStatus4GsonDTO reqStatusGson = new GreeReqStatus4GsonDTO();\r\n+            reqStatusGson.cid = \"app\";\r\n+            reqStatusGson.i = 0;\r\n+            reqStatusGson.t = \"pack\";\r\n+            reqStatusGson.uid = 0;\r\n+            reqStatusGson.tcid = getId();\r\n+            reqStatusGson.pack = new String(encryptedStatusReqPacket.getBytes(), UTF8_CHARSET);\r\n+            String execCmdStr = gson.toJson(reqStatusGson);\r\n+            sendData = execCmdStr.getBytes();\r\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\r\n+            clientSocket.send(sendPacket);\r\n+\r\n+            // Recieve a response\r\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\r\n+            clientSocket.receive(receivePacket);\r\n+            String modifiedSentence = new String(receivePacket.getData());\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 633}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MTE1OA==", "bodyText": "Apache Commons", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432881158", "createdAt": "2020-05-30T19:36:10Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeDeviceFinder.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal.discovery;\r\n+\r\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.StringReader;\r\n+import java.net.DatagramPacket;\r\n+import java.net.DatagramSocket;\r\n+import java.net.InetAddress;\r\n+import java.net.SocketTimeoutException;\r\n+import java.net.UnknownHostException;\r\n+import java.util.HashMap;\r\n+import java.util.Iterator;\r\n+import java.util.Optional;\r\n+import java.util.Set;\r\n+\r\n+import org.apache.commons.lang.Validate;\r\n+import org.eclipse.jdt.annotation.NonNullByDefault;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\r\n+import org.openhab.binding.gree.internal.GreeException;\r\n+import org.openhab.binding.gree.internal.gson.GreeScanReponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeScanRequest4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.GsonBuilder;\r\n+import com.google.gson.stream.JsonReader;\r\n+\r\n+/**\r\n+ * The GreeDeviceFinder provides functionality for searching for GREE Airconditioners on the network and keeping a list\r\n+ * of found devices.\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+@NonNullByDefault\r\n+public class GreeDeviceFinder {\r\n+    private final Logger logger = LoggerFactory.getLogger(GreeDeviceFinder.class);\r\n+\r\n+    protected final InetAddress mIPAddress;\r\n+    protected HashMap<String, GreeAirDevice> mDevicesHashMap = new HashMap<>();\r\n+\r\n+    public GreeDeviceFinder() {\r\n+        mIPAddress = InetAddress.getLoopbackAddress(); // dummy\r\n+    }\r\n+\r\n+    public GreeDeviceFinder(String broadcastAddress) throws UnknownHostException {\r\n+        mIPAddress = InetAddress.getByName(broadcastAddress);\r\n+    }\r\n+\r\n+    public void scan(Optional<DatagramSocket> socket, boolean scanNetwork) throws GreeException {\r\n+        Validate.isTrue(socket.isPresent());\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MTIxMg==", "bodyText": "Encoding", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432881212", "createdAt": "2020-05-30T19:37:09Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeDeviceFinder.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal.discovery;\r\n+\r\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.StringReader;\r\n+import java.net.DatagramPacket;\r\n+import java.net.DatagramSocket;\r\n+import java.net.InetAddress;\r\n+import java.net.SocketTimeoutException;\r\n+import java.net.UnknownHostException;\r\n+import java.util.HashMap;\r\n+import java.util.Iterator;\r\n+import java.util.Optional;\r\n+import java.util.Set;\r\n+\r\n+import org.apache.commons.lang.Validate;\r\n+import org.eclipse.jdt.annotation.NonNullByDefault;\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\r\n+import org.openhab.binding.gree.internal.GreeException;\r\n+import org.openhab.binding.gree.internal.gson.GreeScanReponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeScanRequest4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.GsonBuilder;\r\n+import com.google.gson.stream.JsonReader;\r\n+\r\n+/**\r\n+ * The GreeDeviceFinder provides functionality for searching for GREE Airconditioners on the network and keeping a list\r\n+ * of found devices.\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+@NonNullByDefault\r\n+public class GreeDeviceFinder {\r\n+    private final Logger logger = LoggerFactory.getLogger(GreeDeviceFinder.class);\r\n+\r\n+    protected final InetAddress mIPAddress;\r\n+    protected HashMap<String, GreeAirDevice> mDevicesHashMap = new HashMap<>();\r\n+\r\n+    public GreeDeviceFinder() {\r\n+        mIPAddress = InetAddress.getLoopbackAddress(); // dummy\r\n+    }\r\n+\r\n+    public GreeDeviceFinder(String broadcastAddress) throws UnknownHostException {\r\n+        mIPAddress = InetAddress.getByName(broadcastAddress);\r\n+    }\r\n+\r\n+    public void scan(Optional<DatagramSocket> socket, boolean scanNetwork) throws GreeException {\r\n+        Validate.isTrue(socket.isPresent());\r\n+        byte[] sendData = new byte[1024];\r\n+        byte[] receiveData = new byte[1024];\r\n+\r\n+        // Send the Scan message\r\n+        GreeScanRequest4GsonDTO scanGson = new GreeScanRequest4GsonDTO();\r\n+        scanGson.t = \"scan\";\r\n+\r\n+        GsonBuilder gsonBuilder = new GsonBuilder();\r\n+        Gson gson = gsonBuilder.create();\r\n+        String scanReq = gson.toJson(scanGson);\r\n+        sendData = scanReq.getBytes();\r\n+\r\n+        logger.trace(\"Sending scan packet to {}\", mIPAddress.getHostAddress());\r\n+        try {\r\n+            DatagramSocket clientSocket = socket.get();\r\n+            clientSocket.setSoTimeout(DISCOVERY_TIMEOUT_MS);\r\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, mIPAddress, DISCOVERY_TIMEOUT_MS);\r\n+            clientSocket.send(sendPacket);\r\n+\r\n+            // Loop for respnses from devices until we get a timeout.\r\n+            boolean scanning = true;\r\n+            int retries = MAX_SCAN_CYCLES;\r\n+            while (scanning && (retries > 0)) {\r\n+                // Receive a response\r\n+                DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\r\n+                try {\r\n+                    clientSocket.receive(receivePacket);\r\n+                    InetAddress remoteAddress = receivePacket.getAddress();\r\n+                    int remotePort = receivePacket.getPort();\r\n+\r\n+                    // Read the response\r\n+                    String modifiedSentence = new String(receivePacket.getData());\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MTQwMQ==", "bodyText": "Is there a reason why you don't make this an OSGi Component?", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432881401", "createdAt": "2020-05-30T19:40:11Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeDiscoveryService.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.gree.internal.discovery;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramSocket;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.osgi.framework.Bundle;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link GreeDiscoveryService} implements the device discovery service. UDP broadtcast ius used to find the devices on\n+ * the local subnet.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class GreeDiscoveryService extends AbstractDiscoveryService {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MTQyNg==", "bodyText": "Better specify the unit in the name.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final int TIMEOUT = 10;\n          \n          \n            \n                private static final int TIMEOUT_SEC = 10;", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432881426", "createdAt": "2020-05-30T19:40:33Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeDiscoveryService.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.gree.internal.discovery;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramSocket;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.osgi.framework.Bundle;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link GreeDiscoveryService} implements the device discovery service. UDP broadtcast ius used to find the devices on\n+ * the local subnet.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class GreeDiscoveryService extends AbstractDiscoveryService {\n+    private static final int TIMEOUT = 10;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MTUwMg==", "bodyText": "Does this method has any purpose?", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432881502", "createdAt": "2020-05-30T19:42:04Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeDiscoveryService.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.gree.internal.discovery;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramSocket;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.osgi.framework.Bundle;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link GreeDiscoveryService} implements the device discovery service. UDP broadtcast ius used to find the devices on\n+ * the local subnet.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class GreeDiscoveryService extends AbstractDiscoveryService {\n+    private static final int TIMEOUT = 10;\n+    private final Logger logger = LoggerFactory.getLogger(GreeDiscoveryService.class);\n+    private final GreeTranslationProvider messages;\n+    private final String broadcastAddress;\n+\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+\n+    public GreeDiscoveryService(Bundle bundle, GreeTranslationProvider messages, String broadcastAddress) {\n+        super(SUPPORTED_THING_TYPES_UIDS, TIMEOUT);\n+        this.messages = messages;\n+        this.broadcastAddress = !broadcastAddress.isEmpty() ? broadcastAddress : \"192.168.255.255\";\n+        logger.debug(\"Auto-detected broadcast IP = {}\", this.broadcastAddress);\n+    }\n+\n+    public void activate() {\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MTU0OQ==", "bodyText": "Can this message be replaced by using the debugger?", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432881549", "createdAt": "2020-05-30T19:42:38Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeDiscoveryService.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.gree.internal.discovery;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramSocket;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.osgi.framework.Bundle;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link GreeDiscoveryService} implements the device discovery service. UDP broadtcast ius used to find the devices on\n+ * the local subnet.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class GreeDiscoveryService extends AbstractDiscoveryService {\n+    private static final int TIMEOUT = 10;\n+    private final Logger logger = LoggerFactory.getLogger(GreeDiscoveryService.class);\n+    private final GreeTranslationProvider messages;\n+    private final String broadcastAddress;\n+\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+\n+    public GreeDiscoveryService(Bundle bundle, GreeTranslationProvider messages, String broadcastAddress) {\n+        super(SUPPORTED_THING_TYPES_UIDS, TIMEOUT);\n+        this.messages = messages;\n+        this.broadcastAddress = !broadcastAddress.isEmpty() ? broadcastAddress : \"192.168.255.255\";\n+        logger.debug(\"Auto-detected broadcast IP = {}\", this.broadcastAddress);\n+    }\n+\n+    public void activate() {\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.trace(\"Starting background scan\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MTU2Ng==", "bodyText": "See above", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432881566", "createdAt": "2020-05-30T19:42:46Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeDiscoveryService.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.gree.internal.discovery;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramSocket;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.osgi.framework.Bundle;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link GreeDiscoveryService} implements the device discovery service. UDP broadtcast ius used to find the devices on\n+ * the local subnet.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class GreeDiscoveryService extends AbstractDiscoveryService {\n+    private static final int TIMEOUT = 10;\n+    private final Logger logger = LoggerFactory.getLogger(GreeDiscoveryService.class);\n+    private final GreeTranslationProvider messages;\n+    private final String broadcastAddress;\n+\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+\n+    public GreeDiscoveryService(Bundle bundle, GreeTranslationProvider messages, String broadcastAddress) {\n+        super(SUPPORTED_THING_TYPES_UIDS, TIMEOUT);\n+        this.messages = messages;\n+        this.broadcastAddress = !broadcastAddress.isEmpty() ? broadcastAddress : \"192.168.255.255\";\n+        logger.debug(\"Auto-detected broadcast IP = {}\", this.broadcastAddress);\n+    }\n+\n+    public void activate() {\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.trace(\"Starting background scan\");\n+        startScan();\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        logger.trace(\"Stopping background scan\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MTczOQ==", "bodyText": "Should this be warn?", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432881739", "createdAt": "2020-05-30T19:45:10Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeDiscoveryService.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.gree.internal.discovery;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramSocket;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.osgi.framework.Bundle;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link GreeDiscoveryService} implements the device discovery service. UDP broadtcast ius used to find the devices on\n+ * the local subnet.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class GreeDiscoveryService extends AbstractDiscoveryService {\n+    private static final int TIMEOUT = 10;\n+    private final Logger logger = LoggerFactory.getLogger(GreeDiscoveryService.class);\n+    private final GreeTranslationProvider messages;\n+    private final String broadcastAddress;\n+\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+\n+    public GreeDiscoveryService(Bundle bundle, GreeTranslationProvider messages, String broadcastAddress) {\n+        super(SUPPORTED_THING_TYPES_UIDS, TIMEOUT);\n+        this.messages = messages;\n+        this.broadcastAddress = !broadcastAddress.isEmpty() ? broadcastAddress : \"192.168.255.255\";\n+        logger.debug(\"Auto-detected broadcast IP = {}\", this.broadcastAddress);\n+    }\n+\n+    public void activate() {\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.trace(\"Starting background scan\");\n+        startScan();\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        logger.trace(\"Stopping background scan\");\n+        stopScan();\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        Optional<DatagramSocket> clientSocket = Optional.empty();\n+        try {\n+            clientSocket = Optional.of(new DatagramSocket());\n+            deviceFinder = new GreeDeviceFinder(broadcastAddress);\n+            deviceFinder.scan(clientSocket, true);\n+\n+            int count = deviceFinder.getScannedDeviceCount();\n+            logger.info(\"{}\", messages.get(\"discovery.result\", count));\n+            if (count > 0) {\n+                logger.debug(\"Adding uinits to Inbox\");\n+                createResult(deviceFinder.getDevices());\n+            }\n+        } catch (IOException e) {\n+            logger.debug(\"{}\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MTc0Mw==", "bodyText": "Should this be warn?", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432881743", "createdAt": "2020-05-30T19:45:15Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeDiscoveryService.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.gree.internal.discovery;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramSocket;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.osgi.framework.Bundle;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link GreeDiscoveryService} implements the device discovery service. UDP broadtcast ius used to find the devices on\n+ * the local subnet.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class GreeDiscoveryService extends AbstractDiscoveryService {\n+    private static final int TIMEOUT = 10;\n+    private final Logger logger = LoggerFactory.getLogger(GreeDiscoveryService.class);\n+    private final GreeTranslationProvider messages;\n+    private final String broadcastAddress;\n+\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+\n+    public GreeDiscoveryService(Bundle bundle, GreeTranslationProvider messages, String broadcastAddress) {\n+        super(SUPPORTED_THING_TYPES_UIDS, TIMEOUT);\n+        this.messages = messages;\n+        this.broadcastAddress = !broadcastAddress.isEmpty() ? broadcastAddress : \"192.168.255.255\";\n+        logger.debug(\"Auto-detected broadcast IP = {}\", this.broadcastAddress);\n+    }\n+\n+    public void activate() {\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.trace(\"Starting background scan\");\n+        startScan();\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        logger.trace(\"Stopping background scan\");\n+        stopScan();\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        Optional<DatagramSocket> clientSocket = Optional.empty();\n+        try {\n+            clientSocket = Optional.of(new DatagramSocket());\n+            deviceFinder = new GreeDeviceFinder(broadcastAddress);\n+            deviceFinder.scan(clientSocket, true);\n+\n+            int count = deviceFinder.getScannedDeviceCount();\n+            logger.info(\"{}\", messages.get(\"discovery.result\", count));\n+            if (count > 0) {\n+                logger.debug(\"Adding uinits to Inbox\");\n+                createResult(deviceFinder.getDevices());\n+            }\n+        } catch (IOException e) {\n+            logger.debug(\"{}\",\n+                    new GreeException(e, \"I/O exception while scanning the network for GREE devices\").toString());\n+        } catch (GreeException e) {\n+            logger.debug(\"Discovery failed: {}\", e.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MTk0Mw==", "bodyText": "Can this be removed?", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432881943", "createdAt": "2020-05-30T19:48:51Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeHandler.java", "diffHunk": "@@ -0,0 +1,439 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.net.DatagramSocket;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.gree.internal.GreeConfiguration;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.discovery.GreeAirDevice;\n+import org.openhab.binding.gree.internal.discovery.GreeDeviceFinder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link GreeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(GreeHandler.class);\n+    private final GreeTranslationProvider messages;\n+    private GreeConfiguration config = new GreeConfiguration();\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+    private GreeAirDevice device = new GreeAirDevice();\n+    private Optional<DatagramSocket> clientSocket = Optional.empty();\n+\n+    private @Nullable ScheduledFuture<?> refreshTask;\n+    private long lastRefreshTime = 0;\n+\n+    public GreeHandler(Thing thing, GreeTranslationProvider messages) {\n+        super(thing);\n+        this.messages = messages;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // logger.debug(\"Start initializing!\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MTk1Mw==", "bodyText": "Should this be warn?", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432881953", "createdAt": "2020-05-30T19:49:16Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeHandler.java", "diffHunk": "@@ -0,0 +1,439 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.net.DatagramSocket;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.gree.internal.GreeConfiguration;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.discovery.GreeAirDevice;\n+import org.openhab.binding.gree.internal.discovery.GreeDeviceFinder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link GreeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(GreeHandler.class);\n+    private final GreeTranslationProvider messages;\n+    private GreeConfiguration config = new GreeConfiguration();\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+    private GreeAirDevice device = new GreeAirDevice();\n+    private Optional<DatagramSocket> clientSocket = Optional.empty();\n+\n+    private @Nullable ScheduledFuture<?> refreshTask;\n+    private long lastRefreshTime = 0;\n+\n+    public GreeHandler(Thing thing, GreeTranslationProvider messages) {\n+        super(thing);\n+        this.messages = messages;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // logger.debug(\"Start initializing!\");\n+        config = getConfigAs(GreeConfiguration.class);\n+        logger.debug(\"Config for {} is {}\", thing.getUID(), config.toString());\n+        if (config.ipAddress.isEmpty() || (config.refresh < 0)) {\n+            logger.debug(\"Config of {} is invalid. Check configuration\", thing.getUID());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MTk3MQ==", "bodyText": "Can this message be replaced by using the debugger?", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432881971", "createdAt": "2020-05-30T19:49:48Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeHandler.java", "diffHunk": "@@ -0,0 +1,439 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.net.DatagramSocket;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.gree.internal.GreeConfiguration;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.discovery.GreeAirDevice;\n+import org.openhab.binding.gree.internal.discovery.GreeDeviceFinder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link GreeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(GreeHandler.class);\n+    private final GreeTranslationProvider messages;\n+    private GreeConfiguration config = new GreeConfiguration();\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+    private GreeAirDevice device = new GreeAirDevice();\n+    private Optional<DatagramSocket> clientSocket = Optional.empty();\n+\n+    private @Nullable ScheduledFuture<?> refreshTask;\n+    private long lastRefreshTime = 0;\n+\n+    public GreeHandler(Thing thing, GreeTranslationProvider messages) {\n+        super(thing);\n+        this.messages = messages;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // logger.debug(\"Start initializing!\");\n+        config = getConfigAs(GreeConfiguration.class);\n+        logger.debug(\"Config for {} is {}\", thing.getUID(), config.toString());\n+        if (config.ipAddress.isEmpty() || (config.refresh < 0)) {\n+            logger.debug(\"Config of {} is invalid. Check configuration\", thing.getUID());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid configuration. Check thing configuration.\");\n+            return;\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.execute(() -> {\n+            initializeThing();\n+        });\n+    }\n+\n+    private void initializeThing() {\n+        logger.debug(\"Thing {} is initializing\", thing.getUID());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MjA1OQ==", "bodyText": "This code will never be reached.\nYou could work with a local variable to the new DatagramSocket to prevent using get() all the time.", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432882059", "createdAt": "2020-05-30T19:50:55Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeHandler.java", "diffHunk": "@@ -0,0 +1,439 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.net.DatagramSocket;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.gree.internal.GreeConfiguration;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.discovery.GreeAirDevice;\n+import org.openhab.binding.gree.internal.discovery.GreeDeviceFinder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link GreeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(GreeHandler.class);\n+    private final GreeTranslationProvider messages;\n+    private GreeConfiguration config = new GreeConfiguration();\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+    private GreeAirDevice device = new GreeAirDevice();\n+    private Optional<DatagramSocket> clientSocket = Optional.empty();\n+\n+    private @Nullable ScheduledFuture<?> refreshTask;\n+    private long lastRefreshTime = 0;\n+\n+    public GreeHandler(Thing thing, GreeTranslationProvider messages) {\n+        super(thing);\n+        this.messages = messages;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // logger.debug(\"Start initializing!\");\n+        config = getConfigAs(GreeConfiguration.class);\n+        logger.debug(\"Config for {} is {}\", thing.getUID(), config.toString());\n+        if (config.ipAddress.isEmpty() || (config.refresh < 0)) {\n+            logger.debug(\"Config of {} is invalid. Check configuration\", thing.getUID());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid configuration. Check thing configuration.\");\n+            return;\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.execute(() -> {\n+            initializeThing();\n+        });\n+    }\n+\n+    private void initializeThing() {\n+        logger.debug(\"Thing {} is initializing\", thing.getUID());\n+\n+        try {\n+            // Create a new Datagram socket with a specified timeout\n+            clientSocket = Optional.of(new DatagramSocket());\n+            if (!clientSocket.isPresent()) {\n+                logger.debug(\"Unable to create datagram socket, discovery aborted!\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MjI5NA==", "bodyText": "updateStatus() already logs a message. This message is redundant.", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432882294", "createdAt": "2020-05-30T19:54:42Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeHandler.java", "diffHunk": "@@ -0,0 +1,439 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.net.DatagramSocket;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.gree.internal.GreeConfiguration;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.discovery.GreeAirDevice;\n+import org.openhab.binding.gree.internal.discovery.GreeDeviceFinder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link GreeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(GreeHandler.class);\n+    private final GreeTranslationProvider messages;\n+    private GreeConfiguration config = new GreeConfiguration();\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+    private GreeAirDevice device = new GreeAirDevice();\n+    private Optional<DatagramSocket> clientSocket = Optional.empty();\n+\n+    private @Nullable ScheduledFuture<?> refreshTask;\n+    private long lastRefreshTime = 0;\n+\n+    public GreeHandler(Thing thing, GreeTranslationProvider messages) {\n+        super(thing);\n+        this.messages = messages;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // logger.debug(\"Start initializing!\");\n+        config = getConfigAs(GreeConfiguration.class);\n+        logger.debug(\"Config for {} is {}\", thing.getUID(), config.toString());\n+        if (config.ipAddress.isEmpty() || (config.refresh < 0)) {\n+            logger.debug(\"Config of {} is invalid. Check configuration\", thing.getUID());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid configuration. Check thing configuration.\");\n+            return;\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.execute(() -> {\n+            initializeThing();\n+        });\n+    }\n+\n+    private void initializeThing() {\n+        logger.debug(\"Thing {} is initializing\", thing.getUID());\n+\n+        try {\n+            // Create a new Datagram socket with a specified timeout\n+            clientSocket = Optional.of(new DatagramSocket());\n+            if (!clientSocket.isPresent()) {\n+                logger.debug(\"Unable to create datagram socket, discovery aborted!\");\n+                return;\n+            }\n+            clientSocket.get().setSoTimeout(DATAGRAM_SOCKET_TIMEOUT);\n+\n+            // Find the GREE device\n+            deviceFinder = new GreeDeviceFinder(config.ipAddress);\n+            deviceFinder.scan(clientSocket, false);\n+            logger.debug(\"{} units found matching IP address\", deviceFinder.getScannedDeviceCount());\n+\n+            // Now check that this one is amongst the air conditioners that responded.\n+            GreeAirDevice newDevice = deviceFinder.getDeviceByIPAddress(config.ipAddress);\n+            if (newDevice != null) {\n+                // Ok, our device responded, now let's Bind with it\n+                device = newDevice;\n+                device.bindWithDevice(clientSocket);\n+                if (device.getIsBound()) {\n+                    logger.debug(\"GREE AirConditioner {} bound successful\", thing.getUID());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MjM0OA==", "bodyText": "Should this be warn?", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432882348", "createdAt": "2020-05-30T19:55:34Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeHandler.java", "diffHunk": "@@ -0,0 +1,439 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.net.DatagramSocket;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.gree.internal.GreeConfiguration;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.discovery.GreeAirDevice;\n+import org.openhab.binding.gree.internal.discovery.GreeDeviceFinder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link GreeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(GreeHandler.class);\n+    private final GreeTranslationProvider messages;\n+    private GreeConfiguration config = new GreeConfiguration();\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+    private GreeAirDevice device = new GreeAirDevice();\n+    private Optional<DatagramSocket> clientSocket = Optional.empty();\n+\n+    private @Nullable ScheduledFuture<?> refreshTask;\n+    private long lastRefreshTime = 0;\n+\n+    public GreeHandler(Thing thing, GreeTranslationProvider messages) {\n+        super(thing);\n+        this.messages = messages;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // logger.debug(\"Start initializing!\");\n+        config = getConfigAs(GreeConfiguration.class);\n+        logger.debug(\"Config for {} is {}\", thing.getUID(), config.toString());\n+        if (config.ipAddress.isEmpty() || (config.refresh < 0)) {\n+            logger.debug(\"Config of {} is invalid. Check configuration\", thing.getUID());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid configuration. Check thing configuration.\");\n+            return;\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.execute(() -> {\n+            initializeThing();\n+        });\n+    }\n+\n+    private void initializeThing() {\n+        logger.debug(\"Thing {} is initializing\", thing.getUID());\n+\n+        try {\n+            // Create a new Datagram socket with a specified timeout\n+            clientSocket = Optional.of(new DatagramSocket());\n+            if (!clientSocket.isPresent()) {\n+                logger.debug(\"Unable to create datagram socket, discovery aborted!\");\n+                return;\n+            }\n+            clientSocket.get().setSoTimeout(DATAGRAM_SOCKET_TIMEOUT);\n+\n+            // Find the GREE device\n+            deviceFinder = new GreeDeviceFinder(config.ipAddress);\n+            deviceFinder.scan(clientSocket, false);\n+            logger.debug(\"{} units found matching IP address\", deviceFinder.getScannedDeviceCount());\n+\n+            // Now check that this one is amongst the air conditioners that responded.\n+            GreeAirDevice newDevice = deviceFinder.getDeviceByIPAddress(config.ipAddress);\n+            if (newDevice != null) {\n+                // Ok, our device responded, now let's Bind with it\n+                device = newDevice;\n+                device.bindWithDevice(clientSocket);\n+                if (device.getIsBound()) {\n+                    logger.debug(\"GREE AirConditioner {} bound successful\", thing.getUID());\n+                    updateStatus(ThingStatus.ONLINE);\n+\n+                    // Start the automatic refresh cycles\n+                    startAutomaticRefresh();\n+                    return;\n+                }\n+            }\n+            logger.debug(\"GREE unit is not responding\");\n+        } catch (GreeException e) {\n+            logger.debug(\"Initialization failed: {}\", messages.get(\"thinginit.exception\", e.toString()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MjM4MQ==", "bodyText": "Should this be warn?\nIs it necessary to log the stack trace here or can you log the exception's message instead?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.debug(\"Exception on inituialization\", e);\n          \n          \n            \n                        logger.debug(\"Exception on initialization\", e);", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432882381", "createdAt": "2020-05-30T19:55:57Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeHandler.java", "diffHunk": "@@ -0,0 +1,439 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.net.DatagramSocket;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.gree.internal.GreeConfiguration;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.discovery.GreeAirDevice;\n+import org.openhab.binding.gree.internal.discovery.GreeDeviceFinder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link GreeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(GreeHandler.class);\n+    private final GreeTranslationProvider messages;\n+    private GreeConfiguration config = new GreeConfiguration();\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+    private GreeAirDevice device = new GreeAirDevice();\n+    private Optional<DatagramSocket> clientSocket = Optional.empty();\n+\n+    private @Nullable ScheduledFuture<?> refreshTask;\n+    private long lastRefreshTime = 0;\n+\n+    public GreeHandler(Thing thing, GreeTranslationProvider messages) {\n+        super(thing);\n+        this.messages = messages;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // logger.debug(\"Start initializing!\");\n+        config = getConfigAs(GreeConfiguration.class);\n+        logger.debug(\"Config for {} is {}\", thing.getUID(), config.toString());\n+        if (config.ipAddress.isEmpty() || (config.refresh < 0)) {\n+            logger.debug(\"Config of {} is invalid. Check configuration\", thing.getUID());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid configuration. Check thing configuration.\");\n+            return;\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.execute(() -> {\n+            initializeThing();\n+        });\n+    }\n+\n+    private void initializeThing() {\n+        logger.debug(\"Thing {} is initializing\", thing.getUID());\n+\n+        try {\n+            // Create a new Datagram socket with a specified timeout\n+            clientSocket = Optional.of(new DatagramSocket());\n+            if (!clientSocket.isPresent()) {\n+                logger.debug(\"Unable to create datagram socket, discovery aborted!\");\n+                return;\n+            }\n+            clientSocket.get().setSoTimeout(DATAGRAM_SOCKET_TIMEOUT);\n+\n+            // Find the GREE device\n+            deviceFinder = new GreeDeviceFinder(config.ipAddress);\n+            deviceFinder.scan(clientSocket, false);\n+            logger.debug(\"{} units found matching IP address\", deviceFinder.getScannedDeviceCount());\n+\n+            // Now check that this one is amongst the air conditioners that responded.\n+            GreeAirDevice newDevice = deviceFinder.getDeviceByIPAddress(config.ipAddress);\n+            if (newDevice != null) {\n+                // Ok, our device responded, now let's Bind with it\n+                device = newDevice;\n+                device.bindWithDevice(clientSocket);\n+                if (device.getIsBound()) {\n+                    logger.debug(\"GREE AirConditioner {} bound successful\", thing.getUID());\n+                    updateStatus(ThingStatus.ONLINE);\n+\n+                    // Start the automatic refresh cycles\n+                    startAutomaticRefresh();\n+                    return;\n+                }\n+            }\n+            logger.debug(\"GREE unit is not responding\");\n+        } catch (GreeException e) {\n+            logger.debug(\"Initialization failed: {}\", messages.get(\"thinginit.exception\", e.toString()));\n+        } catch (IOException | RuntimeException e) {\n+            logger.debug(\"Exception on inituialization\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MjUxMg==", "bodyText": "Should this be warn?", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432882512", "createdAt": "2020-05-30T19:58:13Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeHandler.java", "diffHunk": "@@ -0,0 +1,439 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.net.DatagramSocket;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.gree.internal.GreeConfiguration;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.discovery.GreeAirDevice;\n+import org.openhab.binding.gree.internal.discovery.GreeDeviceFinder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link GreeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(GreeHandler.class);\n+    private final GreeTranslationProvider messages;\n+    private GreeConfiguration config = new GreeConfiguration();\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+    private GreeAirDevice device = new GreeAirDevice();\n+    private Optional<DatagramSocket> clientSocket = Optional.empty();\n+\n+    private @Nullable ScheduledFuture<?> refreshTask;\n+    private long lastRefreshTime = 0;\n+\n+    public GreeHandler(Thing thing, GreeTranslationProvider messages) {\n+        super(thing);\n+        this.messages = messages;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // logger.debug(\"Start initializing!\");\n+        config = getConfigAs(GreeConfiguration.class);\n+        logger.debug(\"Config for {} is {}\", thing.getUID(), config.toString());\n+        if (config.ipAddress.isEmpty() || (config.refresh < 0)) {\n+            logger.debug(\"Config of {} is invalid. Check configuration\", thing.getUID());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid configuration. Check thing configuration.\");\n+            return;\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.execute(() -> {\n+            initializeThing();\n+        });\n+    }\n+\n+    private void initializeThing() {\n+        logger.debug(\"Thing {} is initializing\", thing.getUID());\n+\n+        try {\n+            // Create a new Datagram socket with a specified timeout\n+            clientSocket = Optional.of(new DatagramSocket());\n+            if (!clientSocket.isPresent()) {\n+                logger.debug(\"Unable to create datagram socket, discovery aborted!\");\n+                return;\n+            }\n+            clientSocket.get().setSoTimeout(DATAGRAM_SOCKET_TIMEOUT);\n+\n+            // Find the GREE device\n+            deviceFinder = new GreeDeviceFinder(config.ipAddress);\n+            deviceFinder.scan(clientSocket, false);\n+            logger.debug(\"{} units found matching IP address\", deviceFinder.getScannedDeviceCount());\n+\n+            // Now check that this one is amongst the air conditioners that responded.\n+            GreeAirDevice newDevice = deviceFinder.getDeviceByIPAddress(config.ipAddress);\n+            if (newDevice != null) {\n+                // Ok, our device responded, now let's Bind with it\n+                device = newDevice;\n+                device.bindWithDevice(clientSocket);\n+                if (device.getIsBound()) {\n+                    logger.debug(\"GREE AirConditioner {} bound successful\", thing.getUID());\n+                    updateStatus(ThingStatus.ONLINE);\n+\n+                    // Start the automatic refresh cycles\n+                    startAutomaticRefresh();\n+                    return;\n+                }\n+            }\n+            logger.debug(\"GREE unit is not responding\");\n+        } catch (GreeException e) {\n+            logger.debug(\"Initialization failed: {}\", messages.get(\"thinginit.exception\", e.toString()));\n+        } catch (IOException | RuntimeException e) {\n+            logger.debug(\"Exception on inituialization\", e);\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            // The thing is updated by the scheduled automatic refresh so do nothing here.\n+        } else {\n+            if (!clientSocket.isPresent()) {\n+                logger.debug(\"Thing not properly initialized, abort command\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MjU2Nw==", "bodyText": "You should check here for the type with if(command instanceof OnOffType), because the user could also specify e.g. Dimmer. Same for below.", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432882567", "createdAt": "2020-05-30T19:59:24Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeHandler.java", "diffHunk": "@@ -0,0 +1,439 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.net.DatagramSocket;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.gree.internal.GreeConfiguration;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.discovery.GreeAirDevice;\n+import org.openhab.binding.gree.internal.discovery.GreeDeviceFinder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link GreeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(GreeHandler.class);\n+    private final GreeTranslationProvider messages;\n+    private GreeConfiguration config = new GreeConfiguration();\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+    private GreeAirDevice device = new GreeAirDevice();\n+    private Optional<DatagramSocket> clientSocket = Optional.empty();\n+\n+    private @Nullable ScheduledFuture<?> refreshTask;\n+    private long lastRefreshTime = 0;\n+\n+    public GreeHandler(Thing thing, GreeTranslationProvider messages) {\n+        super(thing);\n+        this.messages = messages;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // logger.debug(\"Start initializing!\");\n+        config = getConfigAs(GreeConfiguration.class);\n+        logger.debug(\"Config for {} is {}\", thing.getUID(), config.toString());\n+        if (config.ipAddress.isEmpty() || (config.refresh < 0)) {\n+            logger.debug(\"Config of {} is invalid. Check configuration\", thing.getUID());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid configuration. Check thing configuration.\");\n+            return;\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.execute(() -> {\n+            initializeThing();\n+        });\n+    }\n+\n+    private void initializeThing() {\n+        logger.debug(\"Thing {} is initializing\", thing.getUID());\n+\n+        try {\n+            // Create a new Datagram socket with a specified timeout\n+            clientSocket = Optional.of(new DatagramSocket());\n+            if (!clientSocket.isPresent()) {\n+                logger.debug(\"Unable to create datagram socket, discovery aborted!\");\n+                return;\n+            }\n+            clientSocket.get().setSoTimeout(DATAGRAM_SOCKET_TIMEOUT);\n+\n+            // Find the GREE device\n+            deviceFinder = new GreeDeviceFinder(config.ipAddress);\n+            deviceFinder.scan(clientSocket, false);\n+            logger.debug(\"{} units found matching IP address\", deviceFinder.getScannedDeviceCount());\n+\n+            // Now check that this one is amongst the air conditioners that responded.\n+            GreeAirDevice newDevice = deviceFinder.getDeviceByIPAddress(config.ipAddress);\n+            if (newDevice != null) {\n+                // Ok, our device responded, now let's Bind with it\n+                device = newDevice;\n+                device.bindWithDevice(clientSocket);\n+                if (device.getIsBound()) {\n+                    logger.debug(\"GREE AirConditioner {} bound successful\", thing.getUID());\n+                    updateStatus(ThingStatus.ONLINE);\n+\n+                    // Start the automatic refresh cycles\n+                    startAutomaticRefresh();\n+                    return;\n+                }\n+            }\n+            logger.debug(\"GREE unit is not responding\");\n+        } catch (GreeException e) {\n+            logger.debug(\"Initialization failed: {}\", messages.get(\"thinginit.exception\", e.toString()));\n+        } catch (IOException | RuntimeException e) {\n+            logger.debug(\"Exception on inituialization\", e);\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            // The thing is updated by the scheduled automatic refresh so do nothing here.\n+        } else {\n+            if (!clientSocket.isPresent()) {\n+                logger.debug(\"Thing not properly initialized, abort command\");\n+                return;\n+            }\n+\n+            DatagramSocket socket = clientSocket.get();\n+            logger.debug(\"Issue command {}\u00a0to channe {}\", command, channelUID.getIdWithoutGroup());\n+            try {\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case MODE_CHANNEL:\n+                        handleModeCommand(command, socket);\n+                        break;\n+                    case POWER_CHANNEL:\n+                        device.setDevicePower(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 156}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MjYzNA==", "bodyText": "See above", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432882634", "createdAt": "2020-05-30T20:00:12Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeHandler.java", "diffHunk": "@@ -0,0 +1,439 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.net.DatagramSocket;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.gree.internal.GreeConfiguration;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.discovery.GreeAirDevice;\n+import org.openhab.binding.gree.internal.discovery.GreeDeviceFinder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link GreeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(GreeHandler.class);\n+    private final GreeTranslationProvider messages;\n+    private GreeConfiguration config = new GreeConfiguration();\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+    private GreeAirDevice device = new GreeAirDevice();\n+    private Optional<DatagramSocket> clientSocket = Optional.empty();\n+\n+    private @Nullable ScheduledFuture<?> refreshTask;\n+    private long lastRefreshTime = 0;\n+\n+    public GreeHandler(Thing thing, GreeTranslationProvider messages) {\n+        super(thing);\n+        this.messages = messages;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // logger.debug(\"Start initializing!\");\n+        config = getConfigAs(GreeConfiguration.class);\n+        logger.debug(\"Config for {} is {}\", thing.getUID(), config.toString());\n+        if (config.ipAddress.isEmpty() || (config.refresh < 0)) {\n+            logger.debug(\"Config of {} is invalid. Check configuration\", thing.getUID());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid configuration. Check thing configuration.\");\n+            return;\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.execute(() -> {\n+            initializeThing();\n+        });\n+    }\n+\n+    private void initializeThing() {\n+        logger.debug(\"Thing {} is initializing\", thing.getUID());\n+\n+        try {\n+            // Create a new Datagram socket with a specified timeout\n+            clientSocket = Optional.of(new DatagramSocket());\n+            if (!clientSocket.isPresent()) {\n+                logger.debug(\"Unable to create datagram socket, discovery aborted!\");\n+                return;\n+            }\n+            clientSocket.get().setSoTimeout(DATAGRAM_SOCKET_TIMEOUT);\n+\n+            // Find the GREE device\n+            deviceFinder = new GreeDeviceFinder(config.ipAddress);\n+            deviceFinder.scan(clientSocket, false);\n+            logger.debug(\"{} units found matching IP address\", deviceFinder.getScannedDeviceCount());\n+\n+            // Now check that this one is amongst the air conditioners that responded.\n+            GreeAirDevice newDevice = deviceFinder.getDeviceByIPAddress(config.ipAddress);\n+            if (newDevice != null) {\n+                // Ok, our device responded, now let's Bind with it\n+                device = newDevice;\n+                device.bindWithDevice(clientSocket);\n+                if (device.getIsBound()) {\n+                    logger.debug(\"GREE AirConditioner {} bound successful\", thing.getUID());\n+                    updateStatus(ThingStatus.ONLINE);\n+\n+                    // Start the automatic refresh cycles\n+                    startAutomaticRefresh();\n+                    return;\n+                }\n+            }\n+            logger.debug(\"GREE unit is not responding\");\n+        } catch (GreeException e) {\n+            logger.debug(\"Initialization failed: {}\", messages.get(\"thinginit.exception\", e.toString()));\n+        } catch (IOException | RuntimeException e) {\n+            logger.debug(\"Exception on inituialization\", e);\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            // The thing is updated by the scheduled automatic refresh so do nothing here.\n+        } else {\n+            if (!clientSocket.isPresent()) {\n+                logger.debug(\"Thing not properly initialized, abort command\");\n+                return;\n+            }\n+\n+            DatagramSocket socket = clientSocket.get();\n+            logger.debug(\"Issue command {}\u00a0to channe {}\", command, channelUID.getIdWithoutGroup());\n+            try {\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case MODE_CHANNEL:\n+                        handleModeCommand(command, socket);\n+                        break;\n+                    case POWER_CHANNEL:\n+                        device.setDevicePower(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case TURBO_CHANNEL:\n+                        device.setDeviceTurbo(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case LIGHT_CHANNEL:\n+                        device.setDeviceLight(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case TEMP_CHANNEL:\n+                        device.setDeviceTempSet(socket, ((DecimalType) command).intValue());\n+                        break;\n+                    case SWINGV_CHANNEL:\n+                        device.setDeviceSwingVertical(socket, ((DecimalType) command).intValue());\n+                        break;\n+                    case WINDSPEED_CHANNEL:\n+                        device.setDeviceWindspeed(socket, ((DecimalType) command).intValue());\n+                        break;\n+                    case AIR_CHANNEL:\n+                        device.setDeviceAir(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case DRY_CHANNEL:\n+                        device.setDeviceDry(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case HEALTH_CHANNEL:\n+                        device.setDeviceHealth(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case PWRSAV_CHANNEL:\n+                        device.setDevicePwrSaving(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                }\n+            } catch (GreeException e) {\n+                logger.debug(\"Unable to execute command {}\u00a0for channel {}: {}\", command, channelUID.getId(),\n+                        e.toString());\n+            } catch (RuntimeException e) {\n+                logger.debug(\"Unable to execute command {}\u00a0for channel {}\", command, channelUID.getId(), e);\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 191}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MjcxOQ==", "bodyText": "See above", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432882719", "createdAt": "2020-05-30T20:01:23Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeHandler.java", "diffHunk": "@@ -0,0 +1,439 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.net.DatagramSocket;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.gree.internal.GreeConfiguration;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.discovery.GreeAirDevice;\n+import org.openhab.binding.gree.internal.discovery.GreeDeviceFinder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link GreeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(GreeHandler.class);\n+    private final GreeTranslationProvider messages;\n+    private GreeConfiguration config = new GreeConfiguration();\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+    private GreeAirDevice device = new GreeAirDevice();\n+    private Optional<DatagramSocket> clientSocket = Optional.empty();\n+\n+    private @Nullable ScheduledFuture<?> refreshTask;\n+    private long lastRefreshTime = 0;\n+\n+    public GreeHandler(Thing thing, GreeTranslationProvider messages) {\n+        super(thing);\n+        this.messages = messages;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // logger.debug(\"Start initializing!\");\n+        config = getConfigAs(GreeConfiguration.class);\n+        logger.debug(\"Config for {} is {}\", thing.getUID(), config.toString());\n+        if (config.ipAddress.isEmpty() || (config.refresh < 0)) {\n+            logger.debug(\"Config of {} is invalid. Check configuration\", thing.getUID());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid configuration. Check thing configuration.\");\n+            return;\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.execute(() -> {\n+            initializeThing();\n+        });\n+    }\n+\n+    private void initializeThing() {\n+        logger.debug(\"Thing {} is initializing\", thing.getUID());\n+\n+        try {\n+            // Create a new Datagram socket with a specified timeout\n+            clientSocket = Optional.of(new DatagramSocket());\n+            if (!clientSocket.isPresent()) {\n+                logger.debug(\"Unable to create datagram socket, discovery aborted!\");\n+                return;\n+            }\n+            clientSocket.get().setSoTimeout(DATAGRAM_SOCKET_TIMEOUT);\n+\n+            // Find the GREE device\n+            deviceFinder = new GreeDeviceFinder(config.ipAddress);\n+            deviceFinder.scan(clientSocket, false);\n+            logger.debug(\"{} units found matching IP address\", deviceFinder.getScannedDeviceCount());\n+\n+            // Now check that this one is amongst the air conditioners that responded.\n+            GreeAirDevice newDevice = deviceFinder.getDeviceByIPAddress(config.ipAddress);\n+            if (newDevice != null) {\n+                // Ok, our device responded, now let's Bind with it\n+                device = newDevice;\n+                device.bindWithDevice(clientSocket);\n+                if (device.getIsBound()) {\n+                    logger.debug(\"GREE AirConditioner {} bound successful\", thing.getUID());\n+                    updateStatus(ThingStatus.ONLINE);\n+\n+                    // Start the automatic refresh cycles\n+                    startAutomaticRefresh();\n+                    return;\n+                }\n+            }\n+            logger.debug(\"GREE unit is not responding\");\n+        } catch (GreeException e) {\n+            logger.debug(\"Initialization failed: {}\", messages.get(\"thinginit.exception\", e.toString()));\n+        } catch (IOException | RuntimeException e) {\n+            logger.debug(\"Exception on inituialization\", e);\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            // The thing is updated by the scheduled automatic refresh so do nothing here.\n+        } else {\n+            if (!clientSocket.isPresent()) {\n+                logger.debug(\"Thing not properly initialized, abort command\");\n+                return;\n+            }\n+\n+            DatagramSocket socket = clientSocket.get();\n+            logger.debug(\"Issue command {}\u00a0to channe {}\", command, channelUID.getIdWithoutGroup());\n+            try {\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case MODE_CHANNEL:\n+                        handleModeCommand(command, socket);\n+                        break;\n+                    case POWER_CHANNEL:\n+                        device.setDevicePower(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case TURBO_CHANNEL:\n+                        device.setDeviceTurbo(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case LIGHT_CHANNEL:\n+                        device.setDeviceLight(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case TEMP_CHANNEL:\n+                        device.setDeviceTempSet(socket, ((DecimalType) command).intValue());\n+                        break;\n+                    case SWINGV_CHANNEL:\n+                        device.setDeviceSwingVertical(socket, ((DecimalType) command).intValue());\n+                        break;\n+                    case WINDSPEED_CHANNEL:\n+                        device.setDeviceWindspeed(socket, ((DecimalType) command).intValue());\n+                        break;\n+                    case AIR_CHANNEL:\n+                        device.setDeviceAir(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case DRY_CHANNEL:\n+                        device.setDeviceDry(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case HEALTH_CHANNEL:\n+                        device.setDeviceHealth(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case PWRSAV_CHANNEL:\n+                        device.setDevicePwrSaving(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                }\n+            } catch (GreeException e) {\n+                logger.debug(\"Unable to execute command {}\u00a0for channel {}: {}\", command, channelUID.getId(),\n+                        e.toString());\n+            } catch (RuntimeException e) {\n+                logger.debug(\"Unable to execute command {}\u00a0for channel {}\", command, channelUID.getId(), e);\n+            }\n+        }\n+    }\n+\n+    private void handleModeCommand(Command command, DatagramSocket socket) throws GreeException {\n+        int mode = -1;\n+        String modeStr = \"\";\n+        boolean isNumber = StringUtils.isNumeric(command.toString());\n+        if (command instanceof DecimalType) {\n+            // backward compatibility when channel was Number\n+            mode = ((DecimalType) command).intValue();\n+        } else if (command instanceof OnOffType) {\n+            // Switch\n+            logger.debug(\"Send Power-{}\", command);\n+            device.setDevicePower(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+        } else /* String */ {\n+            modeStr = command.toString().toLowerCase();\n+            switch (modeStr) {\n+                case MODE_AUTO:\n+                    mode = GREE_MODE_AUTO;\n+                    break;\n+                case MODE_COOL:\n+                    mode = GREE_MODE_COOL;\n+                    break;\n+                case MODE_HEAT:\n+                    mode = GREE_MODE_HEAT;\n+                    break;\n+                case MODE_DRY:\n+                    mode = GREE_MODE_DRY;\n+                    break;\n+                case MODE_FAN:\n+                case MODE_FAN2:\n+                    mode = GREE_MODE_FAN;\n+                    break;\n+                case MODE_ECO:\n+                    // power saving will be set after the uinit was turned on\n+                    mode = GREE_MODE_COOL;\n+                    break;\n+                case MODE_ON:\n+                case MODE_OFF:\n+                    device.setDevicePower(socket, modeStr.equals(MODE_ON) ? 1 : 0);\n+                    break;\n+                default:\n+                    if (isNumber) {\n+                        // Support selecting the mode by number, maybe specific models support\n+                        // additional modes\n+                        mode = Integer.parseInt(modeStr);\n+                    } else {\n+                        logger.debug(\"Invalid mode requested: {}\", command);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 239}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MjcyOQ==", "bodyText": "Apache Commons", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432882729", "createdAt": "2020-05-30T20:01:33Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeHandler.java", "diffHunk": "@@ -0,0 +1,439 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.net.DatagramSocket;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.gree.internal.GreeConfiguration;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.discovery.GreeAirDevice;\n+import org.openhab.binding.gree.internal.discovery.GreeDeviceFinder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link GreeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(GreeHandler.class);\n+    private final GreeTranslationProvider messages;\n+    private GreeConfiguration config = new GreeConfiguration();\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+    private GreeAirDevice device = new GreeAirDevice();\n+    private Optional<DatagramSocket> clientSocket = Optional.empty();\n+\n+    private @Nullable ScheduledFuture<?> refreshTask;\n+    private long lastRefreshTime = 0;\n+\n+    public GreeHandler(Thing thing, GreeTranslationProvider messages) {\n+        super(thing);\n+        this.messages = messages;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // logger.debug(\"Start initializing!\");\n+        config = getConfigAs(GreeConfiguration.class);\n+        logger.debug(\"Config for {} is {}\", thing.getUID(), config.toString());\n+        if (config.ipAddress.isEmpty() || (config.refresh < 0)) {\n+            logger.debug(\"Config of {} is invalid. Check configuration\", thing.getUID());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid configuration. Check thing configuration.\");\n+            return;\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.execute(() -> {\n+            initializeThing();\n+        });\n+    }\n+\n+    private void initializeThing() {\n+        logger.debug(\"Thing {} is initializing\", thing.getUID());\n+\n+        try {\n+            // Create a new Datagram socket with a specified timeout\n+            clientSocket = Optional.of(new DatagramSocket());\n+            if (!clientSocket.isPresent()) {\n+                logger.debug(\"Unable to create datagram socket, discovery aborted!\");\n+                return;\n+            }\n+            clientSocket.get().setSoTimeout(DATAGRAM_SOCKET_TIMEOUT);\n+\n+            // Find the GREE device\n+            deviceFinder = new GreeDeviceFinder(config.ipAddress);\n+            deviceFinder.scan(clientSocket, false);\n+            logger.debug(\"{} units found matching IP address\", deviceFinder.getScannedDeviceCount());\n+\n+            // Now check that this one is amongst the air conditioners that responded.\n+            GreeAirDevice newDevice = deviceFinder.getDeviceByIPAddress(config.ipAddress);\n+            if (newDevice != null) {\n+                // Ok, our device responded, now let's Bind with it\n+                device = newDevice;\n+                device.bindWithDevice(clientSocket);\n+                if (device.getIsBound()) {\n+                    logger.debug(\"GREE AirConditioner {} bound successful\", thing.getUID());\n+                    updateStatus(ThingStatus.ONLINE);\n+\n+                    // Start the automatic refresh cycles\n+                    startAutomaticRefresh();\n+                    return;\n+                }\n+            }\n+            logger.debug(\"GREE unit is not responding\");\n+        } catch (GreeException e) {\n+            logger.debug(\"Initialization failed: {}\", messages.get(\"thinginit.exception\", e.toString()));\n+        } catch (IOException | RuntimeException e) {\n+            logger.debug(\"Exception on inituialization\", e);\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            // The thing is updated by the scheduled automatic refresh so do nothing here.\n+        } else {\n+            if (!clientSocket.isPresent()) {\n+                logger.debug(\"Thing not properly initialized, abort command\");\n+                return;\n+            }\n+\n+            DatagramSocket socket = clientSocket.get();\n+            logger.debug(\"Issue command {}\u00a0to channe {}\", command, channelUID.getIdWithoutGroup());\n+            try {\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case MODE_CHANNEL:\n+                        handleModeCommand(command, socket);\n+                        break;\n+                    case POWER_CHANNEL:\n+                        device.setDevicePower(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case TURBO_CHANNEL:\n+                        device.setDeviceTurbo(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case LIGHT_CHANNEL:\n+                        device.setDeviceLight(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case TEMP_CHANNEL:\n+                        device.setDeviceTempSet(socket, ((DecimalType) command).intValue());\n+                        break;\n+                    case SWINGV_CHANNEL:\n+                        device.setDeviceSwingVertical(socket, ((DecimalType) command).intValue());\n+                        break;\n+                    case WINDSPEED_CHANNEL:\n+                        device.setDeviceWindspeed(socket, ((DecimalType) command).intValue());\n+                        break;\n+                    case AIR_CHANNEL:\n+                        device.setDeviceAir(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case DRY_CHANNEL:\n+                        device.setDeviceDry(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case HEALTH_CHANNEL:\n+                        device.setDeviceHealth(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case PWRSAV_CHANNEL:\n+                        device.setDevicePwrSaving(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                }\n+            } catch (GreeException e) {\n+                logger.debug(\"Unable to execute command {}\u00a0for channel {}: {}\", command, channelUID.getId(),\n+                        e.toString());\n+            } catch (RuntimeException e) {\n+                logger.debug(\"Unable to execute command {}\u00a0for channel {}\", command, channelUID.getId(), e);\n+            }\n+        }\n+    }\n+\n+    private void handleModeCommand(Command command, DatagramSocket socket) throws GreeException {\n+        int mode = -1;\n+        String modeStr = \"\";\n+        boolean isNumber = StringUtils.isNumeric(command.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 198}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4Mjg1MQ==", "bodyText": "Can this be replaced by using the debugger?", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432882851", "createdAt": "2020-05-30T20:03:34Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeHandler.java", "diffHunk": "@@ -0,0 +1,439 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.net.DatagramSocket;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.gree.internal.GreeConfiguration;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.discovery.GreeAirDevice;\n+import org.openhab.binding.gree.internal.discovery.GreeDeviceFinder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link GreeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(GreeHandler.class);\n+    private final GreeTranslationProvider messages;\n+    private GreeConfiguration config = new GreeConfiguration();\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+    private GreeAirDevice device = new GreeAirDevice();\n+    private Optional<DatagramSocket> clientSocket = Optional.empty();\n+\n+    private @Nullable ScheduledFuture<?> refreshTask;\n+    private long lastRefreshTime = 0;\n+\n+    public GreeHandler(Thing thing, GreeTranslationProvider messages) {\n+        super(thing);\n+        this.messages = messages;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // logger.debug(\"Start initializing!\");\n+        config = getConfigAs(GreeConfiguration.class);\n+        logger.debug(\"Config for {} is {}\", thing.getUID(), config.toString());\n+        if (config.ipAddress.isEmpty() || (config.refresh < 0)) {\n+            logger.debug(\"Config of {} is invalid. Check configuration\", thing.getUID());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid configuration. Check thing configuration.\");\n+            return;\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.execute(() -> {\n+            initializeThing();\n+        });\n+    }\n+\n+    private void initializeThing() {\n+        logger.debug(\"Thing {} is initializing\", thing.getUID());\n+\n+        try {\n+            // Create a new Datagram socket with a specified timeout\n+            clientSocket = Optional.of(new DatagramSocket());\n+            if (!clientSocket.isPresent()) {\n+                logger.debug(\"Unable to create datagram socket, discovery aborted!\");\n+                return;\n+            }\n+            clientSocket.get().setSoTimeout(DATAGRAM_SOCKET_TIMEOUT);\n+\n+            // Find the GREE device\n+            deviceFinder = new GreeDeviceFinder(config.ipAddress);\n+            deviceFinder.scan(clientSocket, false);\n+            logger.debug(\"{} units found matching IP address\", deviceFinder.getScannedDeviceCount());\n+\n+            // Now check that this one is amongst the air conditioners that responded.\n+            GreeAirDevice newDevice = deviceFinder.getDeviceByIPAddress(config.ipAddress);\n+            if (newDevice != null) {\n+                // Ok, our device responded, now let's Bind with it\n+                device = newDevice;\n+                device.bindWithDevice(clientSocket);\n+                if (device.getIsBound()) {\n+                    logger.debug(\"GREE AirConditioner {} bound successful\", thing.getUID());\n+                    updateStatus(ThingStatus.ONLINE);\n+\n+                    // Start the automatic refresh cycles\n+                    startAutomaticRefresh();\n+                    return;\n+                }\n+            }\n+            logger.debug(\"GREE unit is not responding\");\n+        } catch (GreeException e) {\n+            logger.debug(\"Initialization failed: {}\", messages.get(\"thinginit.exception\", e.toString()));\n+        } catch (IOException | RuntimeException e) {\n+            logger.debug(\"Exception on inituialization\", e);\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            // The thing is updated by the scheduled automatic refresh so do nothing here.\n+        } else {\n+            if (!clientSocket.isPresent()) {\n+                logger.debug(\"Thing not properly initialized, abort command\");\n+                return;\n+            }\n+\n+            DatagramSocket socket = clientSocket.get();\n+            logger.debug(\"Issue command {}\u00a0to channe {}\", command, channelUID.getIdWithoutGroup());\n+            try {\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case MODE_CHANNEL:\n+                        handleModeCommand(command, socket);\n+                        break;\n+                    case POWER_CHANNEL:\n+                        device.setDevicePower(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case TURBO_CHANNEL:\n+                        device.setDeviceTurbo(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case LIGHT_CHANNEL:\n+                        device.setDeviceLight(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case TEMP_CHANNEL:\n+                        device.setDeviceTempSet(socket, ((DecimalType) command).intValue());\n+                        break;\n+                    case SWINGV_CHANNEL:\n+                        device.setDeviceSwingVertical(socket, ((DecimalType) command).intValue());\n+                        break;\n+                    case WINDSPEED_CHANNEL:\n+                        device.setDeviceWindspeed(socket, ((DecimalType) command).intValue());\n+                        break;\n+                    case AIR_CHANNEL:\n+                        device.setDeviceAir(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case DRY_CHANNEL:\n+                        device.setDeviceDry(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case HEALTH_CHANNEL:\n+                        device.setDeviceHealth(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case PWRSAV_CHANNEL:\n+                        device.setDevicePwrSaving(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                }\n+            } catch (GreeException e) {\n+                logger.debug(\"Unable to execute command {}\u00a0for channel {}: {}\", command, channelUID.getId(),\n+                        e.toString());\n+            } catch (RuntimeException e) {\n+                logger.debug(\"Unable to execute command {}\u00a0for channel {}\", command, channelUID.getId(), e);\n+            }\n+        }\n+    }\n+\n+    private void handleModeCommand(Command command, DatagramSocket socket) throws GreeException {\n+        int mode = -1;\n+        String modeStr = \"\";\n+        boolean isNumber = StringUtils.isNumeric(command.toString());\n+        if (command instanceof DecimalType) {\n+            // backward compatibility when channel was Number\n+            mode = ((DecimalType) command).intValue();\n+        } else if (command instanceof OnOffType) {\n+            // Switch\n+            logger.debug(\"Send Power-{}\", command);\n+            device.setDevicePower(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+        } else /* String */ {\n+            modeStr = command.toString().toLowerCase();\n+            switch (modeStr) {\n+                case MODE_AUTO:\n+                    mode = GREE_MODE_AUTO;\n+                    break;\n+                case MODE_COOL:\n+                    mode = GREE_MODE_COOL;\n+                    break;\n+                case MODE_HEAT:\n+                    mode = GREE_MODE_HEAT;\n+                    break;\n+                case MODE_DRY:\n+                    mode = GREE_MODE_DRY;\n+                    break;\n+                case MODE_FAN:\n+                case MODE_FAN2:\n+                    mode = GREE_MODE_FAN;\n+                    break;\n+                case MODE_ECO:\n+                    // power saving will be set after the uinit was turned on\n+                    mode = GREE_MODE_COOL;\n+                    break;\n+                case MODE_ON:\n+                case MODE_OFF:\n+                    device.setDevicePower(socket, modeStr.equals(MODE_ON) ? 1 : 0);\n+                    break;\n+                default:\n+                    if (isNumber) {\n+                        // Support selecting the mode by number, maybe specific models support\n+                        // additional modes\n+                        mode = Integer.parseInt(modeStr);\n+                    } else {\n+                        logger.debug(\"Invalid mode requested: {}\", command);\n+                    }\n+                    break;\n+            }\n+            logger.debug(\"Mode {} mapped to {}\", modeStr, mode);\n+        }\n+\n+        if (mode != -1) {\n+            // Turn on the unit if currently off\n+            if (!isNumber && (device.getIntStatusVal(\"Pow\") == 0)) {\n+                logger.debug(\"Send Auto-ON for mode {}\", mode);\n+                device.setDevicePower(socket, 1);\n+            }\n+\n+            // Select mode\n+            logger.debug(\"Select mode {}\", mode);\n+            device.SetDeviceMode(socket, mode);\n+\n+            // Check for secondary action\n+            switch (modeStr) {\n+                case MODE_ECO:\n+                    // Turn on power saving for eco mode\n+                    logger.debug(\"Turn on Power-Saving\");\n+                    device.setDevicePwrSaving(socket, 1);\n+                    break;\n+                case MODE_TURBO:\n+                    device.setDeviceTurbo(socket, 1);\n+                    break;\n+            }\n+        }\n+    }\n+\n+    private boolean isMinimumRefreshTimeExceeded() {\n+        long currentTime = System.currentTimeMillis();\n+        long timeSinceLastRefresh = currentTime - lastRefreshTime;\n+        if (timeSinceLastRefresh < MINIMUM_REFRESH_TIME_MS) {\n+            return false;\n+        }\n+        lastRefreshTime = currentTime;\n+        return true;\n+    }\n+\n+    private void startAutomaticRefresh() {\n+\n+        Runnable refresher = new Runnable() {\n+            @Override\n+            public void run() {\n+\n+                try {\n+                    logger.debug(\"Executing automatic update of values\");\n+                    // safeguard for multiple REFRESH commands\n+                    if (isMinimumRefreshTimeExceeded()) {\n+                        logger.debug(\"Fetching status values from device.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 291}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4Mjg2OA==", "bodyText": "Should this be warn?\nWhat happens with the other exception causes?", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432882868", "createdAt": "2020-05-30T20:03:49Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeHandler.java", "diffHunk": "@@ -0,0 +1,439 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.net.DatagramSocket;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.gree.internal.GreeConfiguration;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.discovery.GreeAirDevice;\n+import org.openhab.binding.gree.internal.discovery.GreeDeviceFinder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link GreeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(GreeHandler.class);\n+    private final GreeTranslationProvider messages;\n+    private GreeConfiguration config = new GreeConfiguration();\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+    private GreeAirDevice device = new GreeAirDevice();\n+    private Optional<DatagramSocket> clientSocket = Optional.empty();\n+\n+    private @Nullable ScheduledFuture<?> refreshTask;\n+    private long lastRefreshTime = 0;\n+\n+    public GreeHandler(Thing thing, GreeTranslationProvider messages) {\n+        super(thing);\n+        this.messages = messages;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // logger.debug(\"Start initializing!\");\n+        config = getConfigAs(GreeConfiguration.class);\n+        logger.debug(\"Config for {} is {}\", thing.getUID(), config.toString());\n+        if (config.ipAddress.isEmpty() || (config.refresh < 0)) {\n+            logger.debug(\"Config of {} is invalid. Check configuration\", thing.getUID());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid configuration. Check thing configuration.\");\n+            return;\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.execute(() -> {\n+            initializeThing();\n+        });\n+    }\n+\n+    private void initializeThing() {\n+        logger.debug(\"Thing {} is initializing\", thing.getUID());\n+\n+        try {\n+            // Create a new Datagram socket with a specified timeout\n+            clientSocket = Optional.of(new DatagramSocket());\n+            if (!clientSocket.isPresent()) {\n+                logger.debug(\"Unable to create datagram socket, discovery aborted!\");\n+                return;\n+            }\n+            clientSocket.get().setSoTimeout(DATAGRAM_SOCKET_TIMEOUT);\n+\n+            // Find the GREE device\n+            deviceFinder = new GreeDeviceFinder(config.ipAddress);\n+            deviceFinder.scan(clientSocket, false);\n+            logger.debug(\"{} units found matching IP address\", deviceFinder.getScannedDeviceCount());\n+\n+            // Now check that this one is amongst the air conditioners that responded.\n+            GreeAirDevice newDevice = deviceFinder.getDeviceByIPAddress(config.ipAddress);\n+            if (newDevice != null) {\n+                // Ok, our device responded, now let's Bind with it\n+                device = newDevice;\n+                device.bindWithDevice(clientSocket);\n+                if (device.getIsBound()) {\n+                    logger.debug(\"GREE AirConditioner {} bound successful\", thing.getUID());\n+                    updateStatus(ThingStatus.ONLINE);\n+\n+                    // Start the automatic refresh cycles\n+                    startAutomaticRefresh();\n+                    return;\n+                }\n+            }\n+            logger.debug(\"GREE unit is not responding\");\n+        } catch (GreeException e) {\n+            logger.debug(\"Initialization failed: {}\", messages.get(\"thinginit.exception\", e.toString()));\n+        } catch (IOException | RuntimeException e) {\n+            logger.debug(\"Exception on inituialization\", e);\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            // The thing is updated by the scheduled automatic refresh so do nothing here.\n+        } else {\n+            if (!clientSocket.isPresent()) {\n+                logger.debug(\"Thing not properly initialized, abort command\");\n+                return;\n+            }\n+\n+            DatagramSocket socket = clientSocket.get();\n+            logger.debug(\"Issue command {}\u00a0to channe {}\", command, channelUID.getIdWithoutGroup());\n+            try {\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case MODE_CHANNEL:\n+                        handleModeCommand(command, socket);\n+                        break;\n+                    case POWER_CHANNEL:\n+                        device.setDevicePower(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case TURBO_CHANNEL:\n+                        device.setDeviceTurbo(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case LIGHT_CHANNEL:\n+                        device.setDeviceLight(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case TEMP_CHANNEL:\n+                        device.setDeviceTempSet(socket, ((DecimalType) command).intValue());\n+                        break;\n+                    case SWINGV_CHANNEL:\n+                        device.setDeviceSwingVertical(socket, ((DecimalType) command).intValue());\n+                        break;\n+                    case WINDSPEED_CHANNEL:\n+                        device.setDeviceWindspeed(socket, ((DecimalType) command).intValue());\n+                        break;\n+                    case AIR_CHANNEL:\n+                        device.setDeviceAir(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case DRY_CHANNEL:\n+                        device.setDeviceDry(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case HEALTH_CHANNEL:\n+                        device.setDeviceHealth(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case PWRSAV_CHANNEL:\n+                        device.setDevicePwrSaving(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                }\n+            } catch (GreeException e) {\n+                logger.debug(\"Unable to execute command {}\u00a0for channel {}: {}\", command, channelUID.getId(),\n+                        e.toString());\n+            } catch (RuntimeException e) {\n+                logger.debug(\"Unable to execute command {}\u00a0for channel {}\", command, channelUID.getId(), e);\n+            }\n+        }\n+    }\n+\n+    private void handleModeCommand(Command command, DatagramSocket socket) throws GreeException {\n+        int mode = -1;\n+        String modeStr = \"\";\n+        boolean isNumber = StringUtils.isNumeric(command.toString());\n+        if (command instanceof DecimalType) {\n+            // backward compatibility when channel was Number\n+            mode = ((DecimalType) command).intValue();\n+        } else if (command instanceof OnOffType) {\n+            // Switch\n+            logger.debug(\"Send Power-{}\", command);\n+            device.setDevicePower(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+        } else /* String */ {\n+            modeStr = command.toString().toLowerCase();\n+            switch (modeStr) {\n+                case MODE_AUTO:\n+                    mode = GREE_MODE_AUTO;\n+                    break;\n+                case MODE_COOL:\n+                    mode = GREE_MODE_COOL;\n+                    break;\n+                case MODE_HEAT:\n+                    mode = GREE_MODE_HEAT;\n+                    break;\n+                case MODE_DRY:\n+                    mode = GREE_MODE_DRY;\n+                    break;\n+                case MODE_FAN:\n+                case MODE_FAN2:\n+                    mode = GREE_MODE_FAN;\n+                    break;\n+                case MODE_ECO:\n+                    // power saving will be set after the uinit was turned on\n+                    mode = GREE_MODE_COOL;\n+                    break;\n+                case MODE_ON:\n+                case MODE_OFF:\n+                    device.setDevicePower(socket, modeStr.equals(MODE_ON) ? 1 : 0);\n+                    break;\n+                default:\n+                    if (isNumber) {\n+                        // Support selecting the mode by number, maybe specific models support\n+                        // additional modes\n+                        mode = Integer.parseInt(modeStr);\n+                    } else {\n+                        logger.debug(\"Invalid mode requested: {}\", command);\n+                    }\n+                    break;\n+            }\n+            logger.debug(\"Mode {} mapped to {}\", modeStr, mode);\n+        }\n+\n+        if (mode != -1) {\n+            // Turn on the unit if currently off\n+            if (!isNumber && (device.getIntStatusVal(\"Pow\") == 0)) {\n+                logger.debug(\"Send Auto-ON for mode {}\", mode);\n+                device.setDevicePower(socket, 1);\n+            }\n+\n+            // Select mode\n+            logger.debug(\"Select mode {}\", mode);\n+            device.SetDeviceMode(socket, mode);\n+\n+            // Check for secondary action\n+            switch (modeStr) {\n+                case MODE_ECO:\n+                    // Turn on power saving for eco mode\n+                    logger.debug(\"Turn on Power-Saving\");\n+                    device.setDevicePwrSaving(socket, 1);\n+                    break;\n+                case MODE_TURBO:\n+                    device.setDeviceTurbo(socket, 1);\n+                    break;\n+            }\n+        }\n+    }\n+\n+    private boolean isMinimumRefreshTimeExceeded() {\n+        long currentTime = System.currentTimeMillis();\n+        long timeSinceLastRefresh = currentTime - lastRefreshTime;\n+        if (timeSinceLastRefresh < MINIMUM_REFRESH_TIME_MS) {\n+            return false;\n+        }\n+        lastRefreshTime = currentTime;\n+        return true;\n+    }\n+\n+    private void startAutomaticRefresh() {\n+\n+        Runnable refresher = new Runnable() {\n+            @Override\n+            public void run() {\n+\n+                try {\n+                    logger.debug(\"Executing automatic update of values\");\n+                    // safeguard for multiple REFRESH commands\n+                    if (isMinimumRefreshTimeExceeded()) {\n+                        logger.debug(\"Fetching status values from device.\");\n+                        // Get the current status from the Airconditioner\n+                        device.getDeviceStatus(clientSocket.get());\n+                    } else {\n+                        logger.trace(\n+                                \"Skipped fetching status values from device because minimum refresh time not reached\");\n+                    }\n+\n+                    // Update All Channels\n+                    List<Channel> channels = getThing().getChannels();\n+                    for (Channel channel : channels) {\n+                        publishChannel(channel.getUID());\n+                    }\n+                } catch (GreeException e) {\n+                    if (!e.isTimeout()) {\n+                        logger.debug(\"Unable to perform auto-update: {}\", e.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 306}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MjkwMA==", "bodyText": "See above", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432882900", "createdAt": "2020-05-30T20:04:36Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeHandler.java", "diffHunk": "@@ -0,0 +1,439 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.net.DatagramSocket;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.gree.internal.GreeConfiguration;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.discovery.GreeAirDevice;\n+import org.openhab.binding.gree.internal.discovery.GreeDeviceFinder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link GreeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(GreeHandler.class);\n+    private final GreeTranslationProvider messages;\n+    private GreeConfiguration config = new GreeConfiguration();\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+    private GreeAirDevice device = new GreeAirDevice();\n+    private Optional<DatagramSocket> clientSocket = Optional.empty();\n+\n+    private @Nullable ScheduledFuture<?> refreshTask;\n+    private long lastRefreshTime = 0;\n+\n+    public GreeHandler(Thing thing, GreeTranslationProvider messages) {\n+        super(thing);\n+        this.messages = messages;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // logger.debug(\"Start initializing!\");\n+        config = getConfigAs(GreeConfiguration.class);\n+        logger.debug(\"Config for {} is {}\", thing.getUID(), config.toString());\n+        if (config.ipAddress.isEmpty() || (config.refresh < 0)) {\n+            logger.debug(\"Config of {} is invalid. Check configuration\", thing.getUID());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid configuration. Check thing configuration.\");\n+            return;\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.execute(() -> {\n+            initializeThing();\n+        });\n+    }\n+\n+    private void initializeThing() {\n+        logger.debug(\"Thing {} is initializing\", thing.getUID());\n+\n+        try {\n+            // Create a new Datagram socket with a specified timeout\n+            clientSocket = Optional.of(new DatagramSocket());\n+            if (!clientSocket.isPresent()) {\n+                logger.debug(\"Unable to create datagram socket, discovery aborted!\");\n+                return;\n+            }\n+            clientSocket.get().setSoTimeout(DATAGRAM_SOCKET_TIMEOUT);\n+\n+            // Find the GREE device\n+            deviceFinder = new GreeDeviceFinder(config.ipAddress);\n+            deviceFinder.scan(clientSocket, false);\n+            logger.debug(\"{} units found matching IP address\", deviceFinder.getScannedDeviceCount());\n+\n+            // Now check that this one is amongst the air conditioners that responded.\n+            GreeAirDevice newDevice = deviceFinder.getDeviceByIPAddress(config.ipAddress);\n+            if (newDevice != null) {\n+                // Ok, our device responded, now let's Bind with it\n+                device = newDevice;\n+                device.bindWithDevice(clientSocket);\n+                if (device.getIsBound()) {\n+                    logger.debug(\"GREE AirConditioner {} bound successful\", thing.getUID());\n+                    updateStatus(ThingStatus.ONLINE);\n+\n+                    // Start the automatic refresh cycles\n+                    startAutomaticRefresh();\n+                    return;\n+                }\n+            }\n+            logger.debug(\"GREE unit is not responding\");\n+        } catch (GreeException e) {\n+            logger.debug(\"Initialization failed: {}\", messages.get(\"thinginit.exception\", e.toString()));\n+        } catch (IOException | RuntimeException e) {\n+            logger.debug(\"Exception on inituialization\", e);\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            // The thing is updated by the scheduled automatic refresh so do nothing here.\n+        } else {\n+            if (!clientSocket.isPresent()) {\n+                logger.debug(\"Thing not properly initialized, abort command\");\n+                return;\n+            }\n+\n+            DatagramSocket socket = clientSocket.get();\n+            logger.debug(\"Issue command {}\u00a0to channe {}\", command, channelUID.getIdWithoutGroup());\n+            try {\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case MODE_CHANNEL:\n+                        handleModeCommand(command, socket);\n+                        break;\n+                    case POWER_CHANNEL:\n+                        device.setDevicePower(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case TURBO_CHANNEL:\n+                        device.setDeviceTurbo(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case LIGHT_CHANNEL:\n+                        device.setDeviceLight(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case TEMP_CHANNEL:\n+                        device.setDeviceTempSet(socket, ((DecimalType) command).intValue());\n+                        break;\n+                    case SWINGV_CHANNEL:\n+                        device.setDeviceSwingVertical(socket, ((DecimalType) command).intValue());\n+                        break;\n+                    case WINDSPEED_CHANNEL:\n+                        device.setDeviceWindspeed(socket, ((DecimalType) command).intValue());\n+                        break;\n+                    case AIR_CHANNEL:\n+                        device.setDeviceAir(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case DRY_CHANNEL:\n+                        device.setDeviceDry(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case HEALTH_CHANNEL:\n+                        device.setDeviceHealth(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case PWRSAV_CHANNEL:\n+                        device.setDevicePwrSaving(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                }\n+            } catch (GreeException e) {\n+                logger.debug(\"Unable to execute command {}\u00a0for channel {}: {}\", command, channelUID.getId(),\n+                        e.toString());\n+            } catch (RuntimeException e) {\n+                logger.debug(\"Unable to execute command {}\u00a0for channel {}\", command, channelUID.getId(), e);\n+            }\n+        }\n+    }\n+\n+    private void handleModeCommand(Command command, DatagramSocket socket) throws GreeException {\n+        int mode = -1;\n+        String modeStr = \"\";\n+        boolean isNumber = StringUtils.isNumeric(command.toString());\n+        if (command instanceof DecimalType) {\n+            // backward compatibility when channel was Number\n+            mode = ((DecimalType) command).intValue();\n+        } else if (command instanceof OnOffType) {\n+            // Switch\n+            logger.debug(\"Send Power-{}\", command);\n+            device.setDevicePower(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+        } else /* String */ {\n+            modeStr = command.toString().toLowerCase();\n+            switch (modeStr) {\n+                case MODE_AUTO:\n+                    mode = GREE_MODE_AUTO;\n+                    break;\n+                case MODE_COOL:\n+                    mode = GREE_MODE_COOL;\n+                    break;\n+                case MODE_HEAT:\n+                    mode = GREE_MODE_HEAT;\n+                    break;\n+                case MODE_DRY:\n+                    mode = GREE_MODE_DRY;\n+                    break;\n+                case MODE_FAN:\n+                case MODE_FAN2:\n+                    mode = GREE_MODE_FAN;\n+                    break;\n+                case MODE_ECO:\n+                    // power saving will be set after the uinit was turned on\n+                    mode = GREE_MODE_COOL;\n+                    break;\n+                case MODE_ON:\n+                case MODE_OFF:\n+                    device.setDevicePower(socket, modeStr.equals(MODE_ON) ? 1 : 0);\n+                    break;\n+                default:\n+                    if (isNumber) {\n+                        // Support selecting the mode by number, maybe specific models support\n+                        // additional modes\n+                        mode = Integer.parseInt(modeStr);\n+                    } else {\n+                        logger.debug(\"Invalid mode requested: {}\", command);\n+                    }\n+                    break;\n+            }\n+            logger.debug(\"Mode {} mapped to {}\", modeStr, mode);\n+        }\n+\n+        if (mode != -1) {\n+            // Turn on the unit if currently off\n+            if (!isNumber && (device.getIntStatusVal(\"Pow\") == 0)) {\n+                logger.debug(\"Send Auto-ON for mode {}\", mode);\n+                device.setDevicePower(socket, 1);\n+            }\n+\n+            // Select mode\n+            logger.debug(\"Select mode {}\", mode);\n+            device.SetDeviceMode(socket, mode);\n+\n+            // Check for secondary action\n+            switch (modeStr) {\n+                case MODE_ECO:\n+                    // Turn on power saving for eco mode\n+                    logger.debug(\"Turn on Power-Saving\");\n+                    device.setDevicePwrSaving(socket, 1);\n+                    break;\n+                case MODE_TURBO:\n+                    device.setDeviceTurbo(socket, 1);\n+                    break;\n+            }\n+        }\n+    }\n+\n+    private boolean isMinimumRefreshTimeExceeded() {\n+        long currentTime = System.currentTimeMillis();\n+        long timeSinceLastRefresh = currentTime - lastRefreshTime;\n+        if (timeSinceLastRefresh < MINIMUM_REFRESH_TIME_MS) {\n+            return false;\n+        }\n+        lastRefreshTime = currentTime;\n+        return true;\n+    }\n+\n+    private void startAutomaticRefresh() {\n+\n+        Runnable refresher = new Runnable() {\n+            @Override\n+            public void run() {\n+\n+                try {\n+                    logger.debug(\"Executing automatic update of values\");\n+                    // safeguard for multiple REFRESH commands\n+                    if (isMinimumRefreshTimeExceeded()) {\n+                        logger.debug(\"Fetching status values from device.\");\n+                        // Get the current status from the Airconditioner\n+                        device.getDeviceStatus(clientSocket.get());\n+                    } else {\n+                        logger.trace(\n+                                \"Skipped fetching status values from device because minimum refresh time not reached\");\n+                    }\n+\n+                    // Update All Channels\n+                    List<Channel> channels = getThing().getChannels();\n+                    for (Channel channel : channels) {\n+                        publishChannel(channel.getUID());\n+                    }\n+                } catch (GreeException e) {\n+                    if (!e.isTimeout()) {\n+                        logger.debug(\"Unable to perform auto-update: {}\", e.toString());\n+                    }\n+                } catch (RuntimeException e) {\n+                    logger.debug(\"Unable to perform auto-update\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 309}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4Mjk5Ng==", "bodyText": "Should this be warn?", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432882996", "createdAt": "2020-05-30T20:05:29Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeHandler.java", "diffHunk": "@@ -0,0 +1,439 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.net.DatagramSocket;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.gree.internal.GreeConfiguration;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.discovery.GreeAirDevice;\n+import org.openhab.binding.gree.internal.discovery.GreeDeviceFinder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link GreeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(GreeHandler.class);\n+    private final GreeTranslationProvider messages;\n+    private GreeConfiguration config = new GreeConfiguration();\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+    private GreeAirDevice device = new GreeAirDevice();\n+    private Optional<DatagramSocket> clientSocket = Optional.empty();\n+\n+    private @Nullable ScheduledFuture<?> refreshTask;\n+    private long lastRefreshTime = 0;\n+\n+    public GreeHandler(Thing thing, GreeTranslationProvider messages) {\n+        super(thing);\n+        this.messages = messages;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // logger.debug(\"Start initializing!\");\n+        config = getConfigAs(GreeConfiguration.class);\n+        logger.debug(\"Config for {} is {}\", thing.getUID(), config.toString());\n+        if (config.ipAddress.isEmpty() || (config.refresh < 0)) {\n+            logger.debug(\"Config of {} is invalid. Check configuration\", thing.getUID());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid configuration. Check thing configuration.\");\n+            return;\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.execute(() -> {\n+            initializeThing();\n+        });\n+    }\n+\n+    private void initializeThing() {\n+        logger.debug(\"Thing {} is initializing\", thing.getUID());\n+\n+        try {\n+            // Create a new Datagram socket with a specified timeout\n+            clientSocket = Optional.of(new DatagramSocket());\n+            if (!clientSocket.isPresent()) {\n+                logger.debug(\"Unable to create datagram socket, discovery aborted!\");\n+                return;\n+            }\n+            clientSocket.get().setSoTimeout(DATAGRAM_SOCKET_TIMEOUT);\n+\n+            // Find the GREE device\n+            deviceFinder = new GreeDeviceFinder(config.ipAddress);\n+            deviceFinder.scan(clientSocket, false);\n+            logger.debug(\"{} units found matching IP address\", deviceFinder.getScannedDeviceCount());\n+\n+            // Now check that this one is amongst the air conditioners that responded.\n+            GreeAirDevice newDevice = deviceFinder.getDeviceByIPAddress(config.ipAddress);\n+            if (newDevice != null) {\n+                // Ok, our device responded, now let's Bind with it\n+                device = newDevice;\n+                device.bindWithDevice(clientSocket);\n+                if (device.getIsBound()) {\n+                    logger.debug(\"GREE AirConditioner {} bound successful\", thing.getUID());\n+                    updateStatus(ThingStatus.ONLINE);\n+\n+                    // Start the automatic refresh cycles\n+                    startAutomaticRefresh();\n+                    return;\n+                }\n+            }\n+            logger.debug(\"GREE unit is not responding\");\n+        } catch (GreeException e) {\n+            logger.debug(\"Initialization failed: {}\", messages.get(\"thinginit.exception\", e.toString()));\n+        } catch (IOException | RuntimeException e) {\n+            logger.debug(\"Exception on inituialization\", e);\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            // The thing is updated by the scheduled automatic refresh so do nothing here.\n+        } else {\n+            if (!clientSocket.isPresent()) {\n+                logger.debug(\"Thing not properly initialized, abort command\");\n+                return;\n+            }\n+\n+            DatagramSocket socket = clientSocket.get();\n+            logger.debug(\"Issue command {}\u00a0to channe {}\", command, channelUID.getIdWithoutGroup());\n+            try {\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case MODE_CHANNEL:\n+                        handleModeCommand(command, socket);\n+                        break;\n+                    case POWER_CHANNEL:\n+                        device.setDevicePower(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case TURBO_CHANNEL:\n+                        device.setDeviceTurbo(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case LIGHT_CHANNEL:\n+                        device.setDeviceLight(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case TEMP_CHANNEL:\n+                        device.setDeviceTempSet(socket, ((DecimalType) command).intValue());\n+                        break;\n+                    case SWINGV_CHANNEL:\n+                        device.setDeviceSwingVertical(socket, ((DecimalType) command).intValue());\n+                        break;\n+                    case WINDSPEED_CHANNEL:\n+                        device.setDeviceWindspeed(socket, ((DecimalType) command).intValue());\n+                        break;\n+                    case AIR_CHANNEL:\n+                        device.setDeviceAir(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case DRY_CHANNEL:\n+                        device.setDeviceDry(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case HEALTH_CHANNEL:\n+                        device.setDeviceHealth(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case PWRSAV_CHANNEL:\n+                        device.setDevicePwrSaving(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                }\n+            } catch (GreeException e) {\n+                logger.debug(\"Unable to execute command {}\u00a0for channel {}: {}\", command, channelUID.getId(),\n+                        e.toString());\n+            } catch (RuntimeException e) {\n+                logger.debug(\"Unable to execute command {}\u00a0for channel {}\", command, channelUID.getId(), e);\n+            }\n+        }\n+    }\n+\n+    private void handleModeCommand(Command command, DatagramSocket socket) throws GreeException {\n+        int mode = -1;\n+        String modeStr = \"\";\n+        boolean isNumber = StringUtils.isNumeric(command.toString());\n+        if (command instanceof DecimalType) {\n+            // backward compatibility when channel was Number\n+            mode = ((DecimalType) command).intValue();\n+        } else if (command instanceof OnOffType) {\n+            // Switch\n+            logger.debug(\"Send Power-{}\", command);\n+            device.setDevicePower(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+        } else /* String */ {\n+            modeStr = command.toString().toLowerCase();\n+            switch (modeStr) {\n+                case MODE_AUTO:\n+                    mode = GREE_MODE_AUTO;\n+                    break;\n+                case MODE_COOL:\n+                    mode = GREE_MODE_COOL;\n+                    break;\n+                case MODE_HEAT:\n+                    mode = GREE_MODE_HEAT;\n+                    break;\n+                case MODE_DRY:\n+                    mode = GREE_MODE_DRY;\n+                    break;\n+                case MODE_FAN:\n+                case MODE_FAN2:\n+                    mode = GREE_MODE_FAN;\n+                    break;\n+                case MODE_ECO:\n+                    // power saving will be set after the uinit was turned on\n+                    mode = GREE_MODE_COOL;\n+                    break;\n+                case MODE_ON:\n+                case MODE_OFF:\n+                    device.setDevicePower(socket, modeStr.equals(MODE_ON) ? 1 : 0);\n+                    break;\n+                default:\n+                    if (isNumber) {\n+                        // Support selecting the mode by number, maybe specific models support\n+                        // additional modes\n+                        mode = Integer.parseInt(modeStr);\n+                    } else {\n+                        logger.debug(\"Invalid mode requested: {}\", command);\n+                    }\n+                    break;\n+            }\n+            logger.debug(\"Mode {} mapped to {}\", modeStr, mode);\n+        }\n+\n+        if (mode != -1) {\n+            // Turn on the unit if currently off\n+            if (!isNumber && (device.getIntStatusVal(\"Pow\") == 0)) {\n+                logger.debug(\"Send Auto-ON for mode {}\", mode);\n+                device.setDevicePower(socket, 1);\n+            }\n+\n+            // Select mode\n+            logger.debug(\"Select mode {}\", mode);\n+            device.SetDeviceMode(socket, mode);\n+\n+            // Check for secondary action\n+            switch (modeStr) {\n+                case MODE_ECO:\n+                    // Turn on power saving for eco mode\n+                    logger.debug(\"Turn on Power-Saving\");\n+                    device.setDevicePwrSaving(socket, 1);\n+                    break;\n+                case MODE_TURBO:\n+                    device.setDeviceTurbo(socket, 1);\n+                    break;\n+            }\n+        }\n+    }\n+\n+    private boolean isMinimumRefreshTimeExceeded() {\n+        long currentTime = System.currentTimeMillis();\n+        long timeSinceLastRefresh = currentTime - lastRefreshTime;\n+        if (timeSinceLastRefresh < MINIMUM_REFRESH_TIME_MS) {\n+            return false;\n+        }\n+        lastRefreshTime = currentTime;\n+        return true;\n+    }\n+\n+    private void startAutomaticRefresh() {\n+\n+        Runnable refresher = new Runnable() {\n+            @Override\n+            public void run() {\n+\n+                try {\n+                    logger.debug(\"Executing automatic update of values\");\n+                    // safeguard for multiple REFRESH commands\n+                    if (isMinimumRefreshTimeExceeded()) {\n+                        logger.debug(\"Fetching status values from device.\");\n+                        // Get the current status from the Airconditioner\n+                        device.getDeviceStatus(clientSocket.get());\n+                    } else {\n+                        logger.trace(\n+                                \"Skipped fetching status values from device because minimum refresh time not reached\");\n+                    }\n+\n+                    // Update All Channels\n+                    List<Channel> channels = getThing().getChannels();\n+                    for (Channel channel : channels) {\n+                        publishChannel(channel.getUID());\n+                    }\n+                } catch (GreeException e) {\n+                    if (!e.isTimeout()) {\n+                        logger.debug(\"Unable to perform auto-update: {}\", e.toString());\n+                    }\n+                } catch (RuntimeException e) {\n+                    logger.debug(\"Unable to perform auto-update\", e);\n+                }\n+            }\n+        };\n+\n+        refreshTask = scheduler.scheduleWithFixedDelay(refresher, 0, config.refresh, TimeUnit.SECONDS);\n+        logger.debug(\"Automatic refresh started ({} second interval)\", config.refresh);\n+    }\n+\n+    private void publishChannel(ChannelUID channelUID) throws GreeException {\n+        try {\n+            String channelID = channelUID.getId();\n+            Optional<State> state = Optional.empty();\n+            switch (channelUID.getIdWithoutGroup()) {\n+                case POWER_CHANNEL:\n+                    state = updateOnOff(\"Pow\");\n+                    break;\n+                case MODE_CHANNEL:\n+                    state = updateMode();\n+                    break;\n+                case TURBO_CHANNEL:\n+                    state = updateOnOff(\"Tur\");\n+                    break;\n+                case LIGHT_CHANNEL:\n+                    state = updateOnOff(\"Lig\");\n+                    break;\n+                case TEMP_CHANNEL:\n+                    state = updateTemp(\"SetTem\");\n+                    break;\n+                case SWINGV_CHANNEL:\n+                    state = updateNumber(\"SwUpDn\");\n+                    break;\n+                case WINDSPEED_CHANNEL:\n+                    state = updateNumber(\"WdSpd\");\n+                    break;\n+                case AIR_CHANNEL:\n+                    state = updateOnOff(\"Air\");\n+                    break;\n+                case DRY_CHANNEL:\n+                    state = updateOnOff(\"Blo\");\n+                    break;\n+                case HEALTH_CHANNEL:\n+                    state = updateOnOff(\"Health\");\n+                    break;\n+                case PWRSAV_CHANNEL:\n+                    state = updateOnOff(\"SvSt\");\n+                    break;\n+            }\n+            if (state.isPresent()) {\n+                logger.trace(\"Updating channel {} : {}\", channelID, state.get());\n+                updateState(channelID, state.get());\n+            }\n+        } catch (GreeException | IllegalArgumentException e) {\n+            logger.debug(\"Exception on channel update\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 362}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MzA2NA==", "bodyText": "What throws a GreeException here?", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432883064", "createdAt": "2020-05-30T20:06:11Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeHandler.java", "diffHunk": "@@ -0,0 +1,439 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.net.DatagramSocket;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.gree.internal.GreeConfiguration;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.discovery.GreeAirDevice;\n+import org.openhab.binding.gree.internal.discovery.GreeDeviceFinder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link GreeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(GreeHandler.class);\n+    private final GreeTranslationProvider messages;\n+    private GreeConfiguration config = new GreeConfiguration();\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+    private GreeAirDevice device = new GreeAirDevice();\n+    private Optional<DatagramSocket> clientSocket = Optional.empty();\n+\n+    private @Nullable ScheduledFuture<?> refreshTask;\n+    private long lastRefreshTime = 0;\n+\n+    public GreeHandler(Thing thing, GreeTranslationProvider messages) {\n+        super(thing);\n+        this.messages = messages;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // logger.debug(\"Start initializing!\");\n+        config = getConfigAs(GreeConfiguration.class);\n+        logger.debug(\"Config for {} is {}\", thing.getUID(), config.toString());\n+        if (config.ipAddress.isEmpty() || (config.refresh < 0)) {\n+            logger.debug(\"Config of {} is invalid. Check configuration\", thing.getUID());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid configuration. Check thing configuration.\");\n+            return;\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.execute(() -> {\n+            initializeThing();\n+        });\n+    }\n+\n+    private void initializeThing() {\n+        logger.debug(\"Thing {} is initializing\", thing.getUID());\n+\n+        try {\n+            // Create a new Datagram socket with a specified timeout\n+            clientSocket = Optional.of(new DatagramSocket());\n+            if (!clientSocket.isPresent()) {\n+                logger.debug(\"Unable to create datagram socket, discovery aborted!\");\n+                return;\n+            }\n+            clientSocket.get().setSoTimeout(DATAGRAM_SOCKET_TIMEOUT);\n+\n+            // Find the GREE device\n+            deviceFinder = new GreeDeviceFinder(config.ipAddress);\n+            deviceFinder.scan(clientSocket, false);\n+            logger.debug(\"{} units found matching IP address\", deviceFinder.getScannedDeviceCount());\n+\n+            // Now check that this one is amongst the air conditioners that responded.\n+            GreeAirDevice newDevice = deviceFinder.getDeviceByIPAddress(config.ipAddress);\n+            if (newDevice != null) {\n+                // Ok, our device responded, now let's Bind with it\n+                device = newDevice;\n+                device.bindWithDevice(clientSocket);\n+                if (device.getIsBound()) {\n+                    logger.debug(\"GREE AirConditioner {} bound successful\", thing.getUID());\n+                    updateStatus(ThingStatus.ONLINE);\n+\n+                    // Start the automatic refresh cycles\n+                    startAutomaticRefresh();\n+                    return;\n+                }\n+            }\n+            logger.debug(\"GREE unit is not responding\");\n+        } catch (GreeException e) {\n+            logger.debug(\"Initialization failed: {}\", messages.get(\"thinginit.exception\", e.toString()));\n+        } catch (IOException | RuntimeException e) {\n+            logger.debug(\"Exception on inituialization\", e);\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            // The thing is updated by the scheduled automatic refresh so do nothing here.\n+        } else {\n+            if (!clientSocket.isPresent()) {\n+                logger.debug(\"Thing not properly initialized, abort command\");\n+                return;\n+            }\n+\n+            DatagramSocket socket = clientSocket.get();\n+            logger.debug(\"Issue command {}\u00a0to channe {}\", command, channelUID.getIdWithoutGroup());\n+            try {\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case MODE_CHANNEL:\n+                        handleModeCommand(command, socket);\n+                        break;\n+                    case POWER_CHANNEL:\n+                        device.setDevicePower(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case TURBO_CHANNEL:\n+                        device.setDeviceTurbo(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case LIGHT_CHANNEL:\n+                        device.setDeviceLight(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case TEMP_CHANNEL:\n+                        device.setDeviceTempSet(socket, ((DecimalType) command).intValue());\n+                        break;\n+                    case SWINGV_CHANNEL:\n+                        device.setDeviceSwingVertical(socket, ((DecimalType) command).intValue());\n+                        break;\n+                    case WINDSPEED_CHANNEL:\n+                        device.setDeviceWindspeed(socket, ((DecimalType) command).intValue());\n+                        break;\n+                    case AIR_CHANNEL:\n+                        device.setDeviceAir(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case DRY_CHANNEL:\n+                        device.setDeviceDry(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case HEALTH_CHANNEL:\n+                        device.setDeviceHealth(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case PWRSAV_CHANNEL:\n+                        device.setDevicePwrSaving(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                }\n+            } catch (GreeException e) {\n+                logger.debug(\"Unable to execute command {}\u00a0for channel {}: {}\", command, channelUID.getId(),\n+                        e.toString());\n+            } catch (RuntimeException e) {\n+                logger.debug(\"Unable to execute command {}\u00a0for channel {}\", command, channelUID.getId(), e);\n+            }\n+        }\n+    }\n+\n+    private void handleModeCommand(Command command, DatagramSocket socket) throws GreeException {\n+        int mode = -1;\n+        String modeStr = \"\";\n+        boolean isNumber = StringUtils.isNumeric(command.toString());\n+        if (command instanceof DecimalType) {\n+            // backward compatibility when channel was Number\n+            mode = ((DecimalType) command).intValue();\n+        } else if (command instanceof OnOffType) {\n+            // Switch\n+            logger.debug(\"Send Power-{}\", command);\n+            device.setDevicePower(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+        } else /* String */ {\n+            modeStr = command.toString().toLowerCase();\n+            switch (modeStr) {\n+                case MODE_AUTO:\n+                    mode = GREE_MODE_AUTO;\n+                    break;\n+                case MODE_COOL:\n+                    mode = GREE_MODE_COOL;\n+                    break;\n+                case MODE_HEAT:\n+                    mode = GREE_MODE_HEAT;\n+                    break;\n+                case MODE_DRY:\n+                    mode = GREE_MODE_DRY;\n+                    break;\n+                case MODE_FAN:\n+                case MODE_FAN2:\n+                    mode = GREE_MODE_FAN;\n+                    break;\n+                case MODE_ECO:\n+                    // power saving will be set after the uinit was turned on\n+                    mode = GREE_MODE_COOL;\n+                    break;\n+                case MODE_ON:\n+                case MODE_OFF:\n+                    device.setDevicePower(socket, modeStr.equals(MODE_ON) ? 1 : 0);\n+                    break;\n+                default:\n+                    if (isNumber) {\n+                        // Support selecting the mode by number, maybe specific models support\n+                        // additional modes\n+                        mode = Integer.parseInt(modeStr);\n+                    } else {\n+                        logger.debug(\"Invalid mode requested: {}\", command);\n+                    }\n+                    break;\n+            }\n+            logger.debug(\"Mode {} mapped to {}\", modeStr, mode);\n+        }\n+\n+        if (mode != -1) {\n+            // Turn on the unit if currently off\n+            if (!isNumber && (device.getIntStatusVal(\"Pow\") == 0)) {\n+                logger.debug(\"Send Auto-ON for mode {}\", mode);\n+                device.setDevicePower(socket, 1);\n+            }\n+\n+            // Select mode\n+            logger.debug(\"Select mode {}\", mode);\n+            device.SetDeviceMode(socket, mode);\n+\n+            // Check for secondary action\n+            switch (modeStr) {\n+                case MODE_ECO:\n+                    // Turn on power saving for eco mode\n+                    logger.debug(\"Turn on Power-Saving\");\n+                    device.setDevicePwrSaving(socket, 1);\n+                    break;\n+                case MODE_TURBO:\n+                    device.setDeviceTurbo(socket, 1);\n+                    break;\n+            }\n+        }\n+    }\n+\n+    private boolean isMinimumRefreshTimeExceeded() {\n+        long currentTime = System.currentTimeMillis();\n+        long timeSinceLastRefresh = currentTime - lastRefreshTime;\n+        if (timeSinceLastRefresh < MINIMUM_REFRESH_TIME_MS) {\n+            return false;\n+        }\n+        lastRefreshTime = currentTime;\n+        return true;\n+    }\n+\n+    private void startAutomaticRefresh() {\n+\n+        Runnable refresher = new Runnable() {\n+            @Override\n+            public void run() {\n+\n+                try {\n+                    logger.debug(\"Executing automatic update of values\");\n+                    // safeguard for multiple REFRESH commands\n+                    if (isMinimumRefreshTimeExceeded()) {\n+                        logger.debug(\"Fetching status values from device.\");\n+                        // Get the current status from the Airconditioner\n+                        device.getDeviceStatus(clientSocket.get());\n+                    } else {\n+                        logger.trace(\n+                                \"Skipped fetching status values from device because minimum refresh time not reached\");\n+                    }\n+\n+                    // Update All Channels\n+                    List<Channel> channels = getThing().getChannels();\n+                    for (Channel channel : channels) {\n+                        publishChannel(channel.getUID());\n+                    }\n+                } catch (GreeException e) {\n+                    if (!e.isTimeout()) {\n+                        logger.debug(\"Unable to perform auto-update: {}\", e.toString());\n+                    }\n+                } catch (RuntimeException e) {\n+                    logger.debug(\"Unable to perform auto-update\", e);\n+                }\n+            }\n+        };\n+\n+        refreshTask = scheduler.scheduleWithFixedDelay(refresher, 0, config.refresh, TimeUnit.SECONDS);\n+        logger.debug(\"Automatic refresh started ({} second interval)\", config.refresh);\n+    }\n+\n+    private void publishChannel(ChannelUID channelUID) throws GreeException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 318}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MzEwOA==", "bodyText": "What throws an IllegalArgumentException here?", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432883108", "createdAt": "2020-05-30T20:07:04Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeHandler.java", "diffHunk": "@@ -0,0 +1,439 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.net.DatagramSocket;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.gree.internal.GreeConfiguration;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.discovery.GreeAirDevice;\n+import org.openhab.binding.gree.internal.discovery.GreeDeviceFinder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link GreeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(GreeHandler.class);\n+    private final GreeTranslationProvider messages;\n+    private GreeConfiguration config = new GreeConfiguration();\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+    private GreeAirDevice device = new GreeAirDevice();\n+    private Optional<DatagramSocket> clientSocket = Optional.empty();\n+\n+    private @Nullable ScheduledFuture<?> refreshTask;\n+    private long lastRefreshTime = 0;\n+\n+    public GreeHandler(Thing thing, GreeTranslationProvider messages) {\n+        super(thing);\n+        this.messages = messages;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // logger.debug(\"Start initializing!\");\n+        config = getConfigAs(GreeConfiguration.class);\n+        logger.debug(\"Config for {} is {}\", thing.getUID(), config.toString());\n+        if (config.ipAddress.isEmpty() || (config.refresh < 0)) {\n+            logger.debug(\"Config of {} is invalid. Check configuration\", thing.getUID());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid configuration. Check thing configuration.\");\n+            return;\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.execute(() -> {\n+            initializeThing();\n+        });\n+    }\n+\n+    private void initializeThing() {\n+        logger.debug(\"Thing {} is initializing\", thing.getUID());\n+\n+        try {\n+            // Create a new Datagram socket with a specified timeout\n+            clientSocket = Optional.of(new DatagramSocket());\n+            if (!clientSocket.isPresent()) {\n+                logger.debug(\"Unable to create datagram socket, discovery aborted!\");\n+                return;\n+            }\n+            clientSocket.get().setSoTimeout(DATAGRAM_SOCKET_TIMEOUT);\n+\n+            // Find the GREE device\n+            deviceFinder = new GreeDeviceFinder(config.ipAddress);\n+            deviceFinder.scan(clientSocket, false);\n+            logger.debug(\"{} units found matching IP address\", deviceFinder.getScannedDeviceCount());\n+\n+            // Now check that this one is amongst the air conditioners that responded.\n+            GreeAirDevice newDevice = deviceFinder.getDeviceByIPAddress(config.ipAddress);\n+            if (newDevice != null) {\n+                // Ok, our device responded, now let's Bind with it\n+                device = newDevice;\n+                device.bindWithDevice(clientSocket);\n+                if (device.getIsBound()) {\n+                    logger.debug(\"GREE AirConditioner {} bound successful\", thing.getUID());\n+                    updateStatus(ThingStatus.ONLINE);\n+\n+                    // Start the automatic refresh cycles\n+                    startAutomaticRefresh();\n+                    return;\n+                }\n+            }\n+            logger.debug(\"GREE unit is not responding\");\n+        } catch (GreeException e) {\n+            logger.debug(\"Initialization failed: {}\", messages.get(\"thinginit.exception\", e.toString()));\n+        } catch (IOException | RuntimeException e) {\n+            logger.debug(\"Exception on inituialization\", e);\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            // The thing is updated by the scheduled automatic refresh so do nothing here.\n+        } else {\n+            if (!clientSocket.isPresent()) {\n+                logger.debug(\"Thing not properly initialized, abort command\");\n+                return;\n+            }\n+\n+            DatagramSocket socket = clientSocket.get();\n+            logger.debug(\"Issue command {}\u00a0to channe {}\", command, channelUID.getIdWithoutGroup());\n+            try {\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case MODE_CHANNEL:\n+                        handleModeCommand(command, socket);\n+                        break;\n+                    case POWER_CHANNEL:\n+                        device.setDevicePower(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case TURBO_CHANNEL:\n+                        device.setDeviceTurbo(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case LIGHT_CHANNEL:\n+                        device.setDeviceLight(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case TEMP_CHANNEL:\n+                        device.setDeviceTempSet(socket, ((DecimalType) command).intValue());\n+                        break;\n+                    case SWINGV_CHANNEL:\n+                        device.setDeviceSwingVertical(socket, ((DecimalType) command).intValue());\n+                        break;\n+                    case WINDSPEED_CHANNEL:\n+                        device.setDeviceWindspeed(socket, ((DecimalType) command).intValue());\n+                        break;\n+                    case AIR_CHANNEL:\n+                        device.setDeviceAir(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case DRY_CHANNEL:\n+                        device.setDeviceDry(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case HEALTH_CHANNEL:\n+                        device.setDeviceHealth(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case PWRSAV_CHANNEL:\n+                        device.setDevicePwrSaving(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                }\n+            } catch (GreeException e) {\n+                logger.debug(\"Unable to execute command {}\u00a0for channel {}: {}\", command, channelUID.getId(),\n+                        e.toString());\n+            } catch (RuntimeException e) {\n+                logger.debug(\"Unable to execute command {}\u00a0for channel {}\", command, channelUID.getId(), e);\n+            }\n+        }\n+    }\n+\n+    private void handleModeCommand(Command command, DatagramSocket socket) throws GreeException {\n+        int mode = -1;\n+        String modeStr = \"\";\n+        boolean isNumber = StringUtils.isNumeric(command.toString());\n+        if (command instanceof DecimalType) {\n+            // backward compatibility when channel was Number\n+            mode = ((DecimalType) command).intValue();\n+        } else if (command instanceof OnOffType) {\n+            // Switch\n+            logger.debug(\"Send Power-{}\", command);\n+            device.setDevicePower(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+        } else /* String */ {\n+            modeStr = command.toString().toLowerCase();\n+            switch (modeStr) {\n+                case MODE_AUTO:\n+                    mode = GREE_MODE_AUTO;\n+                    break;\n+                case MODE_COOL:\n+                    mode = GREE_MODE_COOL;\n+                    break;\n+                case MODE_HEAT:\n+                    mode = GREE_MODE_HEAT;\n+                    break;\n+                case MODE_DRY:\n+                    mode = GREE_MODE_DRY;\n+                    break;\n+                case MODE_FAN:\n+                case MODE_FAN2:\n+                    mode = GREE_MODE_FAN;\n+                    break;\n+                case MODE_ECO:\n+                    // power saving will be set after the uinit was turned on\n+                    mode = GREE_MODE_COOL;\n+                    break;\n+                case MODE_ON:\n+                case MODE_OFF:\n+                    device.setDevicePower(socket, modeStr.equals(MODE_ON) ? 1 : 0);\n+                    break;\n+                default:\n+                    if (isNumber) {\n+                        // Support selecting the mode by number, maybe specific models support\n+                        // additional modes\n+                        mode = Integer.parseInt(modeStr);\n+                    } else {\n+                        logger.debug(\"Invalid mode requested: {}\", command);\n+                    }\n+                    break;\n+            }\n+            logger.debug(\"Mode {} mapped to {}\", modeStr, mode);\n+        }\n+\n+        if (mode != -1) {\n+            // Turn on the unit if currently off\n+            if (!isNumber && (device.getIntStatusVal(\"Pow\") == 0)) {\n+                logger.debug(\"Send Auto-ON for mode {}\", mode);\n+                device.setDevicePower(socket, 1);\n+            }\n+\n+            // Select mode\n+            logger.debug(\"Select mode {}\", mode);\n+            device.SetDeviceMode(socket, mode);\n+\n+            // Check for secondary action\n+            switch (modeStr) {\n+                case MODE_ECO:\n+                    // Turn on power saving for eco mode\n+                    logger.debug(\"Turn on Power-Saving\");\n+                    device.setDevicePwrSaving(socket, 1);\n+                    break;\n+                case MODE_TURBO:\n+                    device.setDeviceTurbo(socket, 1);\n+                    break;\n+            }\n+        }\n+    }\n+\n+    private boolean isMinimumRefreshTimeExceeded() {\n+        long currentTime = System.currentTimeMillis();\n+        long timeSinceLastRefresh = currentTime - lastRefreshTime;\n+        if (timeSinceLastRefresh < MINIMUM_REFRESH_TIME_MS) {\n+            return false;\n+        }\n+        lastRefreshTime = currentTime;\n+        return true;\n+    }\n+\n+    private void startAutomaticRefresh() {\n+\n+        Runnable refresher = new Runnable() {\n+            @Override\n+            public void run() {\n+\n+                try {\n+                    logger.debug(\"Executing automatic update of values\");\n+                    // safeguard for multiple REFRESH commands\n+                    if (isMinimumRefreshTimeExceeded()) {\n+                        logger.debug(\"Fetching status values from device.\");\n+                        // Get the current status from the Airconditioner\n+                        device.getDeviceStatus(clientSocket.get());\n+                    } else {\n+                        logger.trace(\n+                                \"Skipped fetching status values from device because minimum refresh time not reached\");\n+                    }\n+\n+                    // Update All Channels\n+                    List<Channel> channels = getThing().getChannels();\n+                    for (Channel channel : channels) {\n+                        publishChannel(channel.getUID());\n+                    }\n+                } catch (GreeException e) {\n+                    if (!e.isTimeout()) {\n+                        logger.debug(\"Unable to perform auto-update: {}\", e.toString());\n+                    }\n+                } catch (RuntimeException e) {\n+                    logger.debug(\"Unable to perform auto-update\", e);\n+                }\n+            }\n+        };\n+\n+        refreshTask = scheduler.scheduleWithFixedDelay(refresher, 0, config.refresh, TimeUnit.SECONDS);\n+        logger.debug(\"Automatic refresh started ({} second interval)\", config.refresh);\n+    }\n+\n+    private void publishChannel(ChannelUID channelUID) throws GreeException {\n+        try {\n+            String channelID = channelUID.getId();\n+            Optional<State> state = Optional.empty();\n+            switch (channelUID.getIdWithoutGroup()) {\n+                case POWER_CHANNEL:\n+                    state = updateOnOff(\"Pow\");\n+                    break;\n+                case MODE_CHANNEL:\n+                    state = updateMode();\n+                    break;\n+                case TURBO_CHANNEL:\n+                    state = updateOnOff(\"Tur\");\n+                    break;\n+                case LIGHT_CHANNEL:\n+                    state = updateOnOff(\"Lig\");\n+                    break;\n+                case TEMP_CHANNEL:\n+                    state = updateTemp(\"SetTem\");\n+                    break;\n+                case SWINGV_CHANNEL:\n+                    state = updateNumber(\"SwUpDn\");\n+                    break;\n+                case WINDSPEED_CHANNEL:\n+                    state = updateNumber(\"WdSpd\");\n+                    break;\n+                case AIR_CHANNEL:\n+                    state = updateOnOff(\"Air\");\n+                    break;\n+                case DRY_CHANNEL:\n+                    state = updateOnOff(\"Blo\");\n+                    break;\n+                case HEALTH_CHANNEL:\n+                    state = updateOnOff(\"Health\");\n+                    break;\n+                case PWRSAV_CHANNEL:\n+                    state = updateOnOff(\"SvSt\");\n+                    break;\n+            }\n+            if (state.isPresent()) {\n+                logger.trace(\"Updating channel {} : {}\", channelID, state.get());\n+                updateState(channelID, state.get());\n+            }\n+        } catch (GreeException | IllegalArgumentException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 361}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MzU5OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            channel-type.gree.dry.description = Set on/off the Air Conditioner's Dry function if applicable to the Air Conditioner model .\n          \n          \n            \n            channel-type.gree.dry.description = Set on/off the Air Conditioner's Dry function if applicable to the Air Conditioner model.", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432883599", "createdAt": "2020-05-30T20:14:10Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/resources/ESH-INF/i18n/gree.properties", "diffHunk": "@@ -0,0 +1,64 @@\n+# GREE Binding\n+binding.gree.name = GREE Binding\n+binding.gree.description = This binding integrates the GREE series of air conditioners\n+\n+# thing types\n+thing-type.gree.airconditioner.label = Air Conditioner\n+thing-type.gree.airconditioner.description = A GREE Air Conditioner with WiFi Module\n+\n+# thing type config description\n+thing-type.config.gree.airconditioner.ipAddress.label = IP Address\n+thing-type.config.gree.airconditioner.ipAddress.description = IP Address of the GREE unit.\n+thing-type.config.gree.airconditioner.broadcastAddress.label = Subnet Broadcast Address\n+thing-type.config.gree.airconditioner.broadcastAddress.description = Broadcast IP address of the local subnet.\n+thing-type.config.gree.airconditioner.refresh.label = Refresh Interval\n+thing-type.config.gree.airconditioner.refresh.description = Interval to query an update from the device.\n+\n+\n+# channel types\n+channel-type.gree.power.label = Power\n+channel-type.gree.power.description = Turn power on/off\n+channel-type.gree.mode.label = Unit Mode\n+channel-type.gree.mode.description = Operating mode of the Air Conditioner: Auto: 0, Cool: 1, Dry: 2, Fan: 3, Heat: 4\n+channel-type.gree.mode.state.option.auto = Auto\n+channel-type.gree.mode.state.option.cool = Cool\n+channel-type.gree.mode.state.option.eco = Eco\n+channel-type.gree.mode.state.option.dry = Dry\n+channel-type.gree.mode.state.option.fan = Fan\n+channel-type.gree.mode.state.option.turbo = Turbo\n+channel-type.gree.mode.state.option.heat = Heat\n+channel-type.gree.mode.state.option.on = ON\n+channel-type.gree.mode.state.option.off = OFF\n+channel-type.gree.mode.state.option.0 = Auto\n+channel-type.gree.mode.state.option.1 = Cool\n+channel-type.gree.mode.state.option.2 = Dry\n+channel-type.gree.mode.state.option.3 = Fan\n+channel-type.gree.mode.state.option.4 = Heat\n+channel-type.gree.air.label = Air Mode\n+channel-type.gree.air.description = Set on/off the Air Conditioner's Air function if applicable to the Air Conditioner model.\n+channel-type.gree.dry.label = Dry Mode\n+channel-type.gree.dry.description = Set on/off the Air Conditioner's Dry function if applicable to the Air Conditioner model .", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4Mzg1OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            channel-type.gree.mode.state.option.dry = DTrocknen\n          \n          \n            \n            channel-type.gree.mode.state.option.dry = Trocknen", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432883859", "createdAt": "2020-05-30T20:15:59Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/resources/ESH-INF/i18n/gree_de.properties", "diffHunk": "@@ -0,0 +1,65 @@\n+# GREE Binding\n+binding.gree.name = GREE Binding\n+binding.gree.description = Dieses Binding integriert Klimaanlagen der Marke GREE\n+\n+# thing types\n+thing-type.gree.airconditioner.label = Klimaanlage\n+thing-type.gree.airconditioner.description = Eine GREE Klimaanlage mit WiFi Modul\n+\n+# thing type config description\n+thing-type.config.gree.airconditioner.ipAddress.label = IP Adresse\n+thing-type.config.gree.airconditioner.ipAddress.description = IP Adresse des GREE-Ger\ufffdtes.\n+thing-type.config.gree.airconditioner.broadcastAddress.label = IP Broadcast-Adresse\n+thing-type.config.gree.airconditioner.broadcastAddress.description = Broadcast IP Adresse des lokalen Subnetzes.\n+thing-type.config.gree.airconditioner.refresh.label = Aktualisierungsintervall\n+thing-type.config.gree.airconditioner.refresh.description = Intervall, in dem der Status des Ger\ufffdtes aktualisiert wird.\n+\n+\n+# channel types\n+channel-type.gree.power.label = Betrieb\n+channel-type.gree.power.description = Schaltet das Ger\ufffdt ein/aus.\n+channel-type.gree.mode.label = Betriebsmodus\n+channel-type.gree.mode.description = Betriebsmodus der Klimaanlage: 0: Auto, 1: K\ufffdhlen, 2: Trocknen, L\ufffdften: 3, Heizen: 4\n+channel-type.gree.mode.state.option.auto = Auto\n+channel-type.gree.mode.state.option.cool = K\ufffdhlen\n+channel-type.gree.mode.state.option.eco = Eco\n+channel-type.gree.mode.state.option.dry = DTrocknen", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MzkyMA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            channel-type.gree.dry.description = Schaltet den Trocknungsmodus ein/aus. . Verf\ufffdgbarkeit ist abh\ufffdngig vom Ger\ufffdtemodell.\n          \n          \n            \n            channel-type.gree.dry.description = Schaltet den Trocknungsmodus ein/aus. Verf\ufffdgbarkeit ist abh\ufffdngig vom Ger\ufffdtemodell.", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432883920", "createdAt": "2020-05-30T20:16:30Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/resources/ESH-INF/i18n/gree_de.properties", "diffHunk": "@@ -0,0 +1,65 @@\n+# GREE Binding\n+binding.gree.name = GREE Binding\n+binding.gree.description = Dieses Binding integriert Klimaanlagen der Marke GREE\n+\n+# thing types\n+thing-type.gree.airconditioner.label = Klimaanlage\n+thing-type.gree.airconditioner.description = Eine GREE Klimaanlage mit WiFi Modul\n+\n+# thing type config description\n+thing-type.config.gree.airconditioner.ipAddress.label = IP Adresse\n+thing-type.config.gree.airconditioner.ipAddress.description = IP Adresse des GREE-Ger\ufffdtes.\n+thing-type.config.gree.airconditioner.broadcastAddress.label = IP Broadcast-Adresse\n+thing-type.config.gree.airconditioner.broadcastAddress.description = Broadcast IP Adresse des lokalen Subnetzes.\n+thing-type.config.gree.airconditioner.refresh.label = Aktualisierungsintervall\n+thing-type.config.gree.airconditioner.refresh.description = Intervall, in dem der Status des Ger\ufffdtes aktualisiert wird.\n+\n+\n+# channel types\n+channel-type.gree.power.label = Betrieb\n+channel-type.gree.power.description = Schaltet das Ger\ufffdt ein/aus.\n+channel-type.gree.mode.label = Betriebsmodus\n+channel-type.gree.mode.description = Betriebsmodus der Klimaanlage: 0: Auto, 1: K\ufffdhlen, 2: Trocknen, L\ufffdften: 3, Heizen: 4\n+channel-type.gree.mode.state.option.auto = Auto\n+channel-type.gree.mode.state.option.cool = K\ufffdhlen\n+channel-type.gree.mode.state.option.eco = Eco\n+channel-type.gree.mode.state.option.dry = DTrocknen\n+channel-type.gree.mode.state.option.fan = Ventilator\n+channel-type.gree.mode.state.option.turbo = Turbo\n+channel-type.gree.mode.state.option.heat = Heizen\n+channel-type.gree.mode.state.option.on = Ein\n+channel-type.gree.mode.state.option.off = Aus\n+channel-type.gree.mode.state.option.0 = Auto\n+channel-type.gree.mode.state.option.1 = K\ufffdhlen\n+channel-type.gree.mode.state.option.2 = Trocken\n+channel-type.gree.mode.state.option.3 = Ventilator\n+channel-type.gree.mode.state.option.4 = Heizen\n+channel-type.gree.air.label = L\ufffdftung\n+channel-type.gree.air.description = Schaltet das Ger\ufffdt in den L\ufffdftermodus (keine K\ufffdhlung). Verf\ufffdgbarkeit ist abh\ufffdngig vom Ger\ufffdtemodell.\n+channel-type.gree.dry.label = Trocknen\n+channel-type.gree.dry.description = Schaltet den Trocknungsmodus ein/aus. . Verf\ufffdgbarkeit ist abh\ufffdngig vom Ger\ufffdtemodell.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4NDEyOQ==", "bodyText": "You should use UTF-8 encoding for this file (currently ISO-8859-1).", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432884129", "createdAt": "2020-05-30T20:17:57Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/resources/ESH-INF/i18n/gree_de.properties", "diffHunk": "@@ -0,0 +1,65 @@\n+# GREE Binding", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4NDIxMw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            channel-type.gree.dry.label = Turbo-Modus\n          \n          \n            \n            channel-type.gree.dry.label = Turbomodus", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432884213", "createdAt": "2020-05-30T20:18:34Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/resources/ESH-INF/i18n/gree_de.properties", "diffHunk": "@@ -0,0 +1,65 @@\n+# GREE Binding\n+binding.gree.name = GREE Binding\n+binding.gree.description = Dieses Binding integriert Klimaanlagen der Marke GREE\n+\n+# thing types\n+thing-type.gree.airconditioner.label = Klimaanlage\n+thing-type.gree.airconditioner.description = Eine GREE Klimaanlage mit WiFi Modul\n+\n+# thing type config description\n+thing-type.config.gree.airconditioner.ipAddress.label = IP Adresse\n+thing-type.config.gree.airconditioner.ipAddress.description = IP Adresse des GREE-Ger\ufffdtes.\n+thing-type.config.gree.airconditioner.broadcastAddress.label = IP Broadcast-Adresse\n+thing-type.config.gree.airconditioner.broadcastAddress.description = Broadcast IP Adresse des lokalen Subnetzes.\n+thing-type.config.gree.airconditioner.refresh.label = Aktualisierungsintervall\n+thing-type.config.gree.airconditioner.refresh.description = Intervall, in dem der Status des Ger\ufffdtes aktualisiert wird.\n+\n+\n+# channel types\n+channel-type.gree.power.label = Betrieb\n+channel-type.gree.power.description = Schaltet das Ger\ufffdt ein/aus.\n+channel-type.gree.mode.label = Betriebsmodus\n+channel-type.gree.mode.description = Betriebsmodus der Klimaanlage: 0: Auto, 1: K\ufffdhlen, 2: Trocknen, L\ufffdften: 3, Heizen: 4\n+channel-type.gree.mode.state.option.auto = Auto\n+channel-type.gree.mode.state.option.cool = K\ufffdhlen\n+channel-type.gree.mode.state.option.eco = Eco\n+channel-type.gree.mode.state.option.dry = DTrocknen\n+channel-type.gree.mode.state.option.fan = Ventilator\n+channel-type.gree.mode.state.option.turbo = Turbo\n+channel-type.gree.mode.state.option.heat = Heizen\n+channel-type.gree.mode.state.option.on = Ein\n+channel-type.gree.mode.state.option.off = Aus\n+channel-type.gree.mode.state.option.0 = Auto\n+channel-type.gree.mode.state.option.1 = K\ufffdhlen\n+channel-type.gree.mode.state.option.2 = Trocken\n+channel-type.gree.mode.state.option.3 = Ventilator\n+channel-type.gree.mode.state.option.4 = Heizen\n+channel-type.gree.air.label = L\ufffdftung\n+channel-type.gree.air.description = Schaltet das Ger\ufffdt in den L\ufffdftermodus (keine K\ufffdhlung). Verf\ufffdgbarkeit ist abh\ufffdngig vom Ger\ufffdtemodell.\n+channel-type.gree.dry.label = Trocknen\n+channel-type.gree.dry.description = Schaltet den Trocknungsmodus ein/aus. . Verf\ufffdgbarkeit ist abh\ufffdngig vom Ger\ufffdtemodell.\n+channel-type.gree.health.label = Heizen\n+channel-type.gree.health.description = Schaltet die Heizfunktion ein/aus. Verf\ufffdgbarkeit ist abh\ufffdngig vom Ger\ufffdtemodell.\n+channel-type.gree.dry.label = Turbo-Modus", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4NDM0Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            channel-type.gree.windspeed.description = Geschwindigkeit der Ventilation: 0:Auto, 1=niedrig, 2: langsam, 3: mittel, 4: schneller, 5: hoch. Verf\ufffdgbarkeit der Geschwindigkeitsstufen ist abh\ufffdngig vom Ger\ufffdtemodell.\n          \n          \n            \n            channel-type.gree.windspeed.description = Geschwindigkeit der Ventilation: 0:Auto, 1: niedrig, 2: langsam, 3: mittel, 4: schneller, 5: hoch. Verf\ufffdgbarkeit der Geschwindigkeitsstufen ist abh\ufffdngig vom Ger\ufffdtemodell.", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432884347", "createdAt": "2020-05-30T20:19:40Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/resources/ESH-INF/i18n/gree_de.properties", "diffHunk": "@@ -0,0 +1,65 @@\n+# GREE Binding\n+binding.gree.name = GREE Binding\n+binding.gree.description = Dieses Binding integriert Klimaanlagen der Marke GREE\n+\n+# thing types\n+thing-type.gree.airconditioner.label = Klimaanlage\n+thing-type.gree.airconditioner.description = Eine GREE Klimaanlage mit WiFi Modul\n+\n+# thing type config description\n+thing-type.config.gree.airconditioner.ipAddress.label = IP Adresse\n+thing-type.config.gree.airconditioner.ipAddress.description = IP Adresse des GREE-Ger\ufffdtes.\n+thing-type.config.gree.airconditioner.broadcastAddress.label = IP Broadcast-Adresse\n+thing-type.config.gree.airconditioner.broadcastAddress.description = Broadcast IP Adresse des lokalen Subnetzes.\n+thing-type.config.gree.airconditioner.refresh.label = Aktualisierungsintervall\n+thing-type.config.gree.airconditioner.refresh.description = Intervall, in dem der Status des Ger\ufffdtes aktualisiert wird.\n+\n+\n+# channel types\n+channel-type.gree.power.label = Betrieb\n+channel-type.gree.power.description = Schaltet das Ger\ufffdt ein/aus.\n+channel-type.gree.mode.label = Betriebsmodus\n+channel-type.gree.mode.description = Betriebsmodus der Klimaanlage: 0: Auto, 1: K\ufffdhlen, 2: Trocknen, L\ufffdften: 3, Heizen: 4\n+channel-type.gree.mode.state.option.auto = Auto\n+channel-type.gree.mode.state.option.cool = K\ufffdhlen\n+channel-type.gree.mode.state.option.eco = Eco\n+channel-type.gree.mode.state.option.dry = DTrocknen\n+channel-type.gree.mode.state.option.fan = Ventilator\n+channel-type.gree.mode.state.option.turbo = Turbo\n+channel-type.gree.mode.state.option.heat = Heizen\n+channel-type.gree.mode.state.option.on = Ein\n+channel-type.gree.mode.state.option.off = Aus\n+channel-type.gree.mode.state.option.0 = Auto\n+channel-type.gree.mode.state.option.1 = K\ufffdhlen\n+channel-type.gree.mode.state.option.2 = Trocken\n+channel-type.gree.mode.state.option.3 = Ventilator\n+channel-type.gree.mode.state.option.4 = Heizen\n+channel-type.gree.air.label = L\ufffdftung\n+channel-type.gree.air.description = Schaltet das Ger\ufffdt in den L\ufffdftermodus (keine K\ufffdhlung). Verf\ufffdgbarkeit ist abh\ufffdngig vom Ger\ufffdtemodell.\n+channel-type.gree.dry.label = Trocknen\n+channel-type.gree.dry.description = Schaltet den Trocknungsmodus ein/aus. . Verf\ufffdgbarkeit ist abh\ufffdngig vom Ger\ufffdtemodell.\n+channel-type.gree.health.label = Heizen\n+channel-type.gree.health.description = Schaltet die Heizfunktion ein/aus. Verf\ufffdgbarkeit ist abh\ufffdngig vom Ger\ufffdtemodell.\n+channel-type.gree.dry.label = Turbo-Modus\n+channel-type.gree.dry.description = Schaltet den Turbomodus ein/aus. Verf\ufffdgbarkeit ist abh\ufffdngig vom Ger\ufffdtemodell.\n+channel-type.gree.temperature.label = Temperatur\n+channel-type.gree.temperature.description = Setzt die Ziel-Temperatur.\n+channel-type.gree.windspeed.label = L\ufffdftergeschwindigkeit\n+channel-type.gree.windspeed.description = Geschwindigkeit der Ventilation: 0:Auto, 1=niedrig, 2: langsam, 3: mittel, 4: schneller, 5: hoch. Verf\ufffdgbarkeit der Geschwindigkeitsstufen ist abh\ufffdngig vom Ger\ufffdtemodell.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4NDM3MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            channel-type.gree.windspeed.state.option.1 = Nierdrig\n          \n          \n            \n            channel-type.gree.windspeed.state.option.1 = Niedrig", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432884371", "createdAt": "2020-05-30T20:19:55Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/resources/ESH-INF/i18n/gree_de.properties", "diffHunk": "@@ -0,0 +1,65 @@\n+# GREE Binding\n+binding.gree.name = GREE Binding\n+binding.gree.description = Dieses Binding integriert Klimaanlagen der Marke GREE\n+\n+# thing types\n+thing-type.gree.airconditioner.label = Klimaanlage\n+thing-type.gree.airconditioner.description = Eine GREE Klimaanlage mit WiFi Modul\n+\n+# thing type config description\n+thing-type.config.gree.airconditioner.ipAddress.label = IP Adresse\n+thing-type.config.gree.airconditioner.ipAddress.description = IP Adresse des GREE-Ger\ufffdtes.\n+thing-type.config.gree.airconditioner.broadcastAddress.label = IP Broadcast-Adresse\n+thing-type.config.gree.airconditioner.broadcastAddress.description = Broadcast IP Adresse des lokalen Subnetzes.\n+thing-type.config.gree.airconditioner.refresh.label = Aktualisierungsintervall\n+thing-type.config.gree.airconditioner.refresh.description = Intervall, in dem der Status des Ger\ufffdtes aktualisiert wird.\n+\n+\n+# channel types\n+channel-type.gree.power.label = Betrieb\n+channel-type.gree.power.description = Schaltet das Ger\ufffdt ein/aus.\n+channel-type.gree.mode.label = Betriebsmodus\n+channel-type.gree.mode.description = Betriebsmodus der Klimaanlage: 0: Auto, 1: K\ufffdhlen, 2: Trocknen, L\ufffdften: 3, Heizen: 4\n+channel-type.gree.mode.state.option.auto = Auto\n+channel-type.gree.mode.state.option.cool = K\ufffdhlen\n+channel-type.gree.mode.state.option.eco = Eco\n+channel-type.gree.mode.state.option.dry = DTrocknen\n+channel-type.gree.mode.state.option.fan = Ventilator\n+channel-type.gree.mode.state.option.turbo = Turbo\n+channel-type.gree.mode.state.option.heat = Heizen\n+channel-type.gree.mode.state.option.on = Ein\n+channel-type.gree.mode.state.option.off = Aus\n+channel-type.gree.mode.state.option.0 = Auto\n+channel-type.gree.mode.state.option.1 = K\ufffdhlen\n+channel-type.gree.mode.state.option.2 = Trocken\n+channel-type.gree.mode.state.option.3 = Ventilator\n+channel-type.gree.mode.state.option.4 = Heizen\n+channel-type.gree.air.label = L\ufffdftung\n+channel-type.gree.air.description = Schaltet das Ger\ufffdt in den L\ufffdftermodus (keine K\ufffdhlung). Verf\ufffdgbarkeit ist abh\ufffdngig vom Ger\ufffdtemodell.\n+channel-type.gree.dry.label = Trocknen\n+channel-type.gree.dry.description = Schaltet den Trocknungsmodus ein/aus. . Verf\ufffdgbarkeit ist abh\ufffdngig vom Ger\ufffdtemodell.\n+channel-type.gree.health.label = Heizen\n+channel-type.gree.health.description = Schaltet die Heizfunktion ein/aus. Verf\ufffdgbarkeit ist abh\ufffdngig vom Ger\ufffdtemodell.\n+channel-type.gree.dry.label = Turbo-Modus\n+channel-type.gree.dry.description = Schaltet den Turbomodus ein/aus. Verf\ufffdgbarkeit ist abh\ufffdngig vom Ger\ufffdtemodell.\n+channel-type.gree.temperature.label = Temperatur\n+channel-type.gree.temperature.description = Setzt die Ziel-Temperatur.\n+channel-type.gree.windspeed.label = L\ufffdftergeschwindigkeit\n+channel-type.gree.windspeed.description = Geschwindigkeit der Ventilation: 0:Auto, 1=niedrig, 2: langsam, 3: mittel, 4: schneller, 5: hoch. Verf\ufffdgbarkeit der Geschwindigkeitsstufen ist abh\ufffdngig vom Ger\ufffdtemodell.\n+channel-type.gree.windspeed.state.option.0 = Auto\n+channel-type.gree.windspeed.state.option.1 = Nierdrig", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4NDQxOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            channel-type.gree.temperature.description = Setzt die Ziel-Temperatur.\n          \n          \n            \n            channel-type.gree.temperature.description = Setzt die Solltemperatur.", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432884419", "createdAt": "2020-05-30T20:20:22Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/resources/ESH-INF/i18n/gree_de.properties", "diffHunk": "@@ -0,0 +1,65 @@\n+# GREE Binding\n+binding.gree.name = GREE Binding\n+binding.gree.description = Dieses Binding integriert Klimaanlagen der Marke GREE\n+\n+# thing types\n+thing-type.gree.airconditioner.label = Klimaanlage\n+thing-type.gree.airconditioner.description = Eine GREE Klimaanlage mit WiFi Modul\n+\n+# thing type config description\n+thing-type.config.gree.airconditioner.ipAddress.label = IP Adresse\n+thing-type.config.gree.airconditioner.ipAddress.description = IP Adresse des GREE-Ger\ufffdtes.\n+thing-type.config.gree.airconditioner.broadcastAddress.label = IP Broadcast-Adresse\n+thing-type.config.gree.airconditioner.broadcastAddress.description = Broadcast IP Adresse des lokalen Subnetzes.\n+thing-type.config.gree.airconditioner.refresh.label = Aktualisierungsintervall\n+thing-type.config.gree.airconditioner.refresh.description = Intervall, in dem der Status des Ger\ufffdtes aktualisiert wird.\n+\n+\n+# channel types\n+channel-type.gree.power.label = Betrieb\n+channel-type.gree.power.description = Schaltet das Ger\ufffdt ein/aus.\n+channel-type.gree.mode.label = Betriebsmodus\n+channel-type.gree.mode.description = Betriebsmodus der Klimaanlage: 0: Auto, 1: K\ufffdhlen, 2: Trocknen, L\ufffdften: 3, Heizen: 4\n+channel-type.gree.mode.state.option.auto = Auto\n+channel-type.gree.mode.state.option.cool = K\ufffdhlen\n+channel-type.gree.mode.state.option.eco = Eco\n+channel-type.gree.mode.state.option.dry = DTrocknen\n+channel-type.gree.mode.state.option.fan = Ventilator\n+channel-type.gree.mode.state.option.turbo = Turbo\n+channel-type.gree.mode.state.option.heat = Heizen\n+channel-type.gree.mode.state.option.on = Ein\n+channel-type.gree.mode.state.option.off = Aus\n+channel-type.gree.mode.state.option.0 = Auto\n+channel-type.gree.mode.state.option.1 = K\ufffdhlen\n+channel-type.gree.mode.state.option.2 = Trocken\n+channel-type.gree.mode.state.option.3 = Ventilator\n+channel-type.gree.mode.state.option.4 = Heizen\n+channel-type.gree.air.label = L\ufffdftung\n+channel-type.gree.air.description = Schaltet das Ger\ufffdt in den L\ufffdftermodus (keine K\ufffdhlung). Verf\ufffdgbarkeit ist abh\ufffdngig vom Ger\ufffdtemodell.\n+channel-type.gree.dry.label = Trocknen\n+channel-type.gree.dry.description = Schaltet den Trocknungsmodus ein/aus. . Verf\ufffdgbarkeit ist abh\ufffdngig vom Ger\ufffdtemodell.\n+channel-type.gree.health.label = Heizen\n+channel-type.gree.health.description = Schaltet die Heizfunktion ein/aus. Verf\ufffdgbarkeit ist abh\ufffdngig vom Ger\ufffdtemodell.\n+channel-type.gree.dry.label = Turbo-Modus\n+channel-type.gree.dry.description = Schaltet den Turbomodus ein/aus. Verf\ufffdgbarkeit ist abh\ufffdngig vom Ger\ufffdtemodell.\n+channel-type.gree.temperature.label = Temperatur\n+channel-type.gree.temperature.description = Setzt die Ziel-Temperatur.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4NDUyMw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t<option value=\"ont\">ON</option>\n          \n          \n            \n            \t\t\t\t<option value=\"on\">ON</option>", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432884523", "createdAt": "2020-05-30T20:22:00Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,137 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"gree\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"airconditioner\">\n+\t\t<label>GREE Air Conditioner</label>\n+\t\t<description>This Thing represents a GREE Air Conditioner</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"power\" typeId=\"system.power\" />\n+\t\t\t<channel id=\"mode\" typeId=\"mode\" />\n+\t\t\t<channel id=\"temperature\" typeId=\"temperature\" />\n+\t\t\t<channel id=\"air\" typeId=\"air\" />\n+\t\t\t<channel id=\"dry\" typeId=\"dry\" />\n+\t\t\t<channel id=\"turbo\" typeId=\"turbo\" />\n+\t\t\t<channel id=\"windspeed\" typeId=\"windspeed\" />\n+\t\t\t<channel id=\"swingvertical\" typeId=\"swingvertical\" />\n+\t\t\t<channel id=\"powersave\" typeId=\"powersave\" />\n+\t\t\t<channel id=\"light\" typeId=\"light\" />\n+\t\t\t<channel id=\"health\" typeId=\"health\" />\n+\t\t</channels>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"ipAddress\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Device IP Address</label>\n+\t\t\t\t<description>IP-Address of the GREE device.</description>\n+\t\t\t\t<context>network-address</context>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"broadcastAddress\" type=\"text\" required=\"false\">\n+\t\t\t\t<label>Subnet Broadcast Address</label>\n+\t\t\t\t<description>Broadcast IP address of the local subnet.</description>\n+\t\t\t\t<context>network-address</context>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refresh\" type=\"integer\" required=\"true\" unit=\"s\">\n+\t\t\t\t<label>Update Interval</label>\n+\t\t\t\t<description>Interval to query an update from the device.</description>\n+\t\t\t\t<default>60</default>\n+\t\t\t\t<unitLabel>seconds</unitLabel>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\n+\t</thing-type>\n+\n+\t<channel-type id=\"mode\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Mode</label>\n+\t\t<description>Sets the operating mode of the Air Conditioner - one of auto/cool/dry/fan/heat/eco/turbo or 0/1/2/3/4 or on/off</description>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"auto\">Auto</option>\n+\t\t\t\t<option value=\"cool\">Cool</option>\n+\t\t\t\t<option value=\"eco\">Eco</option>\n+\t\t\t\t<option value=\"dry\">Dry</option>\n+\t\t\t\t<option value=\"fan\">Fan</option>\n+\t\t\t\t<option value=\"turbo\">Turbo</option>\n+\t\t\t\t<option value=\"heat\">Heat</option>\n+\t\t\t\t<option value=\"ont\">ON</option>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4NDczOQ==", "bodyText": "Actually you don't need to add english \"translations\" to this file, which are already contained in the XML files.", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432884739", "createdAt": "2020-05-30T20:24:56Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/resources/ESH-INF/i18n/gree.properties", "diffHunk": "@@ -0,0 +1,64 @@\n+# GREE Binding", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4NDgwNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t<description>Sets the vertical swing action on the Air Conditioner: Full Swing: 1, Up: 2, MidUp: 3, Mid: 4, Mid Down: 5, Down : 6</description>\n          \n          \n            \n            \t\t<description>Sets the vertical swing action on the Air Conditioner: Full Swing: 1, Up: 2, MidUp: 3, Mid: 4, Mid Down: 5, Down: 6</description>", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432884805", "createdAt": "2020-05-30T20:25:42Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,137 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"gree\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"airconditioner\">\n+\t\t<label>GREE Air Conditioner</label>\n+\t\t<description>This Thing represents a GREE Air Conditioner</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"power\" typeId=\"system.power\" />\n+\t\t\t<channel id=\"mode\" typeId=\"mode\" />\n+\t\t\t<channel id=\"temperature\" typeId=\"temperature\" />\n+\t\t\t<channel id=\"air\" typeId=\"air\" />\n+\t\t\t<channel id=\"dry\" typeId=\"dry\" />\n+\t\t\t<channel id=\"turbo\" typeId=\"turbo\" />\n+\t\t\t<channel id=\"windspeed\" typeId=\"windspeed\" />\n+\t\t\t<channel id=\"swingvertical\" typeId=\"swingvertical\" />\n+\t\t\t<channel id=\"powersave\" typeId=\"powersave\" />\n+\t\t\t<channel id=\"light\" typeId=\"light\" />\n+\t\t\t<channel id=\"health\" typeId=\"health\" />\n+\t\t</channels>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"ipAddress\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Device IP Address</label>\n+\t\t\t\t<description>IP-Address of the GREE device.</description>\n+\t\t\t\t<context>network-address</context>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"broadcastAddress\" type=\"text\" required=\"false\">\n+\t\t\t\t<label>Subnet Broadcast Address</label>\n+\t\t\t\t<description>Broadcast IP address of the local subnet.</description>\n+\t\t\t\t<context>network-address</context>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refresh\" type=\"integer\" required=\"true\" unit=\"s\">\n+\t\t\t\t<label>Update Interval</label>\n+\t\t\t\t<description>Interval to query an update from the device.</description>\n+\t\t\t\t<default>60</default>\n+\t\t\t\t<unitLabel>seconds</unitLabel>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\n+\t</thing-type>\n+\n+\t<channel-type id=\"mode\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Mode</label>\n+\t\t<description>Sets the operating mode of the Air Conditioner - one of auto/cool/dry/fan/heat/eco/turbo or 0/1/2/3/4 or on/off</description>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"auto\">Auto</option>\n+\t\t\t\t<option value=\"cool\">Cool</option>\n+\t\t\t\t<option value=\"eco\">Eco</option>\n+\t\t\t\t<option value=\"dry\">Dry</option>\n+\t\t\t\t<option value=\"fan\">Fan</option>\n+\t\t\t\t<option value=\"turbo\">Turbo</option>\n+\t\t\t\t<option value=\"heat\">Heat</option>\n+\t\t\t\t<option value=\"ont\">ON</option>\n+\t\t\t\t<option value=\"off\">OFF</option>\n+\t\t\t\t<option value=\"0\">Auto</option>\n+\t\t\t\t<option value=\"1\">Cool</option>\n+\t\t\t\t<option value=\"2\">Dry</option>\n+\t\t\t\t<option value=\"3\">Fan</option>\n+\t\t\t\t<option value=\"4\">Heat</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"turbo\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Turbo</label>\n+\t\t<description>Set on/off the Air Conditioner's Turbo mode.</description>\n+\t</channel-type>\n+\t<channel-type id=\"air\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Air</label>\n+\t\t<description>Set on/off the Air Conditioner's Air function if applicable to the Air Conditioner model.</description>\n+\t</channel-type>\n+\t<channel-type id=\"dry\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Dry</label>\n+\t\t<description>Set on/off the Air Conditioner's Dry function if applicable to the Air Conditioner model .</description>\n+\t</channel-type>\n+\t<channel-type id=\"temperature\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Temperature</label>\n+\t\t<description>Sets the desired room temperature</description>\n+\t</channel-type>\n+\t<channel-type id=\"windspeed\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Wind Speed</label>\n+\t\t<description>Sets the fan speed on the Air conditioner: Auto:0, Low:1, MidLow:2, Mid:3, MidHigh:4, High:5. The number of speeds depends on the Air Conditioner model.</description>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"0\">Auto</option>\n+\t\t\t\t<option value=\"1\">Low</option>\n+\t\t\t\t<option value=\"2\">MidLow</option>\n+\t\t\t\t<option value=\"3\">Mid</option>\n+\t\t\t\t<option value=\"4\">MidHigh</option>\n+\t\t\t\t<option value=\"5\">High</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"health\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Health</label>\n+\t\t<description>Set on/off the Air Conditioner's Health function if applicable to the Air Conditioner model.</description>\n+\t</channel-type>\n+\n+\t<channel-type id=\"swingvertical\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Swing Vertical</label>\n+\t\t<description>Sets the vertical swing action on the Air Conditioner: Full Swing: 1, Up: 2, MidUp: 3, Mid: 4, Mid Down: 5, Down : 6</description>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4NDgzNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t<option value=\"Upl\">2</option>\n          \n          \n            \n            \t\t\t\t<option value=\"Up\">2</option>", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432884836", "createdAt": "2020-05-30T20:26:05Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,137 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"gree\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"airconditioner\">\n+\t\t<label>GREE Air Conditioner</label>\n+\t\t<description>This Thing represents a GREE Air Conditioner</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"power\" typeId=\"system.power\" />\n+\t\t\t<channel id=\"mode\" typeId=\"mode\" />\n+\t\t\t<channel id=\"temperature\" typeId=\"temperature\" />\n+\t\t\t<channel id=\"air\" typeId=\"air\" />\n+\t\t\t<channel id=\"dry\" typeId=\"dry\" />\n+\t\t\t<channel id=\"turbo\" typeId=\"turbo\" />\n+\t\t\t<channel id=\"windspeed\" typeId=\"windspeed\" />\n+\t\t\t<channel id=\"swingvertical\" typeId=\"swingvertical\" />\n+\t\t\t<channel id=\"powersave\" typeId=\"powersave\" />\n+\t\t\t<channel id=\"light\" typeId=\"light\" />\n+\t\t\t<channel id=\"health\" typeId=\"health\" />\n+\t\t</channels>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"ipAddress\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Device IP Address</label>\n+\t\t\t\t<description>IP-Address of the GREE device.</description>\n+\t\t\t\t<context>network-address</context>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"broadcastAddress\" type=\"text\" required=\"false\">\n+\t\t\t\t<label>Subnet Broadcast Address</label>\n+\t\t\t\t<description>Broadcast IP address of the local subnet.</description>\n+\t\t\t\t<context>network-address</context>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refresh\" type=\"integer\" required=\"true\" unit=\"s\">\n+\t\t\t\t<label>Update Interval</label>\n+\t\t\t\t<description>Interval to query an update from the device.</description>\n+\t\t\t\t<default>60</default>\n+\t\t\t\t<unitLabel>seconds</unitLabel>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\n+\t</thing-type>\n+\n+\t<channel-type id=\"mode\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Mode</label>\n+\t\t<description>Sets the operating mode of the Air Conditioner - one of auto/cool/dry/fan/heat/eco/turbo or 0/1/2/3/4 or on/off</description>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"auto\">Auto</option>\n+\t\t\t\t<option value=\"cool\">Cool</option>\n+\t\t\t\t<option value=\"eco\">Eco</option>\n+\t\t\t\t<option value=\"dry\">Dry</option>\n+\t\t\t\t<option value=\"fan\">Fan</option>\n+\t\t\t\t<option value=\"turbo\">Turbo</option>\n+\t\t\t\t<option value=\"heat\">Heat</option>\n+\t\t\t\t<option value=\"ont\">ON</option>\n+\t\t\t\t<option value=\"off\">OFF</option>\n+\t\t\t\t<option value=\"0\">Auto</option>\n+\t\t\t\t<option value=\"1\">Cool</option>\n+\t\t\t\t<option value=\"2\">Dry</option>\n+\t\t\t\t<option value=\"3\">Fan</option>\n+\t\t\t\t<option value=\"4\">Heat</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"turbo\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Turbo</label>\n+\t\t<description>Set on/off the Air Conditioner's Turbo mode.</description>\n+\t</channel-type>\n+\t<channel-type id=\"air\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Air</label>\n+\t\t<description>Set on/off the Air Conditioner's Air function if applicable to the Air Conditioner model.</description>\n+\t</channel-type>\n+\t<channel-type id=\"dry\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Dry</label>\n+\t\t<description>Set on/off the Air Conditioner's Dry function if applicable to the Air Conditioner model .</description>\n+\t</channel-type>\n+\t<channel-type id=\"temperature\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Temperature</label>\n+\t\t<description>Sets the desired room temperature</description>\n+\t</channel-type>\n+\t<channel-type id=\"windspeed\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Wind Speed</label>\n+\t\t<description>Sets the fan speed on the Air conditioner: Auto:0, Low:1, MidLow:2, Mid:3, MidHigh:4, High:5. The number of speeds depends on the Air Conditioner model.</description>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"0\">Auto</option>\n+\t\t\t\t<option value=\"1\">Low</option>\n+\t\t\t\t<option value=\"2\">MidLow</option>\n+\t\t\t\t<option value=\"3\">Mid</option>\n+\t\t\t\t<option value=\"4\">MidHigh</option>\n+\t\t\t\t<option value=\"5\">High</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"health\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Health</label>\n+\t\t<description>Set on/off the Air Conditioner's Health function if applicable to the Air Conditioner model.</description>\n+\t</channel-type>\n+\n+\t<channel-type id=\"swingvertical\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Swing Vertical</label>\n+\t\t<description>Sets the vertical swing action on the Air Conditioner: Full Swing: 1, Up: 2, MidUp: 3, Mid: 4, Mid Down: 5, Down : 6</description>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"Full\">1</option>\n+\t\t\t\t<option value=\"Upl\">2</option>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4NDk4MA==", "bodyText": "I think you interchanged numbers and texts here.", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432884980", "createdAt": "2020-05-30T20:28:27Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,137 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"gree\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"airconditioner\">\n+\t\t<label>GREE Air Conditioner</label>\n+\t\t<description>This Thing represents a GREE Air Conditioner</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"power\" typeId=\"system.power\" />\n+\t\t\t<channel id=\"mode\" typeId=\"mode\" />\n+\t\t\t<channel id=\"temperature\" typeId=\"temperature\" />\n+\t\t\t<channel id=\"air\" typeId=\"air\" />\n+\t\t\t<channel id=\"dry\" typeId=\"dry\" />\n+\t\t\t<channel id=\"turbo\" typeId=\"turbo\" />\n+\t\t\t<channel id=\"windspeed\" typeId=\"windspeed\" />\n+\t\t\t<channel id=\"swingvertical\" typeId=\"swingvertical\" />\n+\t\t\t<channel id=\"powersave\" typeId=\"powersave\" />\n+\t\t\t<channel id=\"light\" typeId=\"light\" />\n+\t\t\t<channel id=\"health\" typeId=\"health\" />\n+\t\t</channels>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"ipAddress\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Device IP Address</label>\n+\t\t\t\t<description>IP-Address of the GREE device.</description>\n+\t\t\t\t<context>network-address</context>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"broadcastAddress\" type=\"text\" required=\"false\">\n+\t\t\t\t<label>Subnet Broadcast Address</label>\n+\t\t\t\t<description>Broadcast IP address of the local subnet.</description>\n+\t\t\t\t<context>network-address</context>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refresh\" type=\"integer\" required=\"true\" unit=\"s\">\n+\t\t\t\t<label>Update Interval</label>\n+\t\t\t\t<description>Interval to query an update from the device.</description>\n+\t\t\t\t<default>60</default>\n+\t\t\t\t<unitLabel>seconds</unitLabel>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\n+\t</thing-type>\n+\n+\t<channel-type id=\"mode\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Mode</label>\n+\t\t<description>Sets the operating mode of the Air Conditioner - one of auto/cool/dry/fan/heat/eco/turbo or 0/1/2/3/4 or on/off</description>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"auto\">Auto</option>\n+\t\t\t\t<option value=\"cool\">Cool</option>\n+\t\t\t\t<option value=\"eco\">Eco</option>\n+\t\t\t\t<option value=\"dry\">Dry</option>\n+\t\t\t\t<option value=\"fan\">Fan</option>\n+\t\t\t\t<option value=\"turbo\">Turbo</option>\n+\t\t\t\t<option value=\"heat\">Heat</option>\n+\t\t\t\t<option value=\"ont\">ON</option>\n+\t\t\t\t<option value=\"off\">OFF</option>\n+\t\t\t\t<option value=\"0\">Auto</option>\n+\t\t\t\t<option value=\"1\">Cool</option>\n+\t\t\t\t<option value=\"2\">Dry</option>\n+\t\t\t\t<option value=\"3\">Fan</option>\n+\t\t\t\t<option value=\"4\">Heat</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"turbo\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Turbo</label>\n+\t\t<description>Set on/off the Air Conditioner's Turbo mode.</description>\n+\t</channel-type>\n+\t<channel-type id=\"air\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Air</label>\n+\t\t<description>Set on/off the Air Conditioner's Air function if applicable to the Air Conditioner model.</description>\n+\t</channel-type>\n+\t<channel-type id=\"dry\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Dry</label>\n+\t\t<description>Set on/off the Air Conditioner's Dry function if applicable to the Air Conditioner model .</description>\n+\t</channel-type>\n+\t<channel-type id=\"temperature\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Temperature</label>\n+\t\t<description>Sets the desired room temperature</description>\n+\t</channel-type>\n+\t<channel-type id=\"windspeed\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Wind Speed</label>\n+\t\t<description>Sets the fan speed on the Air conditioner: Auto:0, Low:1, MidLow:2, Mid:3, MidHigh:4, High:5. The number of speeds depends on the Air Conditioner model.</description>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"0\">Auto</option>\n+\t\t\t\t<option value=\"1\">Low</option>\n+\t\t\t\t<option value=\"2\">MidLow</option>\n+\t\t\t\t<option value=\"3\">Mid</option>\n+\t\t\t\t<option value=\"4\">MidHigh</option>\n+\t\t\t\t<option value=\"5\">High</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"health\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Health</label>\n+\t\t<description>Set on/off the Air Conditioner's Health function if applicable to the Air Conditioner model.</description>\n+\t</channel-type>\n+\n+\t<channel-type id=\"swingvertical\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Swing Vertical</label>\n+\t\t<description>Sets the vertical swing action on the Air Conditioner: Full Swing: 1, Up: 2, MidUp: 3, Mid: 4, Mid Down: 5, Down : 6</description>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"Full\">1</option>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4NTE5MA==", "bodyText": "Can you mention which of the three variants (auto/cool/eco/dry/fan/turboheat OR on/off OR 0-4) is used, when the status is read from the AC?", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432885190", "createdAt": "2020-05-30T20:31:59Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/README.md", "diffHunk": "@@ -0,0 +1,139 @@\n+# GREE Binding\n+\n+This binding integrates GREE Air Conditioners.\n+\n+Note : The GREE Air Conditioner must already be setup on the WiFi network and must have a fixed IP Address.\n+\n+## Supported Things\n+\n+This binding supports one Thing type `airconditioner`.\n+\n+## Discovery\n+\n+Once the GREE is on the network (WiFi active) it could be discovery automatically.\n+An IP broadcast message is sent and every responding units gets added to the Inbox. \n+\n+## Binding Configuration\n+\n+No binding configuration is required.\n+\n+#### Manual Thing Creation\n+\n+Fans can be manually created in the *PaperUI* or *HABmin*, or by placing a *.things* file in the *conf/things* directory.  See example below.\n+\n+\n+## Thing Configuration\n+\n+The Air Conditioner's IP address is mandantory, all other parameters are optional. \n+If the broadcast is not set (default) it will be derived from openHAB's network setting (PaperUI:Configuration:System:Network Settings). \n+Change this only for good reasons.\n+\n+## Channels\n+\n+The following channels are supported for fans:\n+\n+| Channel Name  | Item Type | Description                                                                                       |\n+|---------------|-----------|---------------------------------------------------------------------------------------------------|\n+| power         | Switch    | Power on/off the Air Conditioner                                                                  |\n+| mode          | String    | Sets the operating mode of the Air Conditioner                                                    |\n+|               |           | Mode can be one of auto/cool/eco/dry/fan/turboheat or on/off                                      |\n+|               |\u00a0          | You could also send \"0\"..\"4\", which will be send transparent to the device:                       |\n+|               |           | those map to: \"0\"=Auto, \"1\"=Cool, \"2\"=Dry, \"3\"=Fan only, \"4\"=heat                                 | \n+|               |           | Check the Air Conditioner's operating manual for supported modes.                                 |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4NTI5OQ==", "bodyText": "You could use Units of Measure here and add a state tag: https://www.openhab.org/docs/developer/bindings/thing-xml.html#state-description\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t<item-type>Number</item-type>\n          \n          \n            \n            \t\t<item-type>Number:Temperature</item-type>", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r432885299", "createdAt": "2020-05-30T20:34:07Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,137 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"gree\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"airconditioner\">\n+\t\t<label>GREE Air Conditioner</label>\n+\t\t<description>This Thing represents a GREE Air Conditioner</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"power\" typeId=\"system.power\" />\n+\t\t\t<channel id=\"mode\" typeId=\"mode\" />\n+\t\t\t<channel id=\"temperature\" typeId=\"temperature\" />\n+\t\t\t<channel id=\"air\" typeId=\"air\" />\n+\t\t\t<channel id=\"dry\" typeId=\"dry\" />\n+\t\t\t<channel id=\"turbo\" typeId=\"turbo\" />\n+\t\t\t<channel id=\"windspeed\" typeId=\"windspeed\" />\n+\t\t\t<channel id=\"swingvertical\" typeId=\"swingvertical\" />\n+\t\t\t<channel id=\"powersave\" typeId=\"powersave\" />\n+\t\t\t<channel id=\"light\" typeId=\"light\" />\n+\t\t\t<channel id=\"health\" typeId=\"health\" />\n+\t\t</channels>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"ipAddress\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Device IP Address</label>\n+\t\t\t\t<description>IP-Address of the GREE device.</description>\n+\t\t\t\t<context>network-address</context>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"broadcastAddress\" type=\"text\" required=\"false\">\n+\t\t\t\t<label>Subnet Broadcast Address</label>\n+\t\t\t\t<description>Broadcast IP address of the local subnet.</description>\n+\t\t\t\t<context>network-address</context>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"refresh\" type=\"integer\" required=\"true\" unit=\"s\">\n+\t\t\t\t<label>Update Interval</label>\n+\t\t\t\t<description>Interval to query an update from the device.</description>\n+\t\t\t\t<default>60</default>\n+\t\t\t\t<unitLabel>seconds</unitLabel>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\n+\t</thing-type>\n+\n+\t<channel-type id=\"mode\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>Mode</label>\n+\t\t<description>Sets the operating mode of the Air Conditioner - one of auto/cool/dry/fan/heat/eco/turbo or 0/1/2/3/4 or on/off</description>\n+\t\t<state>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"auto\">Auto</option>\n+\t\t\t\t<option value=\"cool\">Cool</option>\n+\t\t\t\t<option value=\"eco\">Eco</option>\n+\t\t\t\t<option value=\"dry\">Dry</option>\n+\t\t\t\t<option value=\"fan\">Fan</option>\n+\t\t\t\t<option value=\"turbo\">Turbo</option>\n+\t\t\t\t<option value=\"heat\">Heat</option>\n+\t\t\t\t<option value=\"ont\">ON</option>\n+\t\t\t\t<option value=\"off\">OFF</option>\n+\t\t\t\t<option value=\"0\">Auto</option>\n+\t\t\t\t<option value=\"1\">Cool</option>\n+\t\t\t\t<option value=\"2\">Dry</option>\n+\t\t\t\t<option value=\"3\">Fan</option>\n+\t\t\t\t<option value=\"4\">Heat</option>\n+\t\t\t</options>\n+\t\t</state>\n+\t</channel-type>\n+\t<channel-type id=\"turbo\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Turbo</label>\n+\t\t<description>Set on/off the Air Conditioner's Turbo mode.</description>\n+\t</channel-type>\n+\t<channel-type id=\"air\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Air</label>\n+\t\t<description>Set on/off the Air Conditioner's Air function if applicable to the Air Conditioner model.</description>\n+\t</channel-type>\n+\t<channel-type id=\"dry\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>Dry</label>\n+\t\t<description>Set on/off the Air Conditioner's Dry function if applicable to the Air Conditioner model .</description>\n+\t</channel-type>\n+\t<channel-type id=\"temperature\">\n+\t\t<item-type>Number</item-type>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 86}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "736354bb1824c289f996951da7a35d8e1ce71f31", "author": {"user": {"login": "markus7017", "name": "Markus Michels"}}, "url": "https://github.com/openhab/openhab-addons/commit/736354bb1824c289f996951da7a35d8e1ce71f31", "committedDate": "2020-06-02T19:54:34Z", "message": "various options descriptors added\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>"}, "afterCommit": {"oid": "6a486a9e70febf8869cc822d0821b2e98f651593", "author": {"user": {"login": "markus7017", "name": "Markus Michels"}}, "url": "https://github.com/openhab/openhab-addons/commit/6a486a9e70febf8869cc822d0821b2e98f651593", "committedDate": "2020-06-03T17:55:47Z", "message": "various options descriptors added\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ac59558a4da7a1aea9a453f4b4f19aa32b17082d", "author": {"user": {"login": "markus7017", "name": "Markus Michels"}}, "url": "https://github.com/openhab/openhab-addons/commit/ac59558a4da7a1aea9a453f4b4f19aa32b17082d", "committedDate": "2020-06-06T17:46:09Z", "message": "rebased\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "868041f5bce712be2f9226f7bfac337bcc1828e1", "author": {"user": {"login": "markus7017", "name": "Markus Michels"}}, "url": "https://github.com/openhab/openhab-addons/commit/868041f5bce712be2f9226f7bfac337bcc1828e1", "committedDate": "2020-06-06T17:46:09Z", "message": "re-factoring WIP\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ac3275408bb290d8a2d1a865e5ba3b4c2cc14af5", "author": {"user": {"login": "markus7017", "name": "Markus Michels"}}, "url": "https://github.com/openhab/openhab-addons/commit/ac3275408bb290d8a2d1a865e5ba3b4c2cc14af5", "committedDate": "2020-06-06T17:46:09Z", "message": "re-factoring WIP\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d087ba648e4fec06e9b1a126469d31c90712641f", "author": {"user": {"login": "markus7017", "name": "Markus Michels"}}, "url": "https://github.com/openhab/openhab-addons/commit/d087ba648e4fec06e9b1a126469d31c90712641f", "committedDate": "2020-06-06T17:46:09Z", "message": "re-factoring WIP\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "319b36723d354928fa58ec7b587d038489510819", "author": {"user": {"login": "markus7017", "name": "Markus Michels"}}, "url": "https://github.com/openhab/openhab-addons/commit/319b36723d354928fa58ec7b587d038489510819", "committedDate": "2020-06-06T17:46:09Z", "message": "re-factoring WIP\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "01bfa0b43edb2261deff1a9e4a100913767c6837", "author": {"user": {"login": "markus7017", "name": "Markus Michels"}}, "url": "https://github.com/openhab/openhab-addons/commit/01bfa0b43edb2261deff1a9e4a100913767c6837", "committedDate": "2020-06-06T17:46:09Z", "message": "German translation added, refactoring completed\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "912bf12a49c63c49622427bf1a64d08f7a9315cb", "author": {"user": {"login": "markus7017", "name": "Markus Michels"}}, "url": "https://github.com/openhab/openhab-addons/commit/912bf12a49c63c49622427bf1a64d08f7a9315cb", "committedDate": "2020-06-06T17:46:09Z", "message": "ignore SocketTimeoutException on background status refresh\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "de7d6e6d79c901f632fdfce09299c7627eb50890", "author": {"user": {"login": "markus7017", "name": "Markus Michels"}}, "url": "https://github.com/openhab/openhab-addons/commit/de7d6e6d79c901f632fdfce09299c7627eb50890", "committedDate": "2020-06-06T17:46:10Z", "message": "module re-added to pom.xml\ntimeout adjusted, translation corrected\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d1677a939c7500b07b48eac6136d156931aa8d34", "author": {"user": {"login": "markus7017", "name": "Markus Michels"}}, "url": "https://github.com/openhab/openhab-addons/commit/d1677a939c7500b07b48eac6136d156931aa8d34", "committedDate": "2020-06-06T17:46:10Z", "message": "review changes\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2f27216f0da11adb54fd84482aef9c133dab4653", "author": {"user": {"login": "markus7017", "name": "Markus Michels"}}, "url": "https://github.com/openhab/openhab-addons/commit/2f27216f0da11adb54fd84482aef9c133dab4653", "committedDate": "2020-06-06T17:46:10Z", "message": "Added translations for mode and windspeed values\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "10d3419989fbfdd001b09b1f62c5a61352ca2f01", "author": {"user": {"login": "markus7017", "name": "Markus Michels"}}, "url": "https://github.com/openhab/openhab-addons/commit/10d3419989fbfdd001b09b1f62c5a61352ca2f01", "committedDate": "2020-06-06T17:46:10Z", "message": "Support got Aircon model (thanks @piotras) Support Google GD commands on\nthe mode channel\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2a753b3e0b928e6080ea963a90169586e6c88a4f", "author": {"user": {"login": "markus7017", "name": "Markus Michels"}}, "url": "https://github.com/openhab/openhab-addons/commit/2a753b3e0b928e6080ea963a90169586e6c88a4f", "committedDate": "2020-06-06T17:46:10Z", "message": "Hungarian translation removed for now, seems to have some characterset\nissues\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ba6ad55c45f9d505893483913e71cfe4eb12dee7", "author": {"user": {"login": "markus7017", "name": "Markus Michels"}}, "url": "https://github.com/openhab/openhab-addons/commit/ba6ad55c45f9d505893483913e71cfe4eb12dee7", "committedDate": "2020-06-06T17:46:10Z", "message": "mode channel is now String (supports Number as backward compatibility)\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1b928a843a5c83f3dfb09066439e40d7425021d0", "author": {"user": {"login": "markus7017", "name": "Markus Michels"}}, "url": "https://github.com/openhab/openhab-addons/commit/1b928a843a5c83f3dfb09066439e40d7425021d0", "committedDate": "2020-06-06T17:46:10Z", "message": "naming of binding id and channel names adjusted\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9b1d436adda5d9c17440db094f82f92ff017ddd8", "author": {"user": {"login": "markus7017", "name": "Markus Michels"}}, "url": "https://github.com/openhab/openhab-addons/commit/9b1d436adda5d9c17440db094f82f92ff017ddd8", "committedDate": "2020-06-06T17:46:10Z", "message": "New channels swingLeftRight, quiet; channel swingvertical renamed to\nswingUpDown; README updated; changes driven by PR review\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "536dff441a4231662e76b8361a7c5f9215fbdc61", "author": {"user": {"login": "markus7017", "name": "Markus Michels"}}, "url": "https://github.com/openhab/openhab-addons/commit/536dff441a4231662e76b8361a7c5f9215fbdc61", "committedDate": "2020-06-06T17:46:10Z", "message": "review changes\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a3832334e0b5bddc53a3121463df0dc329c035ef", "author": {"user": {"login": "markus7017", "name": "Markus Michels"}}, "url": "https://github.com/openhab/openhab-addons/commit/a3832334e0b5bddc53a3121463df0dc329c035ef", "committedDate": "2020-06-06T17:46:10Z", "message": "more review changes\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "533e2362069146e21466d1e5161a1331514a4407", "author": {"user": {"login": "markus7017", "name": "Markus Michels"}}, "url": "https://github.com/openhab/openhab-addons/commit/533e2362069146e21466d1e5161a1331514a4407", "committedDate": "2020-06-06T17:46:10Z", "message": "getOnOffType() fixed\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0035358ca2c55385e43c8978905a423012fd5ba3", "author": {"user": {"login": "markus7017", "name": "Markus Michels"}}, "url": "https://github.com/openhab/openhab-addons/commit/0035358ca2c55385e43c8978905a423012fd5ba3", "committedDate": "2020-06-06T17:46:10Z", "message": "updated channel handling (support for UBM)\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "94fd14d821a6179d5278fb04c68fc4b438fbe62c", "author": {"user": {"login": "markus7017", "name": "Markus Michels"}}, "url": "https://github.com/openhab/openhab-addons/commit/94fd14d821a6179d5278fb04c68fc4b438fbe62c", "committedDate": "2020-06-06T17:46:10Z", "message": "various options descriptors added\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6a486a9e70febf8869cc822d0821b2e98f651593", "author": {"user": {"login": "markus7017", "name": "Markus Michels"}}, "url": "https://github.com/openhab/openhab-addons/commit/6a486a9e70febf8869cc822d0821b2e98f651593", "committedDate": "2020-06-03T17:55:47Z", "message": "various options descriptors added\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>"}, "afterCommit": {"oid": "94fd14d821a6179d5278fb04c68fc4b438fbe62c", "author": {"user": {"login": "markus7017", "name": "Markus Michels"}}, "url": "https://github.com/openhab/openhab-addons/commit/94fd14d821a6179d5278fb04c68fc4b438fbe62c", "committedDate": "2020-06-06T17:46:10Z", "message": "various options descriptors added\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b3df5cca635445fac9caa82d48591b8d52cd5907", "author": {"user": {"login": "markus7017", "name": "Markus Michels"}}, "url": "https://github.com/openhab/openhab-addons/commit/b3df5cca635445fac9caa82d48591b8d52cd5907", "committedDate": "2020-06-06T17:47:51Z", "message": "rebased to 2.5.6\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1846cc40776cb0d4ab98b6db903dbffb769ebd62", "author": {"user": {"login": "markus7017", "name": "Markus Michels"}}, "url": "https://github.com/openhab/openhab-addons/commit/1846cc40776cb0d4ab98b6db903dbffb769ebd62", "committedDate": "2020-06-06T18:02:03Z", "message": "review changes\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cd3073b907b96309c9ba0246aa74db523dedcddd", "author": {"user": {"login": "markus7017", "name": "Markus Michels"}}, "url": "https://github.com/openhab/openhab-addons/commit/cd3073b907b96309c9ba0246aa74db523dedcddd", "committedDate": "2020-06-07T09:19:34Z", "message": "review changes; GreeDiscovery class turned into a Component, but this\nnot working yet\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5f205c44fbeeb23b0bfbd3ed08d5e550355330ab", "author": {"user": {"login": "markus7017", "name": "Markus Michels"}}, "url": "https://github.com/openhab/openhab-addons/commit/5f205c44fbeeb23b0bfbd3ed08d5e550355330ab", "committedDate": "2020-06-07T11:48:49Z", "message": "various typos in language properties fixed; thing-type.xml uses @text/\nto reference language properties; quiet channel changed to\noff/auto/quiet rather than 0-2; README updated\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f39b4d2c64b1be550e3809943e3d6837fccda066", "author": {"user": {"login": "markus7017", "name": "Markus Michels"}}, "url": "https://github.com/openhab/openhab-addons/commit/f39b4d2c64b1be550e3809943e3d6837fccda066", "committedDate": "2020-06-07T11:55:36Z", "message": "replace StringUtils.isNumber() by native code\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1ODQ5MzU4", "url": "https://github.com/openhab/openhab-addons/pull/7504#pullrequestreview-425849358", "createdAt": "2020-06-07T20:07:32Z", "commit": {"oid": "f39b4d2c64b1be550e3809943e3d6837fccda066"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QyMDowNzozMlrOGgLkyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QyMDo1NDozNlrOGgLy_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM5NzI1OA==", "bodyText": "mark", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436397258", "createdAt": "2020-06-07T20:07:32Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/GreeHandlerFactory.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.i18n.LocaleProvider;\n+import org.eclipse.smarthome.core.i18n.TranslationProvider;\n+import org.eclipse.smarthome.core.net.NetworkAddressService;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.openhab.binding.gree.internal.handler.GreeHandler;\n+import org.osgi.service.component.ComponentContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link GreeHandlerFactory} is responsible for creating things and thing handlers.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+@Component(configurationPid = \"binding.\" + BINDING_ID, service = ThingHandlerFactory.class)\n+public class GreeHandlerFactory extends BaseThingHandlerFactory {\n+    private final GreeTranslationProvider messages;\n+    // private @Nullable ServiceRegistration<?> serviceRegistration;\n+\n+    @Activate\n+    public GreeHandlerFactory(@Reference NetworkAddressService networkAddressService,\n+            @Reference LocaleProvider localeProvider, @Reference TranslationProvider i18nProvider,\n+            ComponentContext componentContext, Map<String, Object> configProperties) {\n+        super.activate(componentContext);\n+        messages = new GreeTranslationProvider(bundleContext.getBundle(), i18nProvider, localeProvider);\n+        /*\n+         * GreeDiscoveryService discoveryService = new GreeDiscoveryService(bundleContext.getBundle(), messages,\n+         * defBroadcastIp);\n+         * this.serviceRegistration = bundleContext.registerService(DiscoveryService.class.getName(), discoveryService,\n+         * new Hashtable<String, Object>());\n+         */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f39b4d2c64b1be550e3809943e3d6837fccda066"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM5ODU5MQ==", "bodyText": "GreeException is never thrown, because it is catched in this method. So, the throws declaration can be removed.", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436398591", "createdAt": "2020-06-07T20:23:22Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeHandler.java", "diffHunk": "@@ -0,0 +1,439 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.net.DatagramSocket;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.gree.internal.GreeConfiguration;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.discovery.GreeAirDevice;\n+import org.openhab.binding.gree.internal.discovery.GreeDeviceFinder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link GreeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(GreeHandler.class);\n+    private final GreeTranslationProvider messages;\n+    private GreeConfiguration config = new GreeConfiguration();\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+    private GreeAirDevice device = new GreeAirDevice();\n+    private Optional<DatagramSocket> clientSocket = Optional.empty();\n+\n+    private @Nullable ScheduledFuture<?> refreshTask;\n+    private long lastRefreshTime = 0;\n+\n+    public GreeHandler(Thing thing, GreeTranslationProvider messages) {\n+        super(thing);\n+        this.messages = messages;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // logger.debug(\"Start initializing!\");\n+        config = getConfigAs(GreeConfiguration.class);\n+        logger.debug(\"Config for {} is {}\", thing.getUID(), config.toString());\n+        if (config.ipAddress.isEmpty() || (config.refresh < 0)) {\n+            logger.debug(\"Config of {} is invalid. Check configuration\", thing.getUID());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid configuration. Check thing configuration.\");\n+            return;\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.execute(() -> {\n+            initializeThing();\n+        });\n+    }\n+\n+    private void initializeThing() {\n+        logger.debug(\"Thing {} is initializing\", thing.getUID());\n+\n+        try {\n+            // Create a new Datagram socket with a specified timeout\n+            clientSocket = Optional.of(new DatagramSocket());\n+            if (!clientSocket.isPresent()) {\n+                logger.debug(\"Unable to create datagram socket, discovery aborted!\");\n+                return;\n+            }\n+            clientSocket.get().setSoTimeout(DATAGRAM_SOCKET_TIMEOUT);\n+\n+            // Find the GREE device\n+            deviceFinder = new GreeDeviceFinder(config.ipAddress);\n+            deviceFinder.scan(clientSocket, false);\n+            logger.debug(\"{} units found matching IP address\", deviceFinder.getScannedDeviceCount());\n+\n+            // Now check that this one is amongst the air conditioners that responded.\n+            GreeAirDevice newDevice = deviceFinder.getDeviceByIPAddress(config.ipAddress);\n+            if (newDevice != null) {\n+                // Ok, our device responded, now let's Bind with it\n+                device = newDevice;\n+                device.bindWithDevice(clientSocket);\n+                if (device.getIsBound()) {\n+                    logger.debug(\"GREE AirConditioner {} bound successful\", thing.getUID());\n+                    updateStatus(ThingStatus.ONLINE);\n+\n+                    // Start the automatic refresh cycles\n+                    startAutomaticRefresh();\n+                    return;\n+                }\n+            }\n+            logger.debug(\"GREE unit is not responding\");\n+        } catch (GreeException e) {\n+            logger.debug(\"Initialization failed: {}\", messages.get(\"thinginit.exception\", e.toString()));\n+        } catch (IOException | RuntimeException e) {\n+            logger.debug(\"Exception on inituialization\", e);\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            // The thing is updated by the scheduled automatic refresh so do nothing here.\n+        } else {\n+            if (!clientSocket.isPresent()) {\n+                logger.debug(\"Thing not properly initialized, abort command\");\n+                return;\n+            }\n+\n+            DatagramSocket socket = clientSocket.get();\n+            logger.debug(\"Issue command {}\u00a0to channe {}\", command, channelUID.getIdWithoutGroup());\n+            try {\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case MODE_CHANNEL:\n+                        handleModeCommand(command, socket);\n+                        break;\n+                    case POWER_CHANNEL:\n+                        device.setDevicePower(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case TURBO_CHANNEL:\n+                        device.setDeviceTurbo(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case LIGHT_CHANNEL:\n+                        device.setDeviceLight(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case TEMP_CHANNEL:\n+                        device.setDeviceTempSet(socket, ((DecimalType) command).intValue());\n+                        break;\n+                    case SWINGV_CHANNEL:\n+                        device.setDeviceSwingVertical(socket, ((DecimalType) command).intValue());\n+                        break;\n+                    case WINDSPEED_CHANNEL:\n+                        device.setDeviceWindspeed(socket, ((DecimalType) command).intValue());\n+                        break;\n+                    case AIR_CHANNEL:\n+                        device.setDeviceAir(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case DRY_CHANNEL:\n+                        device.setDeviceDry(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case HEALTH_CHANNEL:\n+                        device.setDeviceHealth(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case PWRSAV_CHANNEL:\n+                        device.setDevicePwrSaving(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                }\n+            } catch (GreeException e) {\n+                logger.debug(\"Unable to execute command {}\u00a0for channel {}: {}\", command, channelUID.getId(),\n+                        e.toString());\n+            } catch (RuntimeException e) {\n+                logger.debug(\"Unable to execute command {}\u00a0for channel {}\", command, channelUID.getId(), e);\n+            }\n+        }\n+    }\n+\n+    private void handleModeCommand(Command command, DatagramSocket socket) throws GreeException {\n+        int mode = -1;\n+        String modeStr = \"\";\n+        boolean isNumber = StringUtils.isNumeric(command.toString());\n+        if (command instanceof DecimalType) {\n+            // backward compatibility when channel was Number\n+            mode = ((DecimalType) command).intValue();\n+        } else if (command instanceof OnOffType) {\n+            // Switch\n+            logger.debug(\"Send Power-{}\", command);\n+            device.setDevicePower(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+        } else /* String */ {\n+            modeStr = command.toString().toLowerCase();\n+            switch (modeStr) {\n+                case MODE_AUTO:\n+                    mode = GREE_MODE_AUTO;\n+                    break;\n+                case MODE_COOL:\n+                    mode = GREE_MODE_COOL;\n+                    break;\n+                case MODE_HEAT:\n+                    mode = GREE_MODE_HEAT;\n+                    break;\n+                case MODE_DRY:\n+                    mode = GREE_MODE_DRY;\n+                    break;\n+                case MODE_FAN:\n+                case MODE_FAN2:\n+                    mode = GREE_MODE_FAN;\n+                    break;\n+                case MODE_ECO:\n+                    // power saving will be set after the uinit was turned on\n+                    mode = GREE_MODE_COOL;\n+                    break;\n+                case MODE_ON:\n+                case MODE_OFF:\n+                    device.setDevicePower(socket, modeStr.equals(MODE_ON) ? 1 : 0);\n+                    break;\n+                default:\n+                    if (isNumber) {\n+                        // Support selecting the mode by number, maybe specific models support\n+                        // additional modes\n+                        mode = Integer.parseInt(modeStr);\n+                    } else {\n+                        logger.debug(\"Invalid mode requested: {}\", command);\n+                    }\n+                    break;\n+            }\n+            logger.debug(\"Mode {} mapped to {}\", modeStr, mode);\n+        }\n+\n+        if (mode != -1) {\n+            // Turn on the unit if currently off\n+            if (!isNumber && (device.getIntStatusVal(\"Pow\") == 0)) {\n+                logger.debug(\"Send Auto-ON for mode {}\", mode);\n+                device.setDevicePower(socket, 1);\n+            }\n+\n+            // Select mode\n+            logger.debug(\"Select mode {}\", mode);\n+            device.SetDeviceMode(socket, mode);\n+\n+            // Check for secondary action\n+            switch (modeStr) {\n+                case MODE_ECO:\n+                    // Turn on power saving for eco mode\n+                    logger.debug(\"Turn on Power-Saving\");\n+                    device.setDevicePwrSaving(socket, 1);\n+                    break;\n+                case MODE_TURBO:\n+                    device.setDeviceTurbo(socket, 1);\n+                    break;\n+            }\n+        }\n+    }\n+\n+    private boolean isMinimumRefreshTimeExceeded() {\n+        long currentTime = System.currentTimeMillis();\n+        long timeSinceLastRefresh = currentTime - lastRefreshTime;\n+        if (timeSinceLastRefresh < MINIMUM_REFRESH_TIME_MS) {\n+            return false;\n+        }\n+        lastRefreshTime = currentTime;\n+        return true;\n+    }\n+\n+    private void startAutomaticRefresh() {\n+\n+        Runnable refresher = new Runnable() {\n+            @Override\n+            public void run() {\n+\n+                try {\n+                    logger.debug(\"Executing automatic update of values\");\n+                    // safeguard for multiple REFRESH commands\n+                    if (isMinimumRefreshTimeExceeded()) {\n+                        logger.debug(\"Fetching status values from device.\");\n+                        // Get the current status from the Airconditioner\n+                        device.getDeviceStatus(clientSocket.get());\n+                    } else {\n+                        logger.trace(\n+                                \"Skipped fetching status values from device because minimum refresh time not reached\");\n+                    }\n+\n+                    // Update All Channels\n+                    List<Channel> channels = getThing().getChannels();\n+                    for (Channel channel : channels) {\n+                        publishChannel(channel.getUID());\n+                    }\n+                } catch (GreeException e) {\n+                    if (!e.isTimeout()) {\n+                        logger.debug(\"Unable to perform auto-update: {}\", e.toString());\n+                    }\n+                } catch (RuntimeException e) {\n+                    logger.debug(\"Unable to perform auto-update\", e);\n+                }\n+            }\n+        };\n+\n+        refreshTask = scheduler.scheduleWithFixedDelay(refresher, 0, config.refresh, TimeUnit.SECONDS);\n+        logger.debug(\"Automatic refresh started ({} second interval)\", config.refresh);\n+    }\n+\n+    private void publishChannel(ChannelUID channelUID) throws GreeException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MzA2NA=="}, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 318}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM5ODg1Mg==", "bodyText": "Did you forget to push it?", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436398852", "createdAt": "2020-06-07T20:27:17Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeHandler.java", "diffHunk": "@@ -0,0 +1,439 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.net.DatagramSocket;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.gree.internal.GreeConfiguration;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.discovery.GreeAirDevice;\n+import org.openhab.binding.gree.internal.discovery.GreeDeviceFinder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link GreeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(GreeHandler.class);\n+    private final GreeTranslationProvider messages;\n+    private GreeConfiguration config = new GreeConfiguration();\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+    private GreeAirDevice device = new GreeAirDevice();\n+    private Optional<DatagramSocket> clientSocket = Optional.empty();\n+\n+    private @Nullable ScheduledFuture<?> refreshTask;\n+    private long lastRefreshTime = 0;\n+\n+    public GreeHandler(Thing thing, GreeTranslationProvider messages) {\n+        super(thing);\n+        this.messages = messages;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // logger.debug(\"Start initializing!\");\n+        config = getConfigAs(GreeConfiguration.class);\n+        logger.debug(\"Config for {} is {}\", thing.getUID(), config.toString());\n+        if (config.ipAddress.isEmpty() || (config.refresh < 0)) {\n+            logger.debug(\"Config of {} is invalid. Check configuration\", thing.getUID());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid configuration. Check thing configuration.\");\n+            return;\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.execute(() -> {\n+            initializeThing();\n+        });\n+    }\n+\n+    private void initializeThing() {\n+        logger.debug(\"Thing {} is initializing\", thing.getUID());\n+\n+        try {\n+            // Create a new Datagram socket with a specified timeout\n+            clientSocket = Optional.of(new DatagramSocket());\n+            if (!clientSocket.isPresent()) {\n+                logger.debug(\"Unable to create datagram socket, discovery aborted!\");\n+                return;\n+            }\n+            clientSocket.get().setSoTimeout(DATAGRAM_SOCKET_TIMEOUT);\n+\n+            // Find the GREE device\n+            deviceFinder = new GreeDeviceFinder(config.ipAddress);\n+            deviceFinder.scan(clientSocket, false);\n+            logger.debug(\"{} units found matching IP address\", deviceFinder.getScannedDeviceCount());\n+\n+            // Now check that this one is amongst the air conditioners that responded.\n+            GreeAirDevice newDevice = deviceFinder.getDeviceByIPAddress(config.ipAddress);\n+            if (newDevice != null) {\n+                // Ok, our device responded, now let's Bind with it\n+                device = newDevice;\n+                device.bindWithDevice(clientSocket);\n+                if (device.getIsBound()) {\n+                    logger.debug(\"GREE AirConditioner {} bound successful\", thing.getUID());\n+                    updateStatus(ThingStatus.ONLINE);\n+\n+                    // Start the automatic refresh cycles\n+                    startAutomaticRefresh();\n+                    return;\n+                }\n+            }\n+            logger.debug(\"GREE unit is not responding\");\n+        } catch (GreeException e) {\n+            logger.debug(\"Initialization failed: {}\", messages.get(\"thinginit.exception\", e.toString()));\n+        } catch (IOException | RuntimeException e) {\n+            logger.debug(\"Exception on inituialization\", e);\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            // The thing is updated by the scheduled automatic refresh so do nothing here.\n+        } else {\n+            if (!clientSocket.isPresent()) {\n+                logger.debug(\"Thing not properly initialized, abort command\");\n+                return;\n+            }\n+\n+            DatagramSocket socket = clientSocket.get();\n+            logger.debug(\"Issue command {}\u00a0to channe {}\", command, channelUID.getIdWithoutGroup());\n+            try {\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case MODE_CHANNEL:\n+                        handleModeCommand(command, socket);\n+                        break;\n+                    case POWER_CHANNEL:\n+                        device.setDevicePower(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case TURBO_CHANNEL:\n+                        device.setDeviceTurbo(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case LIGHT_CHANNEL:\n+                        device.setDeviceLight(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case TEMP_CHANNEL:\n+                        device.setDeviceTempSet(socket, ((DecimalType) command).intValue());\n+                        break;\n+                    case SWINGV_CHANNEL:\n+                        device.setDeviceSwingVertical(socket, ((DecimalType) command).intValue());\n+                        break;\n+                    case WINDSPEED_CHANNEL:\n+                        device.setDeviceWindspeed(socket, ((DecimalType) command).intValue());\n+                        break;\n+                    case AIR_CHANNEL:\n+                        device.setDeviceAir(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case DRY_CHANNEL:\n+                        device.setDeviceDry(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case HEALTH_CHANNEL:\n+                        device.setDeviceHealth(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case PWRSAV_CHANNEL:\n+                        device.setDevicePwrSaving(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                }\n+            } catch (GreeException e) {\n+                logger.debug(\"Unable to execute command {}\u00a0for channel {}: {}\", command, channelUID.getId(),\n+                        e.toString());\n+            } catch (RuntimeException e) {\n+                logger.debug(\"Unable to execute command {}\u00a0for channel {}\", command, channelUID.getId(), e);\n+            }\n+        }\n+    }\n+\n+    private void handleModeCommand(Command command, DatagramSocket socket) throws GreeException {\n+        int mode = -1;\n+        String modeStr = \"\";\n+        boolean isNumber = StringUtils.isNumeric(command.toString());\n+        if (command instanceof DecimalType) {\n+            // backward compatibility when channel was Number\n+            mode = ((DecimalType) command).intValue();\n+        } else if (command instanceof OnOffType) {\n+            // Switch\n+            logger.debug(\"Send Power-{}\", command);\n+            device.setDevicePower(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+        } else /* String */ {\n+            modeStr = command.toString().toLowerCase();\n+            switch (modeStr) {\n+                case MODE_AUTO:\n+                    mode = GREE_MODE_AUTO;\n+                    break;\n+                case MODE_COOL:\n+                    mode = GREE_MODE_COOL;\n+                    break;\n+                case MODE_HEAT:\n+                    mode = GREE_MODE_HEAT;\n+                    break;\n+                case MODE_DRY:\n+                    mode = GREE_MODE_DRY;\n+                    break;\n+                case MODE_FAN:\n+                case MODE_FAN2:\n+                    mode = GREE_MODE_FAN;\n+                    break;\n+                case MODE_ECO:\n+                    // power saving will be set after the uinit was turned on\n+                    mode = GREE_MODE_COOL;\n+                    break;\n+                case MODE_ON:\n+                case MODE_OFF:\n+                    device.setDevicePower(socket, modeStr.equals(MODE_ON) ? 1 : 0);\n+                    break;\n+                default:\n+                    if (isNumber) {\n+                        // Support selecting the mode by number, maybe specific models support\n+                        // additional modes\n+                        mode = Integer.parseInt(modeStr);\n+                    } else {\n+                        logger.debug(\"Invalid mode requested: {}\", command);\n+                    }\n+                    break;\n+            }\n+            logger.debug(\"Mode {} mapped to {}\", modeStr, mode);\n+        }\n+\n+        if (mode != -1) {\n+            // Turn on the unit if currently off\n+            if (!isNumber && (device.getIntStatusVal(\"Pow\") == 0)) {\n+                logger.debug(\"Send Auto-ON for mode {}\", mode);\n+                device.setDevicePower(socket, 1);\n+            }\n+\n+            // Select mode\n+            logger.debug(\"Select mode {}\", mode);\n+            device.SetDeviceMode(socket, mode);\n+\n+            // Check for secondary action\n+            switch (modeStr) {\n+                case MODE_ECO:\n+                    // Turn on power saving for eco mode\n+                    logger.debug(\"Turn on Power-Saving\");\n+                    device.setDevicePwrSaving(socket, 1);\n+                    break;\n+                case MODE_TURBO:\n+                    device.setDeviceTurbo(socket, 1);\n+                    break;\n+            }\n+        }\n+    }\n+\n+    private boolean isMinimumRefreshTimeExceeded() {\n+        long currentTime = System.currentTimeMillis();\n+        long timeSinceLastRefresh = currentTime - lastRefreshTime;\n+        if (timeSinceLastRefresh < MINIMUM_REFRESH_TIME_MS) {\n+            return false;\n+        }\n+        lastRefreshTime = currentTime;\n+        return true;\n+    }\n+\n+    private void startAutomaticRefresh() {\n+\n+        Runnable refresher = new Runnable() {\n+            @Override\n+            public void run() {\n+\n+                try {\n+                    logger.debug(\"Executing automatic update of values\");\n+                    // safeguard for multiple REFRESH commands\n+                    if (isMinimumRefreshTimeExceeded()) {\n+                        logger.debug(\"Fetching status values from device.\");\n+                        // Get the current status from the Airconditioner\n+                        device.getDeviceStatus(clientSocket.get());\n+                    } else {\n+                        logger.trace(\n+                                \"Skipped fetching status values from device because minimum refresh time not reached\");\n+                    }\n+\n+                    // Update All Channels\n+                    List<Channel> channels = getThing().getChannels();\n+                    for (Channel channel : channels) {\n+                        publishChannel(channel.getUID());\n+                    }\n+                } catch (GreeException e) {\n+                    if (!e.isTimeout()) {\n+                        logger.debug(\"Unable to perform auto-update: {}\", e.toString());\n+                    }\n+                } catch (RuntimeException e) {\n+                    logger.debug(\"Unable to perform auto-update\", e);\n+                }\n+            }\n+        };\n+\n+        refreshTask = scheduler.scheduleWithFixedDelay(refresher, 0, config.refresh, TimeUnit.SECONDS);\n+        logger.debug(\"Automatic refresh started ({} second interval)\", config.refresh);\n+    }\n+\n+    private void publishChannel(ChannelUID channelUID) throws GreeException {\n+        try {\n+            String channelID = channelUID.getId();\n+            Optional<State> state = Optional.empty();\n+            switch (channelUID.getIdWithoutGroup()) {\n+                case POWER_CHANNEL:\n+                    state = updateOnOff(\"Pow\");\n+                    break;\n+                case MODE_CHANNEL:\n+                    state = updateMode();\n+                    break;\n+                case TURBO_CHANNEL:\n+                    state = updateOnOff(\"Tur\");\n+                    break;\n+                case LIGHT_CHANNEL:\n+                    state = updateOnOff(\"Lig\");\n+                    break;\n+                case TEMP_CHANNEL:\n+                    state = updateTemp(\"SetTem\");\n+                    break;\n+                case SWINGV_CHANNEL:\n+                    state = updateNumber(\"SwUpDn\");\n+                    break;\n+                case WINDSPEED_CHANNEL:\n+                    state = updateNumber(\"WdSpd\");\n+                    break;\n+                case AIR_CHANNEL:\n+                    state = updateOnOff(\"Air\");\n+                    break;\n+                case DRY_CHANNEL:\n+                    state = updateOnOff(\"Blo\");\n+                    break;\n+                case HEALTH_CHANNEL:\n+                    state = updateOnOff(\"Health\");\n+                    break;\n+                case PWRSAV_CHANNEL:\n+                    state = updateOnOff(\"SvSt\");\n+                    break;\n+            }\n+            if (state.isPresent()) {\n+                logger.trace(\"Updating channel {} : {}\", channelID, state.get());\n+                updateState(channelID, state.get());\n+            }\n+        } catch (GreeException | IllegalArgumentException e) {\n+            logger.debug(\"Exception on channel update\", e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4Mjk5Ng=="}, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 362}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM5OTQxMg==", "bodyText": "I see declaring this as NonNullByDefault has bigger impact. Nevertheless, I'd like to encourage you to use this opportunity to make your code even more robust.", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436399412", "createdAt": "2020-06-07T20:34:49Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,714 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal.handler;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.StringReader;\r\n+import java.net.DatagramPacket;\r\n+import java.net.DatagramSocket;\r\n+import java.net.InetAddress;\r\n+import java.nio.charset.Charset;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Optional;\r\n+\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\r\n+import org.openhab.binding.gree.internal.GreeException;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.stream.JsonReader;\r\n+\r\n+/**\r\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\r\n+ * device specific attributes as well a the functionality for the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+// @NonNullByDefault\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f39b4d2c64b1be550e3809943e3d6837fccda066"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM5OTU2Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The Air Conditioner's IP address is mandantory, all other parameters are optional. \n          \n          \n            \n            The Air Conditioner's IP address is mandatory, all other parameters are optional.", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436399566", "createdAt": "2020-06-07T20:36:44Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/README.md", "diffHunk": "@@ -0,0 +1,148 @@\n+# GREE Binding\n+\n+This binding integrates GREE Air Conditioners.\n+\n+Note: The GREE Air Conditioner must already be setup on the WiFi network and must have a fixed IP Address.\n+\n+## Supported Things\n+\n+This binding supports one Thing type `airconditioner`.\n+\n+## Discovery\n+\n+Once the GREE is on the network (WiFi active) it could be discovery automatically.\n+An IP broadcast message is sent and every responding units gets added to the Inbox. \n+\n+## Binding Configuration\n+\n+No binding configuration is required.\n+\n+#### Manual Thing Creation\n+\n+Fans can be manually created in the *PaperUI* or *HABmin*, or by placing a *.things* file in the *conf/things* directory.  See example below.\n+\n+\n+## Thing Configuration\n+\n+| Channel Name     | Type       | Description                                                                                   |\n+|------------------|------------|-----------------------------------------------------------------------------------------------|\n+| ipAddress        | IP Address | IP address of the unit.                                                                       |\n+| broadcastAddress | IP Address | Broadcast address being used for discovery, usually derived from the IP interface address.    |\n+| refresh          | Integer    | Refresh interval in seconds for polling the device status.                                    |\n+\n+The Air Conditioner's IP address is mandantory, all other parameters are optional. ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f39b4d2c64b1be550e3809943e3d6837fccda066"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM5OTk2MA==", "bodyText": "Must be compared with equals().", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436399960", "createdAt": "2020-06-07T20:42:05Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,714 @@\n+/**\r\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\r\n+ *\r\n+ * See the NOTICE file(s) distributed with this work for additional\r\n+ * information.\r\n+ *\r\n+ * This program and the accompanying materials are made available under the\r\n+ * terms of the Eclipse Public License 2.0 which is available at\r\n+ * http://www.eclipse.org/legal/epl-2.0\r\n+ *\r\n+ * SPDX-License-Identifier: EPL-2.0\r\n+ */\r\n+package org.openhab.binding.gree.internal.handler;\r\n+\r\n+import java.io.IOException;\r\n+import java.io.StringReader;\r\n+import java.net.DatagramPacket;\r\n+import java.net.DatagramSocket;\r\n+import java.net.InetAddress;\r\n+import java.nio.charset.Charset;\r\n+import java.util.ArrayList;\r\n+import java.util.Arrays;\r\n+import java.util.HashMap;\r\n+import java.util.List;\r\n+import java.util.Optional;\r\n+\r\n+import org.eclipse.jdt.annotation.Nullable;\r\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\r\n+import org.openhab.binding.gree.internal.GreeException;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\r\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\r\n+import org.slf4j.Logger;\r\n+import org.slf4j.LoggerFactory;\r\n+\r\n+import com.google.gson.Gson;\r\n+import com.google.gson.stream.JsonReader;\r\n+\r\n+/**\r\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\r\n+ * device specific attributes as well a the functionality for the Air Conditioner\r\n+ *\r\n+ * @author John Cunha - Initial contribution\r\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\r\n+ */\r\n+// @NonNullByDefault\r\n+public class GreeAirDevice {\r\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\r\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\r\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\r\n+    private boolean isBound = false;\r\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\r\n+    private int port = 0;\r\n+    private String encKey = \"\";\r\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\r\n+    private GreeBindResponse4GsonDTO bindResponseGson;\r\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\r\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\r\n+\r\n+    public boolean getIsBound() {\r\n+        return isBound;\r\n+    }\r\n+\r\n+    public void setIsBound(boolean isBound) {\r\n+        this.isBound = isBound;\r\n+    }\r\n+\r\n+    public InetAddress getAddress() {\r\n+        return ipAddress;\r\n+    }\r\n+\r\n+    public void setAddress(InetAddress address) {\r\n+        this.ipAddress = address;\r\n+    }\r\n+\r\n+    public int getPort() {\r\n+        return port;\r\n+    }\r\n+\r\n+    public void setPort(int port) {\r\n+        this.port = port;\r\n+    }\r\n+\r\n+    public String getKey() {\r\n+        return encKey;\r\n+    }\r\n+\r\n+    public String getId() {\r\n+        return mScanResponseGson.packJson.mac;\r\n+    }\r\n+\r\n+    public String getName() {\r\n+        return mScanResponseGson.packJson.name;\r\n+    }\r\n+\r\n+    public String getVendor() {\r\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\r\n+    }\r\n+\r\n+    public String getModel() {\r\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\r\n+    }\r\n+\r\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\r\n+        return mScanResponseGson;\r\n+    }\r\n+\r\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\r\n+        mScanResponseGson = gson;\r\n+    }\r\n+\r\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\r\n+        return bindResponseGson;\r\n+    }\r\n+\r\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\r\n+        return statusResponseGson;\r\n+    }\r\n+\r\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\r\n+        validateSocket(socket);\r\n+        byte[] sendData = new byte[1024];\r\n+        byte[] receiveData = new byte[347];\r\n+        Gson gson = new Gson();\r\n+\r\n+        try {\r\n+            // Prep the Binding Request pack\r\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\r\n+            bindReqPackGson.mac = getId();\r\n+            bindReqPackGson.t = \"bind\";\r\n+            bindReqPackGson.uid = 0;\r\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\r\n+\r\n+            // Now Encrypt the Binding Request pack\r\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\r\n+                    bindReqPackStr);\r\n+\r\n+            // Prep the Binding Request\r\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\r\n+            bindReqGson.cid = \"app\";\r\n+            bindReqGson.i = 1;\r\n+            bindReqGson.t = \"pack\";\r\n+            bindReqGson.uid = 0;\r\n+            bindReqGson.tcid = getId();\r\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\r\n+            String bindReqStr = gson.toJson(bindReqGson);\r\n+            sendData = bindReqStr.getBytes();\r\n+\r\n+            // Now Send the request\r\n+            DatagramSocket clientSocket = socket.get();\r\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\r\n+            clientSocket.send(sendPacket);\r\n+\r\n+            // Recieve a response\r\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\r\n+            clientSocket.receive(receivePacket);\r\n+            String modifiedSentence = new String(receivePacket.getData(), \"UTF-8\");\r\n+\r\n+            // Read the response\r\n+            StringReader stringReader = new StringReader(modifiedSentence);\r\n+            bindResponseGson = gson.fromJson(new JsonReader(stringReader), GreeBindResponse4GsonDTO.class);\r\n+            bindResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\r\n+                    bindResponseGson.pack);\r\n+\r\n+            // Create the JSON to hold the response values\r\n+            stringReader = new StringReader(bindResponseGson.decryptedPack);\r\n+            bindResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePack4GsonDTO.class);\r\n+\r\n+            // Now set the key and flag to indicate the bind was succesful\r\n+            encKey = bindResponseGson.packJson.key;\r\n+            setIsBound(true);\r\n+        } catch (IOException e) {\r\n+            throw new GreeException(e, \"failed\");\r\n+        }\r\n+    }\r\n+\r\n+    private void validateSocket(Optional<DatagramSocket> socket) {\r\n+        if (!socket.isPresent()) {\r\n+            throw new IllegalArgumentException(\"Socket not initialized!\");\r\n+        }\r\n+    }\r\n+\r\n+    public void setDevicePower(DatagramSocket clientSocket, int value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if (!getIsBound() || (value < 0 || value > 1)) {\r\n+            throw new GreeException(\"Device not bound or value out of range!\");\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Pow\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void SetDeviceMode(DatagramSocket clientSocket, int value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if (!getIsBound() || (value < 0 || value > 4)) {\r\n+            throw new GreeException(\"Device not bound or value out of range!\");\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Mod\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceSwingUpDown(DatagramSocket clientSocket, int value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\r\n+        if (!getIsBound() || (value < 0 || value > 11) || (value > 6 && value < 10)) {\r\n+            throw new GreeException(\"Device not bound or value out of range!\");\r\n+        }\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"SwUpDn\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceSwingLeftRight(DatagramSocket clientSocket, int value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        // Only values 0,1,2,3,4,5,6 allowed\r\n+        if (!getIsBound() || (value < 0) || (value > 6)) {\r\n+            throw new GreeException(\"Device not bound or value out of range!\");\r\n+        }\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"SwingLfRig\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Only allow this to happen if this device has been bound and values are valid\r\n+     * Possible values are :\r\n+     * 0 : Auto\r\n+     * 1 : Low\r\n+     * 2 : Medium Low\r\n+     * 3 : Medium\r\n+     * 4 : Medium High\r\n+     * 5 : High\r\n+     */\r\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, int value) throws GreeException {\r\n+        if (!getIsBound() || (value < 0 || value > 5)) {\r\n+            throw new GreeException(\"Device not bound or value out of range!\");\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"WdSpd\", value);\r\n+        parameters.put(\"Quiet\", 0);\r\n+        parameters.put(\"Tur\", 0);\r\n+        parameters.put(\"NoiseSet\", 0);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setDeviceTurbo(DatagramSocket clientSocket, int value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if (!getIsBound() || (value < 0 || value > 1)) {\r\n+            throw new GreeException(\"Device not bound or value out of range!\");\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Tur\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public void setQuietMode(DatagramSocket clientSocket, int value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if (!getIsBound() || (value < 0 || value > 2)) {\r\n+            throw new GreeException(\"Device not bound or value out of range!\");\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Quiet\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    public int getDeviceTurbo() {\r\n+        return getIntStatusVal(\"Tur\");\r\n+    }\r\n+\r\n+    public void setDeviceLight(DatagramSocket clientSocket, int value) throws GreeException {\r\n+        // Only allow this to happen if this device has been bound and values are valid\r\n+        if (!getIsBound() || (value < 0 || value > 1)) {\r\n+            throw new GreeException(\"Device not bound or value out of range!\");\r\n+        }\r\n+\r\n+        // Set the values in the HashMap\r\n+        HashMap<String, Integer> parameters = new HashMap<>();\r\n+        parameters.put(\"Lig\", value);\r\n+        executeCommand(clientSocket, parameters);\r\n+    }\r\n+\r\n+    /**\r\n+     * Create Hash Look Up for C and F\r\n+     * Temperature Ranges for gree A/C units (f_range = {86,61}, c_range={16,30}\r\n+     */\r\n+    private static HashMap<String, HashMap<String, Integer>> createTempRangeMap() {\r\n+        HashMap<String, HashMap<String, Integer>> tempRanges = new HashMap<>();\r\n+        HashMap<String, Integer> hmf = new HashMap<>();\r\n+        HashMap<String, Integer> hmc = new HashMap<>();\r\n+\r\n+        hmf.put(\"min\", 61); // F\r\n+        hmf.put(\"max\", 86);\r\n+        tempRanges.put(\"F\", hmf);\r\n+\r\n+        hmc.put(\"min\", 16); // C\r\n+        hmc.put(\"max\", 30);\r\n+        tempRanges.put(\"C\", hmc);\r\n+\r\n+        return tempRanges;\r\n+    }\r\n+\r\n+    /**\r\n+     * Checks input ranges for validity and TempUn for validity\r\n+     * Uses newVal as priority and tries to validate and determine intent\r\n+     * For example if value is 75 and TempUn says Celsius, change TempUn to Fahrenheit\r\n+     */\r\n+    private int[] validateTemperatureRangeForTempSet(int newValIn, @Nullable Integer CorFIn) {\r\n+        final String[] minMaxLUT = { \"max\", \"min\" }; // looks up 0 = C = max, 1 = F = min\r\n+        final String[] tempScaleLUT = { \"C\", \"F\" }; // Look Up Table used to convert TempUn integer 0,1 to \"C\" to \"F\"\r\n+                                                    // string for hashmap\r\n+        HashMap<String, Integer> nullCorFLUT = new HashMap<>(); // simple look up table for logic\r\n+        nullCorFLUT.put(\"C\", 0);\r\n+        nullCorFLUT.put(\"F\", 1);\r\n+        nullCorFLUT.put(\"INVALID\", 0);\r\n+\r\n+        String validRangeCorF; // stores if the input range is a valid C or F temperature\r\n+\r\n+        // force to global min/max\r\n+        int newVal = (Math.max(newValIn, Math.min(tempRanges.get(\"C\").get(\"min\"), tempRanges.get(\"F\").get(\"min\"))));\r\n+        newVal = Math.min(newVal, Math.max(tempRanges.get(\"C\").get(\"max\"), tempRanges.get(\"F\").get(\"max\")));\r\n+\r\n+        if ((newVal >= tempRanges.get(\"C\").get(\"min\")) && (newVal <= tempRanges.get(\"C\").get(\"max\"))) {\r\n+            validRangeCorF = \"C\";\r\n+        } else if ((newVal >= tempRanges.get(\"F\").get(\"min\")) && (newVal <= tempRanges.get(\"F\").get(\"max\"))) {\r\n+            validRangeCorF = \"F\";\r\n+        } else {\r\n+            logger.warn(\"Input Temp request {} is invalid\", newVal);\r\n+            validRangeCorF = \"INVALID\";\r\n+        }\r\n+\r\n+        // if CorF wasnt initialized or is null set it from lookup\r\n+        Integer CorF = CorFIn != null ? CorFIn : nullCorFLUT.get(validRangeCorF);\r\n+\r\n+        if ((CorF == 1) && validRangeCorF.equals(\"C\")) {\r\n+            CorF = 0; // input temp takes priority\r\n+        } else if ((CorF == 0) && validRangeCorF.equals(\"F\")) {\r\n+            CorF = 1; // input temp takes priority\r\n+        } else if (validRangeCorF == \"INVALID\") {\r", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f39b4d2c64b1be550e3809943e3d6837fccda066"}, "originalPosition": 361}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwMDIyNw==", "bodyText": "Do you log a stack trace by intention, when an IOException raises? RuntimeExceptions should be logged to warn or error. Logging IOException to debug is fine.", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436400227", "createdAt": "2020-06-07T20:46:10Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeDiscoveryService.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.gree.internal.discovery;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramSocket;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.core.i18n.LocaleProvider;\n+import org.eclipse.smarthome.core.i18n.TranslationProvider;\n+import org.eclipse.smarthome.core.net.NetworkAddressService;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.handler.GreeAirDevice;\n+import org.osgi.framework.Bundle;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link GreeDiscoveryService} implements the device discovery service. UDP broadtcast ius used to find the devices on\n+ * the local subnet.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+@Component(service = GreeDiscoveryService.class, immediate = true, configurationPid = \"discovery.gree\")\n+public class GreeDiscoveryService extends AbstractDiscoveryService {\n+    private static final int TIMEOUT_SEC = 10;\n+    private final Logger logger = LoggerFactory.getLogger(GreeDiscoveryService.class);\n+    private final GreeTranslationProvider messages;\n+    private final String broadcastAddress;\n+\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+\n+    @Activate\n+    public GreeDiscoveryService(@Reference NetworkAddressService networkAddressService,\n+            @Reference LocaleProvider localeProvider, @Reference TranslationProvider i18nProvider) {\n+        super(SUPPORTED_THING_TYPES_UIDS, TIMEOUT_SEC);\n+        Bundle bundle = FrameworkUtil.getBundle(this.getClass());\n+        messages = new GreeTranslationProvider(bundle.getBundleContext().getBundle(), i18nProvider, localeProvider);\n+        String ip = networkAddressService.getConfiguredBroadcastAddress();\n+        broadcastAddress = ip != null ? ip : \"\";\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        startScan();\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        stopScan();\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        Optional<DatagramSocket> clientSocket = Optional.empty();\n+        try {\n+            clientSocket = Optional.of(new DatagramSocket());\n+            deviceFinder = new GreeDeviceFinder(broadcastAddress);\n+            deviceFinder.scan(clientSocket, true);\n+\n+            int count = deviceFinder.getScannedDeviceCount();\n+            logger.info(\"{}\", messages.get(\"discovery.result\", count));\n+            if (count > 0) {\n+                logger.debug(\"Adding uinits to Inbox\");\n+                createResult(deviceFinder.getDevices());\n+            }\n+        } catch (GreeException e) {\n+            logger.warn(\"Discovery failed: {}\", e.toString());\n+        } catch (IOException | RuntimeException e) {\n+            logger.debug(\"Discovery failed\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f39b4d2c64b1be550e3809943e3d6837fccda066"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwMDQ1Nw==", "bodyText": "See above", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436400457", "createdAt": "2020-06-07T20:49:29Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeHandler.java", "diffHunk": "@@ -0,0 +1,522 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.net.DatagramSocket;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.ImperialUnits;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.gree.internal.GreeConfiguration;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.discovery.GreeDeviceFinder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import tec.uom.se.unit.Units;\n+\n+/**\n+ * The {@link GreeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(GreeHandler.class);\n+    private final GreeTranslationProvider messages;\n+    private GreeConfiguration config = new GreeConfiguration();\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+    private GreeAirDevice device = new GreeAirDevice();\n+    private Optional<DatagramSocket> clientSocket = Optional.empty();\n+\n+    private @Nullable ScheduledFuture<?> refreshTask;\n+    private long lastRefreshTime = 0;\n+\n+    public GreeHandler(Thing thing, GreeTranslationProvider messages) {\n+        super(thing);\n+        this.messages = messages;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(GreeConfiguration.class);\n+        logger.debug(\"Config for {} is {}\", thing.getUID(), config.toString());\n+        if (config.ipAddress.isEmpty() || (config.refresh < 0)) {\n+            logger.warn(\"Config of {} is invalid. Check configuration\", thing.getUID());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid configuration. Check thing configuration.\");\n+            return;\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.execute(() -> {\n+            initializeThing();\n+        });\n+    }\n+\n+    private void initializeThing() {\n+        logger.debug(\"Thing {} is initializing\", thing.getUID());\n+\n+        try {\n+            // Create a new Datagram socket with a specified timeout\n+            clientSocket = Optional.of(new DatagramSocket());\n+            clientSocket.get().setSoTimeout(DATAGRAM_SOCKET_TIMEOUT);\n+\n+            // Find the GREE device\n+            deviceFinder = new GreeDeviceFinder(config.ipAddress);\n+            deviceFinder.scan(clientSocket, false);\n+            logger.debug(\"{} units found matching IP address\", deviceFinder.getScannedDeviceCount());\n+\n+            // Now check that this one is amongst the air conditioners that responded.\n+            GreeAirDevice newDevice = deviceFinder.getDeviceByIPAddress(config.ipAddress);\n+            if (newDevice != null) {\n+                // Ok, our device responded, now let's Bind with it\n+                device = newDevice;\n+                device.bindWithDevice(clientSocket);\n+                if (device.getIsBound()) {\n+                    updateStatus(ThingStatus.ONLINE);\n+\n+                    // Start the automatic refresh cycles\n+                    startAutomaticRefresh();\n+                    return;\n+                }\n+            }\n+            logger.debug(\"GREE unit is not responding\");\n+        } catch (GreeException e) {\n+            logger.warn(\"Initialization failed: {}\", messages.get(\"thinginit.exception\", e.toString()));\n+        } catch (IOException | RuntimeException e) {\n+            logger.debug(\"Exception on initialization\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f39b4d2c64b1be550e3809943e3d6837fccda066"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwMDUzNA==", "bodyText": "See above", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436400534", "createdAt": "2020-06-07T20:50:12Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeHandler.java", "diffHunk": "@@ -0,0 +1,522 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.net.DatagramSocket;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.ImperialUnits;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.gree.internal.GreeConfiguration;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.discovery.GreeDeviceFinder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import tec.uom.se.unit.Units;\n+\n+/**\n+ * The {@link GreeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(GreeHandler.class);\n+    private final GreeTranslationProvider messages;\n+    private GreeConfiguration config = new GreeConfiguration();\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+    private GreeAirDevice device = new GreeAirDevice();\n+    private Optional<DatagramSocket> clientSocket = Optional.empty();\n+\n+    private @Nullable ScheduledFuture<?> refreshTask;\n+    private long lastRefreshTime = 0;\n+\n+    public GreeHandler(Thing thing, GreeTranslationProvider messages) {\n+        super(thing);\n+        this.messages = messages;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(GreeConfiguration.class);\n+        logger.debug(\"Config for {} is {}\", thing.getUID(), config.toString());\n+        if (config.ipAddress.isEmpty() || (config.refresh < 0)) {\n+            logger.warn(\"Config of {} is invalid. Check configuration\", thing.getUID());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid configuration. Check thing configuration.\");\n+            return;\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.execute(() -> {\n+            initializeThing();\n+        });\n+    }\n+\n+    private void initializeThing() {\n+        logger.debug(\"Thing {} is initializing\", thing.getUID());\n+\n+        try {\n+            // Create a new Datagram socket with a specified timeout\n+            clientSocket = Optional.of(new DatagramSocket());\n+            clientSocket.get().setSoTimeout(DATAGRAM_SOCKET_TIMEOUT);\n+\n+            // Find the GREE device\n+            deviceFinder = new GreeDeviceFinder(config.ipAddress);\n+            deviceFinder.scan(clientSocket, false);\n+            logger.debug(\"{} units found matching IP address\", deviceFinder.getScannedDeviceCount());\n+\n+            // Now check that this one is amongst the air conditioners that responded.\n+            GreeAirDevice newDevice = deviceFinder.getDeviceByIPAddress(config.ipAddress);\n+            if (newDevice != null) {\n+                // Ok, our device responded, now let's Bind with it\n+                device = newDevice;\n+                device.bindWithDevice(clientSocket);\n+                if (device.getIsBound()) {\n+                    updateStatus(ThingStatus.ONLINE);\n+\n+                    // Start the automatic refresh cycles\n+                    startAutomaticRefresh();\n+                    return;\n+                }\n+            }\n+            logger.debug(\"GREE unit is not responding\");\n+        } catch (GreeException e) {\n+            logger.warn(\"Initialization failed: {}\", messages.get(\"thinginit.exception\", e.toString()));\n+        } catch (IOException | RuntimeException e) {\n+            logger.debug(\"Exception on initialization\", e);\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            // The thing is updated by the scheduled automatic refresh so do nothing here.\n+        } else {\n+            if (!clientSocket.isPresent()) {\n+                logger.warn(\"Thing not properly initialized, abort command\");\n+                return;\n+            }\n+\n+            DatagramSocket socket = clientSocket.get();\n+            logger.debug(\"Issue command {}\u00a0to channe {}\", command, channelUID.getIdWithoutGroup());\n+            String channelId = channelUID.getIdWithoutGroup();\n+            logger.debug(\"Handle command {} for channel {}, command class {}\", command, channelId, command.getClass());\n+            try {\n+                switch (channelId) {\n+                    case MODE_CHANNEL:\n+                        handleModeCommand(command, socket);\n+                        break;\n+                    case POWER_CHANNEL:\n+                        device.setDevicePower(socket, getOnOff(command));\n+                        break;\n+                    case TURBO_CHANNEL:\n+                        device.setDeviceTurbo(socket, getOnOff(command));\n+                        break;\n+                    case LIGHT_CHANNEL:\n+                        device.setDeviceLight(socket, getOnOff(command));\n+                        break;\n+                    case TEMP_CHANNEL:\n+                        device.setDeviceTempSet(socket, (int) getTemp(command));\n+                        break;\n+                    case SWINGUD_CHANNEL:\n+                        device.setDeviceSwingUpDown(socket, getNumber(command));\n+                        break;\n+                    case SWINGLR_CHANNEL:\n+                        device.setDeviceSwingLeftRight(socket, getNumber(command));\n+                        break;\n+                    case WINDSPEED_CHANNEL:\n+                        device.setDeviceWindspeed(socket, getNumber(command));\n+                        break;\n+                    case QUIET_CHANNEL:\n+                        handleQuietCommand(command, socket);\n+                        break;\n+                    case AIR_CHANNEL:\n+                        device.setDeviceAir(socket, getOnOff(command));\n+                        break;\n+                    case DRY_CHANNEL:\n+                        device.setDeviceDry(socket, getOnOff(command));\n+                        break;\n+                    case HEALTH_CHANNEL:\n+                        device.setDeviceHealth(socket, getOnOff(command));\n+                        break;\n+                    case PWRSAV_CHANNEL:\n+                        device.setDevicePwrSaving(socket, getOnOff(command));\n+                        break;\n+                }\n+            } catch (GreeException e) {\n+                logger.debug(\"Unable to execute command {}\u00a0for channel {}: {}\", command, channelId, e.toString());\n+            } catch (IllegalArgumentException e) {\n+                logger.warn(\"Invalid command value {}\u00a0for channel {}\", command, channelUID.getId());\n+            } catch (RuntimeException e) {\n+                logger.debug(\"Unable to execute command {}\u00a0for channel {}\", command, channelId, e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f39b4d2c64b1be550e3809943e3d6837fccda066"}, "originalPosition": 194}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwMDg5NQ==", "bodyText": "Hm, I still see debug", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436400895", "createdAt": "2020-06-07T20:54:36Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeHandler.java", "diffHunk": "@@ -0,0 +1,439 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.net.DatagramSocket;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.gree.internal.GreeConfiguration;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.discovery.GreeAirDevice;\n+import org.openhab.binding.gree.internal.discovery.GreeDeviceFinder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link GreeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(GreeHandler.class);\n+    private final GreeTranslationProvider messages;\n+    private GreeConfiguration config = new GreeConfiguration();\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+    private GreeAirDevice device = new GreeAirDevice();\n+    private Optional<DatagramSocket> clientSocket = Optional.empty();\n+\n+    private @Nullable ScheduledFuture<?> refreshTask;\n+    private long lastRefreshTime = 0;\n+\n+    public GreeHandler(Thing thing, GreeTranslationProvider messages) {\n+        super(thing);\n+        this.messages = messages;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // logger.debug(\"Start initializing!\");\n+        config = getConfigAs(GreeConfiguration.class);\n+        logger.debug(\"Config for {} is {}\", thing.getUID(), config.toString());\n+        if (config.ipAddress.isEmpty() || (config.refresh < 0)) {\n+            logger.debug(\"Config of {} is invalid. Check configuration\", thing.getUID());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid configuration. Check thing configuration.\");\n+            return;\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.execute(() -> {\n+            initializeThing();\n+        });\n+    }\n+\n+    private void initializeThing() {\n+        logger.debug(\"Thing {} is initializing\", thing.getUID());\n+\n+        try {\n+            // Create a new Datagram socket with a specified timeout\n+            clientSocket = Optional.of(new DatagramSocket());\n+            if (!clientSocket.isPresent()) {\n+                logger.debug(\"Unable to create datagram socket, discovery aborted!\");\n+                return;\n+            }\n+            clientSocket.get().setSoTimeout(DATAGRAM_SOCKET_TIMEOUT);\n+\n+            // Find the GREE device\n+            deviceFinder = new GreeDeviceFinder(config.ipAddress);\n+            deviceFinder.scan(clientSocket, false);\n+            logger.debug(\"{} units found matching IP address\", deviceFinder.getScannedDeviceCount());\n+\n+            // Now check that this one is amongst the air conditioners that responded.\n+            GreeAirDevice newDevice = deviceFinder.getDeviceByIPAddress(config.ipAddress);\n+            if (newDevice != null) {\n+                // Ok, our device responded, now let's Bind with it\n+                device = newDevice;\n+                device.bindWithDevice(clientSocket);\n+                if (device.getIsBound()) {\n+                    logger.debug(\"GREE AirConditioner {} bound successful\", thing.getUID());\n+                    updateStatus(ThingStatus.ONLINE);\n+\n+                    // Start the automatic refresh cycles\n+                    startAutomaticRefresh();\n+                    return;\n+                }\n+            }\n+            logger.debug(\"GREE unit is not responding\");\n+        } catch (GreeException e) {\n+            logger.debug(\"Initialization failed: {}\", messages.get(\"thinginit.exception\", e.toString()));\n+        } catch (IOException | RuntimeException e) {\n+            logger.debug(\"Exception on inituialization\", e);\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            // The thing is updated by the scheduled automatic refresh so do nothing here.\n+        } else {\n+            if (!clientSocket.isPresent()) {\n+                logger.debug(\"Thing not properly initialized, abort command\");\n+                return;\n+            }\n+\n+            DatagramSocket socket = clientSocket.get();\n+            logger.debug(\"Issue command {}\u00a0to channe {}\", command, channelUID.getIdWithoutGroup());\n+            try {\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case MODE_CHANNEL:\n+                        handleModeCommand(command, socket);\n+                        break;\n+                    case POWER_CHANNEL:\n+                        device.setDevicePower(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case TURBO_CHANNEL:\n+                        device.setDeviceTurbo(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case LIGHT_CHANNEL:\n+                        device.setDeviceLight(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case TEMP_CHANNEL:\n+                        device.setDeviceTempSet(socket, ((DecimalType) command).intValue());\n+                        break;\n+                    case SWINGV_CHANNEL:\n+                        device.setDeviceSwingVertical(socket, ((DecimalType) command).intValue());\n+                        break;\n+                    case WINDSPEED_CHANNEL:\n+                        device.setDeviceWindspeed(socket, ((DecimalType) command).intValue());\n+                        break;\n+                    case AIR_CHANNEL:\n+                        device.setDeviceAir(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case DRY_CHANNEL:\n+                        device.setDeviceDry(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case HEALTH_CHANNEL:\n+                        device.setDeviceHealth(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case PWRSAV_CHANNEL:\n+                        device.setDevicePwrSaving(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                }\n+            } catch (GreeException e) {\n+                logger.debug(\"Unable to execute command {}\u00a0for channel {}: {}\", command, channelUID.getId(),\n+                        e.toString());\n+            } catch (RuntimeException e) {\n+                logger.debug(\"Unable to execute command {}\u00a0for channel {}\", command, channelUID.getId(), e);\n+            }\n+        }\n+    }\n+\n+    private void handleModeCommand(Command command, DatagramSocket socket) throws GreeException {\n+        int mode = -1;\n+        String modeStr = \"\";\n+        boolean isNumber = StringUtils.isNumeric(command.toString());\n+        if (command instanceof DecimalType) {\n+            // backward compatibility when channel was Number\n+            mode = ((DecimalType) command).intValue();\n+        } else if (command instanceof OnOffType) {\n+            // Switch\n+            logger.debug(\"Send Power-{}\", command);\n+            device.setDevicePower(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+        } else /* String */ {\n+            modeStr = command.toString().toLowerCase();\n+            switch (modeStr) {\n+                case MODE_AUTO:\n+                    mode = GREE_MODE_AUTO;\n+                    break;\n+                case MODE_COOL:\n+                    mode = GREE_MODE_COOL;\n+                    break;\n+                case MODE_HEAT:\n+                    mode = GREE_MODE_HEAT;\n+                    break;\n+                case MODE_DRY:\n+                    mode = GREE_MODE_DRY;\n+                    break;\n+                case MODE_FAN:\n+                case MODE_FAN2:\n+                    mode = GREE_MODE_FAN;\n+                    break;\n+                case MODE_ECO:\n+                    // power saving will be set after the uinit was turned on\n+                    mode = GREE_MODE_COOL;\n+                    break;\n+                case MODE_ON:\n+                case MODE_OFF:\n+                    device.setDevicePower(socket, modeStr.equals(MODE_ON) ? 1 : 0);\n+                    break;\n+                default:\n+                    if (isNumber) {\n+                        // Support selecting the mode by number, maybe specific models support\n+                        // additional modes\n+                        mode = Integer.parseInt(modeStr);\n+                    } else {\n+                        logger.debug(\"Invalid mode requested: {}\", command);\n+                    }\n+                    break;\n+            }\n+            logger.debug(\"Mode {} mapped to {}\", modeStr, mode);\n+        }\n+\n+        if (mode != -1) {\n+            // Turn on the unit if currently off\n+            if (!isNumber && (device.getIntStatusVal(\"Pow\") == 0)) {\n+                logger.debug(\"Send Auto-ON for mode {}\", mode);\n+                device.setDevicePower(socket, 1);\n+            }\n+\n+            // Select mode\n+            logger.debug(\"Select mode {}\", mode);\n+            device.SetDeviceMode(socket, mode);\n+\n+            // Check for secondary action\n+            switch (modeStr) {\n+                case MODE_ECO:\n+                    // Turn on power saving for eco mode\n+                    logger.debug(\"Turn on Power-Saving\");\n+                    device.setDevicePwrSaving(socket, 1);\n+                    break;\n+                case MODE_TURBO:\n+                    device.setDeviceTurbo(socket, 1);\n+                    break;\n+            }\n+        }\n+    }\n+\n+    private boolean isMinimumRefreshTimeExceeded() {\n+        long currentTime = System.currentTimeMillis();\n+        long timeSinceLastRefresh = currentTime - lastRefreshTime;\n+        if (timeSinceLastRefresh < MINIMUM_REFRESH_TIME_MS) {\n+            return false;\n+        }\n+        lastRefreshTime = currentTime;\n+        return true;\n+    }\n+\n+    private void startAutomaticRefresh() {\n+\n+        Runnable refresher = new Runnable() {\n+            @Override\n+            public void run() {\n+\n+                try {\n+                    logger.debug(\"Executing automatic update of values\");\n+                    // safeguard for multiple REFRESH commands\n+                    if (isMinimumRefreshTimeExceeded()) {\n+                        logger.debug(\"Fetching status values from device.\");\n+                        // Get the current status from the Airconditioner\n+                        device.getDeviceStatus(clientSocket.get());\n+                    } else {\n+                        logger.trace(\n+                                \"Skipped fetching status values from device because minimum refresh time not reached\");\n+                    }\n+\n+                    // Update All Channels\n+                    List<Channel> channels = getThing().getChannels();\n+                    for (Channel channel : channels) {\n+                        publishChannel(channel.getUID());\n+                    }\n+                } catch (GreeException e) {\n+                    if (!e.isTimeout()) {\n+                        logger.debug(\"Unable to perform auto-update: {}\", e.toString());\n+                    }\n+                } catch (RuntimeException e) {\n+                    logger.debug(\"Unable to perform auto-update\", e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MjkwMA=="}, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 309}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7e85fe1969c9ac94e13940ce8c6911a22ec4d558", "author": {"user": {"login": "markus7017", "name": "Markus Michels"}}, "url": "https://github.com/openhab/openhab-addons/commit/7e85fe1969c9ac94e13940ce8c6911a22ec4d558", "committedDate": "2020-06-07T22:03:11Z", "message": "discovery fixed, review changes, README updated\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f1e730ba701dc9c2bb5504f9fbbc0d2176c23490", "author": {"user": {"login": "markus7017", "name": "Markus Michels"}}, "url": "https://github.com/openhab/openhab-addons/commit/f1e730ba701dc9c2bb5504f9fbbc0d2176c23490", "committedDate": "2020-06-07T22:06:34Z", "message": "spotless formatting applied\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1OTMyNzUx", "url": "https://github.com/openhab/openhab-addons/pull/7504#pullrequestreview-425932751", "createdAt": "2020-06-08T05:59:04Z", "commit": {"oid": "f1e730ba701dc9c2bb5504f9fbbc0d2176c23490"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 39, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwNTo1OTowNVrOGgQGkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOFQwNzowMDozNFrOGgRWLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3MTQ0MA==", "bodyText": "The default charset varies from system to system so it is better to specify it yourself instead of using the default.\nYou can specify the charset as an additional parameter in the String constructor.", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436471440", "createdAt": "2020-06-08T05:59:05Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/GreeCryptoUtil.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal;\n+\n+import java.io.UnsupportedEncodingException;\n+import java.security.InvalidKeyException;\n+import java.security.Key;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Base64;\n+\n+import javax.crypto.BadPaddingException;\n+import javax.crypto.Cipher;\n+import javax.crypto.IllegalBlockSizeException;\n+import javax.crypto.NoSuchPaddingException;\n+import javax.crypto.spec.SecretKeySpec;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The CryptoUtil class provides functionality for encrypting and decrypting\n+ * messages sent to and from the Air Conditioner\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeCryptoUtil {\n+    private static final String AES_KEY = \"a3K8Bx%2r8Y7#xDh\";\n+\n+    public static String GetAESGeneralKey() {\n+        return AES_KEY;\n+    }\n+\n+    public static byte[] getAESGeneralKeyByteArray() {\n+        return AES_KEY.getBytes();\n+    }\n+\n+    public static String decryptPack(byte[] keyarray, String message) throws GreeException {\n+        try {\n+            Key key = new SecretKeySpec(keyarray, \"AES\");\n+            Base64.Decoder decoder = Base64.getDecoder();\n+            byte[] imageByte = decoder.decode(message);\n+\n+            Cipher aesCipher = Cipher.getInstance(\"AES\");\n+            aesCipher.init(Cipher.DECRYPT_MODE, key);\n+            byte[] bytePlainText = aesCipher.doFinal(imageByte);\n+\n+            return new String(bytePlainText, \"UTF-8\");\n+        } catch (NoSuchAlgorithmException | UnsupportedEncodingException | NoSuchPaddingException | BadPaddingException\n+                | InvalidKeyException | IllegalBlockSizeException ex) {\n+            throw new GreeException(ex, \"Decryption of recieved data failed\");\n+        }\n+    }\n+\n+    public static String encryptPack(byte[] keyarray, String message) throws GreeException {\n+        try {\n+            Key key = new SecretKeySpec(keyarray, \"AES\");\n+            Cipher aesCipher = Cipher.getInstance(\"AES\");\n+            aesCipher.init(Cipher.ENCRYPT_MODE, key);\n+            byte[] bytePlainText = aesCipher.doFinal(message.getBytes());\n+\n+            Base64.Encoder newencoder = Base64.getEncoder();\n+            String encrytpedMessage = new String(newencoder.encode(bytePlainText));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1e730ba701dc9c2bb5504f9fbbc0d2176c23490"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3MTgwMA==", "bodyText": "Minor knit-pick I know, but I would prefer if you swapped the order of these parameters to be consistent with other exception constructors.", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436471800", "createdAt": "2020-06-08T06:00:30Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/GreeException.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal;\n+\n+import java.net.MalformedURLException;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.text.MessageFormat;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * {@link GreeException} implements a binding specific exception class. This allows to unity exception handling on the\n+ * higher levels, but still carrying the exception, which caused the problem.\n+ *\n+ * @author Markus Michels - Initial Contribution\n+ */\n+@NonNullByDefault\n+public class GreeException extends Exception {\n+    private static final long serialVersionUID = -2337258558995287405L;\n+    private static String EX_NONE = \"none\";\n+\n+    public GreeException(Exception exception) {\n+        super(exception);\n+    }\n+\n+    public GreeException(String message) {\n+        super(message);\n+    }\n+\n+    public GreeException(Exception exception, String message) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1e730ba701dc9c2bb5504f9fbbc0d2176c23490"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3MjE1OA==", "bodyText": "any reason this was overriden?", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436472158", "createdAt": "2020-06-08T06:01:57Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/GreeHandlerFactory.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.i18n.LocaleProvider;\n+import org.eclipse.smarthome.core.i18n.TranslationProvider;\n+import org.eclipse.smarthome.core.net.NetworkAddressService;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.openhab.binding.gree.internal.handler.GreeHandler;\n+import org.osgi.service.component.ComponentContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link GreeHandlerFactory} is responsible for creating things and thing handlers.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+@Component(configurationPid = \"binding.\" + BINDING_ID, service = ThingHandlerFactory.class)\n+public class GreeHandlerFactory extends BaseThingHandlerFactory {\n+    private final GreeTranslationProvider messages;\n+\n+    @Activate\n+    public GreeHandlerFactory(@Reference NetworkAddressService networkAddressService,\n+            @Reference LocaleProvider localeProvider, @Reference TranslationProvider i18nProvider,\n+            ComponentContext componentContext, Map<String, Object> configProperties) {\n+        super.activate(componentContext);\n+        messages = new GreeTranslationProvider(bundleContext.getBundle(), i18nProvider, localeProvider);\n+    }\n+\n+    @Override\n+    public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n+        return SUPPORTED_THING_TYPES_UIDS.contains(thingTypeUID);\n+    }\n+\n+    @Override\n+    protected @Nullable ThingHandler createHandler(Thing thing) {\n+        if (THING_TYPE_GREEAIRCON.equals(thing.getThingTypeUID())) {\n+            return new GreeHandler(thing, messages);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public void deactivate(ComponentContext componentContext) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1e730ba701dc9c2bb5504f9fbbc0d2176c23490"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3MjQ0NA==", "bodyText": "please change this to debug", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436472444", "createdAt": "2020-06-08T06:03:00Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeDiscoveryService.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.gree.internal.discovery;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramSocket;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.i18n.LocaleProvider;\n+import org.eclipse.smarthome.core.i18n.TranslationProvider;\n+import org.eclipse.smarthome.core.net.NetworkAddressService;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.handler.GreeAirDevice;\n+import org.osgi.framework.Bundle;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Modified;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link GreeDiscoveryService} implements the device discovery service. UDP broadtcast ius used to find the devices on\n+ * the local subnet.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+@Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.gree\")\n+public class GreeDiscoveryService extends AbstractDiscoveryService {\n+    private static final int TIMEOUT_SEC = 10;\n+    private final Logger logger = LoggerFactory.getLogger(GreeDiscoveryService.class);\n+    private final GreeTranslationProvider messages;\n+    private final String broadcastAddress;\n+\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+\n+    @Activate\n+    public GreeDiscoveryService(@Reference NetworkAddressService networkAddressService,\n+            @Reference LocaleProvider localeProvider, @Reference TranslationProvider i18nProvider) {\n+        super(SUPPORTED_THING_TYPES_UIDS, TIMEOUT_SEC);\n+        Bundle bundle = FrameworkUtil.getBundle(this.getClass());\n+        messages = new GreeTranslationProvider(bundle.getBundleContext().getBundle(), i18nProvider, localeProvider);\n+        String ip = networkAddressService.getConfiguredBroadcastAddress();\n+        broadcastAddress = ip != null ? ip : \"\";\n+    }\n+\n+    @Override\n+    protected void activate(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.activate(configProperties);\n+    }\n+\n+    @Override\n+    @Modified\n+    protected void modified(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.modified(configProperties);\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        // It's very unusual that a new unit gets installed frequently so we run the discovery once when the binding is\n+        // started, but not frequently\n+        scheduler.execute(() -> {\n+            startScan();\n+        });\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        stopScan();\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        Optional<DatagramSocket> clientSocket = Optional.empty();\n+        try {\n+            clientSocket = Optional.of(new DatagramSocket());\n+            deviceFinder = new GreeDeviceFinder(broadcastAddress);\n+            deviceFinder.scan(clientSocket, true);\n+\n+            int count = deviceFinder.getScannedDeviceCount();\n+            logger.info(\"{}\", messages.get(\"discovery.result\", count));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1e730ba701dc9c2bb5504f9fbbc0d2176c23490"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3MjU3OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                .withRepresentationProperty(device.getId()).withLabel(device.getName()).build();\n          \n          \n            \n                                .withRepresentationProperty(Thing.PROPERTY_MAC_ADDRESS)).withLabel(device.getName()).build();", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436472578", "createdAt": "2020-06-08T06:03:30Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeDiscoveryService.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.gree.internal.discovery;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramSocket;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.i18n.LocaleProvider;\n+import org.eclipse.smarthome.core.i18n.TranslationProvider;\n+import org.eclipse.smarthome.core.net.NetworkAddressService;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.handler.GreeAirDevice;\n+import org.osgi.framework.Bundle;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Modified;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link GreeDiscoveryService} implements the device discovery service. UDP broadtcast ius used to find the devices on\n+ * the local subnet.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+@Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.gree\")\n+public class GreeDiscoveryService extends AbstractDiscoveryService {\n+    private static final int TIMEOUT_SEC = 10;\n+    private final Logger logger = LoggerFactory.getLogger(GreeDiscoveryService.class);\n+    private final GreeTranslationProvider messages;\n+    private final String broadcastAddress;\n+\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+\n+    @Activate\n+    public GreeDiscoveryService(@Reference NetworkAddressService networkAddressService,\n+            @Reference LocaleProvider localeProvider, @Reference TranslationProvider i18nProvider) {\n+        super(SUPPORTED_THING_TYPES_UIDS, TIMEOUT_SEC);\n+        Bundle bundle = FrameworkUtil.getBundle(this.getClass());\n+        messages = new GreeTranslationProvider(bundle.getBundleContext().getBundle(), i18nProvider, localeProvider);\n+        String ip = networkAddressService.getConfiguredBroadcastAddress();\n+        broadcastAddress = ip != null ? ip : \"\";\n+    }\n+\n+    @Override\n+    protected void activate(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.activate(configProperties);\n+    }\n+\n+    @Override\n+    @Modified\n+    protected void modified(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.modified(configProperties);\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        // It's very unusual that a new unit gets installed frequently so we run the discovery once when the binding is\n+        // started, but not frequently\n+        scheduler.execute(() -> {\n+            startScan();\n+        });\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        stopScan();\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        Optional<DatagramSocket> clientSocket = Optional.empty();\n+        try {\n+            clientSocket = Optional.of(new DatagramSocket());\n+            deviceFinder = new GreeDeviceFinder(broadcastAddress);\n+            deviceFinder.scan(clientSocket, true);\n+\n+            int count = deviceFinder.getScannedDeviceCount();\n+            logger.info(\"{}\", messages.get(\"discovery.result\", count));\n+            if (count > 0) {\n+                logger.debug(\"Adding uinits to Inbox\");\n+                createResult(deviceFinder.getDevices());\n+            }\n+        } catch (GreeException e) {\n+            logger.warn(\"Discovery failed: {}\", e.toString());\n+        } catch (IOException e) {\n+            logger.debug(\"Discovery failed: {}\", e.toString());\n+        } catch (RuntimeException e) {\n+            logger.warn(\"Discovery failed\", e);\n+        } finally {\n+            if (clientSocket.isPresent()) {\n+                clientSocket.get().close();\n+            }\n+        }\n+    }\n+\n+    public void createResult(HashMap<String, GreeAirDevice> deviceList) {\n+        for (Map.Entry<String, GreeAirDevice> d : deviceList.entrySet()) {\n+            GreeAirDevice device = d.getValue();\n+            String ipAddress = device.getAddress().getHostAddress();\n+            logger.debug(\"{}\", messages.get(\"discovery.newunit\", device.getName(), ipAddress, device.getId()));\n+            Map<String, Object> properties = new TreeMap<String, Object>();\n+            properties.put(Thing.PROPERTY_VENDOR, device.getVendor());\n+            properties.put(Thing.PROPERTY_MODEL_ID, device.getModel());\n+            properties.put(Thing.PROPERTY_MAC_ADDRESS, device.getId());\n+            properties.put(PROPERTY_IP, ipAddress);\n+            properties.put(PROPERTY_BROADCAST, broadcastAddress);\n+            ThingUID thingUID = new ThingUID(THING_TYPE_GREEAIRCON, device.getId());\n+            DiscoveryResult result = DiscoveryResultBuilder.create(thingUID).withProperties(properties)\n+                    .withRepresentationProperty(device.getId()).withLabel(device.getName()).build();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1e730ba701dc9c2bb5504f9fbbc0d2176c23490"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3MzE3OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                protected HashMap<String, GreeAirDevice> mDevicesHashMap = new HashMap<>();\n          \n          \n            \n                protected Map<String, GreeAirDevice> devicesHashMap = new HashMap<>();", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436473178", "createdAt": "2020-06-08T06:05:43Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeDeviceFinder.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.discovery;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeScanReponsePack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanRequest4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.handler.GreeAirDevice;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDeviceFinder provides functionality for searching for GREE Airconditioners on the network and keeping a list\n+ * of found devices.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeDeviceFinder {\n+    private final Logger logger = LoggerFactory.getLogger(GreeDeviceFinder.class);\n+\n+    protected final InetAddress mIPAddress;\n+    protected HashMap<String, GreeAirDevice> mDevicesHashMap = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1e730ba701dc9c2bb5504f9fbbc0d2176c23490"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3MzQxOQ==", "bodyText": "Please use camelcase naming convention.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                protected final InetAddress mIPAddress;\n          \n          \n            \n                protected final InetAddress ipAddress;", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436473419", "createdAt": "2020-06-08T06:06:29Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeDeviceFinder.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.discovery;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeScanReponsePack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanRequest4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.handler.GreeAirDevice;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDeviceFinder provides functionality for searching for GREE Airconditioners on the network and keeping a list\n+ * of found devices.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeDeviceFinder {\n+    private final Logger logger = LoggerFactory.getLogger(GreeDeviceFinder.class);\n+\n+    protected final InetAddress mIPAddress;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1e730ba701dc9c2bb5504f9fbbc0d2176c23490"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3Mzg5MQ==", "bodyText": "I don't see why you need to use an Optional here. Making socket nullable would more than sufficient.", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436473891", "createdAt": "2020-06-08T06:08:11Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeDeviceFinder.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.discovery;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeScanReponsePack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanRequest4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.handler.GreeAirDevice;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDeviceFinder provides functionality for searching for GREE Airconditioners on the network and keeping a list\n+ * of found devices.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeDeviceFinder {\n+    private final Logger logger = LoggerFactory.getLogger(GreeDeviceFinder.class);\n+\n+    protected final InetAddress mIPAddress;\n+    protected HashMap<String, GreeAirDevice> mDevicesHashMap = new HashMap<>();\n+\n+    public GreeDeviceFinder() {\n+        mIPAddress = InetAddress.getLoopbackAddress(); // dummy\n+    }\n+\n+    public GreeDeviceFinder(String broadcastAddress) throws UnknownHostException {\n+        mIPAddress = InetAddress.getByName(broadcastAddress);\n+    }\n+\n+    public void scan(Optional<DatagramSocket> socket, boolean scanNetwork) throws GreeException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1e730ba701dc9c2bb5504f9fbbc0d2176c23490"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3NDkxNg==", "bodyText": "I don't think you need the scanning variable at all.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                scanning = scanNetwork;\n          \n          \n            \n                                if(!scanNetwork){\n          \n          \n            \n                                    break;\n          \n          \n            \n                                }", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436474916", "createdAt": "2020-06-08T06:11:46Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeDeviceFinder.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.discovery;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeScanReponsePack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanRequest4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.handler.GreeAirDevice;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDeviceFinder provides functionality for searching for GREE Airconditioners on the network and keeping a list\n+ * of found devices.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeDeviceFinder {\n+    private final Logger logger = LoggerFactory.getLogger(GreeDeviceFinder.class);\n+\n+    protected final InetAddress mIPAddress;\n+    protected HashMap<String, GreeAirDevice> mDevicesHashMap = new HashMap<>();\n+\n+    public GreeDeviceFinder() {\n+        mIPAddress = InetAddress.getLoopbackAddress(); // dummy\n+    }\n+\n+    public GreeDeviceFinder(String broadcastAddress) throws UnknownHostException {\n+        mIPAddress = InetAddress.getByName(broadcastAddress);\n+    }\n+\n+    public void scan(Optional<DatagramSocket> socket, boolean scanNetwork) throws GreeException {\n+        validateSocket(socket);\n+        byte[] sendData = new byte[1024];\n+        byte[] receiveData = new byte[1024];\n+\n+        // Send the Scan message\n+        GreeScanRequest4GsonDTO scanGson = new GreeScanRequest4GsonDTO();\n+        scanGson.t = \"scan\";\n+\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        Gson gson = gsonBuilder.create();\n+        String scanReq = gson.toJson(scanGson);\n+        sendData = scanReq.getBytes();\n+\n+        logger.trace(\"Sending scan packet to {}\", mIPAddress.getHostAddress());\n+        try {\n+            DatagramSocket clientSocket = socket.get();\n+            clientSocket.setSoTimeout(DISCOVERY_TIMEOUT_MS);\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, mIPAddress, DISCOVERY_TIMEOUT_MS);\n+            clientSocket.send(sendPacket);\n+\n+            // Loop for respnses from devices until we get a timeout.\n+            boolean scanning = true;\n+            int retries = MAX_SCAN_CYCLES;\n+            while (scanning && (retries > 0)) {\n+                // Receive a response\n+                DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+                try {\n+                    clientSocket.receive(receivePacket);\n+                    InetAddress remoteAddress = receivePacket.getAddress();\n+                    int remotePort = receivePacket.getPort();\n+\n+                    // Read the response\n+                    String modifiedSentence = new String(receivePacket.getData(), \"UTF-8\");\n+                    StringReader stringReader = new StringReader(modifiedSentence);\n+                    GreeScanResponse4GsonDTO scanResponseGson = gson.fromJson(new JsonReader(stringReader),\n+                            GreeScanResponse4GsonDTO.class);\n+\n+                    // If there was no pack, ignore the response\n+                    if (scanResponseGson.pack == null) {\n+                        logger.debug(\"Invalid packet format, ignore\");\n+                        continue;\n+                    }\n+\n+                    // Decrypt message - a a GreeException is thrown when something went wrong\n+                    scanResponseGson.decryptedPack = GreeCryptoUtil\n+                            .decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(), scanResponseGson.pack);\n+                    String decryptedMsg = GreeCryptoUtil.decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\n+                            scanResponseGson.pack);\n+\n+                    logger.debug(\"Response received from address {}: {}\", remoteAddress.getHostAddress(), decryptedMsg);\n+\n+                    // Create the JSON to hold the response values\n+                    stringReader = new StringReader(decryptedMsg);\n+                    scanResponseGson.packJson = gson.fromJson(new JsonReader(stringReader),\n+                            GreeScanReponsePack4GsonDTO.class);\n+\n+                    // Now make sure the device is reported as a Gree device\n+                    if (scanResponseGson.packJson.brand.equalsIgnoreCase(\"gree\")) {\n+                        // Create a new GreeDevice\n+                        logger.debug(\"Discovered device at {}:{}\", remoteAddress.getHostAddress(), remotePort);\n+                        GreeAirDevice newDevice = new GreeAirDevice();\n+                        newDevice.setAddress(remoteAddress);\n+                        newDevice.setPort(remotePort);\n+                        newDevice.setScanResponseGson(scanResponseGson);\n+                        addDevice(newDevice);\n+                    } else {\n+                        logger.debug(\"Unit discovered, but brand is not GREE\");\n+                    }\n+\n+                    scanning = scanNetwork;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1e730ba701dc9c2bb5504f9fbbc0d2176c23490"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3NTA3NQ==", "bodyText": "what is the point of setting this to false if you are breaking out of the loop in the next statement?", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436475075", "createdAt": "2020-06-08T06:12:14Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeDeviceFinder.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.discovery;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeScanReponsePack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanRequest4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.handler.GreeAirDevice;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDeviceFinder provides functionality for searching for GREE Airconditioners on the network and keeping a list\n+ * of found devices.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeDeviceFinder {\n+    private final Logger logger = LoggerFactory.getLogger(GreeDeviceFinder.class);\n+\n+    protected final InetAddress mIPAddress;\n+    protected HashMap<String, GreeAirDevice> mDevicesHashMap = new HashMap<>();\n+\n+    public GreeDeviceFinder() {\n+        mIPAddress = InetAddress.getLoopbackAddress(); // dummy\n+    }\n+\n+    public GreeDeviceFinder(String broadcastAddress) throws UnknownHostException {\n+        mIPAddress = InetAddress.getByName(broadcastAddress);\n+    }\n+\n+    public void scan(Optional<DatagramSocket> socket, boolean scanNetwork) throws GreeException {\n+        validateSocket(socket);\n+        byte[] sendData = new byte[1024];\n+        byte[] receiveData = new byte[1024];\n+\n+        // Send the Scan message\n+        GreeScanRequest4GsonDTO scanGson = new GreeScanRequest4GsonDTO();\n+        scanGson.t = \"scan\";\n+\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        Gson gson = gsonBuilder.create();\n+        String scanReq = gson.toJson(scanGson);\n+        sendData = scanReq.getBytes();\n+\n+        logger.trace(\"Sending scan packet to {}\", mIPAddress.getHostAddress());\n+        try {\n+            DatagramSocket clientSocket = socket.get();\n+            clientSocket.setSoTimeout(DISCOVERY_TIMEOUT_MS);\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, mIPAddress, DISCOVERY_TIMEOUT_MS);\n+            clientSocket.send(sendPacket);\n+\n+            // Loop for respnses from devices until we get a timeout.\n+            boolean scanning = true;\n+            int retries = MAX_SCAN_CYCLES;\n+            while (scanning && (retries > 0)) {\n+                // Receive a response\n+                DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+                try {\n+                    clientSocket.receive(receivePacket);\n+                    InetAddress remoteAddress = receivePacket.getAddress();\n+                    int remotePort = receivePacket.getPort();\n+\n+                    // Read the response\n+                    String modifiedSentence = new String(receivePacket.getData(), \"UTF-8\");\n+                    StringReader stringReader = new StringReader(modifiedSentence);\n+                    GreeScanResponse4GsonDTO scanResponseGson = gson.fromJson(new JsonReader(stringReader),\n+                            GreeScanResponse4GsonDTO.class);\n+\n+                    // If there was no pack, ignore the response\n+                    if (scanResponseGson.pack == null) {\n+                        logger.debug(\"Invalid packet format, ignore\");\n+                        continue;\n+                    }\n+\n+                    // Decrypt message - a a GreeException is thrown when something went wrong\n+                    scanResponseGson.decryptedPack = GreeCryptoUtil\n+                            .decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(), scanResponseGson.pack);\n+                    String decryptedMsg = GreeCryptoUtil.decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\n+                            scanResponseGson.pack);\n+\n+                    logger.debug(\"Response received from address {}: {}\", remoteAddress.getHostAddress(), decryptedMsg);\n+\n+                    // Create the JSON to hold the response values\n+                    stringReader = new StringReader(decryptedMsg);\n+                    scanResponseGson.packJson = gson.fromJson(new JsonReader(stringReader),\n+                            GreeScanReponsePack4GsonDTO.class);\n+\n+                    // Now make sure the device is reported as a Gree device\n+                    if (scanResponseGson.packJson.brand.equalsIgnoreCase(\"gree\")) {\n+                        // Create a new GreeDevice\n+                        logger.debug(\"Discovered device at {}:{}\", remoteAddress.getHostAddress(), remotePort);\n+                        GreeAirDevice newDevice = new GreeAirDevice();\n+                        newDevice.setAddress(remoteAddress);\n+                        newDevice.setPort(remotePort);\n+                        newDevice.setScanResponseGson(scanResponseGson);\n+                        addDevice(newDevice);\n+                    } else {\n+                        logger.debug(\"Unit discovered, but brand is not GREE\");\n+                    }\n+\n+                    scanning = scanNetwork;\n+                } catch (SocketTimeoutException e) {\n+                    // We've received a timeout so lets quit searching for devices\n+                    scanning = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1e730ba701dc9c2bb5504f9fbbc0d2176c23490"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3NTg4Mg==", "bodyText": "Although less concise, I find this to be a bit more readable.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                if (--retries == 0) {\n          \n          \n            \n                                retries--;\n          \n          \n            \n                                if (retries == 0) {", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436475882", "createdAt": "2020-06-08T06:15:01Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeDeviceFinder.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.discovery;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeScanReponsePack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanRequest4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.handler.GreeAirDevice;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDeviceFinder provides functionality for searching for GREE Airconditioners on the network and keeping a list\n+ * of found devices.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeDeviceFinder {\n+    private final Logger logger = LoggerFactory.getLogger(GreeDeviceFinder.class);\n+\n+    protected final InetAddress mIPAddress;\n+    protected HashMap<String, GreeAirDevice> mDevicesHashMap = new HashMap<>();\n+\n+    public GreeDeviceFinder() {\n+        mIPAddress = InetAddress.getLoopbackAddress(); // dummy\n+    }\n+\n+    public GreeDeviceFinder(String broadcastAddress) throws UnknownHostException {\n+        mIPAddress = InetAddress.getByName(broadcastAddress);\n+    }\n+\n+    public void scan(Optional<DatagramSocket> socket, boolean scanNetwork) throws GreeException {\n+        validateSocket(socket);\n+        byte[] sendData = new byte[1024];\n+        byte[] receiveData = new byte[1024];\n+\n+        // Send the Scan message\n+        GreeScanRequest4GsonDTO scanGson = new GreeScanRequest4GsonDTO();\n+        scanGson.t = \"scan\";\n+\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        Gson gson = gsonBuilder.create();\n+        String scanReq = gson.toJson(scanGson);\n+        sendData = scanReq.getBytes();\n+\n+        logger.trace(\"Sending scan packet to {}\", mIPAddress.getHostAddress());\n+        try {\n+            DatagramSocket clientSocket = socket.get();\n+            clientSocket.setSoTimeout(DISCOVERY_TIMEOUT_MS);\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, mIPAddress, DISCOVERY_TIMEOUT_MS);\n+            clientSocket.send(sendPacket);\n+\n+            // Loop for respnses from devices until we get a timeout.\n+            boolean scanning = true;\n+            int retries = MAX_SCAN_CYCLES;\n+            while (scanning && (retries > 0)) {\n+                // Receive a response\n+                DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+                try {\n+                    clientSocket.receive(receivePacket);\n+                    InetAddress remoteAddress = receivePacket.getAddress();\n+                    int remotePort = receivePacket.getPort();\n+\n+                    // Read the response\n+                    String modifiedSentence = new String(receivePacket.getData(), \"UTF-8\");\n+                    StringReader stringReader = new StringReader(modifiedSentence);\n+                    GreeScanResponse4GsonDTO scanResponseGson = gson.fromJson(new JsonReader(stringReader),\n+                            GreeScanResponse4GsonDTO.class);\n+\n+                    // If there was no pack, ignore the response\n+                    if (scanResponseGson.pack == null) {\n+                        logger.debug(\"Invalid packet format, ignore\");\n+                        continue;\n+                    }\n+\n+                    // Decrypt message - a a GreeException is thrown when something went wrong\n+                    scanResponseGson.decryptedPack = GreeCryptoUtil\n+                            .decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(), scanResponseGson.pack);\n+                    String decryptedMsg = GreeCryptoUtil.decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\n+                            scanResponseGson.pack);\n+\n+                    logger.debug(\"Response received from address {}: {}\", remoteAddress.getHostAddress(), decryptedMsg);\n+\n+                    // Create the JSON to hold the response values\n+                    stringReader = new StringReader(decryptedMsg);\n+                    scanResponseGson.packJson = gson.fromJson(new JsonReader(stringReader),\n+                            GreeScanReponsePack4GsonDTO.class);\n+\n+                    // Now make sure the device is reported as a Gree device\n+                    if (scanResponseGson.packJson.brand.equalsIgnoreCase(\"gree\")) {\n+                        // Create a new GreeDevice\n+                        logger.debug(\"Discovered device at {}:{}\", remoteAddress.getHostAddress(), remotePort);\n+                        GreeAirDevice newDevice = new GreeAirDevice();\n+                        newDevice.setAddress(remoteAddress);\n+                        newDevice.setPort(remotePort);\n+                        newDevice.setScanResponseGson(scanResponseGson);\n+                        addDevice(newDevice);\n+                    } else {\n+                        logger.debug(\"Unit discovered, but brand is not GREE\");\n+                    }\n+\n+                    scanning = scanNetwork;\n+                } catch (SocketTimeoutException e) {\n+                    // We've received a timeout so lets quit searching for devices\n+                    scanning = false;\n+                    break;\n+                } catch (IOException e) {\n+                    if (--retries == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1e730ba701dc9c2bb5504f9fbbc0d2176c23490"}, "originalPosition": 142}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3NjQwMQ==", "bodyText": "Please use collection interfaces rather than concrete types if possible.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public HashMap<String, GreeAirDevice> getDevices() {\n          \n          \n            \n                public Map<String, GreeAirDevice> getDevices() {", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436476401", "createdAt": "2020-06-08T06:16:52Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeDeviceFinder.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.discovery;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeScanReponsePack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanRequest4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.handler.GreeAirDevice;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDeviceFinder provides functionality for searching for GREE Airconditioners on the network and keeping a list\n+ * of found devices.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeDeviceFinder {\n+    private final Logger logger = LoggerFactory.getLogger(GreeDeviceFinder.class);\n+\n+    protected final InetAddress mIPAddress;\n+    protected HashMap<String, GreeAirDevice> mDevicesHashMap = new HashMap<>();\n+\n+    public GreeDeviceFinder() {\n+        mIPAddress = InetAddress.getLoopbackAddress(); // dummy\n+    }\n+\n+    public GreeDeviceFinder(String broadcastAddress) throws UnknownHostException {\n+        mIPAddress = InetAddress.getByName(broadcastAddress);\n+    }\n+\n+    public void scan(Optional<DatagramSocket> socket, boolean scanNetwork) throws GreeException {\n+        validateSocket(socket);\n+        byte[] sendData = new byte[1024];\n+        byte[] receiveData = new byte[1024];\n+\n+        // Send the Scan message\n+        GreeScanRequest4GsonDTO scanGson = new GreeScanRequest4GsonDTO();\n+        scanGson.t = \"scan\";\n+\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        Gson gson = gsonBuilder.create();\n+        String scanReq = gson.toJson(scanGson);\n+        sendData = scanReq.getBytes();\n+\n+        logger.trace(\"Sending scan packet to {}\", mIPAddress.getHostAddress());\n+        try {\n+            DatagramSocket clientSocket = socket.get();\n+            clientSocket.setSoTimeout(DISCOVERY_TIMEOUT_MS);\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, mIPAddress, DISCOVERY_TIMEOUT_MS);\n+            clientSocket.send(sendPacket);\n+\n+            // Loop for respnses from devices until we get a timeout.\n+            boolean scanning = true;\n+            int retries = MAX_SCAN_CYCLES;\n+            while (scanning && (retries > 0)) {\n+                // Receive a response\n+                DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+                try {\n+                    clientSocket.receive(receivePacket);\n+                    InetAddress remoteAddress = receivePacket.getAddress();\n+                    int remotePort = receivePacket.getPort();\n+\n+                    // Read the response\n+                    String modifiedSentence = new String(receivePacket.getData(), \"UTF-8\");\n+                    StringReader stringReader = new StringReader(modifiedSentence);\n+                    GreeScanResponse4GsonDTO scanResponseGson = gson.fromJson(new JsonReader(stringReader),\n+                            GreeScanResponse4GsonDTO.class);\n+\n+                    // If there was no pack, ignore the response\n+                    if (scanResponseGson.pack == null) {\n+                        logger.debug(\"Invalid packet format, ignore\");\n+                        continue;\n+                    }\n+\n+                    // Decrypt message - a a GreeException is thrown when something went wrong\n+                    scanResponseGson.decryptedPack = GreeCryptoUtil\n+                            .decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(), scanResponseGson.pack);\n+                    String decryptedMsg = GreeCryptoUtil.decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\n+                            scanResponseGson.pack);\n+\n+                    logger.debug(\"Response received from address {}: {}\", remoteAddress.getHostAddress(), decryptedMsg);\n+\n+                    // Create the JSON to hold the response values\n+                    stringReader = new StringReader(decryptedMsg);\n+                    scanResponseGson.packJson = gson.fromJson(new JsonReader(stringReader),\n+                            GreeScanReponsePack4GsonDTO.class);\n+\n+                    // Now make sure the device is reported as a Gree device\n+                    if (scanResponseGson.packJson.brand.equalsIgnoreCase(\"gree\")) {\n+                        // Create a new GreeDevice\n+                        logger.debug(\"Discovered device at {}:{}\", remoteAddress.getHostAddress(), remotePort);\n+                        GreeAirDevice newDevice = new GreeAirDevice();\n+                        newDevice.setAddress(remoteAddress);\n+                        newDevice.setPort(remotePort);\n+                        newDevice.setScanResponseGson(scanResponseGson);\n+                        addDevice(newDevice);\n+                    } else {\n+                        logger.debug(\"Unit discovered, but brand is not GREE\");\n+                    }\n+\n+                    scanning = scanNetwork;\n+                } catch (SocketTimeoutException e) {\n+                    // We've received a timeout so lets quit searching for devices\n+                    scanning = false;\n+                    break;\n+                } catch (IOException e) {\n+                    if (--retries == 0) {\n+                        throw new GreeException(e, \"Exception on device scan\");\n+                    }\n+                }\n+            }\n+        } catch (IOException e) {\n+            throw new GreeException(e, \"I/O exception during device scan\");\n+        }\n+    }\n+\n+    public void addDevice(GreeAirDevice newDevice) {\n+        mDevicesHashMap.put(newDevice.getId(), newDevice);\n+    }\n+\n+    public GreeAirDevice getDevice(String id) {\n+        return mDevicesHashMap.get(id);\n+    }\n+\n+    public HashMap<String, GreeAirDevice> getDevices() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1e730ba701dc9c2bb5504f9fbbc0d2176c23490"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3NjY4Mg==", "bodyText": "Java will automatically handle conversion of primitive->object (aka boxing) for you.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return new Integer(mDevicesHashMap.size());\n          \n          \n            \n                    return mDevicesHashMap.size();", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436476682", "createdAt": "2020-06-08T06:17:49Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeDeviceFinder.java", "diffHunk": "@@ -0,0 +1,191 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.discovery;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeScanReponsePack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanRequest4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.handler.GreeAirDevice;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDeviceFinder provides functionality for searching for GREE Airconditioners on the network and keeping a list\n+ * of found devices.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeDeviceFinder {\n+    private final Logger logger = LoggerFactory.getLogger(GreeDeviceFinder.class);\n+\n+    protected final InetAddress mIPAddress;\n+    protected HashMap<String, GreeAirDevice> mDevicesHashMap = new HashMap<>();\n+\n+    public GreeDeviceFinder() {\n+        mIPAddress = InetAddress.getLoopbackAddress(); // dummy\n+    }\n+\n+    public GreeDeviceFinder(String broadcastAddress) throws UnknownHostException {\n+        mIPAddress = InetAddress.getByName(broadcastAddress);\n+    }\n+\n+    public void scan(Optional<DatagramSocket> socket, boolean scanNetwork) throws GreeException {\n+        validateSocket(socket);\n+        byte[] sendData = new byte[1024];\n+        byte[] receiveData = new byte[1024];\n+\n+        // Send the Scan message\n+        GreeScanRequest4GsonDTO scanGson = new GreeScanRequest4GsonDTO();\n+        scanGson.t = \"scan\";\n+\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        Gson gson = gsonBuilder.create();\n+        String scanReq = gson.toJson(scanGson);\n+        sendData = scanReq.getBytes();\n+\n+        logger.trace(\"Sending scan packet to {}\", mIPAddress.getHostAddress());\n+        try {\n+            DatagramSocket clientSocket = socket.get();\n+            clientSocket.setSoTimeout(DISCOVERY_TIMEOUT_MS);\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, mIPAddress, DISCOVERY_TIMEOUT_MS);\n+            clientSocket.send(sendPacket);\n+\n+            // Loop for respnses from devices until we get a timeout.\n+            boolean scanning = true;\n+            int retries = MAX_SCAN_CYCLES;\n+            while (scanning && (retries > 0)) {\n+                // Receive a response\n+                DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+                try {\n+                    clientSocket.receive(receivePacket);\n+                    InetAddress remoteAddress = receivePacket.getAddress();\n+                    int remotePort = receivePacket.getPort();\n+\n+                    // Read the response\n+                    String modifiedSentence = new String(receivePacket.getData(), \"UTF-8\");\n+                    StringReader stringReader = new StringReader(modifiedSentence);\n+                    GreeScanResponse4GsonDTO scanResponseGson = gson.fromJson(new JsonReader(stringReader),\n+                            GreeScanResponse4GsonDTO.class);\n+\n+                    // If there was no pack, ignore the response\n+                    if (scanResponseGson.pack == null) {\n+                        logger.debug(\"Invalid packet format, ignore\");\n+                        continue;\n+                    }\n+\n+                    // Decrypt message - a a GreeException is thrown when something went wrong\n+                    scanResponseGson.decryptedPack = GreeCryptoUtil\n+                            .decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(), scanResponseGson.pack);\n+                    String decryptedMsg = GreeCryptoUtil.decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\n+                            scanResponseGson.pack);\n+\n+                    logger.debug(\"Response received from address {}: {}\", remoteAddress.getHostAddress(), decryptedMsg);\n+\n+                    // Create the JSON to hold the response values\n+                    stringReader = new StringReader(decryptedMsg);\n+                    scanResponseGson.packJson = gson.fromJson(new JsonReader(stringReader),\n+                            GreeScanReponsePack4GsonDTO.class);\n+\n+                    // Now make sure the device is reported as a Gree device\n+                    if (scanResponseGson.packJson.brand.equalsIgnoreCase(\"gree\")) {\n+                        // Create a new GreeDevice\n+                        logger.debug(\"Discovered device at {}:{}\", remoteAddress.getHostAddress(), remotePort);\n+                        GreeAirDevice newDevice = new GreeAirDevice();\n+                        newDevice.setAddress(remoteAddress);\n+                        newDevice.setPort(remotePort);\n+                        newDevice.setScanResponseGson(scanResponseGson);\n+                        addDevice(newDevice);\n+                    } else {\n+                        logger.debug(\"Unit discovered, but brand is not GREE\");\n+                    }\n+\n+                    scanning = scanNetwork;\n+                } catch (SocketTimeoutException e) {\n+                    // We've received a timeout so lets quit searching for devices\n+                    scanning = false;\n+                    break;\n+                } catch (IOException e) {\n+                    if (--retries == 0) {\n+                        throw new GreeException(e, \"Exception on device scan\");\n+                    }\n+                }\n+            }\n+        } catch (IOException e) {\n+            throw new GreeException(e, \"I/O exception during device scan\");\n+        }\n+    }\n+\n+    public void addDevice(GreeAirDevice newDevice) {\n+        mDevicesHashMap.put(newDevice.getId(), newDevice);\n+    }\n+\n+    public GreeAirDevice getDevice(String id) {\n+        return mDevicesHashMap.get(id);\n+    }\n+\n+    public HashMap<String, GreeAirDevice> getDevices() {\n+        return mDevicesHashMap;\n+    }\n+\n+    public @Nullable GreeAirDevice getDeviceByIPAddress(String ipAddress) {\n+        GreeAirDevice returnDevice = null;\n+\n+        Set<String> keySet = mDevicesHashMap.keySet();\n+        Iterator<String> iter = keySet.iterator();\n+        while (returnDevice == null && iter.hasNext()) {\n+            Object thiskey = iter.next();\n+            if (mDevicesHashMap.containsKey(thiskey)) {\n+                GreeAirDevice currDevice = mDevicesHashMap.get(thiskey);\n+                if (currDevice.getAddress().getHostAddress().equals(ipAddress)) {\n+                    returnDevice = currDevice;\n+                }\n+            }\n+        }\n+\n+        return returnDevice;\n+    }\n+\n+    public Integer getScannedDeviceCount() {\n+        return new Integer(mDevicesHashMap.size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1e730ba701dc9c2bb5504f9fbbc0d2176c23490"}, "originalPosition": 183}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3NzA5OQ==", "bodyText": "You should make sure to call the super's destructor last.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    super.deactivate();\n          \n          \n            \n                    removeOlderResults(getTimestampOfLastScan());\n          \n          \n            \n                    removeOlderResults(getTimestampOfLastScan());\n          \n          \n            \n                    super.deactivate();", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436477099", "createdAt": "2020-06-08T06:19:23Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeDiscoveryService.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.gree.internal.discovery;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramSocket;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.i18n.LocaleProvider;\n+import org.eclipse.smarthome.core.i18n.TranslationProvider;\n+import org.eclipse.smarthome.core.net.NetworkAddressService;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.handler.GreeAirDevice;\n+import org.osgi.framework.Bundle;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Modified;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link GreeDiscoveryService} implements the device discovery service. UDP broadtcast ius used to find the devices on\n+ * the local subnet.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+@Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.gree\")\n+public class GreeDiscoveryService extends AbstractDiscoveryService {\n+    private static final int TIMEOUT_SEC = 10;\n+    private final Logger logger = LoggerFactory.getLogger(GreeDiscoveryService.class);\n+    private final GreeTranslationProvider messages;\n+    private final String broadcastAddress;\n+\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+\n+    @Activate\n+    public GreeDiscoveryService(@Reference NetworkAddressService networkAddressService,\n+            @Reference LocaleProvider localeProvider, @Reference TranslationProvider i18nProvider) {\n+        super(SUPPORTED_THING_TYPES_UIDS, TIMEOUT_SEC);\n+        Bundle bundle = FrameworkUtil.getBundle(this.getClass());\n+        messages = new GreeTranslationProvider(bundle.getBundleContext().getBundle(), i18nProvider, localeProvider);\n+        String ip = networkAddressService.getConfiguredBroadcastAddress();\n+        broadcastAddress = ip != null ? ip : \"\";\n+    }\n+\n+    @Override\n+    protected void activate(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.activate(configProperties);\n+    }\n+\n+    @Override\n+    @Modified\n+    protected void modified(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.modified(configProperties);\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        // It's very unusual that a new unit gets installed frequently so we run the discovery once when the binding is\n+        // started, but not frequently\n+        scheduler.execute(() -> {\n+            startScan();\n+        });\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        stopScan();\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        Optional<DatagramSocket> clientSocket = Optional.empty();\n+        try {\n+            clientSocket = Optional.of(new DatagramSocket());\n+            deviceFinder = new GreeDeviceFinder(broadcastAddress);\n+            deviceFinder.scan(clientSocket, true);\n+\n+            int count = deviceFinder.getScannedDeviceCount();\n+            logger.info(\"{}\", messages.get(\"discovery.result\", count));\n+            if (count > 0) {\n+                logger.debug(\"Adding uinits to Inbox\");\n+                createResult(deviceFinder.getDevices());\n+            }\n+        } catch (GreeException e) {\n+            logger.warn(\"Discovery failed: {}\", e.toString());\n+        } catch (IOException e) {\n+            logger.debug(\"Discovery failed: {}\", e.toString());\n+        } catch (RuntimeException e) {\n+            logger.warn(\"Discovery failed\", e);\n+        } finally {\n+            if (clientSocket.isPresent()) {\n+                clientSocket.get().close();\n+            }\n+        }\n+    }\n+\n+    public void createResult(HashMap<String, GreeAirDevice> deviceList) {\n+        for (Map.Entry<String, GreeAirDevice> d : deviceList.entrySet()) {\n+            GreeAirDevice device = d.getValue();\n+            String ipAddress = device.getAddress().getHostAddress();\n+            logger.debug(\"{}\", messages.get(\"discovery.newunit\", device.getName(), ipAddress, device.getId()));\n+            Map<String, Object> properties = new TreeMap<String, Object>();\n+            properties.put(Thing.PROPERTY_VENDOR, device.getVendor());\n+            properties.put(Thing.PROPERTY_MODEL_ID, device.getModel());\n+            properties.put(Thing.PROPERTY_MAC_ADDRESS, device.getId());\n+            properties.put(PROPERTY_IP, ipAddress);\n+            properties.put(PROPERTY_BROADCAST, broadcastAddress);\n+            ThingUID thingUID = new ThingUID(THING_TYPE_GREEAIRCON, device.getId());\n+            DiscoveryResult result = DiscoveryResultBuilder.create(thingUID).withProperties(properties)\n+                    .withRepresentationProperty(device.getId()).withLabel(device.getName()).build();\n+            thingDiscovered(result);\n+        }\n+    }\n+\n+    @Override\n+    public void deactivate() {\n+        super.deactivate();\n+        removeOlderResults(getTimestampOfLastScan());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1e730ba701dc9c2bb5504f9fbbc0d2176c23490"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3NzQ4Ng==", "bodyText": "I don't see why clientSocket is Optional here. Please just use a regular local variable instead.", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436477486", "createdAt": "2020-06-08T06:20:44Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeDiscoveryService.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.gree.internal.discovery;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramSocket;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.i18n.LocaleProvider;\n+import org.eclipse.smarthome.core.i18n.TranslationProvider;\n+import org.eclipse.smarthome.core.net.NetworkAddressService;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.handler.GreeAirDevice;\n+import org.osgi.framework.Bundle;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Modified;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link GreeDiscoveryService} implements the device discovery service. UDP broadtcast ius used to find the devices on\n+ * the local subnet.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+@Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.gree\")\n+public class GreeDiscoveryService extends AbstractDiscoveryService {\n+    private static final int TIMEOUT_SEC = 10;\n+    private final Logger logger = LoggerFactory.getLogger(GreeDiscoveryService.class);\n+    private final GreeTranslationProvider messages;\n+    private final String broadcastAddress;\n+\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+\n+    @Activate\n+    public GreeDiscoveryService(@Reference NetworkAddressService networkAddressService,\n+            @Reference LocaleProvider localeProvider, @Reference TranslationProvider i18nProvider) {\n+        super(SUPPORTED_THING_TYPES_UIDS, TIMEOUT_SEC);\n+        Bundle bundle = FrameworkUtil.getBundle(this.getClass());\n+        messages = new GreeTranslationProvider(bundle.getBundleContext().getBundle(), i18nProvider, localeProvider);\n+        String ip = networkAddressService.getConfiguredBroadcastAddress();\n+        broadcastAddress = ip != null ? ip : \"\";\n+    }\n+\n+    @Override\n+    protected void activate(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.activate(configProperties);\n+    }\n+\n+    @Override\n+    @Modified\n+    protected void modified(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.modified(configProperties);\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        // It's very unusual that a new unit gets installed frequently so we run the discovery once when the binding is\n+        // started, but not frequently\n+        scheduler.execute(() -> {\n+            startScan();\n+        });\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        stopScan();\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        Optional<DatagramSocket> clientSocket = Optional.empty();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1e730ba701dc9c2bb5504f9fbbc0d2176c23490"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3Nzg0NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    for (Map.Entry<String, GreeAirDevice> d : deviceList.entrySet()) {\n          \n          \n            \n                        GreeAirDevice device = d.getValue();\n          \n          \n            \n                    for (GreeAirDevice device : deviceList.values()) {", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436477845", "createdAt": "2020-06-08T06:21:57Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeDiscoveryService.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.gree.internal.discovery;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramSocket;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.i18n.LocaleProvider;\n+import org.eclipse.smarthome.core.i18n.TranslationProvider;\n+import org.eclipse.smarthome.core.net.NetworkAddressService;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.handler.GreeAirDevice;\n+import org.osgi.framework.Bundle;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Modified;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link GreeDiscoveryService} implements the device discovery service. UDP broadtcast ius used to find the devices on\n+ * the local subnet.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+@Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.gree\")\n+public class GreeDiscoveryService extends AbstractDiscoveryService {\n+    private static final int TIMEOUT_SEC = 10;\n+    private final Logger logger = LoggerFactory.getLogger(GreeDiscoveryService.class);\n+    private final GreeTranslationProvider messages;\n+    private final String broadcastAddress;\n+\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+\n+    @Activate\n+    public GreeDiscoveryService(@Reference NetworkAddressService networkAddressService,\n+            @Reference LocaleProvider localeProvider, @Reference TranslationProvider i18nProvider) {\n+        super(SUPPORTED_THING_TYPES_UIDS, TIMEOUT_SEC);\n+        Bundle bundle = FrameworkUtil.getBundle(this.getClass());\n+        messages = new GreeTranslationProvider(bundle.getBundleContext().getBundle(), i18nProvider, localeProvider);\n+        String ip = networkAddressService.getConfiguredBroadcastAddress();\n+        broadcastAddress = ip != null ? ip : \"\";\n+    }\n+\n+    @Override\n+    protected void activate(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.activate(configProperties);\n+    }\n+\n+    @Override\n+    @Modified\n+    protected void modified(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.modified(configProperties);\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        // It's very unusual that a new unit gets installed frequently so we run the discovery once when the binding is\n+        // started, but not frequently\n+        scheduler.execute(() -> {\n+            startScan();\n+        });\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        stopScan();\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        Optional<DatagramSocket> clientSocket = Optional.empty();\n+        try {\n+            clientSocket = Optional.of(new DatagramSocket());\n+            deviceFinder = new GreeDeviceFinder(broadcastAddress);\n+            deviceFinder.scan(clientSocket, true);\n+\n+            int count = deviceFinder.getScannedDeviceCount();\n+            logger.info(\"{}\", messages.get(\"discovery.result\", count));\n+            if (count > 0) {\n+                logger.debug(\"Adding uinits to Inbox\");\n+                createResult(deviceFinder.getDevices());\n+            }\n+        } catch (GreeException e) {\n+            logger.warn(\"Discovery failed: {}\", e.toString());\n+        } catch (IOException e) {\n+            logger.debug(\"Discovery failed: {}\", e.toString());\n+        } catch (RuntimeException e) {\n+            logger.warn(\"Discovery failed\", e);\n+        } finally {\n+            if (clientSocket.isPresent()) {\n+                clientSocket.get().close();\n+            }\n+        }\n+    }\n+\n+    public void createResult(HashMap<String, GreeAirDevice> deviceList) {\n+        for (Map.Entry<String, GreeAirDevice> d : deviceList.entrySet()) {\n+            GreeAirDevice device = d.getValue();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1e730ba701dc9c2bb5504f9fbbc0d2176c23490"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3NzkyMQ==", "bodyText": "I don't know why you are using a TreeMap here.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        Map<String, Object> properties = new TreeMap<String, Object>();\n          \n          \n            \n                        Map<String, Object> properties = new HashMap<>();", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436477921", "createdAt": "2020-06-08T06:22:08Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeDiscoveryService.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.gree.internal.discovery;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramSocket;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.i18n.LocaleProvider;\n+import org.eclipse.smarthome.core.i18n.TranslationProvider;\n+import org.eclipse.smarthome.core.net.NetworkAddressService;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.handler.GreeAirDevice;\n+import org.osgi.framework.Bundle;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Modified;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link GreeDiscoveryService} implements the device discovery service. UDP broadtcast ius used to find the devices on\n+ * the local subnet.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+@Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.gree\")\n+public class GreeDiscoveryService extends AbstractDiscoveryService {\n+    private static final int TIMEOUT_SEC = 10;\n+    private final Logger logger = LoggerFactory.getLogger(GreeDiscoveryService.class);\n+    private final GreeTranslationProvider messages;\n+    private final String broadcastAddress;\n+\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+\n+    @Activate\n+    public GreeDiscoveryService(@Reference NetworkAddressService networkAddressService,\n+            @Reference LocaleProvider localeProvider, @Reference TranslationProvider i18nProvider) {\n+        super(SUPPORTED_THING_TYPES_UIDS, TIMEOUT_SEC);\n+        Bundle bundle = FrameworkUtil.getBundle(this.getClass());\n+        messages = new GreeTranslationProvider(bundle.getBundleContext().getBundle(), i18nProvider, localeProvider);\n+        String ip = networkAddressService.getConfiguredBroadcastAddress();\n+        broadcastAddress = ip != null ? ip : \"\";\n+    }\n+\n+    @Override\n+    protected void activate(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.activate(configProperties);\n+    }\n+\n+    @Override\n+    @Modified\n+    protected void modified(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.modified(configProperties);\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        // It's very unusual that a new unit gets installed frequently so we run the discovery once when the binding is\n+        // started, but not frequently\n+        scheduler.execute(() -> {\n+            startScan();\n+        });\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        stopScan();\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        Optional<DatagramSocket> clientSocket = Optional.empty();\n+        try {\n+            clientSocket = Optional.of(new DatagramSocket());\n+            deviceFinder = new GreeDeviceFinder(broadcastAddress);\n+            deviceFinder.scan(clientSocket, true);\n+\n+            int count = deviceFinder.getScannedDeviceCount();\n+            logger.info(\"{}\", messages.get(\"discovery.result\", count));\n+            if (count > 0) {\n+                logger.debug(\"Adding uinits to Inbox\");\n+                createResult(deviceFinder.getDevices());\n+            }\n+        } catch (GreeException e) {\n+            logger.warn(\"Discovery failed: {}\", e.toString());\n+        } catch (IOException e) {\n+            logger.debug(\"Discovery failed: {}\", e.toString());\n+        } catch (RuntimeException e) {\n+            logger.warn(\"Discovery failed\", e);\n+        } finally {\n+            if (clientSocket.isPresent()) {\n+                clientSocket.get().close();\n+            }\n+        }\n+    }\n+\n+    public void createResult(HashMap<String, GreeAirDevice> deviceList) {\n+        for (Map.Entry<String, GreeAirDevice> d : deviceList.entrySet()) {\n+            GreeAirDevice device = d.getValue();\n+            String ipAddress = device.getAddress().getHostAddress();\n+            logger.debug(\"{}\", messages.get(\"discovery.newunit\", device.getName(), ipAddress, device.getId()));\n+            Map<String, Object> properties = new TreeMap<String, Object>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1e730ba701dc9c2bb5504f9fbbc0d2176c23490"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ3OTE0Mw==", "bodyText": "It seems redundant to always use 4GsonDTO as your suffix, just using a DTO suffix would be sufficient without being verbose. I'd prefer if you updated the other DTO classes as well.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            public class GreeBindRequest4GsonDTO {\n          \n          \n            \n            public class GreeBindRequestDTO {", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436479143", "createdAt": "2020-06-08T06:25:58Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/gson/GreeBindRequest4GsonDTO.java", "diffHunk": "@@ -0,0 +1,30 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.gson;\n+\n+/**\n+ *\n+ * The GreeBindRequest4Gson class is used by Gson to hold values to be send to\n+ * the Air Conditioner during Binding\n+ *\n+ * @author John Cunha - Initial contribution\n+ */\n+public class GreeBindRequest4GsonDTO {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1e730ba701dc9c2bb5504f9fbbc0d2176c23490"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4MDIzNA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Runnable refresher = new Runnable() {\n          \n          \n            \n                        @Override\n          \n          \n            \n                        public void run() {\n          \n          \n            \n                    Runnable refresher = () -> {", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436480234", "createdAt": "2020-06-08T06:29:17Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeHandler.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.net.DatagramSocket;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.ImperialUnits;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.gree.internal.GreeConfiguration;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.discovery.GreeDeviceFinder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import tec.uom.se.unit.Units;\n+\n+/**\n+ * The {@link GreeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(GreeHandler.class);\n+    private final GreeTranslationProvider messages;\n+    private GreeConfiguration config = new GreeConfiguration();\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+    private GreeAirDevice device = new GreeAirDevice();\n+    private Optional<DatagramSocket> clientSocket = Optional.empty();\n+\n+    private @Nullable ScheduledFuture<?> refreshTask;\n+    private long lastRefreshTime = 0;\n+\n+    public GreeHandler(Thing thing, GreeTranslationProvider messages) {\n+        super(thing);\n+        this.messages = messages;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(GreeConfiguration.class);\n+        logger.debug(\"Config for {} is {}\", thing.getUID(), config.toString());\n+        if (config.ipAddress.isEmpty() || (config.refresh < 0)) {\n+            logger.warn(\"Config of {} is invalid. Check configuration\", thing.getUID());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid configuration. Check thing configuration.\");\n+            return;\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.execute(() -> {\n+            initializeThing();\n+        });\n+    }\n+\n+    private void initializeThing() {\n+        try {\n+            // Create a new Datagram socket with a specified timeout\n+            clientSocket = Optional.of(new DatagramSocket());\n+            clientSocket.get().setSoTimeout(DATAGRAM_SOCKET_TIMEOUT);\n+\n+            // Find the GREE device\n+            deviceFinder = new GreeDeviceFinder(config.ipAddress);\n+            deviceFinder.scan(clientSocket, false);\n+            logger.debug(\"{} units found matching IP address\", deviceFinder.getScannedDeviceCount());\n+\n+            // Now check that this one is amongst the air conditioners that responded.\n+            GreeAirDevice newDevice = deviceFinder.getDeviceByIPAddress(config.ipAddress);\n+            if (newDevice != null) {\n+                // Ok, our device responded, now let's Bind with it\n+                device = newDevice;\n+                device.bindWithDevice(clientSocket);\n+                if (device.getIsBound()) {\n+                    updateStatus(ThingStatus.ONLINE);\n+\n+                    // Start the automatic refresh cycles\n+                    startAutomaticRefresh();\n+                    return;\n+                }\n+            }\n+            logger.debug(\"GREE unit is not responding\");\n+        } catch (GreeException e) {\n+            logger.warn(\"Initialization failed: {}\", messages.get(\"thinginit.exception\", e.toString()));\n+        } catch (IOException e) {\n+            logger.debug(\"Exception on initialization: {}\", e.toString());\n+        } catch (RuntimeException e) {\n+            logger.warn(\"Initialization failed\", e);\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            // The thing is updated by the scheduled automatic refresh so do nothing here.\n+        } else {\n+            if (!clientSocket.isPresent()) {\n+                logger.warn(\"Thing not properly initialized, abort command\");\n+                return;\n+            }\n+\n+            DatagramSocket socket = clientSocket.get();\n+            logger.debug(\"Issue command {}\u00a0to channe {}\", command, channelUID.getIdWithoutGroup());\n+            String channelId = channelUID.getIdWithoutGroup();\n+            logger.debug(\"Handle command {} for channel {}, command class {}\", command, channelId, command.getClass());\n+            try {\n+                switch (channelId) {\n+                    case MODE_CHANNEL:\n+                        handleModeCommand(command, socket);\n+                        break;\n+                    case POWER_CHANNEL:\n+                        device.setDevicePower(socket, getOnOff(command));\n+                        break;\n+                    case TURBO_CHANNEL:\n+                        device.setDeviceTurbo(socket, getOnOff(command));\n+                        break;\n+                    case LIGHT_CHANNEL:\n+                        device.setDeviceLight(socket, getOnOff(command));\n+                        break;\n+                    case TEMP_CHANNEL:\n+                        device.setDeviceTempSet(socket, (int) getTemp(command));\n+                        break;\n+                    case SWINGUD_CHANNEL:\n+                        device.setDeviceSwingUpDown(socket, getNumber(command));\n+                        break;\n+                    case SWINGLR_CHANNEL:\n+                        device.setDeviceSwingLeftRight(socket, getNumber(command));\n+                        break;\n+                    case WINDSPEED_CHANNEL:\n+                        device.setDeviceWindspeed(socket, getNumber(command));\n+                        break;\n+                    case QUIET_CHANNEL:\n+                        handleQuietCommand(command, socket);\n+                        break;\n+                    case AIR_CHANNEL:\n+                        device.setDeviceAir(socket, getOnOff(command));\n+                        break;\n+                    case DRY_CHANNEL:\n+                        device.setDeviceDry(socket, getOnOff(command));\n+                        break;\n+                    case HEALTH_CHANNEL:\n+                        device.setDeviceHealth(socket, getOnOff(command));\n+                        break;\n+                    case PWRSAV_CHANNEL:\n+                        device.setDevicePwrSaving(socket, getOnOff(command));\n+                        break;\n+                }\n+            } catch (GreeException e) {\n+                logger.debug(\"Unable to execute command {}\u00a0for channel {}: {}\", command, channelId, e.toString());\n+            } catch (IllegalArgumentException e) {\n+                logger.warn(\"Invalid command value {}\u00a0for channel {}\", command, channelUID.getId());\n+            } catch (RuntimeException e) {\n+                logger.warn(\"Unable to execute command {}\u00a0for channel {}\", command, channelId, e);\n+            }\n+        }\n+    }\n+\n+    private void handleModeCommand(Command command, DatagramSocket socket) throws GreeException {\n+        int mode = -1;\n+        String modeStr = \"\";\n+        boolean isNumber = false;\n+        if (command instanceof DecimalType) {\n+            // backward compatibility when channel was Number\n+            mode = ((DecimalType) command).intValue();\n+        } else if (command instanceof OnOffType) {\n+            // Switch\n+            logger.debug(\"Send Power-{}\", command);\n+            device.setDevicePower(socket, getOnOff(command));\n+        } else /* String */ {\n+            modeStr = command.toString().toLowerCase();\n+            switch (modeStr) {\n+                case MODE_AUTO:\n+                    mode = GREE_MODE_AUTO;\n+                    break;\n+                case MODE_COOL:\n+                    mode = GREE_MODE_COOL;\n+                    break;\n+                case MODE_HEAT:\n+                    mode = GREE_MODE_HEAT;\n+                    break;\n+                case MODE_DRY:\n+                    mode = GREE_MODE_DRY;\n+                    break;\n+                case MODE_FAN:\n+                case MODE_FAN2:\n+                    mode = GREE_MODE_FAN;\n+                    break;\n+                case MODE_ECO:\n+                    // power saving will be set after the uinit was turned on\n+                    mode = GREE_MODE_COOL;\n+                    break;\n+                case MODE_ON:\n+                case MODE_OFF:\n+                    device.setDevicePower(socket, modeStr.equals(MODE_ON) ? 1 : 0);\n+                    break;\n+                default:\n+                    // fallback: mode number, pass transparent\n+                    // if string is not parsable parseInt() throws an exception\n+                    mode = Integer.parseInt(modeStr);\n+                    isNumber = true;\n+                    break;\n+            }\n+            logger.debug(\"Mode {} mapped to {}\", modeStr, mode);\n+        }\n+\n+        if (mode == -1) {\n+            throw new IllegalArgumentException(\"Invalid Mode selection\");\n+        }\n+\n+        // Turn on the unit if currently off\n+        if (!isNumber && (device.getIntStatusVal(\"Pow\") == 0)) {\n+            logger.debug(\"Send Auto-ON for mode {}\", mode);\n+            device.setDevicePower(socket, 1);\n+        }\n+\n+        // Select mode\n+        logger.debug(\"Select mode {}\", mode);\n+        device.SetDeviceMode(socket, mode);\n+\n+        // Check for secondary action\n+        switch (modeStr) {\n+            case MODE_ECO:\n+                // Turn on power saving for eco mode\n+                logger.debug(\"Turn on Power-Saving\");\n+                device.setDevicePwrSaving(socket, 1);\n+                break;\n+            case MODE_TURBO:\n+                device.setDeviceTurbo(socket, 1);\n+                break;\n+        }\n+    }\n+\n+    private void handleQuietCommand(Command command, DatagramSocket socket) throws GreeException {\n+        int mode = -1;\n+        if (command instanceof DecimalType) {\n+            mode = ((DecimalType) command).intValue();\n+        } else if (command instanceof StringType) {\n+            switch (command.toString().toLowerCase()) {\n+                case QUIET_OFF:\n+                    mode = GREE_QUIET_OFF;\n+                    break;\n+                case QUIET_AUTO:\n+                    mode = GREE_QUIET_AUTO;\n+                    break;\n+                case QUIET_QUIET:\n+                    mode = GREE_QUIET_QUIET;\n+                    break;\n+            }\n+        }\n+        if (mode != -1) {\n+            device.setQuietMode(socket, mode);\n+        }\n+        throw new IllegalArgumentException(\"Invalid QuietType\");\n+    }\n+\n+    private int getOnOff(Command command) {\n+        if (command instanceof OnOffType) {\n+            return ((OnOffType) command) == OnOffType.ON ? 1 : 0;\n+        }\n+        if ((command instanceof DecimalType) && (((DecimalType) command).intValue() <= 2)) {\n+            return ((DecimalType) command).intValue();\n+        }\n+        throw new IllegalArgumentException(\"Invalid OnOffType\");\n+    }\n+\n+    private int getNumber(Command command) {\n+        if (command instanceof DecimalType) {\n+            return ((DecimalType) command).intValue();\n+        }\n+        throw new IllegalArgumentException(\"Invalud Number type\");\n+    }\n+\n+    private double getTemp(Command command) {\n+        if (command instanceof DecimalType) {\n+            // assume Celsius\n+            return ((DecimalType) command).doubleValue();\n+        }\n+        if (command instanceof QuantityType) {\n+            QuantityType<?> q = (QuantityType<?>) command;\n+            if (q.getUnit() == Units.CELSIUS) {\n+                return q.intValue();\n+            }\n+            if (q.getUnit() == ImperialUnits.FAHRENHEIT) {\n+                return ImperialUnits.FAHRENHEIT.getConverterTo(Units.CELSIUS).convert(q.doubleValue());\n+            }\n+        }\n+        throw new IllegalArgumentException(\"Invalud Temp type\");\n+    }\n+\n+    private boolean isMinimumRefreshTimeExceeded() {\n+        long currentTime = System.currentTimeMillis();\n+        long timeSinceLastRefresh = currentTime - lastRefreshTime;\n+        if (timeSinceLastRefresh < MINIMUM_REFRESH_TIME_MS) {\n+            return false;\n+        }\n+        lastRefreshTime = currentTime;\n+        return true;\n+    }\n+\n+    private void startAutomaticRefresh() {\n+\n+        Runnable refresher = new Runnable() {\n+            @Override\n+            public void run() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1e730ba701dc9c2bb5504f9fbbc0d2176c23490"}, "originalPosition": 345}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4MTE1Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if (q.getUnit() == Units.CELSIUS) {\n          \n          \n            \n                            return q.intValue();\n          \n          \n            \n                        }\n          \n          \n            \n                        if (q.getUnit() == ImperialUnits.FAHRENHEIT) {\n          \n          \n            \n                            return ImperialUnits.FAHRENHEIT.getConverterTo(Units.CELSIUS).convert(q.doubleValue());\n          \n          \n            \n                        }\n          \n          \n            \n                        return q.toUnit(SIUnits.CELSIUS).doubleValue();", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436481157", "createdAt": "2020-06-08T06:32:01Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeHandler.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.net.DatagramSocket;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.ImperialUnits;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.gree.internal.GreeConfiguration;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.discovery.GreeDeviceFinder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import tec.uom.se.unit.Units;\n+\n+/**\n+ * The {@link GreeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(GreeHandler.class);\n+    private final GreeTranslationProvider messages;\n+    private GreeConfiguration config = new GreeConfiguration();\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+    private GreeAirDevice device = new GreeAirDevice();\n+    private Optional<DatagramSocket> clientSocket = Optional.empty();\n+\n+    private @Nullable ScheduledFuture<?> refreshTask;\n+    private long lastRefreshTime = 0;\n+\n+    public GreeHandler(Thing thing, GreeTranslationProvider messages) {\n+        super(thing);\n+        this.messages = messages;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(GreeConfiguration.class);\n+        logger.debug(\"Config for {} is {}\", thing.getUID(), config.toString());\n+        if (config.ipAddress.isEmpty() || (config.refresh < 0)) {\n+            logger.warn(\"Config of {} is invalid. Check configuration\", thing.getUID());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid configuration. Check thing configuration.\");\n+            return;\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.execute(() -> {\n+            initializeThing();\n+        });\n+    }\n+\n+    private void initializeThing() {\n+        try {\n+            // Create a new Datagram socket with a specified timeout\n+            clientSocket = Optional.of(new DatagramSocket());\n+            clientSocket.get().setSoTimeout(DATAGRAM_SOCKET_TIMEOUT);\n+\n+            // Find the GREE device\n+            deviceFinder = new GreeDeviceFinder(config.ipAddress);\n+            deviceFinder.scan(clientSocket, false);\n+            logger.debug(\"{} units found matching IP address\", deviceFinder.getScannedDeviceCount());\n+\n+            // Now check that this one is amongst the air conditioners that responded.\n+            GreeAirDevice newDevice = deviceFinder.getDeviceByIPAddress(config.ipAddress);\n+            if (newDevice != null) {\n+                // Ok, our device responded, now let's Bind with it\n+                device = newDevice;\n+                device.bindWithDevice(clientSocket);\n+                if (device.getIsBound()) {\n+                    updateStatus(ThingStatus.ONLINE);\n+\n+                    // Start the automatic refresh cycles\n+                    startAutomaticRefresh();\n+                    return;\n+                }\n+            }\n+            logger.debug(\"GREE unit is not responding\");\n+        } catch (GreeException e) {\n+            logger.warn(\"Initialization failed: {}\", messages.get(\"thinginit.exception\", e.toString()));\n+        } catch (IOException e) {\n+            logger.debug(\"Exception on initialization: {}\", e.toString());\n+        } catch (RuntimeException e) {\n+            logger.warn(\"Initialization failed\", e);\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            // The thing is updated by the scheduled automatic refresh so do nothing here.\n+        } else {\n+            if (!clientSocket.isPresent()) {\n+                logger.warn(\"Thing not properly initialized, abort command\");\n+                return;\n+            }\n+\n+            DatagramSocket socket = clientSocket.get();\n+            logger.debug(\"Issue command {}\u00a0to channe {}\", command, channelUID.getIdWithoutGroup());\n+            String channelId = channelUID.getIdWithoutGroup();\n+            logger.debug(\"Handle command {} for channel {}, command class {}\", command, channelId, command.getClass());\n+            try {\n+                switch (channelId) {\n+                    case MODE_CHANNEL:\n+                        handleModeCommand(command, socket);\n+                        break;\n+                    case POWER_CHANNEL:\n+                        device.setDevicePower(socket, getOnOff(command));\n+                        break;\n+                    case TURBO_CHANNEL:\n+                        device.setDeviceTurbo(socket, getOnOff(command));\n+                        break;\n+                    case LIGHT_CHANNEL:\n+                        device.setDeviceLight(socket, getOnOff(command));\n+                        break;\n+                    case TEMP_CHANNEL:\n+                        device.setDeviceTempSet(socket, (int) getTemp(command));\n+                        break;\n+                    case SWINGUD_CHANNEL:\n+                        device.setDeviceSwingUpDown(socket, getNumber(command));\n+                        break;\n+                    case SWINGLR_CHANNEL:\n+                        device.setDeviceSwingLeftRight(socket, getNumber(command));\n+                        break;\n+                    case WINDSPEED_CHANNEL:\n+                        device.setDeviceWindspeed(socket, getNumber(command));\n+                        break;\n+                    case QUIET_CHANNEL:\n+                        handleQuietCommand(command, socket);\n+                        break;\n+                    case AIR_CHANNEL:\n+                        device.setDeviceAir(socket, getOnOff(command));\n+                        break;\n+                    case DRY_CHANNEL:\n+                        device.setDeviceDry(socket, getOnOff(command));\n+                        break;\n+                    case HEALTH_CHANNEL:\n+                        device.setDeviceHealth(socket, getOnOff(command));\n+                        break;\n+                    case PWRSAV_CHANNEL:\n+                        device.setDevicePwrSaving(socket, getOnOff(command));\n+                        break;\n+                }\n+            } catch (GreeException e) {\n+                logger.debug(\"Unable to execute command {}\u00a0for channel {}: {}\", command, channelId, e.toString());\n+            } catch (IllegalArgumentException e) {\n+                logger.warn(\"Invalid command value {}\u00a0for channel {}\", command, channelUID.getId());\n+            } catch (RuntimeException e) {\n+                logger.warn(\"Unable to execute command {}\u00a0for channel {}\", command, channelId, e);\n+            }\n+        }\n+    }\n+\n+    private void handleModeCommand(Command command, DatagramSocket socket) throws GreeException {\n+        int mode = -1;\n+        String modeStr = \"\";\n+        boolean isNumber = false;\n+        if (command instanceof DecimalType) {\n+            // backward compatibility when channel was Number\n+            mode = ((DecimalType) command).intValue();\n+        } else if (command instanceof OnOffType) {\n+            // Switch\n+            logger.debug(\"Send Power-{}\", command);\n+            device.setDevicePower(socket, getOnOff(command));\n+        } else /* String */ {\n+            modeStr = command.toString().toLowerCase();\n+            switch (modeStr) {\n+                case MODE_AUTO:\n+                    mode = GREE_MODE_AUTO;\n+                    break;\n+                case MODE_COOL:\n+                    mode = GREE_MODE_COOL;\n+                    break;\n+                case MODE_HEAT:\n+                    mode = GREE_MODE_HEAT;\n+                    break;\n+                case MODE_DRY:\n+                    mode = GREE_MODE_DRY;\n+                    break;\n+                case MODE_FAN:\n+                case MODE_FAN2:\n+                    mode = GREE_MODE_FAN;\n+                    break;\n+                case MODE_ECO:\n+                    // power saving will be set after the uinit was turned on\n+                    mode = GREE_MODE_COOL;\n+                    break;\n+                case MODE_ON:\n+                case MODE_OFF:\n+                    device.setDevicePower(socket, modeStr.equals(MODE_ON) ? 1 : 0);\n+                    break;\n+                default:\n+                    // fallback: mode number, pass transparent\n+                    // if string is not parsable parseInt() throws an exception\n+                    mode = Integer.parseInt(modeStr);\n+                    isNumber = true;\n+                    break;\n+            }\n+            logger.debug(\"Mode {} mapped to {}\", modeStr, mode);\n+        }\n+\n+        if (mode == -1) {\n+            throw new IllegalArgumentException(\"Invalid Mode selection\");\n+        }\n+\n+        // Turn on the unit if currently off\n+        if (!isNumber && (device.getIntStatusVal(\"Pow\") == 0)) {\n+            logger.debug(\"Send Auto-ON for mode {}\", mode);\n+            device.setDevicePower(socket, 1);\n+        }\n+\n+        // Select mode\n+        logger.debug(\"Select mode {}\", mode);\n+        device.SetDeviceMode(socket, mode);\n+\n+        // Check for secondary action\n+        switch (modeStr) {\n+            case MODE_ECO:\n+                // Turn on power saving for eco mode\n+                logger.debug(\"Turn on Power-Saving\");\n+                device.setDevicePwrSaving(socket, 1);\n+                break;\n+            case MODE_TURBO:\n+                device.setDeviceTurbo(socket, 1);\n+                break;\n+        }\n+    }\n+\n+    private void handleQuietCommand(Command command, DatagramSocket socket) throws GreeException {\n+        int mode = -1;\n+        if (command instanceof DecimalType) {\n+            mode = ((DecimalType) command).intValue();\n+        } else if (command instanceof StringType) {\n+            switch (command.toString().toLowerCase()) {\n+                case QUIET_OFF:\n+                    mode = GREE_QUIET_OFF;\n+                    break;\n+                case QUIET_AUTO:\n+                    mode = GREE_QUIET_AUTO;\n+                    break;\n+                case QUIET_QUIET:\n+                    mode = GREE_QUIET_QUIET;\n+                    break;\n+            }\n+        }\n+        if (mode != -1) {\n+            device.setQuietMode(socket, mode);\n+        }\n+        throw new IllegalArgumentException(\"Invalid QuietType\");\n+    }\n+\n+    private int getOnOff(Command command) {\n+        if (command instanceof OnOffType) {\n+            return ((OnOffType) command) == OnOffType.ON ? 1 : 0;\n+        }\n+        if ((command instanceof DecimalType) && (((DecimalType) command).intValue() <= 2)) {\n+            return ((DecimalType) command).intValue();\n+        }\n+        throw new IllegalArgumentException(\"Invalid OnOffType\");\n+    }\n+\n+    private int getNumber(Command command) {\n+        if (command instanceof DecimalType) {\n+            return ((DecimalType) command).intValue();\n+        }\n+        throw new IllegalArgumentException(\"Invalud Number type\");\n+    }\n+\n+    private double getTemp(Command command) {\n+        if (command instanceof DecimalType) {\n+            // assume Celsius\n+            return ((DecimalType) command).doubleValue();\n+        }\n+        if (command instanceof QuantityType) {\n+            QuantityType<?> q = (QuantityType<?>) command;\n+            if (q.getUnit() == Units.CELSIUS) {\n+                return q.intValue();\n+            }\n+            if (q.getUnit() == ImperialUnits.FAHRENHEIT) {\n+                return ImperialUnits.FAHRENHEIT.getConverterTo(Units.CELSIUS).convert(q.doubleValue());\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1e730ba701dc9c2bb5504f9fbbc0d2176c23490"}, "originalPosition": 326}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4MTczNA==", "bodyText": "Your use of Optional here could easily be substituted for a regular variable.\nPlease change all of your \"update*\" methods accordingly.", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436481734", "createdAt": "2020-06-08T06:33:46Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeHandler.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.net.DatagramSocket;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.ImperialUnits;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.gree.internal.GreeConfiguration;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.discovery.GreeDeviceFinder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import tec.uom.se.unit.Units;\n+\n+/**\n+ * The {@link GreeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(GreeHandler.class);\n+    private final GreeTranslationProvider messages;\n+    private GreeConfiguration config = new GreeConfiguration();\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+    private GreeAirDevice device = new GreeAirDevice();\n+    private Optional<DatagramSocket> clientSocket = Optional.empty();\n+\n+    private @Nullable ScheduledFuture<?> refreshTask;\n+    private long lastRefreshTime = 0;\n+\n+    public GreeHandler(Thing thing, GreeTranslationProvider messages) {\n+        super(thing);\n+        this.messages = messages;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(GreeConfiguration.class);\n+        logger.debug(\"Config for {} is {}\", thing.getUID(), config.toString());\n+        if (config.ipAddress.isEmpty() || (config.refresh < 0)) {\n+            logger.warn(\"Config of {} is invalid. Check configuration\", thing.getUID());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid configuration. Check thing configuration.\");\n+            return;\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.execute(() -> {\n+            initializeThing();\n+        });\n+    }\n+\n+    private void initializeThing() {\n+        try {\n+            // Create a new Datagram socket with a specified timeout\n+            clientSocket = Optional.of(new DatagramSocket());\n+            clientSocket.get().setSoTimeout(DATAGRAM_SOCKET_TIMEOUT);\n+\n+            // Find the GREE device\n+            deviceFinder = new GreeDeviceFinder(config.ipAddress);\n+            deviceFinder.scan(clientSocket, false);\n+            logger.debug(\"{} units found matching IP address\", deviceFinder.getScannedDeviceCount());\n+\n+            // Now check that this one is amongst the air conditioners that responded.\n+            GreeAirDevice newDevice = deviceFinder.getDeviceByIPAddress(config.ipAddress);\n+            if (newDevice != null) {\n+                // Ok, our device responded, now let's Bind with it\n+                device = newDevice;\n+                device.bindWithDevice(clientSocket);\n+                if (device.getIsBound()) {\n+                    updateStatus(ThingStatus.ONLINE);\n+\n+                    // Start the automatic refresh cycles\n+                    startAutomaticRefresh();\n+                    return;\n+                }\n+            }\n+            logger.debug(\"GREE unit is not responding\");\n+        } catch (GreeException e) {\n+            logger.warn(\"Initialization failed: {}\", messages.get(\"thinginit.exception\", e.toString()));\n+        } catch (IOException e) {\n+            logger.debug(\"Exception on initialization: {}\", e.toString());\n+        } catch (RuntimeException e) {\n+            logger.warn(\"Initialization failed\", e);\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            // The thing is updated by the scheduled automatic refresh so do nothing here.\n+        } else {\n+            if (!clientSocket.isPresent()) {\n+                logger.warn(\"Thing not properly initialized, abort command\");\n+                return;\n+            }\n+\n+            DatagramSocket socket = clientSocket.get();\n+            logger.debug(\"Issue command {}\u00a0to channe {}\", command, channelUID.getIdWithoutGroup());\n+            String channelId = channelUID.getIdWithoutGroup();\n+            logger.debug(\"Handle command {} for channel {}, command class {}\", command, channelId, command.getClass());\n+            try {\n+                switch (channelId) {\n+                    case MODE_CHANNEL:\n+                        handleModeCommand(command, socket);\n+                        break;\n+                    case POWER_CHANNEL:\n+                        device.setDevicePower(socket, getOnOff(command));\n+                        break;\n+                    case TURBO_CHANNEL:\n+                        device.setDeviceTurbo(socket, getOnOff(command));\n+                        break;\n+                    case LIGHT_CHANNEL:\n+                        device.setDeviceLight(socket, getOnOff(command));\n+                        break;\n+                    case TEMP_CHANNEL:\n+                        device.setDeviceTempSet(socket, (int) getTemp(command));\n+                        break;\n+                    case SWINGUD_CHANNEL:\n+                        device.setDeviceSwingUpDown(socket, getNumber(command));\n+                        break;\n+                    case SWINGLR_CHANNEL:\n+                        device.setDeviceSwingLeftRight(socket, getNumber(command));\n+                        break;\n+                    case WINDSPEED_CHANNEL:\n+                        device.setDeviceWindspeed(socket, getNumber(command));\n+                        break;\n+                    case QUIET_CHANNEL:\n+                        handleQuietCommand(command, socket);\n+                        break;\n+                    case AIR_CHANNEL:\n+                        device.setDeviceAir(socket, getOnOff(command));\n+                        break;\n+                    case DRY_CHANNEL:\n+                        device.setDeviceDry(socket, getOnOff(command));\n+                        break;\n+                    case HEALTH_CHANNEL:\n+                        device.setDeviceHealth(socket, getOnOff(command));\n+                        break;\n+                    case PWRSAV_CHANNEL:\n+                        device.setDevicePwrSaving(socket, getOnOff(command));\n+                        break;\n+                }\n+            } catch (GreeException e) {\n+                logger.debug(\"Unable to execute command {}\u00a0for channel {}: {}\", command, channelId, e.toString());\n+            } catch (IllegalArgumentException e) {\n+                logger.warn(\"Invalid command value {}\u00a0for channel {}\", command, channelUID.getId());\n+            } catch (RuntimeException e) {\n+                logger.warn(\"Unable to execute command {}\u00a0for channel {}\", command, channelId, e);\n+            }\n+        }\n+    }\n+\n+    private void handleModeCommand(Command command, DatagramSocket socket) throws GreeException {\n+        int mode = -1;\n+        String modeStr = \"\";\n+        boolean isNumber = false;\n+        if (command instanceof DecimalType) {\n+            // backward compatibility when channel was Number\n+            mode = ((DecimalType) command).intValue();\n+        } else if (command instanceof OnOffType) {\n+            // Switch\n+            logger.debug(\"Send Power-{}\", command);\n+            device.setDevicePower(socket, getOnOff(command));\n+        } else /* String */ {\n+            modeStr = command.toString().toLowerCase();\n+            switch (modeStr) {\n+                case MODE_AUTO:\n+                    mode = GREE_MODE_AUTO;\n+                    break;\n+                case MODE_COOL:\n+                    mode = GREE_MODE_COOL;\n+                    break;\n+                case MODE_HEAT:\n+                    mode = GREE_MODE_HEAT;\n+                    break;\n+                case MODE_DRY:\n+                    mode = GREE_MODE_DRY;\n+                    break;\n+                case MODE_FAN:\n+                case MODE_FAN2:\n+                    mode = GREE_MODE_FAN;\n+                    break;\n+                case MODE_ECO:\n+                    // power saving will be set after the uinit was turned on\n+                    mode = GREE_MODE_COOL;\n+                    break;\n+                case MODE_ON:\n+                case MODE_OFF:\n+                    device.setDevicePower(socket, modeStr.equals(MODE_ON) ? 1 : 0);\n+                    break;\n+                default:\n+                    // fallback: mode number, pass transparent\n+                    // if string is not parsable parseInt() throws an exception\n+                    mode = Integer.parseInt(modeStr);\n+                    isNumber = true;\n+                    break;\n+            }\n+            logger.debug(\"Mode {} mapped to {}\", modeStr, mode);\n+        }\n+\n+        if (mode == -1) {\n+            throw new IllegalArgumentException(\"Invalid Mode selection\");\n+        }\n+\n+        // Turn on the unit if currently off\n+        if (!isNumber && (device.getIntStatusVal(\"Pow\") == 0)) {\n+            logger.debug(\"Send Auto-ON for mode {}\", mode);\n+            device.setDevicePower(socket, 1);\n+        }\n+\n+        // Select mode\n+        logger.debug(\"Select mode {}\", mode);\n+        device.SetDeviceMode(socket, mode);\n+\n+        // Check for secondary action\n+        switch (modeStr) {\n+            case MODE_ECO:\n+                // Turn on power saving for eco mode\n+                logger.debug(\"Turn on Power-Saving\");\n+                device.setDevicePwrSaving(socket, 1);\n+                break;\n+            case MODE_TURBO:\n+                device.setDeviceTurbo(socket, 1);\n+                break;\n+        }\n+    }\n+\n+    private void handleQuietCommand(Command command, DatagramSocket socket) throws GreeException {\n+        int mode = -1;\n+        if (command instanceof DecimalType) {\n+            mode = ((DecimalType) command).intValue();\n+        } else if (command instanceof StringType) {\n+            switch (command.toString().toLowerCase()) {\n+                case QUIET_OFF:\n+                    mode = GREE_QUIET_OFF;\n+                    break;\n+                case QUIET_AUTO:\n+                    mode = GREE_QUIET_AUTO;\n+                    break;\n+                case QUIET_QUIET:\n+                    mode = GREE_QUIET_QUIET;\n+                    break;\n+            }\n+        }\n+        if (mode != -1) {\n+            device.setQuietMode(socket, mode);\n+        }\n+        throw new IllegalArgumentException(\"Invalid QuietType\");\n+    }\n+\n+    private int getOnOff(Command command) {\n+        if (command instanceof OnOffType) {\n+            return ((OnOffType) command) == OnOffType.ON ? 1 : 0;\n+        }\n+        if ((command instanceof DecimalType) && (((DecimalType) command).intValue() <= 2)) {\n+            return ((DecimalType) command).intValue();\n+        }\n+        throw new IllegalArgumentException(\"Invalid OnOffType\");\n+    }\n+\n+    private int getNumber(Command command) {\n+        if (command instanceof DecimalType) {\n+            return ((DecimalType) command).intValue();\n+        }\n+        throw new IllegalArgumentException(\"Invalud Number type\");\n+    }\n+\n+    private double getTemp(Command command) {\n+        if (command instanceof DecimalType) {\n+            // assume Celsius\n+            return ((DecimalType) command).doubleValue();\n+        }\n+        if (command instanceof QuantityType) {\n+            QuantityType<?> q = (QuantityType<?>) command;\n+            if (q.getUnit() == Units.CELSIUS) {\n+                return q.intValue();\n+            }\n+            if (q.getUnit() == ImperialUnits.FAHRENHEIT) {\n+                return ImperialUnits.FAHRENHEIT.getConverterTo(Units.CELSIUS).convert(q.doubleValue());\n+            }\n+        }\n+        throw new IllegalArgumentException(\"Invalud Temp type\");\n+    }\n+\n+    private boolean isMinimumRefreshTimeExceeded() {\n+        long currentTime = System.currentTimeMillis();\n+        long timeSinceLastRefresh = currentTime - lastRefreshTime;\n+        if (timeSinceLastRefresh < MINIMUM_REFRESH_TIME_MS) {\n+            return false;\n+        }\n+        lastRefreshTime = currentTime;\n+        return true;\n+    }\n+\n+    private void startAutomaticRefresh() {\n+\n+        Runnable refresher = new Runnable() {\n+            @Override\n+            public void run() {\n+\n+                try {\n+                    logger.debug(\"Executing automatic update of values\");\n+                    // safeguard for multiple REFRESH commands\n+                    if (isMinimumRefreshTimeExceeded()) {\n+                        // Get the current status from the Airconditioner\n+                        device.getDeviceStatus(clientSocket.get());\n+                    } else {\n+                        logger.trace(\n+                                \"Skipped fetching status values from device because minimum refresh time not reached\");\n+                    }\n+\n+                    // Update All Channels\n+                    List<Channel> channels = getThing().getChannels();\n+                    for (Channel channel : channels) {\n+                        publishChannel(channel.getUID());\n+                    }\n+                } catch (GreeException e) {\n+                    if (!e.isTimeout()) {\n+                        logger.warn(\"Unable to perform auto-update: {}\", e.toString());\n+                    }\n+                } catch (RuntimeException e) {\n+                    logger.warn(\"Unable to perform auto-update\", e);\n+                }\n+            }\n+        };\n+\n+        refreshTask = scheduler.scheduleWithFixedDelay(refresher, 0, config.refresh, TimeUnit.SECONDS);\n+        logger.debug(\"Automatic refresh started ({} second interval)\", config.refresh);\n+    }\n+\n+    private void publishChannel(ChannelUID channelUID) throws GreeException {\n+        try {\n+            String channelID = channelUID.getId();\n+            Optional<State> state = Optional.empty();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1e730ba701dc9c2bb5504f9fbbc0d2176c23490"}, "originalPosition": 380}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4MjUyNg==", "bodyText": "This exception will always be thrown", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436482526", "createdAt": "2020-06-08T06:36:14Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeHandler.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.net.DatagramSocket;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.ImperialUnits;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.gree.internal.GreeConfiguration;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.discovery.GreeDeviceFinder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import tec.uom.se.unit.Units;\n+\n+/**\n+ * The {@link GreeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(GreeHandler.class);\n+    private final GreeTranslationProvider messages;\n+    private GreeConfiguration config = new GreeConfiguration();\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+    private GreeAirDevice device = new GreeAirDevice();\n+    private Optional<DatagramSocket> clientSocket = Optional.empty();\n+\n+    private @Nullable ScheduledFuture<?> refreshTask;\n+    private long lastRefreshTime = 0;\n+\n+    public GreeHandler(Thing thing, GreeTranslationProvider messages) {\n+        super(thing);\n+        this.messages = messages;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(GreeConfiguration.class);\n+        logger.debug(\"Config for {} is {}\", thing.getUID(), config.toString());\n+        if (config.ipAddress.isEmpty() || (config.refresh < 0)) {\n+            logger.warn(\"Config of {} is invalid. Check configuration\", thing.getUID());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid configuration. Check thing configuration.\");\n+            return;\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.execute(() -> {\n+            initializeThing();\n+        });\n+    }\n+\n+    private void initializeThing() {\n+        try {\n+            // Create a new Datagram socket with a specified timeout\n+            clientSocket = Optional.of(new DatagramSocket());\n+            clientSocket.get().setSoTimeout(DATAGRAM_SOCKET_TIMEOUT);\n+\n+            // Find the GREE device\n+            deviceFinder = new GreeDeviceFinder(config.ipAddress);\n+            deviceFinder.scan(clientSocket, false);\n+            logger.debug(\"{} units found matching IP address\", deviceFinder.getScannedDeviceCount());\n+\n+            // Now check that this one is amongst the air conditioners that responded.\n+            GreeAirDevice newDevice = deviceFinder.getDeviceByIPAddress(config.ipAddress);\n+            if (newDevice != null) {\n+                // Ok, our device responded, now let's Bind with it\n+                device = newDevice;\n+                device.bindWithDevice(clientSocket);\n+                if (device.getIsBound()) {\n+                    updateStatus(ThingStatus.ONLINE);\n+\n+                    // Start the automatic refresh cycles\n+                    startAutomaticRefresh();\n+                    return;\n+                }\n+            }\n+            logger.debug(\"GREE unit is not responding\");\n+        } catch (GreeException e) {\n+            logger.warn(\"Initialization failed: {}\", messages.get(\"thinginit.exception\", e.toString()));\n+        } catch (IOException e) {\n+            logger.debug(\"Exception on initialization: {}\", e.toString());\n+        } catch (RuntimeException e) {\n+            logger.warn(\"Initialization failed\", e);\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            // The thing is updated by the scheduled automatic refresh so do nothing here.\n+        } else {\n+            if (!clientSocket.isPresent()) {\n+                logger.warn(\"Thing not properly initialized, abort command\");\n+                return;\n+            }\n+\n+            DatagramSocket socket = clientSocket.get();\n+            logger.debug(\"Issue command {}\u00a0to channe {}\", command, channelUID.getIdWithoutGroup());\n+            String channelId = channelUID.getIdWithoutGroup();\n+            logger.debug(\"Handle command {} for channel {}, command class {}\", command, channelId, command.getClass());\n+            try {\n+                switch (channelId) {\n+                    case MODE_CHANNEL:\n+                        handleModeCommand(command, socket);\n+                        break;\n+                    case POWER_CHANNEL:\n+                        device.setDevicePower(socket, getOnOff(command));\n+                        break;\n+                    case TURBO_CHANNEL:\n+                        device.setDeviceTurbo(socket, getOnOff(command));\n+                        break;\n+                    case LIGHT_CHANNEL:\n+                        device.setDeviceLight(socket, getOnOff(command));\n+                        break;\n+                    case TEMP_CHANNEL:\n+                        device.setDeviceTempSet(socket, (int) getTemp(command));\n+                        break;\n+                    case SWINGUD_CHANNEL:\n+                        device.setDeviceSwingUpDown(socket, getNumber(command));\n+                        break;\n+                    case SWINGLR_CHANNEL:\n+                        device.setDeviceSwingLeftRight(socket, getNumber(command));\n+                        break;\n+                    case WINDSPEED_CHANNEL:\n+                        device.setDeviceWindspeed(socket, getNumber(command));\n+                        break;\n+                    case QUIET_CHANNEL:\n+                        handleQuietCommand(command, socket);\n+                        break;\n+                    case AIR_CHANNEL:\n+                        device.setDeviceAir(socket, getOnOff(command));\n+                        break;\n+                    case DRY_CHANNEL:\n+                        device.setDeviceDry(socket, getOnOff(command));\n+                        break;\n+                    case HEALTH_CHANNEL:\n+                        device.setDeviceHealth(socket, getOnOff(command));\n+                        break;\n+                    case PWRSAV_CHANNEL:\n+                        device.setDevicePwrSaving(socket, getOnOff(command));\n+                        break;\n+                }\n+            } catch (GreeException e) {\n+                logger.debug(\"Unable to execute command {}\u00a0for channel {}: {}\", command, channelId, e.toString());\n+            } catch (IllegalArgumentException e) {\n+                logger.warn(\"Invalid command value {}\u00a0for channel {}\", command, channelUID.getId());\n+            } catch (RuntimeException e) {\n+                logger.warn(\"Unable to execute command {}\u00a0for channel {}\", command, channelId, e);\n+            }\n+        }\n+    }\n+\n+    private void handleModeCommand(Command command, DatagramSocket socket) throws GreeException {\n+        int mode = -1;\n+        String modeStr = \"\";\n+        boolean isNumber = false;\n+        if (command instanceof DecimalType) {\n+            // backward compatibility when channel was Number\n+            mode = ((DecimalType) command).intValue();\n+        } else if (command instanceof OnOffType) {\n+            // Switch\n+            logger.debug(\"Send Power-{}\", command);\n+            device.setDevicePower(socket, getOnOff(command));\n+        } else /* String */ {\n+            modeStr = command.toString().toLowerCase();\n+            switch (modeStr) {\n+                case MODE_AUTO:\n+                    mode = GREE_MODE_AUTO;\n+                    break;\n+                case MODE_COOL:\n+                    mode = GREE_MODE_COOL;\n+                    break;\n+                case MODE_HEAT:\n+                    mode = GREE_MODE_HEAT;\n+                    break;\n+                case MODE_DRY:\n+                    mode = GREE_MODE_DRY;\n+                    break;\n+                case MODE_FAN:\n+                case MODE_FAN2:\n+                    mode = GREE_MODE_FAN;\n+                    break;\n+                case MODE_ECO:\n+                    // power saving will be set after the uinit was turned on\n+                    mode = GREE_MODE_COOL;\n+                    break;\n+                case MODE_ON:\n+                case MODE_OFF:\n+                    device.setDevicePower(socket, modeStr.equals(MODE_ON) ? 1 : 0);\n+                    break;\n+                default:\n+                    // fallback: mode number, pass transparent\n+                    // if string is not parsable parseInt() throws an exception\n+                    mode = Integer.parseInt(modeStr);\n+                    isNumber = true;\n+                    break;\n+            }\n+            logger.debug(\"Mode {} mapped to {}\", modeStr, mode);\n+        }\n+\n+        if (mode == -1) {\n+            throw new IllegalArgumentException(\"Invalid Mode selection\");\n+        }\n+\n+        // Turn on the unit if currently off\n+        if (!isNumber && (device.getIntStatusVal(\"Pow\") == 0)) {\n+            logger.debug(\"Send Auto-ON for mode {}\", mode);\n+            device.setDevicePower(socket, 1);\n+        }\n+\n+        // Select mode\n+        logger.debug(\"Select mode {}\", mode);\n+        device.SetDeviceMode(socket, mode);\n+\n+        // Check for secondary action\n+        switch (modeStr) {\n+            case MODE_ECO:\n+                // Turn on power saving for eco mode\n+                logger.debug(\"Turn on Power-Saving\");\n+                device.setDevicePwrSaving(socket, 1);\n+                break;\n+            case MODE_TURBO:\n+                device.setDeviceTurbo(socket, 1);\n+                break;\n+        }\n+    }\n+\n+    private void handleQuietCommand(Command command, DatagramSocket socket) throws GreeException {\n+        int mode = -1;\n+        if (command instanceof DecimalType) {\n+            mode = ((DecimalType) command).intValue();\n+        } else if (command instanceof StringType) {\n+            switch (command.toString().toLowerCase()) {\n+                case QUIET_OFF:\n+                    mode = GREE_QUIET_OFF;\n+                    break;\n+                case QUIET_AUTO:\n+                    mode = GREE_QUIET_AUTO;\n+                    break;\n+                case QUIET_QUIET:\n+                    mode = GREE_QUIET_QUIET;\n+                    break;\n+            }\n+        }\n+        if (mode != -1) {\n+            device.setQuietMode(socket, mode);\n+        }\n+        throw new IllegalArgumentException(\"Invalid QuietType\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1e730ba701dc9c2bb5504f9fbbc0d2176c23490"}, "originalPosition": 294}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4Mjk1NA==", "bodyText": "This error doesn't make any sense if the user passes a DecimalType with a value > 2.\nAlso shouldn't you also throw an error if the user passes in a negative DecimalType?", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436482954", "createdAt": "2020-06-08T06:37:28Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeHandler.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.net.DatagramSocket;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.ImperialUnits;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.gree.internal.GreeConfiguration;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.discovery.GreeDeviceFinder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import tec.uom.se.unit.Units;\n+\n+/**\n+ * The {@link GreeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(GreeHandler.class);\n+    private final GreeTranslationProvider messages;\n+    private GreeConfiguration config = new GreeConfiguration();\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+    private GreeAirDevice device = new GreeAirDevice();\n+    private Optional<DatagramSocket> clientSocket = Optional.empty();\n+\n+    private @Nullable ScheduledFuture<?> refreshTask;\n+    private long lastRefreshTime = 0;\n+\n+    public GreeHandler(Thing thing, GreeTranslationProvider messages) {\n+        super(thing);\n+        this.messages = messages;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(GreeConfiguration.class);\n+        logger.debug(\"Config for {} is {}\", thing.getUID(), config.toString());\n+        if (config.ipAddress.isEmpty() || (config.refresh < 0)) {\n+            logger.warn(\"Config of {} is invalid. Check configuration\", thing.getUID());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid configuration. Check thing configuration.\");\n+            return;\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.execute(() -> {\n+            initializeThing();\n+        });\n+    }\n+\n+    private void initializeThing() {\n+        try {\n+            // Create a new Datagram socket with a specified timeout\n+            clientSocket = Optional.of(new DatagramSocket());\n+            clientSocket.get().setSoTimeout(DATAGRAM_SOCKET_TIMEOUT);\n+\n+            // Find the GREE device\n+            deviceFinder = new GreeDeviceFinder(config.ipAddress);\n+            deviceFinder.scan(clientSocket, false);\n+            logger.debug(\"{} units found matching IP address\", deviceFinder.getScannedDeviceCount());\n+\n+            // Now check that this one is amongst the air conditioners that responded.\n+            GreeAirDevice newDevice = deviceFinder.getDeviceByIPAddress(config.ipAddress);\n+            if (newDevice != null) {\n+                // Ok, our device responded, now let's Bind with it\n+                device = newDevice;\n+                device.bindWithDevice(clientSocket);\n+                if (device.getIsBound()) {\n+                    updateStatus(ThingStatus.ONLINE);\n+\n+                    // Start the automatic refresh cycles\n+                    startAutomaticRefresh();\n+                    return;\n+                }\n+            }\n+            logger.debug(\"GREE unit is not responding\");\n+        } catch (GreeException e) {\n+            logger.warn(\"Initialization failed: {}\", messages.get(\"thinginit.exception\", e.toString()));\n+        } catch (IOException e) {\n+            logger.debug(\"Exception on initialization: {}\", e.toString());\n+        } catch (RuntimeException e) {\n+            logger.warn(\"Initialization failed\", e);\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            // The thing is updated by the scheduled automatic refresh so do nothing here.\n+        } else {\n+            if (!clientSocket.isPresent()) {\n+                logger.warn(\"Thing not properly initialized, abort command\");\n+                return;\n+            }\n+\n+            DatagramSocket socket = clientSocket.get();\n+            logger.debug(\"Issue command {}\u00a0to channe {}\", command, channelUID.getIdWithoutGroup());\n+            String channelId = channelUID.getIdWithoutGroup();\n+            logger.debug(\"Handle command {} for channel {}, command class {}\", command, channelId, command.getClass());\n+            try {\n+                switch (channelId) {\n+                    case MODE_CHANNEL:\n+                        handleModeCommand(command, socket);\n+                        break;\n+                    case POWER_CHANNEL:\n+                        device.setDevicePower(socket, getOnOff(command));\n+                        break;\n+                    case TURBO_CHANNEL:\n+                        device.setDeviceTurbo(socket, getOnOff(command));\n+                        break;\n+                    case LIGHT_CHANNEL:\n+                        device.setDeviceLight(socket, getOnOff(command));\n+                        break;\n+                    case TEMP_CHANNEL:\n+                        device.setDeviceTempSet(socket, (int) getTemp(command));\n+                        break;\n+                    case SWINGUD_CHANNEL:\n+                        device.setDeviceSwingUpDown(socket, getNumber(command));\n+                        break;\n+                    case SWINGLR_CHANNEL:\n+                        device.setDeviceSwingLeftRight(socket, getNumber(command));\n+                        break;\n+                    case WINDSPEED_CHANNEL:\n+                        device.setDeviceWindspeed(socket, getNumber(command));\n+                        break;\n+                    case QUIET_CHANNEL:\n+                        handleQuietCommand(command, socket);\n+                        break;\n+                    case AIR_CHANNEL:\n+                        device.setDeviceAir(socket, getOnOff(command));\n+                        break;\n+                    case DRY_CHANNEL:\n+                        device.setDeviceDry(socket, getOnOff(command));\n+                        break;\n+                    case HEALTH_CHANNEL:\n+                        device.setDeviceHealth(socket, getOnOff(command));\n+                        break;\n+                    case PWRSAV_CHANNEL:\n+                        device.setDevicePwrSaving(socket, getOnOff(command));\n+                        break;\n+                }\n+            } catch (GreeException e) {\n+                logger.debug(\"Unable to execute command {}\u00a0for channel {}: {}\", command, channelId, e.toString());\n+            } catch (IllegalArgumentException e) {\n+                logger.warn(\"Invalid command value {}\u00a0for channel {}\", command, channelUID.getId());\n+            } catch (RuntimeException e) {\n+                logger.warn(\"Unable to execute command {}\u00a0for channel {}\", command, channelId, e);\n+            }\n+        }\n+    }\n+\n+    private void handleModeCommand(Command command, DatagramSocket socket) throws GreeException {\n+        int mode = -1;\n+        String modeStr = \"\";\n+        boolean isNumber = false;\n+        if (command instanceof DecimalType) {\n+            // backward compatibility when channel was Number\n+            mode = ((DecimalType) command).intValue();\n+        } else if (command instanceof OnOffType) {\n+            // Switch\n+            logger.debug(\"Send Power-{}\", command);\n+            device.setDevicePower(socket, getOnOff(command));\n+        } else /* String */ {\n+            modeStr = command.toString().toLowerCase();\n+            switch (modeStr) {\n+                case MODE_AUTO:\n+                    mode = GREE_MODE_AUTO;\n+                    break;\n+                case MODE_COOL:\n+                    mode = GREE_MODE_COOL;\n+                    break;\n+                case MODE_HEAT:\n+                    mode = GREE_MODE_HEAT;\n+                    break;\n+                case MODE_DRY:\n+                    mode = GREE_MODE_DRY;\n+                    break;\n+                case MODE_FAN:\n+                case MODE_FAN2:\n+                    mode = GREE_MODE_FAN;\n+                    break;\n+                case MODE_ECO:\n+                    // power saving will be set after the uinit was turned on\n+                    mode = GREE_MODE_COOL;\n+                    break;\n+                case MODE_ON:\n+                case MODE_OFF:\n+                    device.setDevicePower(socket, modeStr.equals(MODE_ON) ? 1 : 0);\n+                    break;\n+                default:\n+                    // fallback: mode number, pass transparent\n+                    // if string is not parsable parseInt() throws an exception\n+                    mode = Integer.parseInt(modeStr);\n+                    isNumber = true;\n+                    break;\n+            }\n+            logger.debug(\"Mode {} mapped to {}\", modeStr, mode);\n+        }\n+\n+        if (mode == -1) {\n+            throw new IllegalArgumentException(\"Invalid Mode selection\");\n+        }\n+\n+        // Turn on the unit if currently off\n+        if (!isNumber && (device.getIntStatusVal(\"Pow\") == 0)) {\n+            logger.debug(\"Send Auto-ON for mode {}\", mode);\n+            device.setDevicePower(socket, 1);\n+        }\n+\n+        // Select mode\n+        logger.debug(\"Select mode {}\", mode);\n+        device.SetDeviceMode(socket, mode);\n+\n+        // Check for secondary action\n+        switch (modeStr) {\n+            case MODE_ECO:\n+                // Turn on power saving for eco mode\n+                logger.debug(\"Turn on Power-Saving\");\n+                device.setDevicePwrSaving(socket, 1);\n+                break;\n+            case MODE_TURBO:\n+                device.setDeviceTurbo(socket, 1);\n+                break;\n+        }\n+    }\n+\n+    private void handleQuietCommand(Command command, DatagramSocket socket) throws GreeException {\n+        int mode = -1;\n+        if (command instanceof DecimalType) {\n+            mode = ((DecimalType) command).intValue();\n+        } else if (command instanceof StringType) {\n+            switch (command.toString().toLowerCase()) {\n+                case QUIET_OFF:\n+                    mode = GREE_QUIET_OFF;\n+                    break;\n+                case QUIET_AUTO:\n+                    mode = GREE_QUIET_AUTO;\n+                    break;\n+                case QUIET_QUIET:\n+                    mode = GREE_QUIET_QUIET;\n+                    break;\n+            }\n+        }\n+        if (mode != -1) {\n+            device.setQuietMode(socket, mode);\n+        }\n+        throw new IllegalArgumentException(\"Invalid QuietType\");\n+    }\n+\n+    private int getOnOff(Command command) {\n+        if (command instanceof OnOffType) {\n+            return ((OnOffType) command) == OnOffType.ON ? 1 : 0;\n+        }\n+        if ((command instanceof DecimalType) && (((DecimalType) command).intValue() <= 2)) {\n+            return ((DecimalType) command).intValue();\n+        }\n+        throw new IllegalArgumentException(\"Invalid OnOffType\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1e730ba701dc9c2bb5504f9fbbc0d2176c23490"}, "originalPosition": 304}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4NDIxNg==", "bodyText": "To safe the caller from casting the result, perhaps you should just change the return type?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private double getTemp(Command command) {\n          \n          \n            \n                private int getTemp(Command command) {", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436484216", "createdAt": "2020-06-08T06:40:48Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeHandler.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.net.DatagramSocket;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.ImperialUnits;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.gree.internal.GreeConfiguration;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.discovery.GreeDeviceFinder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import tec.uom.se.unit.Units;\n+\n+/**\n+ * The {@link GreeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(GreeHandler.class);\n+    private final GreeTranslationProvider messages;\n+    private GreeConfiguration config = new GreeConfiguration();\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+    private GreeAirDevice device = new GreeAirDevice();\n+    private Optional<DatagramSocket> clientSocket = Optional.empty();\n+\n+    private @Nullable ScheduledFuture<?> refreshTask;\n+    private long lastRefreshTime = 0;\n+\n+    public GreeHandler(Thing thing, GreeTranslationProvider messages) {\n+        super(thing);\n+        this.messages = messages;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(GreeConfiguration.class);\n+        logger.debug(\"Config for {} is {}\", thing.getUID(), config.toString());\n+        if (config.ipAddress.isEmpty() || (config.refresh < 0)) {\n+            logger.warn(\"Config of {} is invalid. Check configuration\", thing.getUID());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid configuration. Check thing configuration.\");\n+            return;\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.execute(() -> {\n+            initializeThing();\n+        });\n+    }\n+\n+    private void initializeThing() {\n+        try {\n+            // Create a new Datagram socket with a specified timeout\n+            clientSocket = Optional.of(new DatagramSocket());\n+            clientSocket.get().setSoTimeout(DATAGRAM_SOCKET_TIMEOUT);\n+\n+            // Find the GREE device\n+            deviceFinder = new GreeDeviceFinder(config.ipAddress);\n+            deviceFinder.scan(clientSocket, false);\n+            logger.debug(\"{} units found matching IP address\", deviceFinder.getScannedDeviceCount());\n+\n+            // Now check that this one is amongst the air conditioners that responded.\n+            GreeAirDevice newDevice = deviceFinder.getDeviceByIPAddress(config.ipAddress);\n+            if (newDevice != null) {\n+                // Ok, our device responded, now let's Bind with it\n+                device = newDevice;\n+                device.bindWithDevice(clientSocket);\n+                if (device.getIsBound()) {\n+                    updateStatus(ThingStatus.ONLINE);\n+\n+                    // Start the automatic refresh cycles\n+                    startAutomaticRefresh();\n+                    return;\n+                }\n+            }\n+            logger.debug(\"GREE unit is not responding\");\n+        } catch (GreeException e) {\n+            logger.warn(\"Initialization failed: {}\", messages.get(\"thinginit.exception\", e.toString()));\n+        } catch (IOException e) {\n+            logger.debug(\"Exception on initialization: {}\", e.toString());\n+        } catch (RuntimeException e) {\n+            logger.warn(\"Initialization failed\", e);\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            // The thing is updated by the scheduled automatic refresh so do nothing here.\n+        } else {\n+            if (!clientSocket.isPresent()) {\n+                logger.warn(\"Thing not properly initialized, abort command\");\n+                return;\n+            }\n+\n+            DatagramSocket socket = clientSocket.get();\n+            logger.debug(\"Issue command {}\u00a0to channe {}\", command, channelUID.getIdWithoutGroup());\n+            String channelId = channelUID.getIdWithoutGroup();\n+            logger.debug(\"Handle command {} for channel {}, command class {}\", command, channelId, command.getClass());\n+            try {\n+                switch (channelId) {\n+                    case MODE_CHANNEL:\n+                        handleModeCommand(command, socket);\n+                        break;\n+                    case POWER_CHANNEL:\n+                        device.setDevicePower(socket, getOnOff(command));\n+                        break;\n+                    case TURBO_CHANNEL:\n+                        device.setDeviceTurbo(socket, getOnOff(command));\n+                        break;\n+                    case LIGHT_CHANNEL:\n+                        device.setDeviceLight(socket, getOnOff(command));\n+                        break;\n+                    case TEMP_CHANNEL:\n+                        device.setDeviceTempSet(socket, (int) getTemp(command));\n+                        break;\n+                    case SWINGUD_CHANNEL:\n+                        device.setDeviceSwingUpDown(socket, getNumber(command));\n+                        break;\n+                    case SWINGLR_CHANNEL:\n+                        device.setDeviceSwingLeftRight(socket, getNumber(command));\n+                        break;\n+                    case WINDSPEED_CHANNEL:\n+                        device.setDeviceWindspeed(socket, getNumber(command));\n+                        break;\n+                    case QUIET_CHANNEL:\n+                        handleQuietCommand(command, socket);\n+                        break;\n+                    case AIR_CHANNEL:\n+                        device.setDeviceAir(socket, getOnOff(command));\n+                        break;\n+                    case DRY_CHANNEL:\n+                        device.setDeviceDry(socket, getOnOff(command));\n+                        break;\n+                    case HEALTH_CHANNEL:\n+                        device.setDeviceHealth(socket, getOnOff(command));\n+                        break;\n+                    case PWRSAV_CHANNEL:\n+                        device.setDevicePwrSaving(socket, getOnOff(command));\n+                        break;\n+                }\n+            } catch (GreeException e) {\n+                logger.debug(\"Unable to execute command {}\u00a0for channel {}: {}\", command, channelId, e.toString());\n+            } catch (IllegalArgumentException e) {\n+                logger.warn(\"Invalid command value {}\u00a0for channel {}\", command, channelUID.getId());\n+            } catch (RuntimeException e) {\n+                logger.warn(\"Unable to execute command {}\u00a0for channel {}\", command, channelId, e);\n+            }\n+        }\n+    }\n+\n+    private void handleModeCommand(Command command, DatagramSocket socket) throws GreeException {\n+        int mode = -1;\n+        String modeStr = \"\";\n+        boolean isNumber = false;\n+        if (command instanceof DecimalType) {\n+            // backward compatibility when channel was Number\n+            mode = ((DecimalType) command).intValue();\n+        } else if (command instanceof OnOffType) {\n+            // Switch\n+            logger.debug(\"Send Power-{}\", command);\n+            device.setDevicePower(socket, getOnOff(command));\n+        } else /* String */ {\n+            modeStr = command.toString().toLowerCase();\n+            switch (modeStr) {\n+                case MODE_AUTO:\n+                    mode = GREE_MODE_AUTO;\n+                    break;\n+                case MODE_COOL:\n+                    mode = GREE_MODE_COOL;\n+                    break;\n+                case MODE_HEAT:\n+                    mode = GREE_MODE_HEAT;\n+                    break;\n+                case MODE_DRY:\n+                    mode = GREE_MODE_DRY;\n+                    break;\n+                case MODE_FAN:\n+                case MODE_FAN2:\n+                    mode = GREE_MODE_FAN;\n+                    break;\n+                case MODE_ECO:\n+                    // power saving will be set after the uinit was turned on\n+                    mode = GREE_MODE_COOL;\n+                    break;\n+                case MODE_ON:\n+                case MODE_OFF:\n+                    device.setDevicePower(socket, modeStr.equals(MODE_ON) ? 1 : 0);\n+                    break;\n+                default:\n+                    // fallback: mode number, pass transparent\n+                    // if string is not parsable parseInt() throws an exception\n+                    mode = Integer.parseInt(modeStr);\n+                    isNumber = true;\n+                    break;\n+            }\n+            logger.debug(\"Mode {} mapped to {}\", modeStr, mode);\n+        }\n+\n+        if (mode == -1) {\n+            throw new IllegalArgumentException(\"Invalid Mode selection\");\n+        }\n+\n+        // Turn on the unit if currently off\n+        if (!isNumber && (device.getIntStatusVal(\"Pow\") == 0)) {\n+            logger.debug(\"Send Auto-ON for mode {}\", mode);\n+            device.setDevicePower(socket, 1);\n+        }\n+\n+        // Select mode\n+        logger.debug(\"Select mode {}\", mode);\n+        device.SetDeviceMode(socket, mode);\n+\n+        // Check for secondary action\n+        switch (modeStr) {\n+            case MODE_ECO:\n+                // Turn on power saving for eco mode\n+                logger.debug(\"Turn on Power-Saving\");\n+                device.setDevicePwrSaving(socket, 1);\n+                break;\n+            case MODE_TURBO:\n+                device.setDeviceTurbo(socket, 1);\n+                break;\n+        }\n+    }\n+\n+    private void handleQuietCommand(Command command, DatagramSocket socket) throws GreeException {\n+        int mode = -1;\n+        if (command instanceof DecimalType) {\n+            mode = ((DecimalType) command).intValue();\n+        } else if (command instanceof StringType) {\n+            switch (command.toString().toLowerCase()) {\n+                case QUIET_OFF:\n+                    mode = GREE_QUIET_OFF;\n+                    break;\n+                case QUIET_AUTO:\n+                    mode = GREE_QUIET_AUTO;\n+                    break;\n+                case QUIET_QUIET:\n+                    mode = GREE_QUIET_QUIET;\n+                    break;\n+            }\n+        }\n+        if (mode != -1) {\n+            device.setQuietMode(socket, mode);\n+        }\n+        throw new IllegalArgumentException(\"Invalid QuietType\");\n+    }\n+\n+    private int getOnOff(Command command) {\n+        if (command instanceof OnOffType) {\n+            return ((OnOffType) command) == OnOffType.ON ? 1 : 0;\n+        }\n+        if ((command instanceof DecimalType) && (((DecimalType) command).intValue() <= 2)) {\n+            return ((DecimalType) command).intValue();\n+        }\n+        throw new IllegalArgumentException(\"Invalid OnOffType\");\n+    }\n+\n+    private int getNumber(Command command) {\n+        if (command instanceof DecimalType) {\n+            return ((DecimalType) command).intValue();\n+        }\n+        throw new IllegalArgumentException(\"Invalud Number type\");\n+    }\n+\n+    private double getTemp(Command command) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1e730ba701dc9c2bb5504f9fbbc0d2176c23490"}, "originalPosition": 314}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4NTM5Mw==", "bodyText": "Maybe it would be better to just have your value stay as a QuantityType so that it can handle unit conversion for you.", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436485393", "createdAt": "2020-06-08T06:44:14Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,713 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\n+ * device specific attributes as well a the functionality for the Air Conditioner\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+// @NonNullByDefault\n+public class GreeAirDevice {\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\n+    private boolean isBound = false;\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\n+    private int port = 0;\n+    private String encKey = \"\";\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\n+    private GreeBindResponse4GsonDTO bindResponseGson;\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\n+\n+    public boolean getIsBound() {\n+        return isBound;\n+    }\n+\n+    public void setIsBound(boolean isBound) {\n+        this.isBound = isBound;\n+    }\n+\n+    public InetAddress getAddress() {\n+        return ipAddress;\n+    }\n+\n+    public void setAddress(InetAddress address) {\n+        this.ipAddress = address;\n+    }\n+\n+    public int getPort() {\n+        return port;\n+    }\n+\n+    public void setPort(int port) {\n+        this.port = port;\n+    }\n+\n+    public String getKey() {\n+        return encKey;\n+    }\n+\n+    public String getId() {\n+        return mScanResponseGson.packJson.mac;\n+    }\n+\n+    public String getName() {\n+        return mScanResponseGson.packJson.name;\n+    }\n+\n+    public String getVendor() {\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\n+    }\n+\n+    public String getModel() {\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\n+    }\n+\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\n+        return mScanResponseGson;\n+    }\n+\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\n+        mScanResponseGson = gson;\n+    }\n+\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\n+        return bindResponseGson;\n+    }\n+\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\n+        return statusResponseGson;\n+    }\n+\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\n+        validateSocket(socket);\n+        byte[] sendData = new byte[1024];\n+        byte[] receiveData = new byte[347];\n+        Gson gson = new Gson();\n+\n+        try {\n+            // Prep the Binding Request pack\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\n+            bindReqPackGson.mac = getId();\n+            bindReqPackGson.t = \"bind\";\n+            bindReqPackGson.uid = 0;\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\n+\n+            // Now Encrypt the Binding Request pack\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\n+                    bindReqPackStr);\n+\n+            // Prep the Binding Request\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\n+            bindReqGson.cid = \"app\";\n+            bindReqGson.i = 1;\n+            bindReqGson.t = \"pack\";\n+            bindReqGson.uid = 0;\n+            bindReqGson.tcid = getId();\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\n+            String bindReqStr = gson.toJson(bindReqGson);\n+            sendData = bindReqStr.getBytes();\n+\n+            // Now Send the request\n+            DatagramSocket clientSocket = socket.get();\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\n+            clientSocket.send(sendPacket);\n+\n+            // Recieve a response\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+            clientSocket.receive(receivePacket);\n+            String modifiedSentence = new String(receivePacket.getData(), \"UTF-8\");\n+\n+            // Read the response\n+            StringReader stringReader = new StringReader(modifiedSentence);\n+            bindResponseGson = gson.fromJson(new JsonReader(stringReader), GreeBindResponse4GsonDTO.class);\n+            bindResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\n+                    bindResponseGson.pack);\n+\n+            // Create the JSON to hold the response values\n+            stringReader = new StringReader(bindResponseGson.decryptedPack);\n+            bindResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePack4GsonDTO.class);\n+\n+            // Now set the key and flag to indicate the bind was succesful\n+            encKey = bindResponseGson.packJson.key;\n+            setIsBound(true);\n+        } catch (IOException e) {\n+            throw new GreeException(e, \"failed\");\n+        }\n+    }\n+\n+    private void validateSocket(Optional<DatagramSocket> socket) {\n+        if (!socket.isPresent()) {\n+            throw new IllegalArgumentException(\"Socket not initialized!\");\n+        }\n+    }\n+\n+    public void setDevicePower(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 1)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Pow\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void SetDeviceMode(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 4)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Mod\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceSwingUpDown(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\n+        if (!getIsBound() || (value < 0 || value > 11) || (value > 6 && value < 10)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"SwUpDn\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceSwingLeftRight(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        // Only values 0,1,2,3,4,5,6 allowed\n+        if (!getIsBound() || (value < 0) || (value > 6)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"SwingLfRig\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    /**\n+     * Only allow this to happen if this device has been bound and values are valid\n+     * Possible values are :\n+     * 0 : Auto\n+     * 1 : Low\n+     * 2 : Medium Low\n+     * 3 : Medium\n+     * 4 : Medium High\n+     * 5 : High\n+     */\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, int value) throws GreeException {\n+        if (!getIsBound() || (value < 0 || value > 5)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"WdSpd\", value);\n+        parameters.put(\"Quiet\", 0);\n+        parameters.put(\"Tur\", 0);\n+        parameters.put(\"NoiseSet\", 0);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceTurbo(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 1)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Tur\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setQuietMode(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 2)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Quiet\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public int getDeviceTurbo() {\n+        return getIntStatusVal(\"Tur\");\n+    }\n+\n+    public void setDeviceLight(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 1)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Lig\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    /**\n+     * Create Hash Look Up for C and F\n+     * Temperature Ranges for gree A/C units (f_range = {86,61}, c_range={16,30}\n+     */\n+    private static HashMap<String, HashMap<String, Integer>> createTempRangeMap() {\n+        HashMap<String, HashMap<String, Integer>> tempRanges = new HashMap<>();\n+        HashMap<String, Integer> hmf = new HashMap<>();\n+        HashMap<String, Integer> hmc = new HashMap<>();\n+\n+        hmf.put(\"min\", 61); // F\n+        hmf.put(\"max\", 86);\n+        tempRanges.put(\"F\", hmf);\n+\n+        hmc.put(\"min\", 16); // C\n+        hmc.put(\"max\", 30);\n+        tempRanges.put(\"C\", hmc);\n+\n+        return tempRanges;\n+    }\n+\n+    /**\n+     * Checks input ranges for validity and TempUn for validity\n+     * Uses newVal as priority and tries to validate and determine intent\n+     * For example if value is 75 and TempUn says Celsius, change TempUn to Fahrenheit\n+     */\n+    private int[] validateTemperatureRangeForTempSet(int newValIn, @Nullable Integer CorFIn) {\n+        final String[] minMaxLUT = { \"max\", \"min\" }; // looks up 0 = C = max, 1 = F = min\n+        final String[] tempScaleLUT = { \"C\", \"F\" }; // Look Up Table used to convert TempUn integer 0,1 to \"C\" to \"F\"\n+                                                    // string for hashmap\n+        HashMap<String, Integer> nullCorFLUT = new HashMap<>(); // simple look up table for logic\n+        nullCorFLUT.put(\"C\", 0);\n+        nullCorFLUT.put(\"F\", 1);\n+        nullCorFLUT.put(\"INVALID\", 0);\n+\n+        String validRangeCorF; // stores if the input range is a valid C or F temperature\n+\n+        // force to global min/max\n+        int newVal = (Math.max(newValIn, Math.min(tempRanges.get(\"C\").get(\"min\"), tempRanges.get(\"F\").get(\"min\"))));\n+        newVal = Math.min(newVal, Math.max(tempRanges.get(\"C\").get(\"max\"), tempRanges.get(\"F\").get(\"max\")));\n+\n+        if ((newVal >= tempRanges.get(\"C\").get(\"min\")) && (newVal <= tempRanges.get(\"C\").get(\"max\"))) {\n+            validRangeCorF = \"C\";\n+        } else if ((newVal >= tempRanges.get(\"F\").get(\"min\")) && (newVal <= tempRanges.get(\"F\").get(\"max\"))) {\n+            validRangeCorF = \"F\";\n+        } else {\n+            logger.warn(\"Input Temp request {} is invalid\", newVal);\n+            validRangeCorF = \"INVALID\";\n+        }\n+\n+        // if CorF wasnt initialized or is null set it from lookup\n+        Integer CorF = CorFIn != null ? CorFIn : nullCorFLUT.get(validRangeCorF);\n+\n+        if ((CorF == 1) && validRangeCorF.equals(\"C\")) {\n+            CorF = 0; // input temp takes priority\n+        } else if ((CorF == 0) && validRangeCorF.equals(\"F\")) {\n+            CorF = 1; // input temp takes priority\n+        } else if (validRangeCorF.equals(\"INVALID\")) {\n+            // force min or max temp based on CorF scale to be used\n+            newVal = tempRanges.get(tempScaleLUT[CorF]).get(minMaxLUT[CorF]);\n+        }\n+\n+        return new int[] { newVal, CorF };\n+    }\n+\n+    public void setDeviceTempSet(DatagramSocket clientSocket, int value) throws GreeException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1e730ba701dc9c2bb5504f9fbbc0d2176c23490"}, "originalPosition": 369}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4NjM0NQ==", "bodyText": "Please use the camelcase naming convention.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private GreeScanResponse4GsonDTO mScanResponseGson;\n          \n          \n            \n                private GreeScanResponse4GsonDTO scanResponseGson;", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436486345", "createdAt": "2020-06-08T06:46:46Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,713 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\n+ * device specific attributes as well a the functionality for the Air Conditioner\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+// @NonNullByDefault\n+public class GreeAirDevice {\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\n+    private boolean isBound = false;\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\n+    private int port = 0;\n+    private String encKey = \"\";\n+    private GreeScanResponse4GsonDTO mScanResponseGson;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1e730ba701dc9c2bb5504f9fbbc0d2176c23490"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4NjQ3Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\n          \n          \n            \n                private final static Charset UTF8_CHARSET = StandardCharsets.UTF_8;", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436486472", "createdAt": "2020-06-08T06:47:08Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,713 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\n+ * device specific attributes as well a the functionality for the Air Conditioner\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+// @NonNullByDefault\n+public class GreeAirDevice {\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1e730ba701dc9c2bb5504f9fbbc0d2176c23490"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4NjY2OQ==", "bodyText": "Please make this a private static field so you can reuse it.", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436486669", "createdAt": "2020-06-08T06:47:40Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,713 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\n+ * device specific attributes as well a the functionality for the Air Conditioner\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+// @NonNullByDefault\n+public class GreeAirDevice {\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\n+    private boolean isBound = false;\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\n+    private int port = 0;\n+    private String encKey = \"\";\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\n+    private GreeBindResponse4GsonDTO bindResponseGson;\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\n+\n+    public boolean getIsBound() {\n+        return isBound;\n+    }\n+\n+    public void setIsBound(boolean isBound) {\n+        this.isBound = isBound;\n+    }\n+\n+    public InetAddress getAddress() {\n+        return ipAddress;\n+    }\n+\n+    public void setAddress(InetAddress address) {\n+        this.ipAddress = address;\n+    }\n+\n+    public int getPort() {\n+        return port;\n+    }\n+\n+    public void setPort(int port) {\n+        this.port = port;\n+    }\n+\n+    public String getKey() {\n+        return encKey;\n+    }\n+\n+    public String getId() {\n+        return mScanResponseGson.packJson.mac;\n+    }\n+\n+    public String getName() {\n+        return mScanResponseGson.packJson.name;\n+    }\n+\n+    public String getVendor() {\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\n+    }\n+\n+    public String getModel() {\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\n+    }\n+\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\n+        return mScanResponseGson;\n+    }\n+\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\n+        mScanResponseGson = gson;\n+    }\n+\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\n+        return bindResponseGson;\n+    }\n+\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\n+        return statusResponseGson;\n+    }\n+\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\n+        validateSocket(socket);\n+        byte[] sendData = new byte[1024];\n+        byte[] receiveData = new byte[347];\n+        Gson gson = new Gson();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1e730ba701dc9c2bb5504f9fbbc0d2176c23490"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4NzY0OA==", "bodyText": "This code seems repeated a lot, can you refactor it?", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436487648", "createdAt": "2020-06-08T06:50:06Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,713 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\n+ * device specific attributes as well a the functionality for the Air Conditioner\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+// @NonNullByDefault\n+public class GreeAirDevice {\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\n+    private boolean isBound = false;\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\n+    private int port = 0;\n+    private String encKey = \"\";\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\n+    private GreeBindResponse4GsonDTO bindResponseGson;\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\n+\n+    public boolean getIsBound() {\n+        return isBound;\n+    }\n+\n+    public void setIsBound(boolean isBound) {\n+        this.isBound = isBound;\n+    }\n+\n+    public InetAddress getAddress() {\n+        return ipAddress;\n+    }\n+\n+    public void setAddress(InetAddress address) {\n+        this.ipAddress = address;\n+    }\n+\n+    public int getPort() {\n+        return port;\n+    }\n+\n+    public void setPort(int port) {\n+        this.port = port;\n+    }\n+\n+    public String getKey() {\n+        return encKey;\n+    }\n+\n+    public String getId() {\n+        return mScanResponseGson.packJson.mac;\n+    }\n+\n+    public String getName() {\n+        return mScanResponseGson.packJson.name;\n+    }\n+\n+    public String getVendor() {\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\n+    }\n+\n+    public String getModel() {\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\n+    }\n+\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\n+        return mScanResponseGson;\n+    }\n+\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\n+        mScanResponseGson = gson;\n+    }\n+\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\n+        return bindResponseGson;\n+    }\n+\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\n+        return statusResponseGson;\n+    }\n+\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\n+        validateSocket(socket);\n+        byte[] sendData = new byte[1024];\n+        byte[] receiveData = new byte[347];\n+        Gson gson = new Gson();\n+\n+        try {\n+            // Prep the Binding Request pack\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\n+            bindReqPackGson.mac = getId();\n+            bindReqPackGson.t = \"bind\";\n+            bindReqPackGson.uid = 0;\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\n+\n+            // Now Encrypt the Binding Request pack\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\n+                    bindReqPackStr);\n+\n+            // Prep the Binding Request\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\n+            bindReqGson.cid = \"app\";\n+            bindReqGson.i = 1;\n+            bindReqGson.t = \"pack\";\n+            bindReqGson.uid = 0;\n+            bindReqGson.tcid = getId();\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\n+            String bindReqStr = gson.toJson(bindReqGson);\n+            sendData = bindReqStr.getBytes();\n+\n+            // Now Send the request\n+            DatagramSocket clientSocket = socket.get();\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\n+            clientSocket.send(sendPacket);\n+\n+            // Recieve a response\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+            clientSocket.receive(receivePacket);\n+            String modifiedSentence = new String(receivePacket.getData(), \"UTF-8\");\n+\n+            // Read the response\n+            StringReader stringReader = new StringReader(modifiedSentence);\n+            bindResponseGson = gson.fromJson(new JsonReader(stringReader), GreeBindResponse4GsonDTO.class);\n+            bindResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\n+                    bindResponseGson.pack);\n+\n+            // Create the JSON to hold the response values\n+            stringReader = new StringReader(bindResponseGson.decryptedPack);\n+            bindResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePack4GsonDTO.class);\n+\n+            // Now set the key and flag to indicate the bind was succesful\n+            encKey = bindResponseGson.packJson.key;\n+            setIsBound(true);\n+        } catch (IOException e) {\n+            throw new GreeException(e, \"failed\");\n+        }\n+    }\n+\n+    private void validateSocket(Optional<DatagramSocket> socket) {\n+        if (!socket.isPresent()) {\n+            throw new IllegalArgumentException(\"Socket not initialized!\");\n+        }\n+    }\n+\n+    public void setDevicePower(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 1)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Pow\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void SetDeviceMode(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 4)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Mod\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceSwingUpDown(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\n+        if (!getIsBound() || (value < 0 || value > 11) || (value > 6 && value < 10)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"SwUpDn\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceSwingLeftRight(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        // Only values 0,1,2,3,4,5,6 allowed\n+        if (!getIsBound() || (value < 0) || (value > 6)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"SwingLfRig\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    /**\n+     * Only allow this to happen if this device has been bound and values are valid\n+     * Possible values are :\n+     * 0 : Auto\n+     * 1 : Low\n+     * 2 : Medium Low\n+     * 3 : Medium\n+     * 4 : Medium High\n+     * 5 : High\n+     */\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, int value) throws GreeException {\n+        if (!getIsBound() || (value < 0 || value > 5)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"WdSpd\", value);\n+        parameters.put(\"Quiet\", 0);\n+        parameters.put(\"Tur\", 0);\n+        parameters.put(\"NoiseSet\", 0);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceTurbo(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 1)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Tur\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setQuietMode(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 2)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Quiet\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public int getDeviceTurbo() {\n+        return getIntStatusVal(\"Tur\");\n+    }\n+\n+    public void setDeviceLight(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 1)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Lig\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    /**\n+     * Create Hash Look Up for C and F\n+     * Temperature Ranges for gree A/C units (f_range = {86,61}, c_range={16,30}\n+     */\n+    private static HashMap<String, HashMap<String, Integer>> createTempRangeMap() {\n+        HashMap<String, HashMap<String, Integer>> tempRanges = new HashMap<>();\n+        HashMap<String, Integer> hmf = new HashMap<>();\n+        HashMap<String, Integer> hmc = new HashMap<>();\n+\n+        hmf.put(\"min\", 61); // F\n+        hmf.put(\"max\", 86);\n+        tempRanges.put(\"F\", hmf);\n+\n+        hmc.put(\"min\", 16); // C\n+        hmc.put(\"max\", 30);\n+        tempRanges.put(\"C\", hmc);\n+\n+        return tempRanges;\n+    }\n+\n+    /**\n+     * Checks input ranges for validity and TempUn for validity\n+     * Uses newVal as priority and tries to validate and determine intent\n+     * For example if value is 75 and TempUn says Celsius, change TempUn to Fahrenheit\n+     */\n+    private int[] validateTemperatureRangeForTempSet(int newValIn, @Nullable Integer CorFIn) {\n+        final String[] minMaxLUT = { \"max\", \"min\" }; // looks up 0 = C = max, 1 = F = min\n+        final String[] tempScaleLUT = { \"C\", \"F\" }; // Look Up Table used to convert TempUn integer 0,1 to \"C\" to \"F\"\n+                                                    // string for hashmap\n+        HashMap<String, Integer> nullCorFLUT = new HashMap<>(); // simple look up table for logic\n+        nullCorFLUT.put(\"C\", 0);\n+        nullCorFLUT.put(\"F\", 1);\n+        nullCorFLUT.put(\"INVALID\", 0);\n+\n+        String validRangeCorF; // stores if the input range is a valid C or F temperature\n+\n+        // force to global min/max\n+        int newVal = (Math.max(newValIn, Math.min(tempRanges.get(\"C\").get(\"min\"), tempRanges.get(\"F\").get(\"min\"))));\n+        newVal = Math.min(newVal, Math.max(tempRanges.get(\"C\").get(\"max\"), tempRanges.get(\"F\").get(\"max\")));\n+\n+        if ((newVal >= tempRanges.get(\"C\").get(\"min\")) && (newVal <= tempRanges.get(\"C\").get(\"max\"))) {\n+            validRangeCorF = \"C\";\n+        } else if ((newVal >= tempRanges.get(\"F\").get(\"min\")) && (newVal <= tempRanges.get(\"F\").get(\"max\"))) {\n+            validRangeCorF = \"F\";\n+        } else {\n+            logger.warn(\"Input Temp request {} is invalid\", newVal);\n+            validRangeCorF = \"INVALID\";\n+        }\n+\n+        // if CorF wasnt initialized or is null set it from lookup\n+        Integer CorF = CorFIn != null ? CorFIn : nullCorFLUT.get(validRangeCorF);\n+\n+        if ((CorF == 1) && validRangeCorF.equals(\"C\")) {\n+            CorF = 0; // input temp takes priority\n+        } else if ((CorF == 0) && validRangeCorF.equals(\"F\")) {\n+            CorF = 1; // input temp takes priority\n+        } else if (validRangeCorF.equals(\"INVALID\")) {\n+            // force min or max temp based on CorF scale to be used\n+            newVal = tempRanges.get(tempScaleLUT[CorF]).get(minMaxLUT[CorF]);\n+        }\n+\n+        return new int[] { newVal, CorF };\n+    }\n+\n+    public void setDeviceTempSet(DatagramSocket clientSocket, int value) throws GreeException {\n+        // **value** : set temperature in degrees celsius or Fahrenheit\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+        int newVal = value;\n+        int outVal = value;\n+        // Get Celsius or Fahrenheit from status message\n+        Integer CorF = getIntStatusVal(\"TemUn\");\n+        // TODO put a param in openhab to allow setting this from the config\n+\n+        // If commanding Fahrenheit set halfStep to 1 or 0 to tell the A/C which F integer\n+        // temperature to use as celsius alone is ambigious\n+        int halfStep = 0; // default to C\n+\n+        int[] retList = validateTemperatureRangeForTempSet(newVal, CorF);\n+        newVal = retList[0];\n+        CorF = retList[1];\n+\n+        if (CorF == 1) { // If Fahrenheit,\n+            // value argument is degrees F, convert Fahrenheit to Celsius,\n+            // SetTem input to A/C always in Celsius despite passing in 1 to TemUn\n+            outVal = (int) (Math.round((newVal - 32.) * 5.0 / 9.0)); // Integer Truncated\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\n+            // F = [68. , 69. , 70. , 71. , 72. , 73. , 74. , 75. , 76. , 77. , 78. , 79. , 80. , 81. , 82. , 83. ,\n+            // 84. , 85. , 86. ]\n+            // C = [20.0, 20.5, 21.1, 21.6, 22.2, 22.7, 23.3, 23.8, 24.4, 25.0, 25.5, 26.1, 26.6, 27.2, 27.7, 28.3,\n+            // 28.8, 29.4, 30.0]\n+            // TemSet = [20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 30, 30]\n+            // TemRec = [ 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\n+            // subtract the float version - the int version to get the fractional difference\n+            // if the difference is positive set halfStep to 1, negative to 0\n+            halfStep = ((((newVal - 32.) * 5.0 / 9.0) - outVal) > 0) ? 1 : 0;\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"TemUn\", CorF);\n+        parameters.put(\"SetTem\", outVal);\n+        parameters.put(\"TemRec\", halfStep);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceAir(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Air\", value);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceDry(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Blo\", value);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceHealth(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Health\", value);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDevicePwrSaving(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"SvSt\", value);\n+        parameters.put(\"WdSpd\", 0);\n+        parameters.put(\"Quiet\", 0);\n+        parameters.put(\"Tur\", 0);\n+        parameters.put(\"SwhSlp\", 0);\n+        parameters.put(\"SlpMod\", 0);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public int getIntStatusVal(String valueName) {\n+        /*\n+         * Note : Values can be:\n+         * \"Pow\": Power (0 or 1)\n+         * \"Mod\": Mode: Auto: 0, Cool: 1, Dry: 2, Fan: 3, Heat: 4\n+         * \"SetTem\": Requested Temperature\n+         * \"WdSpd\": Fan Speed : Low:1, Medium Low:2, Medium :3, Medium High :4, High :5\n+         * \"Air\": Air Mode Enabled\n+         * \"Blo\": Dry\n+         * \"Health\": Health\n+         * \"SwhSlp\": Sleep\n+         * \"SlpMod\": ???\n+         * \"Lig\": Light On\n+         * \"SwingLfRig\": Swing Left Right\n+         * \"SwUpDn\": Swing Up Down: // Ceiling:0, Upwards : 10, Downwards : 11, Full range : 1\n+         * \"Quiet\": Quiet mode\n+         * \"Tur\": Turbo\n+         * \"StHt\": 0,\n+         * \"TemUn\": Temperature unit, 0 for Celsius, 1 for Fahrenheit\n+         * \"HeatCoolType\"\n+         * \"TemRec\": (0 or 1), Send with SetTem, when TemUn==1, distinguishes between upper and lower integer Fahrenheit\n+         * temp\n+         * \"SvSt\": Power Saving\n+         */\n+        // Find the valueName in the Returned Status object\n+        String columns[] = statusResponseGson.packJson.cols;\n+        Integer values[] = statusResponseGson.packJson.dat;\n+        List<String> colList = new ArrayList<>(Arrays.asList(columns));\n+        List<Integer> valList = new ArrayList<>(Arrays.asList(values));\n+        int valueArrayposition = colList.indexOf(valueName);\n+        if (valueArrayposition == -1) {\n+            return -1;\n+        }\n+\n+        // Now get the Corresponding value\n+        Integer value = valList.get(valueArrayposition);\n+        return value;\n+    }\n+\n+    public boolean hasStatusValChanged(String valueName) throws GreeException {\n+        if (prevStatusResponsePackGson == null) {\n+            return true; // update value if there is no previous one\n+        }\n+        // Find the valueName in the Current Status object\n+        String currcolumns[] = statusResponseGson.packJson.cols;\n+        Integer currvalues[] = statusResponseGson.packJson.dat;\n+        List<String> currcolList = new ArrayList<>(Arrays.asList(currcolumns));\n+        List<Integer> currvalList = new ArrayList<>(Arrays.asList(currvalues));\n+        int currvalueArrayposition = currcolList.indexOf(valueName);\n+        if (currvalueArrayposition == -1) {\n+            throw new GreeException(\"Unable to decode device status\");\n+        }\n+        // Now get the Corresponding value\n+        int currvalue = currvalList.get(currvalueArrayposition);\n+\n+        // Find the valueName in the Previous Status object\n+        String prevcolumns[] = prevStatusResponsePackGson.cols;\n+        Integer prevvalues[] = prevStatusResponsePackGson.dat;\n+        List<String> prevcolList = new ArrayList<>(Arrays.asList(prevcolumns));\n+        List<Integer> prevvalList = new ArrayList<>(Arrays.asList(prevvalues));\n+        int prevvalueArrayposition = prevcolList.indexOf(valueName);\n+        if (prevvalueArrayposition == -1) {\n+            throw new GreeException(\"Unable to get status value\");\n+        }\n+        // Now get the Corresponding value\n+        int prevvalue = prevvalList.get(prevvalueArrayposition);\n+\n+        // Finally Compare the values\n+        return currvalue != prevvalue;\n+    }\n+\n+    protected void executeCommand(DatagramSocket clientSocket, HashMap<String, Integer> parameters)\n+            throws GreeException {\n+        byte[] sendData = new byte[1024];\n+        byte[] receiveData = new byte[1024];\n+        Gson gson = new Gson();\n+\n+        try {\n+            // Convert the parameter map values to arrays\n+            String[] keyArray = parameters.keySet().toArray(new String[0]);\n+            Integer[] valueArray = parameters.values().toArray(new Integer[0]);\n+\n+            // Prep the Command Request pack\n+            GreeExecuteCommandPack4GsonDTO execCmdPackGson = new GreeExecuteCommandPack4GsonDTO();\n+            execCmdPackGson.opt = keyArray;\n+            execCmdPackGson.p = valueArray;\n+            execCmdPackGson.t = \"cmd\";\n+            String execCmdPackStr = gson.toJson(execCmdPackGson);\n+\n+            // Now Encrypt the Binding Request pack\n+            String encryptedCommandReqPacket = GreeCryptoUtil.encryptPack(getKey().getBytes(), execCmdPackStr);\n+            // String unencryptedCommandReqPacket = CryptoUtil.decryptPack(device.getKey().getBytes(),\n+            // encryptedCommandReqPacket);\n+\n+            // Prep the Command Request\n+            GreeExecCommand4GsonDTO execCmdGson = new GreeExecCommand4GsonDTO();\n+            execCmdGson.cid = \"app\";\n+            execCmdGson.i = 0;\n+            execCmdGson.t = \"pack\";\n+            execCmdGson.uid = 0;\n+            execCmdGson.tcid = getId();\n+            execCmdGson.pack = new String(encryptedCommandReqPacket.getBytes(), UTF8_CHARSET);\n+            String execCmdStr = gson.toJson(execCmdGson);\n+            sendData = execCmdStr.getBytes();\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\n+            clientSocket.send(sendPacket);\n+\n+            // Recieve a response\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+            clientSocket.receive(receivePacket);\n+            String modifiedSentence = new String(receivePacket.getData(), \"UTF-8\");\n+\n+            // Read the response\n+            StringReader stringReader = new StringReader(modifiedSentence);\n+            GreeExecResponse4GsonDTO execResponseGson = gson.fromJson(new JsonReader(stringReader),\n+                    GreeExecResponse4GsonDTO.class);\n+            execResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(this.getKey().getBytes(),\n+                    execResponseGson.pack);\n+\n+            // Create the JSON to hold the response values\n+            stringReader = new StringReader(execResponseGson.decryptedPack);\n+            execResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeExecResponsePack4GsonDTO.class);\n+        } catch (IOException e) {\n+            throw new GreeException(e, \"Exception on command execution\");\n+        }\n+    }\n+\n+    public void getDeviceStatus(DatagramSocket clientSocket) throws GreeException {\n+        Gson gson = new Gson();\n+        byte[] sendData = new byte[1024];\n+        byte[] receiveData = new byte[1024];\n+\n+        try {\n+            // Set the values in the HashMap\n+            ArrayList<String> columns = new ArrayList<>();\n+            columns.add(\"Pow\");\n+            columns.add(\"Mod\");\n+            columns.add(\"SetTem\");\n+            columns.add(\"WdSpd\");\n+            columns.add(\"Air\");\n+            columns.add(\"Blo\");\n+            columns.add(\"Health\");\n+            columns.add(\"SwhSlp\");\n+            columns.add(\"Lig\");\n+            columns.add(\"SwingLfRig\");\n+            columns.add(\"SwUpDn\");\n+            columns.add(\"Quiet\");\n+            columns.add(\"Tur\");\n+            columns.add(\"StHt\");\n+            columns.add(\"TemUn\");\n+            columns.add(\"HeatCoolType\");\n+            columns.add(\"TemRec\");\n+            columns.add(\"SvSt\");\n+            columns.add(\"NoiseSet\");\n+\n+            // Convert the parameter map values to arrays\n+            String[] colArray = columns.toArray(new String[0]);\n+\n+            // Prep the Command Request pack\n+            GreeReqStatusPack4GsonDTO reqStatusPackGson = new GreeReqStatusPack4GsonDTO();\n+            reqStatusPackGson.t = \"status\";\n+            reqStatusPackGson.cols = colArray;\n+            reqStatusPackGson.mac = getId();\n+            String reqStatusPackStr = gson.toJson(reqStatusPackGson);\n+\n+            // Now Encrypt the Binding Request pack\n+            String encryptedStatusReqPacket = GreeCryptoUtil.encryptPack(getKey().getBytes(), reqStatusPackStr);\n+\n+            // Prep the Status Request\n+            GreeReqStatus4GsonDTO reqStatusGson = new GreeReqStatus4GsonDTO();\n+            reqStatusGson.cid = \"app\";\n+            reqStatusGson.i = 0;\n+            reqStatusGson.t = \"pack\";\n+            reqStatusGson.uid = 0;\n+            reqStatusGson.tcid = getId();\n+            reqStatusGson.pack = new String(encryptedStatusReqPacket.getBytes(), UTF8_CHARSET);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1e730ba701dc9c2bb5504f9fbbc0d2176c23490"}, "originalPosition": 647}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4Nzg2OA==", "bodyText": "I'd prefer if you used the units framework to do your conversions.", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436487868", "createdAt": "2020-06-08T06:50:41Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,713 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\n+ * device specific attributes as well a the functionality for the Air Conditioner\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+// @NonNullByDefault\n+public class GreeAirDevice {\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\n+    private boolean isBound = false;\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\n+    private int port = 0;\n+    private String encKey = \"\";\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\n+    private GreeBindResponse4GsonDTO bindResponseGson;\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\n+\n+    public boolean getIsBound() {\n+        return isBound;\n+    }\n+\n+    public void setIsBound(boolean isBound) {\n+        this.isBound = isBound;\n+    }\n+\n+    public InetAddress getAddress() {\n+        return ipAddress;\n+    }\n+\n+    public void setAddress(InetAddress address) {\n+        this.ipAddress = address;\n+    }\n+\n+    public int getPort() {\n+        return port;\n+    }\n+\n+    public void setPort(int port) {\n+        this.port = port;\n+    }\n+\n+    public String getKey() {\n+        return encKey;\n+    }\n+\n+    public String getId() {\n+        return mScanResponseGson.packJson.mac;\n+    }\n+\n+    public String getName() {\n+        return mScanResponseGson.packJson.name;\n+    }\n+\n+    public String getVendor() {\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\n+    }\n+\n+    public String getModel() {\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\n+    }\n+\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\n+        return mScanResponseGson;\n+    }\n+\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\n+        mScanResponseGson = gson;\n+    }\n+\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\n+        return bindResponseGson;\n+    }\n+\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\n+        return statusResponseGson;\n+    }\n+\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\n+        validateSocket(socket);\n+        byte[] sendData = new byte[1024];\n+        byte[] receiveData = new byte[347];\n+        Gson gson = new Gson();\n+\n+        try {\n+            // Prep the Binding Request pack\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\n+            bindReqPackGson.mac = getId();\n+            bindReqPackGson.t = \"bind\";\n+            bindReqPackGson.uid = 0;\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\n+\n+            // Now Encrypt the Binding Request pack\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\n+                    bindReqPackStr);\n+\n+            // Prep the Binding Request\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\n+            bindReqGson.cid = \"app\";\n+            bindReqGson.i = 1;\n+            bindReqGson.t = \"pack\";\n+            bindReqGson.uid = 0;\n+            bindReqGson.tcid = getId();\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\n+            String bindReqStr = gson.toJson(bindReqGson);\n+            sendData = bindReqStr.getBytes();\n+\n+            // Now Send the request\n+            DatagramSocket clientSocket = socket.get();\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\n+            clientSocket.send(sendPacket);\n+\n+            // Recieve a response\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+            clientSocket.receive(receivePacket);\n+            String modifiedSentence = new String(receivePacket.getData(), \"UTF-8\");\n+\n+            // Read the response\n+            StringReader stringReader = new StringReader(modifiedSentence);\n+            bindResponseGson = gson.fromJson(new JsonReader(stringReader), GreeBindResponse4GsonDTO.class);\n+            bindResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\n+                    bindResponseGson.pack);\n+\n+            // Create the JSON to hold the response values\n+            stringReader = new StringReader(bindResponseGson.decryptedPack);\n+            bindResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePack4GsonDTO.class);\n+\n+            // Now set the key and flag to indicate the bind was succesful\n+            encKey = bindResponseGson.packJson.key;\n+            setIsBound(true);\n+        } catch (IOException e) {\n+            throw new GreeException(e, \"failed\");\n+        }\n+    }\n+\n+    private void validateSocket(Optional<DatagramSocket> socket) {\n+        if (!socket.isPresent()) {\n+            throw new IllegalArgumentException(\"Socket not initialized!\");\n+        }\n+    }\n+\n+    public void setDevicePower(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 1)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Pow\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void SetDeviceMode(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 4)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Mod\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceSwingUpDown(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\n+        if (!getIsBound() || (value < 0 || value > 11) || (value > 6 && value < 10)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"SwUpDn\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceSwingLeftRight(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        // Only values 0,1,2,3,4,5,6 allowed\n+        if (!getIsBound() || (value < 0) || (value > 6)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"SwingLfRig\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    /**\n+     * Only allow this to happen if this device has been bound and values are valid\n+     * Possible values are :\n+     * 0 : Auto\n+     * 1 : Low\n+     * 2 : Medium Low\n+     * 3 : Medium\n+     * 4 : Medium High\n+     * 5 : High\n+     */\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, int value) throws GreeException {\n+        if (!getIsBound() || (value < 0 || value > 5)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"WdSpd\", value);\n+        parameters.put(\"Quiet\", 0);\n+        parameters.put(\"Tur\", 0);\n+        parameters.put(\"NoiseSet\", 0);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceTurbo(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 1)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Tur\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setQuietMode(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 2)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Quiet\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public int getDeviceTurbo() {\n+        return getIntStatusVal(\"Tur\");\n+    }\n+\n+    public void setDeviceLight(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 1)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Lig\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    /**\n+     * Create Hash Look Up for C and F\n+     * Temperature Ranges for gree A/C units (f_range = {86,61}, c_range={16,30}\n+     */\n+    private static HashMap<String, HashMap<String, Integer>> createTempRangeMap() {\n+        HashMap<String, HashMap<String, Integer>> tempRanges = new HashMap<>();\n+        HashMap<String, Integer> hmf = new HashMap<>();\n+        HashMap<String, Integer> hmc = new HashMap<>();\n+\n+        hmf.put(\"min\", 61); // F\n+        hmf.put(\"max\", 86);\n+        tempRanges.put(\"F\", hmf);\n+\n+        hmc.put(\"min\", 16); // C\n+        hmc.put(\"max\", 30);\n+        tempRanges.put(\"C\", hmc);\n+\n+        return tempRanges;\n+    }\n+\n+    /**\n+     * Checks input ranges for validity and TempUn for validity\n+     * Uses newVal as priority and tries to validate and determine intent\n+     * For example if value is 75 and TempUn says Celsius, change TempUn to Fahrenheit\n+     */\n+    private int[] validateTemperatureRangeForTempSet(int newValIn, @Nullable Integer CorFIn) {\n+        final String[] minMaxLUT = { \"max\", \"min\" }; // looks up 0 = C = max, 1 = F = min\n+        final String[] tempScaleLUT = { \"C\", \"F\" }; // Look Up Table used to convert TempUn integer 0,1 to \"C\" to \"F\"\n+                                                    // string for hashmap\n+        HashMap<String, Integer> nullCorFLUT = new HashMap<>(); // simple look up table for logic\n+        nullCorFLUT.put(\"C\", 0);\n+        nullCorFLUT.put(\"F\", 1);\n+        nullCorFLUT.put(\"INVALID\", 0);\n+\n+        String validRangeCorF; // stores if the input range is a valid C or F temperature\n+\n+        // force to global min/max\n+        int newVal = (Math.max(newValIn, Math.min(tempRanges.get(\"C\").get(\"min\"), tempRanges.get(\"F\").get(\"min\"))));\n+        newVal = Math.min(newVal, Math.max(tempRanges.get(\"C\").get(\"max\"), tempRanges.get(\"F\").get(\"max\")));\n+\n+        if ((newVal >= tempRanges.get(\"C\").get(\"min\")) && (newVal <= tempRanges.get(\"C\").get(\"max\"))) {\n+            validRangeCorF = \"C\";\n+        } else if ((newVal >= tempRanges.get(\"F\").get(\"min\")) && (newVal <= tempRanges.get(\"F\").get(\"max\"))) {\n+            validRangeCorF = \"F\";\n+        } else {\n+            logger.warn(\"Input Temp request {} is invalid\", newVal);\n+            validRangeCorF = \"INVALID\";\n+        }\n+\n+        // if CorF wasnt initialized or is null set it from lookup\n+        Integer CorF = CorFIn != null ? CorFIn : nullCorFLUT.get(validRangeCorF);\n+\n+        if ((CorF == 1) && validRangeCorF.equals(\"C\")) {\n+            CorF = 0; // input temp takes priority\n+        } else if ((CorF == 0) && validRangeCorF.equals(\"F\")) {\n+            CorF = 1; // input temp takes priority\n+        } else if (validRangeCorF.equals(\"INVALID\")) {\n+            // force min or max temp based on CorF scale to be used\n+            newVal = tempRanges.get(tempScaleLUT[CorF]).get(minMaxLUT[CorF]);\n+        }\n+\n+        return new int[] { newVal, CorF };\n+    }\n+\n+    public void setDeviceTempSet(DatagramSocket clientSocket, int value) throws GreeException {\n+        // **value** : set temperature in degrees celsius or Fahrenheit\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+        int newVal = value;\n+        int outVal = value;\n+        // Get Celsius or Fahrenheit from status message\n+        Integer CorF = getIntStatusVal(\"TemUn\");\n+        // TODO put a param in openhab to allow setting this from the config\n+\n+        // If commanding Fahrenheit set halfStep to 1 or 0 to tell the A/C which F integer\n+        // temperature to use as celsius alone is ambigious\n+        int halfStep = 0; // default to C\n+\n+        int[] retList = validateTemperatureRangeForTempSet(newVal, CorF);\n+        newVal = retList[0];\n+        CorF = retList[1];\n+\n+        if (CorF == 1) { // If Fahrenheit,\n+            // value argument is degrees F, convert Fahrenheit to Celsius,\n+            // SetTem input to A/C always in Celsius despite passing in 1 to TemUn\n+            outVal = (int) (Math.round((newVal - 32.) * 5.0 / 9.0)); // Integer Truncated\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\n+            // F = [68. , 69. , 70. , 71. , 72. , 73. , 74. , 75. , 76. , 77. , 78. , 79. , 80. , 81. , 82. , 83. ,\n+            // 84. , 85. , 86. ]\n+            // C = [20.0, 20.5, 21.1, 21.6, 22.2, 22.7, 23.3, 23.8, 24.4, 25.0, 25.5, 26.1, 26.6, 27.2, 27.7, 28.3,\n+            // 28.8, 29.4, 30.0]\n+            // TemSet = [20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 30, 30]\n+            // TemRec = [ 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\n+            // subtract the float version - the int version to get the fractional difference\n+            // if the difference is positive set halfStep to 1, negative to 0\n+            halfStep = ((((newVal - 32.) * 5.0 / 9.0) - outVal) > 0) ? 1 : 0;\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"TemUn\", CorF);\n+        parameters.put(\"SetTem\", outVal);\n+        parameters.put(\"TemRec\", halfStep);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceAir(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Air\", value);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceDry(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Blo\", value);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceHealth(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Health\", value);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDevicePwrSaving(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"SvSt\", value);\n+        parameters.put(\"WdSpd\", 0);\n+        parameters.put(\"Quiet\", 0);\n+        parameters.put(\"Tur\", 0);\n+        parameters.put(\"SwhSlp\", 0);\n+        parameters.put(\"SlpMod\", 0);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public int getIntStatusVal(String valueName) {\n+        /*\n+         * Note : Values can be:\n+         * \"Pow\": Power (0 or 1)\n+         * \"Mod\": Mode: Auto: 0, Cool: 1, Dry: 2, Fan: 3, Heat: 4\n+         * \"SetTem\": Requested Temperature\n+         * \"WdSpd\": Fan Speed : Low:1, Medium Low:2, Medium :3, Medium High :4, High :5\n+         * \"Air\": Air Mode Enabled\n+         * \"Blo\": Dry\n+         * \"Health\": Health\n+         * \"SwhSlp\": Sleep\n+         * \"SlpMod\": ???\n+         * \"Lig\": Light On\n+         * \"SwingLfRig\": Swing Left Right\n+         * \"SwUpDn\": Swing Up Down: // Ceiling:0, Upwards : 10, Downwards : 11, Full range : 1\n+         * \"Quiet\": Quiet mode\n+         * \"Tur\": Turbo\n+         * \"StHt\": 0,\n+         * \"TemUn\": Temperature unit, 0 for Celsius, 1 for Fahrenheit\n+         * \"HeatCoolType\"\n+         * \"TemRec\": (0 or 1), Send with SetTem, when TemUn==1, distinguishes between upper and lower integer Fahrenheit\n+         * temp\n+         * \"SvSt\": Power Saving\n+         */\n+        // Find the valueName in the Returned Status object\n+        String columns[] = statusResponseGson.packJson.cols;\n+        Integer values[] = statusResponseGson.packJson.dat;\n+        List<String> colList = new ArrayList<>(Arrays.asList(columns));\n+        List<Integer> valList = new ArrayList<>(Arrays.asList(values));\n+        int valueArrayposition = colList.indexOf(valueName);\n+        if (valueArrayposition == -1) {\n+            return -1;\n+        }\n+\n+        // Now get the Corresponding value\n+        Integer value = valList.get(valueArrayposition);\n+        return value;\n+    }\n+\n+    public boolean hasStatusValChanged(String valueName) throws GreeException {\n+        if (prevStatusResponsePackGson == null) {\n+            return true; // update value if there is no previous one\n+        }\n+        // Find the valueName in the Current Status object\n+        String currcolumns[] = statusResponseGson.packJson.cols;\n+        Integer currvalues[] = statusResponseGson.packJson.dat;\n+        List<String> currcolList = new ArrayList<>(Arrays.asList(currcolumns));\n+        List<Integer> currvalList = new ArrayList<>(Arrays.asList(currvalues));\n+        int currvalueArrayposition = currcolList.indexOf(valueName);\n+        if (currvalueArrayposition == -1) {\n+            throw new GreeException(\"Unable to decode device status\");\n+        }\n+        // Now get the Corresponding value\n+        int currvalue = currvalList.get(currvalueArrayposition);\n+\n+        // Find the valueName in the Previous Status object\n+        String prevcolumns[] = prevStatusResponsePackGson.cols;\n+        Integer prevvalues[] = prevStatusResponsePackGson.dat;\n+        List<String> prevcolList = new ArrayList<>(Arrays.asList(prevcolumns));\n+        List<Integer> prevvalList = new ArrayList<>(Arrays.asList(prevvalues));\n+        int prevvalueArrayposition = prevcolList.indexOf(valueName);\n+        if (prevvalueArrayposition == -1) {\n+            throw new GreeException(\"Unable to get status value\");\n+        }\n+        // Now get the Corresponding value\n+        int prevvalue = prevvalList.get(prevvalueArrayposition);\n+\n+        // Finally Compare the values\n+        return currvalue != prevvalue;\n+    }\n+\n+    protected void executeCommand(DatagramSocket clientSocket, HashMap<String, Integer> parameters)\n+            throws GreeException {\n+        byte[] sendData = new byte[1024];\n+        byte[] receiveData = new byte[1024];\n+        Gson gson = new Gson();\n+\n+        try {\n+            // Convert the parameter map values to arrays\n+            String[] keyArray = parameters.keySet().toArray(new String[0]);\n+            Integer[] valueArray = parameters.values().toArray(new Integer[0]);\n+\n+            // Prep the Command Request pack\n+            GreeExecuteCommandPack4GsonDTO execCmdPackGson = new GreeExecuteCommandPack4GsonDTO();\n+            execCmdPackGson.opt = keyArray;\n+            execCmdPackGson.p = valueArray;\n+            execCmdPackGson.t = \"cmd\";\n+            String execCmdPackStr = gson.toJson(execCmdPackGson);\n+\n+            // Now Encrypt the Binding Request pack\n+            String encryptedCommandReqPacket = GreeCryptoUtil.encryptPack(getKey().getBytes(), execCmdPackStr);\n+            // String unencryptedCommandReqPacket = CryptoUtil.decryptPack(device.getKey().getBytes(),\n+            // encryptedCommandReqPacket);\n+\n+            // Prep the Command Request\n+            GreeExecCommand4GsonDTO execCmdGson = new GreeExecCommand4GsonDTO();\n+            execCmdGson.cid = \"app\";\n+            execCmdGson.i = 0;\n+            execCmdGson.t = \"pack\";\n+            execCmdGson.uid = 0;\n+            execCmdGson.tcid = getId();\n+            execCmdGson.pack = new String(encryptedCommandReqPacket.getBytes(), UTF8_CHARSET);\n+            String execCmdStr = gson.toJson(execCmdGson);\n+            sendData = execCmdStr.getBytes();\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\n+            clientSocket.send(sendPacket);\n+\n+            // Recieve a response\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+            clientSocket.receive(receivePacket);\n+            String modifiedSentence = new String(receivePacket.getData(), \"UTF-8\");\n+\n+            // Read the response\n+            StringReader stringReader = new StringReader(modifiedSentence);\n+            GreeExecResponse4GsonDTO execResponseGson = gson.fromJson(new JsonReader(stringReader),\n+                    GreeExecResponse4GsonDTO.class);\n+            execResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(this.getKey().getBytes(),\n+                    execResponseGson.pack);\n+\n+            // Create the JSON to hold the response values\n+            stringReader = new StringReader(execResponseGson.decryptedPack);\n+            execResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeExecResponsePack4GsonDTO.class);\n+        } catch (IOException e) {\n+            throw new GreeException(e, \"Exception on command execution\");\n+        }\n+    }\n+\n+    public void getDeviceStatus(DatagramSocket clientSocket) throws GreeException {\n+        Gson gson = new Gson();\n+        byte[] sendData = new byte[1024];\n+        byte[] receiveData = new byte[1024];\n+\n+        try {\n+            // Set the values in the HashMap\n+            ArrayList<String> columns = new ArrayList<>();\n+            columns.add(\"Pow\");\n+            columns.add(\"Mod\");\n+            columns.add(\"SetTem\");\n+            columns.add(\"WdSpd\");\n+            columns.add(\"Air\");\n+            columns.add(\"Blo\");\n+            columns.add(\"Health\");\n+            columns.add(\"SwhSlp\");\n+            columns.add(\"Lig\");\n+            columns.add(\"SwingLfRig\");\n+            columns.add(\"SwUpDn\");\n+            columns.add(\"Quiet\");\n+            columns.add(\"Tur\");\n+            columns.add(\"StHt\");\n+            columns.add(\"TemUn\");\n+            columns.add(\"HeatCoolType\");\n+            columns.add(\"TemRec\");\n+            columns.add(\"SvSt\");\n+            columns.add(\"NoiseSet\");\n+\n+            // Convert the parameter map values to arrays\n+            String[] colArray = columns.toArray(new String[0]);\n+\n+            // Prep the Command Request pack\n+            GreeReqStatusPack4GsonDTO reqStatusPackGson = new GreeReqStatusPack4GsonDTO();\n+            reqStatusPackGson.t = \"status\";\n+            reqStatusPackGson.cols = colArray;\n+            reqStatusPackGson.mac = getId();\n+            String reqStatusPackStr = gson.toJson(reqStatusPackGson);\n+\n+            // Now Encrypt the Binding Request pack\n+            String encryptedStatusReqPacket = GreeCryptoUtil.encryptPack(getKey().getBytes(), reqStatusPackStr);\n+\n+            // Prep the Status Request\n+            GreeReqStatus4GsonDTO reqStatusGson = new GreeReqStatus4GsonDTO();\n+            reqStatusGson.cid = \"app\";\n+            reqStatusGson.i = 0;\n+            reqStatusGson.t = \"pack\";\n+            reqStatusGson.uid = 0;\n+            reqStatusGson.tcid = getId();\n+            reqStatusGson.pack = new String(encryptedStatusReqPacket.getBytes(), UTF8_CHARSET);\n+            String execCmdStr = gson.toJson(reqStatusGson);\n+            sendData = execCmdStr.getBytes();\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\n+            clientSocket.send(sendPacket);\n+\n+            // Recieve a response\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+            clientSocket.receive(receivePacket);\n+            String modifiedSentence = new String(receivePacket.getData(), \"UTF-8\");\n+\n+            // Keep a copy of the old response to be used to check if values have changed\n+            // If first time running, there will not be a previous GreeStatusResponsePack4Gson\n+            if (statusResponseGson != null && statusResponseGson.packJson != null) {\n+                prevStatusResponsePackGson = new GreeStatusResponsePack4GsonDTO(statusResponseGson.packJson);\n+            }\n+\n+            // Read the response\n+            StringReader stringReader = new StringReader(modifiedSentence);\n+            statusResponseGson = gson.fromJson(new JsonReader(stringReader), GreeStatusResponse4GsonDTO.class);\n+            statusResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(this.getKey().getBytes(),\n+                    statusResponseGson.pack);\n+\n+            logger.trace(\"Response from device: {}\", statusResponseGson.decryptedPack);\n+\n+            // Create the JSON to hold the response values\n+            stringReader = new StringReader(statusResponseGson.decryptedPack);\n+\n+            statusResponseGson.packJson = gson.fromJson(new JsonReader(stringReader),\n+                    GreeStatusResponsePack4GsonDTO.class);\n+            updateTempFtoC();\n+        } catch (IOException e) {\n+            throw new GreeException(e, \"I/O exception while receiving data\");\n+        }\n+    }\n+\n+    private void updateTempFtoC() {\n+        // Status message back from A/C always reports degrees C\n+        // If using Fahrenheit, us SetTem, TemUn and TemRec to reconstruct the Fahrenheit temperature\n+        // Get Celsius or Fahrenheit from status message\n+        int CorF = getIntStatusVal(\"TemUn\");\n+        int newVal = getIntStatusVal(\"SetTem\");\n+        int halfStep = getIntStatusVal(\"TemRec\");\n+\n+        if ((CorF == -1) || (newVal == -1) || (halfStep == -1)) {\n+            throw new IllegalArgumentException(\"SetTem,TemUn or TemRec is invalid, not performing conversion\");\n+        } else if (CorF == 1) { // convert SetTem to Fahrenheit\n+            // Find the valueName in the Returned Status object\n+            String columns[] = statusResponseGson.packJson.cols;\n+            Integer values[] = statusResponseGson.packJson.dat;\n+            List<String> colList = new ArrayList<>(Arrays.asList(columns));\n+            int valueArrayposition = colList.indexOf(\"SetTem\");\n+            if (valueArrayposition != -1) {\n+                // convert Celsius to Fahrenheit,\n+                // SetTem status returns degrees C regardless of TempUn setting\n+\n+                // Perform the float Celsius to Fahrenheit conversion add or subtract 0.5 based on the value of TemRec\n+                // (0 = -0.5, 1 = +0.5). Pass into a rounding function, this yeild the correct Fahrenheit Temperature to\n+                // match A/C display\n+                newVal = (int) (Math.round(((newVal * 9.0 / 5.0) + 32.0) + halfStep - 0.5));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1e730ba701dc9c2bb5504f9fbbc0d2176c23490"}, "originalPosition": 706}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4ODc4MA==", "bodyText": "Any reason this wouldn't work?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    HashMap<String, Integer> parameters = new HashMap<>();\n          \n          \n            \n                    parameters.put(\"SwingLfRig\", value);\n          \n          \n            \n                    executeCommand(clientSocket, parameters);\n          \n          \n            \n                    executeCommand(clientSocket, Collections.singletonMap(\"SwingLfRig\", value));\n          \n      \n    \n    \n  \n\nI'd like other parts of the code to simplified similarly.", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436488780", "createdAt": "2020-06-08T06:52:57Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,713 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\n+ * device specific attributes as well a the functionality for the Air Conditioner\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+// @NonNullByDefault\n+public class GreeAirDevice {\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\n+    private boolean isBound = false;\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\n+    private int port = 0;\n+    private String encKey = \"\";\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\n+    private GreeBindResponse4GsonDTO bindResponseGson;\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\n+\n+    public boolean getIsBound() {\n+        return isBound;\n+    }\n+\n+    public void setIsBound(boolean isBound) {\n+        this.isBound = isBound;\n+    }\n+\n+    public InetAddress getAddress() {\n+        return ipAddress;\n+    }\n+\n+    public void setAddress(InetAddress address) {\n+        this.ipAddress = address;\n+    }\n+\n+    public int getPort() {\n+        return port;\n+    }\n+\n+    public void setPort(int port) {\n+        this.port = port;\n+    }\n+\n+    public String getKey() {\n+        return encKey;\n+    }\n+\n+    public String getId() {\n+        return mScanResponseGson.packJson.mac;\n+    }\n+\n+    public String getName() {\n+        return mScanResponseGson.packJson.name;\n+    }\n+\n+    public String getVendor() {\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\n+    }\n+\n+    public String getModel() {\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\n+    }\n+\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\n+        return mScanResponseGson;\n+    }\n+\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\n+        mScanResponseGson = gson;\n+    }\n+\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\n+        return bindResponseGson;\n+    }\n+\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\n+        return statusResponseGson;\n+    }\n+\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\n+        validateSocket(socket);\n+        byte[] sendData = new byte[1024];\n+        byte[] receiveData = new byte[347];\n+        Gson gson = new Gson();\n+\n+        try {\n+            // Prep the Binding Request pack\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\n+            bindReqPackGson.mac = getId();\n+            bindReqPackGson.t = \"bind\";\n+            bindReqPackGson.uid = 0;\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\n+\n+            // Now Encrypt the Binding Request pack\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\n+                    bindReqPackStr);\n+\n+            // Prep the Binding Request\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\n+            bindReqGson.cid = \"app\";\n+            bindReqGson.i = 1;\n+            bindReqGson.t = \"pack\";\n+            bindReqGson.uid = 0;\n+            bindReqGson.tcid = getId();\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\n+            String bindReqStr = gson.toJson(bindReqGson);\n+            sendData = bindReqStr.getBytes();\n+\n+            // Now Send the request\n+            DatagramSocket clientSocket = socket.get();\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\n+            clientSocket.send(sendPacket);\n+\n+            // Recieve a response\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+            clientSocket.receive(receivePacket);\n+            String modifiedSentence = new String(receivePacket.getData(), \"UTF-8\");\n+\n+            // Read the response\n+            StringReader stringReader = new StringReader(modifiedSentence);\n+            bindResponseGson = gson.fromJson(new JsonReader(stringReader), GreeBindResponse4GsonDTO.class);\n+            bindResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\n+                    bindResponseGson.pack);\n+\n+            // Create the JSON to hold the response values\n+            stringReader = new StringReader(bindResponseGson.decryptedPack);\n+            bindResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePack4GsonDTO.class);\n+\n+            // Now set the key and flag to indicate the bind was succesful\n+            encKey = bindResponseGson.packJson.key;\n+            setIsBound(true);\n+        } catch (IOException e) {\n+            throw new GreeException(e, \"failed\");\n+        }\n+    }\n+\n+    private void validateSocket(Optional<DatagramSocket> socket) {\n+        if (!socket.isPresent()) {\n+            throw new IllegalArgumentException(\"Socket not initialized!\");\n+        }\n+    }\n+\n+    public void setDevicePower(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 1)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Pow\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void SetDeviceMode(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 4)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Mod\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceSwingUpDown(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\n+        if (!getIsBound() || (value < 0 || value > 11) || (value > 6 && value < 10)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"SwUpDn\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceSwingLeftRight(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        // Only values 0,1,2,3,4,5,6 allowed\n+        if (!getIsBound() || (value < 0) || (value > 6)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"SwingLfRig\", value);\n+        executeCommand(clientSocket, parameters);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1e730ba701dc9c2bb5504f9fbbc0d2176c23490"}, "originalPosition": 238}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ4OTkwMA==", "bodyText": "I think it would simplify code if you split this into two separate maps, one for celsius and another for fahrenheit.", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436489900", "createdAt": "2020-06-08T06:55:49Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,713 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\n+ * device specific attributes as well a the functionality for the Air Conditioner\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+// @NonNullByDefault\n+public class GreeAirDevice {\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1e730ba701dc9c2bb5504f9fbbc0d2176c23490"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ5MDMwOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    String columns[] = statusResponseGson.packJson.cols;\n          \n          \n            \n                    Integer values[] = statusResponseGson.packJson.dat;\n          \n          \n            \n                    String[] columns = statusResponseGson.packJson.cols;\n          \n          \n            \n                    Integer[] values = statusResponseGson.packJson.dat;", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436490308", "createdAt": "2020-06-08T06:56:51Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,713 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\n+ * device specific attributes as well a the functionality for the Air Conditioner\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+// @NonNullByDefault\n+public class GreeAirDevice {\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\n+    private boolean isBound = false;\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\n+    private int port = 0;\n+    private String encKey = \"\";\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\n+    private GreeBindResponse4GsonDTO bindResponseGson;\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\n+\n+    public boolean getIsBound() {\n+        return isBound;\n+    }\n+\n+    public void setIsBound(boolean isBound) {\n+        this.isBound = isBound;\n+    }\n+\n+    public InetAddress getAddress() {\n+        return ipAddress;\n+    }\n+\n+    public void setAddress(InetAddress address) {\n+        this.ipAddress = address;\n+    }\n+\n+    public int getPort() {\n+        return port;\n+    }\n+\n+    public void setPort(int port) {\n+        this.port = port;\n+    }\n+\n+    public String getKey() {\n+        return encKey;\n+    }\n+\n+    public String getId() {\n+        return mScanResponseGson.packJson.mac;\n+    }\n+\n+    public String getName() {\n+        return mScanResponseGson.packJson.name;\n+    }\n+\n+    public String getVendor() {\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\n+    }\n+\n+    public String getModel() {\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\n+    }\n+\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\n+        return mScanResponseGson;\n+    }\n+\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\n+        mScanResponseGson = gson;\n+    }\n+\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\n+        return bindResponseGson;\n+    }\n+\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\n+        return statusResponseGson;\n+    }\n+\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\n+        validateSocket(socket);\n+        byte[] sendData = new byte[1024];\n+        byte[] receiveData = new byte[347];\n+        Gson gson = new Gson();\n+\n+        try {\n+            // Prep the Binding Request pack\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\n+            bindReqPackGson.mac = getId();\n+            bindReqPackGson.t = \"bind\";\n+            bindReqPackGson.uid = 0;\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\n+\n+            // Now Encrypt the Binding Request pack\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\n+                    bindReqPackStr);\n+\n+            // Prep the Binding Request\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\n+            bindReqGson.cid = \"app\";\n+            bindReqGson.i = 1;\n+            bindReqGson.t = \"pack\";\n+            bindReqGson.uid = 0;\n+            bindReqGson.tcid = getId();\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\n+            String bindReqStr = gson.toJson(bindReqGson);\n+            sendData = bindReqStr.getBytes();\n+\n+            // Now Send the request\n+            DatagramSocket clientSocket = socket.get();\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\n+            clientSocket.send(sendPacket);\n+\n+            // Recieve a response\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+            clientSocket.receive(receivePacket);\n+            String modifiedSentence = new String(receivePacket.getData(), \"UTF-8\");\n+\n+            // Read the response\n+            StringReader stringReader = new StringReader(modifiedSentence);\n+            bindResponseGson = gson.fromJson(new JsonReader(stringReader), GreeBindResponse4GsonDTO.class);\n+            bindResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\n+                    bindResponseGson.pack);\n+\n+            // Create the JSON to hold the response values\n+            stringReader = new StringReader(bindResponseGson.decryptedPack);\n+            bindResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePack4GsonDTO.class);\n+\n+            // Now set the key and flag to indicate the bind was succesful\n+            encKey = bindResponseGson.packJson.key;\n+            setIsBound(true);\n+        } catch (IOException e) {\n+            throw new GreeException(e, \"failed\");\n+        }\n+    }\n+\n+    private void validateSocket(Optional<DatagramSocket> socket) {\n+        if (!socket.isPresent()) {\n+            throw new IllegalArgumentException(\"Socket not initialized!\");\n+        }\n+    }\n+\n+    public void setDevicePower(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 1)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Pow\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void SetDeviceMode(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 4)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Mod\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceSwingUpDown(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\n+        if (!getIsBound() || (value < 0 || value > 11) || (value > 6 && value < 10)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"SwUpDn\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceSwingLeftRight(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        // Only values 0,1,2,3,4,5,6 allowed\n+        if (!getIsBound() || (value < 0) || (value > 6)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"SwingLfRig\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    /**\n+     * Only allow this to happen if this device has been bound and values are valid\n+     * Possible values are :\n+     * 0 : Auto\n+     * 1 : Low\n+     * 2 : Medium Low\n+     * 3 : Medium\n+     * 4 : Medium High\n+     * 5 : High\n+     */\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, int value) throws GreeException {\n+        if (!getIsBound() || (value < 0 || value > 5)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"WdSpd\", value);\n+        parameters.put(\"Quiet\", 0);\n+        parameters.put(\"Tur\", 0);\n+        parameters.put(\"NoiseSet\", 0);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceTurbo(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 1)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Tur\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setQuietMode(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 2)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Quiet\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public int getDeviceTurbo() {\n+        return getIntStatusVal(\"Tur\");\n+    }\n+\n+    public void setDeviceLight(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 1)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Lig\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    /**\n+     * Create Hash Look Up for C and F\n+     * Temperature Ranges for gree A/C units (f_range = {86,61}, c_range={16,30}\n+     */\n+    private static HashMap<String, HashMap<String, Integer>> createTempRangeMap() {\n+        HashMap<String, HashMap<String, Integer>> tempRanges = new HashMap<>();\n+        HashMap<String, Integer> hmf = new HashMap<>();\n+        HashMap<String, Integer> hmc = new HashMap<>();\n+\n+        hmf.put(\"min\", 61); // F\n+        hmf.put(\"max\", 86);\n+        tempRanges.put(\"F\", hmf);\n+\n+        hmc.put(\"min\", 16); // C\n+        hmc.put(\"max\", 30);\n+        tempRanges.put(\"C\", hmc);\n+\n+        return tempRanges;\n+    }\n+\n+    /**\n+     * Checks input ranges for validity and TempUn for validity\n+     * Uses newVal as priority and tries to validate and determine intent\n+     * For example if value is 75 and TempUn says Celsius, change TempUn to Fahrenheit\n+     */\n+    private int[] validateTemperatureRangeForTempSet(int newValIn, @Nullable Integer CorFIn) {\n+        final String[] minMaxLUT = { \"max\", \"min\" }; // looks up 0 = C = max, 1 = F = min\n+        final String[] tempScaleLUT = { \"C\", \"F\" }; // Look Up Table used to convert TempUn integer 0,1 to \"C\" to \"F\"\n+                                                    // string for hashmap\n+        HashMap<String, Integer> nullCorFLUT = new HashMap<>(); // simple look up table for logic\n+        nullCorFLUT.put(\"C\", 0);\n+        nullCorFLUT.put(\"F\", 1);\n+        nullCorFLUT.put(\"INVALID\", 0);\n+\n+        String validRangeCorF; // stores if the input range is a valid C or F temperature\n+\n+        // force to global min/max\n+        int newVal = (Math.max(newValIn, Math.min(tempRanges.get(\"C\").get(\"min\"), tempRanges.get(\"F\").get(\"min\"))));\n+        newVal = Math.min(newVal, Math.max(tempRanges.get(\"C\").get(\"max\"), tempRanges.get(\"F\").get(\"max\")));\n+\n+        if ((newVal >= tempRanges.get(\"C\").get(\"min\")) && (newVal <= tempRanges.get(\"C\").get(\"max\"))) {\n+            validRangeCorF = \"C\";\n+        } else if ((newVal >= tempRanges.get(\"F\").get(\"min\")) && (newVal <= tempRanges.get(\"F\").get(\"max\"))) {\n+            validRangeCorF = \"F\";\n+        } else {\n+            logger.warn(\"Input Temp request {} is invalid\", newVal);\n+            validRangeCorF = \"INVALID\";\n+        }\n+\n+        // if CorF wasnt initialized or is null set it from lookup\n+        Integer CorF = CorFIn != null ? CorFIn : nullCorFLUT.get(validRangeCorF);\n+\n+        if ((CorF == 1) && validRangeCorF.equals(\"C\")) {\n+            CorF = 0; // input temp takes priority\n+        } else if ((CorF == 0) && validRangeCorF.equals(\"F\")) {\n+            CorF = 1; // input temp takes priority\n+        } else if (validRangeCorF.equals(\"INVALID\")) {\n+            // force min or max temp based on CorF scale to be used\n+            newVal = tempRanges.get(tempScaleLUT[CorF]).get(minMaxLUT[CorF]);\n+        }\n+\n+        return new int[] { newVal, CorF };\n+    }\n+\n+    public void setDeviceTempSet(DatagramSocket clientSocket, int value) throws GreeException {\n+        // **value** : set temperature in degrees celsius or Fahrenheit\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+        int newVal = value;\n+        int outVal = value;\n+        // Get Celsius or Fahrenheit from status message\n+        Integer CorF = getIntStatusVal(\"TemUn\");\n+        // TODO put a param in openhab to allow setting this from the config\n+\n+        // If commanding Fahrenheit set halfStep to 1 or 0 to tell the A/C which F integer\n+        // temperature to use as celsius alone is ambigious\n+        int halfStep = 0; // default to C\n+\n+        int[] retList = validateTemperatureRangeForTempSet(newVal, CorF);\n+        newVal = retList[0];\n+        CorF = retList[1];\n+\n+        if (CorF == 1) { // If Fahrenheit,\n+            // value argument is degrees F, convert Fahrenheit to Celsius,\n+            // SetTem input to A/C always in Celsius despite passing in 1 to TemUn\n+            outVal = (int) (Math.round((newVal - 32.) * 5.0 / 9.0)); // Integer Truncated\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\n+            // F = [68. , 69. , 70. , 71. , 72. , 73. , 74. , 75. , 76. , 77. , 78. , 79. , 80. , 81. , 82. , 83. ,\n+            // 84. , 85. , 86. ]\n+            // C = [20.0, 20.5, 21.1, 21.6, 22.2, 22.7, 23.3, 23.8, 24.4, 25.0, 25.5, 26.1, 26.6, 27.2, 27.7, 28.3,\n+            // 28.8, 29.4, 30.0]\n+            // TemSet = [20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 30, 30]\n+            // TemRec = [ 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\n+            // subtract the float version - the int version to get the fractional difference\n+            // if the difference is positive set halfStep to 1, negative to 0\n+            halfStep = ((((newVal - 32.) * 5.0 / 9.0) - outVal) > 0) ? 1 : 0;\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"TemUn\", CorF);\n+        parameters.put(\"SetTem\", outVal);\n+        parameters.put(\"TemRec\", halfStep);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceAir(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Air\", value);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceDry(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Blo\", value);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceHealth(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Health\", value);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDevicePwrSaving(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"SvSt\", value);\n+        parameters.put(\"WdSpd\", 0);\n+        parameters.put(\"Quiet\", 0);\n+        parameters.put(\"Tur\", 0);\n+        parameters.put(\"SwhSlp\", 0);\n+        parameters.put(\"SlpMod\", 0);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public int getIntStatusVal(String valueName) {\n+        /*\n+         * Note : Values can be:\n+         * \"Pow\": Power (0 or 1)\n+         * \"Mod\": Mode: Auto: 0, Cool: 1, Dry: 2, Fan: 3, Heat: 4\n+         * \"SetTem\": Requested Temperature\n+         * \"WdSpd\": Fan Speed : Low:1, Medium Low:2, Medium :3, Medium High :4, High :5\n+         * \"Air\": Air Mode Enabled\n+         * \"Blo\": Dry\n+         * \"Health\": Health\n+         * \"SwhSlp\": Sleep\n+         * \"SlpMod\": ???\n+         * \"Lig\": Light On\n+         * \"SwingLfRig\": Swing Left Right\n+         * \"SwUpDn\": Swing Up Down: // Ceiling:0, Upwards : 10, Downwards : 11, Full range : 1\n+         * \"Quiet\": Quiet mode\n+         * \"Tur\": Turbo\n+         * \"StHt\": 0,\n+         * \"TemUn\": Temperature unit, 0 for Celsius, 1 for Fahrenheit\n+         * \"HeatCoolType\"\n+         * \"TemRec\": (0 or 1), Send with SetTem, when TemUn==1, distinguishes between upper and lower integer Fahrenheit\n+         * temp\n+         * \"SvSt\": Power Saving\n+         */\n+        // Find the valueName in the Returned Status object\n+        String columns[] = statusResponseGson.packJson.cols;\n+        Integer values[] = statusResponseGson.packJson.dat;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1e730ba701dc9c2bb5504f9fbbc0d2176c23490"}, "originalPosition": 498}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ5MDU1Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    List<String> colList = new ArrayList<>(Arrays.asList(columns));\n          \n          \n            \n                    List<Integer> valList = new ArrayList<>(Arrays.asList(values));\n          \n          \n            \n                    List<String> colList = Arrays.asList(columns);\n          \n          \n            \n                    List<Integer> valList = Arrays.asList(values);", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436490556", "createdAt": "2020-06-08T06:57:29Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,713 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\n+ * device specific attributes as well a the functionality for the Air Conditioner\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+// @NonNullByDefault\n+public class GreeAirDevice {\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\n+    private boolean isBound = false;\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\n+    private int port = 0;\n+    private String encKey = \"\";\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\n+    private GreeBindResponse4GsonDTO bindResponseGson;\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\n+\n+    public boolean getIsBound() {\n+        return isBound;\n+    }\n+\n+    public void setIsBound(boolean isBound) {\n+        this.isBound = isBound;\n+    }\n+\n+    public InetAddress getAddress() {\n+        return ipAddress;\n+    }\n+\n+    public void setAddress(InetAddress address) {\n+        this.ipAddress = address;\n+    }\n+\n+    public int getPort() {\n+        return port;\n+    }\n+\n+    public void setPort(int port) {\n+        this.port = port;\n+    }\n+\n+    public String getKey() {\n+        return encKey;\n+    }\n+\n+    public String getId() {\n+        return mScanResponseGson.packJson.mac;\n+    }\n+\n+    public String getName() {\n+        return mScanResponseGson.packJson.name;\n+    }\n+\n+    public String getVendor() {\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\n+    }\n+\n+    public String getModel() {\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\n+    }\n+\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\n+        return mScanResponseGson;\n+    }\n+\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\n+        mScanResponseGson = gson;\n+    }\n+\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\n+        return bindResponseGson;\n+    }\n+\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\n+        return statusResponseGson;\n+    }\n+\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\n+        validateSocket(socket);\n+        byte[] sendData = new byte[1024];\n+        byte[] receiveData = new byte[347];\n+        Gson gson = new Gson();\n+\n+        try {\n+            // Prep the Binding Request pack\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\n+            bindReqPackGson.mac = getId();\n+            bindReqPackGson.t = \"bind\";\n+            bindReqPackGson.uid = 0;\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\n+\n+            // Now Encrypt the Binding Request pack\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\n+                    bindReqPackStr);\n+\n+            // Prep the Binding Request\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\n+            bindReqGson.cid = \"app\";\n+            bindReqGson.i = 1;\n+            bindReqGson.t = \"pack\";\n+            bindReqGson.uid = 0;\n+            bindReqGson.tcid = getId();\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\n+            String bindReqStr = gson.toJson(bindReqGson);\n+            sendData = bindReqStr.getBytes();\n+\n+            // Now Send the request\n+            DatagramSocket clientSocket = socket.get();\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\n+            clientSocket.send(sendPacket);\n+\n+            // Recieve a response\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+            clientSocket.receive(receivePacket);\n+            String modifiedSentence = new String(receivePacket.getData(), \"UTF-8\");\n+\n+            // Read the response\n+            StringReader stringReader = new StringReader(modifiedSentence);\n+            bindResponseGson = gson.fromJson(new JsonReader(stringReader), GreeBindResponse4GsonDTO.class);\n+            bindResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\n+                    bindResponseGson.pack);\n+\n+            // Create the JSON to hold the response values\n+            stringReader = new StringReader(bindResponseGson.decryptedPack);\n+            bindResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePack4GsonDTO.class);\n+\n+            // Now set the key and flag to indicate the bind was succesful\n+            encKey = bindResponseGson.packJson.key;\n+            setIsBound(true);\n+        } catch (IOException e) {\n+            throw new GreeException(e, \"failed\");\n+        }\n+    }\n+\n+    private void validateSocket(Optional<DatagramSocket> socket) {\n+        if (!socket.isPresent()) {\n+            throw new IllegalArgumentException(\"Socket not initialized!\");\n+        }\n+    }\n+\n+    public void setDevicePower(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 1)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Pow\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void SetDeviceMode(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 4)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Mod\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceSwingUpDown(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\n+        if (!getIsBound() || (value < 0 || value > 11) || (value > 6 && value < 10)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"SwUpDn\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceSwingLeftRight(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        // Only values 0,1,2,3,4,5,6 allowed\n+        if (!getIsBound() || (value < 0) || (value > 6)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"SwingLfRig\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    /**\n+     * Only allow this to happen if this device has been bound and values are valid\n+     * Possible values are :\n+     * 0 : Auto\n+     * 1 : Low\n+     * 2 : Medium Low\n+     * 3 : Medium\n+     * 4 : Medium High\n+     * 5 : High\n+     */\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, int value) throws GreeException {\n+        if (!getIsBound() || (value < 0 || value > 5)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"WdSpd\", value);\n+        parameters.put(\"Quiet\", 0);\n+        parameters.put(\"Tur\", 0);\n+        parameters.put(\"NoiseSet\", 0);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceTurbo(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 1)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Tur\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setQuietMode(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 2)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Quiet\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public int getDeviceTurbo() {\n+        return getIntStatusVal(\"Tur\");\n+    }\n+\n+    public void setDeviceLight(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 1)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Lig\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    /**\n+     * Create Hash Look Up for C and F\n+     * Temperature Ranges for gree A/C units (f_range = {86,61}, c_range={16,30}\n+     */\n+    private static HashMap<String, HashMap<String, Integer>> createTempRangeMap() {\n+        HashMap<String, HashMap<String, Integer>> tempRanges = new HashMap<>();\n+        HashMap<String, Integer> hmf = new HashMap<>();\n+        HashMap<String, Integer> hmc = new HashMap<>();\n+\n+        hmf.put(\"min\", 61); // F\n+        hmf.put(\"max\", 86);\n+        tempRanges.put(\"F\", hmf);\n+\n+        hmc.put(\"min\", 16); // C\n+        hmc.put(\"max\", 30);\n+        tempRanges.put(\"C\", hmc);\n+\n+        return tempRanges;\n+    }\n+\n+    /**\n+     * Checks input ranges for validity and TempUn for validity\n+     * Uses newVal as priority and tries to validate and determine intent\n+     * For example if value is 75 and TempUn says Celsius, change TempUn to Fahrenheit\n+     */\n+    private int[] validateTemperatureRangeForTempSet(int newValIn, @Nullable Integer CorFIn) {\n+        final String[] minMaxLUT = { \"max\", \"min\" }; // looks up 0 = C = max, 1 = F = min\n+        final String[] tempScaleLUT = { \"C\", \"F\" }; // Look Up Table used to convert TempUn integer 0,1 to \"C\" to \"F\"\n+                                                    // string for hashmap\n+        HashMap<String, Integer> nullCorFLUT = new HashMap<>(); // simple look up table for logic\n+        nullCorFLUT.put(\"C\", 0);\n+        nullCorFLUT.put(\"F\", 1);\n+        nullCorFLUT.put(\"INVALID\", 0);\n+\n+        String validRangeCorF; // stores if the input range is a valid C or F temperature\n+\n+        // force to global min/max\n+        int newVal = (Math.max(newValIn, Math.min(tempRanges.get(\"C\").get(\"min\"), tempRanges.get(\"F\").get(\"min\"))));\n+        newVal = Math.min(newVal, Math.max(tempRanges.get(\"C\").get(\"max\"), tempRanges.get(\"F\").get(\"max\")));\n+\n+        if ((newVal >= tempRanges.get(\"C\").get(\"min\")) && (newVal <= tempRanges.get(\"C\").get(\"max\"))) {\n+            validRangeCorF = \"C\";\n+        } else if ((newVal >= tempRanges.get(\"F\").get(\"min\")) && (newVal <= tempRanges.get(\"F\").get(\"max\"))) {\n+            validRangeCorF = \"F\";\n+        } else {\n+            logger.warn(\"Input Temp request {} is invalid\", newVal);\n+            validRangeCorF = \"INVALID\";\n+        }\n+\n+        // if CorF wasnt initialized or is null set it from lookup\n+        Integer CorF = CorFIn != null ? CorFIn : nullCorFLUT.get(validRangeCorF);\n+\n+        if ((CorF == 1) && validRangeCorF.equals(\"C\")) {\n+            CorF = 0; // input temp takes priority\n+        } else if ((CorF == 0) && validRangeCorF.equals(\"F\")) {\n+            CorF = 1; // input temp takes priority\n+        } else if (validRangeCorF.equals(\"INVALID\")) {\n+            // force min or max temp based on CorF scale to be used\n+            newVal = tempRanges.get(tempScaleLUT[CorF]).get(minMaxLUT[CorF]);\n+        }\n+\n+        return new int[] { newVal, CorF };\n+    }\n+\n+    public void setDeviceTempSet(DatagramSocket clientSocket, int value) throws GreeException {\n+        // **value** : set temperature in degrees celsius or Fahrenheit\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+        int newVal = value;\n+        int outVal = value;\n+        // Get Celsius or Fahrenheit from status message\n+        Integer CorF = getIntStatusVal(\"TemUn\");\n+        // TODO put a param in openhab to allow setting this from the config\n+\n+        // If commanding Fahrenheit set halfStep to 1 or 0 to tell the A/C which F integer\n+        // temperature to use as celsius alone is ambigious\n+        int halfStep = 0; // default to C\n+\n+        int[] retList = validateTemperatureRangeForTempSet(newVal, CorF);\n+        newVal = retList[0];\n+        CorF = retList[1];\n+\n+        if (CorF == 1) { // If Fahrenheit,\n+            // value argument is degrees F, convert Fahrenheit to Celsius,\n+            // SetTem input to A/C always in Celsius despite passing in 1 to TemUn\n+            outVal = (int) (Math.round((newVal - 32.) * 5.0 / 9.0)); // Integer Truncated\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\n+            // F = [68. , 69. , 70. , 71. , 72. , 73. , 74. , 75. , 76. , 77. , 78. , 79. , 80. , 81. , 82. , 83. ,\n+            // 84. , 85. , 86. ]\n+            // C = [20.0, 20.5, 21.1, 21.6, 22.2, 22.7, 23.3, 23.8, 24.4, 25.0, 25.5, 26.1, 26.6, 27.2, 27.7, 28.3,\n+            // 28.8, 29.4, 30.0]\n+            // TemSet = [20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 30, 30]\n+            // TemRec = [ 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\n+            // subtract the float version - the int version to get the fractional difference\n+            // if the difference is positive set halfStep to 1, negative to 0\n+            halfStep = ((((newVal - 32.) * 5.0 / 9.0) - outVal) > 0) ? 1 : 0;\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"TemUn\", CorF);\n+        parameters.put(\"SetTem\", outVal);\n+        parameters.put(\"TemRec\", halfStep);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceAir(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Air\", value);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceDry(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Blo\", value);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceHealth(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Health\", value);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDevicePwrSaving(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"SvSt\", value);\n+        parameters.put(\"WdSpd\", 0);\n+        parameters.put(\"Quiet\", 0);\n+        parameters.put(\"Tur\", 0);\n+        parameters.put(\"SwhSlp\", 0);\n+        parameters.put(\"SlpMod\", 0);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public int getIntStatusVal(String valueName) {\n+        /*\n+         * Note : Values can be:\n+         * \"Pow\": Power (0 or 1)\n+         * \"Mod\": Mode: Auto: 0, Cool: 1, Dry: 2, Fan: 3, Heat: 4\n+         * \"SetTem\": Requested Temperature\n+         * \"WdSpd\": Fan Speed : Low:1, Medium Low:2, Medium :3, Medium High :4, High :5\n+         * \"Air\": Air Mode Enabled\n+         * \"Blo\": Dry\n+         * \"Health\": Health\n+         * \"SwhSlp\": Sleep\n+         * \"SlpMod\": ???\n+         * \"Lig\": Light On\n+         * \"SwingLfRig\": Swing Left Right\n+         * \"SwUpDn\": Swing Up Down: // Ceiling:0, Upwards : 10, Downwards : 11, Full range : 1\n+         * \"Quiet\": Quiet mode\n+         * \"Tur\": Turbo\n+         * \"StHt\": 0,\n+         * \"TemUn\": Temperature unit, 0 for Celsius, 1 for Fahrenheit\n+         * \"HeatCoolType\"\n+         * \"TemRec\": (0 or 1), Send with SetTem, when TemUn==1, distinguishes between upper and lower integer Fahrenheit\n+         * temp\n+         * \"SvSt\": Power Saving\n+         */\n+        // Find the valueName in the Returned Status object\n+        String columns[] = statusResponseGson.packJson.cols;\n+        Integer values[] = statusResponseGson.packJson.dat;\n+        List<String> colList = new ArrayList<>(Arrays.asList(columns));\n+        List<Integer> valList = new ArrayList<>(Arrays.asList(values));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1e730ba701dc9c2bb5504f9fbbc0d2176c23490"}, "originalPosition": 500}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ5MTEyOA==", "bodyText": "You should make these strings constants since they are used in multiple places in the code.", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436491128", "createdAt": "2020-06-08T06:58:45Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,713 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\n+ * device specific attributes as well a the functionality for the Air Conditioner\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+// @NonNullByDefault\n+public class GreeAirDevice {\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\n+    private boolean isBound = false;\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\n+    private int port = 0;\n+    private String encKey = \"\";\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\n+    private GreeBindResponse4GsonDTO bindResponseGson;\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\n+\n+    public boolean getIsBound() {\n+        return isBound;\n+    }\n+\n+    public void setIsBound(boolean isBound) {\n+        this.isBound = isBound;\n+    }\n+\n+    public InetAddress getAddress() {\n+        return ipAddress;\n+    }\n+\n+    public void setAddress(InetAddress address) {\n+        this.ipAddress = address;\n+    }\n+\n+    public int getPort() {\n+        return port;\n+    }\n+\n+    public void setPort(int port) {\n+        this.port = port;\n+    }\n+\n+    public String getKey() {\n+        return encKey;\n+    }\n+\n+    public String getId() {\n+        return mScanResponseGson.packJson.mac;\n+    }\n+\n+    public String getName() {\n+        return mScanResponseGson.packJson.name;\n+    }\n+\n+    public String getVendor() {\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\n+    }\n+\n+    public String getModel() {\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\n+    }\n+\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\n+        return mScanResponseGson;\n+    }\n+\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\n+        mScanResponseGson = gson;\n+    }\n+\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\n+        return bindResponseGson;\n+    }\n+\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\n+        return statusResponseGson;\n+    }\n+\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\n+        validateSocket(socket);\n+        byte[] sendData = new byte[1024];\n+        byte[] receiveData = new byte[347];\n+        Gson gson = new Gson();\n+\n+        try {\n+            // Prep the Binding Request pack\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\n+            bindReqPackGson.mac = getId();\n+            bindReqPackGson.t = \"bind\";\n+            bindReqPackGson.uid = 0;\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\n+\n+            // Now Encrypt the Binding Request pack\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\n+                    bindReqPackStr);\n+\n+            // Prep the Binding Request\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\n+            bindReqGson.cid = \"app\";\n+            bindReqGson.i = 1;\n+            bindReqGson.t = \"pack\";\n+            bindReqGson.uid = 0;\n+            bindReqGson.tcid = getId();\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\n+            String bindReqStr = gson.toJson(bindReqGson);\n+            sendData = bindReqStr.getBytes();\n+\n+            // Now Send the request\n+            DatagramSocket clientSocket = socket.get();\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\n+            clientSocket.send(sendPacket);\n+\n+            // Recieve a response\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+            clientSocket.receive(receivePacket);\n+            String modifiedSentence = new String(receivePacket.getData(), \"UTF-8\");\n+\n+            // Read the response\n+            StringReader stringReader = new StringReader(modifiedSentence);\n+            bindResponseGson = gson.fromJson(new JsonReader(stringReader), GreeBindResponse4GsonDTO.class);\n+            bindResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\n+                    bindResponseGson.pack);\n+\n+            // Create the JSON to hold the response values\n+            stringReader = new StringReader(bindResponseGson.decryptedPack);\n+            bindResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePack4GsonDTO.class);\n+\n+            // Now set the key and flag to indicate the bind was succesful\n+            encKey = bindResponseGson.packJson.key;\n+            setIsBound(true);\n+        } catch (IOException e) {\n+            throw new GreeException(e, \"failed\");\n+        }\n+    }\n+\n+    private void validateSocket(Optional<DatagramSocket> socket) {\n+        if (!socket.isPresent()) {\n+            throw new IllegalArgumentException(\"Socket not initialized!\");\n+        }\n+    }\n+\n+    public void setDevicePower(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 1)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Pow\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void SetDeviceMode(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 4)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Mod\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceSwingUpDown(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\n+        if (!getIsBound() || (value < 0 || value > 11) || (value > 6 && value < 10)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"SwUpDn\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceSwingLeftRight(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        // Only values 0,1,2,3,4,5,6 allowed\n+        if (!getIsBound() || (value < 0) || (value > 6)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"SwingLfRig\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    /**\n+     * Only allow this to happen if this device has been bound and values are valid\n+     * Possible values are :\n+     * 0 : Auto\n+     * 1 : Low\n+     * 2 : Medium Low\n+     * 3 : Medium\n+     * 4 : Medium High\n+     * 5 : High\n+     */\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, int value) throws GreeException {\n+        if (!getIsBound() || (value < 0 || value > 5)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"WdSpd\", value);\n+        parameters.put(\"Quiet\", 0);\n+        parameters.put(\"Tur\", 0);\n+        parameters.put(\"NoiseSet\", 0);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceTurbo(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 1)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Tur\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setQuietMode(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 2)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Quiet\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public int getDeviceTurbo() {\n+        return getIntStatusVal(\"Tur\");\n+    }\n+\n+    public void setDeviceLight(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 1)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Lig\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    /**\n+     * Create Hash Look Up for C and F\n+     * Temperature Ranges for gree A/C units (f_range = {86,61}, c_range={16,30}\n+     */\n+    private static HashMap<String, HashMap<String, Integer>> createTempRangeMap() {\n+        HashMap<String, HashMap<String, Integer>> tempRanges = new HashMap<>();\n+        HashMap<String, Integer> hmf = new HashMap<>();\n+        HashMap<String, Integer> hmc = new HashMap<>();\n+\n+        hmf.put(\"min\", 61); // F\n+        hmf.put(\"max\", 86);\n+        tempRanges.put(\"F\", hmf);\n+\n+        hmc.put(\"min\", 16); // C\n+        hmc.put(\"max\", 30);\n+        tempRanges.put(\"C\", hmc);\n+\n+        return tempRanges;\n+    }\n+\n+    /**\n+     * Checks input ranges for validity and TempUn for validity\n+     * Uses newVal as priority and tries to validate and determine intent\n+     * For example if value is 75 and TempUn says Celsius, change TempUn to Fahrenheit\n+     */\n+    private int[] validateTemperatureRangeForTempSet(int newValIn, @Nullable Integer CorFIn) {\n+        final String[] minMaxLUT = { \"max\", \"min\" }; // looks up 0 = C = max, 1 = F = min\n+        final String[] tempScaleLUT = { \"C\", \"F\" }; // Look Up Table used to convert TempUn integer 0,1 to \"C\" to \"F\"\n+                                                    // string for hashmap\n+        HashMap<String, Integer> nullCorFLUT = new HashMap<>(); // simple look up table for logic\n+        nullCorFLUT.put(\"C\", 0);\n+        nullCorFLUT.put(\"F\", 1);\n+        nullCorFLUT.put(\"INVALID\", 0);\n+\n+        String validRangeCorF; // stores if the input range is a valid C or F temperature\n+\n+        // force to global min/max\n+        int newVal = (Math.max(newValIn, Math.min(tempRanges.get(\"C\").get(\"min\"), tempRanges.get(\"F\").get(\"min\"))));\n+        newVal = Math.min(newVal, Math.max(tempRanges.get(\"C\").get(\"max\"), tempRanges.get(\"F\").get(\"max\")));\n+\n+        if ((newVal >= tempRanges.get(\"C\").get(\"min\")) && (newVal <= tempRanges.get(\"C\").get(\"max\"))) {\n+            validRangeCorF = \"C\";\n+        } else if ((newVal >= tempRanges.get(\"F\").get(\"min\")) && (newVal <= tempRanges.get(\"F\").get(\"max\"))) {\n+            validRangeCorF = \"F\";\n+        } else {\n+            logger.warn(\"Input Temp request {} is invalid\", newVal);\n+            validRangeCorF = \"INVALID\";\n+        }\n+\n+        // if CorF wasnt initialized or is null set it from lookup\n+        Integer CorF = CorFIn != null ? CorFIn : nullCorFLUT.get(validRangeCorF);\n+\n+        if ((CorF == 1) && validRangeCorF.equals(\"C\")) {\n+            CorF = 0; // input temp takes priority\n+        } else if ((CorF == 0) && validRangeCorF.equals(\"F\")) {\n+            CorF = 1; // input temp takes priority\n+        } else if (validRangeCorF.equals(\"INVALID\")) {\n+            // force min or max temp based on CorF scale to be used\n+            newVal = tempRanges.get(tempScaleLUT[CorF]).get(minMaxLUT[CorF]);\n+        }\n+\n+        return new int[] { newVal, CorF };\n+    }\n+\n+    public void setDeviceTempSet(DatagramSocket clientSocket, int value) throws GreeException {\n+        // **value** : set temperature in degrees celsius or Fahrenheit\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+        int newVal = value;\n+        int outVal = value;\n+        // Get Celsius or Fahrenheit from status message\n+        Integer CorF = getIntStatusVal(\"TemUn\");\n+        // TODO put a param in openhab to allow setting this from the config\n+\n+        // If commanding Fahrenheit set halfStep to 1 or 0 to tell the A/C which F integer\n+        // temperature to use as celsius alone is ambigious\n+        int halfStep = 0; // default to C\n+\n+        int[] retList = validateTemperatureRangeForTempSet(newVal, CorF);\n+        newVal = retList[0];\n+        CorF = retList[1];\n+\n+        if (CorF == 1) { // If Fahrenheit,\n+            // value argument is degrees F, convert Fahrenheit to Celsius,\n+            // SetTem input to A/C always in Celsius despite passing in 1 to TemUn\n+            outVal = (int) (Math.round((newVal - 32.) * 5.0 / 9.0)); // Integer Truncated\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\n+            // F = [68. , 69. , 70. , 71. , 72. , 73. , 74. , 75. , 76. , 77. , 78. , 79. , 80. , 81. , 82. , 83. ,\n+            // 84. , 85. , 86. ]\n+            // C = [20.0, 20.5, 21.1, 21.6, 22.2, 22.7, 23.3, 23.8, 24.4, 25.0, 25.5, 26.1, 26.6, 27.2, 27.7, 28.3,\n+            // 28.8, 29.4, 30.0]\n+            // TemSet = [20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 30, 30]\n+            // TemRec = [ 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\n+            // subtract the float version - the int version to get the fractional difference\n+            // if the difference is positive set halfStep to 1, negative to 0\n+            halfStep = ((((newVal - 32.) * 5.0 / 9.0) - outVal) > 0) ? 1 : 0;\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"TemUn\", CorF);\n+        parameters.put(\"SetTem\", outVal);\n+        parameters.put(\"TemRec\", halfStep);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceAir(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Air\", value);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceDry(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Blo\", value);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceHealth(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Health\", value);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDevicePwrSaving(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"SvSt\", value);\n+        parameters.put(\"WdSpd\", 0);\n+        parameters.put(\"Quiet\", 0);\n+        parameters.put(\"Tur\", 0);\n+        parameters.put(\"SwhSlp\", 0);\n+        parameters.put(\"SlpMod\", 0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1e730ba701dc9c2bb5504f9fbbc0d2176c23490"}, "originalPosition": 467}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ5MTIzNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        String modifiedSentence = new String(receivePacket.getData(), \"UTF-8\");\n          \n          \n            \n                        String modifiedSentence = new String(receivePacket.getData(), UTF8_CHARSET);", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436491237", "createdAt": "2020-06-08T06:59:02Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,713 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\n+ * device specific attributes as well a the functionality for the Air Conditioner\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+// @NonNullByDefault\n+public class GreeAirDevice {\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\n+    private boolean isBound = false;\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\n+    private int port = 0;\n+    private String encKey = \"\";\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\n+    private GreeBindResponse4GsonDTO bindResponseGson;\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\n+\n+    public boolean getIsBound() {\n+        return isBound;\n+    }\n+\n+    public void setIsBound(boolean isBound) {\n+        this.isBound = isBound;\n+    }\n+\n+    public InetAddress getAddress() {\n+        return ipAddress;\n+    }\n+\n+    public void setAddress(InetAddress address) {\n+        this.ipAddress = address;\n+    }\n+\n+    public int getPort() {\n+        return port;\n+    }\n+\n+    public void setPort(int port) {\n+        this.port = port;\n+    }\n+\n+    public String getKey() {\n+        return encKey;\n+    }\n+\n+    public String getId() {\n+        return mScanResponseGson.packJson.mac;\n+    }\n+\n+    public String getName() {\n+        return mScanResponseGson.packJson.name;\n+    }\n+\n+    public String getVendor() {\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\n+    }\n+\n+    public String getModel() {\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\n+    }\n+\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\n+        return mScanResponseGson;\n+    }\n+\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\n+        mScanResponseGson = gson;\n+    }\n+\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\n+        return bindResponseGson;\n+    }\n+\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\n+        return statusResponseGson;\n+    }\n+\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\n+        validateSocket(socket);\n+        byte[] sendData = new byte[1024];\n+        byte[] receiveData = new byte[347];\n+        Gson gson = new Gson();\n+\n+        try {\n+            // Prep the Binding Request pack\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\n+            bindReqPackGson.mac = getId();\n+            bindReqPackGson.t = \"bind\";\n+            bindReqPackGson.uid = 0;\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\n+\n+            // Now Encrypt the Binding Request pack\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\n+                    bindReqPackStr);\n+\n+            // Prep the Binding Request\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\n+            bindReqGson.cid = \"app\";\n+            bindReqGson.i = 1;\n+            bindReqGson.t = \"pack\";\n+            bindReqGson.uid = 0;\n+            bindReqGson.tcid = getId();\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\n+            String bindReqStr = gson.toJson(bindReqGson);\n+            sendData = bindReqStr.getBytes();\n+\n+            // Now Send the request\n+            DatagramSocket clientSocket = socket.get();\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\n+            clientSocket.send(sendPacket);\n+\n+            // Recieve a response\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+            clientSocket.receive(receivePacket);\n+            String modifiedSentence = new String(receivePacket.getData(), \"UTF-8\");\n+\n+            // Read the response\n+            StringReader stringReader = new StringReader(modifiedSentence);\n+            bindResponseGson = gson.fromJson(new JsonReader(stringReader), GreeBindResponse4GsonDTO.class);\n+            bindResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\n+                    bindResponseGson.pack);\n+\n+            // Create the JSON to hold the response values\n+            stringReader = new StringReader(bindResponseGson.decryptedPack);\n+            bindResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePack4GsonDTO.class);\n+\n+            // Now set the key and flag to indicate the bind was succesful\n+            encKey = bindResponseGson.packJson.key;\n+            setIsBound(true);\n+        } catch (IOException e) {\n+            throw new GreeException(e, \"failed\");\n+        }\n+    }\n+\n+    private void validateSocket(Optional<DatagramSocket> socket) {\n+        if (!socket.isPresent()) {\n+            throw new IllegalArgumentException(\"Socket not initialized!\");\n+        }\n+    }\n+\n+    public void setDevicePower(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 1)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Pow\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void SetDeviceMode(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 4)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Mod\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceSwingUpDown(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\n+        if (!getIsBound() || (value < 0 || value > 11) || (value > 6 && value < 10)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"SwUpDn\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceSwingLeftRight(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        // Only values 0,1,2,3,4,5,6 allowed\n+        if (!getIsBound() || (value < 0) || (value > 6)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"SwingLfRig\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    /**\n+     * Only allow this to happen if this device has been bound and values are valid\n+     * Possible values are :\n+     * 0 : Auto\n+     * 1 : Low\n+     * 2 : Medium Low\n+     * 3 : Medium\n+     * 4 : Medium High\n+     * 5 : High\n+     */\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, int value) throws GreeException {\n+        if (!getIsBound() || (value < 0 || value > 5)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"WdSpd\", value);\n+        parameters.put(\"Quiet\", 0);\n+        parameters.put(\"Tur\", 0);\n+        parameters.put(\"NoiseSet\", 0);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceTurbo(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 1)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Tur\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setQuietMode(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 2)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Quiet\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public int getDeviceTurbo() {\n+        return getIntStatusVal(\"Tur\");\n+    }\n+\n+    public void setDeviceLight(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 1)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Lig\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    /**\n+     * Create Hash Look Up for C and F\n+     * Temperature Ranges for gree A/C units (f_range = {86,61}, c_range={16,30}\n+     */\n+    private static HashMap<String, HashMap<String, Integer>> createTempRangeMap() {\n+        HashMap<String, HashMap<String, Integer>> tempRanges = new HashMap<>();\n+        HashMap<String, Integer> hmf = new HashMap<>();\n+        HashMap<String, Integer> hmc = new HashMap<>();\n+\n+        hmf.put(\"min\", 61); // F\n+        hmf.put(\"max\", 86);\n+        tempRanges.put(\"F\", hmf);\n+\n+        hmc.put(\"min\", 16); // C\n+        hmc.put(\"max\", 30);\n+        tempRanges.put(\"C\", hmc);\n+\n+        return tempRanges;\n+    }\n+\n+    /**\n+     * Checks input ranges for validity and TempUn for validity\n+     * Uses newVal as priority and tries to validate and determine intent\n+     * For example if value is 75 and TempUn says Celsius, change TempUn to Fahrenheit\n+     */\n+    private int[] validateTemperatureRangeForTempSet(int newValIn, @Nullable Integer CorFIn) {\n+        final String[] minMaxLUT = { \"max\", \"min\" }; // looks up 0 = C = max, 1 = F = min\n+        final String[] tempScaleLUT = { \"C\", \"F\" }; // Look Up Table used to convert TempUn integer 0,1 to \"C\" to \"F\"\n+                                                    // string for hashmap\n+        HashMap<String, Integer> nullCorFLUT = new HashMap<>(); // simple look up table for logic\n+        nullCorFLUT.put(\"C\", 0);\n+        nullCorFLUT.put(\"F\", 1);\n+        nullCorFLUT.put(\"INVALID\", 0);\n+\n+        String validRangeCorF; // stores if the input range is a valid C or F temperature\n+\n+        // force to global min/max\n+        int newVal = (Math.max(newValIn, Math.min(tempRanges.get(\"C\").get(\"min\"), tempRanges.get(\"F\").get(\"min\"))));\n+        newVal = Math.min(newVal, Math.max(tempRanges.get(\"C\").get(\"max\"), tempRanges.get(\"F\").get(\"max\")));\n+\n+        if ((newVal >= tempRanges.get(\"C\").get(\"min\")) && (newVal <= tempRanges.get(\"C\").get(\"max\"))) {\n+            validRangeCorF = \"C\";\n+        } else if ((newVal >= tempRanges.get(\"F\").get(\"min\")) && (newVal <= tempRanges.get(\"F\").get(\"max\"))) {\n+            validRangeCorF = \"F\";\n+        } else {\n+            logger.warn(\"Input Temp request {} is invalid\", newVal);\n+            validRangeCorF = \"INVALID\";\n+        }\n+\n+        // if CorF wasnt initialized or is null set it from lookup\n+        Integer CorF = CorFIn != null ? CorFIn : nullCorFLUT.get(validRangeCorF);\n+\n+        if ((CorF == 1) && validRangeCorF.equals(\"C\")) {\n+            CorF = 0; // input temp takes priority\n+        } else if ((CorF == 0) && validRangeCorF.equals(\"F\")) {\n+            CorF = 1; // input temp takes priority\n+        } else if (validRangeCorF.equals(\"INVALID\")) {\n+            // force min or max temp based on CorF scale to be used\n+            newVal = tempRanges.get(tempScaleLUT[CorF]).get(minMaxLUT[CorF]);\n+        }\n+\n+        return new int[] { newVal, CorF };\n+    }\n+\n+    public void setDeviceTempSet(DatagramSocket clientSocket, int value) throws GreeException {\n+        // **value** : set temperature in degrees celsius or Fahrenheit\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+        int newVal = value;\n+        int outVal = value;\n+        // Get Celsius or Fahrenheit from status message\n+        Integer CorF = getIntStatusVal(\"TemUn\");\n+        // TODO put a param in openhab to allow setting this from the config\n+\n+        // If commanding Fahrenheit set halfStep to 1 or 0 to tell the A/C which F integer\n+        // temperature to use as celsius alone is ambigious\n+        int halfStep = 0; // default to C\n+\n+        int[] retList = validateTemperatureRangeForTempSet(newVal, CorF);\n+        newVal = retList[0];\n+        CorF = retList[1];\n+\n+        if (CorF == 1) { // If Fahrenheit,\n+            // value argument is degrees F, convert Fahrenheit to Celsius,\n+            // SetTem input to A/C always in Celsius despite passing in 1 to TemUn\n+            outVal = (int) (Math.round((newVal - 32.) * 5.0 / 9.0)); // Integer Truncated\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\n+            // F = [68. , 69. , 70. , 71. , 72. , 73. , 74. , 75. , 76. , 77. , 78. , 79. , 80. , 81. , 82. , 83. ,\n+            // 84. , 85. , 86. ]\n+            // C = [20.0, 20.5, 21.1, 21.6, 22.2, 22.7, 23.3, 23.8, 24.4, 25.0, 25.5, 26.1, 26.6, 27.2, 27.7, 28.3,\n+            // 28.8, 29.4, 30.0]\n+            // TemSet = [20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 30, 30]\n+            // TemRec = [ 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\n+            // subtract the float version - the int version to get the fractional difference\n+            // if the difference is positive set halfStep to 1, negative to 0\n+            halfStep = ((((newVal - 32.) * 5.0 / 9.0) - outVal) > 0) ? 1 : 0;\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"TemUn\", CorF);\n+        parameters.put(\"SetTem\", outVal);\n+        parameters.put(\"TemRec\", halfStep);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceAir(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Air\", value);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceDry(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Blo\", value);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceHealth(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Health\", value);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDevicePwrSaving(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"SvSt\", value);\n+        parameters.put(\"WdSpd\", 0);\n+        parameters.put(\"Quiet\", 0);\n+        parameters.put(\"Tur\", 0);\n+        parameters.put(\"SwhSlp\", 0);\n+        parameters.put(\"SlpMod\", 0);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public int getIntStatusVal(String valueName) {\n+        /*\n+         * Note : Values can be:\n+         * \"Pow\": Power (0 or 1)\n+         * \"Mod\": Mode: Auto: 0, Cool: 1, Dry: 2, Fan: 3, Heat: 4\n+         * \"SetTem\": Requested Temperature\n+         * \"WdSpd\": Fan Speed : Low:1, Medium Low:2, Medium :3, Medium High :4, High :5\n+         * \"Air\": Air Mode Enabled\n+         * \"Blo\": Dry\n+         * \"Health\": Health\n+         * \"SwhSlp\": Sleep\n+         * \"SlpMod\": ???\n+         * \"Lig\": Light On\n+         * \"SwingLfRig\": Swing Left Right\n+         * \"SwUpDn\": Swing Up Down: // Ceiling:0, Upwards : 10, Downwards : 11, Full range : 1\n+         * \"Quiet\": Quiet mode\n+         * \"Tur\": Turbo\n+         * \"StHt\": 0,\n+         * \"TemUn\": Temperature unit, 0 for Celsius, 1 for Fahrenheit\n+         * \"HeatCoolType\"\n+         * \"TemRec\": (0 or 1), Send with SetTem, when TemUn==1, distinguishes between upper and lower integer Fahrenheit\n+         * temp\n+         * \"SvSt\": Power Saving\n+         */\n+        // Find the valueName in the Returned Status object\n+        String columns[] = statusResponseGson.packJson.cols;\n+        Integer values[] = statusResponseGson.packJson.dat;\n+        List<String> colList = new ArrayList<>(Arrays.asList(columns));\n+        List<Integer> valList = new ArrayList<>(Arrays.asList(values));\n+        int valueArrayposition = colList.indexOf(valueName);\n+        if (valueArrayposition == -1) {\n+            return -1;\n+        }\n+\n+        // Now get the Corresponding value\n+        Integer value = valList.get(valueArrayposition);\n+        return value;\n+    }\n+\n+    public boolean hasStatusValChanged(String valueName) throws GreeException {\n+        if (prevStatusResponsePackGson == null) {\n+            return true; // update value if there is no previous one\n+        }\n+        // Find the valueName in the Current Status object\n+        String currcolumns[] = statusResponseGson.packJson.cols;\n+        Integer currvalues[] = statusResponseGson.packJson.dat;\n+        List<String> currcolList = new ArrayList<>(Arrays.asList(currcolumns));\n+        List<Integer> currvalList = new ArrayList<>(Arrays.asList(currvalues));\n+        int currvalueArrayposition = currcolList.indexOf(valueName);\n+        if (currvalueArrayposition == -1) {\n+            throw new GreeException(\"Unable to decode device status\");\n+        }\n+        // Now get the Corresponding value\n+        int currvalue = currvalList.get(currvalueArrayposition);\n+\n+        // Find the valueName in the Previous Status object\n+        String prevcolumns[] = prevStatusResponsePackGson.cols;\n+        Integer prevvalues[] = prevStatusResponsePackGson.dat;\n+        List<String> prevcolList = new ArrayList<>(Arrays.asList(prevcolumns));\n+        List<Integer> prevvalList = new ArrayList<>(Arrays.asList(prevvalues));\n+        int prevvalueArrayposition = prevcolList.indexOf(valueName);\n+        if (prevvalueArrayposition == -1) {\n+            throw new GreeException(\"Unable to get status value\");\n+        }\n+        // Now get the Corresponding value\n+        int prevvalue = prevvalList.get(prevvalueArrayposition);\n+\n+        // Finally Compare the values\n+        return currvalue != prevvalue;\n+    }\n+\n+    protected void executeCommand(DatagramSocket clientSocket, HashMap<String, Integer> parameters)\n+            throws GreeException {\n+        byte[] sendData = new byte[1024];\n+        byte[] receiveData = new byte[1024];\n+        Gson gson = new Gson();\n+\n+        try {\n+            // Convert the parameter map values to arrays\n+            String[] keyArray = parameters.keySet().toArray(new String[0]);\n+            Integer[] valueArray = parameters.values().toArray(new Integer[0]);\n+\n+            // Prep the Command Request pack\n+            GreeExecuteCommandPack4GsonDTO execCmdPackGson = new GreeExecuteCommandPack4GsonDTO();\n+            execCmdPackGson.opt = keyArray;\n+            execCmdPackGson.p = valueArray;\n+            execCmdPackGson.t = \"cmd\";\n+            String execCmdPackStr = gson.toJson(execCmdPackGson);\n+\n+            // Now Encrypt the Binding Request pack\n+            String encryptedCommandReqPacket = GreeCryptoUtil.encryptPack(getKey().getBytes(), execCmdPackStr);\n+            // String unencryptedCommandReqPacket = CryptoUtil.decryptPack(device.getKey().getBytes(),\n+            // encryptedCommandReqPacket);\n+\n+            // Prep the Command Request\n+            GreeExecCommand4GsonDTO execCmdGson = new GreeExecCommand4GsonDTO();\n+            execCmdGson.cid = \"app\";\n+            execCmdGson.i = 0;\n+            execCmdGson.t = \"pack\";\n+            execCmdGson.uid = 0;\n+            execCmdGson.tcid = getId();\n+            execCmdGson.pack = new String(encryptedCommandReqPacket.getBytes(), UTF8_CHARSET);\n+            String execCmdStr = gson.toJson(execCmdGson);\n+            sendData = execCmdStr.getBytes();\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\n+            clientSocket.send(sendPacket);\n+\n+            // Recieve a response\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+            clientSocket.receive(receivePacket);\n+            String modifiedSentence = new String(receivePacket.getData(), \"UTF-8\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1e730ba701dc9c2bb5504f9fbbc0d2176c23490"}, "originalPosition": 582}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ5MTMxOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        String modifiedSentence = new String(receivePacket.getData(), \"UTF-8\");\n          \n          \n            \n                        String modifiedSentence = new String(receivePacket.getData(), UTF8_CHARSET);", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436491318", "createdAt": "2020-06-08T06:59:15Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,713 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\n+ * device specific attributes as well a the functionality for the Air Conditioner\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+// @NonNullByDefault\n+public class GreeAirDevice {\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\n+    private boolean isBound = false;\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\n+    private int port = 0;\n+    private String encKey = \"\";\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\n+    private GreeBindResponse4GsonDTO bindResponseGson;\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\n+\n+    public boolean getIsBound() {\n+        return isBound;\n+    }\n+\n+    public void setIsBound(boolean isBound) {\n+        this.isBound = isBound;\n+    }\n+\n+    public InetAddress getAddress() {\n+        return ipAddress;\n+    }\n+\n+    public void setAddress(InetAddress address) {\n+        this.ipAddress = address;\n+    }\n+\n+    public int getPort() {\n+        return port;\n+    }\n+\n+    public void setPort(int port) {\n+        this.port = port;\n+    }\n+\n+    public String getKey() {\n+        return encKey;\n+    }\n+\n+    public String getId() {\n+        return mScanResponseGson.packJson.mac;\n+    }\n+\n+    public String getName() {\n+        return mScanResponseGson.packJson.name;\n+    }\n+\n+    public String getVendor() {\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\n+    }\n+\n+    public String getModel() {\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\n+    }\n+\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\n+        return mScanResponseGson;\n+    }\n+\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\n+        mScanResponseGson = gson;\n+    }\n+\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\n+        return bindResponseGson;\n+    }\n+\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\n+        return statusResponseGson;\n+    }\n+\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\n+        validateSocket(socket);\n+        byte[] sendData = new byte[1024];\n+        byte[] receiveData = new byte[347];\n+        Gson gson = new Gson();\n+\n+        try {\n+            // Prep the Binding Request pack\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\n+            bindReqPackGson.mac = getId();\n+            bindReqPackGson.t = \"bind\";\n+            bindReqPackGson.uid = 0;\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\n+\n+            // Now Encrypt the Binding Request pack\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\n+                    bindReqPackStr);\n+\n+            // Prep the Binding Request\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\n+            bindReqGson.cid = \"app\";\n+            bindReqGson.i = 1;\n+            bindReqGson.t = \"pack\";\n+            bindReqGson.uid = 0;\n+            bindReqGson.tcid = getId();\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\n+            String bindReqStr = gson.toJson(bindReqGson);\n+            sendData = bindReqStr.getBytes();\n+\n+            // Now Send the request\n+            DatagramSocket clientSocket = socket.get();\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\n+            clientSocket.send(sendPacket);\n+\n+            // Recieve a response\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+            clientSocket.receive(receivePacket);\n+            String modifiedSentence = new String(receivePacket.getData(), \"UTF-8\");\n+\n+            // Read the response\n+            StringReader stringReader = new StringReader(modifiedSentence);\n+            bindResponseGson = gson.fromJson(new JsonReader(stringReader), GreeBindResponse4GsonDTO.class);\n+            bindResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\n+                    bindResponseGson.pack);\n+\n+            // Create the JSON to hold the response values\n+            stringReader = new StringReader(bindResponseGson.decryptedPack);\n+            bindResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePack4GsonDTO.class);\n+\n+            // Now set the key and flag to indicate the bind was succesful\n+            encKey = bindResponseGson.packJson.key;\n+            setIsBound(true);\n+        } catch (IOException e) {\n+            throw new GreeException(e, \"failed\");\n+        }\n+    }\n+\n+    private void validateSocket(Optional<DatagramSocket> socket) {\n+        if (!socket.isPresent()) {\n+            throw new IllegalArgumentException(\"Socket not initialized!\");\n+        }\n+    }\n+\n+    public void setDevicePower(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 1)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Pow\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void SetDeviceMode(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 4)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Mod\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceSwingUpDown(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\n+        if (!getIsBound() || (value < 0 || value > 11) || (value > 6 && value < 10)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"SwUpDn\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceSwingLeftRight(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        // Only values 0,1,2,3,4,5,6 allowed\n+        if (!getIsBound() || (value < 0) || (value > 6)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"SwingLfRig\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    /**\n+     * Only allow this to happen if this device has been bound and values are valid\n+     * Possible values are :\n+     * 0 : Auto\n+     * 1 : Low\n+     * 2 : Medium Low\n+     * 3 : Medium\n+     * 4 : Medium High\n+     * 5 : High\n+     */\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, int value) throws GreeException {\n+        if (!getIsBound() || (value < 0 || value > 5)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"WdSpd\", value);\n+        parameters.put(\"Quiet\", 0);\n+        parameters.put(\"Tur\", 0);\n+        parameters.put(\"NoiseSet\", 0);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceTurbo(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 1)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Tur\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setQuietMode(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 2)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Quiet\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public int getDeviceTurbo() {\n+        return getIntStatusVal(\"Tur\");\n+    }\n+\n+    public void setDeviceLight(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 1)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Lig\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    /**\n+     * Create Hash Look Up for C and F\n+     * Temperature Ranges for gree A/C units (f_range = {86,61}, c_range={16,30}\n+     */\n+    private static HashMap<String, HashMap<String, Integer>> createTempRangeMap() {\n+        HashMap<String, HashMap<String, Integer>> tempRanges = new HashMap<>();\n+        HashMap<String, Integer> hmf = new HashMap<>();\n+        HashMap<String, Integer> hmc = new HashMap<>();\n+\n+        hmf.put(\"min\", 61); // F\n+        hmf.put(\"max\", 86);\n+        tempRanges.put(\"F\", hmf);\n+\n+        hmc.put(\"min\", 16); // C\n+        hmc.put(\"max\", 30);\n+        tempRanges.put(\"C\", hmc);\n+\n+        return tempRanges;\n+    }\n+\n+    /**\n+     * Checks input ranges for validity and TempUn for validity\n+     * Uses newVal as priority and tries to validate and determine intent\n+     * For example if value is 75 and TempUn says Celsius, change TempUn to Fahrenheit\n+     */\n+    private int[] validateTemperatureRangeForTempSet(int newValIn, @Nullable Integer CorFIn) {\n+        final String[] minMaxLUT = { \"max\", \"min\" }; // looks up 0 = C = max, 1 = F = min\n+        final String[] tempScaleLUT = { \"C\", \"F\" }; // Look Up Table used to convert TempUn integer 0,1 to \"C\" to \"F\"\n+                                                    // string for hashmap\n+        HashMap<String, Integer> nullCorFLUT = new HashMap<>(); // simple look up table for logic\n+        nullCorFLUT.put(\"C\", 0);\n+        nullCorFLUT.put(\"F\", 1);\n+        nullCorFLUT.put(\"INVALID\", 0);\n+\n+        String validRangeCorF; // stores if the input range is a valid C or F temperature\n+\n+        // force to global min/max\n+        int newVal = (Math.max(newValIn, Math.min(tempRanges.get(\"C\").get(\"min\"), tempRanges.get(\"F\").get(\"min\"))));\n+        newVal = Math.min(newVal, Math.max(tempRanges.get(\"C\").get(\"max\"), tempRanges.get(\"F\").get(\"max\")));\n+\n+        if ((newVal >= tempRanges.get(\"C\").get(\"min\")) && (newVal <= tempRanges.get(\"C\").get(\"max\"))) {\n+            validRangeCorF = \"C\";\n+        } else if ((newVal >= tempRanges.get(\"F\").get(\"min\")) && (newVal <= tempRanges.get(\"F\").get(\"max\"))) {\n+            validRangeCorF = \"F\";\n+        } else {\n+            logger.warn(\"Input Temp request {} is invalid\", newVal);\n+            validRangeCorF = \"INVALID\";\n+        }\n+\n+        // if CorF wasnt initialized or is null set it from lookup\n+        Integer CorF = CorFIn != null ? CorFIn : nullCorFLUT.get(validRangeCorF);\n+\n+        if ((CorF == 1) && validRangeCorF.equals(\"C\")) {\n+            CorF = 0; // input temp takes priority\n+        } else if ((CorF == 0) && validRangeCorF.equals(\"F\")) {\n+            CorF = 1; // input temp takes priority\n+        } else if (validRangeCorF.equals(\"INVALID\")) {\n+            // force min or max temp based on CorF scale to be used\n+            newVal = tempRanges.get(tempScaleLUT[CorF]).get(minMaxLUT[CorF]);\n+        }\n+\n+        return new int[] { newVal, CorF };\n+    }\n+\n+    public void setDeviceTempSet(DatagramSocket clientSocket, int value) throws GreeException {\n+        // **value** : set temperature in degrees celsius or Fahrenheit\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+        int newVal = value;\n+        int outVal = value;\n+        // Get Celsius or Fahrenheit from status message\n+        Integer CorF = getIntStatusVal(\"TemUn\");\n+        // TODO put a param in openhab to allow setting this from the config\n+\n+        // If commanding Fahrenheit set halfStep to 1 or 0 to tell the A/C which F integer\n+        // temperature to use as celsius alone is ambigious\n+        int halfStep = 0; // default to C\n+\n+        int[] retList = validateTemperatureRangeForTempSet(newVal, CorF);\n+        newVal = retList[0];\n+        CorF = retList[1];\n+\n+        if (CorF == 1) { // If Fahrenheit,\n+            // value argument is degrees F, convert Fahrenheit to Celsius,\n+            // SetTem input to A/C always in Celsius despite passing in 1 to TemUn\n+            outVal = (int) (Math.round((newVal - 32.) * 5.0 / 9.0)); // Integer Truncated\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\n+            // F = [68. , 69. , 70. , 71. , 72. , 73. , 74. , 75. , 76. , 77. , 78. , 79. , 80. , 81. , 82. , 83. ,\n+            // 84. , 85. , 86. ]\n+            // C = [20.0, 20.5, 21.1, 21.6, 22.2, 22.7, 23.3, 23.8, 24.4, 25.0, 25.5, 26.1, 26.6, 27.2, 27.7, 28.3,\n+            // 28.8, 29.4, 30.0]\n+            // TemSet = [20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 30, 30]\n+            // TemRec = [ 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\n+            // subtract the float version - the int version to get the fractional difference\n+            // if the difference is positive set halfStep to 1, negative to 0\n+            halfStep = ((((newVal - 32.) * 5.0 / 9.0) - outVal) > 0) ? 1 : 0;\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"TemUn\", CorF);\n+        parameters.put(\"SetTem\", outVal);\n+        parameters.put(\"TemRec\", halfStep);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceAir(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Air\", value);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceDry(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Blo\", value);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceHealth(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Health\", value);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDevicePwrSaving(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"SvSt\", value);\n+        parameters.put(\"WdSpd\", 0);\n+        parameters.put(\"Quiet\", 0);\n+        parameters.put(\"Tur\", 0);\n+        parameters.put(\"SwhSlp\", 0);\n+        parameters.put(\"SlpMod\", 0);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public int getIntStatusVal(String valueName) {\n+        /*\n+         * Note : Values can be:\n+         * \"Pow\": Power (0 or 1)\n+         * \"Mod\": Mode: Auto: 0, Cool: 1, Dry: 2, Fan: 3, Heat: 4\n+         * \"SetTem\": Requested Temperature\n+         * \"WdSpd\": Fan Speed : Low:1, Medium Low:2, Medium :3, Medium High :4, High :5\n+         * \"Air\": Air Mode Enabled\n+         * \"Blo\": Dry\n+         * \"Health\": Health\n+         * \"SwhSlp\": Sleep\n+         * \"SlpMod\": ???\n+         * \"Lig\": Light On\n+         * \"SwingLfRig\": Swing Left Right\n+         * \"SwUpDn\": Swing Up Down: // Ceiling:0, Upwards : 10, Downwards : 11, Full range : 1\n+         * \"Quiet\": Quiet mode\n+         * \"Tur\": Turbo\n+         * \"StHt\": 0,\n+         * \"TemUn\": Temperature unit, 0 for Celsius, 1 for Fahrenheit\n+         * \"HeatCoolType\"\n+         * \"TemRec\": (0 or 1), Send with SetTem, when TemUn==1, distinguishes between upper and lower integer Fahrenheit\n+         * temp\n+         * \"SvSt\": Power Saving\n+         */\n+        // Find the valueName in the Returned Status object\n+        String columns[] = statusResponseGson.packJson.cols;\n+        Integer values[] = statusResponseGson.packJson.dat;\n+        List<String> colList = new ArrayList<>(Arrays.asList(columns));\n+        List<Integer> valList = new ArrayList<>(Arrays.asList(values));\n+        int valueArrayposition = colList.indexOf(valueName);\n+        if (valueArrayposition == -1) {\n+            return -1;\n+        }\n+\n+        // Now get the Corresponding value\n+        Integer value = valList.get(valueArrayposition);\n+        return value;\n+    }\n+\n+    public boolean hasStatusValChanged(String valueName) throws GreeException {\n+        if (prevStatusResponsePackGson == null) {\n+            return true; // update value if there is no previous one\n+        }\n+        // Find the valueName in the Current Status object\n+        String currcolumns[] = statusResponseGson.packJson.cols;\n+        Integer currvalues[] = statusResponseGson.packJson.dat;\n+        List<String> currcolList = new ArrayList<>(Arrays.asList(currcolumns));\n+        List<Integer> currvalList = new ArrayList<>(Arrays.asList(currvalues));\n+        int currvalueArrayposition = currcolList.indexOf(valueName);\n+        if (currvalueArrayposition == -1) {\n+            throw new GreeException(\"Unable to decode device status\");\n+        }\n+        // Now get the Corresponding value\n+        int currvalue = currvalList.get(currvalueArrayposition);\n+\n+        // Find the valueName in the Previous Status object\n+        String prevcolumns[] = prevStatusResponsePackGson.cols;\n+        Integer prevvalues[] = prevStatusResponsePackGson.dat;\n+        List<String> prevcolList = new ArrayList<>(Arrays.asList(prevcolumns));\n+        List<Integer> prevvalList = new ArrayList<>(Arrays.asList(prevvalues));\n+        int prevvalueArrayposition = prevcolList.indexOf(valueName);\n+        if (prevvalueArrayposition == -1) {\n+            throw new GreeException(\"Unable to get status value\");\n+        }\n+        // Now get the Corresponding value\n+        int prevvalue = prevvalList.get(prevvalueArrayposition);\n+\n+        // Finally Compare the values\n+        return currvalue != prevvalue;\n+    }\n+\n+    protected void executeCommand(DatagramSocket clientSocket, HashMap<String, Integer> parameters)\n+            throws GreeException {\n+        byte[] sendData = new byte[1024];\n+        byte[] receiveData = new byte[1024];\n+        Gson gson = new Gson();\n+\n+        try {\n+            // Convert the parameter map values to arrays\n+            String[] keyArray = parameters.keySet().toArray(new String[0]);\n+            Integer[] valueArray = parameters.values().toArray(new Integer[0]);\n+\n+            // Prep the Command Request pack\n+            GreeExecuteCommandPack4GsonDTO execCmdPackGson = new GreeExecuteCommandPack4GsonDTO();\n+            execCmdPackGson.opt = keyArray;\n+            execCmdPackGson.p = valueArray;\n+            execCmdPackGson.t = \"cmd\";\n+            String execCmdPackStr = gson.toJson(execCmdPackGson);\n+\n+            // Now Encrypt the Binding Request pack\n+            String encryptedCommandReqPacket = GreeCryptoUtil.encryptPack(getKey().getBytes(), execCmdPackStr);\n+            // String unencryptedCommandReqPacket = CryptoUtil.decryptPack(device.getKey().getBytes(),\n+            // encryptedCommandReqPacket);\n+\n+            // Prep the Command Request\n+            GreeExecCommand4GsonDTO execCmdGson = new GreeExecCommand4GsonDTO();\n+            execCmdGson.cid = \"app\";\n+            execCmdGson.i = 0;\n+            execCmdGson.t = \"pack\";\n+            execCmdGson.uid = 0;\n+            execCmdGson.tcid = getId();\n+            execCmdGson.pack = new String(encryptedCommandReqPacket.getBytes(), UTF8_CHARSET);\n+            String execCmdStr = gson.toJson(execCmdGson);\n+            sendData = execCmdStr.getBytes();\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\n+            clientSocket.send(sendPacket);\n+\n+            // Recieve a response\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+            clientSocket.receive(receivePacket);\n+            String modifiedSentence = new String(receivePacket.getData(), \"UTF-8\");\n+\n+            // Read the response\n+            StringReader stringReader = new StringReader(modifiedSentence);\n+            GreeExecResponse4GsonDTO execResponseGson = gson.fromJson(new JsonReader(stringReader),\n+                    GreeExecResponse4GsonDTO.class);\n+            execResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(this.getKey().getBytes(),\n+                    execResponseGson.pack);\n+\n+            // Create the JSON to hold the response values\n+            stringReader = new StringReader(execResponseGson.decryptedPack);\n+            execResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeExecResponsePack4GsonDTO.class);\n+        } catch (IOException e) {\n+            throw new GreeException(e, \"Exception on command execution\");\n+        }\n+    }\n+\n+    public void getDeviceStatus(DatagramSocket clientSocket) throws GreeException {\n+        Gson gson = new Gson();\n+        byte[] sendData = new byte[1024];\n+        byte[] receiveData = new byte[1024];\n+\n+        try {\n+            // Set the values in the HashMap\n+            ArrayList<String> columns = new ArrayList<>();\n+            columns.add(\"Pow\");\n+            columns.add(\"Mod\");\n+            columns.add(\"SetTem\");\n+            columns.add(\"WdSpd\");\n+            columns.add(\"Air\");\n+            columns.add(\"Blo\");\n+            columns.add(\"Health\");\n+            columns.add(\"SwhSlp\");\n+            columns.add(\"Lig\");\n+            columns.add(\"SwingLfRig\");\n+            columns.add(\"SwUpDn\");\n+            columns.add(\"Quiet\");\n+            columns.add(\"Tur\");\n+            columns.add(\"StHt\");\n+            columns.add(\"TemUn\");\n+            columns.add(\"HeatCoolType\");\n+            columns.add(\"TemRec\");\n+            columns.add(\"SvSt\");\n+            columns.add(\"NoiseSet\");\n+\n+            // Convert the parameter map values to arrays\n+            String[] colArray = columns.toArray(new String[0]);\n+\n+            // Prep the Command Request pack\n+            GreeReqStatusPack4GsonDTO reqStatusPackGson = new GreeReqStatusPack4GsonDTO();\n+            reqStatusPackGson.t = \"status\";\n+            reqStatusPackGson.cols = colArray;\n+            reqStatusPackGson.mac = getId();\n+            String reqStatusPackStr = gson.toJson(reqStatusPackGson);\n+\n+            // Now Encrypt the Binding Request pack\n+            String encryptedStatusReqPacket = GreeCryptoUtil.encryptPack(getKey().getBytes(), reqStatusPackStr);\n+\n+            // Prep the Status Request\n+            GreeReqStatus4GsonDTO reqStatusGson = new GreeReqStatus4GsonDTO();\n+            reqStatusGson.cid = \"app\";\n+            reqStatusGson.i = 0;\n+            reqStatusGson.t = \"pack\";\n+            reqStatusGson.uid = 0;\n+            reqStatusGson.tcid = getId();\n+            reqStatusGson.pack = new String(encryptedStatusReqPacket.getBytes(), UTF8_CHARSET);\n+            String execCmdStr = gson.toJson(reqStatusGson);\n+            sendData = execCmdStr.getBytes();\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\n+            clientSocket.send(sendPacket);\n+\n+            // Recieve a response\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+            clientSocket.receive(receivePacket);\n+            String modifiedSentence = new String(receivePacket.getData(), \"UTF-8\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1e730ba701dc9c2bb5504f9fbbc0d2176c23490"}, "originalPosition": 656}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ5MTc0Ng==", "bodyText": "so same changes here as other comment", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436491746", "createdAt": "2020-06-08T07:00:22Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,713 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\n+ * device specific attributes as well a the functionality for the Air Conditioner\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+// @NonNullByDefault\n+public class GreeAirDevice {\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\n+    private boolean isBound = false;\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\n+    private int port = 0;\n+    private String encKey = \"\";\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\n+    private GreeBindResponse4GsonDTO bindResponseGson;\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\n+\n+    public boolean getIsBound() {\n+        return isBound;\n+    }\n+\n+    public void setIsBound(boolean isBound) {\n+        this.isBound = isBound;\n+    }\n+\n+    public InetAddress getAddress() {\n+        return ipAddress;\n+    }\n+\n+    public void setAddress(InetAddress address) {\n+        this.ipAddress = address;\n+    }\n+\n+    public int getPort() {\n+        return port;\n+    }\n+\n+    public void setPort(int port) {\n+        this.port = port;\n+    }\n+\n+    public String getKey() {\n+        return encKey;\n+    }\n+\n+    public String getId() {\n+        return mScanResponseGson.packJson.mac;\n+    }\n+\n+    public String getName() {\n+        return mScanResponseGson.packJson.name;\n+    }\n+\n+    public String getVendor() {\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\n+    }\n+\n+    public String getModel() {\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\n+    }\n+\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\n+        return mScanResponseGson;\n+    }\n+\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\n+        mScanResponseGson = gson;\n+    }\n+\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\n+        return bindResponseGson;\n+    }\n+\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\n+        return statusResponseGson;\n+    }\n+\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\n+        validateSocket(socket);\n+        byte[] sendData = new byte[1024];\n+        byte[] receiveData = new byte[347];\n+        Gson gson = new Gson();\n+\n+        try {\n+            // Prep the Binding Request pack\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\n+            bindReqPackGson.mac = getId();\n+            bindReqPackGson.t = \"bind\";\n+            bindReqPackGson.uid = 0;\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\n+\n+            // Now Encrypt the Binding Request pack\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\n+                    bindReqPackStr);\n+\n+            // Prep the Binding Request\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\n+            bindReqGson.cid = \"app\";\n+            bindReqGson.i = 1;\n+            bindReqGson.t = \"pack\";\n+            bindReqGson.uid = 0;\n+            bindReqGson.tcid = getId();\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\n+            String bindReqStr = gson.toJson(bindReqGson);\n+            sendData = bindReqStr.getBytes();\n+\n+            // Now Send the request\n+            DatagramSocket clientSocket = socket.get();\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\n+            clientSocket.send(sendPacket);\n+\n+            // Recieve a response\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+            clientSocket.receive(receivePacket);\n+            String modifiedSentence = new String(receivePacket.getData(), \"UTF-8\");\n+\n+            // Read the response\n+            StringReader stringReader = new StringReader(modifiedSentence);\n+            bindResponseGson = gson.fromJson(new JsonReader(stringReader), GreeBindResponse4GsonDTO.class);\n+            bindResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\n+                    bindResponseGson.pack);\n+\n+            // Create the JSON to hold the response values\n+            stringReader = new StringReader(bindResponseGson.decryptedPack);\n+            bindResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePack4GsonDTO.class);\n+\n+            // Now set the key and flag to indicate the bind was succesful\n+            encKey = bindResponseGson.packJson.key;\n+            setIsBound(true);\n+        } catch (IOException e) {\n+            throw new GreeException(e, \"failed\");\n+        }\n+    }\n+\n+    private void validateSocket(Optional<DatagramSocket> socket) {\n+        if (!socket.isPresent()) {\n+            throw new IllegalArgumentException(\"Socket not initialized!\");\n+        }\n+    }\n+\n+    public void setDevicePower(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 1)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Pow\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void SetDeviceMode(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 4)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Mod\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceSwingUpDown(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\n+        if (!getIsBound() || (value < 0 || value > 11) || (value > 6 && value < 10)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"SwUpDn\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceSwingLeftRight(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        // Only values 0,1,2,3,4,5,6 allowed\n+        if (!getIsBound() || (value < 0) || (value > 6)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"SwingLfRig\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    /**\n+     * Only allow this to happen if this device has been bound and values are valid\n+     * Possible values are :\n+     * 0 : Auto\n+     * 1 : Low\n+     * 2 : Medium Low\n+     * 3 : Medium\n+     * 4 : Medium High\n+     * 5 : High\n+     */\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, int value) throws GreeException {\n+        if (!getIsBound() || (value < 0 || value > 5)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"WdSpd\", value);\n+        parameters.put(\"Quiet\", 0);\n+        parameters.put(\"Tur\", 0);\n+        parameters.put(\"NoiseSet\", 0);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceTurbo(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 1)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Tur\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setQuietMode(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 2)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Quiet\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public int getDeviceTurbo() {\n+        return getIntStatusVal(\"Tur\");\n+    }\n+\n+    public void setDeviceLight(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 1)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Lig\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    /**\n+     * Create Hash Look Up for C and F\n+     * Temperature Ranges for gree A/C units (f_range = {86,61}, c_range={16,30}\n+     */\n+    private static HashMap<String, HashMap<String, Integer>> createTempRangeMap() {\n+        HashMap<String, HashMap<String, Integer>> tempRanges = new HashMap<>();\n+        HashMap<String, Integer> hmf = new HashMap<>();\n+        HashMap<String, Integer> hmc = new HashMap<>();\n+\n+        hmf.put(\"min\", 61); // F\n+        hmf.put(\"max\", 86);\n+        tempRanges.put(\"F\", hmf);\n+\n+        hmc.put(\"min\", 16); // C\n+        hmc.put(\"max\", 30);\n+        tempRanges.put(\"C\", hmc);\n+\n+        return tempRanges;\n+    }\n+\n+    /**\n+     * Checks input ranges for validity and TempUn for validity\n+     * Uses newVal as priority and tries to validate and determine intent\n+     * For example if value is 75 and TempUn says Celsius, change TempUn to Fahrenheit\n+     */\n+    private int[] validateTemperatureRangeForTempSet(int newValIn, @Nullable Integer CorFIn) {\n+        final String[] minMaxLUT = { \"max\", \"min\" }; // looks up 0 = C = max, 1 = F = min\n+        final String[] tempScaleLUT = { \"C\", \"F\" }; // Look Up Table used to convert TempUn integer 0,1 to \"C\" to \"F\"\n+                                                    // string for hashmap\n+        HashMap<String, Integer> nullCorFLUT = new HashMap<>(); // simple look up table for logic\n+        nullCorFLUT.put(\"C\", 0);\n+        nullCorFLUT.put(\"F\", 1);\n+        nullCorFLUT.put(\"INVALID\", 0);\n+\n+        String validRangeCorF; // stores if the input range is a valid C or F temperature\n+\n+        // force to global min/max\n+        int newVal = (Math.max(newValIn, Math.min(tempRanges.get(\"C\").get(\"min\"), tempRanges.get(\"F\").get(\"min\"))));\n+        newVal = Math.min(newVal, Math.max(tempRanges.get(\"C\").get(\"max\"), tempRanges.get(\"F\").get(\"max\")));\n+\n+        if ((newVal >= tempRanges.get(\"C\").get(\"min\")) && (newVal <= tempRanges.get(\"C\").get(\"max\"))) {\n+            validRangeCorF = \"C\";\n+        } else if ((newVal >= tempRanges.get(\"F\").get(\"min\")) && (newVal <= tempRanges.get(\"F\").get(\"max\"))) {\n+            validRangeCorF = \"F\";\n+        } else {\n+            logger.warn(\"Input Temp request {} is invalid\", newVal);\n+            validRangeCorF = \"INVALID\";\n+        }\n+\n+        // if CorF wasnt initialized or is null set it from lookup\n+        Integer CorF = CorFIn != null ? CorFIn : nullCorFLUT.get(validRangeCorF);\n+\n+        if ((CorF == 1) && validRangeCorF.equals(\"C\")) {\n+            CorF = 0; // input temp takes priority\n+        } else if ((CorF == 0) && validRangeCorF.equals(\"F\")) {\n+            CorF = 1; // input temp takes priority\n+        } else if (validRangeCorF.equals(\"INVALID\")) {\n+            // force min or max temp based on CorF scale to be used\n+            newVal = tempRanges.get(tempScaleLUT[CorF]).get(minMaxLUT[CorF]);\n+        }\n+\n+        return new int[] { newVal, CorF };\n+    }\n+\n+    public void setDeviceTempSet(DatagramSocket clientSocket, int value) throws GreeException {\n+        // **value** : set temperature in degrees celsius or Fahrenheit\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+        int newVal = value;\n+        int outVal = value;\n+        // Get Celsius or Fahrenheit from status message\n+        Integer CorF = getIntStatusVal(\"TemUn\");\n+        // TODO put a param in openhab to allow setting this from the config\n+\n+        // If commanding Fahrenheit set halfStep to 1 or 0 to tell the A/C which F integer\n+        // temperature to use as celsius alone is ambigious\n+        int halfStep = 0; // default to C\n+\n+        int[] retList = validateTemperatureRangeForTempSet(newVal, CorF);\n+        newVal = retList[0];\n+        CorF = retList[1];\n+\n+        if (CorF == 1) { // If Fahrenheit,\n+            // value argument is degrees F, convert Fahrenheit to Celsius,\n+            // SetTem input to A/C always in Celsius despite passing in 1 to TemUn\n+            outVal = (int) (Math.round((newVal - 32.) * 5.0 / 9.0)); // Integer Truncated\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\n+            // F = [68. , 69. , 70. , 71. , 72. , 73. , 74. , 75. , 76. , 77. , 78. , 79. , 80. , 81. , 82. , 83. ,\n+            // 84. , 85. , 86. ]\n+            // C = [20.0, 20.5, 21.1, 21.6, 22.2, 22.7, 23.3, 23.8, 24.4, 25.0, 25.5, 26.1, 26.6, 27.2, 27.7, 28.3,\n+            // 28.8, 29.4, 30.0]\n+            // TemSet = [20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 30, 30]\n+            // TemRec = [ 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\n+            // subtract the float version - the int version to get the fractional difference\n+            // if the difference is positive set halfStep to 1, negative to 0\n+            halfStep = ((((newVal - 32.) * 5.0 / 9.0) - outVal) > 0) ? 1 : 0;\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"TemUn\", CorF);\n+        parameters.put(\"SetTem\", outVal);\n+        parameters.put(\"TemRec\", halfStep);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceAir(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Air\", value);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceDry(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Blo\", value);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceHealth(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Health\", value);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDevicePwrSaving(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"SvSt\", value);\n+        parameters.put(\"WdSpd\", 0);\n+        parameters.put(\"Quiet\", 0);\n+        parameters.put(\"Tur\", 0);\n+        parameters.put(\"SwhSlp\", 0);\n+        parameters.put(\"SlpMod\", 0);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public int getIntStatusVal(String valueName) {\n+        /*\n+         * Note : Values can be:\n+         * \"Pow\": Power (0 or 1)\n+         * \"Mod\": Mode: Auto: 0, Cool: 1, Dry: 2, Fan: 3, Heat: 4\n+         * \"SetTem\": Requested Temperature\n+         * \"WdSpd\": Fan Speed : Low:1, Medium Low:2, Medium :3, Medium High :4, High :5\n+         * \"Air\": Air Mode Enabled\n+         * \"Blo\": Dry\n+         * \"Health\": Health\n+         * \"SwhSlp\": Sleep\n+         * \"SlpMod\": ???\n+         * \"Lig\": Light On\n+         * \"SwingLfRig\": Swing Left Right\n+         * \"SwUpDn\": Swing Up Down: // Ceiling:0, Upwards : 10, Downwards : 11, Full range : 1\n+         * \"Quiet\": Quiet mode\n+         * \"Tur\": Turbo\n+         * \"StHt\": 0,\n+         * \"TemUn\": Temperature unit, 0 for Celsius, 1 for Fahrenheit\n+         * \"HeatCoolType\"\n+         * \"TemRec\": (0 or 1), Send with SetTem, when TemUn==1, distinguishes between upper and lower integer Fahrenheit\n+         * temp\n+         * \"SvSt\": Power Saving\n+         */\n+        // Find the valueName in the Returned Status object\n+        String columns[] = statusResponseGson.packJson.cols;\n+        Integer values[] = statusResponseGson.packJson.dat;\n+        List<String> colList = new ArrayList<>(Arrays.asList(columns));\n+        List<Integer> valList = new ArrayList<>(Arrays.asList(values));\n+        int valueArrayposition = colList.indexOf(valueName);\n+        if (valueArrayposition == -1) {\n+            return -1;\n+        }\n+\n+        // Now get the Corresponding value\n+        Integer value = valList.get(valueArrayposition);\n+        return value;\n+    }\n+\n+    public boolean hasStatusValChanged(String valueName) throws GreeException {\n+        if (prevStatusResponsePackGson == null) {\n+            return true; // update value if there is no previous one\n+        }\n+        // Find the valueName in the Current Status object\n+        String currcolumns[] = statusResponseGson.packJson.cols;\n+        Integer currvalues[] = statusResponseGson.packJson.dat;\n+        List<String> currcolList = new ArrayList<>(Arrays.asList(currcolumns));\n+        List<Integer> currvalList = new ArrayList<>(Arrays.asList(currvalues));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1e730ba701dc9c2bb5504f9fbbc0d2176c23490"}, "originalPosition": 519}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ5MTgyMA==", "bodyText": "do same changes here as other comment", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r436491820", "createdAt": "2020-06-08T07:00:34Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,713 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequest4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecCommand4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatus4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPack4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponse4GsonDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePack4GsonDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\n+ * device specific attributes as well a the functionality for the Air Conditioner\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+// @NonNullByDefault\n+public class GreeAirDevice {\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\n+    private boolean isBound = false;\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\n+    private int port = 0;\n+    private String encKey = \"\";\n+    private GreeScanResponse4GsonDTO mScanResponseGson;\n+    private GreeBindResponse4GsonDTO bindResponseGson;\n+    private GreeStatusResponse4GsonDTO statusResponseGson;\n+    private GreeStatusResponsePack4GsonDTO prevStatusResponsePackGson;\n+\n+    public boolean getIsBound() {\n+        return isBound;\n+    }\n+\n+    public void setIsBound(boolean isBound) {\n+        this.isBound = isBound;\n+    }\n+\n+    public InetAddress getAddress() {\n+        return ipAddress;\n+    }\n+\n+    public void setAddress(InetAddress address) {\n+        this.ipAddress = address;\n+    }\n+\n+    public int getPort() {\n+        return port;\n+    }\n+\n+    public void setPort(int port) {\n+        this.port = port;\n+    }\n+\n+    public String getKey() {\n+        return encKey;\n+    }\n+\n+    public String getId() {\n+        return mScanResponseGson.packJson.mac;\n+    }\n+\n+    public String getName() {\n+        return mScanResponseGson.packJson.name;\n+    }\n+\n+    public String getVendor() {\n+        return mScanResponseGson.packJson.brand + \" \" + mScanResponseGson.packJson.vender;\n+    }\n+\n+    public String getModel() {\n+        return mScanResponseGson.packJson.series + \" \" + mScanResponseGson.packJson.model;\n+    }\n+\n+    public GreeScanResponse4GsonDTO getScanResponseGson() {\n+        return mScanResponseGson;\n+    }\n+\n+    public void setScanResponseGson(GreeScanResponse4GsonDTO gson) {\n+        mScanResponseGson = gson;\n+    }\n+\n+    public GreeBindResponse4GsonDTO getBindResponseGson() {\n+        return bindResponseGson;\n+    }\n+\n+    public GreeStatusResponse4GsonDTO getGreeStatusResponse4Gson() {\n+        return statusResponseGson;\n+    }\n+\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\n+        validateSocket(socket);\n+        byte[] sendData = new byte[1024];\n+        byte[] receiveData = new byte[347];\n+        Gson gson = new Gson();\n+\n+        try {\n+            // Prep the Binding Request pack\n+            GreeBindRequestPack4GsonDTO bindReqPackGson = new GreeBindRequestPack4GsonDTO();\n+            bindReqPackGson.mac = getId();\n+            bindReqPackGson.t = \"bind\";\n+            bindReqPackGson.uid = 0;\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\n+\n+            // Now Encrypt the Binding Request pack\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\n+                    bindReqPackStr);\n+\n+            // Prep the Binding Request\n+            GreeBindRequest4GsonDTO bindReqGson = new GreeBindRequest4GsonDTO();\n+            bindReqGson.cid = \"app\";\n+            bindReqGson.i = 1;\n+            bindReqGson.t = \"pack\";\n+            bindReqGson.uid = 0;\n+            bindReqGson.tcid = getId();\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\n+            String bindReqStr = gson.toJson(bindReqGson);\n+            sendData = bindReqStr.getBytes();\n+\n+            // Now Send the request\n+            DatagramSocket clientSocket = socket.get();\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\n+            clientSocket.send(sendPacket);\n+\n+            // Recieve a response\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+            clientSocket.receive(receivePacket);\n+            String modifiedSentence = new String(receivePacket.getData(), \"UTF-8\");\n+\n+            // Read the response\n+            StringReader stringReader = new StringReader(modifiedSentence);\n+            bindResponseGson = gson.fromJson(new JsonReader(stringReader), GreeBindResponse4GsonDTO.class);\n+            bindResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\n+                    bindResponseGson.pack);\n+\n+            // Create the JSON to hold the response values\n+            stringReader = new StringReader(bindResponseGson.decryptedPack);\n+            bindResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePack4GsonDTO.class);\n+\n+            // Now set the key and flag to indicate the bind was succesful\n+            encKey = bindResponseGson.packJson.key;\n+            setIsBound(true);\n+        } catch (IOException e) {\n+            throw new GreeException(e, \"failed\");\n+        }\n+    }\n+\n+    private void validateSocket(Optional<DatagramSocket> socket) {\n+        if (!socket.isPresent()) {\n+            throw new IllegalArgumentException(\"Socket not initialized!\");\n+        }\n+    }\n+\n+    public void setDevicePower(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 1)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Pow\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void SetDeviceMode(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 4)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Mod\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceSwingUpDown(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\n+        if (!getIsBound() || (value < 0 || value > 11) || (value > 6 && value < 10)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"SwUpDn\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceSwingLeftRight(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        // Only values 0,1,2,3,4,5,6 allowed\n+        if (!getIsBound() || (value < 0) || (value > 6)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"SwingLfRig\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    /**\n+     * Only allow this to happen if this device has been bound and values are valid\n+     * Possible values are :\n+     * 0 : Auto\n+     * 1 : Low\n+     * 2 : Medium Low\n+     * 3 : Medium\n+     * 4 : Medium High\n+     * 5 : High\n+     */\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, int value) throws GreeException {\n+        if (!getIsBound() || (value < 0 || value > 5)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"WdSpd\", value);\n+        parameters.put(\"Quiet\", 0);\n+        parameters.put(\"Tur\", 0);\n+        parameters.put(\"NoiseSet\", 0);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceTurbo(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 1)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Tur\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setQuietMode(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 2)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Quiet\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public int getDeviceTurbo() {\n+        return getIntStatusVal(\"Tur\");\n+    }\n+\n+    public void setDeviceLight(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 1)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Lig\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    /**\n+     * Create Hash Look Up for C and F\n+     * Temperature Ranges for gree A/C units (f_range = {86,61}, c_range={16,30}\n+     */\n+    private static HashMap<String, HashMap<String, Integer>> createTempRangeMap() {\n+        HashMap<String, HashMap<String, Integer>> tempRanges = new HashMap<>();\n+        HashMap<String, Integer> hmf = new HashMap<>();\n+        HashMap<String, Integer> hmc = new HashMap<>();\n+\n+        hmf.put(\"min\", 61); // F\n+        hmf.put(\"max\", 86);\n+        tempRanges.put(\"F\", hmf);\n+\n+        hmc.put(\"min\", 16); // C\n+        hmc.put(\"max\", 30);\n+        tempRanges.put(\"C\", hmc);\n+\n+        return tempRanges;\n+    }\n+\n+    /**\n+     * Checks input ranges for validity and TempUn for validity\n+     * Uses newVal as priority and tries to validate and determine intent\n+     * For example if value is 75 and TempUn says Celsius, change TempUn to Fahrenheit\n+     */\n+    private int[] validateTemperatureRangeForTempSet(int newValIn, @Nullable Integer CorFIn) {\n+        final String[] minMaxLUT = { \"max\", \"min\" }; // looks up 0 = C = max, 1 = F = min\n+        final String[] tempScaleLUT = { \"C\", \"F\" }; // Look Up Table used to convert TempUn integer 0,1 to \"C\" to \"F\"\n+                                                    // string for hashmap\n+        HashMap<String, Integer> nullCorFLUT = new HashMap<>(); // simple look up table for logic\n+        nullCorFLUT.put(\"C\", 0);\n+        nullCorFLUT.put(\"F\", 1);\n+        nullCorFLUT.put(\"INVALID\", 0);\n+\n+        String validRangeCorF; // stores if the input range is a valid C or F temperature\n+\n+        // force to global min/max\n+        int newVal = (Math.max(newValIn, Math.min(tempRanges.get(\"C\").get(\"min\"), tempRanges.get(\"F\").get(\"min\"))));\n+        newVal = Math.min(newVal, Math.max(tempRanges.get(\"C\").get(\"max\"), tempRanges.get(\"F\").get(\"max\")));\n+\n+        if ((newVal >= tempRanges.get(\"C\").get(\"min\")) && (newVal <= tempRanges.get(\"C\").get(\"max\"))) {\n+            validRangeCorF = \"C\";\n+        } else if ((newVal >= tempRanges.get(\"F\").get(\"min\")) && (newVal <= tempRanges.get(\"F\").get(\"max\"))) {\n+            validRangeCorF = \"F\";\n+        } else {\n+            logger.warn(\"Input Temp request {} is invalid\", newVal);\n+            validRangeCorF = \"INVALID\";\n+        }\n+\n+        // if CorF wasnt initialized or is null set it from lookup\n+        Integer CorF = CorFIn != null ? CorFIn : nullCorFLUT.get(validRangeCorF);\n+\n+        if ((CorF == 1) && validRangeCorF.equals(\"C\")) {\n+            CorF = 0; // input temp takes priority\n+        } else if ((CorF == 0) && validRangeCorF.equals(\"F\")) {\n+            CorF = 1; // input temp takes priority\n+        } else if (validRangeCorF.equals(\"INVALID\")) {\n+            // force min or max temp based on CorF scale to be used\n+            newVal = tempRanges.get(tempScaleLUT[CorF]).get(minMaxLUT[CorF]);\n+        }\n+\n+        return new int[] { newVal, CorF };\n+    }\n+\n+    public void setDeviceTempSet(DatagramSocket clientSocket, int value) throws GreeException {\n+        // **value** : set temperature in degrees celsius or Fahrenheit\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+        int newVal = value;\n+        int outVal = value;\n+        // Get Celsius or Fahrenheit from status message\n+        Integer CorF = getIntStatusVal(\"TemUn\");\n+        // TODO put a param in openhab to allow setting this from the config\n+\n+        // If commanding Fahrenheit set halfStep to 1 or 0 to tell the A/C which F integer\n+        // temperature to use as celsius alone is ambigious\n+        int halfStep = 0; // default to C\n+\n+        int[] retList = validateTemperatureRangeForTempSet(newVal, CorF);\n+        newVal = retList[0];\n+        CorF = retList[1];\n+\n+        if (CorF == 1) { // If Fahrenheit,\n+            // value argument is degrees F, convert Fahrenheit to Celsius,\n+            // SetTem input to A/C always in Celsius despite passing in 1 to TemUn\n+            outVal = (int) (Math.round((newVal - 32.) * 5.0 / 9.0)); // Integer Truncated\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\n+            // F = [68. , 69. , 70. , 71. , 72. , 73. , 74. , 75. , 76. , 77. , 78. , 79. , 80. , 81. , 82. , 83. ,\n+            // 84. , 85. , 86. ]\n+            // C = [20.0, 20.5, 21.1, 21.6, 22.2, 22.7, 23.3, 23.8, 24.4, 25.0, 25.5, 26.1, 26.6, 27.2, 27.7, 28.3,\n+            // 28.8, 29.4, 30.0]\n+            // TemSet = [20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 30, 30]\n+            // TemRec = [ 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\n+            // subtract the float version - the int version to get the fractional difference\n+            // if the difference is positive set halfStep to 1, negative to 0\n+            halfStep = ((((newVal - 32.) * 5.0 / 9.0) - outVal) > 0) ? 1 : 0;\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"TemUn\", CorF);\n+        parameters.put(\"SetTem\", outVal);\n+        parameters.put(\"TemRec\", halfStep);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceAir(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Air\", value);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceDry(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Blo\", value);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceHealth(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Health\", value);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDevicePwrSaving(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"SvSt\", value);\n+        parameters.put(\"WdSpd\", 0);\n+        parameters.put(\"Quiet\", 0);\n+        parameters.put(\"Tur\", 0);\n+        parameters.put(\"SwhSlp\", 0);\n+        parameters.put(\"SlpMod\", 0);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public int getIntStatusVal(String valueName) {\n+        /*\n+         * Note : Values can be:\n+         * \"Pow\": Power (0 or 1)\n+         * \"Mod\": Mode: Auto: 0, Cool: 1, Dry: 2, Fan: 3, Heat: 4\n+         * \"SetTem\": Requested Temperature\n+         * \"WdSpd\": Fan Speed : Low:1, Medium Low:2, Medium :3, Medium High :4, High :5\n+         * \"Air\": Air Mode Enabled\n+         * \"Blo\": Dry\n+         * \"Health\": Health\n+         * \"SwhSlp\": Sleep\n+         * \"SlpMod\": ???\n+         * \"Lig\": Light On\n+         * \"SwingLfRig\": Swing Left Right\n+         * \"SwUpDn\": Swing Up Down: // Ceiling:0, Upwards : 10, Downwards : 11, Full range : 1\n+         * \"Quiet\": Quiet mode\n+         * \"Tur\": Turbo\n+         * \"StHt\": 0,\n+         * \"TemUn\": Temperature unit, 0 for Celsius, 1 for Fahrenheit\n+         * \"HeatCoolType\"\n+         * \"TemRec\": (0 or 1), Send with SetTem, when TemUn==1, distinguishes between upper and lower integer Fahrenheit\n+         * temp\n+         * \"SvSt\": Power Saving\n+         */\n+        // Find the valueName in the Returned Status object\n+        String columns[] = statusResponseGson.packJson.cols;\n+        Integer values[] = statusResponseGson.packJson.dat;\n+        List<String> colList = new ArrayList<>(Arrays.asList(columns));\n+        List<Integer> valList = new ArrayList<>(Arrays.asList(values));\n+        int valueArrayposition = colList.indexOf(valueName);\n+        if (valueArrayposition == -1) {\n+            return -1;\n+        }\n+\n+        // Now get the Corresponding value\n+        Integer value = valList.get(valueArrayposition);\n+        return value;\n+    }\n+\n+    public boolean hasStatusValChanged(String valueName) throws GreeException {\n+        if (prevStatusResponsePackGson == null) {\n+            return true; // update value if there is no previous one\n+        }\n+        // Find the valueName in the Current Status object\n+        String currcolumns[] = statusResponseGson.packJson.cols;\n+        Integer currvalues[] = statusResponseGson.packJson.dat;\n+        List<String> currcolList = new ArrayList<>(Arrays.asList(currcolumns));\n+        List<Integer> currvalList = new ArrayList<>(Arrays.asList(currvalues));\n+        int currvalueArrayposition = currcolList.indexOf(valueName);\n+        if (currvalueArrayposition == -1) {\n+            throw new GreeException(\"Unable to decode device status\");\n+        }\n+        // Now get the Corresponding value\n+        int currvalue = currvalList.get(currvalueArrayposition);\n+\n+        // Find the valueName in the Previous Status object\n+        String prevcolumns[] = prevStatusResponsePackGson.cols;\n+        Integer prevvalues[] = prevStatusResponsePackGson.dat;\n+        List<String> prevcolList = new ArrayList<>(Arrays.asList(prevcolumns));\n+        List<Integer> prevvalList = new ArrayList<>(Arrays.asList(prevvalues));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1e730ba701dc9c2bb5504f9fbbc0d2176c23490"}, "originalPosition": 531}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1c64aff6717981ccb3ec90324cb90ca704e68c88", "author": {"user": {"login": "markus7017", "name": "Markus Michels"}}, "url": "https://github.com/openhab/openhab-addons/commit/1c64aff6717981ccb3ec90324cb90ca704e68c88", "committedDate": "2020-06-08T19:54:52Z", "message": "Turned GreeAirDevice into @NonNullByDefault, test pending\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5f5f5bb2d68d48b8927f43e1403cf06abcf4ea1d", "author": {"user": {"login": "markus7017", "name": "Markus Michels"}}, "url": "https://github.com/openhab/openhab-addons/commit/5f5f5bb2d68d48b8927f43e1403cf06abcf4ea1d", "committedDate": "2020-06-08T22:43:33Z", "message": "review changes\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI2NzQ4NjE1", "url": "https://github.com/openhab/openhab-addons/pull/7504#pullrequestreview-426748615", "createdAt": "2020-06-09T02:33:51Z", "commit": {"oid": "5f5f5bb2d68d48b8927f43e1403cf06abcf4ea1d"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwMjozMzo1MVrOGg2uWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQwMjo0MzozNFrOGg23hg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzEwNDIxNw==", "bodyText": "You should specify the charset here", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r437104217", "createdAt": "2020-06-09T02:33:51Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeDeviceFinder.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.discovery;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeScanReponsePackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanRequestDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponseDTO;\n+import org.openhab.binding.gree.internal.handler.GreeAirDevice;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDeviceFinder provides functionality for searching for GREE Airconditioners on the network and keeping a list\n+ * of found devices.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeDeviceFinder {\n+    private final Logger logger = LoggerFactory.getLogger(GreeDeviceFinder.class);\n+\n+    protected final InetAddress ipAddress;\n+    protected HashMap<String, GreeAirDevice> deviceTable = new HashMap<>();\n+\n+    public GreeDeviceFinder() {\n+        ipAddress = InetAddress.getLoopbackAddress(); // dummy\n+    }\n+\n+    public GreeDeviceFinder(String broadcastAddress) throws UnknownHostException {\n+        ipAddress = InetAddress.getByName(broadcastAddress);\n+    }\n+\n+    public void scan(Optional<DatagramSocket> socket, boolean scanNetwork) throws GreeException {\n+        validateSocket(socket);\n+        byte[] sendData = new byte[1024];\n+        byte[] receiveData = new byte[1024];\n+\n+        // Send the Scan message\n+        GreeScanRequestDTO scanGson = new GreeScanRequestDTO();\n+        scanGson.t = \"scan\";\n+\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        Gson gson = gsonBuilder.create();\n+        String scanReq = gson.toJson(scanGson);\n+        sendData = scanReq.getBytes();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5f5f5bb2d68d48b8927f43e1403cf06abcf4ea1d"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzEwNTAyMA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    GreeAirDevice returnDevice = null;\n          \n          \n            \n            \n          \n          \n            \n                    Set<String> keySet = deviceTable.keySet();\n          \n          \n            \n                    Iterator<String> iter = keySet.iterator();\n          \n          \n            \n                    while (returnDevice == null && iter.hasNext()) {\n          \n          \n            \n                        Object thiskey = iter.next();\n          \n          \n            \n                        if (deviceTable.containsKey(thiskey)) {\n          \n          \n            \n                            GreeAirDevice currDevice = deviceTable.get(thiskey);\n          \n          \n            \n                            if (currDevice.getAddress().getHostAddress().equals(ipAddress)) {\n          \n          \n            \n                                returnDevice = currDevice;\n          \n          \n            \n                            }\n          \n          \n            \n                        }\n          \n          \n            \n                    }\n          \n          \n            \n            \n          \n          \n            \n                    return returnDevice;\n          \n          \n            \n                    for(GreeAirDevice currDevice : deviceTable.values()){\n          \n          \n            \n                        if (currDevice.getAddress().getHostAddress().equals(ipAddress)) {\n          \n          \n            \n                            return currDevice;\n          \n          \n            \n                        }\n          \n          \n            \n                    }\n          \n          \n            \n                    return null;", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r437105020", "createdAt": "2020-06-09T02:36:57Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeDeviceFinder.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.discovery;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeScanReponsePackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanRequestDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponseDTO;\n+import org.openhab.binding.gree.internal.handler.GreeAirDevice;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDeviceFinder provides functionality for searching for GREE Airconditioners on the network and keeping a list\n+ * of found devices.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeDeviceFinder {\n+    private final Logger logger = LoggerFactory.getLogger(GreeDeviceFinder.class);\n+\n+    protected final InetAddress ipAddress;\n+    protected HashMap<String, GreeAirDevice> deviceTable = new HashMap<>();\n+\n+    public GreeDeviceFinder() {\n+        ipAddress = InetAddress.getLoopbackAddress(); // dummy\n+    }\n+\n+    public GreeDeviceFinder(String broadcastAddress) throws UnknownHostException {\n+        ipAddress = InetAddress.getByName(broadcastAddress);\n+    }\n+\n+    public void scan(Optional<DatagramSocket> socket, boolean scanNetwork) throws GreeException {\n+        validateSocket(socket);\n+        byte[] sendData = new byte[1024];\n+        byte[] receiveData = new byte[1024];\n+\n+        // Send the Scan message\n+        GreeScanRequestDTO scanGson = new GreeScanRequestDTO();\n+        scanGson.t = \"scan\";\n+\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        Gson gson = gsonBuilder.create();\n+        String scanReq = gson.toJson(scanGson);\n+        sendData = scanReq.getBytes();\n+\n+        logger.trace(\"Sending scan packet to {}\", ipAddress.getHostAddress());\n+        try {\n+            DatagramSocket clientSocket = socket.get();\n+            clientSocket.setSoTimeout(DISCOVERY_TIMEOUT_MS);\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, ipAddress, DISCOVERY_TIMEOUT_MS);\n+            clientSocket.send(sendPacket);\n+\n+            // Loop for respnses from devices until we get a timeout.\n+            boolean scanning = true;\n+            int retries = MAX_SCAN_CYCLES;\n+            while (scanning && (retries > 0)) {\n+                // Receive a response\n+                DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+                try {\n+                    clientSocket.receive(receivePacket);\n+                    InetAddress remoteAddress = receivePacket.getAddress();\n+                    int remotePort = receivePacket.getPort();\n+\n+                    // Read the response\n+                    String modifiedSentence = new String(receivePacket.getData(), \"UTF-8\");\n+                    StringReader stringReader = new StringReader(modifiedSentence);\n+                    GreeScanResponseDTO scanResponseGson = gson.fromJson(new JsonReader(stringReader),\n+                            GreeScanResponseDTO.class);\n+\n+                    // If there was no pack, ignore the response\n+                    if (scanResponseGson.pack == null) {\n+                        logger.debug(\"Invalid packet format, ignore\");\n+                        continue;\n+                    }\n+\n+                    // Decrypt message - a a GreeException is thrown when something went wrong\n+                    scanResponseGson.decryptedPack = GreeCryptoUtil\n+                            .decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(), scanResponseGson.pack);\n+                    String decryptedMsg = GreeCryptoUtil.decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\n+                            scanResponseGson.pack);\n+\n+                    logger.debug(\"Response received from address {}: {}\", remoteAddress.getHostAddress(), decryptedMsg);\n+\n+                    // Create the JSON to hold the response values\n+                    stringReader = new StringReader(decryptedMsg);\n+                    scanResponseGson.packJson = gson.fromJson(new JsonReader(stringReader),\n+                            GreeScanReponsePackDTO.class);\n+\n+                    // Now make sure the device is reported as a Gree device\n+                    if (scanResponseGson.packJson.brand.equalsIgnoreCase(\"gree\")) {\n+                        // Create a new GreeDevice\n+                        logger.debug(\"Discovered device at {}:{}\", remoteAddress.getHostAddress(), remotePort);\n+                        GreeAirDevice newDevice = new GreeAirDevice();\n+                        newDevice.setAddress(remoteAddress);\n+                        newDevice.setPort(remotePort);\n+                        newDevice.setScanResponseGson(scanResponseGson);\n+                        addDevice(newDevice);\n+                    } else {\n+                        logger.debug(\"Unit discovered, but brand is not GREE\");\n+                    }\n+\n+                    scanning = scanNetwork;\n+                } catch (SocketTimeoutException e) {\n+                    // We've received a timeout so lets quit searching for devices\n+                    scanning = false;\n+                    break;\n+                } catch (IOException e) {\n+                    retries--;\n+                    if (retries == 0) {\n+                        throw new GreeException(\"Exception on device scan\", e);\n+                    }\n+                }\n+            }\n+        } catch (IOException e) {\n+            throw new GreeException(\"I/O exception during device scan\", e);\n+        }\n+    }\n+\n+    public void addDevice(GreeAirDevice newDevice) {\n+        deviceTable.put(newDevice.getId(), newDevice);\n+    }\n+\n+    public GreeAirDevice getDevice(String id) {\n+        return deviceTable.get(id);\n+    }\n+\n+    public Map<String, GreeAirDevice> getDevices() {\n+        return deviceTable;\n+    }\n+\n+    public @Nullable GreeAirDevice getDeviceByIPAddress(String ipAddress) {\n+        GreeAirDevice returnDevice = null;\n+\n+        Set<String> keySet = deviceTable.keySet();\n+        Iterator<String> iter = keySet.iterator();\n+        while (returnDevice == null && iter.hasNext()) {\n+            Object thiskey = iter.next();\n+            if (deviceTable.containsKey(thiskey)) {\n+                GreeAirDevice currDevice = deviceTable.get(thiskey);\n+                if (currDevice.getAddress().getHostAddress().equals(ipAddress)) {\n+                    returnDevice = currDevice;\n+                }\n+            }\n+        }\n+\n+        return returnDevice;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5f5f5bb2d68d48b8927f43e1403cf06abcf4ea1d"}, "originalPosition": 181}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzEwNTQyNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                scanResponseGson.decryptedPack = GreeCryptoUtil\n          \n          \n            \n                                        .decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(), scanResponseGson.pack);\n          \n          \n            \n                                String decryptedMsg = GreeCryptoUtil.decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\n          \n          \n            \n                                        scanResponseGson.pack);\n          \n          \n            \n                                String decryptedMsg = scanResponseGson.decryptedPack = GreeCryptoUtil\n          \n          \n            \n                                        .decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(), scanResponseGson.pack);", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r437105425", "createdAt": "2020-06-09T02:38:43Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeDeviceFinder.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.discovery;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeScanReponsePackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanRequestDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponseDTO;\n+import org.openhab.binding.gree.internal.handler.GreeAirDevice;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDeviceFinder provides functionality for searching for GREE Airconditioners on the network and keeping a list\n+ * of found devices.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeDeviceFinder {\n+    private final Logger logger = LoggerFactory.getLogger(GreeDeviceFinder.class);\n+\n+    protected final InetAddress ipAddress;\n+    protected HashMap<String, GreeAirDevice> deviceTable = new HashMap<>();\n+\n+    public GreeDeviceFinder() {\n+        ipAddress = InetAddress.getLoopbackAddress(); // dummy\n+    }\n+\n+    public GreeDeviceFinder(String broadcastAddress) throws UnknownHostException {\n+        ipAddress = InetAddress.getByName(broadcastAddress);\n+    }\n+\n+    public void scan(Optional<DatagramSocket> socket, boolean scanNetwork) throws GreeException {\n+        validateSocket(socket);\n+        byte[] sendData = new byte[1024];\n+        byte[] receiveData = new byte[1024];\n+\n+        // Send the Scan message\n+        GreeScanRequestDTO scanGson = new GreeScanRequestDTO();\n+        scanGson.t = \"scan\";\n+\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        Gson gson = gsonBuilder.create();\n+        String scanReq = gson.toJson(scanGson);\n+        sendData = scanReq.getBytes();\n+\n+        logger.trace(\"Sending scan packet to {}\", ipAddress.getHostAddress());\n+        try {\n+            DatagramSocket clientSocket = socket.get();\n+            clientSocket.setSoTimeout(DISCOVERY_TIMEOUT_MS);\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, ipAddress, DISCOVERY_TIMEOUT_MS);\n+            clientSocket.send(sendPacket);\n+\n+            // Loop for respnses from devices until we get a timeout.\n+            boolean scanning = true;\n+            int retries = MAX_SCAN_CYCLES;\n+            while (scanning && (retries > 0)) {\n+                // Receive a response\n+                DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+                try {\n+                    clientSocket.receive(receivePacket);\n+                    InetAddress remoteAddress = receivePacket.getAddress();\n+                    int remotePort = receivePacket.getPort();\n+\n+                    // Read the response\n+                    String modifiedSentence = new String(receivePacket.getData(), \"UTF-8\");\n+                    StringReader stringReader = new StringReader(modifiedSentence);\n+                    GreeScanResponseDTO scanResponseGson = gson.fromJson(new JsonReader(stringReader),\n+                            GreeScanResponseDTO.class);\n+\n+                    // If there was no pack, ignore the response\n+                    if (scanResponseGson.pack == null) {\n+                        logger.debug(\"Invalid packet format, ignore\");\n+                        continue;\n+                    }\n+\n+                    // Decrypt message - a a GreeException is thrown when something went wrong\n+                    scanResponseGson.decryptedPack = GreeCryptoUtil\n+                            .decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(), scanResponseGson.pack);\n+                    String decryptedMsg = GreeCryptoUtil.decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\n+                            scanResponseGson.pack);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5f5f5bb2d68d48b8927f43e1403cf06abcf4ea1d"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzEwNTg4Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                String modifiedSentence = new String(receivePacket.getData(), \"UTF-8\");\n          \n          \n            \n                                StringReader stringReader = new StringReader(modifiedSentence);\n          \n          \n            \n                                GreeScanResponseDTO scanResponseGson = gson.fromJson(new JsonReader(stringReader),\n          \n          \n            \n                                String modifiedSentence = new String(receivePacket.getData(), \"UTF-8\");\n          \n          \n            \n                                GreeScanResponseDTO scanResponseGson = gson.fromJson(modifiedSentence,", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r437105886", "createdAt": "2020-06-09T02:40:45Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeDeviceFinder.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.discovery;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeScanReponsePackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanRequestDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponseDTO;\n+import org.openhab.binding.gree.internal.handler.GreeAirDevice;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDeviceFinder provides functionality for searching for GREE Airconditioners on the network and keeping a list\n+ * of found devices.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeDeviceFinder {\n+    private final Logger logger = LoggerFactory.getLogger(GreeDeviceFinder.class);\n+\n+    protected final InetAddress ipAddress;\n+    protected HashMap<String, GreeAirDevice> deviceTable = new HashMap<>();\n+\n+    public GreeDeviceFinder() {\n+        ipAddress = InetAddress.getLoopbackAddress(); // dummy\n+    }\n+\n+    public GreeDeviceFinder(String broadcastAddress) throws UnknownHostException {\n+        ipAddress = InetAddress.getByName(broadcastAddress);\n+    }\n+\n+    public void scan(Optional<DatagramSocket> socket, boolean scanNetwork) throws GreeException {\n+        validateSocket(socket);\n+        byte[] sendData = new byte[1024];\n+        byte[] receiveData = new byte[1024];\n+\n+        // Send the Scan message\n+        GreeScanRequestDTO scanGson = new GreeScanRequestDTO();\n+        scanGson.t = \"scan\";\n+\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        Gson gson = gsonBuilder.create();\n+        String scanReq = gson.toJson(scanGson);\n+        sendData = scanReq.getBytes();\n+\n+        logger.trace(\"Sending scan packet to {}\", ipAddress.getHostAddress());\n+        try {\n+            DatagramSocket clientSocket = socket.get();\n+            clientSocket.setSoTimeout(DISCOVERY_TIMEOUT_MS);\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, ipAddress, DISCOVERY_TIMEOUT_MS);\n+            clientSocket.send(sendPacket);\n+\n+            // Loop for respnses from devices until we get a timeout.\n+            boolean scanning = true;\n+            int retries = MAX_SCAN_CYCLES;\n+            while (scanning && (retries > 0)) {\n+                // Receive a response\n+                DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+                try {\n+                    clientSocket.receive(receivePacket);\n+                    InetAddress remoteAddress = receivePacket.getAddress();\n+                    int remotePort = receivePacket.getPort();\n+\n+                    // Read the response\n+                    String modifiedSentence = new String(receivePacket.getData(), \"UTF-8\");\n+                    StringReader stringReader = new StringReader(modifiedSentence);\n+                    GreeScanResponseDTO scanResponseGson = gson.fromJson(new JsonReader(stringReader),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5f5f5bb2d68d48b8927f43e1403cf06abcf4ea1d"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzEwNjU2Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return mScanResponseGson.isPresent()\n          \n          \n            \n                            ? mScanResponseGson.get().packJson.series + \" \" + mScanResponseGson.get().packJson.model\n          \n          \n            \n                            : \"\";\n          \n          \n            \n                    return mScanResponseGson.map(response -> response.packJson.series + \" \" + response.packJson.model).orElse(\"\");", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r437106566", "createdAt": "2020-06-09T02:43:34Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,721 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecCommandDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePackDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\n+ * device specific attributes as well a the functionality for the Air Conditioner\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeAirDevice {\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\n+    private boolean isBound = false;\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\n+    private int port = 0;\n+    private String encKey = \"\";\n+    private Optional<GreeScanResponseDTO> mScanResponseGson = Optional.empty();\n+    private Optional<GreeBindResponseDTO> bindResponseGson = Optional.empty();\n+    private Optional<GreeStatusResponseDTO> statusResponseGson = Optional.empty();\n+    private Optional<GreeStatusResponsePackDTO> prevStatusResponsePackGson = Optional.empty();\n+\n+    public boolean getIsBound() {\n+        return isBound;\n+    }\n+\n+    public void setIsBound(boolean isBound) {\n+        this.isBound = isBound;\n+    }\n+\n+    public InetAddress getAddress() {\n+        return ipAddress;\n+    }\n+\n+    public void setAddress(InetAddress address) {\n+        this.ipAddress = address;\n+    }\n+\n+    public int getPort() {\n+        return port;\n+    }\n+\n+    public void setPort(int port) {\n+        this.port = port;\n+    }\n+\n+    public String getKey() {\n+        return encKey;\n+    }\n+\n+    public String getId() {\n+        return mScanResponseGson.isPresent() ? mScanResponseGson.get().packJson.mac : \"\";\n+    }\n+\n+    public String getName() {\n+        return mScanResponseGson.isPresent() ? mScanResponseGson.get().packJson.name : \"\";\n+    }\n+\n+    public String getVendor() {\n+        return mScanResponseGson.isPresent()\n+                ? mScanResponseGson.get().packJson.brand + \" \" + mScanResponseGson.get().packJson.vender\n+                : \"\";\n+    }\n+\n+    public String getModel() {\n+        return mScanResponseGson.isPresent()\n+                ? mScanResponseGson.get().packJson.series + \" \" + mScanResponseGson.get().packJson.model\n+                : \"\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5f5f5bb2d68d48b8927f43e1403cf06abcf4ea1d"}, "originalPosition": 116}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI3NDUxMDE4", "url": "https://github.com/openhab/openhab-addons/pull/7504#pullrequestreview-427451018", "createdAt": "2020-06-09T18:54:59Z", "commit": {"oid": "5f5f5bb2d68d48b8927f43e1403cf06abcf4ea1d"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxODo1NDo1OVrOGhX9xg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wOVQxOTowNDoxNVrOGhYSaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY0ODgzOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        String encrytpedMessage = new String(newencoder.encode(bytePlainText), \"UTF-8\");\n          \n          \n            \n                        return encrytpedMessage.substring(0, encrytpedMessage.length());\n          \n          \n            \n                        return new String(newencoder.encode(bytePlainText), \"UTF-8\");", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r437648838", "createdAt": "2020-06-09T18:54:59Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/GreeCryptoUtil.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal;\n+\n+import java.io.UnsupportedEncodingException;\n+import java.security.InvalidKeyException;\n+import java.security.Key;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Base64;\n+\n+import javax.crypto.BadPaddingException;\n+import javax.crypto.Cipher;\n+import javax.crypto.IllegalBlockSizeException;\n+import javax.crypto.NoSuchPaddingException;\n+import javax.crypto.spec.SecretKeySpec;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The CryptoUtil class provides functionality for encrypting and decrypting\n+ * messages sent to and from the Air Conditioner\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeCryptoUtil {\n+    private static final String AES_KEY = \"a3K8Bx%2r8Y7#xDh\";\n+\n+    public static String GetAESGeneralKey() {\n+        return AES_KEY;\n+    }\n+\n+    public static byte[] getAESGeneralKeyByteArray() {\n+        return AES_KEY.getBytes();\n+    }\n+\n+    public static String decryptPack(byte[] keyarray, String message) throws GreeException {\n+        try {\n+            Key key = new SecretKeySpec(keyarray, \"AES\");\n+            Base64.Decoder decoder = Base64.getDecoder();\n+            byte[] imageByte = decoder.decode(message);\n+\n+            Cipher aesCipher = Cipher.getInstance(\"AES\");\n+            aesCipher.init(Cipher.DECRYPT_MODE, key);\n+            byte[] bytePlainText = aesCipher.doFinal(imageByte);\n+\n+            return new String(bytePlainText, \"UTF-8\");\n+        } catch (NoSuchAlgorithmException | UnsupportedEncodingException | NoSuchPaddingException | BadPaddingException\n+                | InvalidKeyException | IllegalBlockSizeException ex) {\n+            throw new GreeException(\"Decryption of recieved data failed\", ex);\n+        }\n+    }\n+\n+    public static String encryptPack(byte[] keyarray, String message) throws GreeException {\n+        try {\n+            Key key = new SecretKeySpec(keyarray, \"AES\");\n+            Cipher aesCipher = Cipher.getInstance(\"AES\");\n+            aesCipher.init(Cipher.ENCRYPT_MODE, key);\n+            byte[] bytePlainText = aesCipher.doFinal(message.getBytes());\n+\n+            Base64.Encoder newencoder = Base64.getEncoder();\n+            String encrytpedMessage = new String(newencoder.encode(bytePlainText), \"UTF-8\");\n+            return encrytpedMessage.substring(0, encrytpedMessage.length());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5f5f5bb2d68d48b8927f43e1403cf06abcf4ea1d"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY0OTk3Nw==", "bodyText": "It is preferred to reuse Gson instances. Can you make a static final instance and use that instead?", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r437649977", "createdAt": "2020-06-09T18:56:43Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeDeviceFinder.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.discovery;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeScanReponsePackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanRequestDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponseDTO;\n+import org.openhab.binding.gree.internal.handler.GreeAirDevice;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDeviceFinder provides functionality for searching for GREE Airconditioners on the network and keeping a list\n+ * of found devices.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeDeviceFinder {\n+    private final Logger logger = LoggerFactory.getLogger(GreeDeviceFinder.class);\n+\n+    protected final InetAddress ipAddress;\n+    protected HashMap<String, GreeAirDevice> deviceTable = new HashMap<>();\n+\n+    public GreeDeviceFinder() {\n+        ipAddress = InetAddress.getLoopbackAddress(); // dummy\n+    }\n+\n+    public GreeDeviceFinder(String broadcastAddress) throws UnknownHostException {\n+        ipAddress = InetAddress.getByName(broadcastAddress);\n+    }\n+\n+    public void scan(Optional<DatagramSocket> socket, boolean scanNetwork) throws GreeException {\n+        validateSocket(socket);\n+        byte[] sendData = new byte[1024];\n+        byte[] receiveData = new byte[1024];\n+\n+        // Send the Scan message\n+        GreeScanRequestDTO scanGson = new GreeScanRequestDTO();\n+        scanGson.t = \"scan\";\n+\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        Gson gson = gsonBuilder.create();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5f5f5bb2d68d48b8927f43e1403cf06abcf4ea1d"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY1MTMwOQ==", "bodyText": "Why not make this an osgi component so that the DiscoveryService and HandlerFactory can just get a reference to it in their constructors?", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r437651309", "createdAt": "2020-06-09T18:59:05Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/GreeTranslationProvider.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal;\n+\n+import java.util.Locale;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.i18n.LocaleProvider;\n+import org.eclipse.smarthome.core.i18n.TranslationProvider;\n+import org.osgi.framework.Bundle;\n+\n+/**\n+ * {@link GreeTranslationProvider} provides i18n message lookup\n+ *\n+ * @author Markus Michels - Initial contribution\n+ */\n+@NonNullByDefault\n+public class GreeTranslationProvider {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5f5f5bb2d68d48b8927f43e1403cf06abcf4ea1d"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY1MTQzNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                protected HashMap<String, GreeAirDevice> deviceTable = new HashMap<>();\n          \n          \n            \n                protected Map<String, GreeAirDevice> deviceTable = new HashMap<>();", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r437651437", "createdAt": "2020-06-09T18:59:21Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeDeviceFinder.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.discovery;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeScanReponsePackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanRequestDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponseDTO;\n+import org.openhab.binding.gree.internal.handler.GreeAirDevice;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDeviceFinder provides functionality for searching for GREE Airconditioners on the network and keeping a list\n+ * of found devices.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeDeviceFinder {\n+    private final Logger logger = LoggerFactory.getLogger(GreeDeviceFinder.class);\n+\n+    protected final InetAddress ipAddress;\n+    protected HashMap<String, GreeAirDevice> deviceTable = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5f5f5bb2d68d48b8927f43e1403cf06abcf4ea1d"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY1MjM2MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    scheduler.execute(() -> {\n          \n          \n            \n                        startScan();\n          \n          \n            \n                    });\n          \n          \n            \n                    scheduler.execute(this::startScan);", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r437652360", "createdAt": "2020-06-09T19:00:54Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeDiscoveryService.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.gree.internal.discovery;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramSocket;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.i18n.LocaleProvider;\n+import org.eclipse.smarthome.core.i18n.TranslationProvider;\n+import org.eclipse.smarthome.core.net.NetworkAddressService;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.handler.GreeAirDevice;\n+import org.osgi.framework.Bundle;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Modified;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link GreeDiscoveryService} implements the device discovery service. UDP broadtcast ius used to find the devices on\n+ * the local subnet.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+@Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.gree\")\n+public class GreeDiscoveryService extends AbstractDiscoveryService {\n+    private static final int TIMEOUT_SEC = 10;\n+    private final Logger logger = LoggerFactory.getLogger(GreeDiscoveryService.class);\n+    private final GreeTranslationProvider messages;\n+    private final String broadcastAddress;\n+\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+\n+    @Activate\n+    public GreeDiscoveryService(@Reference NetworkAddressService networkAddressService,\n+            @Reference LocaleProvider localeProvider, @Reference TranslationProvider i18nProvider) {\n+        super(SUPPORTED_THING_TYPES_UIDS, TIMEOUT_SEC);\n+        Bundle bundle = FrameworkUtil.getBundle(this.getClass());\n+        messages = new GreeTranslationProvider(bundle.getBundleContext().getBundle(), i18nProvider, localeProvider);\n+        String ip = networkAddressService.getConfiguredBroadcastAddress();\n+        broadcastAddress = ip != null ? ip : \"\";\n+    }\n+\n+    @Override\n+    protected void activate(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.activate(configProperties);\n+    }\n+\n+    @Override\n+    @Modified\n+    protected void modified(@Nullable Map<String, @Nullable Object> configProperties) {\n+        super.modified(configProperties);\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        // It's very unusual that a new unit gets installed frequently so we run the discovery once when the binding is\n+        // started, but not frequently\n+        scheduler.execute(() -> {\n+            startScan();\n+        });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5f5f5bb2d68d48b8927f43e1403cf06abcf4ea1d"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY1MzAxNw==", "bodyText": "Please use camelcase for names.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Optional<GreeScanResponseDTO> mScanResponseGson = Optional.empty();\n          \n          \n            \n                private Optional<GreeScanResponseDTO> scanResponseGson = Optional.empty();", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r437653017", "createdAt": "2020-06-09T19:02:10Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,721 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecCommandDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePackDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\n+ * device specific attributes as well a the functionality for the Air Conditioner\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeAirDevice {\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\n+    private boolean isBound = false;\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\n+    private int port = 0;\n+    private String encKey = \"\";\n+    private Optional<GreeScanResponseDTO> mScanResponseGson = Optional.empty();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5f5f5bb2d68d48b8927f43e1403cf06abcf4ea1d"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY1NDEyMQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        String columns[] = statusResponseGson.get().packJson.cols;\n          \n          \n            \n                        Integer values[] = statusResponseGson.get().packJson.dat;\n          \n          \n            \n                        String[] columns = statusResponseGson.get().packJson.cols;\n          \n          \n            \n                        Integer[] values = statusResponseGson.get().packJson.dat;", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r437654121", "createdAt": "2020-06-09T19:04:15Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,721 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecCommandDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePackDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\n+ * device specific attributes as well a the functionality for the Air Conditioner\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeAirDevice {\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\n+    private final static Charset UTF8_CHARSET = Charset.forName(\"UTF-8\");\n+    private final static HashMap<String, HashMap<String, Integer>> tempRanges = createTempRangeMap();\n+    private boolean isBound = false;\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\n+    private int port = 0;\n+    private String encKey = \"\";\n+    private Optional<GreeScanResponseDTO> mScanResponseGson = Optional.empty();\n+    private Optional<GreeBindResponseDTO> bindResponseGson = Optional.empty();\n+    private Optional<GreeStatusResponseDTO> statusResponseGson = Optional.empty();\n+    private Optional<GreeStatusResponsePackDTO> prevStatusResponsePackGson = Optional.empty();\n+\n+    public boolean getIsBound() {\n+        return isBound;\n+    }\n+\n+    public void setIsBound(boolean isBound) {\n+        this.isBound = isBound;\n+    }\n+\n+    public InetAddress getAddress() {\n+        return ipAddress;\n+    }\n+\n+    public void setAddress(InetAddress address) {\n+        this.ipAddress = address;\n+    }\n+\n+    public int getPort() {\n+        return port;\n+    }\n+\n+    public void setPort(int port) {\n+        this.port = port;\n+    }\n+\n+    public String getKey() {\n+        return encKey;\n+    }\n+\n+    public String getId() {\n+        return mScanResponseGson.isPresent() ? mScanResponseGson.get().packJson.mac : \"\";\n+    }\n+\n+    public String getName() {\n+        return mScanResponseGson.isPresent() ? mScanResponseGson.get().packJson.name : \"\";\n+    }\n+\n+    public String getVendor() {\n+        return mScanResponseGson.isPresent()\n+                ? mScanResponseGson.get().packJson.brand + \" \" + mScanResponseGson.get().packJson.vender\n+                : \"\";\n+    }\n+\n+    public String getModel() {\n+        return mScanResponseGson.isPresent()\n+                ? mScanResponseGson.get().packJson.series + \" \" + mScanResponseGson.get().packJson.model\n+                : \"\";\n+    }\n+\n+    public GreeScanResponseDTO getScanResponseGson() {\n+        return mScanResponseGson.get();\n+    }\n+\n+    public void setScanResponseGson(GreeScanResponseDTO gson) {\n+        mScanResponseGson = Optional.of(gson);\n+    }\n+\n+    public GreeBindResponseDTO getBindResponseGson() {\n+        return bindResponseGson.get();\n+    }\n+\n+    public GreeStatusResponseDTO getGreeStatusResponse4Gson() {\n+        return statusResponseGson.get();\n+    }\n+\n+    public void bindWithDevice(Optional<DatagramSocket> socket) throws GreeException {\n+        validateSocket(socket);\n+        byte[] sendData = new byte[1024];\n+        byte[] receiveData = new byte[347];\n+        Gson gson = new Gson();\n+\n+        try {\n+            // Prep the Binding Request pack\n+            GreeBindRequestPackDTO bindReqPackGson = new GreeBindRequestPackDTO();\n+            bindReqPackGson.mac = getId();\n+            bindReqPackGson.t = \"bind\";\n+            bindReqPackGson.uid = 0;\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\n+\n+            // Now Encrypt the Binding Request pack\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\n+                    bindReqPackStr);\n+\n+            // Prep the Binding Request\n+            GreeBindRequestDTO bindReqGson = new GreeBindRequestDTO();\n+            bindReqGson.cid = \"app\";\n+            bindReqGson.i = 1;\n+            bindReqGson.t = \"pack\";\n+            bindReqGson.uid = 0;\n+            bindReqGson.tcid = getId();\n+            bindReqGson.pack = new String(encryptedBindReqPacket.getBytes(), UTF8_CHARSET);\n+            String bindReqStr = gson.toJson(bindReqGson);\n+            sendData = bindReqStr.getBytes();\n+\n+            // Now Send the request\n+            DatagramSocket clientSocket = socket.get();\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\n+            clientSocket.send(sendPacket);\n+\n+            // Recieve a response\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+            clientSocket.receive(receivePacket);\n+            String modifiedSentence = new String(receivePacket.getData(), UTF8_CHARSET);\n+\n+            // Read the response\n+            StringReader stringReader = new StringReader(modifiedSentence);\n+            GreeBindResponseDTO resp = gson.fromJson(new JsonReader(stringReader), GreeBindResponseDTO.class);\n+            resp.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(), resp.pack);\n+\n+            // Create the JSON to hold the response values\n+            stringReader = new StringReader(resp.decryptedPack);\n+            resp.packJson = gson.fromJson(new JsonReader(stringReader), GreeBindResponsePackDTO.class);\n+\n+            // Now set the key and flag to indicate the bind was succesful\n+            encKey = resp.packJson.key;\n+\n+            // save the outcome\n+            bindResponseGson = Optional.of(resp);\n+            setIsBound(true);\n+        } catch (IOException e) {\n+            throw new GreeException(\"Unable to bind to device\", e);\n+        }\n+    }\n+\n+    private void validateSocket(Optional<DatagramSocket> socket) {\n+        if (!socket.isPresent()) {\n+            throw new IllegalArgumentException(\"Socket not initialized!\");\n+        }\n+    }\n+\n+    public void setDevicePower(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 1)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Pow\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void SetDeviceMode(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 4)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Mod\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceSwingUpDown(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\n+        if (!getIsBound() || (value < 0 || value > 11) || (value > 6 && value < 10)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"SwUpDn\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceSwingLeftRight(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        // Only values 0,1,2,3,4,5,6 allowed\n+        if (!getIsBound() || (value < 0) || (value > 6)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"SwingLfRig\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    /**\n+     * Only allow this to happen if this device has been bound and values are valid\n+     * Possible values are :\n+     * 0 : Auto\n+     * 1 : Low\n+     * 2 : Medium Low\n+     * 3 : Medium\n+     * 4 : Medium High\n+     * 5 : High\n+     */\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, int value) throws GreeException {\n+        if (!getIsBound() || (value < 0 || value > 5)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"WdSpd\", value);\n+        parameters.put(\"Quiet\", 0);\n+        parameters.put(\"Tur\", 0);\n+        parameters.put(\"NoiseSet\", 0);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceTurbo(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 1)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Tur\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setQuietMode(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 2)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Quiet\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public int getDeviceTurbo() {\n+        return getIntStatusVal(\"Tur\");\n+    }\n+\n+    public void setDeviceLight(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound and values are valid\n+        if (!getIsBound() || (value < 0 || value > 1)) {\n+            throw new GreeException(\"Device not bound or value out of range!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Lig\", value);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    /**\n+     * Create Hash Look Up for C and F\n+     * Temperature Ranges for gree A/C units (f_range = {86,61}, c_range={16,30}\n+     */\n+    private static HashMap<String, HashMap<String, Integer>> createTempRangeMap() {\n+        HashMap<String, HashMap<String, Integer>> tempRanges = new HashMap<>();\n+        HashMap<String, Integer> hmf = new HashMap<>();\n+        HashMap<String, Integer> hmc = new HashMap<>();\n+\n+        hmf.put(\"min\", 61); // F\n+        hmf.put(\"max\", 86);\n+        tempRanges.put(\"F\", hmf);\n+\n+        hmc.put(\"min\", 16); // C\n+        hmc.put(\"max\", 30);\n+        tempRanges.put(\"C\", hmc);\n+\n+        return tempRanges;\n+    }\n+\n+    /**\n+     * Checks input ranges for validity and TempUn for validity\n+     * Uses newVal as priority and tries to validate and determine intent\n+     * For example if value is 75 and TempUn says Celsius, change TempUn to Fahrenheit\n+     */\n+    private int[] validateTemperatureRangeForTempSet(int newValIn, @Nullable Integer CorFIn) {\n+        final String[] minMaxLUT = { \"max\", \"min\" }; // looks up 0 = C = max, 1 = F = min\n+        final String[] tempScaleLUT = { \"C\", \"F\" }; // Look Up Table used to convert TempUn integer 0,1 to \"C\" to \"F\"\n+                                                    // string for hashmap\n+        HashMap<String, Integer> nullCorFLUT = new HashMap<>(); // simple look up table for logic\n+        nullCorFLUT.put(\"C\", 0);\n+        nullCorFLUT.put(\"F\", 1);\n+        nullCorFLUT.put(\"INVALID\", 0);\n+\n+        String validRangeCorF; // stores if the input range is a valid C or F temperature\n+\n+        // force to global min/max\n+        int newVal = (Math.max(newValIn, Math.min(tempRanges.get(\"C\").get(\"min\"), tempRanges.get(\"F\").get(\"min\"))));\n+        newVal = Math.min(newVal, Math.max(tempRanges.get(\"C\").get(\"max\"), tempRanges.get(\"F\").get(\"max\")));\n+\n+        if ((newVal >= tempRanges.get(\"C\").get(\"min\")) && (newVal <= tempRanges.get(\"C\").get(\"max\"))) {\n+            validRangeCorF = \"C\";\n+        } else if ((newVal >= tempRanges.get(\"F\").get(\"min\")) && (newVal <= tempRanges.get(\"F\").get(\"max\"))) {\n+            validRangeCorF = \"F\";\n+        } else {\n+            logger.warn(\"Input Temp request {} is invalid\", newVal);\n+            validRangeCorF = \"INVALID\";\n+        }\n+\n+        // if CorF wasnt initialized or is null set it from lookup\n+        Integer CorF = CorFIn != null ? CorFIn : nullCorFLUT.get(validRangeCorF);\n+\n+        if ((CorF == 1) && validRangeCorF.equals(\"C\")) {\n+            CorF = 0; // input temp takes priority\n+        } else if ((CorF == 0) && validRangeCorF.equals(\"F\")) {\n+            CorF = 1; // input temp takes priority\n+        } else if (validRangeCorF.equals(\"INVALID\")) {\n+            // force min or max temp based on CorF scale to be used\n+            newVal = tempRanges.get(tempScaleLUT[CorF]).get(minMaxLUT[CorF]);\n+        }\n+\n+        return new int[] { newVal, CorF };\n+    }\n+\n+    public void setDeviceTempSet(DatagramSocket clientSocket, int value) throws GreeException {\n+        // **value** : set temperature in degrees celsius or Fahrenheit\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+        int newVal = value;\n+        int outVal = value;\n+        // Get Celsius or Fahrenheit from status message\n+        Integer CorF = getIntStatusVal(\"TemUn\");\n+        // TODO put a param in openhab to allow setting this from the config\n+\n+        // If commanding Fahrenheit set halfStep to 1 or 0 to tell the A/C which F integer\n+        // temperature to use as celsius alone is ambigious\n+        int halfStep = 0; // default to C\n+\n+        int[] retList = validateTemperatureRangeForTempSet(newVal, CorF);\n+        newVal = retList[0];\n+        CorF = retList[1];\n+\n+        if (CorF == 1) { // If Fahrenheit,\n+            // value argument is degrees F, convert Fahrenheit to Celsius,\n+            // SetTem input to A/C always in Celsius despite passing in 1 to TemUn\n+            outVal = (int) (Math.round((newVal - 32.) * 5.0 / 9.0)); // Integer Truncated\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\n+            // F = [68. , 69. , 70. , 71. , 72. , 73. , 74. , 75. , 76. , 77. , 78. , 79. , 80. , 81. , 82. , 83. ,\n+            // 84. , 85. , 86. ]\n+            // C = [20.0, 20.5, 21.1, 21.6, 22.2, 22.7, 23.3, 23.8, 24.4, 25.0, 25.5, 26.1, 26.6, 27.2, 27.7, 28.3,\n+            // 28.8, 29.4, 30.0]\n+            // TemSet = [20, 21, 21, 22, 22, 23, 23, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 30, 30]\n+            // TemRec = [ 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]\n+            // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\n+            // subtract the float version - the int version to get the fractional difference\n+            // if the difference is positive set halfStep to 1, negative to 0\n+            halfStep = ((((newVal - 32.) * 5.0 / 9.0) - outVal) > 0) ? 1 : 0;\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"TemUn\", CorF);\n+        parameters.put(\"SetTem\", outVal);\n+        parameters.put(\"TemRec\", halfStep);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceAir(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Air\", value);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceDry(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Blo\", value);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceHealth(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"Health\", value);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDevicePwrSaving(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(\"SvSt\", value);\n+        parameters.put(\"WdSpd\", 0);\n+        parameters.put(\"Quiet\", 0);\n+        parameters.put(\"Tur\", 0);\n+        parameters.put(\"SwhSlp\", 0);\n+        parameters.put(\"SlpMod\", 0);\n+\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public int getIntStatusVal(String valueName) {\n+        /*\n+         * Note : Values can be:\n+         * \"Pow\": Power (0 or 1)\n+         * \"Mod\": Mode: Auto: 0, Cool: 1, Dry: 2, Fan: 3, Heat: 4\n+         * \"SetTem\": Requested Temperature\n+         * \"WdSpd\": Fan Speed : Low:1, Medium Low:2, Medium :3, Medium High :4, High :5\n+         * \"Air\": Air Mode Enabled\n+         * \"Blo\": Dry\n+         * \"Health\": Health\n+         * \"SwhSlp\": Sleep\n+         * \"SlpMod\": ???\n+         * \"Lig\": Light On\n+         * \"SwingLfRig\": Swing Left Right\n+         * \"SwUpDn\": Swing Up Down: // Ceiling:0, Upwards : 10, Downwards : 11, Full range : 1\n+         * \"Quiet\": Quiet mode\n+         * \"Tur\": Turbo\n+         * \"StHt\": 0,\n+         * \"TemUn\": Temperature unit, 0 for Celsius, 1 for Fahrenheit\n+         * \"HeatCoolType\"\n+         * \"TemRec\": (0 or 1), Send with SetTem, when TemUn==1, distinguishes between upper and lower integer Fahrenheit\n+         * temp\n+         * \"SvSt\": Power Saving\n+         */\n+        // Find the valueName in the Returned Status object\n+        String columns[] = statusResponseGson.get().packJson.cols;\n+        Integer values[] = statusResponseGson.get().packJson.dat;\n+        List<String> colList = new ArrayList<>(Arrays.asList(columns));\n+        List<Integer> valList = new ArrayList<>(Arrays.asList(values));\n+        int valueArrayposition = colList.indexOf(valueName);\n+        if (valueArrayposition == -1) {\n+            return -1;\n+        }\n+\n+        // Now get the Corresponding value\n+        Integer value = valList.get(valueArrayposition);\n+        return value;\n+    }\n+\n+    public boolean hasStatusValChanged(String valueName) throws GreeException {\n+        if (!prevStatusResponsePackGson.isPresent()) {\n+            return true; // update value if there is no previous one\n+        }\n+        // Find the valueName in the Current Status object\n+        String currcolumns[] = statusResponseGson.get().packJson.cols;\n+        Integer currvalues[] = statusResponseGson.get().packJson.dat;\n+        List<String> currcolList = new ArrayList<>(Arrays.asList(currcolumns));\n+        List<Integer> currvalList = new ArrayList<>(Arrays.asList(currvalues));\n+        int currvalueArrayposition = currcolList.indexOf(valueName);\n+        if (currvalueArrayposition == -1) {\n+            throw new GreeException(\"Unable to decode device status\");\n+        }\n+        // Now get the Corresponding value\n+        int currvalue = currvalList.get(currvalueArrayposition);\n+\n+        // Find the valueName in the Previous Status object\n+        String prevcolumns[] = prevStatusResponsePackGson.get().cols;\n+        Integer prevvalues[] = prevStatusResponsePackGson.get().dat;\n+        List<String> prevcolList = new ArrayList<>(Arrays.asList(prevcolumns));\n+        List<Integer> prevvalList = new ArrayList<>(Arrays.asList(prevvalues));\n+        int prevvalueArrayposition = prevcolList.indexOf(valueName);\n+        if (prevvalueArrayposition == -1) {\n+            throw new GreeException(\"Unable to get status value\");\n+        }\n+        // Now get the Corresponding value\n+        int prevvalue = prevvalList.get(prevvalueArrayposition);\n+\n+        // Finally Compare the values\n+        return currvalue != prevvalue;\n+    }\n+\n+    protected void executeCommand(DatagramSocket clientSocket, HashMap<String, Integer> parameters)\n+            throws GreeException {\n+        byte[] sendData = new byte[1024];\n+        byte[] receiveData = new byte[1024];\n+        Gson gson = new Gson();\n+\n+        try {\n+            // Convert the parameter map values to arrays\n+            String[] keyArray = parameters.keySet().toArray(new String[0]);\n+            Integer[] valueArray = parameters.values().toArray(new Integer[0]);\n+\n+            // Prep the Command Request pack\n+            GreeExecuteCommandPackDTO execCmdPackGson = new GreeExecuteCommandPackDTO();\n+            execCmdPackGson.opt = keyArray;\n+            execCmdPackGson.p = valueArray;\n+            execCmdPackGson.t = \"cmd\";\n+            String execCmdPackStr = gson.toJson(execCmdPackGson);\n+\n+            // Now Encrypt the Binding Request pack\n+            String encryptedCommandReqPacket = GreeCryptoUtil.encryptPack(getKey().getBytes(), execCmdPackStr);\n+            // String unencryptedCommandReqPacket = CryptoUtil.decryptPack(device.getKey().getBytes(),\n+            // encryptedCommandReqPacket);\n+\n+            // Prep the Command Request\n+            GreeExecCommandDTO execCmdGson = new GreeExecCommandDTO();\n+            execCmdGson.cid = \"app\";\n+            execCmdGson.i = 0;\n+            execCmdGson.t = \"pack\";\n+            execCmdGson.uid = 0;\n+            execCmdGson.tcid = getId();\n+            execCmdGson.pack = new String(encryptedCommandReqPacket.getBytes(), UTF8_CHARSET);\n+            String execCmdStr = gson.toJson(execCmdGson);\n+            sendData = execCmdStr.getBytes();\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\n+            clientSocket.send(sendPacket);\n+\n+            // Recieve a response\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+            clientSocket.receive(receivePacket);\n+            String modifiedSentence = new String(receivePacket.getData(), UTF8_CHARSET);\n+\n+            // Read the response\n+            StringReader stringReader = new StringReader(modifiedSentence);\n+            GreeExecResponseDTO execResponseGson = gson.fromJson(new JsonReader(stringReader),\n+                    GreeExecResponseDTO.class);\n+            execResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(this.getKey().getBytes(),\n+                    execResponseGson.pack);\n+\n+            // Create the JSON to hold the response values\n+            stringReader = new StringReader(execResponseGson.decryptedPack);\n+            execResponseGson.packJson = gson.fromJson(new JsonReader(stringReader), GreeExecResponsePackDTO.class);\n+        } catch (IOException e) {\n+            throw new GreeException(\"Exception on command execution\", e);\n+        }\n+    }\n+\n+    public void getDeviceStatus(DatagramSocket clientSocket) throws GreeException {\n+        Gson gson = new Gson();\n+        byte[] sendData = new byte[1024];\n+        byte[] receiveData = new byte[1024];\n+\n+        try {\n+            // Set the values in the HashMap\n+            ArrayList<String> columns = new ArrayList<>();\n+            columns.add(\"Pow\");\n+            columns.add(\"Mod\");\n+            columns.add(\"SetTem\");\n+            columns.add(\"WdSpd\");\n+            columns.add(\"Air\");\n+            columns.add(\"Blo\");\n+            columns.add(\"Health\");\n+            columns.add(\"SwhSlp\");\n+            columns.add(\"Lig\");\n+            columns.add(\"SwingLfRig\");\n+            columns.add(\"SwUpDn\");\n+            columns.add(\"Quiet\");\n+            columns.add(\"Tur\");\n+            columns.add(\"StHt\");\n+            columns.add(\"TemUn\");\n+            columns.add(\"HeatCoolType\");\n+            columns.add(\"TemRec\");\n+            columns.add(\"SvSt\");\n+            columns.add(\"NoiseSet\");\n+\n+            // Convert the parameter map values to arrays\n+            String[] colArray = columns.toArray(new String[0]);\n+\n+            // Prep the Command Request pack\n+            GreeReqStatusPackDTO reqStatusPackGson = new GreeReqStatusPackDTO();\n+            reqStatusPackGson.t = \"status\";\n+            reqStatusPackGson.cols = colArray;\n+            reqStatusPackGson.mac = getId();\n+            String reqStatusPackStr = gson.toJson(reqStatusPackGson);\n+\n+            // Now Encrypt the Binding Request pack\n+            String encryptedStatusReqPacket = GreeCryptoUtil.encryptPack(getKey().getBytes(), reqStatusPackStr);\n+\n+            // Prep the Status Request\n+            GreeReqStatusDTO reqStatusGson = new GreeReqStatusDTO();\n+            reqStatusGson.cid = \"app\";\n+            reqStatusGson.i = 0;\n+            reqStatusGson.t = \"pack\";\n+            reqStatusGson.uid = 0;\n+            reqStatusGson.tcid = getId();\n+            reqStatusGson.pack = new String(encryptedStatusReqPacket.getBytes(), UTF8_CHARSET);\n+            String execCmdStr = gson.toJson(reqStatusGson);\n+            sendData = execCmdStr.getBytes();\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, getAddress(), getPort());\n+            clientSocket.send(sendPacket);\n+\n+            // Recieve a response\n+            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+            clientSocket.receive(receivePacket);\n+            String modifiedSentence = new String(receivePacket.getData(), UTF8_CHARSET);\n+\n+            // Keep a copy of the old response to be used to check if values have changed\n+            // If first time running, there will not be a previous GreeStatusResponsePack4Gson\n+            if (statusResponseGson.isPresent() && statusResponseGson.get().packJson != null) {\n+                prevStatusResponsePackGson = Optional\n+                        .of(new GreeStatusResponsePackDTO(statusResponseGson.get().packJson));\n+            }\n+\n+            // Read the response\n+            StringReader stringReader = new StringReader(modifiedSentence);\n+            GreeStatusResponseDTO resp = gson.fromJson(new JsonReader(stringReader), GreeStatusResponseDTO.class);\n+            resp.decryptedPack = GreeCryptoUtil.decryptPack(this.getKey().getBytes(), resp.pack);\n+            logger.trace(\"Response from device: {}\", resp.decryptedPack);\n+\n+            // Create the JSON to hold the response values\n+            stringReader = new StringReader(resp.decryptedPack);\n+\n+            resp.packJson = gson.fromJson(new JsonReader(stringReader), GreeStatusResponsePackDTO.class);\n+\n+            // save the results\n+            statusResponseGson = Optional.of(resp);\n+            updateTempFtoC();\n+        } catch (IOException e) {\n+            throw new GreeException(\"I/O exception while receiving data\", e);\n+        }\n+    }\n+\n+    private void updateTempFtoC() {\n+        // Status message back from A/C always reports degrees C\n+        // If using Fahrenheit, us SetTem, TemUn and TemRec to reconstruct the Fahrenheit temperature\n+        // Get Celsius or Fahrenheit from status message\n+        int CorF = getIntStatusVal(\"TemUn\");\n+        int newVal = getIntStatusVal(\"SetTem\");\n+        int halfStep = getIntStatusVal(\"TemRec\");\n+\n+        if ((CorF == -1) || (newVal == -1) || (halfStep == -1)) {\n+            throw new IllegalArgumentException(\"SetTem,TemUn or TemRec is invalid, not performing conversion\");\n+        } else if (CorF == 1) { // convert SetTem to Fahrenheit\n+            // Find the valueName in the Returned Status object\n+            String columns[] = statusResponseGson.get().packJson.cols;\n+            Integer values[] = statusResponseGson.get().packJson.dat;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5f5f5bb2d68d48b8927f43e1403cf06abcf4ea1d"}, "originalPosition": 704}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e2fad291715bed6653cd3b0294109aeb3bddf3a4", "author": {"user": {"login": "markus7017", "name": "Markus Michels"}}, "url": "https://github.com/openhab/openhab-addons/commit/e2fad291715bed6653cd3b0294109aeb3bddf3a4", "committedDate": "2020-06-09T20:31:58Z", "message": "more changes from review\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI5MjEzMzU0", "url": "https://github.com/openhab/openhab-addons/pull/7504#pullrequestreview-429213354", "createdAt": "2020-06-11T19:17:55Z", "commit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxOToxNzo1NVrOGirSgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMVQxOToyMjowN1rOGirbDQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTAxNDAxOQ==", "bodyText": "I agree with @fwolter here, the GreeException should be removed from the throws clause since you are already caching it in the body.", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r439014019", "createdAt": "2020-06-11T19:17:55Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeHandler.java", "diffHunk": "@@ -0,0 +1,439 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.net.DatagramSocket;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.gree.internal.GreeConfiguration;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.discovery.GreeAirDevice;\n+import org.openhab.binding.gree.internal.discovery.GreeDeviceFinder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link GreeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(GreeHandler.class);\n+    private final GreeTranslationProvider messages;\n+    private GreeConfiguration config = new GreeConfiguration();\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+    private GreeAirDevice device = new GreeAirDevice();\n+    private Optional<DatagramSocket> clientSocket = Optional.empty();\n+\n+    private @Nullable ScheduledFuture<?> refreshTask;\n+    private long lastRefreshTime = 0;\n+\n+    public GreeHandler(Thing thing, GreeTranslationProvider messages) {\n+        super(thing);\n+        this.messages = messages;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        // logger.debug(\"Start initializing!\");\n+        config = getConfigAs(GreeConfiguration.class);\n+        logger.debug(\"Config for {} is {}\", thing.getUID(), config.toString());\n+        if (config.ipAddress.isEmpty() || (config.refresh < 0)) {\n+            logger.debug(\"Config of {} is invalid. Check configuration\", thing.getUID());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid configuration. Check thing configuration.\");\n+            return;\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.execute(() -> {\n+            initializeThing();\n+        });\n+    }\n+\n+    private void initializeThing() {\n+        logger.debug(\"Thing {} is initializing\", thing.getUID());\n+\n+        try {\n+            // Create a new Datagram socket with a specified timeout\n+            clientSocket = Optional.of(new DatagramSocket());\n+            if (!clientSocket.isPresent()) {\n+                logger.debug(\"Unable to create datagram socket, discovery aborted!\");\n+                return;\n+            }\n+            clientSocket.get().setSoTimeout(DATAGRAM_SOCKET_TIMEOUT);\n+\n+            // Find the GREE device\n+            deviceFinder = new GreeDeviceFinder(config.ipAddress);\n+            deviceFinder.scan(clientSocket, false);\n+            logger.debug(\"{} units found matching IP address\", deviceFinder.getScannedDeviceCount());\n+\n+            // Now check that this one is amongst the air conditioners that responded.\n+            GreeAirDevice newDevice = deviceFinder.getDeviceByIPAddress(config.ipAddress);\n+            if (newDevice != null) {\n+                // Ok, our device responded, now let's Bind with it\n+                device = newDevice;\n+                device.bindWithDevice(clientSocket);\n+                if (device.getIsBound()) {\n+                    logger.debug(\"GREE AirConditioner {} bound successful\", thing.getUID());\n+                    updateStatus(ThingStatus.ONLINE);\n+\n+                    // Start the automatic refresh cycles\n+                    startAutomaticRefresh();\n+                    return;\n+                }\n+            }\n+            logger.debug(\"GREE unit is not responding\");\n+        } catch (GreeException e) {\n+            logger.debug(\"Initialization failed: {}\", messages.get(\"thinginit.exception\", e.toString()));\n+        } catch (IOException | RuntimeException e) {\n+            logger.debug(\"Exception on inituialization\", e);\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            // The thing is updated by the scheduled automatic refresh so do nothing here.\n+        } else {\n+            if (!clientSocket.isPresent()) {\n+                logger.debug(\"Thing not properly initialized, abort command\");\n+                return;\n+            }\n+\n+            DatagramSocket socket = clientSocket.get();\n+            logger.debug(\"Issue command {}\u00a0to channe {}\", command, channelUID.getIdWithoutGroup());\n+            try {\n+                switch (channelUID.getIdWithoutGroup()) {\n+                    case MODE_CHANNEL:\n+                        handleModeCommand(command, socket);\n+                        break;\n+                    case POWER_CHANNEL:\n+                        device.setDevicePower(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case TURBO_CHANNEL:\n+                        device.setDeviceTurbo(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case LIGHT_CHANNEL:\n+                        device.setDeviceLight(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case TEMP_CHANNEL:\n+                        device.setDeviceTempSet(socket, ((DecimalType) command).intValue());\n+                        break;\n+                    case SWINGV_CHANNEL:\n+                        device.setDeviceSwingVertical(socket, ((DecimalType) command).intValue());\n+                        break;\n+                    case WINDSPEED_CHANNEL:\n+                        device.setDeviceWindspeed(socket, ((DecimalType) command).intValue());\n+                        break;\n+                    case AIR_CHANNEL:\n+                        device.setDeviceAir(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case DRY_CHANNEL:\n+                        device.setDeviceDry(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case HEALTH_CHANNEL:\n+                        device.setDeviceHealth(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                    case PWRSAV_CHANNEL:\n+                        device.setDevicePwrSaving(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+                        break;\n+                }\n+            } catch (GreeException e) {\n+                logger.debug(\"Unable to execute command {}\u00a0for channel {}: {}\", command, channelUID.getId(),\n+                        e.toString());\n+            } catch (RuntimeException e) {\n+                logger.debug(\"Unable to execute command {}\u00a0for channel {}\", command, channelUID.getId(), e);\n+            }\n+        }\n+    }\n+\n+    private void handleModeCommand(Command command, DatagramSocket socket) throws GreeException {\n+        int mode = -1;\n+        String modeStr = \"\";\n+        boolean isNumber = StringUtils.isNumeric(command.toString());\n+        if (command instanceof DecimalType) {\n+            // backward compatibility when channel was Number\n+            mode = ((DecimalType) command).intValue();\n+        } else if (command instanceof OnOffType) {\n+            // Switch\n+            logger.debug(\"Send Power-{}\", command);\n+            device.setDevicePower(socket, (OnOffType) command == OnOffType.ON ? 1 : 0);\n+        } else /* String */ {\n+            modeStr = command.toString().toLowerCase();\n+            switch (modeStr) {\n+                case MODE_AUTO:\n+                    mode = GREE_MODE_AUTO;\n+                    break;\n+                case MODE_COOL:\n+                    mode = GREE_MODE_COOL;\n+                    break;\n+                case MODE_HEAT:\n+                    mode = GREE_MODE_HEAT;\n+                    break;\n+                case MODE_DRY:\n+                    mode = GREE_MODE_DRY;\n+                    break;\n+                case MODE_FAN:\n+                case MODE_FAN2:\n+                    mode = GREE_MODE_FAN;\n+                    break;\n+                case MODE_ECO:\n+                    // power saving will be set after the uinit was turned on\n+                    mode = GREE_MODE_COOL;\n+                    break;\n+                case MODE_ON:\n+                case MODE_OFF:\n+                    device.setDevicePower(socket, modeStr.equals(MODE_ON) ? 1 : 0);\n+                    break;\n+                default:\n+                    if (isNumber) {\n+                        // Support selecting the mode by number, maybe specific models support\n+                        // additional modes\n+                        mode = Integer.parseInt(modeStr);\n+                    } else {\n+                        logger.debug(\"Invalid mode requested: {}\", command);\n+                    }\n+                    break;\n+            }\n+            logger.debug(\"Mode {} mapped to {}\", modeStr, mode);\n+        }\n+\n+        if (mode != -1) {\n+            // Turn on the unit if currently off\n+            if (!isNumber && (device.getIntStatusVal(\"Pow\") == 0)) {\n+                logger.debug(\"Send Auto-ON for mode {}\", mode);\n+                device.setDevicePower(socket, 1);\n+            }\n+\n+            // Select mode\n+            logger.debug(\"Select mode {}\", mode);\n+            device.SetDeviceMode(socket, mode);\n+\n+            // Check for secondary action\n+            switch (modeStr) {\n+                case MODE_ECO:\n+                    // Turn on power saving for eco mode\n+                    logger.debug(\"Turn on Power-Saving\");\n+                    device.setDevicePwrSaving(socket, 1);\n+                    break;\n+                case MODE_TURBO:\n+                    device.setDeviceTurbo(socket, 1);\n+                    break;\n+            }\n+        }\n+    }\n+\n+    private boolean isMinimumRefreshTimeExceeded() {\n+        long currentTime = System.currentTimeMillis();\n+        long timeSinceLastRefresh = currentTime - lastRefreshTime;\n+        if (timeSinceLastRefresh < MINIMUM_REFRESH_TIME_MS) {\n+            return false;\n+        }\n+        lastRefreshTime = currentTime;\n+        return true;\n+    }\n+\n+    private void startAutomaticRefresh() {\n+\n+        Runnable refresher = new Runnable() {\n+            @Override\n+            public void run() {\n+\n+                try {\n+                    logger.debug(\"Executing automatic update of values\");\n+                    // safeguard for multiple REFRESH commands\n+                    if (isMinimumRefreshTimeExceeded()) {\n+                        logger.debug(\"Fetching status values from device.\");\n+                        // Get the current status from the Airconditioner\n+                        device.getDeviceStatus(clientSocket.get());\n+                    } else {\n+                        logger.trace(\n+                                \"Skipped fetching status values from device because minimum refresh time not reached\");\n+                    }\n+\n+                    // Update All Channels\n+                    List<Channel> channels = getThing().getChannels();\n+                    for (Channel channel : channels) {\n+                        publishChannel(channel.getUID());\n+                    }\n+                } catch (GreeException e) {\n+                    if (!e.isTimeout()) {\n+                        logger.debug(\"Unable to perform auto-update: {}\", e.toString());\n+                    }\n+                } catch (RuntimeException e) {\n+                    logger.debug(\"Unable to perform auto-update\", e);\n+                }\n+            }\n+        };\n+\n+        refreshTask = scheduler.scheduleWithFixedDelay(refresher, 0, config.refresh, TimeUnit.SECONDS);\n+        logger.debug(\"Automatic refresh started ({} second interval)\", config.refresh);\n+    }\n+\n+    private void publishChannel(ChannelUID channelUID) throws GreeException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MzA2NA=="}, "originalCommit": {"oid": "4a0b49447344a772203fb7a3179f632c0360a0b6"}, "originalPosition": 318}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTAxNDY5NQ==", "bodyText": "I mean like this:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    sendData = scanReq.getBytes();\n          \n          \n            \n                    sendData = scanReq.getBytes(StandardCharsets.UTF_8);", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r439014695", "createdAt": "2020-06-11T19:19:24Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeDeviceFinder.java", "diffHunk": "@@ -0,0 +1,193 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.discovery;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeScanReponsePackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanRequestDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponseDTO;\n+import org.openhab.binding.gree.internal.handler.GreeAirDevice;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDeviceFinder provides functionality for searching for GREE Airconditioners on the network and keeping a list\n+ * of found devices.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeDeviceFinder {\n+    private final Logger logger = LoggerFactory.getLogger(GreeDeviceFinder.class);\n+\n+    protected final InetAddress ipAddress;\n+    protected HashMap<String, GreeAirDevice> deviceTable = new HashMap<>();\n+\n+    public GreeDeviceFinder() {\n+        ipAddress = InetAddress.getLoopbackAddress(); // dummy\n+    }\n+\n+    public GreeDeviceFinder(String broadcastAddress) throws UnknownHostException {\n+        ipAddress = InetAddress.getByName(broadcastAddress);\n+    }\n+\n+    public void scan(Optional<DatagramSocket> socket, boolean scanNetwork) throws GreeException {\n+        validateSocket(socket);\n+        byte[] sendData = new byte[1024];\n+        byte[] receiveData = new byte[1024];\n+\n+        // Send the Scan message\n+        GreeScanRequestDTO scanGson = new GreeScanRequestDTO();\n+        scanGson.t = \"scan\";\n+\n+        GsonBuilder gsonBuilder = new GsonBuilder();\n+        Gson gson = gsonBuilder.create();\n+        String scanReq = gson.toJson(scanGson);\n+        sendData = scanReq.getBytes();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzEwNDIxNw=="}, "originalCommit": {"oid": "5f5f5bb2d68d48b8927f43e1403cf06abcf4ea1d"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTAxNjIwNQ==", "bodyText": "This will make sure that background scanning properly starts since the @Activate annotation is no longer on the activate method.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public GreeDiscoveryService(@Reference NetworkAddressService networkAddressService,\n          \n          \n            \n                        @Reference LocaleProvider localeProvider, @Reference TranslationProvider i18nProvider) {\n          \n          \n            \n                    super(SUPPORTED_THING_TYPES_UIDS, TIMEOUT_SEC);\n          \n          \n            \n                    Bundle bundle = FrameworkUtil.getBundle(this.getClass());\n          \n          \n            \n                    messages = new GreeTranslationProvider(bundle.getBundleContext().getBundle(), i18nProvider, localeProvider);\n          \n          \n            \n                    String ip = networkAddressService.getConfiguredBroadcastAddress();\n          \n          \n            \n                    broadcastAddress = ip != null ? ip : \"\";\n          \n          \n            \n                }\n          \n          \n            \n                public GreeDiscoveryService(@Reference NetworkAddressService networkAddressService,\n          \n          \n            \n                        @Reference LocaleProvider localeProvider, @Reference TranslationProvider i18nProvider,\n          \n          \n            \n                        @Nullable Map<String, @Nullable Object> configProperties) {\n          \n          \n            \n                    super(SUPPORTED_THING_TYPES_UIDS, TIMEOUT_SEC);\n          \n          \n            \n                    Bundle bundle = FrameworkUtil.getBundle(this.getClass());\n          \n          \n            \n                    messages = new GreeTranslationProvider(bundle.getBundleContext().getBundle(), i18nProvider, localeProvider);\n          \n          \n            \n                    String ip = networkAddressService.getConfiguredBroadcastAddress();\n          \n          \n            \n                    broadcastAddress = ip != null ? ip : \"\";\n          \n          \n            \n                    activate(configProperties);\n          \n          \n            \n                }", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r439016205", "createdAt": "2020-06-11T19:22:07Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeDiscoveryService.java", "diffHunk": "@@ -0,0 +1,139 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.gree.internal.discovery;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramSocket;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.config.discovery.AbstractDiscoveryService;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResult;\n+import org.eclipse.smarthome.config.discovery.DiscoveryResultBuilder;\n+import org.eclipse.smarthome.config.discovery.DiscoveryService;\n+import org.eclipse.smarthome.core.i18n.LocaleProvider;\n+import org.eclipse.smarthome.core.i18n.TranslationProvider;\n+import org.eclipse.smarthome.core.net.NetworkAddressService;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.handler.GreeAirDevice;\n+import org.osgi.framework.Bundle;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Modified;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * {@link GreeDiscoveryService} implements the device discovery service. UDP broadtcast ius used to find the devices on\n+ * the local subnet.\n+ *\n+ * @author Markus Michels - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+@Component(service = DiscoveryService.class, immediate = true, configurationPid = \"discovery.gree\")\n+public class GreeDiscoveryService extends AbstractDiscoveryService {\n+    private static final int TIMEOUT_SEC = 10;\n+    private final Logger logger = LoggerFactory.getLogger(GreeDiscoveryService.class);\n+    private final GreeTranslationProvider messages;\n+    private final String broadcastAddress;\n+\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+\n+    @Activate\n+    public GreeDiscoveryService(@Reference NetworkAddressService networkAddressService,\n+            @Reference LocaleProvider localeProvider, @Reference TranslationProvider i18nProvider) {\n+        super(SUPPORTED_THING_TYPES_UIDS, TIMEOUT_SEC);\n+        Bundle bundle = FrameworkUtil.getBundle(this.getClass());\n+        messages = new GreeTranslationProvider(bundle.getBundleContext().getBundle(), i18nProvider, localeProvider);\n+        String ip = networkAddressService.getConfiguredBroadcastAddress();\n+        broadcastAddress = ip != null ? ip : \"\";\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e2fad291715bed6653cd3b0294109aeb3bddf3a4"}, "originalPosition": 71}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3f990a5c390c2404ac5af0c9ef50a599b02903d7", "author": {"user": {"login": "markus7017", "name": "Markus Michels"}}, "url": "https://github.com/openhab/openhab-addons/commit/3f990a5c390c2404ac5af0c9ef50a599b02903d7", "committedDate": "2020-06-11T19:47:05Z", "message": "more review changes (contants for cmd and property values, turn\ntranslation service into component, replaced some Optional stuff in\nhandler by @Nullable)\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e7b4c666c490b45266dfe59133c435ada802d53f", "author": {"user": {"login": "markus7017", "name": "Markus Michels"}}, "url": "https://github.com/openhab/openhab-addons/commit/e7b4c666c490b45266dfe59133c435ada802d53f", "committedDate": "2020-06-14T18:19:12Z", "message": "review changes; fixed mode on/off\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3f8726ecabb25e20818bfae17f95d0c463a50b26", "author": {"user": {"login": "markus7017", "name": "Markus Michels"}}, "url": "https://github.com/openhab/openhab-addons/commit/3f8726ecabb25e20818bfae17f95d0c463a50b26", "committedDate": "2020-06-14T18:48:10Z", "message": "review changes\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f7f599916ee2d6f1894d76b90166300892db7a10", "author": {"user": {"login": "markus7017", "name": "Markus Michels"}}, "url": "https://github.com/openhab/openhab-addons/commit/f7f599916ee2d6f1894d76b90166300892db7a10", "committedDate": "2020-06-16T12:00:47Z", "message": "review changes, support Celsius and Fahrenheit based on QuantityType\n(WIP)\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6ec9f36e5df386e820534e4dba208893ecb95027", "author": {"user": {"login": "markus7017", "name": "Markus Michels"}}, "url": "https://github.com/openhab/openhab-addons/commit/6ec9f36e5df386e820534e4dba208893ecb95027", "committedDate": "2020-06-16T14:06:55Z", "message": "removed C/F conversion (handled by the framework)\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f84b33b5c999635fd61d2476baa3f069ff644618", "author": {"user": {"login": "markus7017", "name": "Markus Michels"}}, "url": "https://github.com/openhab/openhab-addons/commit/f84b33b5c999635fd61d2476baa3f069ff644618", "committedDate": "2020-06-16T14:11:29Z", "message": "activate() method removed\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxOTIyMjc1", "url": "https://github.com/openhab/openhab-addons/pull/7504#pullrequestreview-431922275", "createdAt": "2020-06-16T21:59:11Z", "commit": {"oid": "f7f599916ee2d6f1894d76b90166300892db7a10"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMTo1OToxMVrOGkupkw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQyMjowNDoxOVrOGkuxYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE2NjIyNw==", "bodyText": "statusResponseGson can be empty at this point. That would result in a NoSuchElementException.", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r441166227", "createdAt": "2020-06-16T21:59:11Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeAirDevice.java", "diffHunk": "@@ -136,11 +131,12 @@ public void getDeviceStatus(DatagramSocket clientSocket) throws GreeException {\n             updateTempFtoC();\n         } catch (IOException e) {\n             throw new GreeException(\"I/O exception while receiving data\", e);\n+        } catch (RuntimeException e) {\n+            throw new GreeException(\"Exception while receiving data, JSON=\" + statusResponseGson.get().packJson, e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7f599916ee2d6f1894d76b90166300892db7a10"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE2NzEzMg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // Default for Celsiues\n          \n          \n            \n                    // Default for Celsius", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r441167132", "createdAt": "2020-06-16T22:01:27Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeAirDevice.java", "diffHunk": "@@ -248,37 +233,40 @@ public void setDeviceLight(DatagramSocket clientSocket, int value) throws GreeEx\n     /**\n      * @param value set temperature in degrees Celsius or Fahrenheit\n      */\n-    public void setDeviceTempSet(DatagramSocket clientSocket, int value) throws GreeException {\n-        int newVal = value;\n-        int outVal = value;\n-        // Get Celsius or Fahrenheit from status message\n-        Integer CorF = getIntStatusVal(GREE_PROP_TEMPUNIT);\n-        // TODO put a param in openhab to allow setting this from the config\n-\n+    public void setDeviceTempSet(DatagramSocket clientSocket, QuantityType<?> temp) throws GreeException {\n         // If commanding Fahrenheit set halfStep to 1 or 0 to tell the A/C which F integer\n         // temperature to use as celsius alone is ambigious\n-        int halfStep = 0; // default to C\n-\n-        int[] retList = validateTemperatureRangeForTempSet(newVal, CorF);\n-        newVal = retList[0];\n-        CorF = retList[1];\n+        Double newVal = temp.doubleValue();\n+        int CorF = temp.getUnit() == SIUnits.CELSIUS ? TEMP_UNIT_CELSIUS : TEMP_UNIT_FAHRENHEIT; // 0=Celsius,\n+                                                                                                 // 1=Fahrenheit\n+        if (((CorF == TEMP_UNIT_CELSIUS) && (newVal < TEMP_MIN_C || newVal > TEMP_MAX_C))\n+                || ((CorF == TEMP_UNIT_FAHRENHEIT) && (newVal < TEMP_MIN_F || newVal > TEMP_MAX_F))) {\n+            throw new IllegalArgumentException(\"Temp Value out of Range\");\n+        }\n \n-        if (CorF == 1) { // If Fahrenheit,\n-            // value argument is degrees F, convert Fahrenheit to Celsius,\n-            // SetTem input to A/C always in Celsius despite passing in 1 to TemUn\n+        // Default for Celsiues", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7f599916ee2d6f1894d76b90166300892db7a10"}, "originalPosition": 176}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE2ODIyNQ==", "bodyText": "You could convert the QuantityType with toUnit() to Celsius or Fahrenheit. Then, you need to check the range only once.", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r441168225", "createdAt": "2020-06-16T22:04:19Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeAirDevice.java", "diffHunk": "@@ -248,37 +233,40 @@ public void setDeviceLight(DatagramSocket clientSocket, int value) throws GreeEx\n     /**\n      * @param value set temperature in degrees Celsius or Fahrenheit\n      */\n-    public void setDeviceTempSet(DatagramSocket clientSocket, int value) throws GreeException {\n-        int newVal = value;\n-        int outVal = value;\n-        // Get Celsius or Fahrenheit from status message\n-        Integer CorF = getIntStatusVal(GREE_PROP_TEMPUNIT);\n-        // TODO put a param in openhab to allow setting this from the config\n-\n+    public void setDeviceTempSet(DatagramSocket clientSocket, QuantityType<?> temp) throws GreeException {\n         // If commanding Fahrenheit set halfStep to 1 or 0 to tell the A/C which F integer\n         // temperature to use as celsius alone is ambigious\n-        int halfStep = 0; // default to C\n-\n-        int[] retList = validateTemperatureRangeForTempSet(newVal, CorF);\n-        newVal = retList[0];\n-        CorF = retList[1];\n+        Double newVal = temp.doubleValue();\n+        int CorF = temp.getUnit() == SIUnits.CELSIUS ? TEMP_UNIT_CELSIUS : TEMP_UNIT_FAHRENHEIT; // 0=Celsius,\n+                                                                                                 // 1=Fahrenheit\n+        if (((CorF == TEMP_UNIT_CELSIUS) && (newVal < TEMP_MIN_C || newVal > TEMP_MAX_C))\n+                || ((CorF == TEMP_UNIT_FAHRENHEIT) && (newVal < TEMP_MIN_F || newVal > TEMP_MAX_F))) {\n+            throw new IllegalArgumentException(\"Temp Value out of Range\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7f599916ee2d6f1894d76b90166300892db7a10"}, "originalPosition": 170}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5a2754c8e8096d6f2bc0111d90fbaf896bb331d0", "author": {"user": {"login": "markus7017", "name": "Markus Michels"}}, "url": "https://github.com/openhab/openhab-addons/commit/5a2754c8e8096d6f2bc0111d90fbaf896bb331d0", "committedDate": "2020-06-16T23:09:55Z", "message": "review changes\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "446e73815427bc66cd4e7734e552d9aa80c52b3c", "author": {"user": {"login": "markus7017", "name": "Markus Michels"}}, "url": "https://github.com/openhab/openhab-addons/commit/446e73815427bc66cd4e7734e552d9aa80c52b3c", "committedDate": "2020-06-17T14:34:19Z", "message": "fixed typo in properties id (..), thingId added to debug outputs\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyNTc1NzEz", "url": "https://github.com/openhab/openhab-addons/pull/7504#pullrequestreview-432575713", "createdAt": "2020-06-17T16:33:33Z", "commit": {"oid": "446e73815427bc66cd4e7734e552d9aa80c52b3c"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNjozMzozM1rOGlNzUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNjozMzozM1rOGlNzUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY3NjYyNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        String json = statusResponseGson.isPresent() ? statusResponseGson.get().packJson.toString() : \"n/a\";\n          \n          \n            \n                        String json = statusResponseGson.map(r -> r.packJson.toString()).orElse(\"n/a\");", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r441676625", "createdAt": "2020-06-17T16:33:33Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,524 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeRequestDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePackDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\n+ * device specific attributes as well a the functionality for the Air Conditioner\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeAirDevice {\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\n+    private final static Gson gson = new Gson();\n+    private boolean isBound = false;\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\n+    private int port = 0;\n+    private String encKey = \"\";\n+    private Optional<GreeScanResponseDTO> scanResponseGson = Optional.empty();\n+    private Optional<GreeStatusResponseDTO> statusResponseGson = Optional.empty();\n+    private Optional<GreeStatusResponsePackDTO> prevStatusResponsePackGson = Optional.empty();\n+\n+    public void getDeviceStatus(DatagramSocket clientSocket) throws GreeException {\n+        try {\n+            // Set the values in the HashMap\n+            ArrayList<String> columns = new ArrayList<>();\n+            columns.add(GREE_PROP_POWER);\n+            columns.add(GREE_PROP_MODE);\n+            columns.add(GREE_PROP_SETTEMP);\n+            columns.add(GREE_PROP_WINDSPEED);\n+            columns.add(GREE_PROP_AIR);\n+            columns.add(GREE_PROP_DRY);\n+            columns.add(GREE_PROP_HEALTH);\n+            columns.add(GREE_PROP_SLEEP);\n+            columns.add(GREE_PROP_LIGHT);\n+            columns.add(GREE_PROP_SWINGLEFTRIGHT);\n+            columns.add(GREE_PROP_SWINGUPDOWN);\n+            columns.add(GREE_PROP_QUIET);\n+            columns.add(GREE_PROP_TURBO);\n+            columns.add(GREE_PROP_TEMPUNIT);\n+            columns.add(GREE_PROP_HEAT);\n+            columns.add(GREE_PROP_HEATCOOL);\n+            columns.add(GREE_PROP_TEMPREC);\n+            columns.add(GREE_PROP_PWR_SAVING);\n+            columns.add(GREE_PROP_NOISESET);\n+\n+            // Convert the parameter map values to arrays\n+            String[] colArray = columns.toArray(new String[0]);\n+\n+            // Prep the Command Request pack\n+            GreeReqStatusPackDTO reqStatusPackGson = new GreeReqStatusPackDTO();\n+            reqStatusPackGson.t = GREE_CMDT_STATUS;\n+            reqStatusPackGson.cols = colArray;\n+            reqStatusPackGson.mac = getId();\n+            String reqStatusPackStr = gson.toJson(reqStatusPackGson);\n+\n+            // Encrypt and send the Status Request pack\n+            String encryptedStatusReqPacket = GreeCryptoUtil.encryptPack(getKey().getBytes(), reqStatusPackStr);\n+            DatagramPacket sendPacket = createPackRequest(0,\n+                    new String(encryptedStatusReqPacket.getBytes(), StandardCharsets.UTF_8));\n+            clientSocket.send(sendPacket);\n+\n+            // Recieve a response\n+            JsonReader receivedData = receiveResponse(clientSocket);\n+\n+            // Keep a copy of the old response to be used to check if values have changed\n+            // If first time running, there will not be a previous GreeStatusResponsePack4Gson\n+            if (statusResponseGson.isPresent() && statusResponseGson.get().packJson != null) {\n+                prevStatusResponsePackGson = Optional\n+                        .of(new GreeStatusResponsePackDTO(statusResponseGson.get().packJson));\n+            }\n+\n+            // Read the response, create the JSON to hold the response values\n+            GreeStatusResponseDTO resp = gson.fromJson(receivedData, GreeStatusResponseDTO.class);\n+            resp.decryptedPack = GreeCryptoUtil.decryptPack(this.getKey().getBytes(), resp.pack);\n+            logger.debug(\"Response from device: {}\", resp.decryptedPack);\n+            resp.packJson = gson.fromJson(new JsonReader(new StringReader(resp.decryptedPack)),\n+                    GreeStatusResponsePackDTO.class);\n+\n+            // save the results\n+            statusResponseGson = Optional.of(resp);\n+            updateTempFtoC();\n+        } catch (IOException e) {\n+            throw new GreeException(\"I/O exception while receiving data\", e);\n+        } catch (RuntimeException e) {\n+            String json = statusResponseGson.isPresent() ? statusResponseGson.get().packJson.toString() : \"n/a\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "446e73815427bc66cd4e7734e552d9aa80c52b3c"}, "originalPosition": 135}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ddbba49f802627554c380ef9a5b829ac7b1f8cb1", "author": {"user": {"login": "markus7017", "name": "Markus Michels"}}, "url": "https://github.com/openhab/openhab-addons/commit/ddbba49f802627554c380ef9a5b829ac7b1f8cb1", "committedDate": "2020-06-17T20:27:11Z", "message": "Update status 3sec after a command was sent; avoid NPE when no response\nis available; review change\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyODU0Mjk1", "url": "https://github.com/openhab/openhab-addons/pull/7504#pullrequestreview-432854295", "createdAt": "2020-06-18T00:02:15Z", "commit": {"oid": "ddbba49f802627554c380ef9a5b829ac7b1f8cb1"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwMDowMjoxNVrOGlbQZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwMDozOTozNFrOGlb0xA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg5NzA2Mw==", "bodyText": "You should catch the json syntax exception this throws.", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r441897063", "createdAt": "2020-06-18T00:02:15Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeDeviceFinder.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.discovery;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeScanReponsePackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanRequestDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponseDTO;\n+import org.openhab.binding.gree.internal.handler.GreeAirDevice;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDeviceFinder provides functionality for searching for GREE Airconditioners on the network and keeping a list\n+ * of found devices.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeDeviceFinder {\n+    private final Logger logger = LoggerFactory.getLogger(GreeDeviceFinder.class);\n+    private static final Gson gson = (new GsonBuilder()).create();\n+\n+    protected final InetAddress ipAddress;\n+    protected Map<String, GreeAirDevice> deviceTable = new HashMap<>();\n+\n+    public GreeDeviceFinder() {\n+        ipAddress = InetAddress.getLoopbackAddress(); // dummy\n+    }\n+\n+    public GreeDeviceFinder(String broadcastAddress) throws GreeException {\n+        try {\n+            ipAddress = InetAddress.getByName(broadcastAddress);\n+        } catch (UnknownHostException e) {\n+            throw new GreeException(\"Unknown host or invalid IP address\", e);\n+        }\n+    }\n+\n+    public void scan(DatagramSocket clientSocket, boolean scanNetwork) throws GreeException {\n+        try {\n+            byte[] sendData = new byte[1024];\n+            byte[] receiveData = new byte[1024];\n+\n+            // Send the Scan message\n+            GreeScanRequestDTO scanGson = new GreeScanRequestDTO();\n+            scanGson.t = GREE_CMDT_SCAN;\n+            String scanReq = gson.toJson(scanGson);\n+            sendData = scanReq.getBytes(StandardCharsets.UTF_8);\n+            logger.trace(\"Sending scan packet to {}\", ipAddress.getHostAddress());\n+            clientSocket.setSoTimeout(DISCOVERY_TIMEOUT_MS);\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, ipAddress, DISCOVERY_TIMEOUT_MS);\n+            clientSocket.send(sendPacket);\n+\n+            // Loop for respnses from devices until we get a timeout.\n+            int retries = MAX_SCAN_CYCLES;\n+            while ((retries > 0)) {\n+                // Receive a response\n+                DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+                try {\n+                    clientSocket.receive(receivePacket);\n+                    InetAddress remoteAddress = receivePacket.getAddress();\n+                    int remotePort = receivePacket.getPort();\n+\n+                    // Read the response\n+                    // String modifiedSentence = new String(receivePacket.getData(), StandardCharsets.UTF_8);\n+                    // GreeScanResponseDTO scanResponseGson = gson.fromJson(modifiedSentence,\n+                    // GreeScanResponseDTO.class);\n+                    String modifiedSentence = new String(receivePacket.getData(), StandardCharsets.UTF_8);\n+                    StringReader stringReader = new StringReader(modifiedSentence);\n+                    GreeScanResponseDTO scanResponseGson = gson.fromJson(new JsonReader(stringReader),\n+                            GreeScanResponseDTO.class);\n+\n+                    // If there was no pack, ignore the response\n+                    if (scanResponseGson.pack == null) {\n+                        logger.debug(\"Invalid packet format, ignore\");\n+                        continue;\n+                    }\n+\n+                    // Decrypt message - a a GreeException is thrown when something went wrong\n+                    /*\n+                     * scanResponseGson.decryptedPack = GreeCryptoUtil\n+                     * .decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(), scanResponseGson.pack);\n+                     * String decryptedMsg = GreeCryptoUtil.decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\n+                     * scanResponseGson.pack);\n+                     */\n+                    String decryptedMsg = scanResponseGson.decryptedPack = GreeCryptoUtil\n+                            .decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(), scanResponseGson.pack);\n+                    logger.debug(\"Response received from address {}: {}\", remoteAddress.getHostAddress(), decryptedMsg);\n+\n+                    // Create the JSON to hold the response values\n+                    scanResponseGson.packJson = gson.fromJson(decryptedMsg, GreeScanReponsePackDTO.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ddbba49f802627554c380ef9a5b829ac7b1f8cb1"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg5NzEwNQ==", "bodyText": "here too", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r441897105", "createdAt": "2020-06-18T00:02:25Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeDeviceFinder.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.discovery;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeScanReponsePackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanRequestDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponseDTO;\n+import org.openhab.binding.gree.internal.handler.GreeAirDevice;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDeviceFinder provides functionality for searching for GREE Airconditioners on the network and keeping a list\n+ * of found devices.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeDeviceFinder {\n+    private final Logger logger = LoggerFactory.getLogger(GreeDeviceFinder.class);\n+    private static final Gson gson = (new GsonBuilder()).create();\n+\n+    protected final InetAddress ipAddress;\n+    protected Map<String, GreeAirDevice> deviceTable = new HashMap<>();\n+\n+    public GreeDeviceFinder() {\n+        ipAddress = InetAddress.getLoopbackAddress(); // dummy\n+    }\n+\n+    public GreeDeviceFinder(String broadcastAddress) throws GreeException {\n+        try {\n+            ipAddress = InetAddress.getByName(broadcastAddress);\n+        } catch (UnknownHostException e) {\n+            throw new GreeException(\"Unknown host or invalid IP address\", e);\n+        }\n+    }\n+\n+    public void scan(DatagramSocket clientSocket, boolean scanNetwork) throws GreeException {\n+        try {\n+            byte[] sendData = new byte[1024];\n+            byte[] receiveData = new byte[1024];\n+\n+            // Send the Scan message\n+            GreeScanRequestDTO scanGson = new GreeScanRequestDTO();\n+            scanGson.t = GREE_CMDT_SCAN;\n+            String scanReq = gson.toJson(scanGson);\n+            sendData = scanReq.getBytes(StandardCharsets.UTF_8);\n+            logger.trace(\"Sending scan packet to {}\", ipAddress.getHostAddress());\n+            clientSocket.setSoTimeout(DISCOVERY_TIMEOUT_MS);\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, ipAddress, DISCOVERY_TIMEOUT_MS);\n+            clientSocket.send(sendPacket);\n+\n+            // Loop for respnses from devices until we get a timeout.\n+            int retries = MAX_SCAN_CYCLES;\n+            while ((retries > 0)) {\n+                // Receive a response\n+                DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+                try {\n+                    clientSocket.receive(receivePacket);\n+                    InetAddress remoteAddress = receivePacket.getAddress();\n+                    int remotePort = receivePacket.getPort();\n+\n+                    // Read the response\n+                    // String modifiedSentence = new String(receivePacket.getData(), StandardCharsets.UTF_8);\n+                    // GreeScanResponseDTO scanResponseGson = gson.fromJson(modifiedSentence,\n+                    // GreeScanResponseDTO.class);\n+                    String modifiedSentence = new String(receivePacket.getData(), StandardCharsets.UTF_8);\n+                    StringReader stringReader = new StringReader(modifiedSentence);\n+                    GreeScanResponseDTO scanResponseGson = gson.fromJson(new JsonReader(stringReader),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ddbba49f802627554c380ef9a5b829ac7b1f8cb1"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg5NzE5OQ==", "bodyText": "remove these comments", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r441897199", "createdAt": "2020-06-18T00:02:47Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeDeviceFinder.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.discovery;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeScanReponsePackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanRequestDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponseDTO;\n+import org.openhab.binding.gree.internal.handler.GreeAirDevice;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDeviceFinder provides functionality for searching for GREE Airconditioners on the network and keeping a list\n+ * of found devices.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeDeviceFinder {\n+    private final Logger logger = LoggerFactory.getLogger(GreeDeviceFinder.class);\n+    private static final Gson gson = (new GsonBuilder()).create();\n+\n+    protected final InetAddress ipAddress;\n+    protected Map<String, GreeAirDevice> deviceTable = new HashMap<>();\n+\n+    public GreeDeviceFinder() {\n+        ipAddress = InetAddress.getLoopbackAddress(); // dummy\n+    }\n+\n+    public GreeDeviceFinder(String broadcastAddress) throws GreeException {\n+        try {\n+            ipAddress = InetAddress.getByName(broadcastAddress);\n+        } catch (UnknownHostException e) {\n+            throw new GreeException(\"Unknown host or invalid IP address\", e);\n+        }\n+    }\n+\n+    public void scan(DatagramSocket clientSocket, boolean scanNetwork) throws GreeException {\n+        try {\n+            byte[] sendData = new byte[1024];\n+            byte[] receiveData = new byte[1024];\n+\n+            // Send the Scan message\n+            GreeScanRequestDTO scanGson = new GreeScanRequestDTO();\n+            scanGson.t = GREE_CMDT_SCAN;\n+            String scanReq = gson.toJson(scanGson);\n+            sendData = scanReq.getBytes(StandardCharsets.UTF_8);\n+            logger.trace(\"Sending scan packet to {}\", ipAddress.getHostAddress());\n+            clientSocket.setSoTimeout(DISCOVERY_TIMEOUT_MS);\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, ipAddress, DISCOVERY_TIMEOUT_MS);\n+            clientSocket.send(sendPacket);\n+\n+            // Loop for respnses from devices until we get a timeout.\n+            int retries = MAX_SCAN_CYCLES;\n+            while ((retries > 0)) {\n+                // Receive a response\n+                DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+                try {\n+                    clientSocket.receive(receivePacket);\n+                    InetAddress remoteAddress = receivePacket.getAddress();\n+                    int remotePort = receivePacket.getPort();\n+\n+                    // Read the response\n+                    // String modifiedSentence = new String(receivePacket.getData(), StandardCharsets.UTF_8);\n+                    // GreeScanResponseDTO scanResponseGson = gson.fromJson(modifiedSentence,\n+                    // GreeScanResponseDTO.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ddbba49f802627554c380ef9a5b829ac7b1f8cb1"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg5NzYzMw==", "bodyText": "Gson already has the method that allows parsing from a string.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                String modifiedSentence = new String(receivePacket.getData(), StandardCharsets.UTF_8);\n          \n          \n            \n                                StringReader stringReader = new StringReader(modifiedSentence);\n          \n          \n            \n                                GreeScanResponseDTO scanResponseGson = gson.fromJson(new JsonReader(stringReader),\n          \n          \n            \n                                String modifiedSentence = new String(receivePacket.getData(), StandardCharsets.UTF_8);\n          \n          \n            \n                                GreeScanResponseDTO scanResponseGson = gson.fromJson(modifiedSentence,", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r441897633", "createdAt": "2020-06-18T00:04:21Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeDeviceFinder.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.discovery;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeScanReponsePackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanRequestDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponseDTO;\n+import org.openhab.binding.gree.internal.handler.GreeAirDevice;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDeviceFinder provides functionality for searching for GREE Airconditioners on the network and keeping a list\n+ * of found devices.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeDeviceFinder {\n+    private final Logger logger = LoggerFactory.getLogger(GreeDeviceFinder.class);\n+    private static final Gson gson = (new GsonBuilder()).create();\n+\n+    protected final InetAddress ipAddress;\n+    protected Map<String, GreeAirDevice> deviceTable = new HashMap<>();\n+\n+    public GreeDeviceFinder() {\n+        ipAddress = InetAddress.getLoopbackAddress(); // dummy\n+    }\n+\n+    public GreeDeviceFinder(String broadcastAddress) throws GreeException {\n+        try {\n+            ipAddress = InetAddress.getByName(broadcastAddress);\n+        } catch (UnknownHostException e) {\n+            throw new GreeException(\"Unknown host or invalid IP address\", e);\n+        }\n+    }\n+\n+    public void scan(DatagramSocket clientSocket, boolean scanNetwork) throws GreeException {\n+        try {\n+            byte[] sendData = new byte[1024];\n+            byte[] receiveData = new byte[1024];\n+\n+            // Send the Scan message\n+            GreeScanRequestDTO scanGson = new GreeScanRequestDTO();\n+            scanGson.t = GREE_CMDT_SCAN;\n+            String scanReq = gson.toJson(scanGson);\n+            sendData = scanReq.getBytes(StandardCharsets.UTF_8);\n+            logger.trace(\"Sending scan packet to {}\", ipAddress.getHostAddress());\n+            clientSocket.setSoTimeout(DISCOVERY_TIMEOUT_MS);\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, ipAddress, DISCOVERY_TIMEOUT_MS);\n+            clientSocket.send(sendPacket);\n+\n+            // Loop for respnses from devices until we get a timeout.\n+            int retries = MAX_SCAN_CYCLES;\n+            while ((retries > 0)) {\n+                // Receive a response\n+                DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+                try {\n+                    clientSocket.receive(receivePacket);\n+                    InetAddress remoteAddress = receivePacket.getAddress();\n+                    int remotePort = receivePacket.getPort();\n+\n+                    // Read the response\n+                    // String modifiedSentence = new String(receivePacket.getData(), StandardCharsets.UTF_8);\n+                    // GreeScanResponseDTO scanResponseGson = gson.fromJson(modifiedSentence,\n+                    // GreeScanResponseDTO.class);\n+                    String modifiedSentence = new String(receivePacket.getData(), StandardCharsets.UTF_8);\n+                    StringReader stringReader = new StringReader(modifiedSentence);\n+                    GreeScanResponseDTO scanResponseGson = gson.fromJson(new JsonReader(stringReader),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ddbba49f802627554c380ef9a5b829ac7b1f8cb1"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg5ODQ4MQ==", "bodyText": "Returning from a method explicitly should be preferred over returning implicitly.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    break;\n          \n          \n            \n                                }\n          \n          \n            \n                            } catch (SocketTimeoutException e) {\n          \n          \n            \n                                break;\n          \n          \n            \n                                    return;\n          \n          \n            \n                                }\n          \n          \n            \n                            } catch (SocketTimeoutException e) {\n          \n          \n            \n                                return;", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r441898481", "createdAt": "2020-06-18T00:07:39Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/discovery/GreeDeviceFinder.java", "diffHunk": "@@ -0,0 +1,179 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.discovery;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeScanReponsePackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanRequestDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponseDTO;\n+import org.openhab.binding.gree.internal.handler.GreeAirDevice;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDeviceFinder provides functionality for searching for GREE Airconditioners on the network and keeping a list\n+ * of found devices.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeDeviceFinder {\n+    private final Logger logger = LoggerFactory.getLogger(GreeDeviceFinder.class);\n+    private static final Gson gson = (new GsonBuilder()).create();\n+\n+    protected final InetAddress ipAddress;\n+    protected Map<String, GreeAirDevice> deviceTable = new HashMap<>();\n+\n+    public GreeDeviceFinder() {\n+        ipAddress = InetAddress.getLoopbackAddress(); // dummy\n+    }\n+\n+    public GreeDeviceFinder(String broadcastAddress) throws GreeException {\n+        try {\n+            ipAddress = InetAddress.getByName(broadcastAddress);\n+        } catch (UnknownHostException e) {\n+            throw new GreeException(\"Unknown host or invalid IP address\", e);\n+        }\n+    }\n+\n+    public void scan(DatagramSocket clientSocket, boolean scanNetwork) throws GreeException {\n+        try {\n+            byte[] sendData = new byte[1024];\n+            byte[] receiveData = new byte[1024];\n+\n+            // Send the Scan message\n+            GreeScanRequestDTO scanGson = new GreeScanRequestDTO();\n+            scanGson.t = GREE_CMDT_SCAN;\n+            String scanReq = gson.toJson(scanGson);\n+            sendData = scanReq.getBytes(StandardCharsets.UTF_8);\n+            logger.trace(\"Sending scan packet to {}\", ipAddress.getHostAddress());\n+            clientSocket.setSoTimeout(DISCOVERY_TIMEOUT_MS);\n+            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, ipAddress, DISCOVERY_TIMEOUT_MS);\n+            clientSocket.send(sendPacket);\n+\n+            // Loop for respnses from devices until we get a timeout.\n+            int retries = MAX_SCAN_CYCLES;\n+            while ((retries > 0)) {\n+                // Receive a response\n+                DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n+                try {\n+                    clientSocket.receive(receivePacket);\n+                    InetAddress remoteAddress = receivePacket.getAddress();\n+                    int remotePort = receivePacket.getPort();\n+\n+                    // Read the response\n+                    // String modifiedSentence = new String(receivePacket.getData(), StandardCharsets.UTF_8);\n+                    // GreeScanResponseDTO scanResponseGson = gson.fromJson(modifiedSentence,\n+                    // GreeScanResponseDTO.class);\n+                    String modifiedSentence = new String(receivePacket.getData(), StandardCharsets.UTF_8);\n+                    StringReader stringReader = new StringReader(modifiedSentence);\n+                    GreeScanResponseDTO scanResponseGson = gson.fromJson(new JsonReader(stringReader),\n+                            GreeScanResponseDTO.class);\n+\n+                    // If there was no pack, ignore the response\n+                    if (scanResponseGson.pack == null) {\n+                        logger.debug(\"Invalid packet format, ignore\");\n+                        continue;\n+                    }\n+\n+                    // Decrypt message - a a GreeException is thrown when something went wrong\n+                    /*\n+                     * scanResponseGson.decryptedPack = GreeCryptoUtil\n+                     * .decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(), scanResponseGson.pack);\n+                     * String decryptedMsg = GreeCryptoUtil.decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\n+                     * scanResponseGson.pack);\n+                     */\n+                    String decryptedMsg = scanResponseGson.decryptedPack = GreeCryptoUtil\n+                            .decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(), scanResponseGson.pack);\n+                    logger.debug(\"Response received from address {}: {}\", remoteAddress.getHostAddress(), decryptedMsg);\n+\n+                    // Create the JSON to hold the response values\n+                    scanResponseGson.packJson = gson.fromJson(decryptedMsg, GreeScanReponsePackDTO.class);\n+\n+                    // Now make sure the device is reported as a Gree device\n+                    if (scanResponseGson.packJson.brand.equalsIgnoreCase(\"gree\")) {\n+                        // Create a new GreeDevice\n+                        logger.debug(\"Discovered device at {}:{}\", remoteAddress.getHostAddress(), remotePort);\n+                        GreeAirDevice newDevice = new GreeAirDevice();\n+                        newDevice.setAddress(remoteAddress);\n+                        newDevice.setPort(remotePort);\n+                        newDevice.setScanResponseGson(scanResponseGson);\n+                        addDevice(newDevice);\n+                    } else {\n+                        logger.debug(\"Unit discovered, but brand is not GREE\");\n+                    }\n+\n+                    if (!scanNetwork) {\n+                        break;\n+                    }\n+                } catch (SocketTimeoutException e) {\n+                    break;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ddbba49f802627554c380ef9a5b829ac7b1f8cb1"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg5ODY1NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        return ((OnOffType) command) == OnOffType.ON ? 1 : 0;\n          \n          \n            \n                        return command == OnOffType.ON ? 1 : 0;", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r441898654", "createdAt": "2020-06-18T00:08:22Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeHandler.java", "diffHunk": "@@ -0,0 +1,525 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.net.DatagramSocket;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.ImperialUnits;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.gree.internal.GreeConfiguration;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.discovery.GreeDeviceFinder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link GreeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(GreeHandler.class);\n+    private final GreeTranslationProvider messages;\n+    private GreeConfiguration config = new GreeConfiguration();\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+    private GreeAirDevice device = new GreeAirDevice();\n+    private Optional<DatagramSocket> clientSocket = Optional.empty();\n+    private final String thingId;\n+    private boolean forceRefresh = false;\n+\n+    private @Nullable ScheduledFuture<?> refreshTask;\n+    private long lastRefreshTime = 0;\n+\n+    public GreeHandler(Thing thing, GreeTranslationProvider messages) {\n+        super(thing);\n+        this.messages = messages;\n+        String label = getThing().getLabel();\n+        this.thingId = label != null ? label : getThing().getUID().getId();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(GreeConfiguration.class);\n+        logger.debug(\"{}: Config for {} is {}\", thing.getUID(), thingId, config.toString());\n+        if (config.ipAddress.isEmpty() || (config.refresh < 0)) {\n+            logger.warn(\"{}: Config of {} is invalid. Check configuration\", thingId, thing.getUID());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid configuration. Check thing configuration.\");\n+            return;\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.execute(this::initializeThing);\n+    }\n+\n+    private void initializeThing() {\n+        try {\n+            if (!clientSocket.isPresent()) {\n+                clientSocket = Optional.of(new DatagramSocket());\n+                clientSocket.get().setSoTimeout(DATAGRAM_SOCKET_TIMEOUT);\n+            }\n+            // Find the GREE device\n+            deviceFinder = new GreeDeviceFinder(config.ipAddress);\n+            deviceFinder.scan(clientSocket.get(), false);\n+            logger.debug(\"{}: {} units found matching IP address\", thingId, deviceFinder.getScannedDeviceCount());\n+\n+            // Now check that this one is amongst the air conditioners that responded.\n+            GreeAirDevice newDevice = deviceFinder.getDeviceByIPAddress(config.ipAddress);\n+            if (newDevice != null) {\n+                // Ok, our device responded, now let's Bind with it\n+                device = newDevice;\n+                device.bindWithDevice(clientSocket.get());\n+                if (device.getIsBound()) {\n+                    updateStatus(ThingStatus.ONLINE);\n+\n+                    // Start the automatic refresh cycles\n+                    startAutomaticRefresh();\n+                    return;\n+                }\n+            }\n+            logger.debug(\"{}: GREE unit is not responding\", thingId);\n+        } catch (GreeException e) {\n+            logger.warn(\"{}: Initialization failed: {}\", thingId, messages.get(\"thinginit.exception\", e.toString()));\n+        } catch (IOException e) {\n+            logger.debug(\"{}: Exception on initialization: {}\", thingId, e.toString());\n+        } catch (RuntimeException e) {\n+            logger.warn(\"{}: Initialization failed\", thingId, e);\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Thing initialization failed!\");\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            // The thing is updated by the scheduled automatic refresh so do nothing here.\n+        } else {\n+            logger.debug(\"{}: Issue command {}\u00a0to channe {}\", thingId, command, channelUID.getIdWithoutGroup());\n+            String channelId = channelUID.getIdWithoutGroup();\n+            logger.debug(\"{}: Handle command {} for channel {}, command class {}\", thingId, command, channelId,\n+                    command.getClass());\n+            try {\n+                DatagramSocket socket = clientSocket.get();\n+                switch (channelId) {\n+                    case MODE_CHANNEL:\n+                        handleModeCommand(socket, command);\n+                        break;\n+                    case POWER_CHANNEL:\n+                        device.setDevicePower(socket, getOnOff(command));\n+                        break;\n+                    case TURBO_CHANNEL:\n+                        device.setDeviceTurbo(socket, getOnOff(command));\n+                        break;\n+                    case LIGHT_CHANNEL:\n+                        device.setDeviceLight(socket, getOnOff(command));\n+                        break;\n+                    case TEMP_CHANNEL:\n+                        // Set value, read back effective one and update channel\n+                        // e.g. 22.5C will result in 22.0, because the AC doesn't support half-steps for C\n+                        device.setDeviceTempSet(socket, convertTemp(command));\n+                        break;\n+                    case SWINGUD_CHANNEL:\n+                        device.setDeviceSwingUpDown(socket, getNumber(command));\n+                        break;\n+                    case SWINGLR_CHANNEL:\n+                        device.setDeviceSwingLeftRight(socket, getNumber(command));\n+                        break;\n+                    case WINDSPEED_CHANNEL:\n+                        device.setDeviceWindspeed(socket, getNumber(command));\n+                        break;\n+                    case QUIET_CHANNEL:\n+                        handleQuietCommand(socket, command);\n+                        break;\n+                    case AIR_CHANNEL:\n+                        device.setDeviceAir(socket, getOnOff(command));\n+                        break;\n+                    case DRY_CHANNEL:\n+                        device.setDeviceDry(socket, getOnOff(command));\n+                        break;\n+                    case HEALTH_CHANNEL:\n+                        device.setDeviceHealth(socket, getOnOff(command));\n+                        break;\n+                    case PWRSAV_CHANNEL:\n+                        device.setDevicePwrSaving(socket, getOnOff(command));\n+                        break;\n+                }\n+\n+                // force refresh on next status refresh cycle\n+                forceRefresh = true;\n+            } catch (GreeException e) {\n+                logger.debug(\"{}: Unable to execute command {}\u00a0for channel {}: {}\", thingId, command, channelId,\n+                        e.toString());\n+            } catch (IllegalArgumentException e) {\n+                logger.warn(\"{}: Invalid command value {}\u00a0for channel {}\", thingId, command, channelUID.getId());\n+            } catch (RuntimeException e) {\n+                logger.warn(\"{}: Unable to execute command {}\u00a0for channel {}\", thingId, command, channelId, e);\n+            }\n+        }\n+    }\n+\n+    private void handleModeCommand(DatagramSocket socket, Command command) throws GreeException {\n+        int mode = -1;\n+        String modeStr = \"\";\n+        boolean isNumber = false;\n+        if (command instanceof DecimalType) {\n+            // backward compatibility when channel was Number\n+            mode = ((DecimalType) command).intValue();\n+        } else if (command instanceof OnOffType) {\n+            // Switch\n+            logger.debug(\"{}: Send Power-{}\", thingId, command);\n+            device.setDevicePower(socket, getOnOff(command));\n+        } else /* String */ {\n+            modeStr = command.toString().toLowerCase();\n+            switch (modeStr) {\n+                case MODE_AUTO:\n+                    mode = GREE_MODE_AUTO;\n+                    break;\n+                case MODE_COOL:\n+                    mode = GREE_MODE_COOL;\n+                    break;\n+                case MODE_HEAT:\n+                    mode = GREE_MODE_HEAT;\n+                    break;\n+                case MODE_DRY:\n+                    mode = GREE_MODE_DRY;\n+                    break;\n+                case MODE_FAN:\n+                case MODE_FAN2:\n+                    mode = GREE_MODE_FAN;\n+                    break;\n+                case MODE_ECO:\n+                    // power saving will be set after the uinit was turned on\n+                    mode = GREE_MODE_COOL;\n+                    break;\n+                case MODE_ON:\n+                case MODE_OFF:\n+                    logger.debug(\"{}: Turn unit {}\", thingId, modeStr);\n+                    device.setDevicePower(socket, modeStr.equals(MODE_ON) ? 1 : 0);\n+                    return;\n+                default:\n+                    // fallback: mode number, pass transparent\n+                    // if string is not parsable parseInt() throws an exception\n+                    mode = Integer.parseInt(modeStr);\n+                    isNumber = true;\n+                    break;\n+            }\n+            logger.debug(\"{}: Mode {} mapped to {}\", thingId, modeStr, mode);\n+        }\n+\n+        if (mode == -1) {\n+            throw new IllegalArgumentException(\"Invalid Mode selection\");\n+        }\n+\n+        // Turn on the unit if currently off\n+        if (!isNumber && (device.getIntStatusVal(GREE_PROP_POWER) == 0)) {\n+            logger.debug(\"{}: Send Auto-ON for mode {}\", thingId, mode);\n+            device.setDevicePower(socket, 1);\n+        }\n+\n+        // Select mode\n+        logger.debug(\"{}: Select mode {}\", thingId, mode);\n+        device.SetDeviceMode(socket, mode);\n+\n+        // Check for secondary action\n+        switch (modeStr) {\n+            case MODE_ECO:\n+                // Turn on power saving for eco mode\n+                logger.debug(\"{}: Turn on Power-Saving\", thingId);\n+                device.setDevicePwrSaving(socket, 1);\n+                break;\n+        }\n+    }\n+\n+    private void handleQuietCommand(DatagramSocket socket, Command command) throws GreeException {\n+        int mode = -1;\n+        if (command instanceof DecimalType) {\n+            mode = ((DecimalType) command).intValue();\n+        } else if (command instanceof StringType) {\n+            switch (command.toString().toLowerCase()) {\n+                case QUIET_OFF:\n+                    mode = GREE_QUIET_OFF;\n+                    break;\n+                case QUIET_AUTO:\n+                    mode = GREE_QUIET_AUTO;\n+                    break;\n+                case QUIET_QUIET:\n+                    mode = GREE_QUIET_QUIET;\n+                    break;\n+            }\n+        }\n+        if (mode != -1) {\n+            device.setQuietMode(socket, mode);\n+        } else {\n+            throw new IllegalArgumentException(\"Invalid QuietType\");\n+        }\n+    }\n+\n+    private int getOnOff(Command command) {\n+        if (command instanceof OnOffType) {\n+            return ((OnOffType) command) == OnOffType.ON ? 1 : 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ddbba49f802627554c380ef9a5b829ac7b1f8cb1"}, "originalPosition": 301}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg5ODc3OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            return ((DecimalType) command).intValue();\n          \n          \n            \n                            return value;", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r441898778", "createdAt": "2020-06-18T00:08:52Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeHandler.java", "diffHunk": "@@ -0,0 +1,525 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.net.DatagramSocket;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.ImperialUnits;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.gree.internal.GreeConfiguration;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.discovery.GreeDeviceFinder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link GreeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(GreeHandler.class);\n+    private final GreeTranslationProvider messages;\n+    private GreeConfiguration config = new GreeConfiguration();\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+    private GreeAirDevice device = new GreeAirDevice();\n+    private Optional<DatagramSocket> clientSocket = Optional.empty();\n+    private final String thingId;\n+    private boolean forceRefresh = false;\n+\n+    private @Nullable ScheduledFuture<?> refreshTask;\n+    private long lastRefreshTime = 0;\n+\n+    public GreeHandler(Thing thing, GreeTranslationProvider messages) {\n+        super(thing);\n+        this.messages = messages;\n+        String label = getThing().getLabel();\n+        this.thingId = label != null ? label : getThing().getUID().getId();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(GreeConfiguration.class);\n+        logger.debug(\"{}: Config for {} is {}\", thing.getUID(), thingId, config.toString());\n+        if (config.ipAddress.isEmpty() || (config.refresh < 0)) {\n+            logger.warn(\"{}: Config of {} is invalid. Check configuration\", thingId, thing.getUID());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid configuration. Check thing configuration.\");\n+            return;\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.execute(this::initializeThing);\n+    }\n+\n+    private void initializeThing() {\n+        try {\n+            if (!clientSocket.isPresent()) {\n+                clientSocket = Optional.of(new DatagramSocket());\n+                clientSocket.get().setSoTimeout(DATAGRAM_SOCKET_TIMEOUT);\n+            }\n+            // Find the GREE device\n+            deviceFinder = new GreeDeviceFinder(config.ipAddress);\n+            deviceFinder.scan(clientSocket.get(), false);\n+            logger.debug(\"{}: {} units found matching IP address\", thingId, deviceFinder.getScannedDeviceCount());\n+\n+            // Now check that this one is amongst the air conditioners that responded.\n+            GreeAirDevice newDevice = deviceFinder.getDeviceByIPAddress(config.ipAddress);\n+            if (newDevice != null) {\n+                // Ok, our device responded, now let's Bind with it\n+                device = newDevice;\n+                device.bindWithDevice(clientSocket.get());\n+                if (device.getIsBound()) {\n+                    updateStatus(ThingStatus.ONLINE);\n+\n+                    // Start the automatic refresh cycles\n+                    startAutomaticRefresh();\n+                    return;\n+                }\n+            }\n+            logger.debug(\"{}: GREE unit is not responding\", thingId);\n+        } catch (GreeException e) {\n+            logger.warn(\"{}: Initialization failed: {}\", thingId, messages.get(\"thinginit.exception\", e.toString()));\n+        } catch (IOException e) {\n+            logger.debug(\"{}: Exception on initialization: {}\", thingId, e.toString());\n+        } catch (RuntimeException e) {\n+            logger.warn(\"{}: Initialization failed\", thingId, e);\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Thing initialization failed!\");\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            // The thing is updated by the scheduled automatic refresh so do nothing here.\n+        } else {\n+            logger.debug(\"{}: Issue command {}\u00a0to channe {}\", thingId, command, channelUID.getIdWithoutGroup());\n+            String channelId = channelUID.getIdWithoutGroup();\n+            logger.debug(\"{}: Handle command {} for channel {}, command class {}\", thingId, command, channelId,\n+                    command.getClass());\n+            try {\n+                DatagramSocket socket = clientSocket.get();\n+                switch (channelId) {\n+                    case MODE_CHANNEL:\n+                        handleModeCommand(socket, command);\n+                        break;\n+                    case POWER_CHANNEL:\n+                        device.setDevicePower(socket, getOnOff(command));\n+                        break;\n+                    case TURBO_CHANNEL:\n+                        device.setDeviceTurbo(socket, getOnOff(command));\n+                        break;\n+                    case LIGHT_CHANNEL:\n+                        device.setDeviceLight(socket, getOnOff(command));\n+                        break;\n+                    case TEMP_CHANNEL:\n+                        // Set value, read back effective one and update channel\n+                        // e.g. 22.5C will result in 22.0, because the AC doesn't support half-steps for C\n+                        device.setDeviceTempSet(socket, convertTemp(command));\n+                        break;\n+                    case SWINGUD_CHANNEL:\n+                        device.setDeviceSwingUpDown(socket, getNumber(command));\n+                        break;\n+                    case SWINGLR_CHANNEL:\n+                        device.setDeviceSwingLeftRight(socket, getNumber(command));\n+                        break;\n+                    case WINDSPEED_CHANNEL:\n+                        device.setDeviceWindspeed(socket, getNumber(command));\n+                        break;\n+                    case QUIET_CHANNEL:\n+                        handleQuietCommand(socket, command);\n+                        break;\n+                    case AIR_CHANNEL:\n+                        device.setDeviceAir(socket, getOnOff(command));\n+                        break;\n+                    case DRY_CHANNEL:\n+                        device.setDeviceDry(socket, getOnOff(command));\n+                        break;\n+                    case HEALTH_CHANNEL:\n+                        device.setDeviceHealth(socket, getOnOff(command));\n+                        break;\n+                    case PWRSAV_CHANNEL:\n+                        device.setDevicePwrSaving(socket, getOnOff(command));\n+                        break;\n+                }\n+\n+                // force refresh on next status refresh cycle\n+                forceRefresh = true;\n+            } catch (GreeException e) {\n+                logger.debug(\"{}: Unable to execute command {}\u00a0for channel {}: {}\", thingId, command, channelId,\n+                        e.toString());\n+            } catch (IllegalArgumentException e) {\n+                logger.warn(\"{}: Invalid command value {}\u00a0for channel {}\", thingId, command, channelUID.getId());\n+            } catch (RuntimeException e) {\n+                logger.warn(\"{}: Unable to execute command {}\u00a0for channel {}\", thingId, command, channelId, e);\n+            }\n+        }\n+    }\n+\n+    private void handleModeCommand(DatagramSocket socket, Command command) throws GreeException {\n+        int mode = -1;\n+        String modeStr = \"\";\n+        boolean isNumber = false;\n+        if (command instanceof DecimalType) {\n+            // backward compatibility when channel was Number\n+            mode = ((DecimalType) command).intValue();\n+        } else if (command instanceof OnOffType) {\n+            // Switch\n+            logger.debug(\"{}: Send Power-{}\", thingId, command);\n+            device.setDevicePower(socket, getOnOff(command));\n+        } else /* String */ {\n+            modeStr = command.toString().toLowerCase();\n+            switch (modeStr) {\n+                case MODE_AUTO:\n+                    mode = GREE_MODE_AUTO;\n+                    break;\n+                case MODE_COOL:\n+                    mode = GREE_MODE_COOL;\n+                    break;\n+                case MODE_HEAT:\n+                    mode = GREE_MODE_HEAT;\n+                    break;\n+                case MODE_DRY:\n+                    mode = GREE_MODE_DRY;\n+                    break;\n+                case MODE_FAN:\n+                case MODE_FAN2:\n+                    mode = GREE_MODE_FAN;\n+                    break;\n+                case MODE_ECO:\n+                    // power saving will be set after the uinit was turned on\n+                    mode = GREE_MODE_COOL;\n+                    break;\n+                case MODE_ON:\n+                case MODE_OFF:\n+                    logger.debug(\"{}: Turn unit {}\", thingId, modeStr);\n+                    device.setDevicePower(socket, modeStr.equals(MODE_ON) ? 1 : 0);\n+                    return;\n+                default:\n+                    // fallback: mode number, pass transparent\n+                    // if string is not parsable parseInt() throws an exception\n+                    mode = Integer.parseInt(modeStr);\n+                    isNumber = true;\n+                    break;\n+            }\n+            logger.debug(\"{}: Mode {} mapped to {}\", thingId, modeStr, mode);\n+        }\n+\n+        if (mode == -1) {\n+            throw new IllegalArgumentException(\"Invalid Mode selection\");\n+        }\n+\n+        // Turn on the unit if currently off\n+        if (!isNumber && (device.getIntStatusVal(GREE_PROP_POWER) == 0)) {\n+            logger.debug(\"{}: Send Auto-ON for mode {}\", thingId, mode);\n+            device.setDevicePower(socket, 1);\n+        }\n+\n+        // Select mode\n+        logger.debug(\"{}: Select mode {}\", thingId, mode);\n+        device.SetDeviceMode(socket, mode);\n+\n+        // Check for secondary action\n+        switch (modeStr) {\n+            case MODE_ECO:\n+                // Turn on power saving for eco mode\n+                logger.debug(\"{}: Turn on Power-Saving\", thingId);\n+                device.setDevicePwrSaving(socket, 1);\n+                break;\n+        }\n+    }\n+\n+    private void handleQuietCommand(DatagramSocket socket, Command command) throws GreeException {\n+        int mode = -1;\n+        if (command instanceof DecimalType) {\n+            mode = ((DecimalType) command).intValue();\n+        } else if (command instanceof StringType) {\n+            switch (command.toString().toLowerCase()) {\n+                case QUIET_OFF:\n+                    mode = GREE_QUIET_OFF;\n+                    break;\n+                case QUIET_AUTO:\n+                    mode = GREE_QUIET_AUTO;\n+                    break;\n+                case QUIET_QUIET:\n+                    mode = GREE_QUIET_QUIET;\n+                    break;\n+            }\n+        }\n+        if (mode != -1) {\n+            device.setQuietMode(socket, mode);\n+        } else {\n+            throw new IllegalArgumentException(\"Invalid QuietType\");\n+        }\n+    }\n+\n+    private int getOnOff(Command command) {\n+        if (command instanceof OnOffType) {\n+            return ((OnOffType) command) == OnOffType.ON ? 1 : 0;\n+        }\n+        if (command instanceof DecimalType) {\n+            int value = ((DecimalType) command).intValue();\n+            if ((value == 0) || (value == 1)) {\n+                return ((DecimalType) command).intValue();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ddbba49f802627554c380ef9a5b829ac7b1f8cb1"}, "originalPosition": 306}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg5OTU5OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    throw new IllegalArgumentException(\"Invalud Number type\");\n          \n          \n            \n                    throw new IllegalArgumentException(\"Invalid Number type\");", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r441899598", "createdAt": "2020-06-18T00:12:13Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeHandler.java", "diffHunk": "@@ -0,0 +1,525 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.net.DatagramSocket;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.ImperialUnits;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.gree.internal.GreeConfiguration;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.discovery.GreeDeviceFinder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link GreeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(GreeHandler.class);\n+    private final GreeTranslationProvider messages;\n+    private GreeConfiguration config = new GreeConfiguration();\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+    private GreeAirDevice device = new GreeAirDevice();\n+    private Optional<DatagramSocket> clientSocket = Optional.empty();\n+    private final String thingId;\n+    private boolean forceRefresh = false;\n+\n+    private @Nullable ScheduledFuture<?> refreshTask;\n+    private long lastRefreshTime = 0;\n+\n+    public GreeHandler(Thing thing, GreeTranslationProvider messages) {\n+        super(thing);\n+        this.messages = messages;\n+        String label = getThing().getLabel();\n+        this.thingId = label != null ? label : getThing().getUID().getId();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(GreeConfiguration.class);\n+        logger.debug(\"{}: Config for {} is {}\", thing.getUID(), thingId, config.toString());\n+        if (config.ipAddress.isEmpty() || (config.refresh < 0)) {\n+            logger.warn(\"{}: Config of {} is invalid. Check configuration\", thingId, thing.getUID());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid configuration. Check thing configuration.\");\n+            return;\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.execute(this::initializeThing);\n+    }\n+\n+    private void initializeThing() {\n+        try {\n+            if (!clientSocket.isPresent()) {\n+                clientSocket = Optional.of(new DatagramSocket());\n+                clientSocket.get().setSoTimeout(DATAGRAM_SOCKET_TIMEOUT);\n+            }\n+            // Find the GREE device\n+            deviceFinder = new GreeDeviceFinder(config.ipAddress);\n+            deviceFinder.scan(clientSocket.get(), false);\n+            logger.debug(\"{}: {} units found matching IP address\", thingId, deviceFinder.getScannedDeviceCount());\n+\n+            // Now check that this one is amongst the air conditioners that responded.\n+            GreeAirDevice newDevice = deviceFinder.getDeviceByIPAddress(config.ipAddress);\n+            if (newDevice != null) {\n+                // Ok, our device responded, now let's Bind with it\n+                device = newDevice;\n+                device.bindWithDevice(clientSocket.get());\n+                if (device.getIsBound()) {\n+                    updateStatus(ThingStatus.ONLINE);\n+\n+                    // Start the automatic refresh cycles\n+                    startAutomaticRefresh();\n+                    return;\n+                }\n+            }\n+            logger.debug(\"{}: GREE unit is not responding\", thingId);\n+        } catch (GreeException e) {\n+            logger.warn(\"{}: Initialization failed: {}\", thingId, messages.get(\"thinginit.exception\", e.toString()));\n+        } catch (IOException e) {\n+            logger.debug(\"{}: Exception on initialization: {}\", thingId, e.toString());\n+        } catch (RuntimeException e) {\n+            logger.warn(\"{}: Initialization failed\", thingId, e);\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Thing initialization failed!\");\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            // The thing is updated by the scheduled automatic refresh so do nothing here.\n+        } else {\n+            logger.debug(\"{}: Issue command {}\u00a0to channe {}\", thingId, command, channelUID.getIdWithoutGroup());\n+            String channelId = channelUID.getIdWithoutGroup();\n+            logger.debug(\"{}: Handle command {} for channel {}, command class {}\", thingId, command, channelId,\n+                    command.getClass());\n+            try {\n+                DatagramSocket socket = clientSocket.get();\n+                switch (channelId) {\n+                    case MODE_CHANNEL:\n+                        handleModeCommand(socket, command);\n+                        break;\n+                    case POWER_CHANNEL:\n+                        device.setDevicePower(socket, getOnOff(command));\n+                        break;\n+                    case TURBO_CHANNEL:\n+                        device.setDeviceTurbo(socket, getOnOff(command));\n+                        break;\n+                    case LIGHT_CHANNEL:\n+                        device.setDeviceLight(socket, getOnOff(command));\n+                        break;\n+                    case TEMP_CHANNEL:\n+                        // Set value, read back effective one and update channel\n+                        // e.g. 22.5C will result in 22.0, because the AC doesn't support half-steps for C\n+                        device.setDeviceTempSet(socket, convertTemp(command));\n+                        break;\n+                    case SWINGUD_CHANNEL:\n+                        device.setDeviceSwingUpDown(socket, getNumber(command));\n+                        break;\n+                    case SWINGLR_CHANNEL:\n+                        device.setDeviceSwingLeftRight(socket, getNumber(command));\n+                        break;\n+                    case WINDSPEED_CHANNEL:\n+                        device.setDeviceWindspeed(socket, getNumber(command));\n+                        break;\n+                    case QUIET_CHANNEL:\n+                        handleQuietCommand(socket, command);\n+                        break;\n+                    case AIR_CHANNEL:\n+                        device.setDeviceAir(socket, getOnOff(command));\n+                        break;\n+                    case DRY_CHANNEL:\n+                        device.setDeviceDry(socket, getOnOff(command));\n+                        break;\n+                    case HEALTH_CHANNEL:\n+                        device.setDeviceHealth(socket, getOnOff(command));\n+                        break;\n+                    case PWRSAV_CHANNEL:\n+                        device.setDevicePwrSaving(socket, getOnOff(command));\n+                        break;\n+                }\n+\n+                // force refresh on next status refresh cycle\n+                forceRefresh = true;\n+            } catch (GreeException e) {\n+                logger.debug(\"{}: Unable to execute command {}\u00a0for channel {}: {}\", thingId, command, channelId,\n+                        e.toString());\n+            } catch (IllegalArgumentException e) {\n+                logger.warn(\"{}: Invalid command value {}\u00a0for channel {}\", thingId, command, channelUID.getId());\n+            } catch (RuntimeException e) {\n+                logger.warn(\"{}: Unable to execute command {}\u00a0for channel {}\", thingId, command, channelId, e);\n+            }\n+        }\n+    }\n+\n+    private void handleModeCommand(DatagramSocket socket, Command command) throws GreeException {\n+        int mode = -1;\n+        String modeStr = \"\";\n+        boolean isNumber = false;\n+        if (command instanceof DecimalType) {\n+            // backward compatibility when channel was Number\n+            mode = ((DecimalType) command).intValue();\n+        } else if (command instanceof OnOffType) {\n+            // Switch\n+            logger.debug(\"{}: Send Power-{}\", thingId, command);\n+            device.setDevicePower(socket, getOnOff(command));\n+        } else /* String */ {\n+            modeStr = command.toString().toLowerCase();\n+            switch (modeStr) {\n+                case MODE_AUTO:\n+                    mode = GREE_MODE_AUTO;\n+                    break;\n+                case MODE_COOL:\n+                    mode = GREE_MODE_COOL;\n+                    break;\n+                case MODE_HEAT:\n+                    mode = GREE_MODE_HEAT;\n+                    break;\n+                case MODE_DRY:\n+                    mode = GREE_MODE_DRY;\n+                    break;\n+                case MODE_FAN:\n+                case MODE_FAN2:\n+                    mode = GREE_MODE_FAN;\n+                    break;\n+                case MODE_ECO:\n+                    // power saving will be set after the uinit was turned on\n+                    mode = GREE_MODE_COOL;\n+                    break;\n+                case MODE_ON:\n+                case MODE_OFF:\n+                    logger.debug(\"{}: Turn unit {}\", thingId, modeStr);\n+                    device.setDevicePower(socket, modeStr.equals(MODE_ON) ? 1 : 0);\n+                    return;\n+                default:\n+                    // fallback: mode number, pass transparent\n+                    // if string is not parsable parseInt() throws an exception\n+                    mode = Integer.parseInt(modeStr);\n+                    isNumber = true;\n+                    break;\n+            }\n+            logger.debug(\"{}: Mode {} mapped to {}\", thingId, modeStr, mode);\n+        }\n+\n+        if (mode == -1) {\n+            throw new IllegalArgumentException(\"Invalid Mode selection\");\n+        }\n+\n+        // Turn on the unit if currently off\n+        if (!isNumber && (device.getIntStatusVal(GREE_PROP_POWER) == 0)) {\n+            logger.debug(\"{}: Send Auto-ON for mode {}\", thingId, mode);\n+            device.setDevicePower(socket, 1);\n+        }\n+\n+        // Select mode\n+        logger.debug(\"{}: Select mode {}\", thingId, mode);\n+        device.SetDeviceMode(socket, mode);\n+\n+        // Check for secondary action\n+        switch (modeStr) {\n+            case MODE_ECO:\n+                // Turn on power saving for eco mode\n+                logger.debug(\"{}: Turn on Power-Saving\", thingId);\n+                device.setDevicePwrSaving(socket, 1);\n+                break;\n+        }\n+    }\n+\n+    private void handleQuietCommand(DatagramSocket socket, Command command) throws GreeException {\n+        int mode = -1;\n+        if (command instanceof DecimalType) {\n+            mode = ((DecimalType) command).intValue();\n+        } else if (command instanceof StringType) {\n+            switch (command.toString().toLowerCase()) {\n+                case QUIET_OFF:\n+                    mode = GREE_QUIET_OFF;\n+                    break;\n+                case QUIET_AUTO:\n+                    mode = GREE_QUIET_AUTO;\n+                    break;\n+                case QUIET_QUIET:\n+                    mode = GREE_QUIET_QUIET;\n+                    break;\n+            }\n+        }\n+        if (mode != -1) {\n+            device.setQuietMode(socket, mode);\n+        } else {\n+            throw new IllegalArgumentException(\"Invalid QuietType\");\n+        }\n+    }\n+\n+    private int getOnOff(Command command) {\n+        if (command instanceof OnOffType) {\n+            return ((OnOffType) command) == OnOffType.ON ? 1 : 0;\n+        }\n+        if (command instanceof DecimalType) {\n+            int value = ((DecimalType) command).intValue();\n+            if ((value == 0) || (value == 1)) {\n+                return ((DecimalType) command).intValue();\n+            }\n+        }\n+        throw new IllegalArgumentException(\"Invalid OnOffType\");\n+    }\n+\n+    private int getNumber(Command command) {\n+        if (command instanceof DecimalType) {\n+            return ((DecimalType) command).intValue();\n+        }\n+        throw new IllegalArgumentException(\"Invalud Number type\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ddbba49f802627554c380ef9a5b829ac7b1f8cb1"}, "originalPosition": 316}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkwMDI0MA==", "bodyText": "These can be merged together.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static State toQuantityType(int value, int digits, Unit<?> unit) {\n          \n          \n            \n                    BigDecimal bd = new BigDecimal(value);\n          \n          \n            \n                    return new QuantityType<>(bd.setScale(digits, BigDecimal.ROUND_HALF_EVEN), unit);\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                public static QuantityType<?> toQuantityType(DecimalType value, int digits, Unit<?> unit) {\n          \n          \n            \n                    BigDecimal bd = new BigDecimal(value.doubleValue());\n          \n          \n            \n                    return new QuantityType<>(bd.setScale(digits, BigDecimal.ROUND_HALF_EVEN), unit);\n          \n          \n            \n                }\n          \n          \n            \n                public static QuantityType<?> toQuantityType(Number value, int digits, Unit<?> unit) {\n          \n          \n            \n                    BigDecimal bd = new BigDecimal(value.doubleValue());\n          \n          \n            \n                    return new QuantityType<>(bd.setScale(digits, BigDecimal.ROUND_HALF_EVEN), unit);\n          \n          \n            \n                }", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r441900240", "createdAt": "2020-06-18T00:14:44Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeHandler.java", "diffHunk": "@@ -0,0 +1,525 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.net.DatagramSocket;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.ImperialUnits;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.gree.internal.GreeConfiguration;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.discovery.GreeDeviceFinder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link GreeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(GreeHandler.class);\n+    private final GreeTranslationProvider messages;\n+    private GreeConfiguration config = new GreeConfiguration();\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+    private GreeAirDevice device = new GreeAirDevice();\n+    private Optional<DatagramSocket> clientSocket = Optional.empty();\n+    private final String thingId;\n+    private boolean forceRefresh = false;\n+\n+    private @Nullable ScheduledFuture<?> refreshTask;\n+    private long lastRefreshTime = 0;\n+\n+    public GreeHandler(Thing thing, GreeTranslationProvider messages) {\n+        super(thing);\n+        this.messages = messages;\n+        String label = getThing().getLabel();\n+        this.thingId = label != null ? label : getThing().getUID().getId();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(GreeConfiguration.class);\n+        logger.debug(\"{}: Config for {} is {}\", thing.getUID(), thingId, config.toString());\n+        if (config.ipAddress.isEmpty() || (config.refresh < 0)) {\n+            logger.warn(\"{}: Config of {} is invalid. Check configuration\", thingId, thing.getUID());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Invalid configuration. Check thing configuration.\");\n+            return;\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.execute(this::initializeThing);\n+    }\n+\n+    private void initializeThing() {\n+        try {\n+            if (!clientSocket.isPresent()) {\n+                clientSocket = Optional.of(new DatagramSocket());\n+                clientSocket.get().setSoTimeout(DATAGRAM_SOCKET_TIMEOUT);\n+            }\n+            // Find the GREE device\n+            deviceFinder = new GreeDeviceFinder(config.ipAddress);\n+            deviceFinder.scan(clientSocket.get(), false);\n+            logger.debug(\"{}: {} units found matching IP address\", thingId, deviceFinder.getScannedDeviceCount());\n+\n+            // Now check that this one is amongst the air conditioners that responded.\n+            GreeAirDevice newDevice = deviceFinder.getDeviceByIPAddress(config.ipAddress);\n+            if (newDevice != null) {\n+                // Ok, our device responded, now let's Bind with it\n+                device = newDevice;\n+                device.bindWithDevice(clientSocket.get());\n+                if (device.getIsBound()) {\n+                    updateStatus(ThingStatus.ONLINE);\n+\n+                    // Start the automatic refresh cycles\n+                    startAutomaticRefresh();\n+                    return;\n+                }\n+            }\n+            logger.debug(\"{}: GREE unit is not responding\", thingId);\n+        } catch (GreeException e) {\n+            logger.warn(\"{}: Initialization failed: {}\", thingId, messages.get(\"thinginit.exception\", e.toString()));\n+        } catch (IOException e) {\n+            logger.debug(\"{}: Exception on initialization: {}\", thingId, e.toString());\n+        } catch (RuntimeException e) {\n+            logger.warn(\"{}: Initialization failed\", thingId, e);\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Thing initialization failed!\");\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            // The thing is updated by the scheduled automatic refresh so do nothing here.\n+        } else {\n+            logger.debug(\"{}: Issue command {}\u00a0to channe {}\", thingId, command, channelUID.getIdWithoutGroup());\n+            String channelId = channelUID.getIdWithoutGroup();\n+            logger.debug(\"{}: Handle command {} for channel {}, command class {}\", thingId, command, channelId,\n+                    command.getClass());\n+            try {\n+                DatagramSocket socket = clientSocket.get();\n+                switch (channelId) {\n+                    case MODE_CHANNEL:\n+                        handleModeCommand(socket, command);\n+                        break;\n+                    case POWER_CHANNEL:\n+                        device.setDevicePower(socket, getOnOff(command));\n+                        break;\n+                    case TURBO_CHANNEL:\n+                        device.setDeviceTurbo(socket, getOnOff(command));\n+                        break;\n+                    case LIGHT_CHANNEL:\n+                        device.setDeviceLight(socket, getOnOff(command));\n+                        break;\n+                    case TEMP_CHANNEL:\n+                        // Set value, read back effective one and update channel\n+                        // e.g. 22.5C will result in 22.0, because the AC doesn't support half-steps for C\n+                        device.setDeviceTempSet(socket, convertTemp(command));\n+                        break;\n+                    case SWINGUD_CHANNEL:\n+                        device.setDeviceSwingUpDown(socket, getNumber(command));\n+                        break;\n+                    case SWINGLR_CHANNEL:\n+                        device.setDeviceSwingLeftRight(socket, getNumber(command));\n+                        break;\n+                    case WINDSPEED_CHANNEL:\n+                        device.setDeviceWindspeed(socket, getNumber(command));\n+                        break;\n+                    case QUIET_CHANNEL:\n+                        handleQuietCommand(socket, command);\n+                        break;\n+                    case AIR_CHANNEL:\n+                        device.setDeviceAir(socket, getOnOff(command));\n+                        break;\n+                    case DRY_CHANNEL:\n+                        device.setDeviceDry(socket, getOnOff(command));\n+                        break;\n+                    case HEALTH_CHANNEL:\n+                        device.setDeviceHealth(socket, getOnOff(command));\n+                        break;\n+                    case PWRSAV_CHANNEL:\n+                        device.setDevicePwrSaving(socket, getOnOff(command));\n+                        break;\n+                }\n+\n+                // force refresh on next status refresh cycle\n+                forceRefresh = true;\n+            } catch (GreeException e) {\n+                logger.debug(\"{}: Unable to execute command {}\u00a0for channel {}: {}\", thingId, command, channelId,\n+                        e.toString());\n+            } catch (IllegalArgumentException e) {\n+                logger.warn(\"{}: Invalid command value {}\u00a0for channel {}\", thingId, command, channelUID.getId());\n+            } catch (RuntimeException e) {\n+                logger.warn(\"{}: Unable to execute command {}\u00a0for channel {}\", thingId, command, channelId, e);\n+            }\n+        }\n+    }\n+\n+    private void handleModeCommand(DatagramSocket socket, Command command) throws GreeException {\n+        int mode = -1;\n+        String modeStr = \"\";\n+        boolean isNumber = false;\n+        if (command instanceof DecimalType) {\n+            // backward compatibility when channel was Number\n+            mode = ((DecimalType) command).intValue();\n+        } else if (command instanceof OnOffType) {\n+            // Switch\n+            logger.debug(\"{}: Send Power-{}\", thingId, command);\n+            device.setDevicePower(socket, getOnOff(command));\n+        } else /* String */ {\n+            modeStr = command.toString().toLowerCase();\n+            switch (modeStr) {\n+                case MODE_AUTO:\n+                    mode = GREE_MODE_AUTO;\n+                    break;\n+                case MODE_COOL:\n+                    mode = GREE_MODE_COOL;\n+                    break;\n+                case MODE_HEAT:\n+                    mode = GREE_MODE_HEAT;\n+                    break;\n+                case MODE_DRY:\n+                    mode = GREE_MODE_DRY;\n+                    break;\n+                case MODE_FAN:\n+                case MODE_FAN2:\n+                    mode = GREE_MODE_FAN;\n+                    break;\n+                case MODE_ECO:\n+                    // power saving will be set after the uinit was turned on\n+                    mode = GREE_MODE_COOL;\n+                    break;\n+                case MODE_ON:\n+                case MODE_OFF:\n+                    logger.debug(\"{}: Turn unit {}\", thingId, modeStr);\n+                    device.setDevicePower(socket, modeStr.equals(MODE_ON) ? 1 : 0);\n+                    return;\n+                default:\n+                    // fallback: mode number, pass transparent\n+                    // if string is not parsable parseInt() throws an exception\n+                    mode = Integer.parseInt(modeStr);\n+                    isNumber = true;\n+                    break;\n+            }\n+            logger.debug(\"{}: Mode {} mapped to {}\", thingId, modeStr, mode);\n+        }\n+\n+        if (mode == -1) {\n+            throw new IllegalArgumentException(\"Invalid Mode selection\");\n+        }\n+\n+        // Turn on the unit if currently off\n+        if (!isNumber && (device.getIntStatusVal(GREE_PROP_POWER) == 0)) {\n+            logger.debug(\"{}: Send Auto-ON for mode {}\", thingId, mode);\n+            device.setDevicePower(socket, 1);\n+        }\n+\n+        // Select mode\n+        logger.debug(\"{}: Select mode {}\", thingId, mode);\n+        device.SetDeviceMode(socket, mode);\n+\n+        // Check for secondary action\n+        switch (modeStr) {\n+            case MODE_ECO:\n+                // Turn on power saving for eco mode\n+                logger.debug(\"{}: Turn on Power-Saving\", thingId);\n+                device.setDevicePwrSaving(socket, 1);\n+                break;\n+        }\n+    }\n+\n+    private void handleQuietCommand(DatagramSocket socket, Command command) throws GreeException {\n+        int mode = -1;\n+        if (command instanceof DecimalType) {\n+            mode = ((DecimalType) command).intValue();\n+        } else if (command instanceof StringType) {\n+            switch (command.toString().toLowerCase()) {\n+                case QUIET_OFF:\n+                    mode = GREE_QUIET_OFF;\n+                    break;\n+                case QUIET_AUTO:\n+                    mode = GREE_QUIET_AUTO;\n+                    break;\n+                case QUIET_QUIET:\n+                    mode = GREE_QUIET_QUIET;\n+                    break;\n+            }\n+        }\n+        if (mode != -1) {\n+            device.setQuietMode(socket, mode);\n+        } else {\n+            throw new IllegalArgumentException(\"Invalid QuietType\");\n+        }\n+    }\n+\n+    private int getOnOff(Command command) {\n+        if (command instanceof OnOffType) {\n+            return ((OnOffType) command) == OnOffType.ON ? 1 : 0;\n+        }\n+        if (command instanceof DecimalType) {\n+            int value = ((DecimalType) command).intValue();\n+            if ((value == 0) || (value == 1)) {\n+                return ((DecimalType) command).intValue();\n+            }\n+        }\n+        throw new IllegalArgumentException(\"Invalid OnOffType\");\n+    }\n+\n+    private int getNumber(Command command) {\n+        if (command instanceof DecimalType) {\n+            return ((DecimalType) command).intValue();\n+        }\n+        throw new IllegalArgumentException(\"Invalud Number type\");\n+    }\n+\n+    private QuantityType<?> convertTemp(Command command) {\n+        if (command instanceof DecimalType) {\n+            // The Number alone doesn't specify the temp unit\n+            // for this get current setting from the A/C unit\n+            int unit = device.getIntStatusVal(GREE_PROP_TEMPUNIT);\n+            return toQuantityType((DecimalType) command, DIGITS_TEMP,\n+                    unit == TEMP_UNIT_CELSIUS ? SIUnits.CELSIUS : ImperialUnits.FAHRENHEIT);\n+        }\n+        if (command instanceof QuantityType) {\n+            return (QuantityType<?>) command;\n+        }\n+        throw new IllegalArgumentException(\"Invalud Temp type\");\n+    }\n+\n+    private void startAutomaticRefresh() {\n+        Runnable refresher = () -> {\n+            try {\n+                // safeguard for multiple REFRESH commands\n+                if (isMinimumRefreshTimeExceeded()) {\n+                    // Get the current status from the Airconditioner\n+                    device.getDeviceStatus(clientSocket.get());\n+                    logger.debug(\"{}: Executing automatic update of values\", thingId);\n+\n+                    // Update All Channels\n+                    List<Channel> channels = getThing().getChannels();\n+                    for (Channel channel : channels) {\n+                        publishChannel(channel.getUID());\n+                    }\n+                }\n+            } catch (GreeException e) {\n+                if (!e.isTimeout()) {\n+                    logger.warn(\"{}: Unable to perform auto-update: {} ({})\", thingId, e.toString(),\n+                            e.getCause().getMessage());\n+                }\n+            } catch (RuntimeException e) {\n+                logger.warn(\"{}: Unable to perform auto-update\", thingId, e);\n+            }\n+        };\n+\n+        forceRefresh = false;\n+        if ((refreshTask != null) && !refreshTask.isCancelled()) {\n+            refreshTask.cancel(true);\n+        }\n+        refreshTask = scheduler.scheduleWithFixedDelay(refresher, 0, REFRESH_INTERVAL_SEC, TimeUnit.SECONDS);\n+        logger.debug(\"{}: Automatic refresh started ({} second interval)\", thingId, config.refresh);\n+    }\n+\n+    private boolean isMinimumRefreshTimeExceeded() {\n+        long currentTime = Instant.now().toEpochMilli();\n+        long timeSinceLastRefresh = currentTime - lastRefreshTime;\n+        lastRefreshTime = currentTime;\n+        if (!forceRefresh && ((lastRefreshTime == 0) || (timeSinceLastRefresh < config.refresh * 1000))) {\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    private void publishChannel(ChannelUID channelUID) {\n+        try {\n+            String channelID = channelUID.getId();\n+            State state = null;\n+            switch (channelUID.getIdWithoutGroup()) {\n+                case POWER_CHANNEL:\n+                    state = updateOnOff(GREE_PROP_POWER);\n+                    break;\n+                case MODE_CHANNEL:\n+                    state = updateMode();\n+                    break;\n+                case TURBO_CHANNEL:\n+                    state = updateOnOff(GREE_PROP_TURBO);\n+                    break;\n+                case LIGHT_CHANNEL:\n+                    state = updateOnOff(GREE_PROP_LIGHT);\n+                    break;\n+                case TEMP_CHANNEL:\n+                    state = updateTemp();\n+                    break;\n+                case SWINGUD_CHANNEL:\n+                    state = updateNumber(GREE_PROP_SWINGUPDOWN);\n+                    break;\n+                case SWINGLR_CHANNEL:\n+                    state = updateNumber(GREE_PROP_SWINGLEFTRIGHT);\n+                    break;\n+                case WINDSPEED_CHANNEL:\n+                    state = updateNumber(GREE_PROP_WINDSPEED);\n+                    break;\n+                case QUIET_CHANNEL:\n+                    state = updateQuiet();\n+                    break;\n+                case AIR_CHANNEL:\n+                    state = updateOnOff(GREE_PROP_AIR);\n+                    break;\n+                case DRY_CHANNEL:\n+                    state = updateOnOff(GREE_PROP_DRY);\n+                    break;\n+                case HEALTH_CHANNEL:\n+                    state = updateOnOff(GREE_PROP_HEALTH);\n+                    break;\n+                case PWRSAV_CHANNEL:\n+                    state = updateOnOff(GREE_PROP_PWR_SAVING);\n+                    break;\n+            }\n+            if (state != null) {\n+                logger.debug(\"{}: Updating channel {} : {}\", thingId, channelID, state);\n+                updateState(channelID, state);\n+            }\n+        } catch (GreeException e) {\n+            logger.warn(\"{}: Exception on channel update: {}\", thingId, e.toString());\n+        } catch (RuntimeException e) {\n+            logger.warn(\"{}: Exception on channel update\", thingId, e);\n+        }\n+    }\n+\n+    private @Nullable State updateOnOff(final String valueName) throws GreeException {\n+        if (device.hasStatusValChanged(valueName)) {\n+            return device.getIntStatusVal(valueName) == 1 ? OnOffType.ON : OnOffType.OFF;\n+        }\n+        return null;\n+    }\n+\n+    private @Nullable State updateNumber(final String valueName) throws GreeException {\n+        if (device.hasStatusValChanged(valueName)) {\n+            return new DecimalType(device.getIntStatusVal(valueName));\n+        }\n+        return null;\n+    }\n+\n+    private @Nullable State updateMode() throws GreeException {\n+        if (device.hasStatusValChanged(GREE_PROP_MODE)) {\n+            int mode = device.getIntStatusVal(GREE_PROP_MODE);\n+            String modeStr = \"\";\n+            switch (mode) {\n+                case GREE_MODE_AUTO:\n+                    modeStr = MODE_AUTO;\n+                    break;\n+                case GREE_MODE_COOL:\n+                    boolean powerSave = device.getIntStatusVal(GREE_PROP_PWR_SAVING) == 1;\n+                    modeStr = !powerSave ? MODE_COOL : MODE_ECO;\n+                    break;\n+                case GREE_MODE_DRY:\n+                    modeStr = MODE_DRY;\n+                    break;\n+                case GREE_MODE_FAN:\n+                    modeStr = MODE_FAN;\n+                    break;\n+                case GREE_MODE_HEAT:\n+                    modeStr = MODE_HEAT;\n+                    break;\n+                default:\n+                    modeStr = String.valueOf(mode);\n+\n+            }\n+            if (!modeStr.isEmpty()) {\n+                logger.debug(\"{}: Updading mode channel with {}/{}\", thingId, mode, modeStr);\n+                return new StringType(modeStr);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private @Nullable State updateQuiet() throws GreeException {\n+        if (device.hasStatusValChanged(GREE_PROP_QUIET)) {\n+            switch (device.getIntStatusVal(GREE_PROP_QUIET)) {\n+                case GREE_QUIET_OFF:\n+                    return new StringType(QUIET_OFF);\n+                case GREE_QUIET_AUTO:\n+                    return new StringType(QUIET_AUTO);\n+                case GREE_QUIET_QUIET:\n+                    return new StringType(QUIET_QUIET);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private @Nullable State updateTemp() throws GreeException {\n+        if (device.hasStatusValChanged(GREE_PROP_SETTEMP) || device.hasStatusValChanged(GREE_PROP_TEMPUNIT)) {\n+            int unit = device.getIntStatusVal(GREE_PROP_TEMPUNIT);\n+            return toQuantityType(device.getIntStatusVal(GREE_PROP_SETTEMP), DIGITS_TEMP,\n+                    unit == TEMP_UNIT_CELSIUS ? SIUnits.CELSIUS : ImperialUnits.FAHRENHEIT);\n+        }\n+        return null;\n+    }\n+\n+    public static State toQuantityType(int value, int digits, Unit<?> unit) {\n+        BigDecimal bd = new BigDecimal(value);\n+        return new QuantityType<>(bd.setScale(digits, BigDecimal.ROUND_HALF_EVEN), unit);\n+    }\n+\n+    public static QuantityType<?> toQuantityType(DecimalType value, int digits, Unit<?> unit) {\n+        BigDecimal bd = new BigDecimal(value.doubleValue());\n+        return new QuantityType<>(bd.setScale(digits, BigDecimal.ROUND_HALF_EVEN), unit);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ddbba49f802627554c380ef9a5b829ac7b1f8cb1"}, "originalPosition": 510}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkwMjExNw==", "bodyText": "please specify the charset", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r441902117", "createdAt": "2020-06-18T00:22:22Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/GreeCryptoUtil.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.security.InvalidKeyException;\n+import java.security.Key;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Base64;\n+\n+import javax.crypto.BadPaddingException;\n+import javax.crypto.Cipher;\n+import javax.crypto.IllegalBlockSizeException;\n+import javax.crypto.NoSuchPaddingException;\n+import javax.crypto.spec.SecretKeySpec;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The CryptoUtil class provides functionality for encrypting and decrypting\n+ * messages sent to and from the Air Conditioner\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeCryptoUtil {\n+    private static final String AES_KEY = \"a3K8Bx%2r8Y7#xDh\";\n+\n+    public static String GetAESGeneralKey() {\n+        return AES_KEY;\n+    }\n+\n+    public static byte[] getAESGeneralKeyByteArray() {\n+        return AES_KEY.getBytes();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ddbba49f802627554c380ef9a5b829ac7b1f8cb1"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkwMjg3NA==", "bodyText": "You should catch the json syntax exception", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r441902874", "createdAt": "2020-06-18T00:25:25Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,530 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeRequestDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePackDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\n+ * device specific attributes as well a the functionality for the Air Conditioner\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeAirDevice {\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\n+    private final static Gson gson = new Gson();\n+    private boolean isBound = false;\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\n+    private int port = 0;\n+    private String encKey = \"\";\n+    private Optional<GreeScanResponseDTO> scanResponseGson = Optional.empty();\n+    private Optional<GreeStatusResponseDTO> statusResponseGson = Optional.empty();\n+    private Optional<GreeStatusResponsePackDTO> prevStatusResponsePackGson = Optional.empty();\n+\n+    public void getDeviceStatus(DatagramSocket clientSocket) throws GreeException {\n+        try {\n+            // Set the values in the HashMap\n+            ArrayList<String> columns = new ArrayList<>();\n+            columns.add(GREE_PROP_POWER);\n+            columns.add(GREE_PROP_MODE);\n+            columns.add(GREE_PROP_SETTEMP);\n+            columns.add(GREE_PROP_WINDSPEED);\n+            columns.add(GREE_PROP_AIR);\n+            columns.add(GREE_PROP_DRY);\n+            columns.add(GREE_PROP_HEALTH);\n+            columns.add(GREE_PROP_SLEEP);\n+            columns.add(GREE_PROP_LIGHT);\n+            columns.add(GREE_PROP_SWINGLEFTRIGHT);\n+            columns.add(GREE_PROP_SWINGUPDOWN);\n+            columns.add(GREE_PROP_QUIET);\n+            columns.add(GREE_PROP_TURBO);\n+            columns.add(GREE_PROP_TEMPUNIT);\n+            columns.add(GREE_PROP_HEAT);\n+            columns.add(GREE_PROP_HEATCOOL);\n+            columns.add(GREE_PROP_TEMPREC);\n+            columns.add(GREE_PROP_PWR_SAVING);\n+            columns.add(GREE_PROP_NOISESET);\n+\n+            // Convert the parameter map values to arrays\n+            String[] colArray = columns.toArray(new String[0]);\n+\n+            // Prep the Command Request pack\n+            GreeReqStatusPackDTO reqStatusPackGson = new GreeReqStatusPackDTO();\n+            reqStatusPackGson.t = GREE_CMDT_STATUS;\n+            reqStatusPackGson.cols = colArray;\n+            reqStatusPackGson.mac = getId();\n+            String reqStatusPackStr = gson.toJson(reqStatusPackGson);\n+\n+            // Encrypt and send the Status Request pack\n+            String encryptedStatusReqPacket = GreeCryptoUtil.encryptPack(getKey().getBytes(), reqStatusPackStr);\n+            DatagramPacket sendPacket = createPackRequest(0,\n+                    new String(encryptedStatusReqPacket.getBytes(), StandardCharsets.UTF_8));\n+            clientSocket.send(sendPacket);\n+\n+            // Recieve a response\n+            JsonReader receivedData = receiveResponse(clientSocket);\n+\n+            // Keep a copy of the old response to be used to check if values have changed\n+            // If first time running, there will not be a previous GreeStatusResponsePack4Gson\n+            if (statusResponseGson.isPresent() && statusResponseGson.get().packJson != null) {\n+                prevStatusResponsePackGson = Optional\n+                        .of(new GreeStatusResponsePackDTO(statusResponseGson.get().packJson));\n+            }\n+\n+            // Read the response, create the JSON to hold the response values\n+            GreeStatusResponseDTO resp = gson.fromJson(receivedData, GreeStatusResponseDTO.class);\n+            resp.decryptedPack = GreeCryptoUtil.decryptPack(this.getKey().getBytes(), resp.pack);\n+            logger.debug(\"Response from device: {}\", resp.decryptedPack);\n+            resp.packJson = gson.fromJson(new JsonReader(new StringReader(resp.decryptedPack)),\n+                    GreeStatusResponsePackDTO.class);\n+\n+            // save the results\n+            statusResponseGson = Optional.of(resp);\n+            updateTempFtoC();\n+        } catch (IOException e) {\n+            throw new GreeException(\"I/O exception while receiving data\", e);\n+        } catch (RuntimeException e) {\n+            String json = statusResponseGson.map(r -> r.packJson.toString()).orElse(\"n/a\");\n+            throw new GreeException(\"Exception while receiving data, JSON=\" + json, e);\n+        }\n+    }\n+\n+    public void bindWithDevice(DatagramSocket clientSocket) throws GreeException {\n+        try {\n+            // Prep the Binding Request pack\n+            GreeBindRequestPackDTO bindReqPackGson = new GreeBindRequestPackDTO();\n+            bindReqPackGson.mac = getId();\n+            bindReqPackGson.t = GREE_CMDT_BIND;\n+            bindReqPackGson.uid = 0;\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\n+\n+            // Encrypt and send the Binding Request pack\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\n+                    bindReqPackStr);\n+            DatagramPacket sendPacket = createPackRequest(1,\n+                    new String(encryptedBindReqPacket.getBytes(), StandardCharsets.UTF_8));\n+            clientSocket.send(sendPacket);\n+\n+            // Recieve a response, create the JSON to hold the response values\n+            GreeBindResponseDTO resp = gson.fromJson(receiveResponse(clientSocket), GreeBindResponseDTO.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ddbba49f802627554c380ef9a5b829ac7b1f8cb1"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkwMzIxMw==", "bodyText": "Use primitives if possible.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Double newVal = temp.doubleValue();\n          \n          \n            \n                    double newVal = temp.doubleValue();", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r441903213", "createdAt": "2020-06-18T00:26:49Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,530 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeRequestDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePackDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\n+ * device specific attributes as well a the functionality for the Air Conditioner\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeAirDevice {\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\n+    private final static Gson gson = new Gson();\n+    private boolean isBound = false;\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\n+    private int port = 0;\n+    private String encKey = \"\";\n+    private Optional<GreeScanResponseDTO> scanResponseGson = Optional.empty();\n+    private Optional<GreeStatusResponseDTO> statusResponseGson = Optional.empty();\n+    private Optional<GreeStatusResponsePackDTO> prevStatusResponsePackGson = Optional.empty();\n+\n+    public void getDeviceStatus(DatagramSocket clientSocket) throws GreeException {\n+        try {\n+            // Set the values in the HashMap\n+            ArrayList<String> columns = new ArrayList<>();\n+            columns.add(GREE_PROP_POWER);\n+            columns.add(GREE_PROP_MODE);\n+            columns.add(GREE_PROP_SETTEMP);\n+            columns.add(GREE_PROP_WINDSPEED);\n+            columns.add(GREE_PROP_AIR);\n+            columns.add(GREE_PROP_DRY);\n+            columns.add(GREE_PROP_HEALTH);\n+            columns.add(GREE_PROP_SLEEP);\n+            columns.add(GREE_PROP_LIGHT);\n+            columns.add(GREE_PROP_SWINGLEFTRIGHT);\n+            columns.add(GREE_PROP_SWINGUPDOWN);\n+            columns.add(GREE_PROP_QUIET);\n+            columns.add(GREE_PROP_TURBO);\n+            columns.add(GREE_PROP_TEMPUNIT);\n+            columns.add(GREE_PROP_HEAT);\n+            columns.add(GREE_PROP_HEATCOOL);\n+            columns.add(GREE_PROP_TEMPREC);\n+            columns.add(GREE_PROP_PWR_SAVING);\n+            columns.add(GREE_PROP_NOISESET);\n+\n+            // Convert the parameter map values to arrays\n+            String[] colArray = columns.toArray(new String[0]);\n+\n+            // Prep the Command Request pack\n+            GreeReqStatusPackDTO reqStatusPackGson = new GreeReqStatusPackDTO();\n+            reqStatusPackGson.t = GREE_CMDT_STATUS;\n+            reqStatusPackGson.cols = colArray;\n+            reqStatusPackGson.mac = getId();\n+            String reqStatusPackStr = gson.toJson(reqStatusPackGson);\n+\n+            // Encrypt and send the Status Request pack\n+            String encryptedStatusReqPacket = GreeCryptoUtil.encryptPack(getKey().getBytes(), reqStatusPackStr);\n+            DatagramPacket sendPacket = createPackRequest(0,\n+                    new String(encryptedStatusReqPacket.getBytes(), StandardCharsets.UTF_8));\n+            clientSocket.send(sendPacket);\n+\n+            // Recieve a response\n+            JsonReader receivedData = receiveResponse(clientSocket);\n+\n+            // Keep a copy of the old response to be used to check if values have changed\n+            // If first time running, there will not be a previous GreeStatusResponsePack4Gson\n+            if (statusResponseGson.isPresent() && statusResponseGson.get().packJson != null) {\n+                prevStatusResponsePackGson = Optional\n+                        .of(new GreeStatusResponsePackDTO(statusResponseGson.get().packJson));\n+            }\n+\n+            // Read the response, create the JSON to hold the response values\n+            GreeStatusResponseDTO resp = gson.fromJson(receivedData, GreeStatusResponseDTO.class);\n+            resp.decryptedPack = GreeCryptoUtil.decryptPack(this.getKey().getBytes(), resp.pack);\n+            logger.debug(\"Response from device: {}\", resp.decryptedPack);\n+            resp.packJson = gson.fromJson(new JsonReader(new StringReader(resp.decryptedPack)),\n+                    GreeStatusResponsePackDTO.class);\n+\n+            // save the results\n+            statusResponseGson = Optional.of(resp);\n+            updateTempFtoC();\n+        } catch (IOException e) {\n+            throw new GreeException(\"I/O exception while receiving data\", e);\n+        } catch (RuntimeException e) {\n+            String json = statusResponseGson.map(r -> r.packJson.toString()).orElse(\"n/a\");\n+            throw new GreeException(\"Exception while receiving data, JSON=\" + json, e);\n+        }\n+    }\n+\n+    public void bindWithDevice(DatagramSocket clientSocket) throws GreeException {\n+        try {\n+            // Prep the Binding Request pack\n+            GreeBindRequestPackDTO bindReqPackGson = new GreeBindRequestPackDTO();\n+            bindReqPackGson.mac = getId();\n+            bindReqPackGson.t = GREE_CMDT_BIND;\n+            bindReqPackGson.uid = 0;\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\n+\n+            // Encrypt and send the Binding Request pack\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\n+                    bindReqPackStr);\n+            DatagramPacket sendPacket = createPackRequest(1,\n+                    new String(encryptedBindReqPacket.getBytes(), StandardCharsets.UTF_8));\n+            clientSocket.send(sendPacket);\n+\n+            // Recieve a response, create the JSON to hold the response values\n+            GreeBindResponseDTO resp = gson.fromJson(receiveResponse(clientSocket), GreeBindResponseDTO.class);\n+            resp.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(), resp.pack);\n+            resp.packJson = gson.fromJson(new JsonReader(new StringReader(resp.decryptedPack)),\n+                    GreeBindResponsePackDTO.class);\n+\n+            // Now set the key and flag to indicate the bind was succesful\n+            encKey = resp.packJson.key;\n+\n+            // save the outcome\n+            setIsBound(true);\n+        } catch (IOException e) {\n+            throw new GreeException(\"Unable to bind to device\", e);\n+        }\n+    }\n+\n+    public void setDevicePower(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_POWER, value);\n+    }\n+\n+    public void SetDeviceMode(DatagramSocket clientSocket, int value) throws GreeException {\n+        if ((value < 0 || value > 4)) {\n+            throw new GreeException(\"Device mode out of range!\");\n+        }\n+        setCommandValue(clientSocket, GREE_PROP_MODE, value);\n+    }\n+\n+    public void setDeviceSwingUpDown(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\n+        if ((value < 0 || value > 11) || (value > 6 && value < 10)) {\n+            throw new GreeException(\"SwingUpDown value out of range!\");\n+        }\n+        setCommandValue(clientSocket, GREE_PROP_SWINGUPDOWN, value);\n+    }\n+\n+    public void setDeviceSwingLeftRight(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_SWINGLEFTRIGHT, value, 0, 6);\n+    }\n+\n+    /**\n+     * Only allow this to happen if this device has been bound and values are valid\n+     * Possible values are :\n+     * 0 : Auto\n+     * 1 : Low\n+     * 2 : Medium Low\n+     * 3 : Medium\n+     * 4 : Medium High\n+     * 5 : High\n+     */\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, int value) throws GreeException {\n+        if (value < 0 || value > 5) {\n+            throw new GreeException(\"Value out of range!\");\n+        }\n+\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(GREE_PROP_WINDSPEED, value);\n+        parameters.put(GREE_PROP_QUIET, 0);\n+        parameters.put(GREE_PROP_TURBO, 0);\n+        parameters.put(GREE_PROP_NOISE, 0);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceTurbo(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_TURBO, value, 0, 1);\n+    }\n+\n+    public void setQuietMode(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_QUIET, value, 0, 2);\n+    }\n+\n+    public int getDeviceTurbo() {\n+        return getIntStatusVal(GREE_PROP_TURBO);\n+    }\n+\n+    public void setDeviceLight(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_LIGHT, value);\n+    }\n+\n+    /**\n+     * @param value set temperature in degrees Celsius or Fahrenheit\n+     */\n+    public void setDeviceTempSet(DatagramSocket clientSocket, QuantityType<?> temp) throws GreeException {\n+        // If commanding Fahrenheit set halfStep to 1 or 0 to tell the A/C which F integer\n+        // temperature to use as celsius alone is ambigious\n+        Double newVal = temp.doubleValue();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ddbba49f802627554c380ef9a5b829ac7b1f8cb1"}, "originalPosition": 240}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkwNDQ0MA==", "bodyText": "if statusResponseGson isn't present then this will throw an exception.", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r441904440", "createdAt": "2020-06-18T00:31:51Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,530 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeRequestDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePackDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\n+ * device specific attributes as well a the functionality for the Air Conditioner\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeAirDevice {\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\n+    private final static Gson gson = new Gson();\n+    private boolean isBound = false;\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\n+    private int port = 0;\n+    private String encKey = \"\";\n+    private Optional<GreeScanResponseDTO> scanResponseGson = Optional.empty();\n+    private Optional<GreeStatusResponseDTO> statusResponseGson = Optional.empty();\n+    private Optional<GreeStatusResponsePackDTO> prevStatusResponsePackGson = Optional.empty();\n+\n+    public void getDeviceStatus(DatagramSocket clientSocket) throws GreeException {\n+        try {\n+            // Set the values in the HashMap\n+            ArrayList<String> columns = new ArrayList<>();\n+            columns.add(GREE_PROP_POWER);\n+            columns.add(GREE_PROP_MODE);\n+            columns.add(GREE_PROP_SETTEMP);\n+            columns.add(GREE_PROP_WINDSPEED);\n+            columns.add(GREE_PROP_AIR);\n+            columns.add(GREE_PROP_DRY);\n+            columns.add(GREE_PROP_HEALTH);\n+            columns.add(GREE_PROP_SLEEP);\n+            columns.add(GREE_PROP_LIGHT);\n+            columns.add(GREE_PROP_SWINGLEFTRIGHT);\n+            columns.add(GREE_PROP_SWINGUPDOWN);\n+            columns.add(GREE_PROP_QUIET);\n+            columns.add(GREE_PROP_TURBO);\n+            columns.add(GREE_PROP_TEMPUNIT);\n+            columns.add(GREE_PROP_HEAT);\n+            columns.add(GREE_PROP_HEATCOOL);\n+            columns.add(GREE_PROP_TEMPREC);\n+            columns.add(GREE_PROP_PWR_SAVING);\n+            columns.add(GREE_PROP_NOISESET);\n+\n+            // Convert the parameter map values to arrays\n+            String[] colArray = columns.toArray(new String[0]);\n+\n+            // Prep the Command Request pack\n+            GreeReqStatusPackDTO reqStatusPackGson = new GreeReqStatusPackDTO();\n+            reqStatusPackGson.t = GREE_CMDT_STATUS;\n+            reqStatusPackGson.cols = colArray;\n+            reqStatusPackGson.mac = getId();\n+            String reqStatusPackStr = gson.toJson(reqStatusPackGson);\n+\n+            // Encrypt and send the Status Request pack\n+            String encryptedStatusReqPacket = GreeCryptoUtil.encryptPack(getKey().getBytes(), reqStatusPackStr);\n+            DatagramPacket sendPacket = createPackRequest(0,\n+                    new String(encryptedStatusReqPacket.getBytes(), StandardCharsets.UTF_8));\n+            clientSocket.send(sendPacket);\n+\n+            // Recieve a response\n+            JsonReader receivedData = receiveResponse(clientSocket);\n+\n+            // Keep a copy of the old response to be used to check if values have changed\n+            // If first time running, there will not be a previous GreeStatusResponsePack4Gson\n+            if (statusResponseGson.isPresent() && statusResponseGson.get().packJson != null) {\n+                prevStatusResponsePackGson = Optional\n+                        .of(new GreeStatusResponsePackDTO(statusResponseGson.get().packJson));\n+            }\n+\n+            // Read the response, create the JSON to hold the response values\n+            GreeStatusResponseDTO resp = gson.fromJson(receivedData, GreeStatusResponseDTO.class);\n+            resp.decryptedPack = GreeCryptoUtil.decryptPack(this.getKey().getBytes(), resp.pack);\n+            logger.debug(\"Response from device: {}\", resp.decryptedPack);\n+            resp.packJson = gson.fromJson(new JsonReader(new StringReader(resp.decryptedPack)),\n+                    GreeStatusResponsePackDTO.class);\n+\n+            // save the results\n+            statusResponseGson = Optional.of(resp);\n+            updateTempFtoC();\n+        } catch (IOException e) {\n+            throw new GreeException(\"I/O exception while receiving data\", e);\n+        } catch (RuntimeException e) {\n+            String json = statusResponseGson.map(r -> r.packJson.toString()).orElse(\"n/a\");\n+            throw new GreeException(\"Exception while receiving data, JSON=\" + json, e);\n+        }\n+    }\n+\n+    public void bindWithDevice(DatagramSocket clientSocket) throws GreeException {\n+        try {\n+            // Prep the Binding Request pack\n+            GreeBindRequestPackDTO bindReqPackGson = new GreeBindRequestPackDTO();\n+            bindReqPackGson.mac = getId();\n+            bindReqPackGson.t = GREE_CMDT_BIND;\n+            bindReqPackGson.uid = 0;\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\n+\n+            // Encrypt and send the Binding Request pack\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\n+                    bindReqPackStr);\n+            DatagramPacket sendPacket = createPackRequest(1,\n+                    new String(encryptedBindReqPacket.getBytes(), StandardCharsets.UTF_8));\n+            clientSocket.send(sendPacket);\n+\n+            // Recieve a response, create the JSON to hold the response values\n+            GreeBindResponseDTO resp = gson.fromJson(receiveResponse(clientSocket), GreeBindResponseDTO.class);\n+            resp.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(), resp.pack);\n+            resp.packJson = gson.fromJson(new JsonReader(new StringReader(resp.decryptedPack)),\n+                    GreeBindResponsePackDTO.class);\n+\n+            // Now set the key and flag to indicate the bind was succesful\n+            encKey = resp.packJson.key;\n+\n+            // save the outcome\n+            setIsBound(true);\n+        } catch (IOException e) {\n+            throw new GreeException(\"Unable to bind to device\", e);\n+        }\n+    }\n+\n+    public void setDevicePower(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_POWER, value);\n+    }\n+\n+    public void SetDeviceMode(DatagramSocket clientSocket, int value) throws GreeException {\n+        if ((value < 0 || value > 4)) {\n+            throw new GreeException(\"Device mode out of range!\");\n+        }\n+        setCommandValue(clientSocket, GREE_PROP_MODE, value);\n+    }\n+\n+    public void setDeviceSwingUpDown(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\n+        if ((value < 0 || value > 11) || (value > 6 && value < 10)) {\n+            throw new GreeException(\"SwingUpDown value out of range!\");\n+        }\n+        setCommandValue(clientSocket, GREE_PROP_SWINGUPDOWN, value);\n+    }\n+\n+    public void setDeviceSwingLeftRight(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_SWINGLEFTRIGHT, value, 0, 6);\n+    }\n+\n+    /**\n+     * Only allow this to happen if this device has been bound and values are valid\n+     * Possible values are :\n+     * 0 : Auto\n+     * 1 : Low\n+     * 2 : Medium Low\n+     * 3 : Medium\n+     * 4 : Medium High\n+     * 5 : High\n+     */\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, int value) throws GreeException {\n+        if (value < 0 || value > 5) {\n+            throw new GreeException(\"Value out of range!\");\n+        }\n+\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(GREE_PROP_WINDSPEED, value);\n+        parameters.put(GREE_PROP_QUIET, 0);\n+        parameters.put(GREE_PROP_TURBO, 0);\n+        parameters.put(GREE_PROP_NOISE, 0);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceTurbo(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_TURBO, value, 0, 1);\n+    }\n+\n+    public void setQuietMode(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_QUIET, value, 0, 2);\n+    }\n+\n+    public int getDeviceTurbo() {\n+        return getIntStatusVal(GREE_PROP_TURBO);\n+    }\n+\n+    public void setDeviceLight(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_LIGHT, value);\n+    }\n+\n+    /**\n+     * @param value set temperature in degrees Celsius or Fahrenheit\n+     */\n+    public void setDeviceTempSet(DatagramSocket clientSocket, QuantityType<?> temp) throws GreeException {\n+        // If commanding Fahrenheit set halfStep to 1 or 0 to tell the A/C which F integer\n+        // temperature to use as celsius alone is ambigious\n+        Double newVal = temp.doubleValue();\n+        int CorF = temp.getUnit() == SIUnits.CELSIUS ? TEMP_UNIT_CELSIUS : TEMP_UNIT_FAHRENHEIT; // 0=Celsius,\n+                                                                                                 // 1=Fahrenheit\n+        if (((CorF == TEMP_UNIT_CELSIUS) && (newVal < TEMP_MIN_C || newVal > TEMP_MAX_C))\n+                || ((CorF == TEMP_UNIT_FAHRENHEIT) && (newVal < TEMP_MIN_F || newVal > TEMP_MAX_F))) {\n+            throw new IllegalArgumentException(\"Temp Value out of Range\");\n+        }\n+\n+        // Default for Celsius\n+        int outVal = newVal.intValue();\n+        int halfStep = TEMP_HALFSTEP_NO; // for whatever reason halfStep is not supported for Celsius\n+\n+        // If value argument is degrees F, convert Fahrenheit to Celsius,\n+        // SetTem input to A/C always in Celsius despite passing in 1 to TemUn\n+        // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\n+        // F = [68...86]\n+        // C = [20.0, 20.5, 21.1, 21.6, 22.2, 22.7, 23.3, 23.8, 24.4, 25.0, 25.5, 26.1, 26.6, 27.2, 27.7, 28.3,\n+        // 28.8, 29.4, 30.0]\n+        //\n+        // TemSet = [20..30] or [68..86]\n+        // TemRec = value - (value) > 0 ? 1 : 1 -> when xx.5 is request xx will become TemSet and halfStep the indicator\n+        // for \"half on top of TemSet\"\n+        // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\n+        // subtract the float version - the int version to get the fractional difference\n+        // if the difference is positive set halfStep to 1, negative to 0\n+        if (CorF == TEMP_UNIT_FAHRENHEIT) { // If Fahrenheit,\n+            /*\n+             * outVal = (int) (Math.round((newVal - 32.) * 5.0 / 9.0)); // Integer Truncated\n+             * halfStep = ((((newVal - 32.) * 5.0 / 9.0) - outVal) > 0) ? 1 : 0;\n+             */\n+            halfStep = newVal - outVal > 0 ? TEMP_HALFSTEP_YES : TEMP_HALFSTEP_NO;\n+        }\n+        logger.debug(\"Converted temp from {}{} to temp={}, halfStep={}, unit={})\", newVal, temp.getUnit(), outVal,\n+                halfStep, CorF == TEMP_UNIT_CELSIUS ? \"C\" : \"F\");\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(GREE_PROP_TEMPUNIT, CorF);\n+        parameters.put(GREE_PROP_SETTEMP, outVal);\n+        parameters.put(GREE_PROP_TEMPREC, halfStep);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceAir(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_AIR, value);\n+    }\n+\n+    public void setDeviceDry(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_DRY, value);\n+    }\n+\n+    public void setDeviceHealth(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_HEALTH, value);\n+    }\n+\n+    public void setDevicePwrSaving(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(GREE_PROP_PWR_SAVING, value);\n+        parameters.put(GREE_PROP_WINDSPEED, 0);\n+        parameters.put(GREE_PROP_QUIET, 0);\n+        parameters.put(GREE_PROP_TURBO, 0);\n+        parameters.put(GREE_PROP_SLEEP, 0);\n+        parameters.put(GREE_PROP_SLEEPMODE, 0);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public int getIntStatusVal(String valueName) {\n+        /*\n+         * Note : Values can be:\n+         * \"Pow\": Power (0 or 1)\n+         * \"Mod\": Mode: Auto: 0, Cool: 1, Dry: 2, Fan: 3, Heat: 4\n+         * \"SetTem\": Requested Temperature\n+         * \"WdSpd\": Fan Speed : Low:1, Medium Low:2, Medium :3, Medium High :4, High :5\n+         * \"Air\": Air Mode Enabled\n+         * \"Blo\": Dry\n+         * \"Health\": Health\n+         * \"SwhSlp\": Sleep\n+         * \"SlpMod\": ???\n+         * \"Lig\": Light On\n+         * \"SwingLfRig\": Swing Left Right\n+         * \"SwUpDn\": Swing Up Down: // Ceiling:0, Upwards : 10, Downwards : 11, Full range : 1\n+         * \"Quiet\": Quiet mode\n+         * \"Tur\": Turbo\n+         * \"StHt\": 0,\n+         * \"TemUn\": Temperature unit, 0 for Celsius, 1 for Fahrenheit\n+         * \"HeatCoolType\"\n+         * \"TemRec\": (0 or 1), Send with SetTem, when TemUn==1, distinguishes between upper and lower integer Fahrenheit\n+         * temp\n+         * \"SvSt\": Power Saving\n+         */\n+        // Find the valueName in the Returned Status object\n+        if (isStatusAvailable()) {\n+            List<String> colList = Arrays.asList(statusResponseGson.get().packJson.cols);\n+            List<Integer> valList = Arrays.asList(statusResponseGson.get().packJson.dat);\n+            int valueArrayposition = colList.indexOf(valueName);\n+            if (valueArrayposition != -1) {\n+                // get the Corresponding value\n+                Integer value = valList.get(valueArrayposition);\n+                return value;\n+            }\n+        }\n+\n+        return -1;\n+    }\n+\n+    public boolean isStatusAvailable() {\n+        return statusResponseGson.isPresent();\n+    }\n+\n+    public boolean hasStatusValChanged(String valueName) throws GreeException {\n+        if (!prevStatusResponsePackGson.isPresent()) {\n+            return true; // update value if there is no previous one\n+        }\n+        // Find the valueName in the Current Status object\n+        List<String> currcolList = Arrays.asList(statusResponseGson.get().packJson.cols);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ddbba49f802627554c380ef9a5b829ac7b1f8cb1"}, "originalPosition": 355}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkwNDgyMg==", "bodyText": "There are a lot more places that you are using the JsonReader instead of the string directly, so I suspect you are doing it intentionally. If you aren't then change them all to use the string directly as per my earlier comment.", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r441904822", "createdAt": "2020-06-18T00:33:18Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,530 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeRequestDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePackDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\n+ * device specific attributes as well a the functionality for the Air Conditioner\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeAirDevice {\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\n+    private final static Gson gson = new Gson();\n+    private boolean isBound = false;\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\n+    private int port = 0;\n+    private String encKey = \"\";\n+    private Optional<GreeScanResponseDTO> scanResponseGson = Optional.empty();\n+    private Optional<GreeStatusResponseDTO> statusResponseGson = Optional.empty();\n+    private Optional<GreeStatusResponsePackDTO> prevStatusResponsePackGson = Optional.empty();\n+\n+    public void getDeviceStatus(DatagramSocket clientSocket) throws GreeException {\n+        try {\n+            // Set the values in the HashMap\n+            ArrayList<String> columns = new ArrayList<>();\n+            columns.add(GREE_PROP_POWER);\n+            columns.add(GREE_PROP_MODE);\n+            columns.add(GREE_PROP_SETTEMP);\n+            columns.add(GREE_PROP_WINDSPEED);\n+            columns.add(GREE_PROP_AIR);\n+            columns.add(GREE_PROP_DRY);\n+            columns.add(GREE_PROP_HEALTH);\n+            columns.add(GREE_PROP_SLEEP);\n+            columns.add(GREE_PROP_LIGHT);\n+            columns.add(GREE_PROP_SWINGLEFTRIGHT);\n+            columns.add(GREE_PROP_SWINGUPDOWN);\n+            columns.add(GREE_PROP_QUIET);\n+            columns.add(GREE_PROP_TURBO);\n+            columns.add(GREE_PROP_TEMPUNIT);\n+            columns.add(GREE_PROP_HEAT);\n+            columns.add(GREE_PROP_HEATCOOL);\n+            columns.add(GREE_PROP_TEMPREC);\n+            columns.add(GREE_PROP_PWR_SAVING);\n+            columns.add(GREE_PROP_NOISESET);\n+\n+            // Convert the parameter map values to arrays\n+            String[] colArray = columns.toArray(new String[0]);\n+\n+            // Prep the Command Request pack\n+            GreeReqStatusPackDTO reqStatusPackGson = new GreeReqStatusPackDTO();\n+            reqStatusPackGson.t = GREE_CMDT_STATUS;\n+            reqStatusPackGson.cols = colArray;\n+            reqStatusPackGson.mac = getId();\n+            String reqStatusPackStr = gson.toJson(reqStatusPackGson);\n+\n+            // Encrypt and send the Status Request pack\n+            String encryptedStatusReqPacket = GreeCryptoUtil.encryptPack(getKey().getBytes(), reqStatusPackStr);\n+            DatagramPacket sendPacket = createPackRequest(0,\n+                    new String(encryptedStatusReqPacket.getBytes(), StandardCharsets.UTF_8));\n+            clientSocket.send(sendPacket);\n+\n+            // Recieve a response\n+            JsonReader receivedData = receiveResponse(clientSocket);\n+\n+            // Keep a copy of the old response to be used to check if values have changed\n+            // If first time running, there will not be a previous GreeStatusResponsePack4Gson\n+            if (statusResponseGson.isPresent() && statusResponseGson.get().packJson != null) {\n+                prevStatusResponsePackGson = Optional\n+                        .of(new GreeStatusResponsePackDTO(statusResponseGson.get().packJson));\n+            }\n+\n+            // Read the response, create the JSON to hold the response values\n+            GreeStatusResponseDTO resp = gson.fromJson(receivedData, GreeStatusResponseDTO.class);\n+            resp.decryptedPack = GreeCryptoUtil.decryptPack(this.getKey().getBytes(), resp.pack);\n+            logger.debug(\"Response from device: {}\", resp.decryptedPack);\n+            resp.packJson = gson.fromJson(new JsonReader(new StringReader(resp.decryptedPack)),\n+                    GreeStatusResponsePackDTO.class);\n+\n+            // save the results\n+            statusResponseGson = Optional.of(resp);\n+            updateTempFtoC();\n+        } catch (IOException e) {\n+            throw new GreeException(\"I/O exception while receiving data\", e);\n+        } catch (RuntimeException e) {\n+            String json = statusResponseGson.map(r -> r.packJson.toString()).orElse(\"n/a\");\n+            throw new GreeException(\"Exception while receiving data, JSON=\" + json, e);\n+        }\n+    }\n+\n+    public void bindWithDevice(DatagramSocket clientSocket) throws GreeException {\n+        try {\n+            // Prep the Binding Request pack\n+            GreeBindRequestPackDTO bindReqPackGson = new GreeBindRequestPackDTO();\n+            bindReqPackGson.mac = getId();\n+            bindReqPackGson.t = GREE_CMDT_BIND;\n+            bindReqPackGson.uid = 0;\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\n+\n+            // Encrypt and send the Binding Request pack\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\n+                    bindReqPackStr);\n+            DatagramPacket sendPacket = createPackRequest(1,\n+                    new String(encryptedBindReqPacket.getBytes(), StandardCharsets.UTF_8));\n+            clientSocket.send(sendPacket);\n+\n+            // Recieve a response, create the JSON to hold the response values\n+            GreeBindResponseDTO resp = gson.fromJson(receiveResponse(clientSocket), GreeBindResponseDTO.class);\n+            resp.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(), resp.pack);\n+            resp.packJson = gson.fromJson(new JsonReader(new StringReader(resp.decryptedPack)),\n+                    GreeBindResponsePackDTO.class);\n+\n+            // Now set the key and flag to indicate the bind was succesful\n+            encKey = resp.packJson.key;\n+\n+            // save the outcome\n+            setIsBound(true);\n+        } catch (IOException e) {\n+            throw new GreeException(\"Unable to bind to device\", e);\n+        }\n+    }\n+\n+    public void setDevicePower(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_POWER, value);\n+    }\n+\n+    public void SetDeviceMode(DatagramSocket clientSocket, int value) throws GreeException {\n+        if ((value < 0 || value > 4)) {\n+            throw new GreeException(\"Device mode out of range!\");\n+        }\n+        setCommandValue(clientSocket, GREE_PROP_MODE, value);\n+    }\n+\n+    public void setDeviceSwingUpDown(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\n+        if ((value < 0 || value > 11) || (value > 6 && value < 10)) {\n+            throw new GreeException(\"SwingUpDown value out of range!\");\n+        }\n+        setCommandValue(clientSocket, GREE_PROP_SWINGUPDOWN, value);\n+    }\n+\n+    public void setDeviceSwingLeftRight(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_SWINGLEFTRIGHT, value, 0, 6);\n+    }\n+\n+    /**\n+     * Only allow this to happen if this device has been bound and values are valid\n+     * Possible values are :\n+     * 0 : Auto\n+     * 1 : Low\n+     * 2 : Medium Low\n+     * 3 : Medium\n+     * 4 : Medium High\n+     * 5 : High\n+     */\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, int value) throws GreeException {\n+        if (value < 0 || value > 5) {\n+            throw new GreeException(\"Value out of range!\");\n+        }\n+\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(GREE_PROP_WINDSPEED, value);\n+        parameters.put(GREE_PROP_QUIET, 0);\n+        parameters.put(GREE_PROP_TURBO, 0);\n+        parameters.put(GREE_PROP_NOISE, 0);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceTurbo(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_TURBO, value, 0, 1);\n+    }\n+\n+    public void setQuietMode(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_QUIET, value, 0, 2);\n+    }\n+\n+    public int getDeviceTurbo() {\n+        return getIntStatusVal(GREE_PROP_TURBO);\n+    }\n+\n+    public void setDeviceLight(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_LIGHT, value);\n+    }\n+\n+    /**\n+     * @param value set temperature in degrees Celsius or Fahrenheit\n+     */\n+    public void setDeviceTempSet(DatagramSocket clientSocket, QuantityType<?> temp) throws GreeException {\n+        // If commanding Fahrenheit set halfStep to 1 or 0 to tell the A/C which F integer\n+        // temperature to use as celsius alone is ambigious\n+        Double newVal = temp.doubleValue();\n+        int CorF = temp.getUnit() == SIUnits.CELSIUS ? TEMP_UNIT_CELSIUS : TEMP_UNIT_FAHRENHEIT; // 0=Celsius,\n+                                                                                                 // 1=Fahrenheit\n+        if (((CorF == TEMP_UNIT_CELSIUS) && (newVal < TEMP_MIN_C || newVal > TEMP_MAX_C))\n+                || ((CorF == TEMP_UNIT_FAHRENHEIT) && (newVal < TEMP_MIN_F || newVal > TEMP_MAX_F))) {\n+            throw new IllegalArgumentException(\"Temp Value out of Range\");\n+        }\n+\n+        // Default for Celsius\n+        int outVal = newVal.intValue();\n+        int halfStep = TEMP_HALFSTEP_NO; // for whatever reason halfStep is not supported for Celsius\n+\n+        // If value argument is degrees F, convert Fahrenheit to Celsius,\n+        // SetTem input to A/C always in Celsius despite passing in 1 to TemUn\n+        // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\n+        // F = [68...86]\n+        // C = [20.0, 20.5, 21.1, 21.6, 22.2, 22.7, 23.3, 23.8, 24.4, 25.0, 25.5, 26.1, 26.6, 27.2, 27.7, 28.3,\n+        // 28.8, 29.4, 30.0]\n+        //\n+        // TemSet = [20..30] or [68..86]\n+        // TemRec = value - (value) > 0 ? 1 : 1 -> when xx.5 is request xx will become TemSet and halfStep the indicator\n+        // for \"half on top of TemSet\"\n+        // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\n+        // subtract the float version - the int version to get the fractional difference\n+        // if the difference is positive set halfStep to 1, negative to 0\n+        if (CorF == TEMP_UNIT_FAHRENHEIT) { // If Fahrenheit,\n+            /*\n+             * outVal = (int) (Math.round((newVal - 32.) * 5.0 / 9.0)); // Integer Truncated\n+             * halfStep = ((((newVal - 32.) * 5.0 / 9.0) - outVal) > 0) ? 1 : 0;\n+             */\n+            halfStep = newVal - outVal > 0 ? TEMP_HALFSTEP_YES : TEMP_HALFSTEP_NO;\n+        }\n+        logger.debug(\"Converted temp from {}{} to temp={}, halfStep={}, unit={})\", newVal, temp.getUnit(), outVal,\n+                halfStep, CorF == TEMP_UNIT_CELSIUS ? \"C\" : \"F\");\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(GREE_PROP_TEMPUNIT, CorF);\n+        parameters.put(GREE_PROP_SETTEMP, outVal);\n+        parameters.put(GREE_PROP_TEMPREC, halfStep);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceAir(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_AIR, value);\n+    }\n+\n+    public void setDeviceDry(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_DRY, value);\n+    }\n+\n+    public void setDeviceHealth(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_HEALTH, value);\n+    }\n+\n+    public void setDevicePwrSaving(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(GREE_PROP_PWR_SAVING, value);\n+        parameters.put(GREE_PROP_WINDSPEED, 0);\n+        parameters.put(GREE_PROP_QUIET, 0);\n+        parameters.put(GREE_PROP_TURBO, 0);\n+        parameters.put(GREE_PROP_SLEEP, 0);\n+        parameters.put(GREE_PROP_SLEEPMODE, 0);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public int getIntStatusVal(String valueName) {\n+        /*\n+         * Note : Values can be:\n+         * \"Pow\": Power (0 or 1)\n+         * \"Mod\": Mode: Auto: 0, Cool: 1, Dry: 2, Fan: 3, Heat: 4\n+         * \"SetTem\": Requested Temperature\n+         * \"WdSpd\": Fan Speed : Low:1, Medium Low:2, Medium :3, Medium High :4, High :5\n+         * \"Air\": Air Mode Enabled\n+         * \"Blo\": Dry\n+         * \"Health\": Health\n+         * \"SwhSlp\": Sleep\n+         * \"SlpMod\": ???\n+         * \"Lig\": Light On\n+         * \"SwingLfRig\": Swing Left Right\n+         * \"SwUpDn\": Swing Up Down: // Ceiling:0, Upwards : 10, Downwards : 11, Full range : 1\n+         * \"Quiet\": Quiet mode\n+         * \"Tur\": Turbo\n+         * \"StHt\": 0,\n+         * \"TemUn\": Temperature unit, 0 for Celsius, 1 for Fahrenheit\n+         * \"HeatCoolType\"\n+         * \"TemRec\": (0 or 1), Send with SetTem, when TemUn==1, distinguishes between upper and lower integer Fahrenheit\n+         * temp\n+         * \"SvSt\": Power Saving\n+         */\n+        // Find the valueName in the Returned Status object\n+        if (isStatusAvailable()) {\n+            List<String> colList = Arrays.asList(statusResponseGson.get().packJson.cols);\n+            List<Integer> valList = Arrays.asList(statusResponseGson.get().packJson.dat);\n+            int valueArrayposition = colList.indexOf(valueName);\n+            if (valueArrayposition != -1) {\n+                // get the Corresponding value\n+                Integer value = valList.get(valueArrayposition);\n+                return value;\n+            }\n+        }\n+\n+        return -1;\n+    }\n+\n+    public boolean isStatusAvailable() {\n+        return statusResponseGson.isPresent();\n+    }\n+\n+    public boolean hasStatusValChanged(String valueName) throws GreeException {\n+        if (!prevStatusResponsePackGson.isPresent()) {\n+            return true; // update value if there is no previous one\n+        }\n+        // Find the valueName in the Current Status object\n+        List<String> currcolList = Arrays.asList(statusResponseGson.get().packJson.cols);\n+        List<Integer> currvalList = Arrays.asList(statusResponseGson.get().packJson.dat);\n+        int currvalueArrayposition = currcolList.indexOf(valueName);\n+        if (currvalueArrayposition == -1) {\n+            throw new GreeException(\"Unable to decode device status\");\n+        }\n+\n+        // Find the valueName in the Previous Status object\n+        List<String> prevcolList = Arrays.asList(prevStatusResponsePackGson.get().cols);\n+        List<Integer> prevvalList = Arrays.asList(prevStatusResponsePackGson.get().dat);\n+        int prevvalueArrayposition = prevcolList.indexOf(valueName);\n+        if (prevvalueArrayposition == -1) {\n+            throw new GreeException(\"Unable to get status value\");\n+        }\n+\n+        // Finally Compare the values\n+        return currvalList.get(currvalueArrayposition) != prevvalList.get(prevvalueArrayposition);\n+    }\n+\n+    protected void executeCommand(DatagramSocket clientSocket, Map<String, Integer> parameters) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        try {\n+            // Convert the parameter map values to arrays\n+            String[] keyArray = parameters.keySet().toArray(new String[0]);\n+            Integer[] valueArray = parameters.values().toArray(new Integer[0]);\n+\n+            // Prep the Command Request pack\n+            GreeExecuteCommandPackDTO execCmdPackGson = new GreeExecuteCommandPackDTO();\n+            execCmdPackGson.opt = keyArray;\n+            execCmdPackGson.p = valueArray;\n+            execCmdPackGson.t = GREE_CMDT_CMD;\n+            String execCmdPackStr = gson.toJson(execCmdPackGson);\n+\n+            // Now encrypt and send the Command Request pack\n+            String encryptedCommandReqPacket = GreeCryptoUtil.encryptPack(getKey().getBytes(), execCmdPackStr);\n+            DatagramPacket sendPacket = createPackRequest(0,\n+                    new String(encryptedCommandReqPacket.getBytes(), StandardCharsets.UTF_8));\n+            clientSocket.send(sendPacket);\n+\n+            GreeExecResponseDTO execResponseGson = gson.fromJson(receiveResponse(clientSocket),\n+                    GreeExecResponseDTO.class);\n+            execResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(this.getKey().getBytes(),\n+                    execResponseGson.pack);\n+\n+            // Create the JSON to hold the response values\n+            execResponseGson.packJson = gson.fromJson(new JsonReader(new StringReader(execResponseGson.decryptedPack)),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ddbba49f802627554c380ef9a5b829ac7b1f8cb1"}, "originalPosition": 404}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkwNTYxMA==", "bodyText": "Why are you converting a string -> byte[] -> string?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        DatagramPacket sendPacket = createPackRequest(0,\n          \n          \n            \n                                new String(encryptedCommandReqPacket.getBytes(), StandardCharsets.UTF_8));\n          \n          \n            \n                        DatagramPacket sendPacket = createPackRequest(0, encryptedCommandReqPacket);", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r441905610", "createdAt": "2020-06-18T00:36:12Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,530 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeRequestDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePackDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\n+ * device specific attributes as well a the functionality for the Air Conditioner\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeAirDevice {\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\n+    private final static Gson gson = new Gson();\n+    private boolean isBound = false;\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\n+    private int port = 0;\n+    private String encKey = \"\";\n+    private Optional<GreeScanResponseDTO> scanResponseGson = Optional.empty();\n+    private Optional<GreeStatusResponseDTO> statusResponseGson = Optional.empty();\n+    private Optional<GreeStatusResponsePackDTO> prevStatusResponsePackGson = Optional.empty();\n+\n+    public void getDeviceStatus(DatagramSocket clientSocket) throws GreeException {\n+        try {\n+            // Set the values in the HashMap\n+            ArrayList<String> columns = new ArrayList<>();\n+            columns.add(GREE_PROP_POWER);\n+            columns.add(GREE_PROP_MODE);\n+            columns.add(GREE_PROP_SETTEMP);\n+            columns.add(GREE_PROP_WINDSPEED);\n+            columns.add(GREE_PROP_AIR);\n+            columns.add(GREE_PROP_DRY);\n+            columns.add(GREE_PROP_HEALTH);\n+            columns.add(GREE_PROP_SLEEP);\n+            columns.add(GREE_PROP_LIGHT);\n+            columns.add(GREE_PROP_SWINGLEFTRIGHT);\n+            columns.add(GREE_PROP_SWINGUPDOWN);\n+            columns.add(GREE_PROP_QUIET);\n+            columns.add(GREE_PROP_TURBO);\n+            columns.add(GREE_PROP_TEMPUNIT);\n+            columns.add(GREE_PROP_HEAT);\n+            columns.add(GREE_PROP_HEATCOOL);\n+            columns.add(GREE_PROP_TEMPREC);\n+            columns.add(GREE_PROP_PWR_SAVING);\n+            columns.add(GREE_PROP_NOISESET);\n+\n+            // Convert the parameter map values to arrays\n+            String[] colArray = columns.toArray(new String[0]);\n+\n+            // Prep the Command Request pack\n+            GreeReqStatusPackDTO reqStatusPackGson = new GreeReqStatusPackDTO();\n+            reqStatusPackGson.t = GREE_CMDT_STATUS;\n+            reqStatusPackGson.cols = colArray;\n+            reqStatusPackGson.mac = getId();\n+            String reqStatusPackStr = gson.toJson(reqStatusPackGson);\n+\n+            // Encrypt and send the Status Request pack\n+            String encryptedStatusReqPacket = GreeCryptoUtil.encryptPack(getKey().getBytes(), reqStatusPackStr);\n+            DatagramPacket sendPacket = createPackRequest(0,\n+                    new String(encryptedStatusReqPacket.getBytes(), StandardCharsets.UTF_8));\n+            clientSocket.send(sendPacket);\n+\n+            // Recieve a response\n+            JsonReader receivedData = receiveResponse(clientSocket);\n+\n+            // Keep a copy of the old response to be used to check if values have changed\n+            // If first time running, there will not be a previous GreeStatusResponsePack4Gson\n+            if (statusResponseGson.isPresent() && statusResponseGson.get().packJson != null) {\n+                prevStatusResponsePackGson = Optional\n+                        .of(new GreeStatusResponsePackDTO(statusResponseGson.get().packJson));\n+            }\n+\n+            // Read the response, create the JSON to hold the response values\n+            GreeStatusResponseDTO resp = gson.fromJson(receivedData, GreeStatusResponseDTO.class);\n+            resp.decryptedPack = GreeCryptoUtil.decryptPack(this.getKey().getBytes(), resp.pack);\n+            logger.debug(\"Response from device: {}\", resp.decryptedPack);\n+            resp.packJson = gson.fromJson(new JsonReader(new StringReader(resp.decryptedPack)),\n+                    GreeStatusResponsePackDTO.class);\n+\n+            // save the results\n+            statusResponseGson = Optional.of(resp);\n+            updateTempFtoC();\n+        } catch (IOException e) {\n+            throw new GreeException(\"I/O exception while receiving data\", e);\n+        } catch (RuntimeException e) {\n+            String json = statusResponseGson.map(r -> r.packJson.toString()).orElse(\"n/a\");\n+            throw new GreeException(\"Exception while receiving data, JSON=\" + json, e);\n+        }\n+    }\n+\n+    public void bindWithDevice(DatagramSocket clientSocket) throws GreeException {\n+        try {\n+            // Prep the Binding Request pack\n+            GreeBindRequestPackDTO bindReqPackGson = new GreeBindRequestPackDTO();\n+            bindReqPackGson.mac = getId();\n+            bindReqPackGson.t = GREE_CMDT_BIND;\n+            bindReqPackGson.uid = 0;\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\n+\n+            // Encrypt and send the Binding Request pack\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\n+                    bindReqPackStr);\n+            DatagramPacket sendPacket = createPackRequest(1,\n+                    new String(encryptedBindReqPacket.getBytes(), StandardCharsets.UTF_8));\n+            clientSocket.send(sendPacket);\n+\n+            // Recieve a response, create the JSON to hold the response values\n+            GreeBindResponseDTO resp = gson.fromJson(receiveResponse(clientSocket), GreeBindResponseDTO.class);\n+            resp.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(), resp.pack);\n+            resp.packJson = gson.fromJson(new JsonReader(new StringReader(resp.decryptedPack)),\n+                    GreeBindResponsePackDTO.class);\n+\n+            // Now set the key and flag to indicate the bind was succesful\n+            encKey = resp.packJson.key;\n+\n+            // save the outcome\n+            setIsBound(true);\n+        } catch (IOException e) {\n+            throw new GreeException(\"Unable to bind to device\", e);\n+        }\n+    }\n+\n+    public void setDevicePower(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_POWER, value);\n+    }\n+\n+    public void SetDeviceMode(DatagramSocket clientSocket, int value) throws GreeException {\n+        if ((value < 0 || value > 4)) {\n+            throw new GreeException(\"Device mode out of range!\");\n+        }\n+        setCommandValue(clientSocket, GREE_PROP_MODE, value);\n+    }\n+\n+    public void setDeviceSwingUpDown(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\n+        if ((value < 0 || value > 11) || (value > 6 && value < 10)) {\n+            throw new GreeException(\"SwingUpDown value out of range!\");\n+        }\n+        setCommandValue(clientSocket, GREE_PROP_SWINGUPDOWN, value);\n+    }\n+\n+    public void setDeviceSwingLeftRight(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_SWINGLEFTRIGHT, value, 0, 6);\n+    }\n+\n+    /**\n+     * Only allow this to happen if this device has been bound and values are valid\n+     * Possible values are :\n+     * 0 : Auto\n+     * 1 : Low\n+     * 2 : Medium Low\n+     * 3 : Medium\n+     * 4 : Medium High\n+     * 5 : High\n+     */\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, int value) throws GreeException {\n+        if (value < 0 || value > 5) {\n+            throw new GreeException(\"Value out of range!\");\n+        }\n+\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(GREE_PROP_WINDSPEED, value);\n+        parameters.put(GREE_PROP_QUIET, 0);\n+        parameters.put(GREE_PROP_TURBO, 0);\n+        parameters.put(GREE_PROP_NOISE, 0);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceTurbo(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_TURBO, value, 0, 1);\n+    }\n+\n+    public void setQuietMode(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_QUIET, value, 0, 2);\n+    }\n+\n+    public int getDeviceTurbo() {\n+        return getIntStatusVal(GREE_PROP_TURBO);\n+    }\n+\n+    public void setDeviceLight(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_LIGHT, value);\n+    }\n+\n+    /**\n+     * @param value set temperature in degrees Celsius or Fahrenheit\n+     */\n+    public void setDeviceTempSet(DatagramSocket clientSocket, QuantityType<?> temp) throws GreeException {\n+        // If commanding Fahrenheit set halfStep to 1 or 0 to tell the A/C which F integer\n+        // temperature to use as celsius alone is ambigious\n+        Double newVal = temp.doubleValue();\n+        int CorF = temp.getUnit() == SIUnits.CELSIUS ? TEMP_UNIT_CELSIUS : TEMP_UNIT_FAHRENHEIT; // 0=Celsius,\n+                                                                                                 // 1=Fahrenheit\n+        if (((CorF == TEMP_UNIT_CELSIUS) && (newVal < TEMP_MIN_C || newVal > TEMP_MAX_C))\n+                || ((CorF == TEMP_UNIT_FAHRENHEIT) && (newVal < TEMP_MIN_F || newVal > TEMP_MAX_F))) {\n+            throw new IllegalArgumentException(\"Temp Value out of Range\");\n+        }\n+\n+        // Default for Celsius\n+        int outVal = newVal.intValue();\n+        int halfStep = TEMP_HALFSTEP_NO; // for whatever reason halfStep is not supported for Celsius\n+\n+        // If value argument is degrees F, convert Fahrenheit to Celsius,\n+        // SetTem input to A/C always in Celsius despite passing in 1 to TemUn\n+        // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\n+        // F = [68...86]\n+        // C = [20.0, 20.5, 21.1, 21.6, 22.2, 22.7, 23.3, 23.8, 24.4, 25.0, 25.5, 26.1, 26.6, 27.2, 27.7, 28.3,\n+        // 28.8, 29.4, 30.0]\n+        //\n+        // TemSet = [20..30] or [68..86]\n+        // TemRec = value - (value) > 0 ? 1 : 1 -> when xx.5 is request xx will become TemSet and halfStep the indicator\n+        // for \"half on top of TemSet\"\n+        // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\n+        // subtract the float version - the int version to get the fractional difference\n+        // if the difference is positive set halfStep to 1, negative to 0\n+        if (CorF == TEMP_UNIT_FAHRENHEIT) { // If Fahrenheit,\n+            /*\n+             * outVal = (int) (Math.round((newVal - 32.) * 5.0 / 9.0)); // Integer Truncated\n+             * halfStep = ((((newVal - 32.) * 5.0 / 9.0) - outVal) > 0) ? 1 : 0;\n+             */\n+            halfStep = newVal - outVal > 0 ? TEMP_HALFSTEP_YES : TEMP_HALFSTEP_NO;\n+        }\n+        logger.debug(\"Converted temp from {}{} to temp={}, halfStep={}, unit={})\", newVal, temp.getUnit(), outVal,\n+                halfStep, CorF == TEMP_UNIT_CELSIUS ? \"C\" : \"F\");\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(GREE_PROP_TEMPUNIT, CorF);\n+        parameters.put(GREE_PROP_SETTEMP, outVal);\n+        parameters.put(GREE_PROP_TEMPREC, halfStep);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceAir(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_AIR, value);\n+    }\n+\n+    public void setDeviceDry(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_DRY, value);\n+    }\n+\n+    public void setDeviceHealth(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_HEALTH, value);\n+    }\n+\n+    public void setDevicePwrSaving(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(GREE_PROP_PWR_SAVING, value);\n+        parameters.put(GREE_PROP_WINDSPEED, 0);\n+        parameters.put(GREE_PROP_QUIET, 0);\n+        parameters.put(GREE_PROP_TURBO, 0);\n+        parameters.put(GREE_PROP_SLEEP, 0);\n+        parameters.put(GREE_PROP_SLEEPMODE, 0);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public int getIntStatusVal(String valueName) {\n+        /*\n+         * Note : Values can be:\n+         * \"Pow\": Power (0 or 1)\n+         * \"Mod\": Mode: Auto: 0, Cool: 1, Dry: 2, Fan: 3, Heat: 4\n+         * \"SetTem\": Requested Temperature\n+         * \"WdSpd\": Fan Speed : Low:1, Medium Low:2, Medium :3, Medium High :4, High :5\n+         * \"Air\": Air Mode Enabled\n+         * \"Blo\": Dry\n+         * \"Health\": Health\n+         * \"SwhSlp\": Sleep\n+         * \"SlpMod\": ???\n+         * \"Lig\": Light On\n+         * \"SwingLfRig\": Swing Left Right\n+         * \"SwUpDn\": Swing Up Down: // Ceiling:0, Upwards : 10, Downwards : 11, Full range : 1\n+         * \"Quiet\": Quiet mode\n+         * \"Tur\": Turbo\n+         * \"StHt\": 0,\n+         * \"TemUn\": Temperature unit, 0 for Celsius, 1 for Fahrenheit\n+         * \"HeatCoolType\"\n+         * \"TemRec\": (0 or 1), Send with SetTem, when TemUn==1, distinguishes between upper and lower integer Fahrenheit\n+         * temp\n+         * \"SvSt\": Power Saving\n+         */\n+        // Find the valueName in the Returned Status object\n+        if (isStatusAvailable()) {\n+            List<String> colList = Arrays.asList(statusResponseGson.get().packJson.cols);\n+            List<Integer> valList = Arrays.asList(statusResponseGson.get().packJson.dat);\n+            int valueArrayposition = colList.indexOf(valueName);\n+            if (valueArrayposition != -1) {\n+                // get the Corresponding value\n+                Integer value = valList.get(valueArrayposition);\n+                return value;\n+            }\n+        }\n+\n+        return -1;\n+    }\n+\n+    public boolean isStatusAvailable() {\n+        return statusResponseGson.isPresent();\n+    }\n+\n+    public boolean hasStatusValChanged(String valueName) throws GreeException {\n+        if (!prevStatusResponsePackGson.isPresent()) {\n+            return true; // update value if there is no previous one\n+        }\n+        // Find the valueName in the Current Status object\n+        List<String> currcolList = Arrays.asList(statusResponseGson.get().packJson.cols);\n+        List<Integer> currvalList = Arrays.asList(statusResponseGson.get().packJson.dat);\n+        int currvalueArrayposition = currcolList.indexOf(valueName);\n+        if (currvalueArrayposition == -1) {\n+            throw new GreeException(\"Unable to decode device status\");\n+        }\n+\n+        // Find the valueName in the Previous Status object\n+        List<String> prevcolList = Arrays.asList(prevStatusResponsePackGson.get().cols);\n+        List<Integer> prevvalList = Arrays.asList(prevStatusResponsePackGson.get().dat);\n+        int prevvalueArrayposition = prevcolList.indexOf(valueName);\n+        if (prevvalueArrayposition == -1) {\n+            throw new GreeException(\"Unable to get status value\");\n+        }\n+\n+        // Finally Compare the values\n+        return currvalList.get(currvalueArrayposition) != prevvalList.get(prevvalueArrayposition);\n+    }\n+\n+    protected void executeCommand(DatagramSocket clientSocket, Map<String, Integer> parameters) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        try {\n+            // Convert the parameter map values to arrays\n+            String[] keyArray = parameters.keySet().toArray(new String[0]);\n+            Integer[] valueArray = parameters.values().toArray(new Integer[0]);\n+\n+            // Prep the Command Request pack\n+            GreeExecuteCommandPackDTO execCmdPackGson = new GreeExecuteCommandPackDTO();\n+            execCmdPackGson.opt = keyArray;\n+            execCmdPackGson.p = valueArray;\n+            execCmdPackGson.t = GREE_CMDT_CMD;\n+            String execCmdPackStr = gson.toJson(execCmdPackGson);\n+\n+            // Now encrypt and send the Command Request pack\n+            String encryptedCommandReqPacket = GreeCryptoUtil.encryptPack(getKey().getBytes(), execCmdPackStr);\n+            DatagramPacket sendPacket = createPackRequest(0,\n+                    new String(encryptedCommandReqPacket.getBytes(), StandardCharsets.UTF_8));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ddbba49f802627554c380ef9a5b829ac7b1f8cb1"}, "originalPosition": 395}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkwNTk5Mg==", "bodyText": "You should specify the charset for getBytes. And do the same for the other places you are using getKey() in this class.", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r441905992", "createdAt": "2020-06-18T00:37:52Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,530 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeRequestDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePackDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\n+ * device specific attributes as well a the functionality for the Air Conditioner\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeAirDevice {\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\n+    private final static Gson gson = new Gson();\n+    private boolean isBound = false;\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\n+    private int port = 0;\n+    private String encKey = \"\";\n+    private Optional<GreeScanResponseDTO> scanResponseGson = Optional.empty();\n+    private Optional<GreeStatusResponseDTO> statusResponseGson = Optional.empty();\n+    private Optional<GreeStatusResponsePackDTO> prevStatusResponsePackGson = Optional.empty();\n+\n+    public void getDeviceStatus(DatagramSocket clientSocket) throws GreeException {\n+        try {\n+            // Set the values in the HashMap\n+            ArrayList<String> columns = new ArrayList<>();\n+            columns.add(GREE_PROP_POWER);\n+            columns.add(GREE_PROP_MODE);\n+            columns.add(GREE_PROP_SETTEMP);\n+            columns.add(GREE_PROP_WINDSPEED);\n+            columns.add(GREE_PROP_AIR);\n+            columns.add(GREE_PROP_DRY);\n+            columns.add(GREE_PROP_HEALTH);\n+            columns.add(GREE_PROP_SLEEP);\n+            columns.add(GREE_PROP_LIGHT);\n+            columns.add(GREE_PROP_SWINGLEFTRIGHT);\n+            columns.add(GREE_PROP_SWINGUPDOWN);\n+            columns.add(GREE_PROP_QUIET);\n+            columns.add(GREE_PROP_TURBO);\n+            columns.add(GREE_PROP_TEMPUNIT);\n+            columns.add(GREE_PROP_HEAT);\n+            columns.add(GREE_PROP_HEATCOOL);\n+            columns.add(GREE_PROP_TEMPREC);\n+            columns.add(GREE_PROP_PWR_SAVING);\n+            columns.add(GREE_PROP_NOISESET);\n+\n+            // Convert the parameter map values to arrays\n+            String[] colArray = columns.toArray(new String[0]);\n+\n+            // Prep the Command Request pack\n+            GreeReqStatusPackDTO reqStatusPackGson = new GreeReqStatusPackDTO();\n+            reqStatusPackGson.t = GREE_CMDT_STATUS;\n+            reqStatusPackGson.cols = colArray;\n+            reqStatusPackGson.mac = getId();\n+            String reqStatusPackStr = gson.toJson(reqStatusPackGson);\n+\n+            // Encrypt and send the Status Request pack\n+            String encryptedStatusReqPacket = GreeCryptoUtil.encryptPack(getKey().getBytes(), reqStatusPackStr);\n+            DatagramPacket sendPacket = createPackRequest(0,\n+                    new String(encryptedStatusReqPacket.getBytes(), StandardCharsets.UTF_8));\n+            clientSocket.send(sendPacket);\n+\n+            // Recieve a response\n+            JsonReader receivedData = receiveResponse(clientSocket);\n+\n+            // Keep a copy of the old response to be used to check if values have changed\n+            // If first time running, there will not be a previous GreeStatusResponsePack4Gson\n+            if (statusResponseGson.isPresent() && statusResponseGson.get().packJson != null) {\n+                prevStatusResponsePackGson = Optional\n+                        .of(new GreeStatusResponsePackDTO(statusResponseGson.get().packJson));\n+            }\n+\n+            // Read the response, create the JSON to hold the response values\n+            GreeStatusResponseDTO resp = gson.fromJson(receivedData, GreeStatusResponseDTO.class);\n+            resp.decryptedPack = GreeCryptoUtil.decryptPack(this.getKey().getBytes(), resp.pack);\n+            logger.debug(\"Response from device: {}\", resp.decryptedPack);\n+            resp.packJson = gson.fromJson(new JsonReader(new StringReader(resp.decryptedPack)),\n+                    GreeStatusResponsePackDTO.class);\n+\n+            // save the results\n+            statusResponseGson = Optional.of(resp);\n+            updateTempFtoC();\n+        } catch (IOException e) {\n+            throw new GreeException(\"I/O exception while receiving data\", e);\n+        } catch (RuntimeException e) {\n+            String json = statusResponseGson.map(r -> r.packJson.toString()).orElse(\"n/a\");\n+            throw new GreeException(\"Exception while receiving data, JSON=\" + json, e);\n+        }\n+    }\n+\n+    public void bindWithDevice(DatagramSocket clientSocket) throws GreeException {\n+        try {\n+            // Prep the Binding Request pack\n+            GreeBindRequestPackDTO bindReqPackGson = new GreeBindRequestPackDTO();\n+            bindReqPackGson.mac = getId();\n+            bindReqPackGson.t = GREE_CMDT_BIND;\n+            bindReqPackGson.uid = 0;\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\n+\n+            // Encrypt and send the Binding Request pack\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\n+                    bindReqPackStr);\n+            DatagramPacket sendPacket = createPackRequest(1,\n+                    new String(encryptedBindReqPacket.getBytes(), StandardCharsets.UTF_8));\n+            clientSocket.send(sendPacket);\n+\n+            // Recieve a response, create the JSON to hold the response values\n+            GreeBindResponseDTO resp = gson.fromJson(receiveResponse(clientSocket), GreeBindResponseDTO.class);\n+            resp.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(), resp.pack);\n+            resp.packJson = gson.fromJson(new JsonReader(new StringReader(resp.decryptedPack)),\n+                    GreeBindResponsePackDTO.class);\n+\n+            // Now set the key and flag to indicate the bind was succesful\n+            encKey = resp.packJson.key;\n+\n+            // save the outcome\n+            setIsBound(true);\n+        } catch (IOException e) {\n+            throw new GreeException(\"Unable to bind to device\", e);\n+        }\n+    }\n+\n+    public void setDevicePower(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_POWER, value);\n+    }\n+\n+    public void SetDeviceMode(DatagramSocket clientSocket, int value) throws GreeException {\n+        if ((value < 0 || value > 4)) {\n+            throw new GreeException(\"Device mode out of range!\");\n+        }\n+        setCommandValue(clientSocket, GREE_PROP_MODE, value);\n+    }\n+\n+    public void setDeviceSwingUpDown(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\n+        if ((value < 0 || value > 11) || (value > 6 && value < 10)) {\n+            throw new GreeException(\"SwingUpDown value out of range!\");\n+        }\n+        setCommandValue(clientSocket, GREE_PROP_SWINGUPDOWN, value);\n+    }\n+\n+    public void setDeviceSwingLeftRight(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_SWINGLEFTRIGHT, value, 0, 6);\n+    }\n+\n+    /**\n+     * Only allow this to happen if this device has been bound and values are valid\n+     * Possible values are :\n+     * 0 : Auto\n+     * 1 : Low\n+     * 2 : Medium Low\n+     * 3 : Medium\n+     * 4 : Medium High\n+     * 5 : High\n+     */\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, int value) throws GreeException {\n+        if (value < 0 || value > 5) {\n+            throw new GreeException(\"Value out of range!\");\n+        }\n+\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(GREE_PROP_WINDSPEED, value);\n+        parameters.put(GREE_PROP_QUIET, 0);\n+        parameters.put(GREE_PROP_TURBO, 0);\n+        parameters.put(GREE_PROP_NOISE, 0);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceTurbo(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_TURBO, value, 0, 1);\n+    }\n+\n+    public void setQuietMode(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_QUIET, value, 0, 2);\n+    }\n+\n+    public int getDeviceTurbo() {\n+        return getIntStatusVal(GREE_PROP_TURBO);\n+    }\n+\n+    public void setDeviceLight(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_LIGHT, value);\n+    }\n+\n+    /**\n+     * @param value set temperature in degrees Celsius or Fahrenheit\n+     */\n+    public void setDeviceTempSet(DatagramSocket clientSocket, QuantityType<?> temp) throws GreeException {\n+        // If commanding Fahrenheit set halfStep to 1 or 0 to tell the A/C which F integer\n+        // temperature to use as celsius alone is ambigious\n+        Double newVal = temp.doubleValue();\n+        int CorF = temp.getUnit() == SIUnits.CELSIUS ? TEMP_UNIT_CELSIUS : TEMP_UNIT_FAHRENHEIT; // 0=Celsius,\n+                                                                                                 // 1=Fahrenheit\n+        if (((CorF == TEMP_UNIT_CELSIUS) && (newVal < TEMP_MIN_C || newVal > TEMP_MAX_C))\n+                || ((CorF == TEMP_UNIT_FAHRENHEIT) && (newVal < TEMP_MIN_F || newVal > TEMP_MAX_F))) {\n+            throw new IllegalArgumentException(\"Temp Value out of Range\");\n+        }\n+\n+        // Default for Celsius\n+        int outVal = newVal.intValue();\n+        int halfStep = TEMP_HALFSTEP_NO; // for whatever reason halfStep is not supported for Celsius\n+\n+        // If value argument is degrees F, convert Fahrenheit to Celsius,\n+        // SetTem input to A/C always in Celsius despite passing in 1 to TemUn\n+        // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\n+        // F = [68...86]\n+        // C = [20.0, 20.5, 21.1, 21.6, 22.2, 22.7, 23.3, 23.8, 24.4, 25.0, 25.5, 26.1, 26.6, 27.2, 27.7, 28.3,\n+        // 28.8, 29.4, 30.0]\n+        //\n+        // TemSet = [20..30] or [68..86]\n+        // TemRec = value - (value) > 0 ? 1 : 1 -> when xx.5 is request xx will become TemSet and halfStep the indicator\n+        // for \"half on top of TemSet\"\n+        // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\n+        // subtract the float version - the int version to get the fractional difference\n+        // if the difference is positive set halfStep to 1, negative to 0\n+        if (CorF == TEMP_UNIT_FAHRENHEIT) { // If Fahrenheit,\n+            /*\n+             * outVal = (int) (Math.round((newVal - 32.) * 5.0 / 9.0)); // Integer Truncated\n+             * halfStep = ((((newVal - 32.) * 5.0 / 9.0) - outVal) > 0) ? 1 : 0;\n+             */\n+            halfStep = newVal - outVal > 0 ? TEMP_HALFSTEP_YES : TEMP_HALFSTEP_NO;\n+        }\n+        logger.debug(\"Converted temp from {}{} to temp={}, halfStep={}, unit={})\", newVal, temp.getUnit(), outVal,\n+                halfStep, CorF == TEMP_UNIT_CELSIUS ? \"C\" : \"F\");\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(GREE_PROP_TEMPUNIT, CorF);\n+        parameters.put(GREE_PROP_SETTEMP, outVal);\n+        parameters.put(GREE_PROP_TEMPREC, halfStep);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceAir(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_AIR, value);\n+    }\n+\n+    public void setDeviceDry(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_DRY, value);\n+    }\n+\n+    public void setDeviceHealth(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_HEALTH, value);\n+    }\n+\n+    public void setDevicePwrSaving(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(GREE_PROP_PWR_SAVING, value);\n+        parameters.put(GREE_PROP_WINDSPEED, 0);\n+        parameters.put(GREE_PROP_QUIET, 0);\n+        parameters.put(GREE_PROP_TURBO, 0);\n+        parameters.put(GREE_PROP_SLEEP, 0);\n+        parameters.put(GREE_PROP_SLEEPMODE, 0);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public int getIntStatusVal(String valueName) {\n+        /*\n+         * Note : Values can be:\n+         * \"Pow\": Power (0 or 1)\n+         * \"Mod\": Mode: Auto: 0, Cool: 1, Dry: 2, Fan: 3, Heat: 4\n+         * \"SetTem\": Requested Temperature\n+         * \"WdSpd\": Fan Speed : Low:1, Medium Low:2, Medium :3, Medium High :4, High :5\n+         * \"Air\": Air Mode Enabled\n+         * \"Blo\": Dry\n+         * \"Health\": Health\n+         * \"SwhSlp\": Sleep\n+         * \"SlpMod\": ???\n+         * \"Lig\": Light On\n+         * \"SwingLfRig\": Swing Left Right\n+         * \"SwUpDn\": Swing Up Down: // Ceiling:0, Upwards : 10, Downwards : 11, Full range : 1\n+         * \"Quiet\": Quiet mode\n+         * \"Tur\": Turbo\n+         * \"StHt\": 0,\n+         * \"TemUn\": Temperature unit, 0 for Celsius, 1 for Fahrenheit\n+         * \"HeatCoolType\"\n+         * \"TemRec\": (0 or 1), Send with SetTem, when TemUn==1, distinguishes between upper and lower integer Fahrenheit\n+         * temp\n+         * \"SvSt\": Power Saving\n+         */\n+        // Find the valueName in the Returned Status object\n+        if (isStatusAvailable()) {\n+            List<String> colList = Arrays.asList(statusResponseGson.get().packJson.cols);\n+            List<Integer> valList = Arrays.asList(statusResponseGson.get().packJson.dat);\n+            int valueArrayposition = colList.indexOf(valueName);\n+            if (valueArrayposition != -1) {\n+                // get the Corresponding value\n+                Integer value = valList.get(valueArrayposition);\n+                return value;\n+            }\n+        }\n+\n+        return -1;\n+    }\n+\n+    public boolean isStatusAvailable() {\n+        return statusResponseGson.isPresent();\n+    }\n+\n+    public boolean hasStatusValChanged(String valueName) throws GreeException {\n+        if (!prevStatusResponsePackGson.isPresent()) {\n+            return true; // update value if there is no previous one\n+        }\n+        // Find the valueName in the Current Status object\n+        List<String> currcolList = Arrays.asList(statusResponseGson.get().packJson.cols);\n+        List<Integer> currvalList = Arrays.asList(statusResponseGson.get().packJson.dat);\n+        int currvalueArrayposition = currcolList.indexOf(valueName);\n+        if (currvalueArrayposition == -1) {\n+            throw new GreeException(\"Unable to decode device status\");\n+        }\n+\n+        // Find the valueName in the Previous Status object\n+        List<String> prevcolList = Arrays.asList(prevStatusResponsePackGson.get().cols);\n+        List<Integer> prevvalList = Arrays.asList(prevStatusResponsePackGson.get().dat);\n+        int prevvalueArrayposition = prevcolList.indexOf(valueName);\n+        if (prevvalueArrayposition == -1) {\n+            throw new GreeException(\"Unable to get status value\");\n+        }\n+\n+        // Finally Compare the values\n+        return currvalList.get(currvalueArrayposition) != prevvalList.get(prevvalueArrayposition);\n+    }\n+\n+    protected void executeCommand(DatagramSocket clientSocket, Map<String, Integer> parameters) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        try {\n+            // Convert the parameter map values to arrays\n+            String[] keyArray = parameters.keySet().toArray(new String[0]);\n+            Integer[] valueArray = parameters.values().toArray(new Integer[0]);\n+\n+            // Prep the Command Request pack\n+            GreeExecuteCommandPackDTO execCmdPackGson = new GreeExecuteCommandPackDTO();\n+            execCmdPackGson.opt = keyArray;\n+            execCmdPackGson.p = valueArray;\n+            execCmdPackGson.t = GREE_CMDT_CMD;\n+            String execCmdPackStr = gson.toJson(execCmdPackGson);\n+\n+            // Now encrypt and send the Command Request pack\n+            String encryptedCommandReqPacket = GreeCryptoUtil.encryptPack(getKey().getBytes(), execCmdPackStr);\n+            DatagramPacket sendPacket = createPackRequest(0,\n+                    new String(encryptedCommandReqPacket.getBytes(), StandardCharsets.UTF_8));\n+            clientSocket.send(sendPacket);\n+\n+            GreeExecResponseDTO execResponseGson = gson.fromJson(receiveResponse(clientSocket),\n+                    GreeExecResponseDTO.class);\n+            execResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(this.getKey().getBytes(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ddbba49f802627554c380ef9a5b829ac7b1f8cb1"}, "originalPosition": 400}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkwNjE4MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        String encryptedStatusReqPacket = GreeCryptoUtil.encryptPack(getKey().getBytes(), reqStatusPackStr);\n          \n          \n            \n                        DatagramPacket sendPacket = createPackRequest(0,\n          \n          \n            \n                                new String(encryptedStatusReqPacket.getBytes(), StandardCharsets.UTF_8));\n          \n          \n            \n                        String encryptedStatusReqPacket = GreeCryptoUtil.encryptPack(getKey().getBytes(), reqStatusPackStr);\n          \n          \n            \n                        DatagramPacket sendPacket = createPackRequest(0, encryptedStatusReqPacket);", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r441906180", "createdAt": "2020-06-18T00:38:42Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,530 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeRequestDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePackDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\n+ * device specific attributes as well a the functionality for the Air Conditioner\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeAirDevice {\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\n+    private final static Gson gson = new Gson();\n+    private boolean isBound = false;\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\n+    private int port = 0;\n+    private String encKey = \"\";\n+    private Optional<GreeScanResponseDTO> scanResponseGson = Optional.empty();\n+    private Optional<GreeStatusResponseDTO> statusResponseGson = Optional.empty();\n+    private Optional<GreeStatusResponsePackDTO> prevStatusResponsePackGson = Optional.empty();\n+\n+    public void getDeviceStatus(DatagramSocket clientSocket) throws GreeException {\n+        try {\n+            // Set the values in the HashMap\n+            ArrayList<String> columns = new ArrayList<>();\n+            columns.add(GREE_PROP_POWER);\n+            columns.add(GREE_PROP_MODE);\n+            columns.add(GREE_PROP_SETTEMP);\n+            columns.add(GREE_PROP_WINDSPEED);\n+            columns.add(GREE_PROP_AIR);\n+            columns.add(GREE_PROP_DRY);\n+            columns.add(GREE_PROP_HEALTH);\n+            columns.add(GREE_PROP_SLEEP);\n+            columns.add(GREE_PROP_LIGHT);\n+            columns.add(GREE_PROP_SWINGLEFTRIGHT);\n+            columns.add(GREE_PROP_SWINGUPDOWN);\n+            columns.add(GREE_PROP_QUIET);\n+            columns.add(GREE_PROP_TURBO);\n+            columns.add(GREE_PROP_TEMPUNIT);\n+            columns.add(GREE_PROP_HEAT);\n+            columns.add(GREE_PROP_HEATCOOL);\n+            columns.add(GREE_PROP_TEMPREC);\n+            columns.add(GREE_PROP_PWR_SAVING);\n+            columns.add(GREE_PROP_NOISESET);\n+\n+            // Convert the parameter map values to arrays\n+            String[] colArray = columns.toArray(new String[0]);\n+\n+            // Prep the Command Request pack\n+            GreeReqStatusPackDTO reqStatusPackGson = new GreeReqStatusPackDTO();\n+            reqStatusPackGson.t = GREE_CMDT_STATUS;\n+            reqStatusPackGson.cols = colArray;\n+            reqStatusPackGson.mac = getId();\n+            String reqStatusPackStr = gson.toJson(reqStatusPackGson);\n+\n+            // Encrypt and send the Status Request pack\n+            String encryptedStatusReqPacket = GreeCryptoUtil.encryptPack(getKey().getBytes(), reqStatusPackStr);\n+            DatagramPacket sendPacket = createPackRequest(0,\n+                    new String(encryptedStatusReqPacket.getBytes(), StandardCharsets.UTF_8));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ddbba49f802627554c380ef9a5b829ac7b1f8cb1"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkwNjM3Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        DatagramPacket sendPacket = createPackRequest(1,\n          \n          \n            \n                                new String(encryptedBindReqPacket.getBytes(), StandardCharsets.UTF_8));\n          \n          \n            \n                        DatagramPacket sendPacket = createPackRequest(1, encryptedBindReqPacket);", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r441906372", "createdAt": "2020-06-18T00:39:34Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,530 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeRequestDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePackDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\n+ * device specific attributes as well a the functionality for the Air Conditioner\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeAirDevice {\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\n+    private final static Gson gson = new Gson();\n+    private boolean isBound = false;\n+    private InetAddress ipAddress = InetAddress.getLoopbackAddress();\n+    private int port = 0;\n+    private String encKey = \"\";\n+    private Optional<GreeScanResponseDTO> scanResponseGson = Optional.empty();\n+    private Optional<GreeStatusResponseDTO> statusResponseGson = Optional.empty();\n+    private Optional<GreeStatusResponsePackDTO> prevStatusResponsePackGson = Optional.empty();\n+\n+    public void getDeviceStatus(DatagramSocket clientSocket) throws GreeException {\n+        try {\n+            // Set the values in the HashMap\n+            ArrayList<String> columns = new ArrayList<>();\n+            columns.add(GREE_PROP_POWER);\n+            columns.add(GREE_PROP_MODE);\n+            columns.add(GREE_PROP_SETTEMP);\n+            columns.add(GREE_PROP_WINDSPEED);\n+            columns.add(GREE_PROP_AIR);\n+            columns.add(GREE_PROP_DRY);\n+            columns.add(GREE_PROP_HEALTH);\n+            columns.add(GREE_PROP_SLEEP);\n+            columns.add(GREE_PROP_LIGHT);\n+            columns.add(GREE_PROP_SWINGLEFTRIGHT);\n+            columns.add(GREE_PROP_SWINGUPDOWN);\n+            columns.add(GREE_PROP_QUIET);\n+            columns.add(GREE_PROP_TURBO);\n+            columns.add(GREE_PROP_TEMPUNIT);\n+            columns.add(GREE_PROP_HEAT);\n+            columns.add(GREE_PROP_HEATCOOL);\n+            columns.add(GREE_PROP_TEMPREC);\n+            columns.add(GREE_PROP_PWR_SAVING);\n+            columns.add(GREE_PROP_NOISESET);\n+\n+            // Convert the parameter map values to arrays\n+            String[] colArray = columns.toArray(new String[0]);\n+\n+            // Prep the Command Request pack\n+            GreeReqStatusPackDTO reqStatusPackGson = new GreeReqStatusPackDTO();\n+            reqStatusPackGson.t = GREE_CMDT_STATUS;\n+            reqStatusPackGson.cols = colArray;\n+            reqStatusPackGson.mac = getId();\n+            String reqStatusPackStr = gson.toJson(reqStatusPackGson);\n+\n+            // Encrypt and send the Status Request pack\n+            String encryptedStatusReqPacket = GreeCryptoUtil.encryptPack(getKey().getBytes(), reqStatusPackStr);\n+            DatagramPacket sendPacket = createPackRequest(0,\n+                    new String(encryptedStatusReqPacket.getBytes(), StandardCharsets.UTF_8));\n+            clientSocket.send(sendPacket);\n+\n+            // Recieve a response\n+            JsonReader receivedData = receiveResponse(clientSocket);\n+\n+            // Keep a copy of the old response to be used to check if values have changed\n+            // If first time running, there will not be a previous GreeStatusResponsePack4Gson\n+            if (statusResponseGson.isPresent() && statusResponseGson.get().packJson != null) {\n+                prevStatusResponsePackGson = Optional\n+                        .of(new GreeStatusResponsePackDTO(statusResponseGson.get().packJson));\n+            }\n+\n+            // Read the response, create the JSON to hold the response values\n+            GreeStatusResponseDTO resp = gson.fromJson(receivedData, GreeStatusResponseDTO.class);\n+            resp.decryptedPack = GreeCryptoUtil.decryptPack(this.getKey().getBytes(), resp.pack);\n+            logger.debug(\"Response from device: {}\", resp.decryptedPack);\n+            resp.packJson = gson.fromJson(new JsonReader(new StringReader(resp.decryptedPack)),\n+                    GreeStatusResponsePackDTO.class);\n+\n+            // save the results\n+            statusResponseGson = Optional.of(resp);\n+            updateTempFtoC();\n+        } catch (IOException e) {\n+            throw new GreeException(\"I/O exception while receiving data\", e);\n+        } catch (RuntimeException e) {\n+            String json = statusResponseGson.map(r -> r.packJson.toString()).orElse(\"n/a\");\n+            throw new GreeException(\"Exception while receiving data, JSON=\" + json, e);\n+        }\n+    }\n+\n+    public void bindWithDevice(DatagramSocket clientSocket) throws GreeException {\n+        try {\n+            // Prep the Binding Request pack\n+            GreeBindRequestPackDTO bindReqPackGson = new GreeBindRequestPackDTO();\n+            bindReqPackGson.mac = getId();\n+            bindReqPackGson.t = GREE_CMDT_BIND;\n+            bindReqPackGson.uid = 0;\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\n+\n+            // Encrypt and send the Binding Request pack\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\n+                    bindReqPackStr);\n+            DatagramPacket sendPacket = createPackRequest(1,\n+                    new String(encryptedBindReqPacket.getBytes(), StandardCharsets.UTF_8));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ddbba49f802627554c380ef9a5b829ac7b1f8cb1"}, "originalPosition": 153}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a46683468d9c5bd20ec602c68e8f06f809522c77", "author": {"user": {"login": "markus7017", "name": "Markus Michels"}}, "url": "https://github.com/openhab/openhab-addons/commit/a46683468d9c5bd20ec602c68e8f06f809522c77", "committedDate": "2020-06-20T09:34:08Z", "message": "review changes, ONLINE/OFFLINE handling, missing localized messages\nadded for logging/thing status, some minor issues fixed\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM0NjE1NjUz", "url": "https://github.com/openhab/openhab-addons/pull/7504#pullrequestreview-434615653", "createdAt": "2020-06-22T05:40:53Z", "commit": {"oid": "a46683468d9c5bd20ec602c68e8f06f809522c77"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQwNTo0MDo1M1rOGmyhyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQwNjoxMzo1MFrOGmzF8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzMyNjkyMQ==", "bodyText": "remove these comments", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r443326921", "createdAt": "2020-06-22T05:40:53Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/GreeBindingConstants.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal;\n+\n+import java.util.Collections;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+\n+/**\n+ * The {@link GreeBindingConstants} class defines common constants, which are\n+ * used across the whole binding.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeBindingConstants {\n+\n+    public static final String BINDING_ID = \"gree\";\n+\n+    public static final ThingTypeUID THING_TYPE_GREEAIRCON = new ThingTypeUID(BINDING_ID, \"airconditioner\");\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections.singleton(THING_TYPE_GREEAIRCON);\n+\n+    // List of all Thing Type UIDs\n+    public static final ThingTypeUID GREE_THING_TYPE = new ThingTypeUID(BINDING_ID, \"airconditioner\");\n+\n+    // Thing configuration items\n+    public static final String PROPERTY_IP = \"ipAddress\";\n+    public static final String PROPERTY_BROADCAST = \"broadcastAddress\";\n+\n+    // List of all Channel ids\n+    public static final String POWER_CHANNEL = \"power\";\n+    public static final String MODE_CHANNEL = \"mode\";\n+    public static final String TURBO_CHANNEL = \"turbo\";\n+    public static final String LIGHT_CHANNEL = \"light\";\n+    public static final String TEMP_CHANNEL = \"temperature\";\n+    public static final String SWINGUD_CHANNEL = \"swingUpDown\";\n+    public static final String SWINGLR_CHANNEL = \"swingLeftRight\";\n+    public static final String WINDSPEED_CHANNEL = \"windspeed\";\n+    public static final String QUIET_CHANNEL = \"quiet\";\n+    public static final String AIR_CHANNEL = \"air\";\n+    public static final String DRY_CHANNEL = \"dry\";\n+    public static final String HEALTH_CHANNEL = \"health\";\n+    public static final String PWRSAV_CHANNEL = \"powersave\";\n+\n+    // Mode channel\n+    public static final String MODE_AUTO = \"auto\";\n+    public static final String MODE_COOL = \"cool\";\n+    public static final String MODE_DRY = \"dry\";\n+    public static final String MODE_FAN = \"fan\";\n+    public static final String MODE_FAN2 = \"fan-only\";\n+    public static final String MODE_HEAT = \"heat\";\n+    public static final String MODE_ECO = \"eco\";\n+    public static final String MODE_ON = \"on\";\n+    public static final String MODE_OFF = \"off\";\n+    public static final int GREE_MODE_AUTO = 0;\n+    public static final int GREE_MODE_COOL = 1;\n+    public static final int GREE_MODE_DRY = 2;\n+    public static final int GREE_MODE_FAN = 3;\n+    public static final int GREE_MODE_HEAT = 4;\n+\n+    // Quiet channel\n+    public static final String QUIET_OFF = \"off\";\n+    public static final String QUIET_AUTO = \"auto\";\n+    public static final String QUIET_QUIET = \"quiet\";\n+    public static final int GREE_QUIET_OFF = 0;\n+    public static final int GREE_QUIET_AUTO = 1;\n+    public static final int GREE_QUIET_QUIET = 2;\n+\n+    // UDPPort used to communicate using UDP with GREE Airconditioners. .\n+    public static final String VENDOR_GREE = \"gree\";\n+    public static final int GREE_PORT = 7000;\n+\n+    public static final String GREE_CID = \"app\";\n+    public static final String GREE_CMDT_BIND = \"bind\";\n+    public static final String GREE_CMDT_SCAN = \"scan\";\n+    public static final String GREE_CMDT_STATUS = \"status\";\n+    public static final String GREE_CMDT_CMD = \"cmd\";\n+    public static final String GREE_CMDT_PACK = \"pack\";\n+\n+    public static final String GREE_CMD_OPT_NAME = \"name\"; // unit name\n+    public static final String GREE_CMD_OPT_HOST = \"host\"; // remote host (cloud)\n+\n+    /*\n+     * Note : Values can be:\n+     * \"Pow\": Power (0 or 1)\n+     * \"Mod\": Mode: Auto: 0, Cool: 1, Dry: 2, Fan: 3, Heat: 4\n+     * \"SetTem\": Requested Temperature\n+     * \"WdSpd\": Fan Speed : Low:1, Medium Low:2, Medium :3, Medium High :4, High :5\n+     * \"Air\": Air Mode Enabled\n+     * \"Blo\": Dry\n+     * \"Health\": Health\n+     * \"SwhSlp\": Sleep\n+     * \"SlpMod\": ???\n+     * \"Lig\": Light On\n+     * \"SwingLfRig\": Swing Left Right\n+     * \"SwUpDn\": Swing Up Down: // Ceiling:0, Upwards : 10, Downwards : 11, Full range : 1\n+     * \"Quiet\": Quiet mode\n+     * \"Tur\": Turbo\n+     * \"StHt\": 0,\n+     * \"TemUn\": Temperature unit, 0 for Celsius, 1 for Fahrenheit\n+     * \"HeatCoolType\"\n+     * \"TemRec\": (0 or 1), Send with SetTem, when TemUn==1, distinguishes between upper and lower integer Fahrenheit\n+     * temp\n+     * \"SvSt\": Power Saving\n+     */\n+    public static final String GREE_PROP_POWER = \"Pow\";\n+    public static final String GREE_PROP_MODE = \"Mod\";\n+    public static final String GREE_PROP_SWINGUPDOWN = \"SwUpDn\";\n+    public static final String GREE_PROP_SWINGLEFTRIGHT = \"SwingLfRig\";\n+    public static final String GREE_PROP_WINDSPEED = \"WdSpd\";\n+    public static final String GREE_PROP_AIR = \"Air\";\n+    public static final String GREE_PROP_DRY = \"Blo\";\n+    public static final String GREE_PROP_TURBO = \"Tur\";\n+    public static final String GREE_PROP_QUIET = \"Quiet\";\n+    public static final String GREE_PROP_NOISE = \"NoiseSet\";\n+    public static final String GREE_PROP_LIGHT = \"Lig\";\n+    public static final String GREE_PROP_HEALTH = \"Health\";\n+    public static final String GREE_PROP_SLEEP = \"SwhSlp\";\n+    public static final String GREE_PROP_SLEEPMODE = \"SlpMod\";\n+    public static final String GREE_PROP_PWR_SAVING = \"SvSt\";\n+    public static final String GREE_PROP_SETTEMP = \"SetTem\";\n+    public static final String GREE_PROP_TEMPUNIT = \"TemUn\";\n+    public static final String GREE_PROP_TEMPREC = \"TemRec\";\n+    public static final String GREE_PROP_HEAT = \"StHt\";\n+    public static final String GREE_PROP_HEATCOOL = \"HeatCoolType\";\n+    public static final String GREE_PROP_NOISESET = \"NoiseSet\";\n+\n+    // Temperatur types and min/max ranges\n+    public static final int TEMP_UNIT_CELSIUS = 0;\n+    public static final int TEMP_UNIT_FAHRENHEIT = 1;\n+    public static final int TEMP_MIN_C = 16;\n+    public static final int TEMP_MAX_C = 30;\n+    public static final int TEMP_MIN_F = 61;\n+    public static final int TEMP_MAX_F = 86;\n+    public static final int TEMP_HALFSTEP_NO = 0;\n+    public static final int TEMP_HALFSTEP_YES = 1;\n+\n+    // parameters.put(\"SvSt\", value);\n+    // parameters.put(\"SwhSlp\", 0);\n+    // parameters.put(\"SlpMod\", 0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a46683468d9c5bd20ec602c68e8f06f809522c77"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzMyNzA0NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static String GetAESGeneralKey() {\n          \n          \n            \n                public static String getAESGeneralKey() {", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r443327044", "createdAt": "2020-06-22T05:41:28Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/GreeCryptoUtil.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.security.InvalidKeyException;\n+import java.security.Key;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Base64;\n+\n+import javax.crypto.BadPaddingException;\n+import javax.crypto.Cipher;\n+import javax.crypto.IllegalBlockSizeException;\n+import javax.crypto.NoSuchPaddingException;\n+import javax.crypto.spec.SecretKeySpec;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The CryptoUtil class provides functionality for encrypting and decrypting\n+ * messages sent to and from the Air Conditioner\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeCryptoUtil {\n+    private static final String AES_KEY = \"a3K8Bx%2r8Y7#xDh\";\n+\n+    public static String GetAESGeneralKey() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a46683468d9c5bd20ec602c68e8f06f809522c77"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzMzNTk2MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void SetDeviceMode(DatagramSocket clientSocket, int value) throws GreeException {\n          \n          \n            \n                public void setDeviceMode(DatagramSocket clientSocket, int value) throws GreeException {", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r443335960", "createdAt": "2020-06-22T06:12:59Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,512 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeRequestDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePackDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\n+ * device specific attributes as well a the functionality for the Air Conditioner\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeAirDevice {\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\n+    private final static Gson gson = new Gson();\n+    private boolean isBound = false;\n+    private final InetAddress ipAddress;\n+    private int port = 0;\n+    private String encKey = \"\";\n+    private Optional<GreeScanResponseDTO> scanResponseGson = Optional.empty();\n+    private Optional<GreeStatusResponseDTO> statusResponseGson = Optional.empty();\n+    private Optional<GreeStatusResponsePackDTO> prevStatusResponsePackGson = Optional.empty();\n+\n+    public GreeAirDevice() {\n+        ipAddress = InetAddress.getLoopbackAddress();\n+    }\n+\n+    public GreeAirDevice(InetAddress ipAddress, int port, GreeScanResponseDTO scanResponse) {\n+        this.ipAddress = ipAddress;\n+        this.port = port;\n+        this.scanResponseGson = Optional.of(scanResponse);\n+    }\n+\n+    public void getDeviceStatus(DatagramSocket clientSocket) throws GreeException {\n+\n+        if (!isBound) {\n+            throw new GreeException(\"Device not bound\");\n+        }\n+        try {\n+            // Set the values in the HashMap\n+            ArrayList<String> columns = new ArrayList<>();\n+            columns.add(GREE_PROP_POWER);\n+            columns.add(GREE_PROP_MODE);\n+            columns.add(GREE_PROP_SETTEMP);\n+            columns.add(GREE_PROP_WINDSPEED);\n+            columns.add(GREE_PROP_AIR);\n+            columns.add(GREE_PROP_DRY);\n+            columns.add(GREE_PROP_HEALTH);\n+            columns.add(GREE_PROP_SLEEP);\n+            columns.add(GREE_PROP_LIGHT);\n+            columns.add(GREE_PROP_SWINGLEFTRIGHT);\n+            columns.add(GREE_PROP_SWINGUPDOWN);\n+            columns.add(GREE_PROP_QUIET);\n+            columns.add(GREE_PROP_TURBO);\n+            columns.add(GREE_PROP_TEMPUNIT);\n+            columns.add(GREE_PROP_HEAT);\n+            columns.add(GREE_PROP_HEATCOOL);\n+            columns.add(GREE_PROP_TEMPREC);\n+            columns.add(GREE_PROP_PWR_SAVING);\n+            columns.add(GREE_PROP_NOISESET);\n+\n+            // Convert the parameter map values to arrays\n+            String[] colArray = columns.toArray(new String[0]);\n+\n+            // Prep the Command Request pack\n+            GreeReqStatusPackDTO reqStatusPackGson = new GreeReqStatusPackDTO();\n+            reqStatusPackGson.t = GREE_CMDT_STATUS;\n+            reqStatusPackGson.cols = colArray;\n+            reqStatusPackGson.mac = getId();\n+            String reqStatusPackStr = gson.toJson(reqStatusPackGson);\n+\n+            // Encrypt and send the Status Request pack\n+            String encryptedStatusReqPacket = GreeCryptoUtil.encryptPack(getKey(), reqStatusPackStr);\n+            DatagramPacket sendPacket = createPackRequest(0,\n+                    new String(encryptedStatusReqPacket.getBytes(), StandardCharsets.UTF_8));\n+            clientSocket.send(sendPacket);\n+\n+            // Keep a copy of the old response to be used to check if values have changed\n+            // If first time running, there will not be a previous GreeStatusResponsePack4Gson\n+            if (statusResponseGson.isPresent() && statusResponseGson.get().packJson != null) {\n+                prevStatusResponsePackGson = Optional\n+                        .of(new GreeStatusResponsePackDTO(statusResponseGson.get().packJson));\n+            }\n+\n+            // Read the response, create the JSON to hold the response values\n+            GreeStatusResponseDTO resp = receiveResponse(clientSocket, GreeStatusResponseDTO.class);\n+            resp.decryptedPack = GreeCryptoUtil.decryptPack(getKey(), resp.pack);\n+            logger.debug(\"Response from device: {}\", resp.decryptedPack);\n+            resp.packJson = gson.fromJson(resp.decryptedPack, GreeStatusResponsePackDTO.class);\n+\n+            // save the results\n+            statusResponseGson = Optional.of(resp);\n+            updateTempFtoC();\n+        } catch (IOException | JsonSyntaxException e) {\n+            throw new GreeException(\"I/O exception while updating status\", e);\n+        } catch (RuntimeException e) {\n+            logger.debug(\"Exception\", e);\n+            String json = statusResponseGson.map(r -> r.packJson.toString()).orElse(\"n/a\");\n+            throw new GreeException(\"Exception while updating status, JSON=\" + json, e);\n+        }\n+    }\n+\n+    public void bindWithDevice(DatagramSocket clientSocket) throws GreeException {\n+        try {\n+            // Prep the Binding Request pack\n+            GreeBindRequestPackDTO bindReqPackGson = new GreeBindRequestPackDTO();\n+            bindReqPackGson.mac = getId();\n+            bindReqPackGson.t = GREE_CMDT_BIND;\n+            bindReqPackGson.uid = 0;\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\n+\n+            // Encrypt and send the Binding Request pack\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\n+                    bindReqPackStr);\n+            DatagramPacket sendPacket = createPackRequest(1, encryptedBindReqPacket);\n+            clientSocket.send(sendPacket);\n+\n+            // Recieve a response, create the JSON to hold the response values\n+            GreeBindResponseDTO resp = receiveResponse(clientSocket, GreeBindResponseDTO.class);\n+            resp.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(), resp.pack);\n+            resp.packJson = gson.fromJson(resp.decryptedPack, GreeBindResponsePackDTO.class);\n+\n+            // Now set the key and flag to indicate the bind was succesful\n+            encKey = resp.packJson.key;\n+\n+            // save the outcome\n+            isBound = true;\n+        } catch (IOException | JsonSyntaxException e) {\n+            throw new GreeException(\"Unable to bind to device\", e);\n+        }\n+    }\n+\n+    public void setDevicePower(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_POWER, value);\n+    }\n+\n+    public void SetDeviceMode(DatagramSocket clientSocket, int value) throws GreeException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a46683468d9c5bd20ec602c68e8f06f809522c77"}, "originalPosition": 184}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzMzNjE3Ng==", "bodyText": "please specify the charset", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r443336176", "createdAt": "2020-06-22T06:13:50Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeAirDevice.java", "diffHunk": "@@ -0,0 +1,512 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.openhab.binding.gree.internal.GreeCryptoUtil;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.gson.GreeBindRequestPackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeBindResponsePackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecResponsePackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeExecuteCommandPackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeReqStatusPackDTO;\n+import org.openhab.binding.gree.internal.gson.GreeRequestDTO;\n+import org.openhab.binding.gree.internal.gson.GreeScanResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponseDTO;\n+import org.openhab.binding.gree.internal.gson.GreeStatusResponsePackDTO;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * The GreeDevice object repesents a Gree Airconditioner and provides\n+ * device specific attributes as well a the functionality for the Air Conditioner\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeAirDevice {\n+    private final Logger logger = LoggerFactory.getLogger(GreeAirDevice.class);\n+    private final static Gson gson = new Gson();\n+    private boolean isBound = false;\n+    private final InetAddress ipAddress;\n+    private int port = 0;\n+    private String encKey = \"\";\n+    private Optional<GreeScanResponseDTO> scanResponseGson = Optional.empty();\n+    private Optional<GreeStatusResponseDTO> statusResponseGson = Optional.empty();\n+    private Optional<GreeStatusResponsePackDTO> prevStatusResponsePackGson = Optional.empty();\n+\n+    public GreeAirDevice() {\n+        ipAddress = InetAddress.getLoopbackAddress();\n+    }\n+\n+    public GreeAirDevice(InetAddress ipAddress, int port, GreeScanResponseDTO scanResponse) {\n+        this.ipAddress = ipAddress;\n+        this.port = port;\n+        this.scanResponseGson = Optional.of(scanResponse);\n+    }\n+\n+    public void getDeviceStatus(DatagramSocket clientSocket) throws GreeException {\n+\n+        if (!isBound) {\n+            throw new GreeException(\"Device not bound\");\n+        }\n+        try {\n+            // Set the values in the HashMap\n+            ArrayList<String> columns = new ArrayList<>();\n+            columns.add(GREE_PROP_POWER);\n+            columns.add(GREE_PROP_MODE);\n+            columns.add(GREE_PROP_SETTEMP);\n+            columns.add(GREE_PROP_WINDSPEED);\n+            columns.add(GREE_PROP_AIR);\n+            columns.add(GREE_PROP_DRY);\n+            columns.add(GREE_PROP_HEALTH);\n+            columns.add(GREE_PROP_SLEEP);\n+            columns.add(GREE_PROP_LIGHT);\n+            columns.add(GREE_PROP_SWINGLEFTRIGHT);\n+            columns.add(GREE_PROP_SWINGUPDOWN);\n+            columns.add(GREE_PROP_QUIET);\n+            columns.add(GREE_PROP_TURBO);\n+            columns.add(GREE_PROP_TEMPUNIT);\n+            columns.add(GREE_PROP_HEAT);\n+            columns.add(GREE_PROP_HEATCOOL);\n+            columns.add(GREE_PROP_TEMPREC);\n+            columns.add(GREE_PROP_PWR_SAVING);\n+            columns.add(GREE_PROP_NOISESET);\n+\n+            // Convert the parameter map values to arrays\n+            String[] colArray = columns.toArray(new String[0]);\n+\n+            // Prep the Command Request pack\n+            GreeReqStatusPackDTO reqStatusPackGson = new GreeReqStatusPackDTO();\n+            reqStatusPackGson.t = GREE_CMDT_STATUS;\n+            reqStatusPackGson.cols = colArray;\n+            reqStatusPackGson.mac = getId();\n+            String reqStatusPackStr = gson.toJson(reqStatusPackGson);\n+\n+            // Encrypt and send the Status Request pack\n+            String encryptedStatusReqPacket = GreeCryptoUtil.encryptPack(getKey(), reqStatusPackStr);\n+            DatagramPacket sendPacket = createPackRequest(0,\n+                    new String(encryptedStatusReqPacket.getBytes(), StandardCharsets.UTF_8));\n+            clientSocket.send(sendPacket);\n+\n+            // Keep a copy of the old response to be used to check if values have changed\n+            // If first time running, there will not be a previous GreeStatusResponsePack4Gson\n+            if (statusResponseGson.isPresent() && statusResponseGson.get().packJson != null) {\n+                prevStatusResponsePackGson = Optional\n+                        .of(new GreeStatusResponsePackDTO(statusResponseGson.get().packJson));\n+            }\n+\n+            // Read the response, create the JSON to hold the response values\n+            GreeStatusResponseDTO resp = receiveResponse(clientSocket, GreeStatusResponseDTO.class);\n+            resp.decryptedPack = GreeCryptoUtil.decryptPack(getKey(), resp.pack);\n+            logger.debug(\"Response from device: {}\", resp.decryptedPack);\n+            resp.packJson = gson.fromJson(resp.decryptedPack, GreeStatusResponsePackDTO.class);\n+\n+            // save the results\n+            statusResponseGson = Optional.of(resp);\n+            updateTempFtoC();\n+        } catch (IOException | JsonSyntaxException e) {\n+            throw new GreeException(\"I/O exception while updating status\", e);\n+        } catch (RuntimeException e) {\n+            logger.debug(\"Exception\", e);\n+            String json = statusResponseGson.map(r -> r.packJson.toString()).orElse(\"n/a\");\n+            throw new GreeException(\"Exception while updating status, JSON=\" + json, e);\n+        }\n+    }\n+\n+    public void bindWithDevice(DatagramSocket clientSocket) throws GreeException {\n+        try {\n+            // Prep the Binding Request pack\n+            GreeBindRequestPackDTO bindReqPackGson = new GreeBindRequestPackDTO();\n+            bindReqPackGson.mac = getId();\n+            bindReqPackGson.t = GREE_CMDT_BIND;\n+            bindReqPackGson.uid = 0;\n+            String bindReqPackStr = gson.toJson(bindReqPackGson);\n+\n+            // Encrypt and send the Binding Request pack\n+            String encryptedBindReqPacket = GreeCryptoUtil.encryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(),\n+                    bindReqPackStr);\n+            DatagramPacket sendPacket = createPackRequest(1, encryptedBindReqPacket);\n+            clientSocket.send(sendPacket);\n+\n+            // Recieve a response, create the JSON to hold the response values\n+            GreeBindResponseDTO resp = receiveResponse(clientSocket, GreeBindResponseDTO.class);\n+            resp.decryptedPack = GreeCryptoUtil.decryptPack(GreeCryptoUtil.getAESGeneralKeyByteArray(), resp.pack);\n+            resp.packJson = gson.fromJson(resp.decryptedPack, GreeBindResponsePackDTO.class);\n+\n+            // Now set the key and flag to indicate the bind was succesful\n+            encKey = resp.packJson.key;\n+\n+            // save the outcome\n+            isBound = true;\n+        } catch (IOException | JsonSyntaxException e) {\n+            throw new GreeException(\"Unable to bind to device\", e);\n+        }\n+    }\n+\n+    public void setDevicePower(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_POWER, value);\n+    }\n+\n+    public void SetDeviceMode(DatagramSocket clientSocket, int value) throws GreeException {\n+        if ((value < 0 || value > 4)) {\n+            throw new GreeException(\"Device mode out of range!\");\n+        }\n+        setCommandValue(clientSocket, GREE_PROP_MODE, value);\n+    }\n+\n+    public void setDeviceSwingUpDown(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Only values 0,1,2,3,4,5,6,10,11 allowed\n+        if ((value < 0 || value > 11) || (value > 6 && value < 10)) {\n+            throw new GreeException(\"SwingUpDown value out of range!\");\n+        }\n+        setCommandValue(clientSocket, GREE_PROP_SWINGUPDOWN, value);\n+    }\n+\n+    public void setDeviceSwingLeftRight(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_SWINGLEFTRIGHT, value, 0, 6);\n+    }\n+\n+    /**\n+     * Only allow this to happen if this device has been bound and values are valid\n+     * Possible values are :\n+     * 0 : Auto\n+     * 1 : Low\n+     * 2 : Medium Low\n+     * 3 : Medium\n+     * 4 : Medium High\n+     * 5 : High\n+     */\n+    public void setDeviceWindspeed(DatagramSocket clientSocket, int value) throws GreeException {\n+        if (value < 0 || value > 5) {\n+            throw new GreeException(\"Value out of range!\");\n+        }\n+\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(GREE_PROP_WINDSPEED, value);\n+        parameters.put(GREE_PROP_QUIET, 0);\n+        parameters.put(GREE_PROP_TURBO, 0);\n+        parameters.put(GREE_PROP_NOISE, 0);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceTurbo(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_TURBO, value, 0, 1);\n+    }\n+\n+    public void setQuietMode(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_QUIET, value, 0, 2);\n+    }\n+\n+    public int getDeviceTurbo() {\n+        return getIntStatusVal(GREE_PROP_TURBO);\n+    }\n+\n+    public void setDeviceLight(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_LIGHT, value);\n+    }\n+\n+    /**\n+     * @param value set temperature in degrees Celsius or Fahrenheit\n+     */\n+    public void setDeviceTempSet(DatagramSocket clientSocket, QuantityType<?> temp) throws GreeException {\n+        // If commanding Fahrenheit set halfStep to 1 or 0 to tell the A/C which F integer\n+        // temperature to use as celsius alone is ambigious\n+        double newVal = temp.doubleValue();\n+        int CorF = temp.getUnit() == SIUnits.CELSIUS ? TEMP_UNIT_CELSIUS : TEMP_UNIT_FAHRENHEIT; // 0=Celsius,\n+                                                                                                 // 1=Fahrenheit\n+        if (((CorF == TEMP_UNIT_CELSIUS) && (newVal < TEMP_MIN_C || newVal > TEMP_MAX_C))\n+                || ((CorF == TEMP_UNIT_FAHRENHEIT) && (newVal < TEMP_MIN_F || newVal > TEMP_MAX_F))) {\n+            throw new IllegalArgumentException(\"Temp Value out of Range\");\n+        }\n+\n+        // Default for Celsius\n+        int outVal = (int) newVal;\n+        int halfStep = TEMP_HALFSTEP_NO; // for whatever reason halfStep is not supported for Celsius\n+\n+        // If value argument is degrees F, convert Fahrenheit to Celsius,\n+        // SetTem input to A/C always in Celsius despite passing in 1 to TemUn\n+        // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\n+        // F = [68...86]\n+        // C = [20.0, 20.5, 21.1, 21.6, 22.2, 22.7, 23.3, 23.8, 24.4, 25.0, 25.5, 26.1, 26.6, 27.2, 27.7, 28.3,\n+        // 28.8, 29.4, 30.0]\n+        //\n+        // TemSet = [20..30] or [68..86]\n+        // TemRec = value - (value) > 0 ? 1 : 1 -> when xx.5 is request xx will become TemSet and halfStep the indicator\n+        // for \"half on top of TemSet\"\n+        // ******************TempRec TemSet Mapping for setting Fahrenheit****************************\n+        // subtract the float version - the int version to get the fractional difference\n+        // if the difference is positive set halfStep to 1, negative to 0\n+        if (CorF == TEMP_UNIT_FAHRENHEIT) { // If Fahrenheit,\n+            halfStep = newVal - outVal > 0 ? TEMP_HALFSTEP_YES : TEMP_HALFSTEP_NO;\n+        }\n+        logger.debug(\"Converted temp from {}{} to temp={}, halfStep={}, unit={})\", newVal, temp.getUnit(), outVal,\n+                halfStep, CorF == TEMP_UNIT_CELSIUS ? \"C\" : \"F\");\n+\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(GREE_PROP_TEMPUNIT, CorF);\n+        parameters.put(GREE_PROP_SETTEMP, outVal);\n+        parameters.put(GREE_PROP_TEMPREC, halfStep);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public void setDeviceAir(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_AIR, value);\n+    }\n+\n+    public void setDeviceDry(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_DRY, value);\n+    }\n+\n+    public void setDeviceHealth(DatagramSocket clientSocket, int value) throws GreeException {\n+        setCommandValue(clientSocket, GREE_PROP_HEALTH, value);\n+    }\n+\n+    public void setDevicePwrSaving(DatagramSocket clientSocket, int value) throws GreeException {\n+        // Set the values in the HashMap\n+        HashMap<String, Integer> parameters = new HashMap<>();\n+        parameters.put(GREE_PROP_PWR_SAVING, value);\n+        parameters.put(GREE_PROP_WINDSPEED, 0);\n+        parameters.put(GREE_PROP_QUIET, 0);\n+        parameters.put(GREE_PROP_TURBO, 0);\n+        parameters.put(GREE_PROP_SLEEP, 0);\n+        parameters.put(GREE_PROP_SLEEPMODE, 0);\n+        executeCommand(clientSocket, parameters);\n+    }\n+\n+    public int getIntStatusVal(String valueName) {\n+        /*\n+         * Note : Values can be:\n+         * \"Pow\": Power (0 or 1)\n+         * \"Mod\": Mode: Auto: 0, Cool: 1, Dry: 2, Fan: 3, Heat: 4\n+         * \"SetTem\": Requested Temperature\n+         * \"WdSpd\": Fan Speed : Low:1, Medium Low:2, Medium :3, Medium High :4, High :5\n+         * \"Air\": Air Mode Enabled\n+         * \"Blo\": Dry\n+         * \"Health\": Health\n+         * \"SwhSlp\": Sleep\n+         * \"SlpMod\": ???\n+         * \"Lig\": Light On\n+         * \"SwingLfRig\": Swing Left Right\n+         * \"SwUpDn\": Swing Up Down: // Ceiling:0, Upwards : 10, Downwards : 11, Full range : 1\n+         * \"Quiet\": Quiet mode\n+         * \"Tur\": Turbo\n+         * \"StHt\": 0,\n+         * \"TemUn\": Temperature unit, 0 for Celsius, 1 for Fahrenheit\n+         * \"HeatCoolType\"\n+         * \"TemRec\": (0 or 1), Send with SetTem, when TemUn==1, distinguishes between upper and lower integer Fahrenheit\n+         * temp\n+         * \"SvSt\": Power Saving\n+         */\n+        // Find the valueName in the Returned Status object\n+        if (isStatusAvailable()) {\n+            List<String> colList = Arrays.asList(statusResponseGson.get().packJson.cols);\n+            List<Integer> valList = Arrays.asList(statusResponseGson.get().packJson.dat);\n+            int valueArrayposition = colList.indexOf(valueName);\n+            if (valueArrayposition != -1) {\n+                // get the Corresponding value\n+                Integer value = valList.get(valueArrayposition);\n+                return value;\n+            }\n+        }\n+\n+        return -1;\n+    }\n+\n+    public boolean isStatusAvailable() {\n+        return statusResponseGson.isPresent();\n+    }\n+\n+    public boolean hasStatusValChanged(String valueName) throws GreeException {\n+        if (!prevStatusResponsePackGson.isPresent()) {\n+            return true; // update value if there is no previous one\n+        }\n+        // Find the valueName in the Current Status object\n+        List<String> currcolList = Arrays.asList(statusResponseGson.get().packJson.cols);\n+        List<Integer> currvalList = Arrays.asList(statusResponseGson.get().packJson.dat);\n+        int currvalueArrayposition = currcolList.indexOf(valueName);\n+        if (currvalueArrayposition == -1) {\n+            throw new GreeException(\"Unable to decode device status\");\n+        }\n+\n+        // Find the valueName in the Previous Status object\n+        List<String> prevcolList = Arrays.asList(prevStatusResponsePackGson.get().cols);\n+        List<Integer> prevvalList = Arrays.asList(prevStatusResponsePackGson.get().dat);\n+        int prevvalueArrayposition = prevcolList.indexOf(valueName);\n+        if (prevvalueArrayposition == -1) {\n+            throw new GreeException(\"Unable to get status value\");\n+        }\n+\n+        // Finally Compare the values\n+        return currvalList.get(currvalueArrayposition) != prevvalList.get(prevvalueArrayposition);\n+    }\n+\n+    protected void executeCommand(DatagramSocket clientSocket, Map<String, Integer> parameters) throws GreeException {\n+        // Only allow this to happen if this device has been bound\n+        if (!getIsBound()) {\n+            throw new GreeException(\"Device is not bound!\");\n+        }\n+\n+        try {\n+            // Convert the parameter map values to arrays\n+            String[] keyArray = parameters.keySet().toArray(new String[0]);\n+            Integer[] valueArray = parameters.values().toArray(new Integer[0]);\n+\n+            // Prep the Command Request pack\n+            GreeExecuteCommandPackDTO execCmdPackGson = new GreeExecuteCommandPackDTO();\n+            execCmdPackGson.opt = keyArray;\n+            execCmdPackGson.p = valueArray;\n+            execCmdPackGson.t = GREE_CMDT_CMD;\n+            String execCmdPackStr = gson.toJson(execCmdPackGson);\n+\n+            // Now encrypt and send the Command Request pack\n+            String encryptedCommandReqPacket = GreeCryptoUtil.encryptPack(getKey(), execCmdPackStr);\n+            DatagramPacket sendPacket = createPackRequest(0, encryptedCommandReqPacket);\n+            clientSocket.send(sendPacket);\n+\n+            // Receive and decode result\n+            GreeExecResponseDTO execResponseGson = receiveResponse(clientSocket, GreeExecResponseDTO.class);\n+            execResponseGson.decryptedPack = GreeCryptoUtil.decryptPack(getKey(), execResponseGson.pack);\n+\n+            // Create the JSON to hold the response values\n+            execResponseGson.packJson = gson.fromJson(execResponseGson.decryptedPack, GreeExecResponsePackDTO.class);\n+        } catch (IOException | JsonSyntaxException e) {\n+            throw new GreeException(\"Exception on command execution\", e);\n+        }\n+    }\n+\n+    private void setCommandValue(DatagramSocket clientSocket, String command, int value) throws GreeException {\n+        executeCommand(clientSocket, Collections.singletonMap(command, value));\n+    }\n+\n+    private void setCommandValue(DatagramSocket clientSocket, String command, int value, int min, int max)\n+            throws GreeException {\n+        if ((value < min) || (value > max)) {\n+            throw new GreeException(\"Command value out of range!\");\n+        }\n+        executeCommand(clientSocket, Collections.singletonMap(command, value));\n+    }\n+\n+    private DatagramPacket createPackRequest(int i, String pack) {\n+        GreeRequestDTO request = new GreeRequestDTO();\n+        request.cid = GREE_CID;\n+        request.i = i;\n+        request.t = GREE_CMDT_PACK;\n+        request.uid = 0;\n+        request.tcid = getId();\n+        request.pack = pack;\n+        byte[] sendData = gson.toJson(request).getBytes();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a46683468d9c5bd20ec602c68e8f06f809522c77"}, "originalPosition": 432}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5c171d858e3aa58b6de4206ed8ea96ebcc3514bb", "author": {"user": {"login": "markus7017", "name": "Markus Michels"}}, "url": "https://github.com/openhab/openhab-addons/commit/5c171d858e3aa58b6de4206ed8ea96ebcc3514bb", "committedDate": "2020-06-22T22:40:11Z", "message": "review changes\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM2MTEzMDQ1", "url": "https://github.com/openhab/openhab-addons/pull/7504#pullrequestreview-436113045", "createdAt": "2020-06-23T20:03:00Z", "commit": {"oid": "5c171d858e3aa58b6de4206ed8ea96ebcc3514bb"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QyMDowMzowMFrOGn4lUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QyMToyMzoxMVrOGn7JHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ3NDcwNQ==", "bodyText": "Just had a new release to have to update the version.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                <version>2.5.6-SNAPSHOT</version>\n          \n          \n            \n                <version>2.5.7-SNAPSHOT</version>", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r444474705", "createdAt": "2020-06-23T20:03:00Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/pom.xml", "diffHunk": "@@ -0,0 +1,17 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+\n+  <modelVersion>4.0.0</modelVersion>\n+\n+  <parent>\n+    <groupId>org.openhab.addons.bundles</groupId>\n+    <artifactId>org.openhab.addons.reactor.bundles</artifactId>\n+    <version>2.5.6-SNAPSHOT</version>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c171d858e3aa58b6de4206ed8ea96ebcc3514bb"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDQ3NTMxMA==", "bodyText": "This is populated in the constructor so you can make it final.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n          \n          \n            \n                private final GreeDeviceFinder deviceFinder;", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r444475310", "createdAt": "2020-06-23T20:04:19Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeHandler.java", "diffHunk": "@@ -0,0 +1,549 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.net.DatagramSocket;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.ImperialUnits;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.gree.internal.GreeConfiguration;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.discovery.GreeDeviceFinder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link GreeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(GreeHandler.class);\n+    private final GreeTranslationProvider messages;\n+    private GreeConfiguration config = new GreeConfiguration();\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c171d858e3aa58b6de4206ed8ea96ebcc3514bb"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDUxMjI2MA==", "bodyText": "Thing labels can be changed at runtime, so you should either retrieve the label at runtime at the time when you need to use it, or you should just stick to the thing uid that doesn't change.", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r444512260", "createdAt": "2020-06-23T21:13:46Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeHandler.java", "diffHunk": "@@ -0,0 +1,549 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.net.DatagramSocket;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.ImperialUnits;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.gree.internal.GreeConfiguration;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.discovery.GreeDeviceFinder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link GreeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(GreeHandler.class);\n+    private final GreeTranslationProvider messages;\n+    private GreeConfiguration config = new GreeConfiguration();\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+    private GreeAirDevice device = new GreeAirDevice();\n+    private Optional<DatagramSocket> clientSocket = Optional.empty();\n+    private final String thingId;\n+    private boolean forceRefresh = false;\n+\n+    private @Nullable ScheduledFuture<?> refreshTask;\n+    private long lastRefreshTime = 0;\n+\n+    public GreeHandler(Thing thing, GreeTranslationProvider messages, GreeDeviceFinder deviceFinder) {\n+        super(thing);\n+        this.messages = messages;\n+        this.deviceFinder = deviceFinder;\n+        String label = getThing().getLabel();\n+        this.thingId = label != null ? label : getThing().getUID().getId();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c171d858e3aa58b6de4206ed8ea96ebcc3514bb"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDUxNDQyOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Change this only for good reasons.\n          \n          \n            \n            Only change this if you have a good reason to.", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r444514428", "createdAt": "2020-06-23T21:18:19Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/README.md", "diffHunk": "@@ -0,0 +1,148 @@\n+# GREE Binding\n+\n+This binding integrates GREE Air Conditioners.\n+\n+Note: The GREE Air Conditioner must already be setup on the WiFi network and must have a fixed IP Address.\n+\n+## Supported Things\n+\n+This binding supports one Thing type `airconditioner`.\n+\n+## Discovery\n+\n+Once the GREE is on the network (WiFi active) it could be discovery automatically.\n+An IP broadcast message is sent and every responding units gets added to the Inbox. \n+\n+## Binding Configuration\n+\n+No binding configuration is required.\n+\n+#### Manual Thing Creation\n+\n+Fans can be manually created in the *PaperUI* or *HABmin*, or by placing a *.things* file in the *conf/things* directory.  See example below.\n+\n+\n+## Thing Configuration\n+\n+| Channel Name     | Type       | Description                                                                                   |\n+|------------------|------------|-----------------------------------------------------------------------------------------------|\n+| ipAddress        | IP Address | IP address of the unit.                                                                       |\n+| broadcastAddress | IP Address | Broadcast address being used for discovery, usually derived from the IP interface address.    |\n+| refresh          | Integer    | Refresh interval in seconds for polling the device status.                                    |\n+\n+The Air Conditioner's IP address is mandatory, all other parameters are optional. \n+If the broadcast is not set (default) it will be derived from openHAB's network setting (PaperUI:Configuration:System:Network Settings). \n+Change this only for good reasons.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c171d858e3aa58b6de4206ed8ea96ebcc3514bb"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDUxNTE2NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            When changing the mode the air conditioner will be turned on (unless is off is selected).\n          \n          \n            \n            When changing mode, the air conditioner will be turned on unless \"off\" is selected.", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r444515164", "createdAt": "2020-06-23T21:20:03Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/README.md", "diffHunk": "@@ -0,0 +1,148 @@\n+# GREE Binding\n+\n+This binding integrates GREE Air Conditioners.\n+\n+Note: The GREE Air Conditioner must already be setup on the WiFi network and must have a fixed IP Address.\n+\n+## Supported Things\n+\n+This binding supports one Thing type `airconditioner`.\n+\n+## Discovery\n+\n+Once the GREE is on the network (WiFi active) it could be discovery automatically.\n+An IP broadcast message is sent and every responding units gets added to the Inbox. \n+\n+## Binding Configuration\n+\n+No binding configuration is required.\n+\n+#### Manual Thing Creation\n+\n+Fans can be manually created in the *PaperUI* or *HABmin*, or by placing a *.things* file in the *conf/things* directory.  See example below.\n+\n+\n+## Thing Configuration\n+\n+| Channel Name     | Type       | Description                                                                                   |\n+|------------------|------------|-----------------------------------------------------------------------------------------------|\n+| ipAddress        | IP Address | IP address of the unit.                                                                       |\n+| broadcastAddress | IP Address | Broadcast address being used for discovery, usually derived from the IP interface address.    |\n+| refresh          | Integer    | Refresh interval in seconds for polling the device status.                                    |\n+\n+The Air Conditioner's IP address is mandatory, all other parameters are optional. \n+If the broadcast is not set (default) it will be derived from openHAB's network setting (PaperUI:Configuration:System:Network Settings). \n+Change this only for good reasons.\n+\n+## Channels\n+\n+The following channels are supported for fans:\n+\n+| Channel Name  | Item Type | Description                                                                                       |\n+|---------------|-----------|---------------------------------------------------------------------------------------------------|\n+| power         | Switch    | Power on/off the Air Conditioner                                                                  |\n+| mode          | String    | Sets the operating mode of the Air Conditioner                                                    |\n+|               |           | Mode can be one of auto/cool/eco/dry/fan/heat or on/off                                     |\n+|               |           | Check the Air Conditioner's operating manual for supported modes.                                 |\n+| temperature   | Number    | Sets the desired room temperature                                                                 |\n+|\u00a0air           | Switch    | Set on/off the Air Conditioner's Air function if applicable to the Air Conditioner model          |\n+| dry           | Switch    | Set on/off the Air Conditioner's Dry function if applicable to the Air Conditioner model          |\n+|\u00a0health        | Switch    | Set on/off the Air Conditioner's Health function if applicable to the Air Conditioner model       |\n+| turbo         | Switch    | Set on/off the Air Conditioner's Turbo Mode.                                                      |\n+| quiet         | String    | Set Quiet Mode: off/auto/quiet                                                                    |\n+| swingUpDown   | Number    | Sets the vertical (up..down) swing action on the Air Conditioner,                                 |\n+|               |           | OFF: 0, Full Swing: 1, Up: 2, MidUp: 3, Mid: 4, Mid Down: 5, Down : 6                             |\n+| swingLeftRight| Number    | Sets the horizontal (left..right) swing action on the Air Conditioner                             |\n+|               |           |\u00a0OFF: 0, Full Swing: 1, Left: 2, Mid Left: 3, Mid: 4, Mid Right: 5, Right : 6                      |\n+|\u00a0windspeed     | Number    | Sets the fan speed on the Air conditioner Auto:0, Low:1, MidLow:2, Mid:3, MidHigh:4, High:5       |\n+|               |           |\u00a0The number of speeds depends on the Air Conditioner model.                                        |\n+|\u00a0powersave     | Switch    | Set on/off the Air Conditioner's Power Saving function if applicable to the Air Conditioner model |\n+| light         | Switch    | Enable/disable the front display on the Air Conditioner if applicable to the Air Conditioner model|\n+|               |           | Full Swing: 1, Up: 2, MidUp: 3, Mid: 4, Mid Down: 5, Down : 6                                     |\n+\n+\n+When changing the mode the air conditioner will be turned on (unless is off is selected).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c171d858e3aa58b6de4206ed8ea96ebcc3514bb"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDUxNTU3MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            This example shows who to make the GREE Air Conditioner controllable by Google HA (A/C mode + temperature)\n          \n          \n            \n            This example shows how to make a GREE Air Conditioner controllable by Google HA (A/C mode + temperature)", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r444515571", "createdAt": "2020-06-23T21:20:58Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/README.md", "diffHunk": "@@ -0,0 +1,148 @@\n+# GREE Binding\n+\n+This binding integrates GREE Air Conditioners.\n+\n+Note: The GREE Air Conditioner must already be setup on the WiFi network and must have a fixed IP Address.\n+\n+## Supported Things\n+\n+This binding supports one Thing type `airconditioner`.\n+\n+## Discovery\n+\n+Once the GREE is on the network (WiFi active) it could be discovery automatically.\n+An IP broadcast message is sent and every responding units gets added to the Inbox. \n+\n+## Binding Configuration\n+\n+No binding configuration is required.\n+\n+#### Manual Thing Creation\n+\n+Fans can be manually created in the *PaperUI* or *HABmin*, or by placing a *.things* file in the *conf/things* directory.  See example below.\n+\n+\n+## Thing Configuration\n+\n+| Channel Name     | Type       | Description                                                                                   |\n+|------------------|------------|-----------------------------------------------------------------------------------------------|\n+| ipAddress        | IP Address | IP address of the unit.                                                                       |\n+| broadcastAddress | IP Address | Broadcast address being used for discovery, usually derived from the IP interface address.    |\n+| refresh          | Integer    | Refresh interval in seconds for polling the device status.                                    |\n+\n+The Air Conditioner's IP address is mandatory, all other parameters are optional. \n+If the broadcast is not set (default) it will be derived from openHAB's network setting (PaperUI:Configuration:System:Network Settings). \n+Change this only for good reasons.\n+\n+## Channels\n+\n+The following channels are supported for fans:\n+\n+| Channel Name  | Item Type | Description                                                                                       |\n+|---------------|-----------|---------------------------------------------------------------------------------------------------|\n+| power         | Switch    | Power on/off the Air Conditioner                                                                  |\n+| mode          | String    | Sets the operating mode of the Air Conditioner                                                    |\n+|               |           | Mode can be one of auto/cool/eco/dry/fan/heat or on/off                                     |\n+|               |           | Check the Air Conditioner's operating manual for supported modes.                                 |\n+| temperature   | Number    | Sets the desired room temperature                                                                 |\n+|\u00a0air           | Switch    | Set on/off the Air Conditioner's Air function if applicable to the Air Conditioner model          |\n+| dry           | Switch    | Set on/off the Air Conditioner's Dry function if applicable to the Air Conditioner model          |\n+|\u00a0health        | Switch    | Set on/off the Air Conditioner's Health function if applicable to the Air Conditioner model       |\n+| turbo         | Switch    | Set on/off the Air Conditioner's Turbo Mode.                                                      |\n+| quiet         | String    | Set Quiet Mode: off/auto/quiet                                                                    |\n+| swingUpDown   | Number    | Sets the vertical (up..down) swing action on the Air Conditioner,                                 |\n+|               |           | OFF: 0, Full Swing: 1, Up: 2, MidUp: 3, Mid: 4, Mid Down: 5, Down : 6                             |\n+| swingLeftRight| Number    | Sets the horizontal (left..right) swing action on the Air Conditioner                             |\n+|               |           |\u00a0OFF: 0, Full Swing: 1, Left: 2, Mid Left: 3, Mid: 4, Mid Right: 5, Right : 6                      |\n+|\u00a0windspeed     | Number    | Sets the fan speed on the Air conditioner Auto:0, Low:1, MidLow:2, Mid:3, MidHigh:4, High:5       |\n+|               |           |\u00a0The number of speeds depends on the Air Conditioner model.                                        |\n+|\u00a0powersave     | Switch    | Set on/off the Air Conditioner's Power Saving function if applicable to the Air Conditioner model |\n+| light         | Switch    | Enable/disable the front display on the Air Conditioner if applicable to the Air Conditioner model|\n+|               |           | Full Swing: 1, Up: 2, MidUp: 3, Mid: 4, Mid Down: 5, Down : 6                                     |\n+\n+\n+When changing the mode the air conditioner will be turned on (unless is off is selected).\n+\n+## Full Example\n+\n+**Things**\n+\n+```\n+Thing gree:airconditioner:a1234561 [ ipAddress=\"192.168.1.111\", refresh=2 ]\n+```\n+\n+**Items**\n+\n+```\n+Switch AirconPower                  { channel=\"gree:airconditioner:a1234561:power\" }\n+Number AirconMode                   { channel=\"gree:airconditioner:a1234561:mode\" }\n+Switch AirconTurbo                  { channel=\"gree:airconditioner:a1234561:turbo\" }\n+Switch AirconLight                  { channel=\"gree:airconditioner:a1234561:light\" }\n+Number AirconTemp \"Temperature [%.1f \u00b0C]\" {channel=\"gree:airconditioner:a1234561:temperature\" }\n+Number AirconTempSet                { channel=\"gree:airconditioner:a1234561:temperature\" }\n+Number AirconSwingVertical          { channel=\"gree:airconditioner:a1234561:swingUpDown\" }\n+Number AirconSwingHorizontal        { channel=\"gree:airconditioner:a1234561:swingLeftRight\" }\n+Number AirconFanSpeed               { channel=\"gree:airconditioner:a1234561:windspeed\" }\n+Switch AirconAir                    { channel=\"gree:airconditioner:a1234561:air\" }\n+Switch AirconDry                    { channel=\"gree:airconditioner:a1234561:dry\" }\n+Switch AirconHealth                 { channel=\"gree:airconditioner:a1234561:health\" }\n+Switch AirconPowerSaving            { channel=\"gree:airconditioner:a1234561:powersave\" }\n+```\n+\n+**Sitemap**\n+\n+This is an example of how to set up your sitemap.\n+\n+```\n+Frame label=\"Controls\"\n+{\n+   Switch item=AirconMode label=\"Mode\" mappings=[\"auto\"=\"Auto\", \"cool\"=\"Cool\", \"eco\"=\"Eco\", \"dry\"=\"Dry\", \"fan\"=\"Fan\", \"turbo\"=\"Turbo\", \"heat\"=\"Heat\", \"on\"=\"ON\", \"off\"=\"OFF\"]\n+   Setpoint item=AirconTemp label=\"Set temperature\" icon=temperature minValue=16 maxValue=30 step=1\n+}\n+Frame label=\"Fan Speed\"\n+{\n+   Switch item=AirconFanSpeed label=\"Fan Speed\" mappings=[0=\"Auto\", 1=\"Low\", 2=\"Medium Low\", 3=\"Medium\", 4=\"Medium High\", 5=\"High\"] icon=fan\n+}\n+Frame label=\"Fan-Swing Direction\"\n+{\n+   Switch item=AirconSwingVertical label=\"Direction V\" mappings=[0=\"Off\", 1=\"Full\", 2=\"Up\", 3=\"Mid-up\", 4=\"Mid\", 5=\"Mid-low\", 6=\"Down\"] icon=flow\n+   Switch item=AirconSwingHorizontal label=\"Direction H\" mappings=[0=\"Off\", 1=\"Full\", 2=\"Left\", 3=\"Mid-left\", 4=\"Mid\", 5=\"Mid-right\", 6=\"Right\"] icon=flow\n+}\n+Frame label=\"Options\"\n+{\n+   Switch item=AirconTurbo label=\"Turbo\" icon=fan\n+   Switch item=AirconLight label=\"Light\" icon=light\n+   Switch item=AirconAir label=\"Air\" icon=flow\n+   Switch item=AirconDry label=\"Dry\" icon=rain\n+   Switch item=AirconHealth label=\"Health\" icon=smiley\n+   Switch item=AirconPowerSaving label=\"Power Saving\" icon=poweroutlet\n+}\n+```\n+\n+**Example**\n+\n+This example shows who to make the GREE Air Conditioner controllable by Google HA (A/C mode + temperature)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c171d858e3aa58b6de4206ed8ea96ebcc3514bb"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDUxNTcwOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                     } \n          \n          \n            \n                    }", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r444515708", "createdAt": "2020-06-23T21:21:15Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/README.md", "diffHunk": "@@ -0,0 +1,148 @@\n+# GREE Binding\n+\n+This binding integrates GREE Air Conditioners.\n+\n+Note: The GREE Air Conditioner must already be setup on the WiFi network and must have a fixed IP Address.\n+\n+## Supported Things\n+\n+This binding supports one Thing type `airconditioner`.\n+\n+## Discovery\n+\n+Once the GREE is on the network (WiFi active) it could be discovery automatically.\n+An IP broadcast message is sent and every responding units gets added to the Inbox. \n+\n+## Binding Configuration\n+\n+No binding configuration is required.\n+\n+#### Manual Thing Creation\n+\n+Fans can be manually created in the *PaperUI* or *HABmin*, or by placing a *.things* file in the *conf/things* directory.  See example below.\n+\n+\n+## Thing Configuration\n+\n+| Channel Name     | Type       | Description                                                                                   |\n+|------------------|------------|-----------------------------------------------------------------------------------------------|\n+| ipAddress        | IP Address | IP address of the unit.                                                                       |\n+| broadcastAddress | IP Address | Broadcast address being used for discovery, usually derived from the IP interface address.    |\n+| refresh          | Integer    | Refresh interval in seconds for polling the device status.                                    |\n+\n+The Air Conditioner's IP address is mandatory, all other parameters are optional. \n+If the broadcast is not set (default) it will be derived from openHAB's network setting (PaperUI:Configuration:System:Network Settings). \n+Change this only for good reasons.\n+\n+## Channels\n+\n+The following channels are supported for fans:\n+\n+| Channel Name  | Item Type | Description                                                                                       |\n+|---------------|-----------|---------------------------------------------------------------------------------------------------|\n+| power         | Switch    | Power on/off the Air Conditioner                                                                  |\n+| mode          | String    | Sets the operating mode of the Air Conditioner                                                    |\n+|               |           | Mode can be one of auto/cool/eco/dry/fan/heat or on/off                                     |\n+|               |           | Check the Air Conditioner's operating manual for supported modes.                                 |\n+| temperature   | Number    | Sets the desired room temperature                                                                 |\n+|\u00a0air           | Switch    | Set on/off the Air Conditioner's Air function if applicable to the Air Conditioner model          |\n+| dry           | Switch    | Set on/off the Air Conditioner's Dry function if applicable to the Air Conditioner model          |\n+|\u00a0health        | Switch    | Set on/off the Air Conditioner's Health function if applicable to the Air Conditioner model       |\n+| turbo         | Switch    | Set on/off the Air Conditioner's Turbo Mode.                                                      |\n+| quiet         | String    | Set Quiet Mode: off/auto/quiet                                                                    |\n+| swingUpDown   | Number    | Sets the vertical (up..down) swing action on the Air Conditioner,                                 |\n+|               |           | OFF: 0, Full Swing: 1, Up: 2, MidUp: 3, Mid: 4, Mid Down: 5, Down : 6                             |\n+| swingLeftRight| Number    | Sets the horizontal (left..right) swing action on the Air Conditioner                             |\n+|               |           |\u00a0OFF: 0, Full Swing: 1, Left: 2, Mid Left: 3, Mid: 4, Mid Right: 5, Right : 6                      |\n+|\u00a0windspeed     | Number    | Sets the fan speed on the Air conditioner Auto:0, Low:1, MidLow:2, Mid:3, MidHigh:4, High:5       |\n+|               |           |\u00a0The number of speeds depends on the Air Conditioner model.                                        |\n+|\u00a0powersave     | Switch    | Set on/off the Air Conditioner's Power Saving function if applicable to the Air Conditioner model |\n+| light         | Switch    | Enable/disable the front display on the Air Conditioner if applicable to the Air Conditioner model|\n+|               |           | Full Swing: 1, Up: 2, MidUp: 3, Mid: 4, Mid Down: 5, Down : 6                                     |\n+\n+\n+When changing the mode the air conditioner will be turned on (unless is off is selected).\n+\n+## Full Example\n+\n+**Things**\n+\n+```\n+Thing gree:airconditioner:a1234561 [ ipAddress=\"192.168.1.111\", refresh=2 ]\n+```\n+\n+**Items**\n+\n+```\n+Switch AirconPower                  { channel=\"gree:airconditioner:a1234561:power\" }\n+Number AirconMode                   { channel=\"gree:airconditioner:a1234561:mode\" }\n+Switch AirconTurbo                  { channel=\"gree:airconditioner:a1234561:turbo\" }\n+Switch AirconLight                  { channel=\"gree:airconditioner:a1234561:light\" }\n+Number AirconTemp \"Temperature [%.1f \u00b0C]\" {channel=\"gree:airconditioner:a1234561:temperature\" }\n+Number AirconTempSet                { channel=\"gree:airconditioner:a1234561:temperature\" }\n+Number AirconSwingVertical          { channel=\"gree:airconditioner:a1234561:swingUpDown\" }\n+Number AirconSwingHorizontal        { channel=\"gree:airconditioner:a1234561:swingLeftRight\" }\n+Number AirconFanSpeed               { channel=\"gree:airconditioner:a1234561:windspeed\" }\n+Switch AirconAir                    { channel=\"gree:airconditioner:a1234561:air\" }\n+Switch AirconDry                    { channel=\"gree:airconditioner:a1234561:dry\" }\n+Switch AirconHealth                 { channel=\"gree:airconditioner:a1234561:health\" }\n+Switch AirconPowerSaving            { channel=\"gree:airconditioner:a1234561:powersave\" }\n+```\n+\n+**Sitemap**\n+\n+This is an example of how to set up your sitemap.\n+\n+```\n+Frame label=\"Controls\"\n+{\n+   Switch item=AirconMode label=\"Mode\" mappings=[\"auto\"=\"Auto\", \"cool\"=\"Cool\", \"eco\"=\"Eco\", \"dry\"=\"Dry\", \"fan\"=\"Fan\", \"turbo\"=\"Turbo\", \"heat\"=\"Heat\", \"on\"=\"ON\", \"off\"=\"OFF\"]\n+   Setpoint item=AirconTemp label=\"Set temperature\" icon=temperature minValue=16 maxValue=30 step=1\n+}\n+Frame label=\"Fan Speed\"\n+{\n+   Switch item=AirconFanSpeed label=\"Fan Speed\" mappings=[0=\"Auto\", 1=\"Low\", 2=\"Medium Low\", 3=\"Medium\", 4=\"Medium High\", 5=\"High\"] icon=fan\n+}\n+Frame label=\"Fan-Swing Direction\"\n+{\n+   Switch item=AirconSwingVertical label=\"Direction V\" mappings=[0=\"Off\", 1=\"Full\", 2=\"Up\", 3=\"Mid-up\", 4=\"Mid\", 5=\"Mid-low\", 6=\"Down\"] icon=flow\n+   Switch item=AirconSwingHorizontal label=\"Direction H\" mappings=[0=\"Off\", 1=\"Full\", 2=\"Left\", 3=\"Mid-left\", 4=\"Mid\", 5=\"Mid-right\", 6=\"Right\"] icon=flow\n+}\n+Frame label=\"Options\"\n+{\n+   Switch item=AirconTurbo label=\"Turbo\" icon=fan\n+   Switch item=AirconLight label=\"Light\" icon=light\n+   Switch item=AirconAir label=\"Air\" icon=flow\n+   Switch item=AirconDry label=\"Dry\" icon=rain\n+   Switch item=AirconHealth label=\"Health\" icon=smiley\n+   Switch item=AirconPowerSaving label=\"Power Saving\" icon=poweroutlet\n+}\n+```\n+\n+**Example**\n+\n+This example shows who to make the GREE Air Conditioner controllable by Google HA (A/C mode + temperature)\n+\n+**Items**\n+\n+\n+```\n+Group Gree_Modechannel              \"Gree\"                { ga=\"Thermostat\" } // allows mapping for Google Home Assistent\n+Switch   GreeAirConditioner_Power   \"Aircon\"              {channel=\"gree:airconditioner:a1234561:power\", ga=\"Switch\"}\n+Number   GreeAirConditioner_Mode    \"Aircon Mode\"         {channel=\"gree:airconditioner:a1234561:mode\", ga=\"thermostatMode\"}\n+Number   GreeAirConditioner_Temp    \"Aircon Temperature\"  {channel=\"gree:airconditioner:a1234561:temperature}\n+Switch   GreeAirConditioner_Lightl  \"Light\"               {channel=\"gree:airconditioner:a1234561:light\"}\n+```\n+\n+**Rules**\n+\n+```\n+rule \"Mode changed\"\n+when\n+        Item GreeAirConditioner_Mode changed\n+then        \n+        if(GreeAirConditioner_Mode.state == \"cool\" ) {\n+            logInfo(\"A/C\", \"Cooling has be turned on\")\n+         } ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c171d858e3aa58b6de4206ed8ea96ebcc3514bb"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDUxNTkxMA==", "bodyText": "Please move final fields above non-final fields.", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r444515910", "createdAt": "2020-06-23T21:21:42Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeHandler.java", "diffHunk": "@@ -0,0 +1,549 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.net.DatagramSocket;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.ImperialUnits;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.gree.internal.GreeConfiguration;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.discovery.GreeDeviceFinder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link GreeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(GreeHandler.class);\n+    private final GreeTranslationProvider messages;\n+    private GreeConfiguration config = new GreeConfiguration();\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+    private GreeAirDevice device = new GreeAirDevice();\n+    private Optional<DatagramSocket> clientSocket = Optional.empty();\n+    private final String thingId;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c171d858e3aa58b6de4206ed8ea96ebcc3514bb"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDUxNjQxMg==", "bodyText": "You can safely remove synchronization here.", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r444516412", "createdAt": "2020-06-23T21:22:42Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeHandler.java", "diffHunk": "@@ -0,0 +1,549 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.net.DatagramSocket;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.ImperialUnits;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.gree.internal.GreeConfiguration;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.discovery.GreeDeviceFinder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link GreeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(GreeHandler.class);\n+    private final GreeTranslationProvider messages;\n+    private GreeConfiguration config = new GreeConfiguration();\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+    private GreeAirDevice device = new GreeAirDevice();\n+    private Optional<DatagramSocket> clientSocket = Optional.empty();\n+    private final String thingId;\n+    private boolean forceRefresh = false;\n+\n+    private @Nullable ScheduledFuture<?> refreshTask;\n+    private long lastRefreshTime = 0;\n+\n+    public GreeHandler(Thing thing, GreeTranslationProvider messages, GreeDeviceFinder deviceFinder) {\n+        super(thing);\n+        this.messages = messages;\n+        this.deviceFinder = deviceFinder;\n+        String label = getThing().getLabel();\n+        this.thingId = label != null ? label : getThing().getUID().getId();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(GreeConfiguration.class);\n+        if (config.ipAddress.isEmpty() || (config.refresh < 0)) {\n+            String message = messages.get(\"thinginit.invconf\");\n+            logger.warn(\"{}: {}\", thingId, message);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, message);\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        // Start the automatic refresh cycles\n+        startAutomaticRefresh();\n+        scheduler.execute(this::initializeThing);\n+    }\n+\n+    private void initializeThing() {\n+        String message = \"\";\n+        try {\n+            if (!clientSocket.isPresent()) {\n+                clientSocket = Optional.of(new DatagramSocket());\n+                clientSocket.get().setSoTimeout(DATAGRAM_SOCKET_TIMEOUT);\n+            }\n+            // Find the GREE device\n+            deviceFinder.scan(clientSocket.get(), config.ipAddress, false);\n+            GreeAirDevice newDevice = deviceFinder.getDeviceByIPAddress(config.ipAddress);\n+            if (newDevice != null) {\n+                // Ok, our device responded, now let's Bind with it\n+                device = newDevice;\n+                device.bindWithDevice(clientSocket.get());\n+                if (device.getIsBound()) {\n+                    updateStatus(ThingStatus.ONLINE);\n+                    return;\n+                }\n+            }\n+\n+            message = messages.get(\"thinginit.failed\");\n+            logger.info(\"{}: {}\", thingId, message);\n+        } catch (GreeException e) {\n+            logger.info(\"{}: {}\", thingId, messages.get(\"thinginit.exception\", e.getMessage()));\n+        } catch (IOException e) {\n+            logger.warn(\"{}: {}\", thingId, messages.get(\"thinginit.exception\", \"I/O Error\"), e);\n+        } catch (RuntimeException e) {\n+            logger.warn(\"{}: {}\", thingId, messages.get(\"thinginit.exception\", \"RuntimeException\"), e);\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, message);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            // The thing is updated by the scheduled automatic refresh so do nothing here.\n+        } else {\n+            logger.debug(\"{}: Issue command {}\u00a0to channe {}\", thingId, command, channelUID.getIdWithoutGroup());\n+            String channelId = channelUID.getIdWithoutGroup();\n+            logger.debug(\"{}: Handle command {} for channel {}, command class {}\", thingId, command, channelId,\n+                    command.getClass());\n+            try {\n+                DatagramSocket socket = clientSocket.get();\n+                switch (channelId) {\n+                    case MODE_CHANNEL:\n+                        handleModeCommand(socket, command);\n+                        break;\n+                    case POWER_CHANNEL:\n+                        device.setDevicePower(socket, getOnOff(command));\n+                        break;\n+                    case TURBO_CHANNEL:\n+                        device.setDeviceTurbo(socket, getOnOff(command));\n+                        break;\n+                    case LIGHT_CHANNEL:\n+                        device.setDeviceLight(socket, getOnOff(command));\n+                        break;\n+                    case TEMP_CHANNEL:\n+                        // Set value, read back effective one and update channel\n+                        // e.g. 22.5C will result in 22.0, because the AC doesn't support half-steps for C\n+                        device.setDeviceTempSet(socket, convertTemp(command));\n+                        break;\n+                    case SWINGUD_CHANNEL:\n+                        device.setDeviceSwingUpDown(socket, getNumber(command));\n+                        break;\n+                    case SWINGLR_CHANNEL:\n+                        device.setDeviceSwingLeftRight(socket, getNumber(command));\n+                        break;\n+                    case WINDSPEED_CHANNEL:\n+                        device.setDeviceWindspeed(socket, getNumber(command));\n+                        break;\n+                    case QUIET_CHANNEL:\n+                        handleQuietCommand(socket, command);\n+                        break;\n+                    case AIR_CHANNEL:\n+                        device.setDeviceAir(socket, getOnOff(command));\n+                        break;\n+                    case DRY_CHANNEL:\n+                        device.setDeviceDry(socket, getOnOff(command));\n+                        break;\n+                    case HEALTH_CHANNEL:\n+                        device.setDeviceHealth(socket, getOnOff(command));\n+                        break;\n+                    case PWRSAV_CHANNEL:\n+                        device.setDevicePwrSaving(socket, getOnOff(command));\n+                        break;\n+                }\n+\n+                // force refresh on next status refresh cycle\n+                forceRefresh = true;\n+            } catch (GreeException e) {\n+                String message = logInfo(\"command.exception\", command, channelId) + \": \" + e.getMessage();\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, message);\n+            } catch (IllegalArgumentException e) {\n+                logInfo(\"command.invarg\", command, channelId);\n+            } catch (RuntimeException e) {\n+                logger.warn(\"{}: {}\", thingId, messages.get(\"command.exception\", command, channelId), e);\n+            }\n+        }\n+    }\n+\n+    private void handleModeCommand(DatagramSocket socket, Command command) throws GreeException {\n+        int mode = -1;\n+        String modeStr = \"\";\n+        boolean isNumber = false;\n+        if (command instanceof DecimalType) {\n+            // backward compatibility when channel was Number\n+            mode = ((DecimalType) command).intValue();\n+        } else if (command instanceof OnOffType) {\n+            // Switch\n+            logger.debug(\"{}: Send Power-{}\", thingId, command);\n+            device.setDevicePower(socket, getOnOff(command));\n+        } else /* String */ {\n+            modeStr = command.toString().toLowerCase();\n+            switch (modeStr) {\n+                case MODE_AUTO:\n+                    mode = GREE_MODE_AUTO;\n+                    break;\n+                case MODE_COOL:\n+                    mode = GREE_MODE_COOL;\n+                    break;\n+                case MODE_HEAT:\n+                    mode = GREE_MODE_HEAT;\n+                    break;\n+                case MODE_DRY:\n+                    mode = GREE_MODE_DRY;\n+                    break;\n+                case MODE_FAN:\n+                case MODE_FAN2:\n+                    mode = GREE_MODE_FAN;\n+                    break;\n+                case MODE_ECO:\n+                    // power saving will be set after the uinit was turned on\n+                    mode = GREE_MODE_COOL;\n+                    break;\n+                case MODE_ON:\n+                case MODE_OFF:\n+                    logger.debug(\"{}: Turn unit {}\", thingId, modeStr);\n+                    device.setDevicePower(socket, modeStr.equals(MODE_ON) ? 1 : 0);\n+                    return;\n+                default:\n+                    // fallback: mode number, pass transparent\n+                    // if string is not parsable parseInt() throws an exception\n+                    mode = Integer.parseInt(modeStr);\n+                    isNumber = true;\n+                    break;\n+            }\n+            logger.debug(\"{}: Mode {} mapped to {}\", thingId, modeStr, mode);\n+        }\n+\n+        if (mode == -1) {\n+            throw new IllegalArgumentException(\"Invalid Mode selection\");\n+        }\n+\n+        // Turn on the unit if currently off\n+        if (!isNumber && (device.getIntStatusVal(GREE_PROP_POWER) == 0)) {\n+            logger.debug(\"{}: Send Auto-ON for mode {}\", thingId, mode);\n+            device.setDevicePower(socket, 1);\n+        }\n+\n+        // Select mode\n+        logger.debug(\"{}: Select mode {}\", thingId, mode);\n+        device.setDeviceMode(socket, mode);\n+\n+        // Check for secondary action\n+        switch (modeStr) {\n+            case MODE_ECO:\n+                // Turn on power saving for eco mode\n+                logger.debug(\"{}: Turn on Power-Saving\", thingId);\n+                device.setDevicePwrSaving(socket, 1);\n+                break;\n+        }\n+    }\n+\n+    private void handleQuietCommand(DatagramSocket socket, Command command) throws GreeException {\n+        int mode = -1;\n+        if (command instanceof DecimalType) {\n+            mode = ((DecimalType) command).intValue();\n+        } else if (command instanceof StringType) {\n+            switch (command.toString().toLowerCase()) {\n+                case QUIET_OFF:\n+                    mode = GREE_QUIET_OFF;\n+                    break;\n+                case QUIET_AUTO:\n+                    mode = GREE_QUIET_AUTO;\n+                    break;\n+                case QUIET_QUIET:\n+                    mode = GREE_QUIET_QUIET;\n+                    break;\n+            }\n+        }\n+        if (mode != -1) {\n+            device.setQuietMode(socket, mode);\n+        } else {\n+            throw new IllegalArgumentException(\"Invalid QuietType\");\n+        }\n+    }\n+\n+    private int getOnOff(Command command) {\n+        if (command instanceof OnOffType) {\n+            return command == OnOffType.ON ? 1 : 0;\n+        }\n+        if (command instanceof DecimalType) {\n+            int value = ((DecimalType) command).intValue();\n+            if ((value == 0) || (value == 1)) {\n+                return value;\n+            }\n+        }\n+        throw new IllegalArgumentException(\"Invalid OnOffType\");\n+    }\n+\n+    private int getNumber(Command command) {\n+        if (command instanceof DecimalType) {\n+            return ((DecimalType) command).intValue();\n+        }\n+        throw new IllegalArgumentException(\"Invalid Number type\");\n+    }\n+\n+    private QuantityType<?> convertTemp(Command command) {\n+        if (command instanceof DecimalType) {\n+            // The Number alone doesn't specify the temp unit\n+            // for this get current setting from the A/C unit\n+            int unit = device.getIntStatusVal(GREE_PROP_TEMPUNIT);\n+            return toQuantityType((DecimalType) command, DIGITS_TEMP,\n+                    unit == TEMP_UNIT_CELSIUS ? SIUnits.CELSIUS : ImperialUnits.FAHRENHEIT);\n+        }\n+        if (command instanceof QuantityType) {\n+            return (QuantityType<?>) command;\n+        }\n+        throw new IllegalArgumentException(\"Invalud Temp type\");\n+    }\n+\n+    private void startAutomaticRefresh() {\n+        Runnable refresher = () -> {\n+            try {\n+                // safeguard for multiple REFRESH commands\n+                if (isMinimumRefreshTimeExceeded()) {\n+                    // Get the current status from the Airconditioner\n+\n+                    if (getThing().getStatus() == ThingStatus.OFFLINE) {\n+                        initializeThing();\n+                        return;\n+                    }\n+\n+                    if (clientSocket.isPresent()) {\n+                        device.getDeviceStatus(clientSocket.get());\n+                        logger.debug(\"{}: Executing automatic update of values\", thingId);\n+                        List<Channel> channels = getThing().getChannels();\n+                        for (Channel channel : channels) {\n+                            publishChannel(channel.getUID());\n+                        }\n+                    }\n+                }\n+            } catch (GreeException e) {\n+                String subcode = \"\";\n+                if (e.getCause() != null) {\n+                    subcode = \" (\" + e.getCause().getMessage() + \")\";\n+                }\n+                String message = messages.get(\"update.exception\", e.getMessage() + subcode);\n+                if (getThing().getStatus() == ThingStatus.OFFLINE) {\n+                    logger.debug(\"{}: Thing still OFFLINE ({})\", thingId, message);\n+                } else {\n+                    if (!e.isTimeout()) {\n+                        logger.info(\"{}: {}\", thingId, message);\n+                    } else {\n+                        logger.debug(\"{}: {}\", thingId, message);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, message);\n+                }\n+            } catch (RuntimeException e) {\n+                String message = messages.get(\"update.exception\", \"RuntimeException\");\n+                logger.warn(\"{}: {}\", thingId, message, e);\n+            }\n+        };\n+\n+        if (refreshTask == null) {\n+            refreshTask = scheduler.scheduleWithFixedDelay(refresher, 0, REFRESH_INTERVAL_SEC, TimeUnit.SECONDS);\n+            logger.debug(\"{}: Automatic refresh started ({} second interval)\", thingId, config.refresh);\n+        }\n+    }\n+\n+    private boolean isMinimumRefreshTimeExceeded() {\n+        long currentTime = Instant.now().toEpochMilli();\n+        long timeSinceLastRefresh = currentTime - lastRefreshTime;\n+        if (!forceRefresh && (timeSinceLastRefresh < config.refresh * 1000)) {\n+            return false;\n+        }\n+        lastRefreshTime = currentTime;\n+        return true;\n+    }\n+\n+    private void publishChannel(ChannelUID channelUID) {\n+        String channelID = channelUID.getId();\n+        try {\n+            State state = null;\n+            switch (channelUID.getIdWithoutGroup()) {\n+                case POWER_CHANNEL:\n+                    state = updateOnOff(GREE_PROP_POWER);\n+                    break;\n+                case MODE_CHANNEL:\n+                    state = updateMode();\n+                    break;\n+                case TURBO_CHANNEL:\n+                    state = updateOnOff(GREE_PROP_TURBO);\n+                    break;\n+                case LIGHT_CHANNEL:\n+                    state = updateOnOff(GREE_PROP_LIGHT);\n+                    break;\n+                case TEMP_CHANNEL:\n+                    state = updateTemp();\n+                    break;\n+                case SWINGUD_CHANNEL:\n+                    state = updateNumber(GREE_PROP_SWINGUPDOWN);\n+                    break;\n+                case SWINGLR_CHANNEL:\n+                    state = updateNumber(GREE_PROP_SWINGLEFTRIGHT);\n+                    break;\n+                case WINDSPEED_CHANNEL:\n+                    state = updateNumber(GREE_PROP_WINDSPEED);\n+                    break;\n+                case QUIET_CHANNEL:\n+                    state = updateQuiet();\n+                    break;\n+                case AIR_CHANNEL:\n+                    state = updateOnOff(GREE_PROP_AIR);\n+                    break;\n+                case DRY_CHANNEL:\n+                    state = updateOnOff(GREE_PROP_DRY);\n+                    break;\n+                case HEALTH_CHANNEL:\n+                    state = updateOnOff(GREE_PROP_HEALTH);\n+                    break;\n+                case PWRSAV_CHANNEL:\n+                    state = updateOnOff(GREE_PROP_PWR_SAVING);\n+                    break;\n+            }\n+            if (state != null) {\n+                logger.debug(\"{}: Updating channel {} : {}\", thingId, channelID, state);\n+                updateState(channelID, state);\n+            }\n+        } catch (GreeException e) {\n+            logger.info(\"{}: {}\", thingId, messages.get(\"channel.exception\", channelID, e.getMessage()));\n+        } catch (RuntimeException e) {\n+            logger.warn(\"{}: {}\", thingId, messages.get(\"channel.exception\", \"RuntimeException\"), e);\n+        }\n+    }\n+\n+    private @Nullable State updateOnOff(final String valueName) throws GreeException {\n+        if (device.hasStatusValChanged(valueName)) {\n+            return device.getIntStatusVal(valueName) == 1 ? OnOffType.ON : OnOffType.OFF;\n+        }\n+        return null;\n+    }\n+\n+    private @Nullable State updateNumber(final String valueName) throws GreeException {\n+        if (device.hasStatusValChanged(valueName)) {\n+            return new DecimalType(device.getIntStatusVal(valueName));\n+        }\n+        return null;\n+    }\n+\n+    private @Nullable State updateMode() throws GreeException {\n+        if (device.hasStatusValChanged(GREE_PROP_MODE)) {\n+            int mode = device.getIntStatusVal(GREE_PROP_MODE);\n+            String modeStr = \"\";\n+            switch (mode) {\n+                case GREE_MODE_AUTO:\n+                    modeStr = MODE_AUTO;\n+                    break;\n+                case GREE_MODE_COOL:\n+                    boolean powerSave = device.getIntStatusVal(GREE_PROP_PWR_SAVING) == 1;\n+                    modeStr = !powerSave ? MODE_COOL : MODE_ECO;\n+                    break;\n+                case GREE_MODE_DRY:\n+                    modeStr = MODE_DRY;\n+                    break;\n+                case GREE_MODE_FAN:\n+                    modeStr = MODE_FAN;\n+                    break;\n+                case GREE_MODE_HEAT:\n+                    modeStr = MODE_HEAT;\n+                    break;\n+                default:\n+                    modeStr = String.valueOf(mode);\n+\n+            }\n+            if (!modeStr.isEmpty()) {\n+                logger.debug(\"{}: Updading mode channel with {}/{}\", thingId, mode, modeStr);\n+                return new StringType(modeStr);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private @Nullable State updateQuiet() throws GreeException {\n+        if (device.hasStatusValChanged(GREE_PROP_QUIET)) {\n+            switch (device.getIntStatusVal(GREE_PROP_QUIET)) {\n+                case GREE_QUIET_OFF:\n+                    return new StringType(QUIET_OFF);\n+                case GREE_QUIET_AUTO:\n+                    return new StringType(QUIET_AUTO);\n+                case GREE_QUIET_QUIET:\n+                    return new StringType(QUIET_QUIET);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private @Nullable State updateTemp() throws GreeException {\n+        if (device.hasStatusValChanged(GREE_PROP_SETTEMP) || device.hasStatusValChanged(GREE_PROP_TEMPUNIT)) {\n+            int unit = device.getIntStatusVal(GREE_PROP_TEMPUNIT);\n+            return toQuantityType(device.getIntStatusVal(GREE_PROP_SETTEMP), DIGITS_TEMP,\n+                    unit == TEMP_UNIT_CELSIUS ? SIUnits.CELSIUS : ImperialUnits.FAHRENHEIT);\n+        }\n+        return null;\n+    }\n+\n+    private String logInfo(String msgKey, Object... arg) {\n+        String message = messages.get(msgKey, arg);\n+        logger.info(\"{}: {}\", thingId, message);\n+        return message;\n+    }\n+\n+    public static QuantityType<?> toQuantityType(Number value, int digits, Unit<?> unit) {\n+        BigDecimal bd = new BigDecimal(value.doubleValue());\n+        return new QuantityType<>(bd.setScale(digits, BigDecimal.ROUND_HALF_EVEN), unit);\n+    }\n+\n+    private void stopRefrestTask() {\n+        forceRefresh = false;\n+        if (refreshTask == null) {\n+            return;\n+        }\n+        synchronized (refreshTask) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c171d858e3aa58b6de4206ed8ea96ebcc3514bb"}, "originalPosition": 531}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDUxNjYzNg==", "bodyText": "No harm in cancelling something that is already cancelled.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if ((task != null) && !task.isCancelled()) {\n          \n          \n            \n                        if (task != null) {", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r444516636", "createdAt": "2020-06-23T21:23:11Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeHandler.java", "diffHunk": "@@ -0,0 +1,549 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.net.DatagramSocket;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.ImperialUnits;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.gree.internal.GreeConfiguration;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.discovery.GreeDeviceFinder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link GreeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(GreeHandler.class);\n+    private final GreeTranslationProvider messages;\n+    private GreeConfiguration config = new GreeConfiguration();\n+    private GreeDeviceFinder deviceFinder = new GreeDeviceFinder();\n+    private GreeAirDevice device = new GreeAirDevice();\n+    private Optional<DatagramSocket> clientSocket = Optional.empty();\n+    private final String thingId;\n+    private boolean forceRefresh = false;\n+\n+    private @Nullable ScheduledFuture<?> refreshTask;\n+    private long lastRefreshTime = 0;\n+\n+    public GreeHandler(Thing thing, GreeTranslationProvider messages, GreeDeviceFinder deviceFinder) {\n+        super(thing);\n+        this.messages = messages;\n+        this.deviceFinder = deviceFinder;\n+        String label = getThing().getLabel();\n+        this.thingId = label != null ? label : getThing().getUID().getId();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(GreeConfiguration.class);\n+        if (config.ipAddress.isEmpty() || (config.refresh < 0)) {\n+            String message = messages.get(\"thinginit.invconf\");\n+            logger.warn(\"{}: {}\", thingId, message);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, message);\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        // Start the automatic refresh cycles\n+        startAutomaticRefresh();\n+        scheduler.execute(this::initializeThing);\n+    }\n+\n+    private void initializeThing() {\n+        String message = \"\";\n+        try {\n+            if (!clientSocket.isPresent()) {\n+                clientSocket = Optional.of(new DatagramSocket());\n+                clientSocket.get().setSoTimeout(DATAGRAM_SOCKET_TIMEOUT);\n+            }\n+            // Find the GREE device\n+            deviceFinder.scan(clientSocket.get(), config.ipAddress, false);\n+            GreeAirDevice newDevice = deviceFinder.getDeviceByIPAddress(config.ipAddress);\n+            if (newDevice != null) {\n+                // Ok, our device responded, now let's Bind with it\n+                device = newDevice;\n+                device.bindWithDevice(clientSocket.get());\n+                if (device.getIsBound()) {\n+                    updateStatus(ThingStatus.ONLINE);\n+                    return;\n+                }\n+            }\n+\n+            message = messages.get(\"thinginit.failed\");\n+            logger.info(\"{}: {}\", thingId, message);\n+        } catch (GreeException e) {\n+            logger.info(\"{}: {}\", thingId, messages.get(\"thinginit.exception\", e.getMessage()));\n+        } catch (IOException e) {\n+            logger.warn(\"{}: {}\", thingId, messages.get(\"thinginit.exception\", \"I/O Error\"), e);\n+        } catch (RuntimeException e) {\n+            logger.warn(\"{}: {}\", thingId, messages.get(\"thinginit.exception\", \"RuntimeException\"), e);\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, message);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            // The thing is updated by the scheduled automatic refresh so do nothing here.\n+        } else {\n+            logger.debug(\"{}: Issue command {}\u00a0to channe {}\", thingId, command, channelUID.getIdWithoutGroup());\n+            String channelId = channelUID.getIdWithoutGroup();\n+            logger.debug(\"{}: Handle command {} for channel {}, command class {}\", thingId, command, channelId,\n+                    command.getClass());\n+            try {\n+                DatagramSocket socket = clientSocket.get();\n+                switch (channelId) {\n+                    case MODE_CHANNEL:\n+                        handleModeCommand(socket, command);\n+                        break;\n+                    case POWER_CHANNEL:\n+                        device.setDevicePower(socket, getOnOff(command));\n+                        break;\n+                    case TURBO_CHANNEL:\n+                        device.setDeviceTurbo(socket, getOnOff(command));\n+                        break;\n+                    case LIGHT_CHANNEL:\n+                        device.setDeviceLight(socket, getOnOff(command));\n+                        break;\n+                    case TEMP_CHANNEL:\n+                        // Set value, read back effective one and update channel\n+                        // e.g. 22.5C will result in 22.0, because the AC doesn't support half-steps for C\n+                        device.setDeviceTempSet(socket, convertTemp(command));\n+                        break;\n+                    case SWINGUD_CHANNEL:\n+                        device.setDeviceSwingUpDown(socket, getNumber(command));\n+                        break;\n+                    case SWINGLR_CHANNEL:\n+                        device.setDeviceSwingLeftRight(socket, getNumber(command));\n+                        break;\n+                    case WINDSPEED_CHANNEL:\n+                        device.setDeviceWindspeed(socket, getNumber(command));\n+                        break;\n+                    case QUIET_CHANNEL:\n+                        handleQuietCommand(socket, command);\n+                        break;\n+                    case AIR_CHANNEL:\n+                        device.setDeviceAir(socket, getOnOff(command));\n+                        break;\n+                    case DRY_CHANNEL:\n+                        device.setDeviceDry(socket, getOnOff(command));\n+                        break;\n+                    case HEALTH_CHANNEL:\n+                        device.setDeviceHealth(socket, getOnOff(command));\n+                        break;\n+                    case PWRSAV_CHANNEL:\n+                        device.setDevicePwrSaving(socket, getOnOff(command));\n+                        break;\n+                }\n+\n+                // force refresh on next status refresh cycle\n+                forceRefresh = true;\n+            } catch (GreeException e) {\n+                String message = logInfo(\"command.exception\", command, channelId) + \": \" + e.getMessage();\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, message);\n+            } catch (IllegalArgumentException e) {\n+                logInfo(\"command.invarg\", command, channelId);\n+            } catch (RuntimeException e) {\n+                logger.warn(\"{}: {}\", thingId, messages.get(\"command.exception\", command, channelId), e);\n+            }\n+        }\n+    }\n+\n+    private void handleModeCommand(DatagramSocket socket, Command command) throws GreeException {\n+        int mode = -1;\n+        String modeStr = \"\";\n+        boolean isNumber = false;\n+        if (command instanceof DecimalType) {\n+            // backward compatibility when channel was Number\n+            mode = ((DecimalType) command).intValue();\n+        } else if (command instanceof OnOffType) {\n+            // Switch\n+            logger.debug(\"{}: Send Power-{}\", thingId, command);\n+            device.setDevicePower(socket, getOnOff(command));\n+        } else /* String */ {\n+            modeStr = command.toString().toLowerCase();\n+            switch (modeStr) {\n+                case MODE_AUTO:\n+                    mode = GREE_MODE_AUTO;\n+                    break;\n+                case MODE_COOL:\n+                    mode = GREE_MODE_COOL;\n+                    break;\n+                case MODE_HEAT:\n+                    mode = GREE_MODE_HEAT;\n+                    break;\n+                case MODE_DRY:\n+                    mode = GREE_MODE_DRY;\n+                    break;\n+                case MODE_FAN:\n+                case MODE_FAN2:\n+                    mode = GREE_MODE_FAN;\n+                    break;\n+                case MODE_ECO:\n+                    // power saving will be set after the uinit was turned on\n+                    mode = GREE_MODE_COOL;\n+                    break;\n+                case MODE_ON:\n+                case MODE_OFF:\n+                    logger.debug(\"{}: Turn unit {}\", thingId, modeStr);\n+                    device.setDevicePower(socket, modeStr.equals(MODE_ON) ? 1 : 0);\n+                    return;\n+                default:\n+                    // fallback: mode number, pass transparent\n+                    // if string is not parsable parseInt() throws an exception\n+                    mode = Integer.parseInt(modeStr);\n+                    isNumber = true;\n+                    break;\n+            }\n+            logger.debug(\"{}: Mode {} mapped to {}\", thingId, modeStr, mode);\n+        }\n+\n+        if (mode == -1) {\n+            throw new IllegalArgumentException(\"Invalid Mode selection\");\n+        }\n+\n+        // Turn on the unit if currently off\n+        if (!isNumber && (device.getIntStatusVal(GREE_PROP_POWER) == 0)) {\n+            logger.debug(\"{}: Send Auto-ON for mode {}\", thingId, mode);\n+            device.setDevicePower(socket, 1);\n+        }\n+\n+        // Select mode\n+        logger.debug(\"{}: Select mode {}\", thingId, mode);\n+        device.setDeviceMode(socket, mode);\n+\n+        // Check for secondary action\n+        switch (modeStr) {\n+            case MODE_ECO:\n+                // Turn on power saving for eco mode\n+                logger.debug(\"{}: Turn on Power-Saving\", thingId);\n+                device.setDevicePwrSaving(socket, 1);\n+                break;\n+        }\n+    }\n+\n+    private void handleQuietCommand(DatagramSocket socket, Command command) throws GreeException {\n+        int mode = -1;\n+        if (command instanceof DecimalType) {\n+            mode = ((DecimalType) command).intValue();\n+        } else if (command instanceof StringType) {\n+            switch (command.toString().toLowerCase()) {\n+                case QUIET_OFF:\n+                    mode = GREE_QUIET_OFF;\n+                    break;\n+                case QUIET_AUTO:\n+                    mode = GREE_QUIET_AUTO;\n+                    break;\n+                case QUIET_QUIET:\n+                    mode = GREE_QUIET_QUIET;\n+                    break;\n+            }\n+        }\n+        if (mode != -1) {\n+            device.setQuietMode(socket, mode);\n+        } else {\n+            throw new IllegalArgumentException(\"Invalid QuietType\");\n+        }\n+    }\n+\n+    private int getOnOff(Command command) {\n+        if (command instanceof OnOffType) {\n+            return command == OnOffType.ON ? 1 : 0;\n+        }\n+        if (command instanceof DecimalType) {\n+            int value = ((DecimalType) command).intValue();\n+            if ((value == 0) || (value == 1)) {\n+                return value;\n+            }\n+        }\n+        throw new IllegalArgumentException(\"Invalid OnOffType\");\n+    }\n+\n+    private int getNumber(Command command) {\n+        if (command instanceof DecimalType) {\n+            return ((DecimalType) command).intValue();\n+        }\n+        throw new IllegalArgumentException(\"Invalid Number type\");\n+    }\n+\n+    private QuantityType<?> convertTemp(Command command) {\n+        if (command instanceof DecimalType) {\n+            // The Number alone doesn't specify the temp unit\n+            // for this get current setting from the A/C unit\n+            int unit = device.getIntStatusVal(GREE_PROP_TEMPUNIT);\n+            return toQuantityType((DecimalType) command, DIGITS_TEMP,\n+                    unit == TEMP_UNIT_CELSIUS ? SIUnits.CELSIUS : ImperialUnits.FAHRENHEIT);\n+        }\n+        if (command instanceof QuantityType) {\n+            return (QuantityType<?>) command;\n+        }\n+        throw new IllegalArgumentException(\"Invalud Temp type\");\n+    }\n+\n+    private void startAutomaticRefresh() {\n+        Runnable refresher = () -> {\n+            try {\n+                // safeguard for multiple REFRESH commands\n+                if (isMinimumRefreshTimeExceeded()) {\n+                    // Get the current status from the Airconditioner\n+\n+                    if (getThing().getStatus() == ThingStatus.OFFLINE) {\n+                        initializeThing();\n+                        return;\n+                    }\n+\n+                    if (clientSocket.isPresent()) {\n+                        device.getDeviceStatus(clientSocket.get());\n+                        logger.debug(\"{}: Executing automatic update of values\", thingId);\n+                        List<Channel> channels = getThing().getChannels();\n+                        for (Channel channel : channels) {\n+                            publishChannel(channel.getUID());\n+                        }\n+                    }\n+                }\n+            } catch (GreeException e) {\n+                String subcode = \"\";\n+                if (e.getCause() != null) {\n+                    subcode = \" (\" + e.getCause().getMessage() + \")\";\n+                }\n+                String message = messages.get(\"update.exception\", e.getMessage() + subcode);\n+                if (getThing().getStatus() == ThingStatus.OFFLINE) {\n+                    logger.debug(\"{}: Thing still OFFLINE ({})\", thingId, message);\n+                } else {\n+                    if (!e.isTimeout()) {\n+                        logger.info(\"{}: {}\", thingId, message);\n+                    } else {\n+                        logger.debug(\"{}: {}\", thingId, message);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, message);\n+                }\n+            } catch (RuntimeException e) {\n+                String message = messages.get(\"update.exception\", \"RuntimeException\");\n+                logger.warn(\"{}: {}\", thingId, message, e);\n+            }\n+        };\n+\n+        if (refreshTask == null) {\n+            refreshTask = scheduler.scheduleWithFixedDelay(refresher, 0, REFRESH_INTERVAL_SEC, TimeUnit.SECONDS);\n+            logger.debug(\"{}: Automatic refresh started ({} second interval)\", thingId, config.refresh);\n+        }\n+    }\n+\n+    private boolean isMinimumRefreshTimeExceeded() {\n+        long currentTime = Instant.now().toEpochMilli();\n+        long timeSinceLastRefresh = currentTime - lastRefreshTime;\n+        if (!forceRefresh && (timeSinceLastRefresh < config.refresh * 1000)) {\n+            return false;\n+        }\n+        lastRefreshTime = currentTime;\n+        return true;\n+    }\n+\n+    private void publishChannel(ChannelUID channelUID) {\n+        String channelID = channelUID.getId();\n+        try {\n+            State state = null;\n+            switch (channelUID.getIdWithoutGroup()) {\n+                case POWER_CHANNEL:\n+                    state = updateOnOff(GREE_PROP_POWER);\n+                    break;\n+                case MODE_CHANNEL:\n+                    state = updateMode();\n+                    break;\n+                case TURBO_CHANNEL:\n+                    state = updateOnOff(GREE_PROP_TURBO);\n+                    break;\n+                case LIGHT_CHANNEL:\n+                    state = updateOnOff(GREE_PROP_LIGHT);\n+                    break;\n+                case TEMP_CHANNEL:\n+                    state = updateTemp();\n+                    break;\n+                case SWINGUD_CHANNEL:\n+                    state = updateNumber(GREE_PROP_SWINGUPDOWN);\n+                    break;\n+                case SWINGLR_CHANNEL:\n+                    state = updateNumber(GREE_PROP_SWINGLEFTRIGHT);\n+                    break;\n+                case WINDSPEED_CHANNEL:\n+                    state = updateNumber(GREE_PROP_WINDSPEED);\n+                    break;\n+                case QUIET_CHANNEL:\n+                    state = updateQuiet();\n+                    break;\n+                case AIR_CHANNEL:\n+                    state = updateOnOff(GREE_PROP_AIR);\n+                    break;\n+                case DRY_CHANNEL:\n+                    state = updateOnOff(GREE_PROP_DRY);\n+                    break;\n+                case HEALTH_CHANNEL:\n+                    state = updateOnOff(GREE_PROP_HEALTH);\n+                    break;\n+                case PWRSAV_CHANNEL:\n+                    state = updateOnOff(GREE_PROP_PWR_SAVING);\n+                    break;\n+            }\n+            if (state != null) {\n+                logger.debug(\"{}: Updating channel {} : {}\", thingId, channelID, state);\n+                updateState(channelID, state);\n+            }\n+        } catch (GreeException e) {\n+            logger.info(\"{}: {}\", thingId, messages.get(\"channel.exception\", channelID, e.getMessage()));\n+        } catch (RuntimeException e) {\n+            logger.warn(\"{}: {}\", thingId, messages.get(\"channel.exception\", \"RuntimeException\"), e);\n+        }\n+    }\n+\n+    private @Nullable State updateOnOff(final String valueName) throws GreeException {\n+        if (device.hasStatusValChanged(valueName)) {\n+            return device.getIntStatusVal(valueName) == 1 ? OnOffType.ON : OnOffType.OFF;\n+        }\n+        return null;\n+    }\n+\n+    private @Nullable State updateNumber(final String valueName) throws GreeException {\n+        if (device.hasStatusValChanged(valueName)) {\n+            return new DecimalType(device.getIntStatusVal(valueName));\n+        }\n+        return null;\n+    }\n+\n+    private @Nullable State updateMode() throws GreeException {\n+        if (device.hasStatusValChanged(GREE_PROP_MODE)) {\n+            int mode = device.getIntStatusVal(GREE_PROP_MODE);\n+            String modeStr = \"\";\n+            switch (mode) {\n+                case GREE_MODE_AUTO:\n+                    modeStr = MODE_AUTO;\n+                    break;\n+                case GREE_MODE_COOL:\n+                    boolean powerSave = device.getIntStatusVal(GREE_PROP_PWR_SAVING) == 1;\n+                    modeStr = !powerSave ? MODE_COOL : MODE_ECO;\n+                    break;\n+                case GREE_MODE_DRY:\n+                    modeStr = MODE_DRY;\n+                    break;\n+                case GREE_MODE_FAN:\n+                    modeStr = MODE_FAN;\n+                    break;\n+                case GREE_MODE_HEAT:\n+                    modeStr = MODE_HEAT;\n+                    break;\n+                default:\n+                    modeStr = String.valueOf(mode);\n+\n+            }\n+            if (!modeStr.isEmpty()) {\n+                logger.debug(\"{}: Updading mode channel with {}/{}\", thingId, mode, modeStr);\n+                return new StringType(modeStr);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private @Nullable State updateQuiet() throws GreeException {\n+        if (device.hasStatusValChanged(GREE_PROP_QUIET)) {\n+            switch (device.getIntStatusVal(GREE_PROP_QUIET)) {\n+                case GREE_QUIET_OFF:\n+                    return new StringType(QUIET_OFF);\n+                case GREE_QUIET_AUTO:\n+                    return new StringType(QUIET_AUTO);\n+                case GREE_QUIET_QUIET:\n+                    return new StringType(QUIET_QUIET);\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private @Nullable State updateTemp() throws GreeException {\n+        if (device.hasStatusValChanged(GREE_PROP_SETTEMP) || device.hasStatusValChanged(GREE_PROP_TEMPUNIT)) {\n+            int unit = device.getIntStatusVal(GREE_PROP_TEMPUNIT);\n+            return toQuantityType(device.getIntStatusVal(GREE_PROP_SETTEMP), DIGITS_TEMP,\n+                    unit == TEMP_UNIT_CELSIUS ? SIUnits.CELSIUS : ImperialUnits.FAHRENHEIT);\n+        }\n+        return null;\n+    }\n+\n+    private String logInfo(String msgKey, Object... arg) {\n+        String message = messages.get(msgKey, arg);\n+        logger.info(\"{}: {}\", thingId, message);\n+        return message;\n+    }\n+\n+    public static QuantityType<?> toQuantityType(Number value, int digits, Unit<?> unit) {\n+        BigDecimal bd = new BigDecimal(value.doubleValue());\n+        return new QuantityType<>(bd.setScale(digits, BigDecimal.ROUND_HALF_EVEN), unit);\n+    }\n+\n+    private void stopRefrestTask() {\n+        forceRefresh = false;\n+        if (refreshTask == null) {\n+            return;\n+        }\n+        synchronized (refreshTask) {\n+            ScheduledFuture<?> task = refreshTask;\n+            if ((task != null) && !task.isCancelled()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c171d858e3aa58b6de4206ed8ea96ebcc3514bb"}, "originalPosition": 533}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fdde046cbff4b752165c1de442adb4daad23afca", "author": {"user": {"login": "markus7017", "name": "Markus Michels"}}, "url": "https://github.com/openhab/openhab-addons/commit/fdde046cbff4b752165c1de442adb4daad23afca", "committedDate": "2020-06-24T21:59:01Z", "message": "commit\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b33acc6856c4abf4fba3646107029414a373166c", "author": {"user": {"login": "markus7017", "name": "Markus Michels"}}, "url": "https://github.com/openhab/openhab-addons/commit/b33acc6856c4abf4fba3646107029414a373166c", "committedDate": "2020-06-24T21:59:14Z", "message": "gree added\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cad9ffd82bfe4cb49b9555543307fb9c260d8bc8", "author": {"user": {"login": "markus7017", "name": "Markus Michels"}}, "url": "https://github.com/openhab/openhab-addons/commit/cad9ffd82bfe4cb49b9555543307fb9c260d8bc8", "committedDate": "2020-06-24T22:07:26Z", "message": "ordering fixed\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM3MDM3MTI1", "url": "https://github.com/openhab/openhab-addons/pull/7504#pullrequestreview-437037125", "createdAt": "2020-06-24T22:00:46Z", "commit": {"oid": "b33acc6856c4abf4fba3646107029414a373166c"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQyMjowNToyMVrOGoku8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQyMjoyOTowMlrOGolRKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE5ODA2Nw==", "bodyText": "You should make sure that this returns a future so you can cancel it on dispose.", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r445198067", "createdAt": "2020-06-24T22:05:21Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/src/main/java/org/openhab/binding/gree/internal/handler/GreeHandler.java", "diffHunk": "@@ -0,0 +1,546 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.gree.internal.handler;\n+\n+import static org.openhab.binding.gree.internal.GreeBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.math.BigDecimal;\n+import java.net.DatagramSocket;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.measure.Unit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.library.unit.ImperialUnits;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.openhab.binding.gree.internal.GreeConfiguration;\n+import org.openhab.binding.gree.internal.GreeException;\n+import org.openhab.binding.gree.internal.GreeTranslationProvider;\n+import org.openhab.binding.gree.internal.discovery.GreeDeviceFinder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link GreeHandler} is responsible for handling commands, which are sent to one of the channels.\n+ *\n+ * @author John Cunha - Initial contribution\n+ * @author Markus Michels - Refactoring, adapted to OH 2.5x\n+ */\n+@NonNullByDefault\n+public class GreeHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(GreeHandler.class);\n+    private final GreeTranslationProvider messages;\n+    private final GreeDeviceFinder deviceFinder;\n+    private final String thingId;\n+    private GreeConfiguration config = new GreeConfiguration();\n+    private GreeAirDevice device = new GreeAirDevice();\n+    private Optional<DatagramSocket> clientSocket = Optional.empty();\n+    private boolean forceRefresh = false;\n+\n+    private @Nullable ScheduledFuture<?> refreshTask;\n+    private long lastRefreshTime = 0;\n+\n+    public GreeHandler(Thing thing, GreeTranslationProvider messages, GreeDeviceFinder deviceFinder) {\n+        super(thing);\n+        this.messages = messages;\n+        this.deviceFinder = deviceFinder;\n+        this.thingId = getThing().getUID().getId();\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(GreeConfiguration.class);\n+        if (config.ipAddress.isEmpty() || (config.refresh < 0)) {\n+            String message = messages.get(\"thinginit.invconf\");\n+            logger.warn(\"{}: {}\", thingId, message);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, message);\n+        }\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        // Start the automatic refresh cycles\n+        startAutomaticRefresh();\n+        scheduler.execute(this::initializeThing);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b33acc6856c4abf4fba3646107029414a373166c"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTIwNjgyNw==", "bodyText": "This shouldn't have been moved...", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r445206827", "createdAt": "2020-06-24T22:29:02Z", "author": {"login": "cpmeister"}, "path": "bundles/pom.xml", "diffHunk": "@@ -100,9 +100,10 @@\n     <module>org.openhab.binding.fsinternetradio</module>\n     <module>org.openhab.binding.ftpupload</module>\n     <module>org.openhab.binding.gardena</module>\n-    <module>org.openhab.binding.goecharger</module>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cad9ffd82bfe4cb49b9555543307fb9c260d8bc8"}, "originalPosition": 4}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d185fbef94d9672fbb2d5a2b851b0b3445727bab", "author": {"user": {"login": "markus7017", "name": "Markus Michels"}}, "url": "https://github.com/openhab/openhab-addons/commit/d185fbef94d9672fbb2d5a2b851b0b3445727bab", "committedDate": "2020-06-24T22:56:11Z", "message": "order change reverted\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "77a3e2f1a23592c952b0ae4622f7647de3bb4fdd", "author": {"user": {"login": "markus7017", "name": "Markus Michels"}}, "url": "https://github.com/openhab/openhab-addons/commit/77a3e2f1a23592c952b0ae4622f7647de3bb4fdd", "committedDate": "2020-06-25T19:32:44Z", "message": "review change, force status update on init"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d02afd67855da8b4600742a9275b4a37adc694b8", "author": {"user": {"login": "markus7017", "name": "Markus Michels"}}, "url": "https://github.com/openhab/openhab-addons/commit/d02afd67855da8b4600742a9275b4a37adc694b8", "committedDate": "2020-06-25T19:34:46Z", "message": "removed empty line\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "719da78d59f842ee3a1fb190853547aaa63c8e0d", "author": {"user": {"login": "markus7017", "name": "Markus Michels"}}, "url": "https://github.com/openhab/openhab-addons/commit/719da78d59f842ee3a1fb190853547aaa63c8e0d", "committedDate": "2020-06-25T19:33:38Z", "message": "removed empty line\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>"}, "afterCommit": {"oid": "d02afd67855da8b4600742a9275b4a37adc694b8", "author": {"user": {"login": "markus7017", "name": "Markus Michels"}}, "url": "https://github.com/openhab/openhab-addons/commit/d02afd67855da8b4600742a9275b4a37adc694b8", "committedDate": "2020-06-25T19:34:46Z", "message": "removed empty line\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM3ODkyMTI1", "url": "https://github.com/openhab/openhab-addons/pull/7504#pullrequestreview-437892125", "createdAt": "2020-06-25T22:06:26Z", "commit": {"oid": "d02afd67855da8b4600742a9275b4a37adc694b8"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQyMjowNjoyNlrOGpNciQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQyMjoxNzowMFrOGpNsmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTg2NTA5Nw==", "bodyText": "These parameters should have labels.", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r445865097", "createdAt": "2020-06-25T22:06:26Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,154 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"gree\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"airconditioner\">\n+\t\t<label>@text/thing-type.gree.airconditioner.label</label>\n+\t\t<channels>\n+\t\t\t<channel id=\"power\" typeId=\"system.power\" />\n+\t\t\t<channel id=\"mode\" typeId=\"mode\" />\n+\t\t\t<channel id=\"temperature\" typeId=\"temperature\" />\n+\t\t\t<channel id=\"air\" typeId=\"air\" />\n+\t\t\t<channel id=\"dry\" typeId=\"dry\" />\n+\t\t\t<channel id=\"turbo\" typeId=\"turbo\" />\n+\t\t\t<channel id=\"windspeed\" typeId=\"windspeed\" />\n+\t\t\t<channel id=\"quiet\" typeId=\"quiet\" />\n+\t\t\t<channel id=\"swingUpDown\" typeId=\"swingUpDown\" />\n+\t\t\t<channel id=\"swingLeftRight\" typeId=\"swingLeftRight\" />\n+\t\t\t<channel id=\"powersave\" typeId=\"powersave\" />\n+\t\t\t<channel id=\"light\" typeId=\"light\" />\n+\t\t\t<channel id=\"health\" typeId=\"health\" />\n+\t\t</channels>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"ipAddress\" type=\"text\" required=\"true\">\n+\t\t\t\t<context>network-address</context>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"broadcastAddress\" type=\"text\" required=\"false\">\n+\t\t\t\t<context>network-address</context>\n+\t\t\t</parameter>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d02afd67855da8b4600742a9275b4a37adc694b8"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTg2NzQ3Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            An IP broadcast message is sent and every responding units gets added to the Inbox. \n          \n          \n            \n            An IP broadcast message is sent and every responding unit gets added to the Inbox.", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r445867473", "createdAt": "2020-06-25T22:12:20Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/README.md", "diffHunk": "@@ -0,0 +1,147 @@\n+# GREE Binding\n+\n+This binding integrates GREE Air Conditioners.\n+\n+Note: The GREE Air Conditioner must already be setup on the WiFi network and must have a fixed IP Address.\n+\n+## Supported Things\n+\n+This binding supports one Thing type `airconditioner`.\n+\n+## Discovery\n+\n+Once the GREE is on the network (WiFi active) it could be discovery automatically.\n+An IP broadcast message is sent and every responding units gets added to the Inbox. ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d02afd67855da8b4600742a9275b4a37adc694b8"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTg2NzY5NA==", "bodyText": "These sections should be removed.", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r445867694", "createdAt": "2020-06-25T22:12:52Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/README.md", "diffHunk": "@@ -0,0 +1,147 @@\n+# GREE Binding\n+\n+This binding integrates GREE Air Conditioners.\n+\n+Note: The GREE Air Conditioner must already be setup on the WiFi network and must have a fixed IP Address.\n+\n+## Supported Things\n+\n+This binding supports one Thing type `airconditioner`.\n+\n+## Discovery\n+\n+Once the GREE is on the network (WiFi active) it could be discovery automatically.\n+An IP broadcast message is sent and every responding units gets added to the Inbox. \n+\n+## Binding Configuration\n+\n+No binding configuration is required.\n+\n+#### Manual Thing Creation\n+\n+Fans can be manually created in the *PaperUI* or *HABmin*, or by placing a *.things* file in the *conf/things* directory.  See example below.\n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d02afd67855da8b4600742a9275b4a37adc694b8"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTg2OTE2MA==", "bodyText": "Why are there two items for the same channel here?\nAlso they should be Number:Temperature.", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r445869160", "createdAt": "2020-06-25T22:16:50Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/README.md", "diffHunk": "@@ -0,0 +1,147 @@\n+# GREE Binding\n+\n+This binding integrates GREE Air Conditioners.\n+\n+Note: The GREE Air Conditioner must already be setup on the WiFi network and must have a fixed IP Address.\n+\n+## Supported Things\n+\n+This binding supports one Thing type `airconditioner`.\n+\n+## Discovery\n+\n+Once the GREE is on the network (WiFi active) it could be discovery automatically.\n+An IP broadcast message is sent and every responding units gets added to the Inbox. \n+\n+## Binding Configuration\n+\n+No binding configuration is required.\n+\n+#### Manual Thing Creation\n+\n+Fans can be manually created in the *PaperUI* or *HABmin*, or by placing a *.things* file in the *conf/things* directory.  See example below.\n+\n+\n+## Thing Configuration\n+\n+| Channel Name     | Type       | Description                                                                                   |\n+|------------------|------------|-----------------------------------------------------------------------------------------------|\n+| ipAddress        | IP Address | IP address of the unit.                                                                       |\n+| broadcastAddress | IP Address | Broadcast address being used for discovery, usually derived from the IP interface address.    |\n+| refresh          | Integer    | Refresh interval in seconds for polling the device status.                                    |\n+\n+The Air Conditioner's IP address is mandatory, all other parameters are optional. \n+If the broadcast is not set (default) it will be derived from openHAB's network setting (PaperUI:Configuration:System:Network Settings). \n+Only change this if you have a good reason to.\n+\n+## Channels\n+\n+The following channels are supported for fans:\n+\n+| Channel Name  | Item Type | Description                                                                                       |\n+|---------------|-----------|---------------------------------------------------------------------------------------------------|\n+| power         | Switch    | Power on/off the Air Conditioner                                                                  |\n+| mode          | String    | Sets the operating mode of the Air Conditioner                                                    |\n+|               |           | Mode can be one of auto/cool/eco/dry/fan/heat or on/off                                     |\n+|               |           | Check the Air Conditioner's operating manual for supported modes.                                 |\n+| temperature   | Number    | Sets the desired room temperature                                                                 |\n+|\u00a0air           | Switch    | Set on/off the Air Conditioner's Air function if applicable to the Air Conditioner model          |\n+| dry           | Switch    | Set on/off the Air Conditioner's Dry function if applicable to the Air Conditioner model          |\n+|\u00a0health        | Switch    | Set on/off the Air Conditioner's Health function if applicable to the Air Conditioner model       |\n+| turbo         | Switch    | Set on/off the Air Conditioner's Turbo Mode.                                                      |\n+| quiet         | String    | Set Quiet Mode: off/auto/quiet                                                                    |\n+| swingUpDown   | Number    | Sets the vertical (up..down) swing action on the Air Conditioner,                                 |\n+|               |           | OFF: 0, Full Swing: 1, Up: 2, MidUp: 3, Mid: 4, Mid Down: 5, Down : 6                             |\n+| swingLeftRight| Number    | Sets the horizontal (left..right) swing action on the Air Conditioner                             |\n+|               |           |\u00a0OFF: 0, Full Swing: 1, Left: 2, Mid Left: 3, Mid: 4, Mid Right: 5, Right : 6                      |\n+|\u00a0windspeed     | Number    | Sets the fan speed on the Air conditioner Auto:0, Low:1, MidLow:2, Mid:3, MidHigh:4, High:5       |\n+|               |           |\u00a0The number of speeds depends on the Air Conditioner model.                                        |\n+|\u00a0powersave     | Switch    | Set on/off the Air Conditioner's Power Saving function if applicable to the Air Conditioner model |\n+| light         | Switch    | Enable/disable the front display on the Air Conditioner if applicable to the Air Conditioner model|\n+|               |           | Full Swing: 1, Up: 2, MidUp: 3, Mid: 4, Mid Down: 5, Down : 6                                     |\n+\n+\n+When changing mode, the air conditioner will be turned on unless \"off\" is selected.\n+\n+## Full Example\n+\n+**Things**\n+\n+```\n+Thing gree:airconditioner:a1234561 [ ipAddress=\"192.168.1.111\", refresh=2 ]\n+```\n+\n+**Items**\n+\n+```\n+Switch AirconPower                  { channel=\"gree:airconditioner:a1234561:power\" }\n+Number AirconMode                   { channel=\"gree:airconditioner:a1234561:mode\" }\n+Switch AirconTurbo                  { channel=\"gree:airconditioner:a1234561:turbo\" }\n+Switch AirconLight                  { channel=\"gree:airconditioner:a1234561:light\" }\n+Number AirconTemp \"Temperature [%.1f \u00b0C]\" {channel=\"gree:airconditioner:a1234561:temperature\" }\n+Number AirconTempSet                { channel=\"gree:airconditioner:a1234561:temperature\" }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d02afd67855da8b4600742a9275b4a37adc694b8"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTg2OTIxMA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            | temperature   | Number    | Sets the desired room temperature                                                                 |\n          \n          \n            \n            | temperature   | Number:Temperature    | Sets the desired room temperature                                                                 |", "url": "https://github.com/openhab/openhab-addons/pull/7504#discussion_r445869210", "createdAt": "2020-06-25T22:17:00Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.gree/README.md", "diffHunk": "@@ -0,0 +1,147 @@\n+# GREE Binding\n+\n+This binding integrates GREE Air Conditioners.\n+\n+Note: The GREE Air Conditioner must already be setup on the WiFi network and must have a fixed IP Address.\n+\n+## Supported Things\n+\n+This binding supports one Thing type `airconditioner`.\n+\n+## Discovery\n+\n+Once the GREE is on the network (WiFi active) it could be discovery automatically.\n+An IP broadcast message is sent and every responding units gets added to the Inbox. \n+\n+## Binding Configuration\n+\n+No binding configuration is required.\n+\n+#### Manual Thing Creation\n+\n+Fans can be manually created in the *PaperUI* or *HABmin*, or by placing a *.things* file in the *conf/things* directory.  See example below.\n+\n+\n+## Thing Configuration\n+\n+| Channel Name     | Type       | Description                                                                                   |\n+|------------------|------------|-----------------------------------------------------------------------------------------------|\n+| ipAddress        | IP Address | IP address of the unit.                                                                       |\n+| broadcastAddress | IP Address | Broadcast address being used for discovery, usually derived from the IP interface address.    |\n+| refresh          | Integer    | Refresh interval in seconds for polling the device status.                                    |\n+\n+The Air Conditioner's IP address is mandatory, all other parameters are optional. \n+If the broadcast is not set (default) it will be derived from openHAB's network setting (PaperUI:Configuration:System:Network Settings). \n+Only change this if you have a good reason to.\n+\n+## Channels\n+\n+The following channels are supported for fans:\n+\n+| Channel Name  | Item Type | Description                                                                                       |\n+|---------------|-----------|---------------------------------------------------------------------------------------------------|\n+| power         | Switch    | Power on/off the Air Conditioner                                                                  |\n+| mode          | String    | Sets the operating mode of the Air Conditioner                                                    |\n+|               |           | Mode can be one of auto/cool/eco/dry/fan/heat or on/off                                     |\n+|               |           | Check the Air Conditioner's operating manual for supported modes.                                 |\n+| temperature   | Number    | Sets the desired room temperature                                                                 |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d02afd67855da8b4600742a9275b4a37adc694b8"}, "originalPosition": 47}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "079b7452df9d58f2f03e4f8f7716083c1d6614e7", "author": {"user": {"login": "markus7017", "name": "Markus Michels"}}, "url": "https://github.com/openhab/openhab-addons/commit/079b7452df9d58f2f03e4f8f7716083c1d6614e7", "committedDate": "2020-06-26T17:49:42Z", "message": "duplicate removed\n\nSigned-off-by: Markus Michels <markus7017@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0NDE0ODI5", "url": "https://github.com/openhab/openhab-addons/pull/7504#pullrequestreview-444414829", "createdAt": "2020-07-08T05:03:11Z", "commit": {"oid": "079b7452df9d58f2f03e4f8f7716083c1d6614e7"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 944, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}