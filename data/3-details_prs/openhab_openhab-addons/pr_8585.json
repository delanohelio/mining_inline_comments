{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDkzNTk5ODY5", "number": 8585, "title": "[playstation] Initial contribution", "bodyText": "[playstation] Initial contribution\nA new binding for mainly PlayStation 4 consoles.\nIts main goals are to be able to change power and current game.\nYou can also control the PS4 UI and send/receive text from the On-Screen-Keyboard from the binding.\nTo read power and game you don't need any credentials but to control them you need user-credentials for your PSN user.\nHere is a discussion on the forum:\nhttps://community.openhab.org/t/playstation-binding/93789/13", "createdAt": "2020-09-26T16:46:03Z", "url": "https://github.com/openhab/openhab-addons/pull/8585", "merged": true, "mergeCommit": {"oid": "fde30fbadab04e29d4af8c403f217fdf9b841e46"}, "closed": true, "closedAt": "2020-11-26T01:39:28Z", "author": {"login": "FluBBaOfWard"}, "timelineItems": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdMrJ6IAH2gAyNDkzNTk5ODY5OjZjYjRlMmUyN2U4MzFlMGEyMGM3Mzg4NWQyMDlhNzQxODk4N2JlNjg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdfs8WrAH2gAyNDkzNTk5ODY5OjBmODA4YzVjMWFmZTEwOGUxMzAzOWZlNWU4NDI2NmEyNTdjZjY0YTQ=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "6cb4e2e27e831e0a20c73885d209a7418987be68", "author": {"user": {"login": "FluBBaOfWard", "name": "Fredrik Ahlstr\u00f6m"}}, "url": "https://github.com/openhab/openhab-addons/commit/6cb4e2e27e831e0a20c73885d209a7418987be68", "committedDate": "2020-09-26T14:21:04Z", "message": "[playstation] Initial contribution.\n\nSigned-off-by: Fredrik Ahlstro\u0308m <fredrikahlstrom75@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a8c66b99af1137f6fe388c6072f14876186d7879", "author": {"user": {"login": "FluBBaOfWard", "name": "Fredrik Ahlstr\u00f6m"}}, "url": "https://github.com/openhab/openhab-addons/commit/a8c66b99af1137f6fe388c6072f14876186d7879", "committedDate": "2020-09-26T16:35:51Z", "message": "[playstation] Fixed problem after conversion to openHAB 3.\n\nSigned-off-by: Fredrik Ahlstro\u0308m <fredrikahlstrom75@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAyMjE0MDI5", "url": "https://github.com/openhab/openhab-addons/pull/8585#pullrequestreview-502214029", "createdAt": "2020-10-05T16:14:02Z", "commit": {"oid": "a8c66b99af1137f6fe388c6072f14876186d7879"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxNjoxNDowMlrOHckO4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNVQxNjo1Njo0NFrOHclyLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcxNTgwOQ==", "bodyText": "Is it both, width and height?", "url": "https://github.com/openhab/openhab-addons/pull/8585#discussion_r499715809", "createdAt": "2020-10-05T16:14:02Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.playstation/README.md", "diffHunk": "@@ -0,0 +1,126 @@\n+# Sony PlayStation Binding\n+\n+This binding allows you to monitor the on/off status and which application that is currently running on your PlayStation 4.\n+By providing your user-credentials you can also change the power, which application that is running and more.\n+\n+## Supported Things\n+\n+This binding should support all PS4 variants.\n+It can also tell if your PS3 is ON or OFF/not present.\n+\n+## Discovery\n+\n+Discovery should find all your PS4s within a few seconds as long as they are in standby mode and not completely turned off.\n+To be able to discover your PS3 you need to turn on \"Connect PS Vita System Using Network\" in\n+Settings -> System Settings -> Connect PS Vita System Using Network.\n+\n+## Thing Configuration\n+\n+**playstation4** parameters:\n+\n+| Property            | Default | Required | Description                                                              |\n+|---------------------|---------|:--------:|--------------------------------------------------------------------------|\n+| ipAddress           |         | Yes      | The IP address of the PlayStation 4                                      |\n+| userCredential      |         | Yes      | A key used for authentication, get via PS4-waker.                        |\n+| pairingCode         |         | Yes      | This is shown on the PlayStation 4 during pairing, only needed once.     |\n+| passCode            |         | (Yes)    | If you use a code to log in your user on the PS4, set this.              |\n+| connectionTimeout   |  60     | No       | How long the connection to the PS4 is kept up, seconds.                  |\n+| autoConnect         |  false  | No       | If a connection should be establish to the PS4 when it's turned on.      |\n+| artworkSize         |  320    | No       | Width and height of downloaded artwork.                                  |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a8c66b99af1137f6fe388c6072f14876186d7879"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcyMjEwOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        byte[] discover = \"SRCH\".getBytes();\n          \n          \n            \n                        byte[] discover = \"SRCH\".getBytes(StandardCharsets.UTF_8);", "url": "https://github.com/openhab/openhab-addons/pull/8585#discussion_r499722108", "createdAt": "2020-10-05T16:24:01Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.playstation/src/main/java/org/openhab/binding/playstation/internal/PS3Handler.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.playstation.internal;\n+\n+import static org.openhab.binding.playstation.internal.PlayStationBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.SocketTimeoutException;\n+import java.nio.channels.SocketChannel;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.util.HexUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link PS3Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Fredrik Ahlstr\u00f6m - Initial contribution\n+ */\n+@NonNullByDefault\n+public class PS3Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(PS3Handler.class);\n+    private static final int SOCKET_TIMEOUT_SECONDS = 2;\n+\n+    private PS3Configuration config = new PS3Configuration();\n+\n+    private @Nullable ScheduledFuture<?> refreshTimer;\n+\n+    public PS3Handler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (!(command instanceof RefreshType)) {\n+            if (CHANNEL_POWER.equals(channelUID.getId()) && command instanceof OnOffType) {\n+                if (command.equals(OnOffType.ON)) {\n+                    turnOnPS3();\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(PS3Configuration.class);\n+\n+        updateStatus(ThingStatus.ONLINE);\n+        setupRefreshTimer();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        final ScheduledFuture<?> timer = refreshTimer;\n+        if (timer != null) {\n+            timer.cancel(false);\n+            refreshTimer = null;\n+        }\n+    }\n+\n+    /**\n+     * Sets up a timer for querying the PS3 (using the scheduler) every 10 seconds.\n+     */\n+    private void setupRefreshTimer() {\n+        final ScheduledFuture<?> timer = refreshTimer;\n+        if (timer != null) {\n+            timer.cancel(false);\n+        }\n+        refreshTimer = scheduler.scheduleWithFixedDelay(this::updateAllChannels, 0, 10, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * This tries to connect to port 5223 on the PS3,\n+     * if the connection times out the PS3 is OFF, if connection is refused the PS3 is ON.\n+     */\n+    private void updateAllChannels() {\n+        try (SocketChannel channel = SocketChannel.open()) {\n+            Socket socket = channel.socket();\n+            socket.setSoTimeout(SOCKET_TIMEOUT_SECONDS * 1000);\n+            channel.configureBlocking(true);\n+            channel.connect(new InetSocketAddress(config.ipAddress, DEFAULT_PS3_WAKE_ON_LAN_PORT));\n+        } catch (IOException e) {\n+            String message = e.getMessage();\n+            if (message.contains(\"refused\")) {\n+                updateState(CHANNEL_POWER, OnOffType.ON);\n+                updateStatus(ThingStatus.ONLINE);\n+            } else if (message.contains(\"timed out\") || message.contains(\"is down\")) {\n+                updateState(CHANNEL_POWER, OnOffType.OFF);\n+            } else {\n+                logger.debug(\"PS3 read power, IOException: {}\", e.getMessage());\n+            }\n+        }\n+    }\n+\n+    private void turnOnPS3() {\n+        try {\n+            InetAddress bcAddress = InetAddress.getByName(\"255.255.255.255\");\n+\n+            // send WOL magic packet\n+            byte[] magicPacket = makeWOLMagicPacket(thing.getProperties().get(Thing.PROPERTY_MAC_ADDRESS));\n+            logger.debug(\"PS3 wol packet: {}\", magicPacket);\n+            DatagramPacket wakePacket = new DatagramPacket(magicPacket, magicPacket.length, bcAddress,\n+                    DEFAULT_PS3_WAKE_ON_LAN_PORT);\n+            // send discover\n+            byte[] discover = \"SRCH\".getBytes();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a8c66b99af1137f6fe388c6072f14876186d7879"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcyNDQyNA==", "bodyText": "Can you add a comment where you got the public key from, in case it needs an update?", "url": "https://github.com/openhab/openhab-addons/pull/8585#discussion_r499724424", "createdAt": "2020-10-05T16:27:50Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.playstation/src/main/java/org/openhab/binding/playstation/internal/PS4Crypto.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.playstation.internal;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.KeyFactory;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.PublicKey;\n+import java.security.SecureRandom;\n+import java.security.spec.InvalidKeySpecException;\n+import java.security.spec.X509EncodedKeySpec;\n+import java.util.Base64;\n+\n+import javax.crypto.BadPaddingException;\n+import javax.crypto.Cipher;\n+import javax.crypto.IllegalBlockSizeException;\n+import javax.crypto.NoSuchPaddingException;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link PS4Crypto} is responsible for encryption and decryption of\n+ * packets to / from the PS4.\n+ *\n+ * @author Fredrik Ahlstr\u00f6m - Initial contribution\n+ */\n+@NonNullByDefault\n+public class PS4Crypto {\n+\n+    private final Logger logger = LoggerFactory.getLogger(PS4Crypto.class);\n+\n+    private static final String PUBLIC_KEY = \"-----BEGIN PUBLIC KEY-----\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a8c66b99af1137f6fe388c6072f14876186d7879"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcyNDkwMQ==", "bodyText": "Logging to info should be used rarely. This could be debug or warn. Same for below.", "url": "https://github.com/openhab/openhab-addons/pull/8585#discussion_r499724901", "createdAt": "2020-10-05T16:28:39Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.playstation/src/main/java/org/openhab/binding/playstation/internal/PS4Crypto.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.playstation.internal;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.security.InvalidAlgorithmParameterException;\n+import java.security.InvalidKeyException;\n+import java.security.KeyFactory;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.PublicKey;\n+import java.security.SecureRandom;\n+import java.security.spec.InvalidKeySpecException;\n+import java.security.spec.X509EncodedKeySpec;\n+import java.util.Base64;\n+\n+import javax.crypto.BadPaddingException;\n+import javax.crypto.Cipher;\n+import javax.crypto.IllegalBlockSizeException;\n+import javax.crypto.NoSuchPaddingException;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link PS4Crypto} is responsible for encryption and decryption of\n+ * packets to / from the PS4.\n+ *\n+ * @author Fredrik Ahlstr\u00f6m - Initial contribution\n+ */\n+@NonNullByDefault\n+public class PS4Crypto {\n+\n+    private final Logger logger = LoggerFactory.getLogger(PS4Crypto.class);\n+\n+    private static final String PUBLIC_KEY = \"-----BEGIN PUBLIC KEY-----\"\n+            + \"MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAxfAO/MDk5ovZpp7xlG9J\"\n+            + \"JKc4Sg4ztAz+BbOt6Gbhub02tF9bryklpTIyzM0v817pwQ3TCoigpxEcWdTykhDL\"\n+            + \"cGhAbcp6E7Xh8aHEsqgtQ/c+wY1zIl3fU//uddlB1XuipXthDv6emXsyyU/tJWqc\"\n+            + \"zy9HCJncLJeYo7MJvf2TE9nnlVm1x4flmD0k1zrvb3MONqoZbKb/TQVuVhBv7SM+\"\n+            + \"U5PSi3diXIx1Nnj4vQ8clRNUJ5X1tT9XfVmKQS1J513XNZ0uYHYRDzQYujpLWucu\"\n+            + \"ob7v50wCpUm3iKP1fYCixMP6xFm0jPYz1YQaMV35VkYwc40qgk3av0PDS+1G0dCm\" + \"swIDAQAB\"\n+            + \"-----END PUBLIC KEY-----\";\n+\n+    private final byte[] remoteSeed = new byte[16];\n+    private final byte[] randomSeed = new byte[16];\n+    private @Nullable Cipher ps4Cipher;\n+    private @Nullable Cipher aesEncryptCipher;\n+    private @Nullable Cipher aesDecryptCipher;\n+\n+    PS4Crypto() {\n+        ps4Cipher = getRsaCipher(PUBLIC_KEY);\n+    }\n+\n+    void clearCiphers() {\n+        aesEncryptCipher = null;\n+        aesDecryptCipher = null;\n+    }\n+\n+    void initCiphers() {\n+        new SecureRandom().nextBytes(randomSeed);\n+        SecretKeySpec keySpec = new SecretKeySpec(randomSeed, \"AES\");\n+        IvParameterSpec ivSpec = new IvParameterSpec(remoteSeed);\n+        try {\n+            Cipher encCipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n+            encCipher.init(Cipher.ENCRYPT_MODE, keySpec, ivSpec);\n+            Cipher decCipher = Cipher.getInstance(\"AES/CBC/NoPadding\");\n+            decCipher.init(Cipher.DECRYPT_MODE, keySpec, ivSpec);\n+            logger.debug(\"Ciphers initialized.\");\n+            aesEncryptCipher = encCipher;\n+            aesDecryptCipher = decCipher;\n+        } catch (NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException\n+                | InvalidAlgorithmParameterException e) {\n+            logger.warn(\"Can not initialize ciphers.\", e);\n+        }\n+    }\n+\n+    int parseHelloResponsePacket(ByteBuffer rBuffer) {\n+        int result = -1;\n+        rBuffer.rewind();\n+        final int buffSize = rBuffer.remaining();\n+        final int size = rBuffer.getInt();\n+        if (size > buffSize || size < 12) {\n+            logger.info(\"Response size ({}) not good, buffer size ({}).\", size, buffSize);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a8c66b99af1137f6fe388c6072f14876186d7879"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTcyNzc0NQ==", "bodyText": "Syntactical sugar\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        scheduler.execute(() -> login());\n          \n          \n            \n                                        scheduler.execute(this::login);", "url": "https://github.com/openhab/openhab-addons/pull/8585#discussion_r499727745", "createdAt": "2020-10-05T16:33:38Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.playstation/src/main/java/org/openhab/binding/playstation/internal/PS4Handler.java", "diffHunk": "@@ -0,0 +1,852 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.playstation.internal;\n+\n+import static org.openhab.binding.playstation.internal.PlayStationBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.UnknownHostException;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.channels.SocketChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.playstation.internal.discovery.PlayStationDiscovery;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.i18n.LocaleProvider;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.net.NetworkAddressService;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link PS4Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Fredrik Ahlstr\u00f6m - Initial contribution\n+ */\n+@NonNullByDefault\n+public class PS4Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(PS4Handler.class);\n+    private final PS4Crypto ps4Crypto = new PS4Crypto();\n+    private static final int SOCKET_TIMEOUT_SECONDS = 5;\n+    /** Time after connect that we can start to send key events, milli seconds */\n+    private static final int POST_CONNECT_SENDKEY_DELAY_MS = 500;\n+    /** Minimum delay between sendKey sends, milli seconds */\n+    private static final int MIN_SENDKEY_DELAY_MS = 250;\n+    /** Minimum delay after Key set, milli seconds */\n+    private static final int MIN_HOLDKEY_DELAY_MS = 300;\n+\n+    private PS4Configuration config = new PS4Configuration();\n+\n+    private final @Nullable LocaleProvider localeProvider;\n+    private final @Nullable NetworkAddressService networkAS;\n+    private @Nullable ScheduledFuture<?> refreshTimer;\n+    private @Nullable ScheduledFuture<?> timeoutTimer;\n+    private @Nullable SocketChannelHandler socketChannelHandler;\n+    private @Nullable InetAddress localAddress;\n+\n+    // State of PS4\n+    private String currentApplication = \"\";\n+    private String currentApplicationId = \"\";\n+    private OnOffType currentPower = OnOffType.OFF;\n+    private State currentArtwork = UnDefType.UNDEF;\n+    private int currentComPort = DEFAULT_COMMUNICATION_PORT;\n+\n+    boolean loggedIn = false;\n+    boolean oskOpen = false;\n+\n+    public PS4Handler(Thing thing, LocaleProvider locProvider, NetworkAddressService network) {\n+        super(thing);\n+        localeProvider = locProvider;\n+        networkAS = network;\n+    }\n+\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        super.handleConfigurationUpdate(configurationParameters);\n+        figureOutLocalIP();\n+        SocketChannelHandler scHandler = socketChannelHandler;\n+        if (!config.pairingCode.isEmpty() && (scHandler == null || !loggedIn)) {\n+            // Try to log in then remove pairing code as it's one use only.\n+            scheduler.execute(() -> {\n+                login();\n+                Configuration editedConfig = editConfiguration();\n+                editedConfig.put(PAIRING_CODE, \"\");\n+                updateConfiguration(editedConfig);\n+            });\n+        }\n+        setupConnectionTimeout(config.connectionTimeout);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            refreshFromState(channelUID);\n+        } else {\n+            if (command instanceof StringType) {\n+                switch (channelUID.getId()) {\n+                    case CHANNEL_APPLICATION_ID:\n+                        if (!currentApplicationId.equals(((StringType) command).toString())) {\n+                            updateApplicationTitleid(((StringType) command).toString());\n+                            startApplication(currentApplicationId);\n+                        }\n+                        break;\n+                    case CHANNEL_OSK_TEXT:\n+                        setOSKText(((StringType) command).toString());\n+                        break;\n+                    case CHANNEL_SEND_KEY:\n+                        int ps4Key = 0;\n+                        switch (((StringType) command).toString()) {\n+                            case SEND_KEY_UP:\n+                                ps4Key = PS4_KEY_UP;\n+                                break;\n+                            case SEND_KEY_DOWN:\n+                                ps4Key = PS4_KEY_DOWN;\n+                                break;\n+                            case SEND_KEY_RIGHT:\n+                                ps4Key = PS4_KEY_RIGHT;\n+                                break;\n+                            case SEND_KEY_LEFT:\n+                                ps4Key = PS4_KEY_LEFT;\n+                                break;\n+                            case SEND_KEY_ENTER:\n+                                ps4Key = PS4_KEY_ENTER;\n+                                break;\n+                            case SEND_KEY_BACK:\n+                                ps4Key = PS4_KEY_BACK;\n+                                break;\n+                            case SEND_KEY_OPTION:\n+                                ps4Key = PS4_KEY_OPTION;\n+                                break;\n+                            case SEND_KEY_PS:\n+                                ps4Key = PS4_KEY_PS;\n+                                break;\n+                            default:\n+                                break;\n+                        }\n+                        if (ps4Key != 0) {\n+                            sendRemoteKey(ps4Key);\n+                        }\n+                        break;\n+                    default:\n+                        break;\n+                }\n+            } else if (command instanceof OnOffType) {\n+                OnOffType onOff = (OnOffType) command;\n+                switch (channelUID.getId()) {\n+                    case CHANNEL_POWER:\n+                        if (currentPower != onOff) {\n+                            currentPower = onOff;\n+                            if (currentPower.equals(OnOffType.ON)) {\n+                                turnOnPS4();\n+                            } else if (currentPower.equals(OnOffType.OFF)) {\n+                                sendStandby();\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_CONNECT:\n+                        boolean connected = socketChannelHandler != null && socketChannelHandler.isChannelOpen();\n+                        if (connected && onOff.equals(OnOffType.OFF)) {\n+                            sendByeBye();\n+                        } else if (!connected && onOff.equals(OnOffType.ON)) {\n+                            scheduler.execute(() -> login());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a8c66b99af1137f6fe388c6072f14876186d7879"}, "originalPosition": 185}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTczNjM3OQ==", "bodyText": "Syntactical sugar\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    secondScrStr = \"http://\" + config.ipAddress + \":\" + Integer.toString(port);\n          \n          \n            \n                                    secondScrStr = \"http://\" + config.ipAddress + \":\" + port;", "url": "https://github.com/openhab/openhab-addons/pull/8585#discussion_r499736379", "createdAt": "2020-10-05T16:48:30Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.playstation/src/main/java/org/openhab/binding/playstation/internal/PS4Handler.java", "diffHunk": "@@ -0,0 +1,852 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.playstation.internal;\n+\n+import static org.openhab.binding.playstation.internal.PlayStationBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.UnknownHostException;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.channels.SocketChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.playstation.internal.discovery.PlayStationDiscovery;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.i18n.LocaleProvider;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.net.NetworkAddressService;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link PS4Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Fredrik Ahlstr\u00f6m - Initial contribution\n+ */\n+@NonNullByDefault\n+public class PS4Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(PS4Handler.class);\n+    private final PS4Crypto ps4Crypto = new PS4Crypto();\n+    private static final int SOCKET_TIMEOUT_SECONDS = 5;\n+    /** Time after connect that we can start to send key events, milli seconds */\n+    private static final int POST_CONNECT_SENDKEY_DELAY_MS = 500;\n+    /** Minimum delay between sendKey sends, milli seconds */\n+    private static final int MIN_SENDKEY_DELAY_MS = 250;\n+    /** Minimum delay after Key set, milli seconds */\n+    private static final int MIN_HOLDKEY_DELAY_MS = 300;\n+\n+    private PS4Configuration config = new PS4Configuration();\n+\n+    private final @Nullable LocaleProvider localeProvider;\n+    private final @Nullable NetworkAddressService networkAS;\n+    private @Nullable ScheduledFuture<?> refreshTimer;\n+    private @Nullable ScheduledFuture<?> timeoutTimer;\n+    private @Nullable SocketChannelHandler socketChannelHandler;\n+    private @Nullable InetAddress localAddress;\n+\n+    // State of PS4\n+    private String currentApplication = \"\";\n+    private String currentApplicationId = \"\";\n+    private OnOffType currentPower = OnOffType.OFF;\n+    private State currentArtwork = UnDefType.UNDEF;\n+    private int currentComPort = DEFAULT_COMMUNICATION_PORT;\n+\n+    boolean loggedIn = false;\n+    boolean oskOpen = false;\n+\n+    public PS4Handler(Thing thing, LocaleProvider locProvider, NetworkAddressService network) {\n+        super(thing);\n+        localeProvider = locProvider;\n+        networkAS = network;\n+    }\n+\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        super.handleConfigurationUpdate(configurationParameters);\n+        figureOutLocalIP();\n+        SocketChannelHandler scHandler = socketChannelHandler;\n+        if (!config.pairingCode.isEmpty() && (scHandler == null || !loggedIn)) {\n+            // Try to log in then remove pairing code as it's one use only.\n+            scheduler.execute(() -> {\n+                login();\n+                Configuration editedConfig = editConfiguration();\n+                editedConfig.put(PAIRING_CODE, \"\");\n+                updateConfiguration(editedConfig);\n+            });\n+        }\n+        setupConnectionTimeout(config.connectionTimeout);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            refreshFromState(channelUID);\n+        } else {\n+            if (command instanceof StringType) {\n+                switch (channelUID.getId()) {\n+                    case CHANNEL_APPLICATION_ID:\n+                        if (!currentApplicationId.equals(((StringType) command).toString())) {\n+                            updateApplicationTitleid(((StringType) command).toString());\n+                            startApplication(currentApplicationId);\n+                        }\n+                        break;\n+                    case CHANNEL_OSK_TEXT:\n+                        setOSKText(((StringType) command).toString());\n+                        break;\n+                    case CHANNEL_SEND_KEY:\n+                        int ps4Key = 0;\n+                        switch (((StringType) command).toString()) {\n+                            case SEND_KEY_UP:\n+                                ps4Key = PS4_KEY_UP;\n+                                break;\n+                            case SEND_KEY_DOWN:\n+                                ps4Key = PS4_KEY_DOWN;\n+                                break;\n+                            case SEND_KEY_RIGHT:\n+                                ps4Key = PS4_KEY_RIGHT;\n+                                break;\n+                            case SEND_KEY_LEFT:\n+                                ps4Key = PS4_KEY_LEFT;\n+                                break;\n+                            case SEND_KEY_ENTER:\n+                                ps4Key = PS4_KEY_ENTER;\n+                                break;\n+                            case SEND_KEY_BACK:\n+                                ps4Key = PS4_KEY_BACK;\n+                                break;\n+                            case SEND_KEY_OPTION:\n+                                ps4Key = PS4_KEY_OPTION;\n+                                break;\n+                            case SEND_KEY_PS:\n+                                ps4Key = PS4_KEY_PS;\n+                                break;\n+                            default:\n+                                break;\n+                        }\n+                        if (ps4Key != 0) {\n+                            sendRemoteKey(ps4Key);\n+                        }\n+                        break;\n+                    default:\n+                        break;\n+                }\n+            } else if (command instanceof OnOffType) {\n+                OnOffType onOff = (OnOffType) command;\n+                switch (channelUID.getId()) {\n+                    case CHANNEL_POWER:\n+                        if (currentPower != onOff) {\n+                            currentPower = onOff;\n+                            if (currentPower.equals(OnOffType.ON)) {\n+                                turnOnPS4();\n+                            } else if (currentPower.equals(OnOffType.OFF)) {\n+                                sendStandby();\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_CONNECT:\n+                        boolean connected = socketChannelHandler != null && socketChannelHandler.isChannelOpen();\n+                        if (connected && onOff.equals(OnOffType.OFF)) {\n+                            sendByeBye();\n+                        } else if (!connected && onOff.equals(OnOffType.ON)) {\n+                            scheduler.execute(() -> login());\n+                        }\n+                        break;\n+                    default:\n+                        break;\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(PS4Configuration.class);\n+\n+        figureOutLocalIP();\n+        updateStatus(ThingStatus.UNKNOWN);\n+        setupRefreshTimer();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        ScheduledFuture<?> timer = refreshTimer;\n+        if (timer != null) {\n+            timer.cancel(false);\n+            refreshTimer = null;\n+        }\n+        timer = timeoutTimer;\n+        if (timer != null) {\n+            timer.cancel(false);\n+            timeoutTimer = null;\n+        }\n+        stopConnection();\n+    }\n+\n+    /**\n+     * Tries to figure out a local IP that can communicate with the PS4.\n+     */\n+    private void figureOutLocalIP() {\n+        if (!config.outboundIP.trim().isEmpty()) {\n+            try {\n+                localAddress = InetAddress.getByName(config.outboundIP);\n+                logger.debug(\"Outbound local IP.\\\"{}\\\"\", localAddress);\n+                return;\n+            } catch (UnknownHostException e) {\n+                // This is expected\n+            }\n+        }\n+        NetworkAddressService network = networkAS;\n+        String adr = (network != null) ? network.getPrimaryIpv4HostAddress() : null;\n+        if (adr != null) {\n+            try {\n+                localAddress = InetAddress.getByName(adr);\n+            } catch (UnknownHostException e) {\n+                // Ignore, just let the socket use whatever.\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Sets up a timer for querying the PS4 (using the scheduler) every 10 seconds.\n+     */\n+    private void setupRefreshTimer() {\n+        final ScheduledFuture<?> timer = refreshTimer;\n+        if (timer != null) {\n+            timer.cancel(false);\n+        }\n+        refreshTimer = scheduler.scheduleWithFixedDelay(this::updateAllChannels, 0, 10, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Sets up a timer for stopping the connection to the PS4 (using the scheduler) with the given time.\n+     *\n+     * @param waitTime The time in seconds before the connection is stopped.\n+     */\n+    private void setupConnectionTimeout(int waitTime) {\n+        final ScheduledFuture<?> timer = timeoutTimer;\n+        if (timer != null) {\n+            timer.cancel(false);\n+        }\n+        if (waitTime > 0) {\n+            timeoutTimer = scheduler.schedule(this::stopConnection, waitTime, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    private void refreshFromState(ChannelUID channelUID) {\n+        switch (channelUID.getId()) {\n+            case CHANNEL_POWER:\n+                updateState(channelUID, currentPower);\n+                break;\n+            case CHANNEL_APPLICATION_NAME:\n+                updateState(channelUID, StringType.valueOf(currentApplication));\n+                break;\n+            case CHANNEL_APPLICATION_ID:\n+                updateState(channelUID, StringType.valueOf(currentApplicationId));\n+                break;\n+            case CHANNEL_APPLICATION_IMAGE:\n+                updateApplicationTitleid(currentApplicationId);\n+                updateState(channelUID, currentArtwork);\n+                break;\n+            case CHANNEL_OSK_TEXT:\n+            case CHANNEL_2ND_SCREEN:\n+                updateState(channelUID, UnDefType.UNDEF);\n+                break;\n+            case CHANNEL_CONNECT:\n+                boolean connected = socketChannelHandler != null && socketChannelHandler.isChannelOpen();\n+                updateState(channelUID, OnOffType.from(connected));\n+                break;\n+            case CHANNEL_SEND_KEY:\n+                break;\n+            default:\n+                logger.warn(\"Channel refresh for {} not implemented!\", channelUID.getId());\n+        }\n+    }\n+\n+    private void updateAllChannels() {\n+        try (DatagramSocket socket = new DatagramSocket(0, localAddress)) {\n+            socket.setBroadcast(false);\n+            socket.setSoTimeout(SOCKET_TIMEOUT_SECONDS * 1000);\n+            InetAddress inetAddress = InetAddress.getByName(config.ipAddress);\n+\n+            // send discover\n+            byte[] discover = PS4PacketHandler.makeSearchPacket();\n+            DatagramPacket packet = new DatagramPacket(discover, discover.length, inetAddress, DEFAULT_BROADCAST_PORT);\n+            socket.send(packet);\n+\n+            // wait for response\n+            byte[] rxbuf = new byte[256];\n+            packet = new DatagramPacket(rxbuf, rxbuf.length);\n+            socket.receive(packet);\n+            parseSearchResponse(packet);\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        }\n+    }\n+\n+    private void stopConnection() {\n+        SocketChannelHandler handler = socketChannelHandler;\n+        if (handler != null && handler.isChannelOpen()) {\n+            sendByeBye();\n+        }\n+    }\n+\n+    private void wakeUpPS4() {\n+        logger.debug(\"Waking up PS4...\");\n+        try (DatagramSocket socket = new DatagramSocket(0, localAddress)) {\n+            socket.setBroadcast(false);\n+            InetAddress inetAddress = InetAddress.getByName(config.ipAddress);\n+            // send wake-up\n+            byte[] wakeup = PS4PacketHandler.makeWakeupPacket(config.userCredential);\n+            DatagramPacket packet = new DatagramPacket(wakeup, wakeup.length, inetAddress, DEFAULT_BROADCAST_PORT);\n+            socket.send(packet);\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        }\n+    }\n+\n+    private boolean openComs() {\n+        try (DatagramSocket socket = new DatagramSocket(0, localAddress)) {\n+            socket.setBroadcast(false);\n+            InetAddress inetAddress = InetAddress.getByName(config.ipAddress);\n+            // send launch\n+            byte[] launch = PS4PacketHandler.makeLaunchPacket(config.userCredential);\n+            DatagramPacket packet = new DatagramPacket(launch, launch.length, inetAddress, DEFAULT_BROADCAST_PORT);\n+            socket.send(packet);\n+            Thread.sleep(100);\n+            return true;\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        } catch (InterruptedException e) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    private boolean setupConnection(SocketChannel channel) throws IOException {\n+        logger.debug(\"TCP connecting\");\n+\n+        channel.socket().setSoTimeout(2000);\n+        channel.configureBlocking(true);\n+        channel.connect(new InetSocketAddress(config.ipAddress, currentComPort));\n+\n+        ByteBuffer outPacket = PS4PacketHandler.makeHelloPacket();\n+        sendPacketToPS4(outPacket, channel, false, false);\n+\n+        // Read hello response\n+        final ByteBuffer readBuffer = ByteBuffer.allocate(512).order(ByteOrder.LITTLE_ENDIAN);\n+\n+        int responseLength = channel.read(readBuffer);\n+        if (responseLength > 0) {\n+            ps4Crypto.parseHelloResponsePacket(readBuffer);\n+        } else {\n+            return false;\n+        }\n+\n+        outPacket = ps4Crypto.makeHandshakePacket();\n+        sendPacketToPS4(outPacket, channel, false, false);\n+        return true;\n+    }\n+\n+    private class SocketChannelHandler extends Thread {\n+        private SocketChannel socketChannel;\n+\n+        public SocketChannelHandler() throws IOException {\n+            socketChannel = setupChannel();\n+            loggedIn = false;\n+            oskOpen = false;\n+            start();\n+        }\n+\n+        public SocketChannel getChannel() {\n+            if (!socketChannel.isOpen()) {\n+                try {\n+                    socketChannel = setupChannel();\n+                } catch (IOException e) {\n+                    logger.debug(\"Couldn't open SocketChannel.{}\", e.getMessage());\n+                }\n+            }\n+            return socketChannel;\n+        }\n+\n+        public boolean isChannelOpen() {\n+            return socketChannel.isOpen();\n+        }\n+\n+        private SocketChannel setupChannel() throws IOException {\n+            SocketChannel channel = SocketChannel.open();\n+            if (!openComs()) {\n+                throw new IOException(\"Open coms failed\");\n+            }\n+            if (!setupConnection(channel)) {\n+                throw new IOException(\"Setup connection failed\");\n+            }\n+            updateState(CHANNEL_CONNECT, OnOffType.ON);\n+            return channel;\n+        }\n+\n+        @Override\n+        public void run() {\n+            SocketChannel channel = socketChannel;\n+            final ByteBuffer readBuffer = ByteBuffer.allocate(512).order(ByteOrder.LITTLE_ENDIAN);\n+            try {\n+                while (channel.read(readBuffer) > 0) {\n+                    ByteBuffer messBuffer = ps4Crypto.decryptPacket(readBuffer);\n+                    readBuffer.position(0);\n+                    PS4Command lastCommand = parseResponsePacket(messBuffer);\n+\n+                    if (lastCommand == PS4Command.SERVER_STATUS_RSP) {\n+                        if (oskOpen && isLinked(CHANNEL_OSK_TEXT)) {\n+                            sendOSKStart();\n+                        } else {\n+                            sendStatus();\n+                        }\n+                    }\n+                }\n+            } catch (IOException e) {\n+                logger.debug(\"Connection read exception: {}\", e.getMessage());\n+            } finally {\n+                try {\n+                    channel.close();\n+                } catch (IOException e) {\n+                    logger.debug(\"Connection close exception: {}\", e.getMessage());\n+                }\n+            }\n+            updateState(CHANNEL_CONNECT, OnOffType.OFF);\n+            logger.debug(\"SocketHandler done.\");\n+            ps4Crypto.clearCiphers();\n+            loggedIn = false;\n+        }\n+    }\n+\n+    private @Nullable PS4Command parseResponsePacket(ByteBuffer rBuffer) {\n+        rBuffer.rewind();\n+        final int buffSize = rBuffer.remaining();\n+        final int size = rBuffer.getInt();\n+        if (size > buffSize || size < 12) {\n+            logger.debug(\"Response size ({}) not good, buffer size ({}).\", size, buffSize);\n+            return null;\n+        }\n+        int cmdValue = rBuffer.getInt();\n+        int statValue = rBuffer.getInt();\n+        PS4ErrorStatus status = PS4ErrorStatus.valueOfTag(statValue);\n+        PS4Command command = PS4Command.valueOfTag(cmdValue);\n+        byte[] respBuff = new byte[size];\n+        rBuffer.rewind();\n+        rBuffer.get(respBuff);\n+        if (command != null) {\n+            if (status == null) {\n+                logger.debug(\"Resp; size:{}, command:{}, statValue:{}, data:{}.\", size, command, statValue, respBuff);\n+            } else {\n+                logger.debug(\"Resp; size:{}, command:{}, status:{}, data:{}.\", size, command, status, respBuff);\n+            }\n+            switch (command) {\n+                case LOGIN_RSP:\n+                    if (status == null) {\n+                        logger.debug(\"Unhandled Login status value: {}\", statValue);\n+                        return command;\n+                    }\n+                    // Read login response\n+                    switch (status) {\n+                        case STATUS_OK:\n+                            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, status.message);\n+                            loggedIn = true;\n+                            if (isLinked(CHANNEL_2ND_SCREEN)) {\n+                                scheduler.execute(() -> {\n+                                    ByteBuffer outPacket = PS4PacketHandler\n+                                            .makeClientIDPacket(\"com.playstation.mobile2ndscreen\", \"18.9.3\");\n+                                    sendPacketEncrypted(outPacket, false);\n+                                });\n+                            }\n+                            break;\n+                        case STATUS_NOT_PAIRED:\n+                            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.CONFIGURATION_PENDING, status.message);\n+                            loggedIn = false;\n+                            break;\n+                        case STATUS_MISSING_PAIRING_CODE:\n+                        case STATUS_MISSING_PASS_CODE:\n+                        case STATUS_WRONG_PAIRING_CODE:\n+                        case STATUS_WRONG_PASS_CODE:\n+                        case STATUS_WRONG_USER_CREDENTIAL:\n+                            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.CONFIGURATION_ERROR, status.message);\n+                            loggedIn = false;\n+                            logger.debug(\"Not logged in: {}\", status.message);\n+                            break;\n+                        case STATUS_CAN_NOT_PLAY_NOW:\n+                        case STATUS_CLOSE_OTHER_APP:\n+                        case STATUS_COMMAND_NOT_GOOD:\n+                        case STATUS_COULD_NOT_LOG_IN:\n+                        case STATUS_DO_LOGIN:\n+                        case STATUS_MAX_USERS:\n+                        case STATUS_REGISTER_DEVICE_OVER:\n+                        case STATUS_RESTART_APP:\n+                        case STATUS_SOMEONE_ELSE_USING:\n+                        case STATUS_UPDATE_APP:\n+                        case STATUS_UPDATE_PS4:\n+                            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, status.message);\n+                            loggedIn = false;\n+                            logger.debug(\"Not logged in: {}\", status.message);\n+                            break;\n+                        default:\n+                            logger.debug(\"Unhandled Login response status:{}, message:{}\", status, status.message);\n+                            break;\n+                    }\n+                    break;\n+                case APP_START_RSP:\n+                    if (status != null && status != PS4ErrorStatus.STATUS_OK) {\n+                        logger.debug(\"App start response: {}\", status.message);\n+                    }\n+                    break;\n+                case STANDBY_RSP:\n+                    if (status != null && status != PS4ErrorStatus.STATUS_OK) {\n+                        logger.debug(\"Standby response: {}\", status.message);\n+                    }\n+                    break;\n+                case SERVER_STATUS_RSP:\n+                    if ((statValue & 4) != 0) {\n+                        oskOpen = true;\n+                    } else {\n+                        if (oskOpen) {\n+                            updateState(CHANNEL_OSK_TEXT, StringType.valueOf(\"\"));\n+                        }\n+                        oskOpen = false;\n+                    }\n+                    logger.debug(\"Server status value:{}\", statValue);\n+                    break;\n+                case HTTPD_STATUS_RSP:\n+                    String httpdStat = PS4PacketHandler.parseHTTPdPacket(rBuffer);\n+                    logger.debug(\"HTTPd Response; {}\", httpdStat);\n+                    String secondScrStr = \"\";\n+                    int httpStatus = rBuffer.getInt(8);\n+                    int port = rBuffer.getInt(12);\n+                    if (httpStatus != 0 && port != 0) {\n+                        secondScrStr = \"http://\" + config.ipAddress + \":\" + Integer.toString(port);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a8c66b99af1137f6fe388c6072f14876186d7879"}, "originalPosition": 556}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTczODYyMQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                            scheduler.schedule(() -> login(), 20, TimeUnit.SECONDS);\n          \n          \n            \n                                            scheduler.schedule(this::login, 20, TimeUnit.SECONDS);", "url": "https://github.com/openhab/openhab-addons/pull/8585#discussion_r499738621", "createdAt": "2020-10-05T16:52:15Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.playstation/src/main/java/org/openhab/binding/playstation/internal/PS4Handler.java", "diffHunk": "@@ -0,0 +1,852 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.playstation.internal;\n+\n+import static org.openhab.binding.playstation.internal.PlayStationBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.UnknownHostException;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.channels.SocketChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.playstation.internal.discovery.PlayStationDiscovery;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.i18n.LocaleProvider;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.net.NetworkAddressService;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link PS4Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Fredrik Ahlstr\u00f6m - Initial contribution\n+ */\n+@NonNullByDefault\n+public class PS4Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(PS4Handler.class);\n+    private final PS4Crypto ps4Crypto = new PS4Crypto();\n+    private static final int SOCKET_TIMEOUT_SECONDS = 5;\n+    /** Time after connect that we can start to send key events, milli seconds */\n+    private static final int POST_CONNECT_SENDKEY_DELAY_MS = 500;\n+    /** Minimum delay between sendKey sends, milli seconds */\n+    private static final int MIN_SENDKEY_DELAY_MS = 250;\n+    /** Minimum delay after Key set, milli seconds */\n+    private static final int MIN_HOLDKEY_DELAY_MS = 300;\n+\n+    private PS4Configuration config = new PS4Configuration();\n+\n+    private final @Nullable LocaleProvider localeProvider;\n+    private final @Nullable NetworkAddressService networkAS;\n+    private @Nullable ScheduledFuture<?> refreshTimer;\n+    private @Nullable ScheduledFuture<?> timeoutTimer;\n+    private @Nullable SocketChannelHandler socketChannelHandler;\n+    private @Nullable InetAddress localAddress;\n+\n+    // State of PS4\n+    private String currentApplication = \"\";\n+    private String currentApplicationId = \"\";\n+    private OnOffType currentPower = OnOffType.OFF;\n+    private State currentArtwork = UnDefType.UNDEF;\n+    private int currentComPort = DEFAULT_COMMUNICATION_PORT;\n+\n+    boolean loggedIn = false;\n+    boolean oskOpen = false;\n+\n+    public PS4Handler(Thing thing, LocaleProvider locProvider, NetworkAddressService network) {\n+        super(thing);\n+        localeProvider = locProvider;\n+        networkAS = network;\n+    }\n+\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        super.handleConfigurationUpdate(configurationParameters);\n+        figureOutLocalIP();\n+        SocketChannelHandler scHandler = socketChannelHandler;\n+        if (!config.pairingCode.isEmpty() && (scHandler == null || !loggedIn)) {\n+            // Try to log in then remove pairing code as it's one use only.\n+            scheduler.execute(() -> {\n+                login();\n+                Configuration editedConfig = editConfiguration();\n+                editedConfig.put(PAIRING_CODE, \"\");\n+                updateConfiguration(editedConfig);\n+            });\n+        }\n+        setupConnectionTimeout(config.connectionTimeout);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            refreshFromState(channelUID);\n+        } else {\n+            if (command instanceof StringType) {\n+                switch (channelUID.getId()) {\n+                    case CHANNEL_APPLICATION_ID:\n+                        if (!currentApplicationId.equals(((StringType) command).toString())) {\n+                            updateApplicationTitleid(((StringType) command).toString());\n+                            startApplication(currentApplicationId);\n+                        }\n+                        break;\n+                    case CHANNEL_OSK_TEXT:\n+                        setOSKText(((StringType) command).toString());\n+                        break;\n+                    case CHANNEL_SEND_KEY:\n+                        int ps4Key = 0;\n+                        switch (((StringType) command).toString()) {\n+                            case SEND_KEY_UP:\n+                                ps4Key = PS4_KEY_UP;\n+                                break;\n+                            case SEND_KEY_DOWN:\n+                                ps4Key = PS4_KEY_DOWN;\n+                                break;\n+                            case SEND_KEY_RIGHT:\n+                                ps4Key = PS4_KEY_RIGHT;\n+                                break;\n+                            case SEND_KEY_LEFT:\n+                                ps4Key = PS4_KEY_LEFT;\n+                                break;\n+                            case SEND_KEY_ENTER:\n+                                ps4Key = PS4_KEY_ENTER;\n+                                break;\n+                            case SEND_KEY_BACK:\n+                                ps4Key = PS4_KEY_BACK;\n+                                break;\n+                            case SEND_KEY_OPTION:\n+                                ps4Key = PS4_KEY_OPTION;\n+                                break;\n+                            case SEND_KEY_PS:\n+                                ps4Key = PS4_KEY_PS;\n+                                break;\n+                            default:\n+                                break;\n+                        }\n+                        if (ps4Key != 0) {\n+                            sendRemoteKey(ps4Key);\n+                        }\n+                        break;\n+                    default:\n+                        break;\n+                }\n+            } else if (command instanceof OnOffType) {\n+                OnOffType onOff = (OnOffType) command;\n+                switch (channelUID.getId()) {\n+                    case CHANNEL_POWER:\n+                        if (currentPower != onOff) {\n+                            currentPower = onOff;\n+                            if (currentPower.equals(OnOffType.ON)) {\n+                                turnOnPS4();\n+                            } else if (currentPower.equals(OnOffType.OFF)) {\n+                                sendStandby();\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_CONNECT:\n+                        boolean connected = socketChannelHandler != null && socketChannelHandler.isChannelOpen();\n+                        if (connected && onOff.equals(OnOffType.OFF)) {\n+                            sendByeBye();\n+                        } else if (!connected && onOff.equals(OnOffType.ON)) {\n+                            scheduler.execute(() -> login());\n+                        }\n+                        break;\n+                    default:\n+                        break;\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(PS4Configuration.class);\n+\n+        figureOutLocalIP();\n+        updateStatus(ThingStatus.UNKNOWN);\n+        setupRefreshTimer();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        ScheduledFuture<?> timer = refreshTimer;\n+        if (timer != null) {\n+            timer.cancel(false);\n+            refreshTimer = null;\n+        }\n+        timer = timeoutTimer;\n+        if (timer != null) {\n+            timer.cancel(false);\n+            timeoutTimer = null;\n+        }\n+        stopConnection();\n+    }\n+\n+    /**\n+     * Tries to figure out a local IP that can communicate with the PS4.\n+     */\n+    private void figureOutLocalIP() {\n+        if (!config.outboundIP.trim().isEmpty()) {\n+            try {\n+                localAddress = InetAddress.getByName(config.outboundIP);\n+                logger.debug(\"Outbound local IP.\\\"{}\\\"\", localAddress);\n+                return;\n+            } catch (UnknownHostException e) {\n+                // This is expected\n+            }\n+        }\n+        NetworkAddressService network = networkAS;\n+        String adr = (network != null) ? network.getPrimaryIpv4HostAddress() : null;\n+        if (adr != null) {\n+            try {\n+                localAddress = InetAddress.getByName(adr);\n+            } catch (UnknownHostException e) {\n+                // Ignore, just let the socket use whatever.\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Sets up a timer for querying the PS4 (using the scheduler) every 10 seconds.\n+     */\n+    private void setupRefreshTimer() {\n+        final ScheduledFuture<?> timer = refreshTimer;\n+        if (timer != null) {\n+            timer.cancel(false);\n+        }\n+        refreshTimer = scheduler.scheduleWithFixedDelay(this::updateAllChannels, 0, 10, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Sets up a timer for stopping the connection to the PS4 (using the scheduler) with the given time.\n+     *\n+     * @param waitTime The time in seconds before the connection is stopped.\n+     */\n+    private void setupConnectionTimeout(int waitTime) {\n+        final ScheduledFuture<?> timer = timeoutTimer;\n+        if (timer != null) {\n+            timer.cancel(false);\n+        }\n+        if (waitTime > 0) {\n+            timeoutTimer = scheduler.schedule(this::stopConnection, waitTime, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    private void refreshFromState(ChannelUID channelUID) {\n+        switch (channelUID.getId()) {\n+            case CHANNEL_POWER:\n+                updateState(channelUID, currentPower);\n+                break;\n+            case CHANNEL_APPLICATION_NAME:\n+                updateState(channelUID, StringType.valueOf(currentApplication));\n+                break;\n+            case CHANNEL_APPLICATION_ID:\n+                updateState(channelUID, StringType.valueOf(currentApplicationId));\n+                break;\n+            case CHANNEL_APPLICATION_IMAGE:\n+                updateApplicationTitleid(currentApplicationId);\n+                updateState(channelUID, currentArtwork);\n+                break;\n+            case CHANNEL_OSK_TEXT:\n+            case CHANNEL_2ND_SCREEN:\n+                updateState(channelUID, UnDefType.UNDEF);\n+                break;\n+            case CHANNEL_CONNECT:\n+                boolean connected = socketChannelHandler != null && socketChannelHandler.isChannelOpen();\n+                updateState(channelUID, OnOffType.from(connected));\n+                break;\n+            case CHANNEL_SEND_KEY:\n+                break;\n+            default:\n+                logger.warn(\"Channel refresh for {} not implemented!\", channelUID.getId());\n+        }\n+    }\n+\n+    private void updateAllChannels() {\n+        try (DatagramSocket socket = new DatagramSocket(0, localAddress)) {\n+            socket.setBroadcast(false);\n+            socket.setSoTimeout(SOCKET_TIMEOUT_SECONDS * 1000);\n+            InetAddress inetAddress = InetAddress.getByName(config.ipAddress);\n+\n+            // send discover\n+            byte[] discover = PS4PacketHandler.makeSearchPacket();\n+            DatagramPacket packet = new DatagramPacket(discover, discover.length, inetAddress, DEFAULT_BROADCAST_PORT);\n+            socket.send(packet);\n+\n+            // wait for response\n+            byte[] rxbuf = new byte[256];\n+            packet = new DatagramPacket(rxbuf, rxbuf.length);\n+            socket.receive(packet);\n+            parseSearchResponse(packet);\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        }\n+    }\n+\n+    private void stopConnection() {\n+        SocketChannelHandler handler = socketChannelHandler;\n+        if (handler != null && handler.isChannelOpen()) {\n+            sendByeBye();\n+        }\n+    }\n+\n+    private void wakeUpPS4() {\n+        logger.debug(\"Waking up PS4...\");\n+        try (DatagramSocket socket = new DatagramSocket(0, localAddress)) {\n+            socket.setBroadcast(false);\n+            InetAddress inetAddress = InetAddress.getByName(config.ipAddress);\n+            // send wake-up\n+            byte[] wakeup = PS4PacketHandler.makeWakeupPacket(config.userCredential);\n+            DatagramPacket packet = new DatagramPacket(wakeup, wakeup.length, inetAddress, DEFAULT_BROADCAST_PORT);\n+            socket.send(packet);\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        }\n+    }\n+\n+    private boolean openComs() {\n+        try (DatagramSocket socket = new DatagramSocket(0, localAddress)) {\n+            socket.setBroadcast(false);\n+            InetAddress inetAddress = InetAddress.getByName(config.ipAddress);\n+            // send launch\n+            byte[] launch = PS4PacketHandler.makeLaunchPacket(config.userCredential);\n+            DatagramPacket packet = new DatagramPacket(launch, launch.length, inetAddress, DEFAULT_BROADCAST_PORT);\n+            socket.send(packet);\n+            Thread.sleep(100);\n+            return true;\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        } catch (InterruptedException e) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    private boolean setupConnection(SocketChannel channel) throws IOException {\n+        logger.debug(\"TCP connecting\");\n+\n+        channel.socket().setSoTimeout(2000);\n+        channel.configureBlocking(true);\n+        channel.connect(new InetSocketAddress(config.ipAddress, currentComPort));\n+\n+        ByteBuffer outPacket = PS4PacketHandler.makeHelloPacket();\n+        sendPacketToPS4(outPacket, channel, false, false);\n+\n+        // Read hello response\n+        final ByteBuffer readBuffer = ByteBuffer.allocate(512).order(ByteOrder.LITTLE_ENDIAN);\n+\n+        int responseLength = channel.read(readBuffer);\n+        if (responseLength > 0) {\n+            ps4Crypto.parseHelloResponsePacket(readBuffer);\n+        } else {\n+            return false;\n+        }\n+\n+        outPacket = ps4Crypto.makeHandshakePacket();\n+        sendPacketToPS4(outPacket, channel, false, false);\n+        return true;\n+    }\n+\n+    private class SocketChannelHandler extends Thread {\n+        private SocketChannel socketChannel;\n+\n+        public SocketChannelHandler() throws IOException {\n+            socketChannel = setupChannel();\n+            loggedIn = false;\n+            oskOpen = false;\n+            start();\n+        }\n+\n+        public SocketChannel getChannel() {\n+            if (!socketChannel.isOpen()) {\n+                try {\n+                    socketChannel = setupChannel();\n+                } catch (IOException e) {\n+                    logger.debug(\"Couldn't open SocketChannel.{}\", e.getMessage());\n+                }\n+            }\n+            return socketChannel;\n+        }\n+\n+        public boolean isChannelOpen() {\n+            return socketChannel.isOpen();\n+        }\n+\n+        private SocketChannel setupChannel() throws IOException {\n+            SocketChannel channel = SocketChannel.open();\n+            if (!openComs()) {\n+                throw new IOException(\"Open coms failed\");\n+            }\n+            if (!setupConnection(channel)) {\n+                throw new IOException(\"Setup connection failed\");\n+            }\n+            updateState(CHANNEL_CONNECT, OnOffType.ON);\n+            return channel;\n+        }\n+\n+        @Override\n+        public void run() {\n+            SocketChannel channel = socketChannel;\n+            final ByteBuffer readBuffer = ByteBuffer.allocate(512).order(ByteOrder.LITTLE_ENDIAN);\n+            try {\n+                while (channel.read(readBuffer) > 0) {\n+                    ByteBuffer messBuffer = ps4Crypto.decryptPacket(readBuffer);\n+                    readBuffer.position(0);\n+                    PS4Command lastCommand = parseResponsePacket(messBuffer);\n+\n+                    if (lastCommand == PS4Command.SERVER_STATUS_RSP) {\n+                        if (oskOpen && isLinked(CHANNEL_OSK_TEXT)) {\n+                            sendOSKStart();\n+                        } else {\n+                            sendStatus();\n+                        }\n+                    }\n+                }\n+            } catch (IOException e) {\n+                logger.debug(\"Connection read exception: {}\", e.getMessage());\n+            } finally {\n+                try {\n+                    channel.close();\n+                } catch (IOException e) {\n+                    logger.debug(\"Connection close exception: {}\", e.getMessage());\n+                }\n+            }\n+            updateState(CHANNEL_CONNECT, OnOffType.OFF);\n+            logger.debug(\"SocketHandler done.\");\n+            ps4Crypto.clearCiphers();\n+            loggedIn = false;\n+        }\n+    }\n+\n+    private @Nullable PS4Command parseResponsePacket(ByteBuffer rBuffer) {\n+        rBuffer.rewind();\n+        final int buffSize = rBuffer.remaining();\n+        final int size = rBuffer.getInt();\n+        if (size > buffSize || size < 12) {\n+            logger.debug(\"Response size ({}) not good, buffer size ({}).\", size, buffSize);\n+            return null;\n+        }\n+        int cmdValue = rBuffer.getInt();\n+        int statValue = rBuffer.getInt();\n+        PS4ErrorStatus status = PS4ErrorStatus.valueOfTag(statValue);\n+        PS4Command command = PS4Command.valueOfTag(cmdValue);\n+        byte[] respBuff = new byte[size];\n+        rBuffer.rewind();\n+        rBuffer.get(respBuff);\n+        if (command != null) {\n+            if (status == null) {\n+                logger.debug(\"Resp; size:{}, command:{}, statValue:{}, data:{}.\", size, command, statValue, respBuff);\n+            } else {\n+                logger.debug(\"Resp; size:{}, command:{}, status:{}, data:{}.\", size, command, status, respBuff);\n+            }\n+            switch (command) {\n+                case LOGIN_RSP:\n+                    if (status == null) {\n+                        logger.debug(\"Unhandled Login status value: {}\", statValue);\n+                        return command;\n+                    }\n+                    // Read login response\n+                    switch (status) {\n+                        case STATUS_OK:\n+                            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, status.message);\n+                            loggedIn = true;\n+                            if (isLinked(CHANNEL_2ND_SCREEN)) {\n+                                scheduler.execute(() -> {\n+                                    ByteBuffer outPacket = PS4PacketHandler\n+                                            .makeClientIDPacket(\"com.playstation.mobile2ndscreen\", \"18.9.3\");\n+                                    sendPacketEncrypted(outPacket, false);\n+                                });\n+                            }\n+                            break;\n+                        case STATUS_NOT_PAIRED:\n+                            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.CONFIGURATION_PENDING, status.message);\n+                            loggedIn = false;\n+                            break;\n+                        case STATUS_MISSING_PAIRING_CODE:\n+                        case STATUS_MISSING_PASS_CODE:\n+                        case STATUS_WRONG_PAIRING_CODE:\n+                        case STATUS_WRONG_PASS_CODE:\n+                        case STATUS_WRONG_USER_CREDENTIAL:\n+                            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.CONFIGURATION_ERROR, status.message);\n+                            loggedIn = false;\n+                            logger.debug(\"Not logged in: {}\", status.message);\n+                            break;\n+                        case STATUS_CAN_NOT_PLAY_NOW:\n+                        case STATUS_CLOSE_OTHER_APP:\n+                        case STATUS_COMMAND_NOT_GOOD:\n+                        case STATUS_COULD_NOT_LOG_IN:\n+                        case STATUS_DO_LOGIN:\n+                        case STATUS_MAX_USERS:\n+                        case STATUS_REGISTER_DEVICE_OVER:\n+                        case STATUS_RESTART_APP:\n+                        case STATUS_SOMEONE_ELSE_USING:\n+                        case STATUS_UPDATE_APP:\n+                        case STATUS_UPDATE_PS4:\n+                            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, status.message);\n+                            loggedIn = false;\n+                            logger.debug(\"Not logged in: {}\", status.message);\n+                            break;\n+                        default:\n+                            logger.debug(\"Unhandled Login response status:{}, message:{}\", status, status.message);\n+                            break;\n+                    }\n+                    break;\n+                case APP_START_RSP:\n+                    if (status != null && status != PS4ErrorStatus.STATUS_OK) {\n+                        logger.debug(\"App start response: {}\", status.message);\n+                    }\n+                    break;\n+                case STANDBY_RSP:\n+                    if (status != null && status != PS4ErrorStatus.STATUS_OK) {\n+                        logger.debug(\"Standby response: {}\", status.message);\n+                    }\n+                    break;\n+                case SERVER_STATUS_RSP:\n+                    if ((statValue & 4) != 0) {\n+                        oskOpen = true;\n+                    } else {\n+                        if (oskOpen) {\n+                            updateState(CHANNEL_OSK_TEXT, StringType.valueOf(\"\"));\n+                        }\n+                        oskOpen = false;\n+                    }\n+                    logger.debug(\"Server status value:{}\", statValue);\n+                    break;\n+                case HTTPD_STATUS_RSP:\n+                    String httpdStat = PS4PacketHandler.parseHTTPdPacket(rBuffer);\n+                    logger.debug(\"HTTPd Response; {}\", httpdStat);\n+                    String secondScrStr = \"\";\n+                    int httpStatus = rBuffer.getInt(8);\n+                    int port = rBuffer.getInt(12);\n+                    if (httpStatus != 0 && port != 0) {\n+                        secondScrStr = \"http://\" + config.ipAddress + \":\" + Integer.toString(port);\n+                    }\n+                    updateState(CHANNEL_2ND_SCREEN, StringType.valueOf(secondScrStr));\n+                    break;\n+                case OSK_CHANGE_STRING_REQ:\n+                    String oskText = PS4PacketHandler.parseOSKStringChangePacket(rBuffer);\n+                    updateState(CHANNEL_OSK_TEXT, StringType.valueOf(oskText));\n+                    break;\n+                case OSK_START_RSP:\n+                case OSK_CONTROL_REQ:\n+                case COMMENT_VIEWER_START_RESULT:\n+                case SCREEN_SHOT_RSP:\n+                case APP_START2_RSP:\n+                case LOGOUT_RSP:\n+                    break;\n+                default:\n+                    logger.debug(\"Unknown response, command:{}. Missing case.\", command);\n+                    break;\n+            }\n+        } else {\n+            logger.debug(\"Unknown resp-cmd, size:{}, command:{}, status:{}, data:{}.\", size, cmdValue, statValue,\n+                    respBuff);\n+        }\n+        return command;\n+    }\n+\n+    private SocketChannel getConnection() throws IOException {\n+        return getConnection(true);\n+    }\n+\n+    private SocketChannel getConnection(boolean requiresLogin) throws IOException {\n+        SocketChannel channel = null;\n+        SocketChannelHandler handler = socketChannelHandler;\n+        if (handler == null || !handler.isChannelOpen()) {\n+            try {\n+                handler = new SocketChannelHandler();\n+                socketChannelHandler = handler;\n+            } catch (IOException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                throw e;\n+            }\n+        }\n+        channel = handler.getChannel();\n+        if (!loggedIn && requiresLogin) {\n+            login(channel);\n+        }\n+        return channel;\n+    }\n+\n+    private void sendPacketToPS4(ByteBuffer packet, SocketChannel channel, boolean encrypted, boolean restartTimeout) {\n+        PS4Command cmd = PS4Command.valueOfTag(packet.getInt(4));\n+        logger.debug(\"Sending {} packet.\", cmd);\n+        try {\n+            if (encrypted) {\n+                ByteBuffer outPacket = ps4Crypto.encryptPacket(packet);\n+                channel.write(outPacket);\n+            } else {\n+                channel.write(packet);\n+            }\n+            if (restartTimeout) {\n+                setupConnectionTimeout(config.connectionTimeout);\n+            }\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        }\n+    }\n+\n+    private void sendPacketEncrypted(ByteBuffer packet, SocketChannel channel) {\n+        sendPacketToPS4(packet, channel, true, true);\n+    }\n+\n+    private void sendPacketEncrypted(ByteBuffer packet) {\n+        sendPacketEncrypted(packet, true);\n+    }\n+\n+    private void sendPacketEncrypted(ByteBuffer packet, boolean requiresLogin) {\n+        try {\n+            SocketChannel channel = getConnection(requiresLogin);\n+            if (requiresLogin && !loggedIn) {\n+                scheduler.schedule(() -> sendPacketToPS4(packet, channel, true, requiresLogin), 250,\n+                        TimeUnit.MILLISECONDS);\n+            } else {\n+                sendPacketToPS4(packet, channel, true, requiresLogin);\n+            }\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * This is used as a heart beat to let the PS4 know that we are still listening.\n+     */\n+    private void sendStatus() {\n+        ByteBuffer outPacket = PS4PacketHandler.makeStatusPacket(0);\n+        sendPacketEncrypted(outPacket, false);\n+    }\n+\n+    private void login(SocketChannel channel) {\n+        // Send login request\n+        ByteBuffer outPacket = PS4PacketHandler.makeLoginPacket(config.userCredential, config.passCode,\n+                config.pairingCode);\n+        sendPacketEncrypted(outPacket, channel);\n+    }\n+\n+    private void login() {\n+        try {\n+            SocketChannel channel = getConnection(false);\n+            login(channel);\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * This closes the connection with the PS4.\n+     */\n+    private void sendByeBye() {\n+        ByteBuffer outPacket = PS4PacketHandler.makeByebyePacket();\n+        sendPacketEncrypted(outPacket, false);\n+    }\n+\n+    private void turnOnPS4() {\n+        wakeUpPS4();\n+        scheduler.schedule(this::waitAndConnectToPS4, 13, TimeUnit.SECONDS);\n+    }\n+\n+    private void waitAndConnectToPS4() {\n+        try {\n+            getConnection();\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        }\n+    }\n+\n+    private void sendStandby() {\n+        ByteBuffer outPacket = PS4PacketHandler.makeStandbyPacket();\n+        sendPacketEncrypted(outPacket);\n+    }\n+\n+    /**\n+     * Ask PS4 if the OSK is open so we can get and set text.\n+     */\n+    private void sendOSKStart() {\n+        ByteBuffer outPacket = PS4PacketHandler.makeOSKStartPacket();\n+        sendPacketEncrypted(outPacket);\n+    }\n+\n+    /**\n+     * Sets the entire OSK string on the PS4.\n+     *\n+     * @param text The text to set in the OSK.\n+     */\n+    private void setOSKText(String text) {\n+        logger.debug(\"Sending osk text packet,\\\"{}\\\"\", text);\n+        ByteBuffer outPacket = PS4PacketHandler.makeOSKStringChangePacket(text);\n+        sendPacketEncrypted(outPacket);\n+    }\n+\n+    /**\n+     * Tries to start an application on the PS4.\n+     *\n+     * @param applicationId The unique id for the application (CUSAxxxxx).\n+     */\n+    private void startApplication(String applicationId) {\n+        ByteBuffer outPacket = PS4PacketHandler.makeApplicationPacket(applicationId);\n+        sendPacketEncrypted(outPacket);\n+    }\n+\n+    private void sendRemoteKey(int pushedKey) {\n+        try {\n+            SocketChannelHandler scHandler = socketChannelHandler;\n+            int preWait = (scHandler == null || !loggedIn) ? POST_CONNECT_SENDKEY_DELAY_MS : 0;\n+            SocketChannel channel = getConnection();\n+\n+            scheduler.schedule(() -> {\n+                ByteBuffer outPacket = PS4PacketHandler.makeRemoteControlPacket(PS4_KEY_OPEN_RC);\n+                sendPacketEncrypted(outPacket, channel);\n+\n+                scheduler.schedule(() -> {\n+                    // Send remote key\n+                    ByteBuffer keyPacket = PS4PacketHandler.makeRemoteControlPacket(pushedKey);\n+                    sendPacketEncrypted(keyPacket, channel);\n+\n+                    scheduler.schedule(() -> {\n+                        ByteBuffer offPacket = PS4PacketHandler.makeRemoteControlPacket(PS4_KEY_OFF);\n+                        sendPacketEncrypted(offPacket, channel);\n+\n+                        scheduler.schedule(() -> {\n+                            ByteBuffer closePacket = PS4PacketHandler.makeRemoteControlPacket(PS4_KEY_CLOSE_RC);\n+                            sendPacketEncrypted(closePacket, channel);\n+                        }, MIN_SENDKEY_DELAY_MS, TimeUnit.MILLISECONDS);\n+\n+                    }, MIN_HOLDKEY_DELAY_MS, TimeUnit.MILLISECONDS);\n+\n+                }, MIN_SENDKEY_DELAY_MS, TimeUnit.MILLISECONDS);\n+\n+            }, preWait, TimeUnit.MILLISECONDS);\n+\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        }\n+    }\n+\n+    private void parseSearchResponse(DatagramPacket packet) {\n+        byte[] data = packet.getData();\n+        String message = new String(data, StandardCharsets.UTF_8);\n+        String applicationName = \"\";\n+        String applicationId = \"\";\n+\n+        String[] rowStrings = message.trim().split(\"\\\\r?\\\\n\");\n+        for (String row : rowStrings) {\n+            int index = row.indexOf(':');\n+            if (index == -1) {\n+                OnOffType power = null;\n+                if (row.contains(\"200\")) {\n+                    power = OnOffType.ON;\n+                } else if (row.contains(\"620\")) {\n+                    power = OnOffType.OFF;\n+                }\n+                if (power != null) {\n+                    updateState(CHANNEL_POWER, power);\n+                    if (!currentPower.equals(power)) {\n+                        currentPower = power;\n+                        if (power.equals(OnOffType.ON) && config.autoConnect) {\n+                            SocketChannelHandler scHandler = socketChannelHandler;\n+                            if (scHandler == null || !loggedIn) {\n+                                logger.debug(\"Trying to login after power on.\");\n+                                scheduler.schedule(() -> login(), 20, TimeUnit.SECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a8c66b99af1137f6fe388c6072f14876186d7879"}, "originalPosition": 783}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc0MTIzMA==", "bodyText": "See above. Logging to info.", "url": "https://github.com/openhab/openhab-addons/pull/8585#discussion_r499741230", "createdAt": "2020-10-05T16:56:44Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.playstation/src/main/java/org/openhab/binding/playstation/internal/discovery/PlayStationDiscovery.java", "diffHunk": "@@ -0,0 +1,475 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.playstation.internal.discovery;\n+\n+import static org.openhab.binding.playstation.internal.PlayStationBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.net.NetworkAddressService;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.util.HexUtils;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link PlayStationDiscovery} is responsible for discovering\n+ * all PS4 devices\n+ *\n+ * @author Fredrik Ahlstr\u00f6m - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = { DiscoveryService.class, PlayStationDiscovery.class }, configurationPid = \"binding.playstation\")\n+public class PlayStationDiscovery extends AbstractDiscoveryService {\n+\n+    private final Logger logger = LoggerFactory.getLogger(PlayStationDiscovery.class);\n+\n+    private static final int DISCOVERY_TIMEOUT_SECONDS = 2;\n+\n+    private @Nullable NetworkAddressService networkAS;\n+\n+    public PlayStationDiscovery() {\n+        super(SUPPORTED_THING_TYPES_UIDS, DISCOVERY_TIMEOUT_SECONDS * 2, true);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Updating discovered things (new scan)\");\n+        discover();\n+        discoverPS3();\n+    }\n+\n+    @Reference\n+    public void bindNetworkAddressService(NetworkAddressService network) {\n+        networkAS = network;\n+    }\n+\n+    private @Nullable InetAddress getBroadcastAdress() {\n+        NetworkAddressService nwService = networkAS;\n+        if (nwService != null) {\n+            try {\n+                String address = nwService.getConfiguredBroadcastAddress();\n+                if (address != null) {\n+                    return InetAddress.getByName(address);\n+                } else {\n+                    return InetAddress.getByName(\"255.255.255.255\");\n+                }\n+            } catch (UnknownHostException e) {\n+                // We catch errors later.\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private @Nullable InetAddress getIPv4Adress() {\n+        NetworkAddressService nwService = networkAS;\n+        if (nwService != null) {\n+            try {\n+                String address = nwService.getPrimaryIpv4HostAddress();\n+                if (address != null) {\n+                    return InetAddress.getByName(address);\n+                }\n+            } catch (UnknownHostException e) {\n+                // We catch errors later.\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private synchronized void discover() {\n+        logger.debug(\"Trying to discover all PS4 devices\");\n+\n+        try (DatagramSocket socket = new DatagramSocket(0, getIPv4Adress())) {\n+            socket.setBroadcast(true);\n+            socket.setSoTimeout(DISCOVERY_TIMEOUT_SECONDS * 1000);\n+\n+            InetAddress bcAddress = getBroadcastAdress();\n+\n+            // send discover\n+            byte[] discover = \"SRCH * HTTP/1.1\\ndevice-discovery-protocol-version:00020020\\n\".getBytes();\n+            DatagramPacket packet = new DatagramPacket(discover, discover.length, bcAddress, DEFAULT_BROADCAST_PORT);\n+            socket.send(packet);\n+            logger.debug(\"Discover message sent: '{}'\", discover);\n+\n+            // wait for responses\n+            while (true) {\n+                byte[] rxbuf = new byte[256];\n+                packet = new DatagramPacket(rxbuf, rxbuf.length);\n+                try {\n+                    socket.receive(packet);\n+                    parsePS4Packet(packet);\n+                } catch (SocketTimeoutException e) {\n+                    break; // leave the endless loop\n+                }\n+            }\n+        } catch (IOException e) {\n+            logger.debug(\"No PS4 device found. Diagnostic: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private synchronized void discoverPS3() {\n+        logger.trace(\"Trying to discover all PS3 devices that have \\\"Connect PS Vita System Using Network\\\" on.\");\n+\n+        InetAddress bcAddress = getBroadcastAdress();\n+        InetAddress localAddress = getIPv4Adress();\n+\n+        if (localAddress == null || bcAddress == null) {\n+            logger.info(\"No IP/Broadcast address found. Make sure OpenHab is configured!\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a8c66b99af1137f6fe388c6072f14876186d7879"}, "originalPosition": 145}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1b5efd6b29b01ff1b2384e8ae94061d10ad8ae41", "author": {"user": {"login": "FluBBaOfWard", "name": "Fredrik Ahlstr\u00f6m"}}, "url": "https://github.com/openhab/openhab-addons/commit/1b5efd6b29b01ff1b2384e8ae94061d10ad8ae41", "committedDate": "2020-10-06T18:29:21Z", "message": "[playstation] Fixed requested changes from the pr.\n\nSigned-off-by: Fredrik Ahlstro\u0308m <fredrikahlstrom75@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAzOTc0MjM1", "url": "https://github.com/openhab/openhab-addons/pull/8585#pullrequestreview-503974235", "createdAt": "2020-10-07T14:58:39Z", "commit": {"oid": "1b5efd6b29b01ff1b2384e8ae94061d10ad8ae41"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA0MjE3OTg2", "url": "https://github.com/openhab/openhab-addons/pull/8585#pullrequestreview-504217986", "createdAt": "2020-10-07T19:54:40Z", "commit": {"oid": "1b5efd6b29b01ff1b2384e8ae94061d10ad8ae41"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QxOTo1NDo0MVrOHeDMxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QyMDo1MTo0MFrOHeFEsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI3MTc1MQ==", "bodyText": "This type of nested delayed scheduling is what happens when use of sleep is forbidden. I'd almost prefer you using sleep here instead in order for the code to become linear, but sleep is only allowed on executors that your handler is managing and scheduler isn't one of them.\nThe biggest drawback of this nested scheduler structure is that you can't cancel these chain of commands once it gets started. Cancelling async tasks is a required part of cleanup when the handler is getting disposed of.\nI think the simplest and cleanest approach would be to manage your own ExecutorService instance in your handler which you can create through the Executors utility functions. Just make sure to use new NamedThreadFactory(<id>, true) for the ThreadFactory parameter. <id> can be any String value that you want, but since it is used as the part of the thread name you should make sure that you make it some value that can easily be tied back to this binding.\nThen you can rewrite this logic to use sleep inside of a lambda. Just make sure to exit early if an interrupt is received.\nprivate @Nullable ExecutorService executor;\nprivate @Nullable Future<?> sendKeyFuture;\n...\npublic void initialize(){\n...\n    executor = Executors.<you decide which method>;\n...\n}\n\npublic void dispose(){\n...\n    dispose(sendKeyFuture);\n    dispose(executor);\n...\n}\n\nprivate static void dispose(@Nullable Future<?> future){\n    if(future != null){\n        future.cancel(true);\n    }\n}\nprivate static void dispose(@Nullable ExecutorService executor){\n    if(executor != null){\n        executor.shutdownNow();\n    }\n}\n\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        scheduler.schedule(() -> {\n          \n          \n            \n                            ByteBuffer outPacket = PS4PacketHandler.makeRemoteControlPacket(PS4_KEY_OPEN_RC);\n          \n          \n            \n                            sendPacketEncrypted(outPacket, channel);\n          \n          \n            \n            \n          \n          \n            \n                            scheduler.schedule(() -> {\n          \n          \n            \n                                // Send remote key\n          \n          \n            \n                                ByteBuffer keyPacket = PS4PacketHandler.makeRemoteControlPacket(pushedKey);\n          \n          \n            \n                                sendPacketEncrypted(keyPacket, channel);\n          \n          \n            \n            \n          \n          \n            \n                                scheduler.schedule(() -> {\n          \n          \n            \n                                    ByteBuffer offPacket = PS4PacketHandler.makeRemoteControlPacket(PS4_KEY_OFF);\n          \n          \n            \n                                    sendPacketEncrypted(offPacket, channel);\n          \n          \n            \n            \n          \n          \n            \n                                    scheduler.schedule(() -> {\n          \n          \n            \n                                        ByteBuffer closePacket = PS4PacketHandler.makeRemoteControlPacket(PS4_KEY_CLOSE_RC);\n          \n          \n            \n                                        sendPacketEncrypted(closePacket, channel);\n          \n          \n            \n                                    }, MIN_SENDKEY_DELAY_MS, TimeUnit.MILLISECONDS);\n          \n          \n            \n            \n          \n          \n            \n                                }, MIN_HOLDKEY_DELAY_MS, TimeUnit.MILLISECONDS);\n          \n          \n            \n            \n          \n          \n            \n                            }, MIN_SENDKEY_DELAY_MS, TimeUnit.MILLISECONDS);\n          \n          \n            \n            \n          \n          \n            \n                        }, preWait, TimeUnit.MILLISECONDS);\n          \n          \n            \n                Future<?> sendKeyFuture = executor.submit(() -> {\n          \n          \n            \n                    try{\n          \n          \n            \n                        Thread.sleep(preWait);\n          \n          \n            \n                        ByteBuffer outPacket = PS4PacketHandler.makeRemoteControlPacket(PS4_KEY_OPEN_RC);\n          \n          \n            \n                        sendPacketEncrypted(outPacket, channel);\n          \n          \n            \n                        Thread.sleep(MIN_SENDKEY_DELAY_MS);\n          \n          \n            \n                        \n          \n          \n            \n                        ByteBuffer keyPacket = PS4PacketHandler.makeRemoteControlPacket(pushedKey);\n          \n          \n            \n                        sendPacketEncrypted(keyPacket, channel);\n          \n          \n            \n                        Thread.sleep(MIN_HOLDKEY_DELAY_MS);\n          \n          \n            \n                        \n          \n          \n            \n                        ByteBuffer offPacket = PS4PacketHandler.makeRemoteControlPacket(PS4_KEY_OFF);\n          \n          \n            \n                        sendPacketEncrypted(offPacket, channel);\n          \n          \n            \n                        Thread.sleep(MIN_SENDKEY_DELAY_MS);\n          \n          \n            \n                        \n          \n          \n            \n                        ByteBuffer closePacket = PS4PacketHandler.makeRemoteControlPacket(PS4_KEY_CLOSE_RC);\n          \n          \n            \n                        sendPacketEncrypted(closePacket, channel);\n          \n          \n            \n                    }catch(InterruptedException ex){\n          \n          \n            \n                        //do nothing, just exit early\n          \n          \n            \n                    }\n          \n          \n            \n                });\n          \n      \n    \n    \n  \n\nJust to clarify, in general sleep should be avoided if possible, but I think this circumstance is an exception since you have a series of chained operations that each need to be delayed from eachother.", "url": "https://github.com/openhab/openhab-addons/pull/8585#discussion_r501271751", "createdAt": "2020-10-07T19:54:41Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.playstation/src/main/java/org/openhab/binding/playstation/internal/PS4Handler.java", "diffHunk": "@@ -0,0 +1,852 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.playstation.internal;\n+\n+import static org.openhab.binding.playstation.internal.PlayStationBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.UnknownHostException;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.channels.SocketChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.playstation.internal.discovery.PlayStationDiscovery;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.i18n.LocaleProvider;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.net.NetworkAddressService;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link PS4Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Fredrik Ahlstr\u00f6m - Initial contribution\n+ */\n+@NonNullByDefault\n+public class PS4Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(PS4Handler.class);\n+    private final PS4Crypto ps4Crypto = new PS4Crypto();\n+    private static final int SOCKET_TIMEOUT_SECONDS = 5;\n+    /** Time after connect that we can start to send key events, milli seconds */\n+    private static final int POST_CONNECT_SENDKEY_DELAY_MS = 500;\n+    /** Minimum delay between sendKey sends, milli seconds */\n+    private static final int MIN_SENDKEY_DELAY_MS = 250;\n+    /** Minimum delay after Key set, milli seconds */\n+    private static final int MIN_HOLDKEY_DELAY_MS = 300;\n+\n+    private PS4Configuration config = new PS4Configuration();\n+\n+    private final @Nullable LocaleProvider localeProvider;\n+    private final @Nullable NetworkAddressService networkAS;\n+    private @Nullable ScheduledFuture<?> refreshTimer;\n+    private @Nullable ScheduledFuture<?> timeoutTimer;\n+    private @Nullable SocketChannelHandler socketChannelHandler;\n+    private @Nullable InetAddress localAddress;\n+\n+    // State of PS4\n+    private String currentApplication = \"\";\n+    private String currentApplicationId = \"\";\n+    private OnOffType currentPower = OnOffType.OFF;\n+    private State currentArtwork = UnDefType.UNDEF;\n+    private int currentComPort = DEFAULT_COMMUNICATION_PORT;\n+\n+    boolean loggedIn = false;\n+    boolean oskOpen = false;\n+\n+    public PS4Handler(Thing thing, LocaleProvider locProvider, NetworkAddressService network) {\n+        super(thing);\n+        localeProvider = locProvider;\n+        networkAS = network;\n+    }\n+\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        super.handleConfigurationUpdate(configurationParameters);\n+        figureOutLocalIP();\n+        SocketChannelHandler scHandler = socketChannelHandler;\n+        if (!config.pairingCode.isEmpty() && (scHandler == null || !loggedIn)) {\n+            // Try to log in then remove pairing code as it's one use only.\n+            scheduler.execute(() -> {\n+                login();\n+                Configuration editedConfig = editConfiguration();\n+                editedConfig.put(PAIRING_CODE, \"\");\n+                updateConfiguration(editedConfig);\n+            });\n+        }\n+        setupConnectionTimeout(config.connectionTimeout);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            refreshFromState(channelUID);\n+        } else {\n+            if (command instanceof StringType) {\n+                switch (channelUID.getId()) {\n+                    case CHANNEL_APPLICATION_ID:\n+                        if (!currentApplicationId.equals(((StringType) command).toString())) {\n+                            updateApplicationTitleid(((StringType) command).toString());\n+                            startApplication(currentApplicationId);\n+                        }\n+                        break;\n+                    case CHANNEL_OSK_TEXT:\n+                        setOSKText(((StringType) command).toString());\n+                        break;\n+                    case CHANNEL_SEND_KEY:\n+                        int ps4Key = 0;\n+                        switch (((StringType) command).toString()) {\n+                            case SEND_KEY_UP:\n+                                ps4Key = PS4_KEY_UP;\n+                                break;\n+                            case SEND_KEY_DOWN:\n+                                ps4Key = PS4_KEY_DOWN;\n+                                break;\n+                            case SEND_KEY_RIGHT:\n+                                ps4Key = PS4_KEY_RIGHT;\n+                                break;\n+                            case SEND_KEY_LEFT:\n+                                ps4Key = PS4_KEY_LEFT;\n+                                break;\n+                            case SEND_KEY_ENTER:\n+                                ps4Key = PS4_KEY_ENTER;\n+                                break;\n+                            case SEND_KEY_BACK:\n+                                ps4Key = PS4_KEY_BACK;\n+                                break;\n+                            case SEND_KEY_OPTION:\n+                                ps4Key = PS4_KEY_OPTION;\n+                                break;\n+                            case SEND_KEY_PS:\n+                                ps4Key = PS4_KEY_PS;\n+                                break;\n+                            default:\n+                                break;\n+                        }\n+                        if (ps4Key != 0) {\n+                            sendRemoteKey(ps4Key);\n+                        }\n+                        break;\n+                    default:\n+                        break;\n+                }\n+            } else if (command instanceof OnOffType) {\n+                OnOffType onOff = (OnOffType) command;\n+                switch (channelUID.getId()) {\n+                    case CHANNEL_POWER:\n+                        if (currentPower != onOff) {\n+                            currentPower = onOff;\n+                            if (currentPower.equals(OnOffType.ON)) {\n+                                turnOnPS4();\n+                            } else if (currentPower.equals(OnOffType.OFF)) {\n+                                sendStandby();\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_CONNECT:\n+                        boolean connected = socketChannelHandler != null && socketChannelHandler.isChannelOpen();\n+                        if (connected && onOff.equals(OnOffType.OFF)) {\n+                            sendByeBye();\n+                        } else if (!connected && onOff.equals(OnOffType.ON)) {\n+                            scheduler.execute(() -> login());\n+                        }\n+                        break;\n+                    default:\n+                        break;\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(PS4Configuration.class);\n+\n+        figureOutLocalIP();\n+        updateStatus(ThingStatus.UNKNOWN);\n+        setupRefreshTimer();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        ScheduledFuture<?> timer = refreshTimer;\n+        if (timer != null) {\n+            timer.cancel(false);\n+            refreshTimer = null;\n+        }\n+        timer = timeoutTimer;\n+        if (timer != null) {\n+            timer.cancel(false);\n+            timeoutTimer = null;\n+        }\n+        stopConnection();\n+    }\n+\n+    /**\n+     * Tries to figure out a local IP that can communicate with the PS4.\n+     */\n+    private void figureOutLocalIP() {\n+        if (!config.outboundIP.trim().isEmpty()) {\n+            try {\n+                localAddress = InetAddress.getByName(config.outboundIP);\n+                logger.debug(\"Outbound local IP.\\\"{}\\\"\", localAddress);\n+                return;\n+            } catch (UnknownHostException e) {\n+                // This is expected\n+            }\n+        }\n+        NetworkAddressService network = networkAS;\n+        String adr = (network != null) ? network.getPrimaryIpv4HostAddress() : null;\n+        if (adr != null) {\n+            try {\n+                localAddress = InetAddress.getByName(adr);\n+            } catch (UnknownHostException e) {\n+                // Ignore, just let the socket use whatever.\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Sets up a timer for querying the PS4 (using the scheduler) every 10 seconds.\n+     */\n+    private void setupRefreshTimer() {\n+        final ScheduledFuture<?> timer = refreshTimer;\n+        if (timer != null) {\n+            timer.cancel(false);\n+        }\n+        refreshTimer = scheduler.scheduleWithFixedDelay(this::updateAllChannels, 0, 10, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Sets up a timer for stopping the connection to the PS4 (using the scheduler) with the given time.\n+     *\n+     * @param waitTime The time in seconds before the connection is stopped.\n+     */\n+    private void setupConnectionTimeout(int waitTime) {\n+        final ScheduledFuture<?> timer = timeoutTimer;\n+        if (timer != null) {\n+            timer.cancel(false);\n+        }\n+        if (waitTime > 0) {\n+            timeoutTimer = scheduler.schedule(this::stopConnection, waitTime, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    private void refreshFromState(ChannelUID channelUID) {\n+        switch (channelUID.getId()) {\n+            case CHANNEL_POWER:\n+                updateState(channelUID, currentPower);\n+                break;\n+            case CHANNEL_APPLICATION_NAME:\n+                updateState(channelUID, StringType.valueOf(currentApplication));\n+                break;\n+            case CHANNEL_APPLICATION_ID:\n+                updateState(channelUID, StringType.valueOf(currentApplicationId));\n+                break;\n+            case CHANNEL_APPLICATION_IMAGE:\n+                updateApplicationTitleid(currentApplicationId);\n+                updateState(channelUID, currentArtwork);\n+                break;\n+            case CHANNEL_OSK_TEXT:\n+            case CHANNEL_2ND_SCREEN:\n+                updateState(channelUID, UnDefType.UNDEF);\n+                break;\n+            case CHANNEL_CONNECT:\n+                boolean connected = socketChannelHandler != null && socketChannelHandler.isChannelOpen();\n+                updateState(channelUID, OnOffType.from(connected));\n+                break;\n+            case CHANNEL_SEND_KEY:\n+                break;\n+            default:\n+                logger.warn(\"Channel refresh for {} not implemented!\", channelUID.getId());\n+        }\n+    }\n+\n+    private void updateAllChannels() {\n+        try (DatagramSocket socket = new DatagramSocket(0, localAddress)) {\n+            socket.setBroadcast(false);\n+            socket.setSoTimeout(SOCKET_TIMEOUT_SECONDS * 1000);\n+            InetAddress inetAddress = InetAddress.getByName(config.ipAddress);\n+\n+            // send discover\n+            byte[] discover = PS4PacketHandler.makeSearchPacket();\n+            DatagramPacket packet = new DatagramPacket(discover, discover.length, inetAddress, DEFAULT_BROADCAST_PORT);\n+            socket.send(packet);\n+\n+            // wait for response\n+            byte[] rxbuf = new byte[256];\n+            packet = new DatagramPacket(rxbuf, rxbuf.length);\n+            socket.receive(packet);\n+            parseSearchResponse(packet);\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        }\n+    }\n+\n+    private void stopConnection() {\n+        SocketChannelHandler handler = socketChannelHandler;\n+        if (handler != null && handler.isChannelOpen()) {\n+            sendByeBye();\n+        }\n+    }\n+\n+    private void wakeUpPS4() {\n+        logger.debug(\"Waking up PS4...\");\n+        try (DatagramSocket socket = new DatagramSocket(0, localAddress)) {\n+            socket.setBroadcast(false);\n+            InetAddress inetAddress = InetAddress.getByName(config.ipAddress);\n+            // send wake-up\n+            byte[] wakeup = PS4PacketHandler.makeWakeupPacket(config.userCredential);\n+            DatagramPacket packet = new DatagramPacket(wakeup, wakeup.length, inetAddress, DEFAULT_BROADCAST_PORT);\n+            socket.send(packet);\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        }\n+    }\n+\n+    private boolean openComs() {\n+        try (DatagramSocket socket = new DatagramSocket(0, localAddress)) {\n+            socket.setBroadcast(false);\n+            InetAddress inetAddress = InetAddress.getByName(config.ipAddress);\n+            // send launch\n+            byte[] launch = PS4PacketHandler.makeLaunchPacket(config.userCredential);\n+            DatagramPacket packet = new DatagramPacket(launch, launch.length, inetAddress, DEFAULT_BROADCAST_PORT);\n+            socket.send(packet);\n+            Thread.sleep(100);\n+            return true;\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        } catch (InterruptedException e) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    private boolean setupConnection(SocketChannel channel) throws IOException {\n+        logger.debug(\"TCP connecting\");\n+\n+        channel.socket().setSoTimeout(2000);\n+        channel.configureBlocking(true);\n+        channel.connect(new InetSocketAddress(config.ipAddress, currentComPort));\n+\n+        ByteBuffer outPacket = PS4PacketHandler.makeHelloPacket();\n+        sendPacketToPS4(outPacket, channel, false, false);\n+\n+        // Read hello response\n+        final ByteBuffer readBuffer = ByteBuffer.allocate(512).order(ByteOrder.LITTLE_ENDIAN);\n+\n+        int responseLength = channel.read(readBuffer);\n+        if (responseLength > 0) {\n+            ps4Crypto.parseHelloResponsePacket(readBuffer);\n+        } else {\n+            return false;\n+        }\n+\n+        outPacket = ps4Crypto.makeHandshakePacket();\n+        sendPacketToPS4(outPacket, channel, false, false);\n+        return true;\n+    }\n+\n+    private class SocketChannelHandler extends Thread {\n+        private SocketChannel socketChannel;\n+\n+        public SocketChannelHandler() throws IOException {\n+            socketChannel = setupChannel();\n+            loggedIn = false;\n+            oskOpen = false;\n+            start();\n+        }\n+\n+        public SocketChannel getChannel() {\n+            if (!socketChannel.isOpen()) {\n+                try {\n+                    socketChannel = setupChannel();\n+                } catch (IOException e) {\n+                    logger.debug(\"Couldn't open SocketChannel.{}\", e.getMessage());\n+                }\n+            }\n+            return socketChannel;\n+        }\n+\n+        public boolean isChannelOpen() {\n+            return socketChannel.isOpen();\n+        }\n+\n+        private SocketChannel setupChannel() throws IOException {\n+            SocketChannel channel = SocketChannel.open();\n+            if (!openComs()) {\n+                throw new IOException(\"Open coms failed\");\n+            }\n+            if (!setupConnection(channel)) {\n+                throw new IOException(\"Setup connection failed\");\n+            }\n+            updateState(CHANNEL_CONNECT, OnOffType.ON);\n+            return channel;\n+        }\n+\n+        @Override\n+        public void run() {\n+            SocketChannel channel = socketChannel;\n+            final ByteBuffer readBuffer = ByteBuffer.allocate(512).order(ByteOrder.LITTLE_ENDIAN);\n+            try {\n+                while (channel.read(readBuffer) > 0) {\n+                    ByteBuffer messBuffer = ps4Crypto.decryptPacket(readBuffer);\n+                    readBuffer.position(0);\n+                    PS4Command lastCommand = parseResponsePacket(messBuffer);\n+\n+                    if (lastCommand == PS4Command.SERVER_STATUS_RSP) {\n+                        if (oskOpen && isLinked(CHANNEL_OSK_TEXT)) {\n+                            sendOSKStart();\n+                        } else {\n+                            sendStatus();\n+                        }\n+                    }\n+                }\n+            } catch (IOException e) {\n+                logger.debug(\"Connection read exception: {}\", e.getMessage());\n+            } finally {\n+                try {\n+                    channel.close();\n+                } catch (IOException e) {\n+                    logger.debug(\"Connection close exception: {}\", e.getMessage());\n+                }\n+            }\n+            updateState(CHANNEL_CONNECT, OnOffType.OFF);\n+            logger.debug(\"SocketHandler done.\");\n+            ps4Crypto.clearCiphers();\n+            loggedIn = false;\n+        }\n+    }\n+\n+    private @Nullable PS4Command parseResponsePacket(ByteBuffer rBuffer) {\n+        rBuffer.rewind();\n+        final int buffSize = rBuffer.remaining();\n+        final int size = rBuffer.getInt();\n+        if (size > buffSize || size < 12) {\n+            logger.debug(\"Response size ({}) not good, buffer size ({}).\", size, buffSize);\n+            return null;\n+        }\n+        int cmdValue = rBuffer.getInt();\n+        int statValue = rBuffer.getInt();\n+        PS4ErrorStatus status = PS4ErrorStatus.valueOfTag(statValue);\n+        PS4Command command = PS4Command.valueOfTag(cmdValue);\n+        byte[] respBuff = new byte[size];\n+        rBuffer.rewind();\n+        rBuffer.get(respBuff);\n+        if (command != null) {\n+            if (status == null) {\n+                logger.debug(\"Resp; size:{}, command:{}, statValue:{}, data:{}.\", size, command, statValue, respBuff);\n+            } else {\n+                logger.debug(\"Resp; size:{}, command:{}, status:{}, data:{}.\", size, command, status, respBuff);\n+            }\n+            switch (command) {\n+                case LOGIN_RSP:\n+                    if (status == null) {\n+                        logger.debug(\"Unhandled Login status value: {}\", statValue);\n+                        return command;\n+                    }\n+                    // Read login response\n+                    switch (status) {\n+                        case STATUS_OK:\n+                            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, status.message);\n+                            loggedIn = true;\n+                            if (isLinked(CHANNEL_2ND_SCREEN)) {\n+                                scheduler.execute(() -> {\n+                                    ByteBuffer outPacket = PS4PacketHandler\n+                                            .makeClientIDPacket(\"com.playstation.mobile2ndscreen\", \"18.9.3\");\n+                                    sendPacketEncrypted(outPacket, false);\n+                                });\n+                            }\n+                            break;\n+                        case STATUS_NOT_PAIRED:\n+                            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.CONFIGURATION_PENDING, status.message);\n+                            loggedIn = false;\n+                            break;\n+                        case STATUS_MISSING_PAIRING_CODE:\n+                        case STATUS_MISSING_PASS_CODE:\n+                        case STATUS_WRONG_PAIRING_CODE:\n+                        case STATUS_WRONG_PASS_CODE:\n+                        case STATUS_WRONG_USER_CREDENTIAL:\n+                            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.CONFIGURATION_ERROR, status.message);\n+                            loggedIn = false;\n+                            logger.debug(\"Not logged in: {}\", status.message);\n+                            break;\n+                        case STATUS_CAN_NOT_PLAY_NOW:\n+                        case STATUS_CLOSE_OTHER_APP:\n+                        case STATUS_COMMAND_NOT_GOOD:\n+                        case STATUS_COULD_NOT_LOG_IN:\n+                        case STATUS_DO_LOGIN:\n+                        case STATUS_MAX_USERS:\n+                        case STATUS_REGISTER_DEVICE_OVER:\n+                        case STATUS_RESTART_APP:\n+                        case STATUS_SOMEONE_ELSE_USING:\n+                        case STATUS_UPDATE_APP:\n+                        case STATUS_UPDATE_PS4:\n+                            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, status.message);\n+                            loggedIn = false;\n+                            logger.debug(\"Not logged in: {}\", status.message);\n+                            break;\n+                        default:\n+                            logger.debug(\"Unhandled Login response status:{}, message:{}\", status, status.message);\n+                            break;\n+                    }\n+                    break;\n+                case APP_START_RSP:\n+                    if (status != null && status != PS4ErrorStatus.STATUS_OK) {\n+                        logger.debug(\"App start response: {}\", status.message);\n+                    }\n+                    break;\n+                case STANDBY_RSP:\n+                    if (status != null && status != PS4ErrorStatus.STATUS_OK) {\n+                        logger.debug(\"Standby response: {}\", status.message);\n+                    }\n+                    break;\n+                case SERVER_STATUS_RSP:\n+                    if ((statValue & 4) != 0) {\n+                        oskOpen = true;\n+                    } else {\n+                        if (oskOpen) {\n+                            updateState(CHANNEL_OSK_TEXT, StringType.valueOf(\"\"));\n+                        }\n+                        oskOpen = false;\n+                    }\n+                    logger.debug(\"Server status value:{}\", statValue);\n+                    break;\n+                case HTTPD_STATUS_RSP:\n+                    String httpdStat = PS4PacketHandler.parseHTTPdPacket(rBuffer);\n+                    logger.debug(\"HTTPd Response; {}\", httpdStat);\n+                    String secondScrStr = \"\";\n+                    int httpStatus = rBuffer.getInt(8);\n+                    int port = rBuffer.getInt(12);\n+                    if (httpStatus != 0 && port != 0) {\n+                        secondScrStr = \"http://\" + config.ipAddress + \":\" + port;\n+                    }\n+                    updateState(CHANNEL_2ND_SCREEN, StringType.valueOf(secondScrStr));\n+                    break;\n+                case OSK_CHANGE_STRING_REQ:\n+                    String oskText = PS4PacketHandler.parseOSKStringChangePacket(rBuffer);\n+                    updateState(CHANNEL_OSK_TEXT, StringType.valueOf(oskText));\n+                    break;\n+                case OSK_START_RSP:\n+                case OSK_CONTROL_REQ:\n+                case COMMENT_VIEWER_START_RESULT:\n+                case SCREEN_SHOT_RSP:\n+                case APP_START2_RSP:\n+                case LOGOUT_RSP:\n+                    break;\n+                default:\n+                    logger.debug(\"Unknown response, command:{}. Missing case.\", command);\n+                    break;\n+            }\n+        } else {\n+            logger.debug(\"Unknown resp-cmd, size:{}, command:{}, status:{}, data:{}.\", size, cmdValue, statValue,\n+                    respBuff);\n+        }\n+        return command;\n+    }\n+\n+    private SocketChannel getConnection() throws IOException {\n+        return getConnection(true);\n+    }\n+\n+    private SocketChannel getConnection(boolean requiresLogin) throws IOException {\n+        SocketChannel channel = null;\n+        SocketChannelHandler handler = socketChannelHandler;\n+        if (handler == null || !handler.isChannelOpen()) {\n+            try {\n+                handler = new SocketChannelHandler();\n+                socketChannelHandler = handler;\n+            } catch (IOException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                throw e;\n+            }\n+        }\n+        channel = handler.getChannel();\n+        if (!loggedIn && requiresLogin) {\n+            login(channel);\n+        }\n+        return channel;\n+    }\n+\n+    private void sendPacketToPS4(ByteBuffer packet, SocketChannel channel, boolean encrypted, boolean restartTimeout) {\n+        PS4Command cmd = PS4Command.valueOfTag(packet.getInt(4));\n+        logger.debug(\"Sending {} packet.\", cmd);\n+        try {\n+            if (encrypted) {\n+                ByteBuffer outPacket = ps4Crypto.encryptPacket(packet);\n+                channel.write(outPacket);\n+            } else {\n+                channel.write(packet);\n+            }\n+            if (restartTimeout) {\n+                setupConnectionTimeout(config.connectionTimeout);\n+            }\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        }\n+    }\n+\n+    private void sendPacketEncrypted(ByteBuffer packet, SocketChannel channel) {\n+        sendPacketToPS4(packet, channel, true, true);\n+    }\n+\n+    private void sendPacketEncrypted(ByteBuffer packet) {\n+        sendPacketEncrypted(packet, true);\n+    }\n+\n+    private void sendPacketEncrypted(ByteBuffer packet, boolean requiresLogin) {\n+        try {\n+            SocketChannel channel = getConnection(requiresLogin);\n+            if (requiresLogin && !loggedIn) {\n+                scheduler.schedule(() -> sendPacketToPS4(packet, channel, true, requiresLogin), 250,\n+                        TimeUnit.MILLISECONDS);\n+            } else {\n+                sendPacketToPS4(packet, channel, true, requiresLogin);\n+            }\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * This is used as a heart beat to let the PS4 know that we are still listening.\n+     */\n+    private void sendStatus() {\n+        ByteBuffer outPacket = PS4PacketHandler.makeStatusPacket(0);\n+        sendPacketEncrypted(outPacket, false);\n+    }\n+\n+    private void login(SocketChannel channel) {\n+        // Send login request\n+        ByteBuffer outPacket = PS4PacketHandler.makeLoginPacket(config.userCredential, config.passCode,\n+                config.pairingCode);\n+        sendPacketEncrypted(outPacket, channel);\n+    }\n+\n+    private void login() {\n+        try {\n+            SocketChannel channel = getConnection(false);\n+            login(channel);\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * This closes the connection with the PS4.\n+     */\n+    private void sendByeBye() {\n+        ByteBuffer outPacket = PS4PacketHandler.makeByebyePacket();\n+        sendPacketEncrypted(outPacket, false);\n+    }\n+\n+    private void turnOnPS4() {\n+        wakeUpPS4();\n+        scheduler.schedule(this::waitAndConnectToPS4, 13, TimeUnit.SECONDS);\n+    }\n+\n+    private void waitAndConnectToPS4() {\n+        try {\n+            getConnection();\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        }\n+    }\n+\n+    private void sendStandby() {\n+        ByteBuffer outPacket = PS4PacketHandler.makeStandbyPacket();\n+        sendPacketEncrypted(outPacket);\n+    }\n+\n+    /**\n+     * Ask PS4 if the OSK is open so we can get and set text.\n+     */\n+    private void sendOSKStart() {\n+        ByteBuffer outPacket = PS4PacketHandler.makeOSKStartPacket();\n+        sendPacketEncrypted(outPacket);\n+    }\n+\n+    /**\n+     * Sets the entire OSK string on the PS4.\n+     *\n+     * @param text The text to set in the OSK.\n+     */\n+    private void setOSKText(String text) {\n+        logger.debug(\"Sending osk text packet,\\\"{}\\\"\", text);\n+        ByteBuffer outPacket = PS4PacketHandler.makeOSKStringChangePacket(text);\n+        sendPacketEncrypted(outPacket);\n+    }\n+\n+    /**\n+     * Tries to start an application on the PS4.\n+     *\n+     * @param applicationId The unique id for the application (CUSAxxxxx).\n+     */\n+    private void startApplication(String applicationId) {\n+        ByteBuffer outPacket = PS4PacketHandler.makeApplicationPacket(applicationId);\n+        sendPacketEncrypted(outPacket);\n+    }\n+\n+    private void sendRemoteKey(int pushedKey) {\n+        try {\n+            SocketChannelHandler scHandler = socketChannelHandler;\n+            int preWait = (scHandler == null || !loggedIn) ? POST_CONNECT_SENDKEY_DELAY_MS : 0;\n+            SocketChannel channel = getConnection();\n+\n+            scheduler.schedule(() -> {\n+                ByteBuffer outPacket = PS4PacketHandler.makeRemoteControlPacket(PS4_KEY_OPEN_RC);\n+                sendPacketEncrypted(outPacket, channel);\n+\n+                scheduler.schedule(() -> {\n+                    // Send remote key\n+                    ByteBuffer keyPacket = PS4PacketHandler.makeRemoteControlPacket(pushedKey);\n+                    sendPacketEncrypted(keyPacket, channel);\n+\n+                    scheduler.schedule(() -> {\n+                        ByteBuffer offPacket = PS4PacketHandler.makeRemoteControlPacket(PS4_KEY_OFF);\n+                        sendPacketEncrypted(offPacket, channel);\n+\n+                        scheduler.schedule(() -> {\n+                            ByteBuffer closePacket = PS4PacketHandler.makeRemoteControlPacket(PS4_KEY_CLOSE_RC);\n+                            sendPacketEncrypted(closePacket, channel);\n+                        }, MIN_SENDKEY_DELAY_MS, TimeUnit.MILLISECONDS);\n+\n+                    }, MIN_HOLDKEY_DELAY_MS, TimeUnit.MILLISECONDS);\n+\n+                }, MIN_SENDKEY_DELAY_MS, TimeUnit.MILLISECONDS);\n+\n+            }, preWait, TimeUnit.MILLISECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b5efd6b29b01ff1b2384e8ae94061d10ad8ae41"}, "originalPosition": 752}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI4OTUzNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t<parameter name=\"connectionTimeout\" type=\"integer\" min=\"0\">\n          \n          \n            \n            \t\t<parameter name=\"connectionTimeout\" type=\"integer\" min=\"0\" unit=\"s\">", "url": "https://github.com/openhab/openhab-addons/pull/8585#discussion_r501289537", "createdAt": "2020-10-07T20:28:14Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.playstation/src/main/resources/OH-INF/config/config.xml", "diffHunk": "@@ -0,0 +1,69 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<config-description:config-descriptions\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:config-description=\"https://openhab.org/schemas/config-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/config-description/v1.0.0 https://openhab.org/schemas/config-description-1.0.0.xsd\">\n+\n+\t<config-description uri=\"thing-type:playstation:PS3\">\n+\t\t<parameter name=\"ipAddress\" type=\"text\" required=\"true\">\n+\t\t\t<context>network-address</context>\n+\t\t\t<label>IP Address</label>\n+\t\t\t<description>The IP Address of the PlayStation 3.</description>\n+\t\t\t<advanced>true</advanced>\n+\t\t</parameter>\n+\t</config-description>\n+\n+\t<config-description uri=\"thing-type:playstation:PS4\">\n+\t\t<parameter name=\"userCredential\" type=\"text\" required=\"true\" min=\"64\" max=\"64\" pattern=\"[0-9A-Fa-f]*\">\n+\t\t\t<label>User Credential</label>\n+\t\t\t<description>User Credential to Communicate with the PlayStation 4.</description>\n+\t\t</parameter>\n+\t\t<parameter name=\"passCode\" type=\"text\" min=\"4\" max=\"4\" pattern=\"[0-9]*\">\n+\t\t\t<context>password</context>\n+\t\t\t<label>Pass Code</label>\n+\t\t\t<description>Pass Code to Log in to PlayStation 4.</description>\n+\t\t</parameter>\n+\t\t<parameter name=\"pairingCode\" type=\"text\" min=\"8\" max=\"8\" pattern=\"[0-9]*\">\n+\t\t\t<label>Pairing Code</label>\n+\t\t\t<description>Code to Pair openHAB Device to PlayStation 4. Only Needed During Pairing.</description>\n+\t\t</parameter>\n+\t\t<parameter name=\"connectionTimeout\" type=\"integer\" min=\"0\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b5efd6b29b01ff1b2384e8ae94061d10ad8ae41"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI5MjQyNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private synchronized void discover() {\n          \n          \n            \n                private synchronized void discoverPS4() {", "url": "https://github.com/openhab/openhab-addons/pull/8585#discussion_r501292426", "createdAt": "2020-10-07T20:33:31Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.playstation/src/main/java/org/openhab/binding/playstation/internal/discovery/PlayStationDiscovery.java", "diffHunk": "@@ -0,0 +1,475 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.playstation.internal.discovery;\n+\n+import static org.openhab.binding.playstation.internal.PlayStationBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.net.NetworkAddressService;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.util.HexUtils;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link PlayStationDiscovery} is responsible for discovering\n+ * all PS4 devices\n+ *\n+ * @author Fredrik Ahlstr\u00f6m - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = { DiscoveryService.class, PlayStationDiscovery.class }, configurationPid = \"binding.playstation\")\n+public class PlayStationDiscovery extends AbstractDiscoveryService {\n+\n+    private final Logger logger = LoggerFactory.getLogger(PlayStationDiscovery.class);\n+\n+    private static final int DISCOVERY_TIMEOUT_SECONDS = 2;\n+\n+    private @Nullable NetworkAddressService networkAS;\n+\n+    public PlayStationDiscovery() {\n+        super(SUPPORTED_THING_TYPES_UIDS, DISCOVERY_TIMEOUT_SECONDS * 2, true);\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.debug(\"Updating discovered things (new scan)\");\n+        discover();\n+        discoverPS3();\n+    }\n+\n+    @Reference\n+    public void bindNetworkAddressService(NetworkAddressService network) {\n+        networkAS = network;\n+    }\n+\n+    private @Nullable InetAddress getBroadcastAdress() {\n+        NetworkAddressService nwService = networkAS;\n+        if (nwService != null) {\n+            try {\n+                String address = nwService.getConfiguredBroadcastAddress();\n+                if (address != null) {\n+                    return InetAddress.getByName(address);\n+                } else {\n+                    return InetAddress.getByName(\"255.255.255.255\");\n+                }\n+            } catch (UnknownHostException e) {\n+                // We catch errors later.\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private @Nullable InetAddress getIPv4Adress() {\n+        NetworkAddressService nwService = networkAS;\n+        if (nwService != null) {\n+            try {\n+                String address = nwService.getPrimaryIpv4HostAddress();\n+                if (address != null) {\n+                    return InetAddress.getByName(address);\n+                }\n+            } catch (UnknownHostException e) {\n+                // We catch errors later.\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private synchronized void discover() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b5efd6b29b01ff1b2384e8ae94061d10ad8ae41"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI5MzgzOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            @Component(service = { DiscoveryService.class, PlayStationDiscovery.class }, configurationPid = \"binding.playstation\")\n          \n          \n            \n            @Component(service = { DiscoveryService.class, PlayStationDiscovery.class }, configurationPid = \"discovery.playstation\")", "url": "https://github.com/openhab/openhab-addons/pull/8585#discussion_r501293838", "createdAt": "2020-10-07T20:36:14Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.playstation/src/main/java/org/openhab/binding/playstation/internal/discovery/PlayStationDiscovery.java", "diffHunk": "@@ -0,0 +1,475 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.playstation.internal.discovery;\n+\n+import static org.openhab.binding.playstation.internal.PlayStationBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.NetworkInterface;\n+import java.net.SocketTimeoutException;\n+import java.net.UnknownHostException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.net.NetworkAddressService;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.util.HexUtils;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link PlayStationDiscovery} is responsible for discovering\n+ * all PS4 devices\n+ *\n+ * @author Fredrik Ahlstr\u00f6m - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = { DiscoveryService.class, PlayStationDiscovery.class }, configurationPid = \"binding.playstation\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b5efd6b29b01ff1b2384e8ae94061d10ad8ae41"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI5OTQwNw==", "bodyText": "You should keep track of the returned future so that it can be canceled if this handler gets disposed.", "url": "https://github.com/openhab/openhab-addons/pull/8585#discussion_r501299407", "createdAt": "2020-10-07T20:46:02Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.playstation/src/main/java/org/openhab/binding/playstation/internal/PS4Handler.java", "diffHunk": "@@ -0,0 +1,852 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.playstation.internal;\n+\n+import static org.openhab.binding.playstation.internal.PlayStationBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.UnknownHostException;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.channels.SocketChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.playstation.internal.discovery.PlayStationDiscovery;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.i18n.LocaleProvider;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.net.NetworkAddressService;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link PS4Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Fredrik Ahlstr\u00f6m - Initial contribution\n+ */\n+@NonNullByDefault\n+public class PS4Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(PS4Handler.class);\n+    private final PS4Crypto ps4Crypto = new PS4Crypto();\n+    private static final int SOCKET_TIMEOUT_SECONDS = 5;\n+    /** Time after connect that we can start to send key events, milli seconds */\n+    private static final int POST_CONNECT_SENDKEY_DELAY_MS = 500;\n+    /** Minimum delay between sendKey sends, milli seconds */\n+    private static final int MIN_SENDKEY_DELAY_MS = 250;\n+    /** Minimum delay after Key set, milli seconds */\n+    private static final int MIN_HOLDKEY_DELAY_MS = 300;\n+\n+    private PS4Configuration config = new PS4Configuration();\n+\n+    private final @Nullable LocaleProvider localeProvider;\n+    private final @Nullable NetworkAddressService networkAS;\n+    private @Nullable ScheduledFuture<?> refreshTimer;\n+    private @Nullable ScheduledFuture<?> timeoutTimer;\n+    private @Nullable SocketChannelHandler socketChannelHandler;\n+    private @Nullable InetAddress localAddress;\n+\n+    // State of PS4\n+    private String currentApplication = \"\";\n+    private String currentApplicationId = \"\";\n+    private OnOffType currentPower = OnOffType.OFF;\n+    private State currentArtwork = UnDefType.UNDEF;\n+    private int currentComPort = DEFAULT_COMMUNICATION_PORT;\n+\n+    boolean loggedIn = false;\n+    boolean oskOpen = false;\n+\n+    public PS4Handler(Thing thing, LocaleProvider locProvider, NetworkAddressService network) {\n+        super(thing);\n+        localeProvider = locProvider;\n+        networkAS = network;\n+    }\n+\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        super.handleConfigurationUpdate(configurationParameters);\n+        figureOutLocalIP();\n+        SocketChannelHandler scHandler = socketChannelHandler;\n+        if (!config.pairingCode.isEmpty() && (scHandler == null || !loggedIn)) {\n+            // Try to log in then remove pairing code as it's one use only.\n+            scheduler.execute(() -> {\n+                login();\n+                Configuration editedConfig = editConfiguration();\n+                editedConfig.put(PAIRING_CODE, \"\");\n+                updateConfiguration(editedConfig);\n+            });\n+        }\n+        setupConnectionTimeout(config.connectionTimeout);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            refreshFromState(channelUID);\n+        } else {\n+            if (command instanceof StringType) {\n+                switch (channelUID.getId()) {\n+                    case CHANNEL_APPLICATION_ID:\n+                        if (!currentApplicationId.equals(((StringType) command).toString())) {\n+                            updateApplicationTitleid(((StringType) command).toString());\n+                            startApplication(currentApplicationId);\n+                        }\n+                        break;\n+                    case CHANNEL_OSK_TEXT:\n+                        setOSKText(((StringType) command).toString());\n+                        break;\n+                    case CHANNEL_SEND_KEY:\n+                        int ps4Key = 0;\n+                        switch (((StringType) command).toString()) {\n+                            case SEND_KEY_UP:\n+                                ps4Key = PS4_KEY_UP;\n+                                break;\n+                            case SEND_KEY_DOWN:\n+                                ps4Key = PS4_KEY_DOWN;\n+                                break;\n+                            case SEND_KEY_RIGHT:\n+                                ps4Key = PS4_KEY_RIGHT;\n+                                break;\n+                            case SEND_KEY_LEFT:\n+                                ps4Key = PS4_KEY_LEFT;\n+                                break;\n+                            case SEND_KEY_ENTER:\n+                                ps4Key = PS4_KEY_ENTER;\n+                                break;\n+                            case SEND_KEY_BACK:\n+                                ps4Key = PS4_KEY_BACK;\n+                                break;\n+                            case SEND_KEY_OPTION:\n+                                ps4Key = PS4_KEY_OPTION;\n+                                break;\n+                            case SEND_KEY_PS:\n+                                ps4Key = PS4_KEY_PS;\n+                                break;\n+                            default:\n+                                break;\n+                        }\n+                        if (ps4Key != 0) {\n+                            sendRemoteKey(ps4Key);\n+                        }\n+                        break;\n+                    default:\n+                        break;\n+                }\n+            } else if (command instanceof OnOffType) {\n+                OnOffType onOff = (OnOffType) command;\n+                switch (channelUID.getId()) {\n+                    case CHANNEL_POWER:\n+                        if (currentPower != onOff) {\n+                            currentPower = onOff;\n+                            if (currentPower.equals(OnOffType.ON)) {\n+                                turnOnPS4();\n+                            } else if (currentPower.equals(OnOffType.OFF)) {\n+                                sendStandby();\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_CONNECT:\n+                        boolean connected = socketChannelHandler != null && socketChannelHandler.isChannelOpen();\n+                        if (connected && onOff.equals(OnOffType.OFF)) {\n+                            sendByeBye();\n+                        } else if (!connected && onOff.equals(OnOffType.ON)) {\n+                            scheduler.execute(() -> login());\n+                        }\n+                        break;\n+                    default:\n+                        break;\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(PS4Configuration.class);\n+\n+        figureOutLocalIP();\n+        updateStatus(ThingStatus.UNKNOWN);\n+        setupRefreshTimer();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        ScheduledFuture<?> timer = refreshTimer;\n+        if (timer != null) {\n+            timer.cancel(false);\n+            refreshTimer = null;\n+        }\n+        timer = timeoutTimer;\n+        if (timer != null) {\n+            timer.cancel(false);\n+            timeoutTimer = null;\n+        }\n+        stopConnection();\n+    }\n+\n+    /**\n+     * Tries to figure out a local IP that can communicate with the PS4.\n+     */\n+    private void figureOutLocalIP() {\n+        if (!config.outboundIP.trim().isEmpty()) {\n+            try {\n+                localAddress = InetAddress.getByName(config.outboundIP);\n+                logger.debug(\"Outbound local IP.\\\"{}\\\"\", localAddress);\n+                return;\n+            } catch (UnknownHostException e) {\n+                // This is expected\n+            }\n+        }\n+        NetworkAddressService network = networkAS;\n+        String adr = (network != null) ? network.getPrimaryIpv4HostAddress() : null;\n+        if (adr != null) {\n+            try {\n+                localAddress = InetAddress.getByName(adr);\n+            } catch (UnknownHostException e) {\n+                // Ignore, just let the socket use whatever.\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Sets up a timer for querying the PS4 (using the scheduler) every 10 seconds.\n+     */\n+    private void setupRefreshTimer() {\n+        final ScheduledFuture<?> timer = refreshTimer;\n+        if (timer != null) {\n+            timer.cancel(false);\n+        }\n+        refreshTimer = scheduler.scheduleWithFixedDelay(this::updateAllChannels, 0, 10, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Sets up a timer for stopping the connection to the PS4 (using the scheduler) with the given time.\n+     *\n+     * @param waitTime The time in seconds before the connection is stopped.\n+     */\n+    private void setupConnectionTimeout(int waitTime) {\n+        final ScheduledFuture<?> timer = timeoutTimer;\n+        if (timer != null) {\n+            timer.cancel(false);\n+        }\n+        if (waitTime > 0) {\n+            timeoutTimer = scheduler.schedule(this::stopConnection, waitTime, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    private void refreshFromState(ChannelUID channelUID) {\n+        switch (channelUID.getId()) {\n+            case CHANNEL_POWER:\n+                updateState(channelUID, currentPower);\n+                break;\n+            case CHANNEL_APPLICATION_NAME:\n+                updateState(channelUID, StringType.valueOf(currentApplication));\n+                break;\n+            case CHANNEL_APPLICATION_ID:\n+                updateState(channelUID, StringType.valueOf(currentApplicationId));\n+                break;\n+            case CHANNEL_APPLICATION_IMAGE:\n+                updateApplicationTitleid(currentApplicationId);\n+                updateState(channelUID, currentArtwork);\n+                break;\n+            case CHANNEL_OSK_TEXT:\n+            case CHANNEL_2ND_SCREEN:\n+                updateState(channelUID, UnDefType.UNDEF);\n+                break;\n+            case CHANNEL_CONNECT:\n+                boolean connected = socketChannelHandler != null && socketChannelHandler.isChannelOpen();\n+                updateState(channelUID, OnOffType.from(connected));\n+                break;\n+            case CHANNEL_SEND_KEY:\n+                break;\n+            default:\n+                logger.warn(\"Channel refresh for {} not implemented!\", channelUID.getId());\n+        }\n+    }\n+\n+    private void updateAllChannels() {\n+        try (DatagramSocket socket = new DatagramSocket(0, localAddress)) {\n+            socket.setBroadcast(false);\n+            socket.setSoTimeout(SOCKET_TIMEOUT_SECONDS * 1000);\n+            InetAddress inetAddress = InetAddress.getByName(config.ipAddress);\n+\n+            // send discover\n+            byte[] discover = PS4PacketHandler.makeSearchPacket();\n+            DatagramPacket packet = new DatagramPacket(discover, discover.length, inetAddress, DEFAULT_BROADCAST_PORT);\n+            socket.send(packet);\n+\n+            // wait for response\n+            byte[] rxbuf = new byte[256];\n+            packet = new DatagramPacket(rxbuf, rxbuf.length);\n+            socket.receive(packet);\n+            parseSearchResponse(packet);\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        }\n+    }\n+\n+    private void stopConnection() {\n+        SocketChannelHandler handler = socketChannelHandler;\n+        if (handler != null && handler.isChannelOpen()) {\n+            sendByeBye();\n+        }\n+    }\n+\n+    private void wakeUpPS4() {\n+        logger.debug(\"Waking up PS4...\");\n+        try (DatagramSocket socket = new DatagramSocket(0, localAddress)) {\n+            socket.setBroadcast(false);\n+            InetAddress inetAddress = InetAddress.getByName(config.ipAddress);\n+            // send wake-up\n+            byte[] wakeup = PS4PacketHandler.makeWakeupPacket(config.userCredential);\n+            DatagramPacket packet = new DatagramPacket(wakeup, wakeup.length, inetAddress, DEFAULT_BROADCAST_PORT);\n+            socket.send(packet);\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        }\n+    }\n+\n+    private boolean openComs() {\n+        try (DatagramSocket socket = new DatagramSocket(0, localAddress)) {\n+            socket.setBroadcast(false);\n+            InetAddress inetAddress = InetAddress.getByName(config.ipAddress);\n+            // send launch\n+            byte[] launch = PS4PacketHandler.makeLaunchPacket(config.userCredential);\n+            DatagramPacket packet = new DatagramPacket(launch, launch.length, inetAddress, DEFAULT_BROADCAST_PORT);\n+            socket.send(packet);\n+            Thread.sleep(100);\n+            return true;\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        } catch (InterruptedException e) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    private boolean setupConnection(SocketChannel channel) throws IOException {\n+        logger.debug(\"TCP connecting\");\n+\n+        channel.socket().setSoTimeout(2000);\n+        channel.configureBlocking(true);\n+        channel.connect(new InetSocketAddress(config.ipAddress, currentComPort));\n+\n+        ByteBuffer outPacket = PS4PacketHandler.makeHelloPacket();\n+        sendPacketToPS4(outPacket, channel, false, false);\n+\n+        // Read hello response\n+        final ByteBuffer readBuffer = ByteBuffer.allocate(512).order(ByteOrder.LITTLE_ENDIAN);\n+\n+        int responseLength = channel.read(readBuffer);\n+        if (responseLength > 0) {\n+            ps4Crypto.parseHelloResponsePacket(readBuffer);\n+        } else {\n+            return false;\n+        }\n+\n+        outPacket = ps4Crypto.makeHandshakePacket();\n+        sendPacketToPS4(outPacket, channel, false, false);\n+        return true;\n+    }\n+\n+    private class SocketChannelHandler extends Thread {\n+        private SocketChannel socketChannel;\n+\n+        public SocketChannelHandler() throws IOException {\n+            socketChannel = setupChannel();\n+            loggedIn = false;\n+            oskOpen = false;\n+            start();\n+        }\n+\n+        public SocketChannel getChannel() {\n+            if (!socketChannel.isOpen()) {\n+                try {\n+                    socketChannel = setupChannel();\n+                } catch (IOException e) {\n+                    logger.debug(\"Couldn't open SocketChannel.{}\", e.getMessage());\n+                }\n+            }\n+            return socketChannel;\n+        }\n+\n+        public boolean isChannelOpen() {\n+            return socketChannel.isOpen();\n+        }\n+\n+        private SocketChannel setupChannel() throws IOException {\n+            SocketChannel channel = SocketChannel.open();\n+            if (!openComs()) {\n+                throw new IOException(\"Open coms failed\");\n+            }\n+            if (!setupConnection(channel)) {\n+                throw new IOException(\"Setup connection failed\");\n+            }\n+            updateState(CHANNEL_CONNECT, OnOffType.ON);\n+            return channel;\n+        }\n+\n+        @Override\n+        public void run() {\n+            SocketChannel channel = socketChannel;\n+            final ByteBuffer readBuffer = ByteBuffer.allocate(512).order(ByteOrder.LITTLE_ENDIAN);\n+            try {\n+                while (channel.read(readBuffer) > 0) {\n+                    ByteBuffer messBuffer = ps4Crypto.decryptPacket(readBuffer);\n+                    readBuffer.position(0);\n+                    PS4Command lastCommand = parseResponsePacket(messBuffer);\n+\n+                    if (lastCommand == PS4Command.SERVER_STATUS_RSP) {\n+                        if (oskOpen && isLinked(CHANNEL_OSK_TEXT)) {\n+                            sendOSKStart();\n+                        } else {\n+                            sendStatus();\n+                        }\n+                    }\n+                }\n+            } catch (IOException e) {\n+                logger.debug(\"Connection read exception: {}\", e.getMessage());\n+            } finally {\n+                try {\n+                    channel.close();\n+                } catch (IOException e) {\n+                    logger.debug(\"Connection close exception: {}\", e.getMessage());\n+                }\n+            }\n+            updateState(CHANNEL_CONNECT, OnOffType.OFF);\n+            logger.debug(\"SocketHandler done.\");\n+            ps4Crypto.clearCiphers();\n+            loggedIn = false;\n+        }\n+    }\n+\n+    private @Nullable PS4Command parseResponsePacket(ByteBuffer rBuffer) {\n+        rBuffer.rewind();\n+        final int buffSize = rBuffer.remaining();\n+        final int size = rBuffer.getInt();\n+        if (size > buffSize || size < 12) {\n+            logger.debug(\"Response size ({}) not good, buffer size ({}).\", size, buffSize);\n+            return null;\n+        }\n+        int cmdValue = rBuffer.getInt();\n+        int statValue = rBuffer.getInt();\n+        PS4ErrorStatus status = PS4ErrorStatus.valueOfTag(statValue);\n+        PS4Command command = PS4Command.valueOfTag(cmdValue);\n+        byte[] respBuff = new byte[size];\n+        rBuffer.rewind();\n+        rBuffer.get(respBuff);\n+        if (command != null) {\n+            if (status == null) {\n+                logger.debug(\"Resp; size:{}, command:{}, statValue:{}, data:{}.\", size, command, statValue, respBuff);\n+            } else {\n+                logger.debug(\"Resp; size:{}, command:{}, status:{}, data:{}.\", size, command, status, respBuff);\n+            }\n+            switch (command) {\n+                case LOGIN_RSP:\n+                    if (status == null) {\n+                        logger.debug(\"Unhandled Login status value: {}\", statValue);\n+                        return command;\n+                    }\n+                    // Read login response\n+                    switch (status) {\n+                        case STATUS_OK:\n+                            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, status.message);\n+                            loggedIn = true;\n+                            if (isLinked(CHANNEL_2ND_SCREEN)) {\n+                                scheduler.execute(() -> {\n+                                    ByteBuffer outPacket = PS4PacketHandler\n+                                            .makeClientIDPacket(\"com.playstation.mobile2ndscreen\", \"18.9.3\");\n+                                    sendPacketEncrypted(outPacket, false);\n+                                });\n+                            }\n+                            break;\n+                        case STATUS_NOT_PAIRED:\n+                            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.CONFIGURATION_PENDING, status.message);\n+                            loggedIn = false;\n+                            break;\n+                        case STATUS_MISSING_PAIRING_CODE:\n+                        case STATUS_MISSING_PASS_CODE:\n+                        case STATUS_WRONG_PAIRING_CODE:\n+                        case STATUS_WRONG_PASS_CODE:\n+                        case STATUS_WRONG_USER_CREDENTIAL:\n+                            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.CONFIGURATION_ERROR, status.message);\n+                            loggedIn = false;\n+                            logger.debug(\"Not logged in: {}\", status.message);\n+                            break;\n+                        case STATUS_CAN_NOT_PLAY_NOW:\n+                        case STATUS_CLOSE_OTHER_APP:\n+                        case STATUS_COMMAND_NOT_GOOD:\n+                        case STATUS_COULD_NOT_LOG_IN:\n+                        case STATUS_DO_LOGIN:\n+                        case STATUS_MAX_USERS:\n+                        case STATUS_REGISTER_DEVICE_OVER:\n+                        case STATUS_RESTART_APP:\n+                        case STATUS_SOMEONE_ELSE_USING:\n+                        case STATUS_UPDATE_APP:\n+                        case STATUS_UPDATE_PS4:\n+                            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, status.message);\n+                            loggedIn = false;\n+                            logger.debug(\"Not logged in: {}\", status.message);\n+                            break;\n+                        default:\n+                            logger.debug(\"Unhandled Login response status:{}, message:{}\", status, status.message);\n+                            break;\n+                    }\n+                    break;\n+                case APP_START_RSP:\n+                    if (status != null && status != PS4ErrorStatus.STATUS_OK) {\n+                        logger.debug(\"App start response: {}\", status.message);\n+                    }\n+                    break;\n+                case STANDBY_RSP:\n+                    if (status != null && status != PS4ErrorStatus.STATUS_OK) {\n+                        logger.debug(\"Standby response: {}\", status.message);\n+                    }\n+                    break;\n+                case SERVER_STATUS_RSP:\n+                    if ((statValue & 4) != 0) {\n+                        oskOpen = true;\n+                    } else {\n+                        if (oskOpen) {\n+                            updateState(CHANNEL_OSK_TEXT, StringType.valueOf(\"\"));\n+                        }\n+                        oskOpen = false;\n+                    }\n+                    logger.debug(\"Server status value:{}\", statValue);\n+                    break;\n+                case HTTPD_STATUS_RSP:\n+                    String httpdStat = PS4PacketHandler.parseHTTPdPacket(rBuffer);\n+                    logger.debug(\"HTTPd Response; {}\", httpdStat);\n+                    String secondScrStr = \"\";\n+                    int httpStatus = rBuffer.getInt(8);\n+                    int port = rBuffer.getInt(12);\n+                    if (httpStatus != 0 && port != 0) {\n+                        secondScrStr = \"http://\" + config.ipAddress + \":\" + port;\n+                    }\n+                    updateState(CHANNEL_2ND_SCREEN, StringType.valueOf(secondScrStr));\n+                    break;\n+                case OSK_CHANGE_STRING_REQ:\n+                    String oskText = PS4PacketHandler.parseOSKStringChangePacket(rBuffer);\n+                    updateState(CHANNEL_OSK_TEXT, StringType.valueOf(oskText));\n+                    break;\n+                case OSK_START_RSP:\n+                case OSK_CONTROL_REQ:\n+                case COMMENT_VIEWER_START_RESULT:\n+                case SCREEN_SHOT_RSP:\n+                case APP_START2_RSP:\n+                case LOGOUT_RSP:\n+                    break;\n+                default:\n+                    logger.debug(\"Unknown response, command:{}. Missing case.\", command);\n+                    break;\n+            }\n+        } else {\n+            logger.debug(\"Unknown resp-cmd, size:{}, command:{}, status:{}, data:{}.\", size, cmdValue, statValue,\n+                    respBuff);\n+        }\n+        return command;\n+    }\n+\n+    private SocketChannel getConnection() throws IOException {\n+        return getConnection(true);\n+    }\n+\n+    private SocketChannel getConnection(boolean requiresLogin) throws IOException {\n+        SocketChannel channel = null;\n+        SocketChannelHandler handler = socketChannelHandler;\n+        if (handler == null || !handler.isChannelOpen()) {\n+            try {\n+                handler = new SocketChannelHandler();\n+                socketChannelHandler = handler;\n+            } catch (IOException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                throw e;\n+            }\n+        }\n+        channel = handler.getChannel();\n+        if (!loggedIn && requiresLogin) {\n+            login(channel);\n+        }\n+        return channel;\n+    }\n+\n+    private void sendPacketToPS4(ByteBuffer packet, SocketChannel channel, boolean encrypted, boolean restartTimeout) {\n+        PS4Command cmd = PS4Command.valueOfTag(packet.getInt(4));\n+        logger.debug(\"Sending {} packet.\", cmd);\n+        try {\n+            if (encrypted) {\n+                ByteBuffer outPacket = ps4Crypto.encryptPacket(packet);\n+                channel.write(outPacket);\n+            } else {\n+                channel.write(packet);\n+            }\n+            if (restartTimeout) {\n+                setupConnectionTimeout(config.connectionTimeout);\n+            }\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        }\n+    }\n+\n+    private void sendPacketEncrypted(ByteBuffer packet, SocketChannel channel) {\n+        sendPacketToPS4(packet, channel, true, true);\n+    }\n+\n+    private void sendPacketEncrypted(ByteBuffer packet) {\n+        sendPacketEncrypted(packet, true);\n+    }\n+\n+    private void sendPacketEncrypted(ByteBuffer packet, boolean requiresLogin) {\n+        try {\n+            SocketChannel channel = getConnection(requiresLogin);\n+            if (requiresLogin && !loggedIn) {\n+                scheduler.schedule(() -> sendPacketToPS4(packet, channel, true, requiresLogin), 250,\n+                        TimeUnit.MILLISECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b5efd6b29b01ff1b2384e8ae94061d10ad8ae41"}, "originalPosition": 636}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTI5OTU2NQ==", "bodyText": "same here", "url": "https://github.com/openhab/openhab-addons/pull/8585#discussion_r501299565", "createdAt": "2020-10-07T20:46:20Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.playstation/src/main/java/org/openhab/binding/playstation/internal/PS4Handler.java", "diffHunk": "@@ -0,0 +1,852 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.playstation.internal;\n+\n+import static org.openhab.binding.playstation.internal.PlayStationBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.UnknownHostException;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.channels.SocketChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.playstation.internal.discovery.PlayStationDiscovery;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.i18n.LocaleProvider;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.net.NetworkAddressService;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link PS4Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Fredrik Ahlstr\u00f6m - Initial contribution\n+ */\n+@NonNullByDefault\n+public class PS4Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(PS4Handler.class);\n+    private final PS4Crypto ps4Crypto = new PS4Crypto();\n+    private static final int SOCKET_TIMEOUT_SECONDS = 5;\n+    /** Time after connect that we can start to send key events, milli seconds */\n+    private static final int POST_CONNECT_SENDKEY_DELAY_MS = 500;\n+    /** Minimum delay between sendKey sends, milli seconds */\n+    private static final int MIN_SENDKEY_DELAY_MS = 250;\n+    /** Minimum delay after Key set, milli seconds */\n+    private static final int MIN_HOLDKEY_DELAY_MS = 300;\n+\n+    private PS4Configuration config = new PS4Configuration();\n+\n+    private final @Nullable LocaleProvider localeProvider;\n+    private final @Nullable NetworkAddressService networkAS;\n+    private @Nullable ScheduledFuture<?> refreshTimer;\n+    private @Nullable ScheduledFuture<?> timeoutTimer;\n+    private @Nullable SocketChannelHandler socketChannelHandler;\n+    private @Nullable InetAddress localAddress;\n+\n+    // State of PS4\n+    private String currentApplication = \"\";\n+    private String currentApplicationId = \"\";\n+    private OnOffType currentPower = OnOffType.OFF;\n+    private State currentArtwork = UnDefType.UNDEF;\n+    private int currentComPort = DEFAULT_COMMUNICATION_PORT;\n+\n+    boolean loggedIn = false;\n+    boolean oskOpen = false;\n+\n+    public PS4Handler(Thing thing, LocaleProvider locProvider, NetworkAddressService network) {\n+        super(thing);\n+        localeProvider = locProvider;\n+        networkAS = network;\n+    }\n+\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        super.handleConfigurationUpdate(configurationParameters);\n+        figureOutLocalIP();\n+        SocketChannelHandler scHandler = socketChannelHandler;\n+        if (!config.pairingCode.isEmpty() && (scHandler == null || !loggedIn)) {\n+            // Try to log in then remove pairing code as it's one use only.\n+            scheduler.execute(() -> {\n+                login();\n+                Configuration editedConfig = editConfiguration();\n+                editedConfig.put(PAIRING_CODE, \"\");\n+                updateConfiguration(editedConfig);\n+            });\n+        }\n+        setupConnectionTimeout(config.connectionTimeout);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            refreshFromState(channelUID);\n+        } else {\n+            if (command instanceof StringType) {\n+                switch (channelUID.getId()) {\n+                    case CHANNEL_APPLICATION_ID:\n+                        if (!currentApplicationId.equals(((StringType) command).toString())) {\n+                            updateApplicationTitleid(((StringType) command).toString());\n+                            startApplication(currentApplicationId);\n+                        }\n+                        break;\n+                    case CHANNEL_OSK_TEXT:\n+                        setOSKText(((StringType) command).toString());\n+                        break;\n+                    case CHANNEL_SEND_KEY:\n+                        int ps4Key = 0;\n+                        switch (((StringType) command).toString()) {\n+                            case SEND_KEY_UP:\n+                                ps4Key = PS4_KEY_UP;\n+                                break;\n+                            case SEND_KEY_DOWN:\n+                                ps4Key = PS4_KEY_DOWN;\n+                                break;\n+                            case SEND_KEY_RIGHT:\n+                                ps4Key = PS4_KEY_RIGHT;\n+                                break;\n+                            case SEND_KEY_LEFT:\n+                                ps4Key = PS4_KEY_LEFT;\n+                                break;\n+                            case SEND_KEY_ENTER:\n+                                ps4Key = PS4_KEY_ENTER;\n+                                break;\n+                            case SEND_KEY_BACK:\n+                                ps4Key = PS4_KEY_BACK;\n+                                break;\n+                            case SEND_KEY_OPTION:\n+                                ps4Key = PS4_KEY_OPTION;\n+                                break;\n+                            case SEND_KEY_PS:\n+                                ps4Key = PS4_KEY_PS;\n+                                break;\n+                            default:\n+                                break;\n+                        }\n+                        if (ps4Key != 0) {\n+                            sendRemoteKey(ps4Key);\n+                        }\n+                        break;\n+                    default:\n+                        break;\n+                }\n+            } else if (command instanceof OnOffType) {\n+                OnOffType onOff = (OnOffType) command;\n+                switch (channelUID.getId()) {\n+                    case CHANNEL_POWER:\n+                        if (currentPower != onOff) {\n+                            currentPower = onOff;\n+                            if (currentPower.equals(OnOffType.ON)) {\n+                                turnOnPS4();\n+                            } else if (currentPower.equals(OnOffType.OFF)) {\n+                                sendStandby();\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_CONNECT:\n+                        boolean connected = socketChannelHandler != null && socketChannelHandler.isChannelOpen();\n+                        if (connected && onOff.equals(OnOffType.OFF)) {\n+                            sendByeBye();\n+                        } else if (!connected && onOff.equals(OnOffType.ON)) {\n+                            scheduler.execute(() -> login());\n+                        }\n+                        break;\n+                    default:\n+                        break;\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(PS4Configuration.class);\n+\n+        figureOutLocalIP();\n+        updateStatus(ThingStatus.UNKNOWN);\n+        setupRefreshTimer();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        ScheduledFuture<?> timer = refreshTimer;\n+        if (timer != null) {\n+            timer.cancel(false);\n+            refreshTimer = null;\n+        }\n+        timer = timeoutTimer;\n+        if (timer != null) {\n+            timer.cancel(false);\n+            timeoutTimer = null;\n+        }\n+        stopConnection();\n+    }\n+\n+    /**\n+     * Tries to figure out a local IP that can communicate with the PS4.\n+     */\n+    private void figureOutLocalIP() {\n+        if (!config.outboundIP.trim().isEmpty()) {\n+            try {\n+                localAddress = InetAddress.getByName(config.outboundIP);\n+                logger.debug(\"Outbound local IP.\\\"{}\\\"\", localAddress);\n+                return;\n+            } catch (UnknownHostException e) {\n+                // This is expected\n+            }\n+        }\n+        NetworkAddressService network = networkAS;\n+        String adr = (network != null) ? network.getPrimaryIpv4HostAddress() : null;\n+        if (adr != null) {\n+            try {\n+                localAddress = InetAddress.getByName(adr);\n+            } catch (UnknownHostException e) {\n+                // Ignore, just let the socket use whatever.\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Sets up a timer for querying the PS4 (using the scheduler) every 10 seconds.\n+     */\n+    private void setupRefreshTimer() {\n+        final ScheduledFuture<?> timer = refreshTimer;\n+        if (timer != null) {\n+            timer.cancel(false);\n+        }\n+        refreshTimer = scheduler.scheduleWithFixedDelay(this::updateAllChannels, 0, 10, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Sets up a timer for stopping the connection to the PS4 (using the scheduler) with the given time.\n+     *\n+     * @param waitTime The time in seconds before the connection is stopped.\n+     */\n+    private void setupConnectionTimeout(int waitTime) {\n+        final ScheduledFuture<?> timer = timeoutTimer;\n+        if (timer != null) {\n+            timer.cancel(false);\n+        }\n+        if (waitTime > 0) {\n+            timeoutTimer = scheduler.schedule(this::stopConnection, waitTime, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    private void refreshFromState(ChannelUID channelUID) {\n+        switch (channelUID.getId()) {\n+            case CHANNEL_POWER:\n+                updateState(channelUID, currentPower);\n+                break;\n+            case CHANNEL_APPLICATION_NAME:\n+                updateState(channelUID, StringType.valueOf(currentApplication));\n+                break;\n+            case CHANNEL_APPLICATION_ID:\n+                updateState(channelUID, StringType.valueOf(currentApplicationId));\n+                break;\n+            case CHANNEL_APPLICATION_IMAGE:\n+                updateApplicationTitleid(currentApplicationId);\n+                updateState(channelUID, currentArtwork);\n+                break;\n+            case CHANNEL_OSK_TEXT:\n+            case CHANNEL_2ND_SCREEN:\n+                updateState(channelUID, UnDefType.UNDEF);\n+                break;\n+            case CHANNEL_CONNECT:\n+                boolean connected = socketChannelHandler != null && socketChannelHandler.isChannelOpen();\n+                updateState(channelUID, OnOffType.from(connected));\n+                break;\n+            case CHANNEL_SEND_KEY:\n+                break;\n+            default:\n+                logger.warn(\"Channel refresh for {} not implemented!\", channelUID.getId());\n+        }\n+    }\n+\n+    private void updateAllChannels() {\n+        try (DatagramSocket socket = new DatagramSocket(0, localAddress)) {\n+            socket.setBroadcast(false);\n+            socket.setSoTimeout(SOCKET_TIMEOUT_SECONDS * 1000);\n+            InetAddress inetAddress = InetAddress.getByName(config.ipAddress);\n+\n+            // send discover\n+            byte[] discover = PS4PacketHandler.makeSearchPacket();\n+            DatagramPacket packet = new DatagramPacket(discover, discover.length, inetAddress, DEFAULT_BROADCAST_PORT);\n+            socket.send(packet);\n+\n+            // wait for response\n+            byte[] rxbuf = new byte[256];\n+            packet = new DatagramPacket(rxbuf, rxbuf.length);\n+            socket.receive(packet);\n+            parseSearchResponse(packet);\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        }\n+    }\n+\n+    private void stopConnection() {\n+        SocketChannelHandler handler = socketChannelHandler;\n+        if (handler != null && handler.isChannelOpen()) {\n+            sendByeBye();\n+        }\n+    }\n+\n+    private void wakeUpPS4() {\n+        logger.debug(\"Waking up PS4...\");\n+        try (DatagramSocket socket = new DatagramSocket(0, localAddress)) {\n+            socket.setBroadcast(false);\n+            InetAddress inetAddress = InetAddress.getByName(config.ipAddress);\n+            // send wake-up\n+            byte[] wakeup = PS4PacketHandler.makeWakeupPacket(config.userCredential);\n+            DatagramPacket packet = new DatagramPacket(wakeup, wakeup.length, inetAddress, DEFAULT_BROADCAST_PORT);\n+            socket.send(packet);\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        }\n+    }\n+\n+    private boolean openComs() {\n+        try (DatagramSocket socket = new DatagramSocket(0, localAddress)) {\n+            socket.setBroadcast(false);\n+            InetAddress inetAddress = InetAddress.getByName(config.ipAddress);\n+            // send launch\n+            byte[] launch = PS4PacketHandler.makeLaunchPacket(config.userCredential);\n+            DatagramPacket packet = new DatagramPacket(launch, launch.length, inetAddress, DEFAULT_BROADCAST_PORT);\n+            socket.send(packet);\n+            Thread.sleep(100);\n+            return true;\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        } catch (InterruptedException e) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    private boolean setupConnection(SocketChannel channel) throws IOException {\n+        logger.debug(\"TCP connecting\");\n+\n+        channel.socket().setSoTimeout(2000);\n+        channel.configureBlocking(true);\n+        channel.connect(new InetSocketAddress(config.ipAddress, currentComPort));\n+\n+        ByteBuffer outPacket = PS4PacketHandler.makeHelloPacket();\n+        sendPacketToPS4(outPacket, channel, false, false);\n+\n+        // Read hello response\n+        final ByteBuffer readBuffer = ByteBuffer.allocate(512).order(ByteOrder.LITTLE_ENDIAN);\n+\n+        int responseLength = channel.read(readBuffer);\n+        if (responseLength > 0) {\n+            ps4Crypto.parseHelloResponsePacket(readBuffer);\n+        } else {\n+            return false;\n+        }\n+\n+        outPacket = ps4Crypto.makeHandshakePacket();\n+        sendPacketToPS4(outPacket, channel, false, false);\n+        return true;\n+    }\n+\n+    private class SocketChannelHandler extends Thread {\n+        private SocketChannel socketChannel;\n+\n+        public SocketChannelHandler() throws IOException {\n+            socketChannel = setupChannel();\n+            loggedIn = false;\n+            oskOpen = false;\n+            start();\n+        }\n+\n+        public SocketChannel getChannel() {\n+            if (!socketChannel.isOpen()) {\n+                try {\n+                    socketChannel = setupChannel();\n+                } catch (IOException e) {\n+                    logger.debug(\"Couldn't open SocketChannel.{}\", e.getMessage());\n+                }\n+            }\n+            return socketChannel;\n+        }\n+\n+        public boolean isChannelOpen() {\n+            return socketChannel.isOpen();\n+        }\n+\n+        private SocketChannel setupChannel() throws IOException {\n+            SocketChannel channel = SocketChannel.open();\n+            if (!openComs()) {\n+                throw new IOException(\"Open coms failed\");\n+            }\n+            if (!setupConnection(channel)) {\n+                throw new IOException(\"Setup connection failed\");\n+            }\n+            updateState(CHANNEL_CONNECT, OnOffType.ON);\n+            return channel;\n+        }\n+\n+        @Override\n+        public void run() {\n+            SocketChannel channel = socketChannel;\n+            final ByteBuffer readBuffer = ByteBuffer.allocate(512).order(ByteOrder.LITTLE_ENDIAN);\n+            try {\n+                while (channel.read(readBuffer) > 0) {\n+                    ByteBuffer messBuffer = ps4Crypto.decryptPacket(readBuffer);\n+                    readBuffer.position(0);\n+                    PS4Command lastCommand = parseResponsePacket(messBuffer);\n+\n+                    if (lastCommand == PS4Command.SERVER_STATUS_RSP) {\n+                        if (oskOpen && isLinked(CHANNEL_OSK_TEXT)) {\n+                            sendOSKStart();\n+                        } else {\n+                            sendStatus();\n+                        }\n+                    }\n+                }\n+            } catch (IOException e) {\n+                logger.debug(\"Connection read exception: {}\", e.getMessage());\n+            } finally {\n+                try {\n+                    channel.close();\n+                } catch (IOException e) {\n+                    logger.debug(\"Connection close exception: {}\", e.getMessage());\n+                }\n+            }\n+            updateState(CHANNEL_CONNECT, OnOffType.OFF);\n+            logger.debug(\"SocketHandler done.\");\n+            ps4Crypto.clearCiphers();\n+            loggedIn = false;\n+        }\n+    }\n+\n+    private @Nullable PS4Command parseResponsePacket(ByteBuffer rBuffer) {\n+        rBuffer.rewind();\n+        final int buffSize = rBuffer.remaining();\n+        final int size = rBuffer.getInt();\n+        if (size > buffSize || size < 12) {\n+            logger.debug(\"Response size ({}) not good, buffer size ({}).\", size, buffSize);\n+            return null;\n+        }\n+        int cmdValue = rBuffer.getInt();\n+        int statValue = rBuffer.getInt();\n+        PS4ErrorStatus status = PS4ErrorStatus.valueOfTag(statValue);\n+        PS4Command command = PS4Command.valueOfTag(cmdValue);\n+        byte[] respBuff = new byte[size];\n+        rBuffer.rewind();\n+        rBuffer.get(respBuff);\n+        if (command != null) {\n+            if (status == null) {\n+                logger.debug(\"Resp; size:{}, command:{}, statValue:{}, data:{}.\", size, command, statValue, respBuff);\n+            } else {\n+                logger.debug(\"Resp; size:{}, command:{}, status:{}, data:{}.\", size, command, status, respBuff);\n+            }\n+            switch (command) {\n+                case LOGIN_RSP:\n+                    if (status == null) {\n+                        logger.debug(\"Unhandled Login status value: {}\", statValue);\n+                        return command;\n+                    }\n+                    // Read login response\n+                    switch (status) {\n+                        case STATUS_OK:\n+                            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, status.message);\n+                            loggedIn = true;\n+                            if (isLinked(CHANNEL_2ND_SCREEN)) {\n+                                scheduler.execute(() -> {\n+                                    ByteBuffer outPacket = PS4PacketHandler\n+                                            .makeClientIDPacket(\"com.playstation.mobile2ndscreen\", \"18.9.3\");\n+                                    sendPacketEncrypted(outPacket, false);\n+                                });\n+                            }\n+                            break;\n+                        case STATUS_NOT_PAIRED:\n+                            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.CONFIGURATION_PENDING, status.message);\n+                            loggedIn = false;\n+                            break;\n+                        case STATUS_MISSING_PAIRING_CODE:\n+                        case STATUS_MISSING_PASS_CODE:\n+                        case STATUS_WRONG_PAIRING_CODE:\n+                        case STATUS_WRONG_PASS_CODE:\n+                        case STATUS_WRONG_USER_CREDENTIAL:\n+                            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.CONFIGURATION_ERROR, status.message);\n+                            loggedIn = false;\n+                            logger.debug(\"Not logged in: {}\", status.message);\n+                            break;\n+                        case STATUS_CAN_NOT_PLAY_NOW:\n+                        case STATUS_CLOSE_OTHER_APP:\n+                        case STATUS_COMMAND_NOT_GOOD:\n+                        case STATUS_COULD_NOT_LOG_IN:\n+                        case STATUS_DO_LOGIN:\n+                        case STATUS_MAX_USERS:\n+                        case STATUS_REGISTER_DEVICE_OVER:\n+                        case STATUS_RESTART_APP:\n+                        case STATUS_SOMEONE_ELSE_USING:\n+                        case STATUS_UPDATE_APP:\n+                        case STATUS_UPDATE_PS4:\n+                            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, status.message);\n+                            loggedIn = false;\n+                            logger.debug(\"Not logged in: {}\", status.message);\n+                            break;\n+                        default:\n+                            logger.debug(\"Unhandled Login response status:{}, message:{}\", status, status.message);\n+                            break;\n+                    }\n+                    break;\n+                case APP_START_RSP:\n+                    if (status != null && status != PS4ErrorStatus.STATUS_OK) {\n+                        logger.debug(\"App start response: {}\", status.message);\n+                    }\n+                    break;\n+                case STANDBY_RSP:\n+                    if (status != null && status != PS4ErrorStatus.STATUS_OK) {\n+                        logger.debug(\"Standby response: {}\", status.message);\n+                    }\n+                    break;\n+                case SERVER_STATUS_RSP:\n+                    if ((statValue & 4) != 0) {\n+                        oskOpen = true;\n+                    } else {\n+                        if (oskOpen) {\n+                            updateState(CHANNEL_OSK_TEXT, StringType.valueOf(\"\"));\n+                        }\n+                        oskOpen = false;\n+                    }\n+                    logger.debug(\"Server status value:{}\", statValue);\n+                    break;\n+                case HTTPD_STATUS_RSP:\n+                    String httpdStat = PS4PacketHandler.parseHTTPdPacket(rBuffer);\n+                    logger.debug(\"HTTPd Response; {}\", httpdStat);\n+                    String secondScrStr = \"\";\n+                    int httpStatus = rBuffer.getInt(8);\n+                    int port = rBuffer.getInt(12);\n+                    if (httpStatus != 0 && port != 0) {\n+                        secondScrStr = \"http://\" + config.ipAddress + \":\" + port;\n+                    }\n+                    updateState(CHANNEL_2ND_SCREEN, StringType.valueOf(secondScrStr));\n+                    break;\n+                case OSK_CHANGE_STRING_REQ:\n+                    String oskText = PS4PacketHandler.parseOSKStringChangePacket(rBuffer);\n+                    updateState(CHANNEL_OSK_TEXT, StringType.valueOf(oskText));\n+                    break;\n+                case OSK_START_RSP:\n+                case OSK_CONTROL_REQ:\n+                case COMMENT_VIEWER_START_RESULT:\n+                case SCREEN_SHOT_RSP:\n+                case APP_START2_RSP:\n+                case LOGOUT_RSP:\n+                    break;\n+                default:\n+                    logger.debug(\"Unknown response, command:{}. Missing case.\", command);\n+                    break;\n+            }\n+        } else {\n+            logger.debug(\"Unknown resp-cmd, size:{}, command:{}, status:{}, data:{}.\", size, cmdValue, statValue,\n+                    respBuff);\n+        }\n+        return command;\n+    }\n+\n+    private SocketChannel getConnection() throws IOException {\n+        return getConnection(true);\n+    }\n+\n+    private SocketChannel getConnection(boolean requiresLogin) throws IOException {\n+        SocketChannel channel = null;\n+        SocketChannelHandler handler = socketChannelHandler;\n+        if (handler == null || !handler.isChannelOpen()) {\n+            try {\n+                handler = new SocketChannelHandler();\n+                socketChannelHandler = handler;\n+            } catch (IOException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                throw e;\n+            }\n+        }\n+        channel = handler.getChannel();\n+        if (!loggedIn && requiresLogin) {\n+            login(channel);\n+        }\n+        return channel;\n+    }\n+\n+    private void sendPacketToPS4(ByteBuffer packet, SocketChannel channel, boolean encrypted, boolean restartTimeout) {\n+        PS4Command cmd = PS4Command.valueOfTag(packet.getInt(4));\n+        logger.debug(\"Sending {} packet.\", cmd);\n+        try {\n+            if (encrypted) {\n+                ByteBuffer outPacket = ps4Crypto.encryptPacket(packet);\n+                channel.write(outPacket);\n+            } else {\n+                channel.write(packet);\n+            }\n+            if (restartTimeout) {\n+                setupConnectionTimeout(config.connectionTimeout);\n+            }\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        }\n+    }\n+\n+    private void sendPacketEncrypted(ByteBuffer packet, SocketChannel channel) {\n+        sendPacketToPS4(packet, channel, true, true);\n+    }\n+\n+    private void sendPacketEncrypted(ByteBuffer packet) {\n+        sendPacketEncrypted(packet, true);\n+    }\n+\n+    private void sendPacketEncrypted(ByteBuffer packet, boolean requiresLogin) {\n+        try {\n+            SocketChannel channel = getConnection(requiresLogin);\n+            if (requiresLogin && !loggedIn) {\n+                scheduler.schedule(() -> sendPacketToPS4(packet, channel, true, requiresLogin), 250,\n+                        TimeUnit.MILLISECONDS);\n+            } else {\n+                sendPacketToPS4(packet, channel, true, requiresLogin);\n+            }\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * This is used as a heart beat to let the PS4 know that we are still listening.\n+     */\n+    private void sendStatus() {\n+        ByteBuffer outPacket = PS4PacketHandler.makeStatusPacket(0);\n+        sendPacketEncrypted(outPacket, false);\n+    }\n+\n+    private void login(SocketChannel channel) {\n+        // Send login request\n+        ByteBuffer outPacket = PS4PacketHandler.makeLoginPacket(config.userCredential, config.passCode,\n+                config.pairingCode);\n+        sendPacketEncrypted(outPacket, channel);\n+    }\n+\n+    private void login() {\n+        try {\n+            SocketChannel channel = getConnection(false);\n+            login(channel);\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * This closes the connection with the PS4.\n+     */\n+    private void sendByeBye() {\n+        ByteBuffer outPacket = PS4PacketHandler.makeByebyePacket();\n+        sendPacketEncrypted(outPacket, false);\n+    }\n+\n+    private void turnOnPS4() {\n+        wakeUpPS4();\n+        scheduler.schedule(this::waitAndConnectToPS4, 13, TimeUnit.SECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b5efd6b29b01ff1b2384e8ae94061d10ad8ae41"}, "originalPosition": 679}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMwMDY0Nw==", "bodyText": "At this point I think you might as well manage your own scheduler so that you can destroy any pending tasks a part of handler disposal. It would certainly be easier than trying to keep track of all of these scheduled task futures.", "url": "https://github.com/openhab/openhab-addons/pull/8585#discussion_r501300647", "createdAt": "2020-10-07T20:48:20Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.playstation/src/main/java/org/openhab/binding/playstation/internal/PS4Handler.java", "diffHunk": "@@ -0,0 +1,852 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.playstation.internal;\n+\n+import static org.openhab.binding.playstation.internal.PlayStationBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.UnknownHostException;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.channels.SocketChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.playstation.internal.discovery.PlayStationDiscovery;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.i18n.LocaleProvider;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.RawType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.net.NetworkAddressService;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.openhab.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link PS4Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Fredrik Ahlstr\u00f6m - Initial contribution\n+ */\n+@NonNullByDefault\n+public class PS4Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(PS4Handler.class);\n+    private final PS4Crypto ps4Crypto = new PS4Crypto();\n+    private static final int SOCKET_TIMEOUT_SECONDS = 5;\n+    /** Time after connect that we can start to send key events, milli seconds */\n+    private static final int POST_CONNECT_SENDKEY_DELAY_MS = 500;\n+    /** Minimum delay between sendKey sends, milli seconds */\n+    private static final int MIN_SENDKEY_DELAY_MS = 250;\n+    /** Minimum delay after Key set, milli seconds */\n+    private static final int MIN_HOLDKEY_DELAY_MS = 300;\n+\n+    private PS4Configuration config = new PS4Configuration();\n+\n+    private final @Nullable LocaleProvider localeProvider;\n+    private final @Nullable NetworkAddressService networkAS;\n+    private @Nullable ScheduledFuture<?> refreshTimer;\n+    private @Nullable ScheduledFuture<?> timeoutTimer;\n+    private @Nullable SocketChannelHandler socketChannelHandler;\n+    private @Nullable InetAddress localAddress;\n+\n+    // State of PS4\n+    private String currentApplication = \"\";\n+    private String currentApplicationId = \"\";\n+    private OnOffType currentPower = OnOffType.OFF;\n+    private State currentArtwork = UnDefType.UNDEF;\n+    private int currentComPort = DEFAULT_COMMUNICATION_PORT;\n+\n+    boolean loggedIn = false;\n+    boolean oskOpen = false;\n+\n+    public PS4Handler(Thing thing, LocaleProvider locProvider, NetworkAddressService network) {\n+        super(thing);\n+        localeProvider = locProvider;\n+        networkAS = network;\n+    }\n+\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        super.handleConfigurationUpdate(configurationParameters);\n+        figureOutLocalIP();\n+        SocketChannelHandler scHandler = socketChannelHandler;\n+        if (!config.pairingCode.isEmpty() && (scHandler == null || !loggedIn)) {\n+            // Try to log in then remove pairing code as it's one use only.\n+            scheduler.execute(() -> {\n+                login();\n+                Configuration editedConfig = editConfiguration();\n+                editedConfig.put(PAIRING_CODE, \"\");\n+                updateConfiguration(editedConfig);\n+            });\n+        }\n+        setupConnectionTimeout(config.connectionTimeout);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            refreshFromState(channelUID);\n+        } else {\n+            if (command instanceof StringType) {\n+                switch (channelUID.getId()) {\n+                    case CHANNEL_APPLICATION_ID:\n+                        if (!currentApplicationId.equals(((StringType) command).toString())) {\n+                            updateApplicationTitleid(((StringType) command).toString());\n+                            startApplication(currentApplicationId);\n+                        }\n+                        break;\n+                    case CHANNEL_OSK_TEXT:\n+                        setOSKText(((StringType) command).toString());\n+                        break;\n+                    case CHANNEL_SEND_KEY:\n+                        int ps4Key = 0;\n+                        switch (((StringType) command).toString()) {\n+                            case SEND_KEY_UP:\n+                                ps4Key = PS4_KEY_UP;\n+                                break;\n+                            case SEND_KEY_DOWN:\n+                                ps4Key = PS4_KEY_DOWN;\n+                                break;\n+                            case SEND_KEY_RIGHT:\n+                                ps4Key = PS4_KEY_RIGHT;\n+                                break;\n+                            case SEND_KEY_LEFT:\n+                                ps4Key = PS4_KEY_LEFT;\n+                                break;\n+                            case SEND_KEY_ENTER:\n+                                ps4Key = PS4_KEY_ENTER;\n+                                break;\n+                            case SEND_KEY_BACK:\n+                                ps4Key = PS4_KEY_BACK;\n+                                break;\n+                            case SEND_KEY_OPTION:\n+                                ps4Key = PS4_KEY_OPTION;\n+                                break;\n+                            case SEND_KEY_PS:\n+                                ps4Key = PS4_KEY_PS;\n+                                break;\n+                            default:\n+                                break;\n+                        }\n+                        if (ps4Key != 0) {\n+                            sendRemoteKey(ps4Key);\n+                        }\n+                        break;\n+                    default:\n+                        break;\n+                }\n+            } else if (command instanceof OnOffType) {\n+                OnOffType onOff = (OnOffType) command;\n+                switch (channelUID.getId()) {\n+                    case CHANNEL_POWER:\n+                        if (currentPower != onOff) {\n+                            currentPower = onOff;\n+                            if (currentPower.equals(OnOffType.ON)) {\n+                                turnOnPS4();\n+                            } else if (currentPower.equals(OnOffType.OFF)) {\n+                                sendStandby();\n+                            }\n+                        }\n+                        break;\n+                    case CHANNEL_CONNECT:\n+                        boolean connected = socketChannelHandler != null && socketChannelHandler.isChannelOpen();\n+                        if (connected && onOff.equals(OnOffType.OFF)) {\n+                            sendByeBye();\n+                        } else if (!connected && onOff.equals(OnOffType.ON)) {\n+                            scheduler.execute(() -> login());\n+                        }\n+                        break;\n+                    default:\n+                        break;\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(PS4Configuration.class);\n+\n+        figureOutLocalIP();\n+        updateStatus(ThingStatus.UNKNOWN);\n+        setupRefreshTimer();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        ScheduledFuture<?> timer = refreshTimer;\n+        if (timer != null) {\n+            timer.cancel(false);\n+            refreshTimer = null;\n+        }\n+        timer = timeoutTimer;\n+        if (timer != null) {\n+            timer.cancel(false);\n+            timeoutTimer = null;\n+        }\n+        stopConnection();\n+    }\n+\n+    /**\n+     * Tries to figure out a local IP that can communicate with the PS4.\n+     */\n+    private void figureOutLocalIP() {\n+        if (!config.outboundIP.trim().isEmpty()) {\n+            try {\n+                localAddress = InetAddress.getByName(config.outboundIP);\n+                logger.debug(\"Outbound local IP.\\\"{}\\\"\", localAddress);\n+                return;\n+            } catch (UnknownHostException e) {\n+                // This is expected\n+            }\n+        }\n+        NetworkAddressService network = networkAS;\n+        String adr = (network != null) ? network.getPrimaryIpv4HostAddress() : null;\n+        if (adr != null) {\n+            try {\n+                localAddress = InetAddress.getByName(adr);\n+            } catch (UnknownHostException e) {\n+                // Ignore, just let the socket use whatever.\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Sets up a timer for querying the PS4 (using the scheduler) every 10 seconds.\n+     */\n+    private void setupRefreshTimer() {\n+        final ScheduledFuture<?> timer = refreshTimer;\n+        if (timer != null) {\n+            timer.cancel(false);\n+        }\n+        refreshTimer = scheduler.scheduleWithFixedDelay(this::updateAllChannels, 0, 10, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Sets up a timer for stopping the connection to the PS4 (using the scheduler) with the given time.\n+     *\n+     * @param waitTime The time in seconds before the connection is stopped.\n+     */\n+    private void setupConnectionTimeout(int waitTime) {\n+        final ScheduledFuture<?> timer = timeoutTimer;\n+        if (timer != null) {\n+            timer.cancel(false);\n+        }\n+        if (waitTime > 0) {\n+            timeoutTimer = scheduler.schedule(this::stopConnection, waitTime, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    private void refreshFromState(ChannelUID channelUID) {\n+        switch (channelUID.getId()) {\n+            case CHANNEL_POWER:\n+                updateState(channelUID, currentPower);\n+                break;\n+            case CHANNEL_APPLICATION_NAME:\n+                updateState(channelUID, StringType.valueOf(currentApplication));\n+                break;\n+            case CHANNEL_APPLICATION_ID:\n+                updateState(channelUID, StringType.valueOf(currentApplicationId));\n+                break;\n+            case CHANNEL_APPLICATION_IMAGE:\n+                updateApplicationTitleid(currentApplicationId);\n+                updateState(channelUID, currentArtwork);\n+                break;\n+            case CHANNEL_OSK_TEXT:\n+            case CHANNEL_2ND_SCREEN:\n+                updateState(channelUID, UnDefType.UNDEF);\n+                break;\n+            case CHANNEL_CONNECT:\n+                boolean connected = socketChannelHandler != null && socketChannelHandler.isChannelOpen();\n+                updateState(channelUID, OnOffType.from(connected));\n+                break;\n+            case CHANNEL_SEND_KEY:\n+                break;\n+            default:\n+                logger.warn(\"Channel refresh for {} not implemented!\", channelUID.getId());\n+        }\n+    }\n+\n+    private void updateAllChannels() {\n+        try (DatagramSocket socket = new DatagramSocket(0, localAddress)) {\n+            socket.setBroadcast(false);\n+            socket.setSoTimeout(SOCKET_TIMEOUT_SECONDS * 1000);\n+            InetAddress inetAddress = InetAddress.getByName(config.ipAddress);\n+\n+            // send discover\n+            byte[] discover = PS4PacketHandler.makeSearchPacket();\n+            DatagramPacket packet = new DatagramPacket(discover, discover.length, inetAddress, DEFAULT_BROADCAST_PORT);\n+            socket.send(packet);\n+\n+            // wait for response\n+            byte[] rxbuf = new byte[256];\n+            packet = new DatagramPacket(rxbuf, rxbuf.length);\n+            socket.receive(packet);\n+            parseSearchResponse(packet);\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        }\n+    }\n+\n+    private void stopConnection() {\n+        SocketChannelHandler handler = socketChannelHandler;\n+        if (handler != null && handler.isChannelOpen()) {\n+            sendByeBye();\n+        }\n+    }\n+\n+    private void wakeUpPS4() {\n+        logger.debug(\"Waking up PS4...\");\n+        try (DatagramSocket socket = new DatagramSocket(0, localAddress)) {\n+            socket.setBroadcast(false);\n+            InetAddress inetAddress = InetAddress.getByName(config.ipAddress);\n+            // send wake-up\n+            byte[] wakeup = PS4PacketHandler.makeWakeupPacket(config.userCredential);\n+            DatagramPacket packet = new DatagramPacket(wakeup, wakeup.length, inetAddress, DEFAULT_BROADCAST_PORT);\n+            socket.send(packet);\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        }\n+    }\n+\n+    private boolean openComs() {\n+        try (DatagramSocket socket = new DatagramSocket(0, localAddress)) {\n+            socket.setBroadcast(false);\n+            InetAddress inetAddress = InetAddress.getByName(config.ipAddress);\n+            // send launch\n+            byte[] launch = PS4PacketHandler.makeLaunchPacket(config.userCredential);\n+            DatagramPacket packet = new DatagramPacket(launch, launch.length, inetAddress, DEFAULT_BROADCAST_PORT);\n+            socket.send(packet);\n+            Thread.sleep(100);\n+            return true;\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        } catch (InterruptedException e) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    private boolean setupConnection(SocketChannel channel) throws IOException {\n+        logger.debug(\"TCP connecting\");\n+\n+        channel.socket().setSoTimeout(2000);\n+        channel.configureBlocking(true);\n+        channel.connect(new InetSocketAddress(config.ipAddress, currentComPort));\n+\n+        ByteBuffer outPacket = PS4PacketHandler.makeHelloPacket();\n+        sendPacketToPS4(outPacket, channel, false, false);\n+\n+        // Read hello response\n+        final ByteBuffer readBuffer = ByteBuffer.allocate(512).order(ByteOrder.LITTLE_ENDIAN);\n+\n+        int responseLength = channel.read(readBuffer);\n+        if (responseLength > 0) {\n+            ps4Crypto.parseHelloResponsePacket(readBuffer);\n+        } else {\n+            return false;\n+        }\n+\n+        outPacket = ps4Crypto.makeHandshakePacket();\n+        sendPacketToPS4(outPacket, channel, false, false);\n+        return true;\n+    }\n+\n+    private class SocketChannelHandler extends Thread {\n+        private SocketChannel socketChannel;\n+\n+        public SocketChannelHandler() throws IOException {\n+            socketChannel = setupChannel();\n+            loggedIn = false;\n+            oskOpen = false;\n+            start();\n+        }\n+\n+        public SocketChannel getChannel() {\n+            if (!socketChannel.isOpen()) {\n+                try {\n+                    socketChannel = setupChannel();\n+                } catch (IOException e) {\n+                    logger.debug(\"Couldn't open SocketChannel.{}\", e.getMessage());\n+                }\n+            }\n+            return socketChannel;\n+        }\n+\n+        public boolean isChannelOpen() {\n+            return socketChannel.isOpen();\n+        }\n+\n+        private SocketChannel setupChannel() throws IOException {\n+            SocketChannel channel = SocketChannel.open();\n+            if (!openComs()) {\n+                throw new IOException(\"Open coms failed\");\n+            }\n+            if (!setupConnection(channel)) {\n+                throw new IOException(\"Setup connection failed\");\n+            }\n+            updateState(CHANNEL_CONNECT, OnOffType.ON);\n+            return channel;\n+        }\n+\n+        @Override\n+        public void run() {\n+            SocketChannel channel = socketChannel;\n+            final ByteBuffer readBuffer = ByteBuffer.allocate(512).order(ByteOrder.LITTLE_ENDIAN);\n+            try {\n+                while (channel.read(readBuffer) > 0) {\n+                    ByteBuffer messBuffer = ps4Crypto.decryptPacket(readBuffer);\n+                    readBuffer.position(0);\n+                    PS4Command lastCommand = parseResponsePacket(messBuffer);\n+\n+                    if (lastCommand == PS4Command.SERVER_STATUS_RSP) {\n+                        if (oskOpen && isLinked(CHANNEL_OSK_TEXT)) {\n+                            sendOSKStart();\n+                        } else {\n+                            sendStatus();\n+                        }\n+                    }\n+                }\n+            } catch (IOException e) {\n+                logger.debug(\"Connection read exception: {}\", e.getMessage());\n+            } finally {\n+                try {\n+                    channel.close();\n+                } catch (IOException e) {\n+                    logger.debug(\"Connection close exception: {}\", e.getMessage());\n+                }\n+            }\n+            updateState(CHANNEL_CONNECT, OnOffType.OFF);\n+            logger.debug(\"SocketHandler done.\");\n+            ps4Crypto.clearCiphers();\n+            loggedIn = false;\n+        }\n+    }\n+\n+    private @Nullable PS4Command parseResponsePacket(ByteBuffer rBuffer) {\n+        rBuffer.rewind();\n+        final int buffSize = rBuffer.remaining();\n+        final int size = rBuffer.getInt();\n+        if (size > buffSize || size < 12) {\n+            logger.debug(\"Response size ({}) not good, buffer size ({}).\", size, buffSize);\n+            return null;\n+        }\n+        int cmdValue = rBuffer.getInt();\n+        int statValue = rBuffer.getInt();\n+        PS4ErrorStatus status = PS4ErrorStatus.valueOfTag(statValue);\n+        PS4Command command = PS4Command.valueOfTag(cmdValue);\n+        byte[] respBuff = new byte[size];\n+        rBuffer.rewind();\n+        rBuffer.get(respBuff);\n+        if (command != null) {\n+            if (status == null) {\n+                logger.debug(\"Resp; size:{}, command:{}, statValue:{}, data:{}.\", size, command, statValue, respBuff);\n+            } else {\n+                logger.debug(\"Resp; size:{}, command:{}, status:{}, data:{}.\", size, command, status, respBuff);\n+            }\n+            switch (command) {\n+                case LOGIN_RSP:\n+                    if (status == null) {\n+                        logger.debug(\"Unhandled Login status value: {}\", statValue);\n+                        return command;\n+                    }\n+                    // Read login response\n+                    switch (status) {\n+                        case STATUS_OK:\n+                            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, status.message);\n+                            loggedIn = true;\n+                            if (isLinked(CHANNEL_2ND_SCREEN)) {\n+                                scheduler.execute(() -> {\n+                                    ByteBuffer outPacket = PS4PacketHandler\n+                                            .makeClientIDPacket(\"com.playstation.mobile2ndscreen\", \"18.9.3\");\n+                                    sendPacketEncrypted(outPacket, false);\n+                                });\n+                            }\n+                            break;\n+                        case STATUS_NOT_PAIRED:\n+                            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.CONFIGURATION_PENDING, status.message);\n+                            loggedIn = false;\n+                            break;\n+                        case STATUS_MISSING_PAIRING_CODE:\n+                        case STATUS_MISSING_PASS_CODE:\n+                        case STATUS_WRONG_PAIRING_CODE:\n+                        case STATUS_WRONG_PASS_CODE:\n+                        case STATUS_WRONG_USER_CREDENTIAL:\n+                            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.CONFIGURATION_ERROR, status.message);\n+                            loggedIn = false;\n+                            logger.debug(\"Not logged in: {}\", status.message);\n+                            break;\n+                        case STATUS_CAN_NOT_PLAY_NOW:\n+                        case STATUS_CLOSE_OTHER_APP:\n+                        case STATUS_COMMAND_NOT_GOOD:\n+                        case STATUS_COULD_NOT_LOG_IN:\n+                        case STATUS_DO_LOGIN:\n+                        case STATUS_MAX_USERS:\n+                        case STATUS_REGISTER_DEVICE_OVER:\n+                        case STATUS_RESTART_APP:\n+                        case STATUS_SOMEONE_ELSE_USING:\n+                        case STATUS_UPDATE_APP:\n+                        case STATUS_UPDATE_PS4:\n+                            updateStatus(ThingStatus.ONLINE, ThingStatusDetail.NONE, status.message);\n+                            loggedIn = false;\n+                            logger.debug(\"Not logged in: {}\", status.message);\n+                            break;\n+                        default:\n+                            logger.debug(\"Unhandled Login response status:{}, message:{}\", status, status.message);\n+                            break;\n+                    }\n+                    break;\n+                case APP_START_RSP:\n+                    if (status != null && status != PS4ErrorStatus.STATUS_OK) {\n+                        logger.debug(\"App start response: {}\", status.message);\n+                    }\n+                    break;\n+                case STANDBY_RSP:\n+                    if (status != null && status != PS4ErrorStatus.STATUS_OK) {\n+                        logger.debug(\"Standby response: {}\", status.message);\n+                    }\n+                    break;\n+                case SERVER_STATUS_RSP:\n+                    if ((statValue & 4) != 0) {\n+                        oskOpen = true;\n+                    } else {\n+                        if (oskOpen) {\n+                            updateState(CHANNEL_OSK_TEXT, StringType.valueOf(\"\"));\n+                        }\n+                        oskOpen = false;\n+                    }\n+                    logger.debug(\"Server status value:{}\", statValue);\n+                    break;\n+                case HTTPD_STATUS_RSP:\n+                    String httpdStat = PS4PacketHandler.parseHTTPdPacket(rBuffer);\n+                    logger.debug(\"HTTPd Response; {}\", httpdStat);\n+                    String secondScrStr = \"\";\n+                    int httpStatus = rBuffer.getInt(8);\n+                    int port = rBuffer.getInt(12);\n+                    if (httpStatus != 0 && port != 0) {\n+                        secondScrStr = \"http://\" + config.ipAddress + \":\" + port;\n+                    }\n+                    updateState(CHANNEL_2ND_SCREEN, StringType.valueOf(secondScrStr));\n+                    break;\n+                case OSK_CHANGE_STRING_REQ:\n+                    String oskText = PS4PacketHandler.parseOSKStringChangePacket(rBuffer);\n+                    updateState(CHANNEL_OSK_TEXT, StringType.valueOf(oskText));\n+                    break;\n+                case OSK_START_RSP:\n+                case OSK_CONTROL_REQ:\n+                case COMMENT_VIEWER_START_RESULT:\n+                case SCREEN_SHOT_RSP:\n+                case APP_START2_RSP:\n+                case LOGOUT_RSP:\n+                    break;\n+                default:\n+                    logger.debug(\"Unknown response, command:{}. Missing case.\", command);\n+                    break;\n+            }\n+        } else {\n+            logger.debug(\"Unknown resp-cmd, size:{}, command:{}, status:{}, data:{}.\", size, cmdValue, statValue,\n+                    respBuff);\n+        }\n+        return command;\n+    }\n+\n+    private SocketChannel getConnection() throws IOException {\n+        return getConnection(true);\n+    }\n+\n+    private SocketChannel getConnection(boolean requiresLogin) throws IOException {\n+        SocketChannel channel = null;\n+        SocketChannelHandler handler = socketChannelHandler;\n+        if (handler == null || !handler.isChannelOpen()) {\n+            try {\n+                handler = new SocketChannelHandler();\n+                socketChannelHandler = handler;\n+            } catch (IOException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+                throw e;\n+            }\n+        }\n+        channel = handler.getChannel();\n+        if (!loggedIn && requiresLogin) {\n+            login(channel);\n+        }\n+        return channel;\n+    }\n+\n+    private void sendPacketToPS4(ByteBuffer packet, SocketChannel channel, boolean encrypted, boolean restartTimeout) {\n+        PS4Command cmd = PS4Command.valueOfTag(packet.getInt(4));\n+        logger.debug(\"Sending {} packet.\", cmd);\n+        try {\n+            if (encrypted) {\n+                ByteBuffer outPacket = ps4Crypto.encryptPacket(packet);\n+                channel.write(outPacket);\n+            } else {\n+                channel.write(packet);\n+            }\n+            if (restartTimeout) {\n+                setupConnectionTimeout(config.connectionTimeout);\n+            }\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        }\n+    }\n+\n+    private void sendPacketEncrypted(ByteBuffer packet, SocketChannel channel) {\n+        sendPacketToPS4(packet, channel, true, true);\n+    }\n+\n+    private void sendPacketEncrypted(ByteBuffer packet) {\n+        sendPacketEncrypted(packet, true);\n+    }\n+\n+    private void sendPacketEncrypted(ByteBuffer packet, boolean requiresLogin) {\n+        try {\n+            SocketChannel channel = getConnection(requiresLogin);\n+            if (requiresLogin && !loggedIn) {\n+                scheduler.schedule(() -> sendPacketToPS4(packet, channel, true, requiresLogin), 250,\n+                        TimeUnit.MILLISECONDS);\n+            } else {\n+                sendPacketToPS4(packet, channel, true, requiresLogin);\n+            }\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * This is used as a heart beat to let the PS4 know that we are still listening.\n+     */\n+    private void sendStatus() {\n+        ByteBuffer outPacket = PS4PacketHandler.makeStatusPacket(0);\n+        sendPacketEncrypted(outPacket, false);\n+    }\n+\n+    private void login(SocketChannel channel) {\n+        // Send login request\n+        ByteBuffer outPacket = PS4PacketHandler.makeLoginPacket(config.userCredential, config.passCode,\n+                config.pairingCode);\n+        sendPacketEncrypted(outPacket, channel);\n+    }\n+\n+    private void login() {\n+        try {\n+            SocketChannel channel = getConnection(false);\n+            login(channel);\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        }\n+    }\n+\n+    /**\n+     * This closes the connection with the PS4.\n+     */\n+    private void sendByeBye() {\n+        ByteBuffer outPacket = PS4PacketHandler.makeByebyePacket();\n+        sendPacketEncrypted(outPacket, false);\n+    }\n+\n+    private void turnOnPS4() {\n+        wakeUpPS4();\n+        scheduler.schedule(this::waitAndConnectToPS4, 13, TimeUnit.SECONDS);\n+    }\n+\n+    private void waitAndConnectToPS4() {\n+        try {\n+            getConnection();\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        }\n+    }\n+\n+    private void sendStandby() {\n+        ByteBuffer outPacket = PS4PacketHandler.makeStandbyPacket();\n+        sendPacketEncrypted(outPacket);\n+    }\n+\n+    /**\n+     * Ask PS4 if the OSK is open so we can get and set text.\n+     */\n+    private void sendOSKStart() {\n+        ByteBuffer outPacket = PS4PacketHandler.makeOSKStartPacket();\n+        sendPacketEncrypted(outPacket);\n+    }\n+\n+    /**\n+     * Sets the entire OSK string on the PS4.\n+     *\n+     * @param text The text to set in the OSK.\n+     */\n+    private void setOSKText(String text) {\n+        logger.debug(\"Sending osk text packet,\\\"{}\\\"\", text);\n+        ByteBuffer outPacket = PS4PacketHandler.makeOSKStringChangePacket(text);\n+        sendPacketEncrypted(outPacket);\n+    }\n+\n+    /**\n+     * Tries to start an application on the PS4.\n+     *\n+     * @param applicationId The unique id for the application (CUSAxxxxx).\n+     */\n+    private void startApplication(String applicationId) {\n+        ByteBuffer outPacket = PS4PacketHandler.makeApplicationPacket(applicationId);\n+        sendPacketEncrypted(outPacket);\n+    }\n+\n+    private void sendRemoteKey(int pushedKey) {\n+        try {\n+            SocketChannelHandler scHandler = socketChannelHandler;\n+            int preWait = (scHandler == null || !loggedIn) ? POST_CONNECT_SENDKEY_DELAY_MS : 0;\n+            SocketChannel channel = getConnection();\n+\n+            scheduler.schedule(() -> {\n+                ByteBuffer outPacket = PS4PacketHandler.makeRemoteControlPacket(PS4_KEY_OPEN_RC);\n+                sendPacketEncrypted(outPacket, channel);\n+\n+                scheduler.schedule(() -> {\n+                    // Send remote key\n+                    ByteBuffer keyPacket = PS4PacketHandler.makeRemoteControlPacket(pushedKey);\n+                    sendPacketEncrypted(keyPacket, channel);\n+\n+                    scheduler.schedule(() -> {\n+                        ByteBuffer offPacket = PS4PacketHandler.makeRemoteControlPacket(PS4_KEY_OFF);\n+                        sendPacketEncrypted(offPacket, channel);\n+\n+                        scheduler.schedule(() -> {\n+                            ByteBuffer closePacket = PS4PacketHandler.makeRemoteControlPacket(PS4_KEY_CLOSE_RC);\n+                            sendPacketEncrypted(closePacket, channel);\n+                        }, MIN_SENDKEY_DELAY_MS, TimeUnit.MILLISECONDS);\n+\n+                    }, MIN_HOLDKEY_DELAY_MS, TimeUnit.MILLISECONDS);\n+\n+                }, MIN_SENDKEY_DELAY_MS, TimeUnit.MILLISECONDS);\n+\n+            }, preWait, TimeUnit.MILLISECONDS);\n+\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+        }\n+    }\n+\n+    private void parseSearchResponse(DatagramPacket packet) {\n+        byte[] data = packet.getData();\n+        String message = new String(data, StandardCharsets.UTF_8);\n+        String applicationName = \"\";\n+        String applicationId = \"\";\n+\n+        String[] rowStrings = message.trim().split(\"\\\\r?\\\\n\");\n+        for (String row : rowStrings) {\n+            int index = row.indexOf(':');\n+            if (index == -1) {\n+                OnOffType power = null;\n+                if (row.contains(\"200\")) {\n+                    power = OnOffType.ON;\n+                } else if (row.contains(\"620\")) {\n+                    power = OnOffType.OFF;\n+                }\n+                if (power != null) {\n+                    updateState(CHANNEL_POWER, power);\n+                    if (!currentPower.equals(power)) {\n+                        currentPower = power;\n+                        if (power.equals(OnOffType.ON) && config.autoConnect) {\n+                            SocketChannelHandler scHandler = socketChannelHandler;\n+                            if (scHandler == null || !loggedIn) {\n+                                logger.debug(\"Trying to login after power on.\");\n+                                scheduler.schedule(() -> login(), 20, TimeUnit.SECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b5efd6b29b01ff1b2384e8ae94061d10ad8ae41"}, "originalPosition": 783}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMwMjQ0OQ==", "bodyText": "You should check whether or not this handler has been disposed of before you try scheduling more things here.", "url": "https://github.com/openhab/openhab-addons/pull/8585#discussion_r501302449", "createdAt": "2020-10-07T20:51:40Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.playstation/src/main/java/org/openhab/binding/playstation/internal/PS3Handler.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.playstation.internal;\n+\n+import static org.openhab.binding.playstation.internal.PlayStationBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.net.SocketTimeoutException;\n+import java.nio.channels.SocketChannel;\n+import java.nio.charset.StandardCharsets;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.util.HexUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link PS3Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Fredrik Ahlstr\u00f6m - Initial contribution\n+ */\n+@NonNullByDefault\n+public class PS3Handler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(PS3Handler.class);\n+    private static final int SOCKET_TIMEOUT_SECONDS = 2;\n+\n+    private PS3Configuration config = new PS3Configuration();\n+\n+    private @Nullable ScheduledFuture<?> refreshTimer;\n+\n+    public PS3Handler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (!(command instanceof RefreshType)) {\n+            if (CHANNEL_POWER.equals(channelUID.getId()) && command instanceof OnOffType) {\n+                if (command.equals(OnOffType.ON)) {\n+                    turnOnPS3();\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(PS3Configuration.class);\n+\n+        updateStatus(ThingStatus.ONLINE);\n+        setupRefreshTimer();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        final ScheduledFuture<?> timer = refreshTimer;\n+        if (timer != null) {\n+            timer.cancel(false);\n+            refreshTimer = null;\n+        }\n+    }\n+\n+    /**\n+     * Sets up a timer for querying the PS3 (using the scheduler) every 10 seconds.\n+     */\n+    private void setupRefreshTimer() {\n+        final ScheduledFuture<?> timer = refreshTimer;\n+        if (timer != null) {\n+            timer.cancel(false);\n+        }\n+        refreshTimer = scheduler.scheduleWithFixedDelay(this::updateAllChannels, 0, 10, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * This tries to connect to port 5223 on the PS3,\n+     * if the connection times out the PS3 is OFF, if connection is refused the PS3 is ON.\n+     */\n+    private void updateAllChannels() {\n+        try (SocketChannel channel = SocketChannel.open()) {\n+            Socket socket = channel.socket();\n+            socket.setSoTimeout(SOCKET_TIMEOUT_SECONDS * 1000);\n+            channel.configureBlocking(true);\n+            channel.connect(new InetSocketAddress(config.ipAddress, DEFAULT_PS3_WAKE_ON_LAN_PORT));\n+        } catch (IOException e) {\n+            String message = e.getMessage();\n+            if (message.contains(\"refused\")) {\n+                updateState(CHANNEL_POWER, OnOffType.ON);\n+                updateStatus(ThingStatus.ONLINE);\n+            } else if (message.contains(\"timed out\") || message.contains(\"is down\")) {\n+                updateState(CHANNEL_POWER, OnOffType.OFF);\n+            } else {\n+                logger.debug(\"PS3 read power, IOException: {}\", e.getMessage());\n+            }\n+        }\n+    }\n+\n+    private void turnOnPS3() {\n+        try {\n+            InetAddress bcAddress = InetAddress.getByName(\"255.255.255.255\");\n+\n+            // send WOL magic packet\n+            byte[] magicPacket = makeWOLMagicPacket(thing.getProperties().get(Thing.PROPERTY_MAC_ADDRESS));\n+            logger.debug(\"PS3 wol packet: {}\", magicPacket);\n+            DatagramPacket wakePacket = new DatagramPacket(magicPacket, magicPacket.length, bcAddress,\n+                    DEFAULT_PS3_WAKE_ON_LAN_PORT);\n+            // send discover\n+            byte[] discover = \"SRCH\".getBytes(StandardCharsets.US_ASCII);\n+            DatagramPacket srchPacket = new DatagramPacket(discover, discover.length, bcAddress,\n+                    DEFAULT_PS3_WAKE_ON_LAN_PORT);\n+            logger.debug(\"Search message: '{}'\", discover);\n+\n+            // wait for responses\n+            byte[] rxbuf = new byte[256];\n+            DatagramPacket receivePacket = new DatagramPacket(rxbuf, rxbuf.length);\n+            scheduler.execute(() -> wakeMethod(srchPacket, receivePacket, wakePacket, 34));\n+        } catch (IOException e) {\n+            logger.debug(\"No PS3 device found. Diagnostic: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private void wakeMethod(DatagramPacket srchPacket, DatagramPacket receivePacket, DatagramPacket wakePacket,\n+            int triesLeft) {\n+        try (DatagramSocket searchSocket = new DatagramSocket(); DatagramSocket wakeSocket = new DatagramSocket();) {\n+            wakeSocket.setBroadcast(true);\n+            searchSocket.setBroadcast(true);\n+            searchSocket.setSoTimeout(1000);\n+\n+            searchSocket.send(srchPacket);\n+            try {\n+                searchSocket.receive(receivePacket);\n+                logger.debug(\"PS3 started?: '{}'\", receivePacket);\n+                return;\n+            } catch (SocketTimeoutException e) {\n+                // try again\n+            }\n+            wakeSocket.send(wakePacket);\n+            if (triesLeft <= 0) {\n+                logger.debug(\"PS3 not started!\");\n+            } else {\n+                scheduler.execute(() -> wakeMethod(srchPacket, receivePacket, wakePacket, triesLeft - 1));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1b5efd6b29b01ff1b2384e8ae94061d10ad8ae41"}, "originalPosition": 167}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5d616c1ef3e50524875d201dd4c89027c4bfbd0b", "author": {"user": {"login": "FluBBaOfWard", "name": "Fredrik Ahlstr\u00f6m"}}, "url": "https://github.com/openhab/openhab-addons/commit/5d616c1ef3e50524875d201dd4c89027c4bfbd0b", "committedDate": "2020-10-17T08:36:39Z", "message": "[playstation] Some more fixes for the PR.\n\nSigned-off-by: Fredrik Ahlstro\u0308m <fredrikahlstrom75@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI1Njk4NTI0", "url": "https://github.com/openhab/openhab-addons/pull/8585#pullrequestreview-525698524", "createdAt": "2020-11-08T02:08:32Z", "commit": {"oid": "5d616c1ef3e50524875d201dd4c89027c4bfbd0b"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOFQwMjowODozM1rOHvMOlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOFQwMjowODozM1rOHvMOlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTI0NTQ2MA==", "bodyText": "This should be set to false during initialization. Otherwise the handler instance can't be reused.", "url": "https://github.com/openhab/openhab-addons/pull/8585#discussion_r519245460", "createdAt": "2020-11-08T02:08:33Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.playstation/src/main/java/org/openhab/binding/playstation/internal/PS3Handler.java", "diffHunk": "@@ -50,6 +50,7 @@\n \n     private final Logger logger = LoggerFactory.getLogger(PS3Handler.class);\n     private static final int SOCKET_TIMEOUT_SECONDS = 2;\n+    private boolean isDisposed = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5d616c1ef3e50524875d201dd4c89027c4bfbd0b"}, "originalPosition": 4}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a0b70c027d0582a316c9d0906a2521213fc518e2", "author": {"user": {"login": "FluBBaOfWard", "name": "Fredrik Ahlstr\u00f6m"}}, "url": "https://github.com/openhab/openhab-addons/commit/a0b70c027d0582a316c9d0906a2521213fc518e2", "committedDate": "2020-11-14T11:41:26Z", "message": "[playstation] Fixed initialisation of isDisposed in PS3Handler.\n\nSigned-off-by: Fredrik Ahlstro\u0308m <fredrikahlstrom75@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f1e4cb61f06f97b34fb54ac02fe2f70ae82fe156", "author": {"user": {"login": "FluBBaOfWard", "name": "Fredrik Ahlstr\u00f6m"}}, "url": "https://github.com/openhab/openhab-addons/commit/f1e4cb61f06f97b34fb54ac02fe2f70ae82fe156", "committedDate": "2020-11-23T18:22:27Z", "message": "[playstation] Fixed handling of Futures during dispose.\n\nSigned-off-by: Fredrik Ahlstro\u0308m <fredrikahlstrom75@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2OTEwNDcw", "url": "https://github.com/openhab/openhab-addons/pull/8585#pullrequestreview-536910470", "createdAt": "2020-11-23T22:57:04Z", "commit": {"oid": "f1e4cb61f06f97b34fb54ac02fe2f70ae82fe156"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0f808c5c1afe108e13039fe5e84266a257cf64a4", "author": {"user": {"login": "FluBBaOfWard", "name": "Fredrik Ahlstr\u00f6m"}}, "url": "https://github.com/openhab/openhab-addons/commit/0f808c5c1afe108e13039fe5e84266a257cf64a4", "committedDate": "2020-11-24T17:10:38Z", "message": "[playstation] Hopefully fixed the null issue.\n\nSigned-off-by: Fredrik Ahlstro\u0308m <fredrikahlstrom75@gmail.com>"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4699, "cost": 1, "resetAt": "2021-10-28T20:13:43Z"}}}