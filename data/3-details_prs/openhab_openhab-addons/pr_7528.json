{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEyNDY1OTg2", "number": 7528, "title": "[novafinedust] Nova Fine Dust binding for SDS011 sensors", "bodyText": "Closes #7527\nSigned-off-by: Stefan Triller github@stefantriller.de", "createdAt": "2020-05-02T15:21:15Z", "url": "https://github.com/openhab/openhab-addons/pull/7528", "merged": true, "mergeCommit": {"oid": "0b20457d8a3d5c656cc0aa877de085ae5b70d978"}, "closed": true, "closedAt": "2020-06-14T11:34:10Z", "author": {"login": "t2000"}, "timelineItems": {"totalCount": 31, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcdYA_CgBqjMyOTYyMjUwNTM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcrJbYqgFqTQzMDIwNjEwNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4efa7b4f18dccb0b08da6eda939a6ccc41d87248", "author": {"user": {"login": "t2000", "name": "Stefan Triller"}}, "url": "https://github.com/openhab/openhab-addons/commit/4efa7b4f18dccb0b08da6eda939a6ccc41d87248", "committedDate": "2020-05-02T15:20:32Z", "message": "Nova Fine Dust binding for SDS011 sensors\n\nCloses #7527\n\nSigned-off-by: Stefan Triller <github@stefantriller.de>"}, "afterCommit": {"oid": "082d9ead955ebed650a8633f622b4ed35639f597", "author": {"user": {"login": "t2000", "name": "Stefan Triller"}}, "url": "https://github.com/openhab/openhab-addons/commit/082d9ead955ebed650a8633f622b4ed35639f597", "committedDate": "2020-05-02T15:28:32Z", "message": "Nova Fine Dust binding for SDS011 sensors\n\nCloses #7527\n\nSigned-off-by: Stefan Triller <github@stefantriller.de>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "082d9ead955ebed650a8633f622b4ed35639f597", "author": {"user": {"login": "t2000", "name": "Stefan Triller"}}, "url": "https://github.com/openhab/openhab-addons/commit/082d9ead955ebed650a8633f622b4ed35639f597", "committedDate": "2020-05-02T15:28:32Z", "message": "Nova Fine Dust binding for SDS011 sensors\n\nCloses #7527\n\nSigned-off-by: Stefan Triller <github@stefantriller.de>"}, "afterCommit": {"oid": "17ab9e48eb7ee697b10405fcdabcba5a6d99288a", "author": {"user": {"login": "t2000", "name": "Stefan Triller"}}, "url": "https://github.com/openhab/openhab-addons/commit/17ab9e48eb7ee697b10405fcdabcba5a6d99288a", "committedDate": "2020-05-02T15:42:20Z", "message": "Nova Fine Dust binding for SDS011 sensors\n\nCloses #7527\n\nSigned-off-by: Stefan Triller <github@stefantriller.de>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE3MTQxNjU4", "url": "https://github.com/openhab/openhab-addons/pull/7528#pullrequestreview-417141658", "createdAt": "2020-05-22T19:25:03Z", "commit": {"oid": "17ab9e48eb7ee697b10405fcdabcba5a6d99288a"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxOToyNTowNFrOGZhrng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQyMDowMDoxMFrOGZiYuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQxOTQyMg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            | port              | yes       | the port the sensor is connected to, i.e. /detv/ttyUSB0.                              |\n          \n          \n            \n            | port              | yes       | the port the sensor is connected to, i.e. /dev/ttyUSB0.                               |", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r429419422", "createdAt": "2020-05-22T19:25:04Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.novafinedust/README.md", "diffHunk": "@@ -0,0 +1,78 @@\n+# NovaFineDust Binding\n+\n+This binding is for the fine dust sensor (PM Sensor) from Nova Fitness. Currently only one model is supported, the SDS011.\n+\n+It basically implements the protocol specified in [this document](https://cdn.sparkfun.com/assets/parts/1/2/2/7/5/Laser_Dust_Sensor_Control_Protocol_V1.3.pdf).\n+One can measure the PM 2.5 and PM 10 values with this device. It comes very handy for detecting air pollution like neighbors firing their oven with wet wood etc. so one can deactivate the ventilation system. \n+\n+## Supported Things\n+\n+There is only one Thing for this binding is `SDS011`.\n+\n+## Discovery\n+\n+There is no automatic discovery. The Thing has to be added manually via the `.things` configuration file or via (Paper) UI.\n+\n+## Thing Configuration\n+\n+There are 2 different working modes for the `SDS011` thing: Reporting and Polling.\n+\n+### Reporting\n+\n+This is the preferred mode and thus also configured as a default. In this mode the sensor wakes up every `reportingInterval` minutes, performs a measurement for 30 seconds and sleeps for `reportingInterval` minus 30 seconds. Remember: According to the [datasheet](https://www-sd-nf.oss-cn-beijing.aliyuncs.com/%E5%AE%98%E7%BD%91%E4%B8%8B%E8%BD%BD/SDS011%20laser%20PM2.5%20sensor%20specification-V1.4.pdf) the sensor has a lifetime of 8000 hours. Using a 0 as `reportingInterval` will make the sensor report its data as fast as possible.\n+\n+### Polling\n+\n+If one needs data in different intervals, i.e. not as fast as possible and not in intervals that are a multiple of full minutes, polling can be configured. The `pollingInterval` parameter specifies the time in seconds when data will be polled from the sensor.\n+\n+In addition to the mode one has to provide the port to which the device is connected.\n+\n+A full overview about the parameters of the `SDS011` thing is given in the following table:\n+\n+| parameter name    | mandatory | description                                                                           |\n+|-------------------|-----------|---------------------------------------------------------------------------------------|\n+| port              | yes       | the port the sensor is connected to, i.e. /detv/ttyUSB0.                              |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17ab9e48eb7ee697b10405fcdabcba5a6d99288a"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQyMDQ5OQ==", "bodyText": "typo \"Tolerance\"", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r429420499", "createdAt": "2020-05-22T19:27:57Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/SDS011Handler.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.ZonedDateTime;\n+import java.time.chrono.ChronoZonedDateTime;\n+import java.time.temporal.Temporal;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.dimension.Density;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.SDS011Communicator;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.WorkMode;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SDS011Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SDS011Handler extends BaseThingHandler {\n+    private static final Duration CONNECTION_MONITOR_START_DELAY_OFFSET = Duration.ofSeconds(10);\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Handler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    private @NonNullByDefault({}) NovaFineDustConfiguration config;\n+    private @NonNullByDefault({}) SDS011Communicator communicator;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable ScheduledFuture<?> connectionMonitor;\n+\n+    private Temporal lastCommunication = ZonedDateTime.now();\n+\n+    // initialize timeBetweenDataShouldArrive with a large number\n+    private Duration timeBetweenDataShouldArrive = Duration.ofDays(1);\n+    private final Duration dataCanBeLateTollerance = Duration.ofSeconds(5);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17ab9e48eb7ee697b10405fcdabcba5a6d99288a"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQyNDE3OA==", "bodyText": "The Thing is not set as online again, if the connection succeeds in one of the upcoming cycles.", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r429424178", "createdAt": "2020-05-22T19:38:15Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/SDS011Handler.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.ZonedDateTime;\n+import java.time.chrono.ChronoZonedDateTime;\n+import java.time.temporal.Temporal;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.dimension.Density;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.SDS011Communicator;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.WorkMode;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SDS011Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SDS011Handler extends BaseThingHandler {\n+    private static final Duration CONNECTION_MONITOR_START_DELAY_OFFSET = Duration.ofSeconds(10);\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Handler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    private @NonNullByDefault({}) NovaFineDustConfiguration config;\n+    private @NonNullByDefault({}) SDS011Communicator communicator;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable ScheduledFuture<?> connectionMonitor;\n+\n+    private Temporal lastCommunication = ZonedDateTime.now();\n+\n+    // initialize timeBetweenDataShouldArrive with a large number\n+    private Duration timeBetweenDataShouldArrive = Duration.ofDays(1);\n+    private final Duration dataCanBeLateTollerance = Duration.ofSeconds(5);\n+\n+    public SDS011Handler(Thing thing, SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // we do not support refreshing as values are either reported by the device or polled from the device in fixed\n+        // intervals\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        config = getConfigAs(NovaFineDustConfiguration.class);\n+\n+        if (!validateConfiguration()) {\n+            return;\n+        }\n+\n+        // parse ports and if the port is found, initialize the reader\n+        SerialPortIdentifier portId = serialPortManager.getIdentifier(config.port);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port is not known!\");\n+            return;\n+        }\n+\n+        this.communicator = new SDS011Communicator(this, portId);\n+\n+        if (config.reporting) {\n+            timeBetweenDataShouldArrive = Duration.ofMinutes(config.reportingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.REPORTING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        } else {\n+            timeBetweenDataShouldArrive = Duration.ofSeconds(config.pollingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.POLLING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        }\n+\n+        Duration connectionMonitorStartDelay = timeBetweenDataShouldArrive.plus(CONNECTION_MONITOR_START_DELAY_OFFSET);\n+        connectionMonitor = scheduler.scheduleWithFixedDelay(this::verifyIfStillConnected,\n+                connectionMonitorStartDelay.getSeconds(), timeBetweenDataShouldArrive.getSeconds(), TimeUnit.SECONDS);\n+    }\n+\n+    private void initializeCommunicator(WorkMode mode, Duration interval) {\n+        boolean initSuccessful = false;\n+        try {\n+            initSuccessful = communicator.initialize(mode, interval);\n+        } catch (final IOException ex) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"I/O error!\");\n+            return;\n+        } catch (PortInUseException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"Port is in use!\");\n+            return;\n+        } catch (TooManyListenersException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Cannot attach listener to port!\");\n+            return;\n+        } catch (UnsupportedCommOperationException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Cannot set serial port parameters\");\n+            return;\n+        }\n+\n+        if (initSuccessful) {\n+            lastCommunication = ZonedDateTime.now();\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            if (mode == WorkMode.POLLING) {\n+                pollingJob = scheduler.scheduleWithFixedDelay(() -> {\n+                    try {\n+                        communicator.requestSensorData();\n+                    } catch (IOException e) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17ab9e48eb7ee697b10405fcdabcba5a6d99288a"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQyNDkxOQ==", "bodyText": "You don't need to check the config again, if you configured min/max etc. in the XML files.", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r429424919", "createdAt": "2020-05-22T19:40:17Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/SDS011Handler.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.ZonedDateTime;\n+import java.time.chrono.ChronoZonedDateTime;\n+import java.time.temporal.Temporal;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.dimension.Density;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.SDS011Communicator;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.WorkMode;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SDS011Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SDS011Handler extends BaseThingHandler {\n+    private static final Duration CONNECTION_MONITOR_START_DELAY_OFFSET = Duration.ofSeconds(10);\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Handler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    private @NonNullByDefault({}) NovaFineDustConfiguration config;\n+    private @NonNullByDefault({}) SDS011Communicator communicator;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable ScheduledFuture<?> connectionMonitor;\n+\n+    private Temporal lastCommunication = ZonedDateTime.now();\n+\n+    // initialize timeBetweenDataShouldArrive with a large number\n+    private Duration timeBetweenDataShouldArrive = Duration.ofDays(1);\n+    private final Duration dataCanBeLateTollerance = Duration.ofSeconds(5);\n+\n+    public SDS011Handler(Thing thing, SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // we do not support refreshing as values are either reported by the device or polled from the device in fixed\n+        // intervals\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        config = getConfigAs(NovaFineDustConfiguration.class);\n+\n+        if (!validateConfiguration()) {\n+            return;\n+        }\n+\n+        // parse ports and if the port is found, initialize the reader\n+        SerialPortIdentifier portId = serialPortManager.getIdentifier(config.port);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port is not known!\");\n+            return;\n+        }\n+\n+        this.communicator = new SDS011Communicator(this, portId);\n+\n+        if (config.reporting) {\n+            timeBetweenDataShouldArrive = Duration.ofMinutes(config.reportingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.REPORTING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        } else {\n+            timeBetweenDataShouldArrive = Duration.ofSeconds(config.pollingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.POLLING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        }\n+\n+        Duration connectionMonitorStartDelay = timeBetweenDataShouldArrive.plus(CONNECTION_MONITOR_START_DELAY_OFFSET);\n+        connectionMonitor = scheduler.scheduleWithFixedDelay(this::verifyIfStillConnected,\n+                connectionMonitorStartDelay.getSeconds(), timeBetweenDataShouldArrive.getSeconds(), TimeUnit.SECONDS);\n+    }\n+\n+    private void initializeCommunicator(WorkMode mode, Duration interval) {\n+        boolean initSuccessful = false;\n+        try {\n+            initSuccessful = communicator.initialize(mode, interval);\n+        } catch (final IOException ex) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"I/O error!\");\n+            return;\n+        } catch (PortInUseException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"Port is in use!\");\n+            return;\n+        } catch (TooManyListenersException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Cannot attach listener to port!\");\n+            return;\n+        } catch (UnsupportedCommOperationException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Cannot set serial port parameters\");\n+            return;\n+        }\n+\n+        if (initSuccessful) {\n+            lastCommunication = ZonedDateTime.now();\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            if (mode == WorkMode.POLLING) {\n+                pollingJob = scheduler.scheduleWithFixedDelay(() -> {\n+                    try {\n+                        communicator.requestSensorData();\n+                    } catch (IOException e) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                                \"Cannot query data from device\");\n+                    }\n+                }, 2, config.pollingInterval, TimeUnit.SECONDS);\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Commands and replies from the device don't seem to match\");\n+            logger.debug(\"Could not configure sensor -> setting Thing to OFFLINE and disposing the handler\");\n+            dispose();\n+        }\n+    }\n+\n+    private boolean validateConfiguration() {\n+        if (config.port == null || config.port.isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port must be set!\");\n+            return false;\n+        }\n+\n+        if (config.reporting) {\n+            if (config.reportingInterval < 0 || config.reportingInterval > 30) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Reporting interval has to be between 0 and 30 minutes\");\n+                return false;\n+            }\n+        } else {\n+            if (config.pollingInterval < 3 || config.pollingInterval > 3600) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Polling interval has to be between 3 and 3600 seconds\");\n+                return false;\n+            }\n+        }\n+        return true;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17ab9e48eb7ee697b10405fcdabcba5a6d99288a"}, "originalPosition": 177}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQyNjQ2MQ==", "bodyText": "If you use ZonedDateTime instead of Temporal, you could remove this cast.", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r429426461", "createdAt": "2020-05-22T19:44:40Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/SDS011Handler.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.ZonedDateTime;\n+import java.time.chrono.ChronoZonedDateTime;\n+import java.time.temporal.Temporal;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.dimension.Density;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.SDS011Communicator;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.WorkMode;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SDS011Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SDS011Handler extends BaseThingHandler {\n+    private static final Duration CONNECTION_MONITOR_START_DELAY_OFFSET = Duration.ofSeconds(10);\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Handler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    private @NonNullByDefault({}) NovaFineDustConfiguration config;\n+    private @NonNullByDefault({}) SDS011Communicator communicator;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable ScheduledFuture<?> connectionMonitor;\n+\n+    private Temporal lastCommunication = ZonedDateTime.now();\n+\n+    // initialize timeBetweenDataShouldArrive with a large number\n+    private Duration timeBetweenDataShouldArrive = Duration.ofDays(1);\n+    private final Duration dataCanBeLateTollerance = Duration.ofSeconds(5);\n+\n+    public SDS011Handler(Thing thing, SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // we do not support refreshing as values are either reported by the device or polled from the device in fixed\n+        // intervals\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        config = getConfigAs(NovaFineDustConfiguration.class);\n+\n+        if (!validateConfiguration()) {\n+            return;\n+        }\n+\n+        // parse ports and if the port is found, initialize the reader\n+        SerialPortIdentifier portId = serialPortManager.getIdentifier(config.port);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port is not known!\");\n+            return;\n+        }\n+\n+        this.communicator = new SDS011Communicator(this, portId);\n+\n+        if (config.reporting) {\n+            timeBetweenDataShouldArrive = Duration.ofMinutes(config.reportingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.REPORTING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        } else {\n+            timeBetweenDataShouldArrive = Duration.ofSeconds(config.pollingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.POLLING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        }\n+\n+        Duration connectionMonitorStartDelay = timeBetweenDataShouldArrive.plus(CONNECTION_MONITOR_START_DELAY_OFFSET);\n+        connectionMonitor = scheduler.scheduleWithFixedDelay(this::verifyIfStillConnected,\n+                connectionMonitorStartDelay.getSeconds(), timeBetweenDataShouldArrive.getSeconds(), TimeUnit.SECONDS);\n+    }\n+\n+    private void initializeCommunicator(WorkMode mode, Duration interval) {\n+        boolean initSuccessful = false;\n+        try {\n+            initSuccessful = communicator.initialize(mode, interval);\n+        } catch (final IOException ex) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"I/O error!\");\n+            return;\n+        } catch (PortInUseException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"Port is in use!\");\n+            return;\n+        } catch (TooManyListenersException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Cannot attach listener to port!\");\n+            return;\n+        } catch (UnsupportedCommOperationException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Cannot set serial port parameters\");\n+            return;\n+        }\n+\n+        if (initSuccessful) {\n+            lastCommunication = ZonedDateTime.now();\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            if (mode == WorkMode.POLLING) {\n+                pollingJob = scheduler.scheduleWithFixedDelay(() -> {\n+                    try {\n+                        communicator.requestSensorData();\n+                    } catch (IOException e) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                                \"Cannot query data from device\");\n+                    }\n+                }, 2, config.pollingInterval, TimeUnit.SECONDS);\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Commands and replies from the device don't seem to match\");\n+            logger.debug(\"Could not configure sensor -> setting Thing to OFFLINE and disposing the handler\");\n+            dispose();\n+        }\n+    }\n+\n+    private boolean validateConfiguration() {\n+        if (config.port == null || config.port.isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port must be set!\");\n+            return false;\n+        }\n+\n+        if (config.reporting) {\n+            if (config.reportingInterval < 0 || config.reportingInterval > 30) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Reporting interval has to be between 0 and 30 minutes\");\n+                return false;\n+            }\n+        } else {\n+            if (config.pollingInterval < 3 || config.pollingInterval > 3600) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Polling interval has to be between 3 and 3600 seconds\");\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (pollingJob != null && !pollingJob.isCancelled()) {\n+            pollingJob.cancel(true);\n+            pollingJob = null;\n+        }\n+\n+        if (connectionMonitor != null && !connectionMonitor.isCancelled()) {\n+            connectionMonitor.cancel(true);\n+            connectionMonitor = null;\n+        }\n+\n+        if (communicator != null) {\n+            scheduler.schedule(() -> communicator.dispose(), 0, TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    /**\n+     * Pass the data from the device to the Thing channels\n+     *\n+     * @param sensorData the parsed data from the sensor\n+     */\n+    public void updateChannels(SensorMeasuredDataReply sensorData) {\n+        if (sensorData.isValidData()) {\n+            logger.debug(\"Updating channels with data: {}\", sensorData);\n+\n+            QuantityType<Density> statePM10 = new QuantityType<>(sensorData.getPm10(),\n+                    SmartHomeUnits.MICROGRAM_PER_CUBICMETRE);\n+            updateState(NovaFineDustBindingConstants.CHANNEL_PM10, statePM10);\n+\n+            QuantityType<Density> statePM25 = new QuantityType<>(sensorData.getPm25(),\n+                    SmartHomeUnits.MICROGRAM_PER_CUBICMETRE);\n+            updateState(NovaFineDustBindingConstants.CHANNEL_PM25, statePM25);\n+\n+            updateStatus(ThingStatus.ONLINE);\n+        }\n+        // there was a communication, even if the data was not valid, thus resetting the value here\n+        lastCommunication = ZonedDateTime.now();\n+    }\n+\n+    private void verifyIfStillConnected() {\n+        ZonedDateTime now = ZonedDateTime.now();\n+        Temporal lastData = lastCommunication.plus(timeBetweenDataShouldArrive).plus(dataCanBeLateTollerance);\n+        if (now.isAfter((ChronoZonedDateTime<?>) lastData)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17ab9e48eb7ee697b10405fcdabcba5a6d99288a"}, "originalPosition": 222}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQzMDIwNA==", "bodyText": "Bindings should only log as error, when a bug in the code is detected. You could use warn here.", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r429430204", "createdAt": "2020-05-22T19:57:02Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/SDS011Communicator.java", "diffHunk": "@@ -0,0 +1,287 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal.sds011protocol;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.TooManyListenersException;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.SDS011Handler;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.CommandMessage;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.Constants;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.ModeReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorFirmwareReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SleepReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.WorkingPeriodReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Central instance to communicate with the device, i.e. receive data from it and send commands to it\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class SDS011Communicator implements SerialPortEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Communicator.class);\n+\n+    private SerialPortIdentifier portId;\n+    private SDS011Handler thingHandler;\n+    private @NonNullByDefault({}) SerialPort serialPort;\n+\n+    private @NonNullByDefault({}) OutputStream outputStream;\n+    private @NonNullByDefault({}) InputStream inputStream;\n+\n+    public SDS011Communicator(SDS011Handler thingHandler, SerialPortIdentifier portId) {\n+        this.thingHandler = thingHandler;\n+        this.portId = portId;\n+    }\n+\n+    /**\n+     * Initialize the communication with the device, i.e. open the serial port etc.\n+     *\n+     * @param mode the {@link WorkMode} if we want to use polling or reporting\n+     * @param interval the time between polling or reportings\n+     * @return {@code true} if we can communicate with the device\n+     * @throws PortInUseException\n+     * @throws TooManyListenersException\n+     * @throws IOException\n+     * @throws UnsupportedCommOperationException\n+     */\n+    public boolean initialize(WorkMode mode, Duration interval)\n+            throws PortInUseException, TooManyListenersException, IOException, UnsupportedCommOperationException {\n+        boolean initSuccessful = true;\n+\n+        SerialPort localSerialPort = portId.open(thingHandler.getThing().getUID().toString(), 2000);\n+        localSerialPort.setSerialPortParams(9600, 8, 1, 0);\n+\n+        outputStream = localSerialPort.getOutputStream();\n+        inputStream = localSerialPort.getInputStream();\n+\n+        if (inputStream == null || outputStream == null) {\n+            throw new IOException(\"Could not create input or outputstream for the port\");\n+        }\n+\n+        // wake up the device\n+        initSuccessful &= sendSleep(false);\n+        initSuccessful &= getFirmware();\n+\n+        if (mode == WorkMode.POLLING) {\n+            initSuccessful &= setMode(WorkMode.POLLING);\n+            initSuccessful &= setWorkingPeriod((byte) 0);\n+        } else {\n+            // reporting\n+            initSuccessful &= setWorkingPeriod((byte) interval.toMinutes());\n+            initSuccessful &= setMode(WorkMode.REPORTING);\n+        }\n+\n+        // enable listeners only after we have configured the sensor above because for configuring we send and read data\n+        // sequentially\n+        localSerialPort.notifyOnDataAvailable(true);\n+        localSerialPort.addEventListener(this);\n+        this.serialPort = localSerialPort;\n+\n+        return initSuccessful;\n+    }\n+\n+    private @Nullable SensorReply sendCommand(CommandMessage message) throws IOException {\n+        byte[] commandData = message.getBytes();\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Will send command: {} ({})\", Helper.toHexString(commandData), Arrays.toString(commandData));\n+        }\n+        outputStream.write(commandData, 0, commandData.length);\n+        outputStream.flush();\n+        try {\n+            // Give the sensor some time to handle the command\n+            Thread.sleep(500);\n+        } catch (InterruptedException e) {\n+            logger.warn(\"Problem while waiting for reading a reply to our command.\");\n+            Thread.currentThread().interrupt();\n+        }\n+        SensorReply reply = readReply();\n+        // in case there is still another reporting active, we want to discard the sensor data and read the reply to our\n+        // command again\n+        if (reply instanceof SensorMeasuredDataReply) {\n+            reply = readReply();\n+        }\n+        return reply;\n+    }\n+\n+    private boolean setWorkingPeriod(byte period) throws IOException {\n+        CommandMessage m = new CommandMessage(Command.WORKING_PERIOD, new byte[] { Constants.SET_ACTION, period });\n+        logger.debug(\"Sending work period: {}\", period);\n+        SensorReply reply = sendCommand(m);\n+        logger.debug(\"Got reply to setWorkingPeriod command: {}\", reply);\n+        if (reply instanceof WorkingPeriodReply) {\n+            WorkingPeriodReply wpReply = (WorkingPeriodReply) reply;\n+            if (wpReply.getPeriod() == period && wpReply.getActionType() == Constants.SET_ACTION) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean setMode(WorkMode workMode) throws IOException {\n+        byte haveToRequestData = 0;\n+        if (workMode == WorkMode.POLLING) {\n+            haveToRequestData = 1;\n+        }\n+\n+        CommandMessage m = new CommandMessage(Command.MODE, new byte[] { Constants.SET_ACTION, haveToRequestData });\n+        logger.debug(\"Sending mode: {}\", workMode);\n+        SensorReply reply = sendCommand(m);\n+        logger.debug(\"Got reply to setMode command: {}\", reply);\n+        if (reply instanceof ModeReply) {\n+            ModeReply mr = (ModeReply) reply;\n+            if (mr.getActionType() == Constants.SET_ACTION && mr.getMode() == workMode) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean sendSleep(boolean doSleep) throws IOException {\n+        byte payload = (byte) 1;\n+        if (doSleep) {\n+            payload = (byte) 0;\n+        }\n+\n+        CommandMessage m = new CommandMessage(Command.SLEEP, new byte[] { Constants.SET_ACTION, payload });\n+        logger.debug(\"Sending doSleep: {}\", doSleep);\n+        SensorReply reply = sendCommand(m);\n+        logger.debug(\"Got reply to sendSleep command: {}\", reply);\n+\n+        if (!doSleep) {\n+            // sometimes the sensor does not wakeup on the first attempt, thus we try again\n+            for (int i = 0; reply == null && i < 3; i++) {\n+                reply = sendCommand(m);\n+                logger.debug(\"Got reply to sendSleep command after retry#{}: {}\", i + 1, reply);\n+            }\n+        }\n+\n+        if (reply instanceof SleepReply) {\n+            SleepReply sr = (SleepReply) reply;\n+            if (sr.getActionType() == Constants.SET_ACTION && sr.getSleep() == payload) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean getFirmware() throws IOException {\n+        CommandMessage m = new CommandMessage(Command.FIRMWARE, new byte[] {});\n+        logger.debug(\"Sending get firmware request\");\n+        SensorReply reply = sendCommand(m);\n+        logger.debug(\"Got reply to getFirmware command: {}\", reply);\n+\n+        if (reply instanceof SensorFirmwareReply) {\n+            SensorFirmwareReply fwReply = (SensorFirmwareReply) reply;\n+            thingHandler.setFirmware(fwReply.getFirmware());\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Request data from the device, they will be returned via the serialEvent callback\n+     *\n+     * @throws IOException\n+     */\n+    public void requestSensorData() throws IOException {\n+        CommandMessage m = new CommandMessage(Command.REQUEST_DATA, new byte[] {});\n+        byte[] data = m.getBytes();\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Requesting sensor data, will send: {}\", Helper.toHexString(data));\n+        }\n+        outputStream.write(data, 0, data.length);\n+    }\n+\n+    private @Nullable SensorReply readReply() throws IOException {\n+        byte[] readBuffer = new byte[Constants.REPLY_LENGTH];\n+\n+        int b = -1;\n+        if (inputStream.available() > 0) {\n+            while ((b = inputStream.read()) != Constants.MESSAGE_START_AS_INT) {\n+                logger.debug(\"Trying to find first reply byte now...\");\n+            }\n+            readBuffer[0] = (byte) b;\n+            int remainingBytesRead = inputStream.read(readBuffer, 1, Constants.REPLY_LENGTH - 1);\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"Read remaining bytes: {}, full reply={}\", remainingBytesRead,\n+                        Helper.toHexString(readBuffer));\n+            }\n+            return ReplyFactory.create(readBuffer);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Data from the device is arriving and will be parsed accordingly\n+     */\n+    @Override\n+    public void serialEvent(SerialPortEvent event) {\n+        if (event.getEventType() == SerialPortEvent.DATA_AVAILABLE) {\n+            // we get here if data has been received\n+            SensorReply reply = null;\n+            try {\n+                reply = readReply();\n+                logger.debug(\"Got data from sensor: {}\", reply);\n+            } catch (IOException e) {\n+                logger.error(\"Could not read available data from the serial port\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17ab9e48eb7ee697b10405fcdabcba5a6d99288a"}, "originalPosition": 256}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQzMDk2OA==", "bodyText": "Since we are going to remove the Apache Commons dependencies, could you replace the lines with standard Java code? See #7722", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r429430968", "createdAt": "2020-05-22T20:00:10Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/SDS011Communicator.java", "diffHunk": "@@ -0,0 +1,287 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal.sds011protocol;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.TooManyListenersException;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.SDS011Handler;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.CommandMessage;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.Constants;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.ModeReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorFirmwareReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SleepReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.WorkingPeriodReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Central instance to communicate with the device, i.e. receive data from it and send commands to it\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class SDS011Communicator implements SerialPortEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Communicator.class);\n+\n+    private SerialPortIdentifier portId;\n+    private SDS011Handler thingHandler;\n+    private @NonNullByDefault({}) SerialPort serialPort;\n+\n+    private @NonNullByDefault({}) OutputStream outputStream;\n+    private @NonNullByDefault({}) InputStream inputStream;\n+\n+    public SDS011Communicator(SDS011Handler thingHandler, SerialPortIdentifier portId) {\n+        this.thingHandler = thingHandler;\n+        this.portId = portId;\n+    }\n+\n+    /**\n+     * Initialize the communication with the device, i.e. open the serial port etc.\n+     *\n+     * @param mode the {@link WorkMode} if we want to use polling or reporting\n+     * @param interval the time between polling or reportings\n+     * @return {@code true} if we can communicate with the device\n+     * @throws PortInUseException\n+     * @throws TooManyListenersException\n+     * @throws IOException\n+     * @throws UnsupportedCommOperationException\n+     */\n+    public boolean initialize(WorkMode mode, Duration interval)\n+            throws PortInUseException, TooManyListenersException, IOException, UnsupportedCommOperationException {\n+        boolean initSuccessful = true;\n+\n+        SerialPort localSerialPort = portId.open(thingHandler.getThing().getUID().toString(), 2000);\n+        localSerialPort.setSerialPortParams(9600, 8, 1, 0);\n+\n+        outputStream = localSerialPort.getOutputStream();\n+        inputStream = localSerialPort.getInputStream();\n+\n+        if (inputStream == null || outputStream == null) {\n+            throw new IOException(\"Could not create input or outputstream for the port\");\n+        }\n+\n+        // wake up the device\n+        initSuccessful &= sendSleep(false);\n+        initSuccessful &= getFirmware();\n+\n+        if (mode == WorkMode.POLLING) {\n+            initSuccessful &= setMode(WorkMode.POLLING);\n+            initSuccessful &= setWorkingPeriod((byte) 0);\n+        } else {\n+            // reporting\n+            initSuccessful &= setWorkingPeriod((byte) interval.toMinutes());\n+            initSuccessful &= setMode(WorkMode.REPORTING);\n+        }\n+\n+        // enable listeners only after we have configured the sensor above because for configuring we send and read data\n+        // sequentially\n+        localSerialPort.notifyOnDataAvailable(true);\n+        localSerialPort.addEventListener(this);\n+        this.serialPort = localSerialPort;\n+\n+        return initSuccessful;\n+    }\n+\n+    private @Nullable SensorReply sendCommand(CommandMessage message) throws IOException {\n+        byte[] commandData = message.getBytes();\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Will send command: {} ({})\", Helper.toHexString(commandData), Arrays.toString(commandData));\n+        }\n+        outputStream.write(commandData, 0, commandData.length);\n+        outputStream.flush();\n+        try {\n+            // Give the sensor some time to handle the command\n+            Thread.sleep(500);\n+        } catch (InterruptedException e) {\n+            logger.warn(\"Problem while waiting for reading a reply to our command.\");\n+            Thread.currentThread().interrupt();\n+        }\n+        SensorReply reply = readReply();\n+        // in case there is still another reporting active, we want to discard the sensor data and read the reply to our\n+        // command again\n+        if (reply instanceof SensorMeasuredDataReply) {\n+            reply = readReply();\n+        }\n+        return reply;\n+    }\n+\n+    private boolean setWorkingPeriod(byte period) throws IOException {\n+        CommandMessage m = new CommandMessage(Command.WORKING_PERIOD, new byte[] { Constants.SET_ACTION, period });\n+        logger.debug(\"Sending work period: {}\", period);\n+        SensorReply reply = sendCommand(m);\n+        logger.debug(\"Got reply to setWorkingPeriod command: {}\", reply);\n+        if (reply instanceof WorkingPeriodReply) {\n+            WorkingPeriodReply wpReply = (WorkingPeriodReply) reply;\n+            if (wpReply.getPeriod() == period && wpReply.getActionType() == Constants.SET_ACTION) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean setMode(WorkMode workMode) throws IOException {\n+        byte haveToRequestData = 0;\n+        if (workMode == WorkMode.POLLING) {\n+            haveToRequestData = 1;\n+        }\n+\n+        CommandMessage m = new CommandMessage(Command.MODE, new byte[] { Constants.SET_ACTION, haveToRequestData });\n+        logger.debug(\"Sending mode: {}\", workMode);\n+        SensorReply reply = sendCommand(m);\n+        logger.debug(\"Got reply to setMode command: {}\", reply);\n+        if (reply instanceof ModeReply) {\n+            ModeReply mr = (ModeReply) reply;\n+            if (mr.getActionType() == Constants.SET_ACTION && mr.getMode() == workMode) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean sendSleep(boolean doSleep) throws IOException {\n+        byte payload = (byte) 1;\n+        if (doSleep) {\n+            payload = (byte) 0;\n+        }\n+\n+        CommandMessage m = new CommandMessage(Command.SLEEP, new byte[] { Constants.SET_ACTION, payload });\n+        logger.debug(\"Sending doSleep: {}\", doSleep);\n+        SensorReply reply = sendCommand(m);\n+        logger.debug(\"Got reply to sendSleep command: {}\", reply);\n+\n+        if (!doSleep) {\n+            // sometimes the sensor does not wakeup on the first attempt, thus we try again\n+            for (int i = 0; reply == null && i < 3; i++) {\n+                reply = sendCommand(m);\n+                logger.debug(\"Got reply to sendSleep command after retry#{}: {}\", i + 1, reply);\n+            }\n+        }\n+\n+        if (reply instanceof SleepReply) {\n+            SleepReply sr = (SleepReply) reply;\n+            if (sr.getActionType() == Constants.SET_ACTION && sr.getSleep() == payload) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean getFirmware() throws IOException {\n+        CommandMessage m = new CommandMessage(Command.FIRMWARE, new byte[] {});\n+        logger.debug(\"Sending get firmware request\");\n+        SensorReply reply = sendCommand(m);\n+        logger.debug(\"Got reply to getFirmware command: {}\", reply);\n+\n+        if (reply instanceof SensorFirmwareReply) {\n+            SensorFirmwareReply fwReply = (SensorFirmwareReply) reply;\n+            thingHandler.setFirmware(fwReply.getFirmware());\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Request data from the device, they will be returned via the serialEvent callback\n+     *\n+     * @throws IOException\n+     */\n+    public void requestSensorData() throws IOException {\n+        CommandMessage m = new CommandMessage(Command.REQUEST_DATA, new byte[] {});\n+        byte[] data = m.getBytes();\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Requesting sensor data, will send: {}\", Helper.toHexString(data));\n+        }\n+        outputStream.write(data, 0, data.length);\n+    }\n+\n+    private @Nullable SensorReply readReply() throws IOException {\n+        byte[] readBuffer = new byte[Constants.REPLY_LENGTH];\n+\n+        int b = -1;\n+        if (inputStream.available() > 0) {\n+            while ((b = inputStream.read()) != Constants.MESSAGE_START_AS_INT) {\n+                logger.debug(\"Trying to find first reply byte now...\");\n+            }\n+            readBuffer[0] = (byte) b;\n+            int remainingBytesRead = inputStream.read(readBuffer, 1, Constants.REPLY_LENGTH - 1);\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"Read remaining bytes: {}, full reply={}\", remainingBytesRead,\n+                        Helper.toHexString(readBuffer));\n+            }\n+            return ReplyFactory.create(readBuffer);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Data from the device is arriving and will be parsed accordingly\n+     */\n+    @Override\n+    public void serialEvent(SerialPortEvent event) {\n+        if (event.getEventType() == SerialPortEvent.DATA_AVAILABLE) {\n+            // we get here if data has been received\n+            SensorReply reply = null;\n+            try {\n+                reply = readReply();\n+                logger.debug(\"Got data from sensor: {}\", reply);\n+            } catch (IOException e) {\n+                logger.error(\"Could not read available data from the serial port\", e);\n+            }\n+            if (reply instanceof SensorMeasuredDataReply) {\n+                SensorMeasuredDataReply sensorData = (SensorMeasuredDataReply) reply;\n+                if (sensorData.isValidData()) {\n+                    thingHandler.updateChannels(sensorData);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Shutdown the communication, i.e. send the device to sleep and close the serial port\n+     */\n+    public void dispose() {\n+        if (serialPort != null) {\n+            try {\n+                // send the device to sleep to preserve power and extend the lifetime of the sensor\n+                sendSleep(true);\n+            } catch (IOException e) {\n+                // ignore because we are shutting down anyway\n+                logger.debug(\"Exception while disposing communicator (will ignore it)\", e);\n+            } finally {\n+                serialPort.removeEventListener();\n+                serialPort.close();\n+                serialPort = null;\n+            }\n+        }\n+        IOUtils.closeQuietly(inputStream);\n+        IOUtils.closeQuietly(outputStream);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "17ab9e48eb7ee697b10405fcdabcba5a6d99288a"}, "originalPosition": 285}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bf0810c7b031185b426267d586b8cee193dfeeff", "author": {"user": {"login": "t2000", "name": "Stefan Triller"}}, "url": "https://github.com/openhab/openhab-addons/commit/bf0810c7b031185b426267d586b8cee193dfeeff", "committedDate": "2020-05-23T12:47:52Z", "message": "Nova Fine Dust binding for SDS011 sensors\n\nCloses #7527\n\nSigned-off-by: Stefan Triller <github@stefantriller.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bde3d2b7dce707a863eafa496bd10e55b6dc7cd2", "author": {"user": {"login": "t2000", "name": "Stefan Triller"}}, "url": "https://github.com/openhab/openhab-addons/commit/bde3d2b7dce707a863eafa496bd10e55b6dc7cd2", "committedDate": "2020-05-23T13:01:50Z", "message": "Address review comments\n\nSigned-off-by: Stefan Triller <github@stefantriller.de>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "17ab9e48eb7ee697b10405fcdabcba5a6d99288a", "author": {"user": {"login": "t2000", "name": "Stefan Triller"}}, "url": "https://github.com/openhab/openhab-addons/commit/17ab9e48eb7ee697b10405fcdabcba5a6d99288a", "committedDate": "2020-05-02T15:42:20Z", "message": "Nova Fine Dust binding for SDS011 sensors\n\nCloses #7527\n\nSigned-off-by: Stefan Triller <github@stefantriller.de>"}, "afterCommit": {"oid": "bde3d2b7dce707a863eafa496bd10e55b6dc7cd2", "author": {"user": {"login": "t2000", "name": "Stefan Triller"}}, "url": "https://github.com/openhab/openhab-addons/commit/bde3d2b7dce707a863eafa496bd10e55b6dc7cd2", "committedDate": "2020-05-23T13:01:50Z", "message": "Address review comments\n\nSigned-off-by: Stefan Triller <github@stefantriller.de>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE3Mjg1OTE0", "url": "https://github.com/openhab/openhab-addons/pull/7528#pullrequestreview-417285914", "createdAt": "2020-05-23T15:12:06Z", "commit": {"oid": "bde3d2b7dce707a863eafa496bd10e55b6dc7cd2"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QxNToxMjowNlrOGZp5yw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QxNToxMjowNlrOGZp5yw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU1NDEyMw==", "bodyText": "No need to log the stacktrace here, but you could log the exception message:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            logger.warn(\"Could not read available data from the serial port\", e);\n          \n          \n            \n                            logger.warn(\"Could not read available data from the serial port: {}\", e.getMessage());", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r429554123", "createdAt": "2020-05-23T15:12:06Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/SDS011Communicator.java", "diffHunk": "@@ -253,7 +252,7 @@ public void serialEvent(SerialPortEvent event) {\n                 reply = readReply();\n                 logger.debug(\"Got data from sensor: {}\", reply);\n             } catch (IOException e) {\n-                logger.error(\"Could not read available data from the serial port\", e);\n+                logger.warn(\"Could not read available data from the serial port\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bde3d2b7dce707a863eafa496bd10e55b6dc7cd2"}, "originalPosition": 13}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0d2971b437b5c6dffb681d35908a946d857530be", "author": {"user": {"login": "t2000", "name": "Stefan Triller"}}, "url": "https://github.com/openhab/openhab-addons/commit/0d2971b437b5c6dffb681d35908a946d857530be", "committedDate": "2020-05-23T16:51:08Z", "message": "Address further review comments\n\nSigned-off-by: Stefan Triller <github@stefantriller.de>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE3MzA0Mjky", "url": "https://github.com/openhab/openhab-addons/pull/7528#pullrequestreview-417304292", "createdAt": "2020-05-23T19:50:24Z", "commit": {"oid": "0d2971b437b5c6dffb681d35908a946d857530be"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QxOTo1MDoyNFrOGZrFLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QyMzoxMjoyN1rOGZrywQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU3MzQyMg==", "bodyText": "There is an implementation of this in HexUtils from openhab core.", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r429573422", "createdAt": "2020-05-23T19:50:24Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/Helper.java", "diffHunk": "@@ -0,0 +1,42 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal.sds011protocol;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * Class with useful utility functions\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class Helper {\n+\n+    private Helper() {\n+    }\n+\n+    /**\n+     * Converts a byte array to a hexadecimal string, handy for printing\n+     *\n+     * @param bytes the byte array to be converted\n+     * @return a String describing the byte array in hexadecimal values\n+     */\n+    public static String toHexString(byte[] bytes) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d2971b437b5c6dffb681d35908a946d857530be"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU3NTA0OQ==", "bodyText": "Perhaps you could cache the values so that a Refresh command would be able to get the most recently reported ones.", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r429575049", "createdAt": "2020-05-23T20:15:56Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/SDS011Handler.java", "diffHunk": "@@ -0,0 +1,228 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.ZonedDateTime;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.dimension.Density;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.SDS011Communicator;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.WorkMode;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SDS011Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SDS011Handler extends BaseThingHandler {\n+    private static final Duration CONNECTION_MONITOR_START_DELAY_OFFSET = Duration.ofSeconds(10);\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Handler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    private @NonNullByDefault({}) NovaFineDustConfiguration config;\n+    private @NonNullByDefault({}) SDS011Communicator communicator;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable ScheduledFuture<?> connectionMonitor;\n+\n+    private ZonedDateTime lastCommunication = ZonedDateTime.now();\n+\n+    // initialize timeBetweenDataShouldArrive with a large number\n+    private Duration timeBetweenDataShouldArrive = Duration.ofDays(1);\n+    private final Duration dataCanBeLateTolerance = Duration.ofSeconds(5);\n+\n+    public SDS011Handler(Thing thing, SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // we do not support refreshing as values are either reported by the device or polled from the device in fixed\n+        // intervals", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d2971b437b5c6dffb681d35908a946d857530be"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU3NTE2MA==", "bodyText": "why is this disposed asynchronously?", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r429575160", "createdAt": "2020-05-23T20:17:34Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/SDS011Handler.java", "diffHunk": "@@ -0,0 +1,228 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.ZonedDateTime;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.dimension.Density;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.SDS011Communicator;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.WorkMode;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SDS011Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SDS011Handler extends BaseThingHandler {\n+    private static final Duration CONNECTION_MONITOR_START_DELAY_OFFSET = Duration.ofSeconds(10);\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Handler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    private @NonNullByDefault({}) NovaFineDustConfiguration config;\n+    private @NonNullByDefault({}) SDS011Communicator communicator;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable ScheduledFuture<?> connectionMonitor;\n+\n+    private ZonedDateTime lastCommunication = ZonedDateTime.now();\n+\n+    // initialize timeBetweenDataShouldArrive with a large number\n+    private Duration timeBetweenDataShouldArrive = Duration.ofDays(1);\n+    private final Duration dataCanBeLateTolerance = Duration.ofSeconds(5);\n+\n+    public SDS011Handler(Thing thing, SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // we do not support refreshing as values are either reported by the device or polled from the device in fixed\n+        // intervals\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        config = getConfigAs(NovaFineDustConfiguration.class);\n+\n+        if (!validateConfiguration()) {\n+            return;\n+        }\n+\n+        // parse ports and if the port is found, initialize the reader\n+        SerialPortIdentifier portId = serialPortManager.getIdentifier(config.port);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port is not known!\");\n+            return;\n+        }\n+\n+        this.communicator = new SDS011Communicator(this, portId);\n+\n+        if (config.reporting) {\n+            timeBetweenDataShouldArrive = Duration.ofMinutes(config.reportingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.REPORTING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        } else {\n+            timeBetweenDataShouldArrive = Duration.ofSeconds(config.pollingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.POLLING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        }\n+\n+        Duration connectionMonitorStartDelay = timeBetweenDataShouldArrive.plus(CONNECTION_MONITOR_START_DELAY_OFFSET);\n+        connectionMonitor = scheduler.scheduleWithFixedDelay(this::verifyIfStillConnected,\n+                connectionMonitorStartDelay.getSeconds(), timeBetweenDataShouldArrive.getSeconds(), TimeUnit.SECONDS);\n+    }\n+\n+    private void initializeCommunicator(WorkMode mode, Duration interval) {\n+        boolean initSuccessful = false;\n+        try {\n+            initSuccessful = communicator.initialize(mode, interval);\n+        } catch (final IOException ex) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"I/O error!\");\n+            return;\n+        } catch (PortInUseException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"Port is in use!\");\n+            return;\n+        } catch (TooManyListenersException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Cannot attach listener to port!\");\n+            return;\n+        } catch (UnsupportedCommOperationException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Cannot set serial port parameters\");\n+            return;\n+        }\n+\n+        if (initSuccessful) {\n+            lastCommunication = ZonedDateTime.now();\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            if (mode == WorkMode.POLLING) {\n+                pollingJob = scheduler.scheduleWithFixedDelay(() -> {\n+                    try {\n+                        communicator.requestSensorData();\n+                    } catch (IOException e) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                                \"Cannot query data from device\");\n+                    }\n+                }, 2, config.pollingInterval, TimeUnit.SECONDS);\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Commands and replies from the device don't seem to match\");\n+            logger.debug(\"Could not configure sensor -> setting Thing to OFFLINE and disposing the handler\");\n+            dispose();\n+        }\n+    }\n+\n+    private boolean validateConfiguration() {\n+        if (config.port == null || config.port.isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port must be set!\");\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (pollingJob != null && !pollingJob.isCancelled()) {\n+            pollingJob.cancel(true);\n+            pollingJob = null;\n+        }\n+\n+        if (connectionMonitor != null && !connectionMonitor.isCancelled()) {\n+            connectionMonitor.cancel(true);\n+            connectionMonitor = null;\n+        }\n+\n+        if (communicator != null) {\n+            scheduler.schedule(() -> communicator.dispose(), 0, TimeUnit.SECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d2971b437b5c6dffb681d35908a946d857530be"}, "originalPosition": 176}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU4Mzk2Mg==", "bodyText": "I suggest populating this through the NovaFineDustHandlerFactory constructor.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private @NonNullByDefault({}) SerialPortManager serialPortManager;\n          \n          \n            \n                private final SerialPortManager serialPortManager;\n          \n          \n            \n                \n          \n          \n            \n                @Activate\n          \n          \n            \n                public NovaFineDustHandlerFactory(@Reference SerialPortManager serialPortManager){\n          \n          \n            \n                    this.serialPortManager = serialPortManager;\n          \n          \n            \n                }\n          \n      \n    \n    \n  \n\nThen you can remove the setSerialPortManager and unsetSerialPortManager methods.", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r429583962", "createdAt": "2020-05-23T22:47:18Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/NovaFineDustHandlerFactory.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal;\n+\n+import static org.openhab.binding.novafinedust.internal.NovaFineDustBindingConstants.THING_TYPE_SDS011;\n+\n+import java.util.Collections;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link NovaFineDustHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(configurationPid = \"binding.novafinedust\", service = ThingHandlerFactory.class)\n+public class NovaFineDustHandlerFactory extends BaseThingHandlerFactory {\n+\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections.singleton(THING_TYPE_SDS011);\n+\n+    private @NonNullByDefault({}) SerialPortManager serialPortManager;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d2971b437b5c6dffb681d35908a946d857530be"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU4NDA0NA==", "bodyText": "No harm in cancelling something that is already cancelled.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (pollingJob != null && !pollingJob.isCancelled()) {\n          \n          \n            \n                    if (pollingJob != null) {", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r429584044", "createdAt": "2020-05-23T22:48:55Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/SDS011Handler.java", "diffHunk": "@@ -0,0 +1,228 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.ZonedDateTime;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.dimension.Density;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.SDS011Communicator;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.WorkMode;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SDS011Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SDS011Handler extends BaseThingHandler {\n+    private static final Duration CONNECTION_MONITOR_START_DELAY_OFFSET = Duration.ofSeconds(10);\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Handler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    private @NonNullByDefault({}) NovaFineDustConfiguration config;\n+    private @NonNullByDefault({}) SDS011Communicator communicator;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable ScheduledFuture<?> connectionMonitor;\n+\n+    private ZonedDateTime lastCommunication = ZonedDateTime.now();\n+\n+    // initialize timeBetweenDataShouldArrive with a large number\n+    private Duration timeBetweenDataShouldArrive = Duration.ofDays(1);\n+    private final Duration dataCanBeLateTolerance = Duration.ofSeconds(5);\n+\n+    public SDS011Handler(Thing thing, SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // we do not support refreshing as values are either reported by the device or polled from the device in fixed\n+        // intervals\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        config = getConfigAs(NovaFineDustConfiguration.class);\n+\n+        if (!validateConfiguration()) {\n+            return;\n+        }\n+\n+        // parse ports and if the port is found, initialize the reader\n+        SerialPortIdentifier portId = serialPortManager.getIdentifier(config.port);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port is not known!\");\n+            return;\n+        }\n+\n+        this.communicator = new SDS011Communicator(this, portId);\n+\n+        if (config.reporting) {\n+            timeBetweenDataShouldArrive = Duration.ofMinutes(config.reportingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.REPORTING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        } else {\n+            timeBetweenDataShouldArrive = Duration.ofSeconds(config.pollingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.POLLING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        }\n+\n+        Duration connectionMonitorStartDelay = timeBetweenDataShouldArrive.plus(CONNECTION_MONITOR_START_DELAY_OFFSET);\n+        connectionMonitor = scheduler.scheduleWithFixedDelay(this::verifyIfStillConnected,\n+                connectionMonitorStartDelay.getSeconds(), timeBetweenDataShouldArrive.getSeconds(), TimeUnit.SECONDS);\n+    }\n+\n+    private void initializeCommunicator(WorkMode mode, Duration interval) {\n+        boolean initSuccessful = false;\n+        try {\n+            initSuccessful = communicator.initialize(mode, interval);\n+        } catch (final IOException ex) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"I/O error!\");\n+            return;\n+        } catch (PortInUseException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"Port is in use!\");\n+            return;\n+        } catch (TooManyListenersException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Cannot attach listener to port!\");\n+            return;\n+        } catch (UnsupportedCommOperationException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Cannot set serial port parameters\");\n+            return;\n+        }\n+\n+        if (initSuccessful) {\n+            lastCommunication = ZonedDateTime.now();\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            if (mode == WorkMode.POLLING) {\n+                pollingJob = scheduler.scheduleWithFixedDelay(() -> {\n+                    try {\n+                        communicator.requestSensorData();\n+                    } catch (IOException e) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                                \"Cannot query data from device\");\n+                    }\n+                }, 2, config.pollingInterval, TimeUnit.SECONDS);\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Commands and replies from the device don't seem to match\");\n+            logger.debug(\"Could not configure sensor -> setting Thing to OFFLINE and disposing the handler\");\n+            dispose();\n+        }\n+    }\n+\n+    private boolean validateConfiguration() {\n+        if (config.port == null || config.port.isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port must be set!\");\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (pollingJob != null && !pollingJob.isCancelled()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d2971b437b5c6dffb681d35908a946d857530be"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU4NDA1Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (connectionMonitor != null && !connectionMonitor.isCancelled()) {\n          \n          \n            \n                    if (connectionMonitor != null) {", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r429584056", "createdAt": "2020-05-23T22:49:15Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/SDS011Handler.java", "diffHunk": "@@ -0,0 +1,228 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.ZonedDateTime;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.dimension.Density;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.SDS011Communicator;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.WorkMode;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SDS011Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SDS011Handler extends BaseThingHandler {\n+    private static final Duration CONNECTION_MONITOR_START_DELAY_OFFSET = Duration.ofSeconds(10);\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Handler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    private @NonNullByDefault({}) NovaFineDustConfiguration config;\n+    private @NonNullByDefault({}) SDS011Communicator communicator;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable ScheduledFuture<?> connectionMonitor;\n+\n+    private ZonedDateTime lastCommunication = ZonedDateTime.now();\n+\n+    // initialize timeBetweenDataShouldArrive with a large number\n+    private Duration timeBetweenDataShouldArrive = Duration.ofDays(1);\n+    private final Duration dataCanBeLateTolerance = Duration.ofSeconds(5);\n+\n+    public SDS011Handler(Thing thing, SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // we do not support refreshing as values are either reported by the device or polled from the device in fixed\n+        // intervals\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        config = getConfigAs(NovaFineDustConfiguration.class);\n+\n+        if (!validateConfiguration()) {\n+            return;\n+        }\n+\n+        // parse ports and if the port is found, initialize the reader\n+        SerialPortIdentifier portId = serialPortManager.getIdentifier(config.port);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port is not known!\");\n+            return;\n+        }\n+\n+        this.communicator = new SDS011Communicator(this, portId);\n+\n+        if (config.reporting) {\n+            timeBetweenDataShouldArrive = Duration.ofMinutes(config.reportingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.REPORTING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        } else {\n+            timeBetweenDataShouldArrive = Duration.ofSeconds(config.pollingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.POLLING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        }\n+\n+        Duration connectionMonitorStartDelay = timeBetweenDataShouldArrive.plus(CONNECTION_MONITOR_START_DELAY_OFFSET);\n+        connectionMonitor = scheduler.scheduleWithFixedDelay(this::verifyIfStillConnected,\n+                connectionMonitorStartDelay.getSeconds(), timeBetweenDataShouldArrive.getSeconds(), TimeUnit.SECONDS);\n+    }\n+\n+    private void initializeCommunicator(WorkMode mode, Duration interval) {\n+        boolean initSuccessful = false;\n+        try {\n+            initSuccessful = communicator.initialize(mode, interval);\n+        } catch (final IOException ex) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"I/O error!\");\n+            return;\n+        } catch (PortInUseException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"Port is in use!\");\n+            return;\n+        } catch (TooManyListenersException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Cannot attach listener to port!\");\n+            return;\n+        } catch (UnsupportedCommOperationException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Cannot set serial port parameters\");\n+            return;\n+        }\n+\n+        if (initSuccessful) {\n+            lastCommunication = ZonedDateTime.now();\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            if (mode == WorkMode.POLLING) {\n+                pollingJob = scheduler.scheduleWithFixedDelay(() -> {\n+                    try {\n+                        communicator.requestSensorData();\n+                    } catch (IOException e) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                                \"Cannot query data from device\");\n+                    }\n+                }, 2, config.pollingInterval, TimeUnit.SECONDS);\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Commands and replies from the device don't seem to match\");\n+            logger.debug(\"Could not configure sensor -> setting Thing to OFFLINE and disposing the handler\");\n+            dispose();\n+        }\n+    }\n+\n+    private boolean validateConfiguration() {\n+        if (config.port == null || config.port.isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port must be set!\");\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (pollingJob != null && !pollingJob.isCancelled()) {\n+            pollingJob.cancel(true);\n+            pollingJob = null;\n+        }\n+\n+        if (connectionMonitor != null && !connectionMonitor.isCancelled()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d2971b437b5c6dffb681d35908a946d857530be"}, "originalPosition": 170}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU4NDE4Nw==", "bodyText": "Please make these nullable.", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r429584187", "createdAt": "2020-05-23T22:51:24Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/SDS011Communicator.java", "diffHunk": "@@ -0,0 +1,296 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal.sds011protocol;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.TooManyListenersException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.SDS011Handler;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.CommandMessage;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.Constants;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.ModeReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorFirmwareReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SleepReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.WorkingPeriodReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Central instance to communicate with the device, i.e. receive data from it and send commands to it\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class SDS011Communicator implements SerialPortEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Communicator.class);\n+\n+    private SerialPortIdentifier portId;\n+    private SDS011Handler thingHandler;\n+    private @NonNullByDefault({}) SerialPort serialPort;\n+\n+    private @NonNullByDefault({}) OutputStream outputStream;\n+    private @NonNullByDefault({}) InputStream inputStream;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d2971b437b5c6dffb681d35908a946d857530be"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU4NDMyOQ==", "bodyText": "Why is this necessary? inputStream.read() will block until data becomes available anyway.", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r429584329", "createdAt": "2020-05-23T22:54:46Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/SDS011Communicator.java", "diffHunk": "@@ -0,0 +1,296 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal.sds011protocol;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.TooManyListenersException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.SDS011Handler;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.CommandMessage;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.Constants;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.ModeReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorFirmwareReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SleepReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.WorkingPeriodReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Central instance to communicate with the device, i.e. receive data from it and send commands to it\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class SDS011Communicator implements SerialPortEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Communicator.class);\n+\n+    private SerialPortIdentifier portId;\n+    private SDS011Handler thingHandler;\n+    private @NonNullByDefault({}) SerialPort serialPort;\n+\n+    private @NonNullByDefault({}) OutputStream outputStream;\n+    private @NonNullByDefault({}) InputStream inputStream;\n+\n+    public SDS011Communicator(SDS011Handler thingHandler, SerialPortIdentifier portId) {\n+        this.thingHandler = thingHandler;\n+        this.portId = portId;\n+    }\n+\n+    /**\n+     * Initialize the communication with the device, i.e. open the serial port etc.\n+     *\n+     * @param mode the {@link WorkMode} if we want to use polling or reporting\n+     * @param interval the time between polling or reportings\n+     * @return {@code true} if we can communicate with the device\n+     * @throws PortInUseException\n+     * @throws TooManyListenersException\n+     * @throws IOException\n+     * @throws UnsupportedCommOperationException\n+     */\n+    public boolean initialize(WorkMode mode, Duration interval)\n+            throws PortInUseException, TooManyListenersException, IOException, UnsupportedCommOperationException {\n+        boolean initSuccessful = true;\n+\n+        SerialPort localSerialPort = portId.open(thingHandler.getThing().getUID().toString(), 2000);\n+        localSerialPort.setSerialPortParams(9600, 8, 1, 0);\n+\n+        outputStream = localSerialPort.getOutputStream();\n+        inputStream = localSerialPort.getInputStream();\n+\n+        if (inputStream == null || outputStream == null) {\n+            throw new IOException(\"Could not create input or outputstream for the port\");\n+        }\n+\n+        // wake up the device\n+        initSuccessful &= sendSleep(false);\n+        initSuccessful &= getFirmware();\n+\n+        if (mode == WorkMode.POLLING) {\n+            initSuccessful &= setMode(WorkMode.POLLING);\n+            initSuccessful &= setWorkingPeriod((byte) 0);\n+        } else {\n+            // reporting\n+            initSuccessful &= setWorkingPeriod((byte) interval.toMinutes());\n+            initSuccessful &= setMode(WorkMode.REPORTING);\n+        }\n+\n+        // enable listeners only after we have configured the sensor above because for configuring we send and read data\n+        // sequentially\n+        localSerialPort.notifyOnDataAvailable(true);\n+        localSerialPort.addEventListener(this);\n+        this.serialPort = localSerialPort;\n+\n+        return initSuccessful;\n+    }\n+\n+    private @Nullable SensorReply sendCommand(CommandMessage message) throws IOException {\n+        byte[] commandData = message.getBytes();\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Will send command: {} ({})\", Helper.toHexString(commandData), Arrays.toString(commandData));\n+        }\n+        outputStream.write(commandData, 0, commandData.length);\n+        outputStream.flush();\n+        try {\n+            // Give the sensor some time to handle the command\n+            Thread.sleep(500);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d2971b437b5c6dffb681d35908a946d857530be"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU4NDgwNQ==", "bodyText": "Wouldn't this already be called implicitly through serialEvent? Wouldn't the data on the input stream be gone at that point? Could you explain how this works? I might be misunderstanding how the serial protocol works.", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r429584805", "createdAt": "2020-05-23T23:05:44Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/SDS011Communicator.java", "diffHunk": "@@ -0,0 +1,296 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal.sds011protocol;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.TooManyListenersException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.SDS011Handler;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.CommandMessage;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.Constants;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.ModeReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorFirmwareReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SleepReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.WorkingPeriodReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Central instance to communicate with the device, i.e. receive data from it and send commands to it\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class SDS011Communicator implements SerialPortEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Communicator.class);\n+\n+    private SerialPortIdentifier portId;\n+    private SDS011Handler thingHandler;\n+    private @NonNullByDefault({}) SerialPort serialPort;\n+\n+    private @NonNullByDefault({}) OutputStream outputStream;\n+    private @NonNullByDefault({}) InputStream inputStream;\n+\n+    public SDS011Communicator(SDS011Handler thingHandler, SerialPortIdentifier portId) {\n+        this.thingHandler = thingHandler;\n+        this.portId = portId;\n+    }\n+\n+    /**\n+     * Initialize the communication with the device, i.e. open the serial port etc.\n+     *\n+     * @param mode the {@link WorkMode} if we want to use polling or reporting\n+     * @param interval the time between polling or reportings\n+     * @return {@code true} if we can communicate with the device\n+     * @throws PortInUseException\n+     * @throws TooManyListenersException\n+     * @throws IOException\n+     * @throws UnsupportedCommOperationException\n+     */\n+    public boolean initialize(WorkMode mode, Duration interval)\n+            throws PortInUseException, TooManyListenersException, IOException, UnsupportedCommOperationException {\n+        boolean initSuccessful = true;\n+\n+        SerialPort localSerialPort = portId.open(thingHandler.getThing().getUID().toString(), 2000);\n+        localSerialPort.setSerialPortParams(9600, 8, 1, 0);\n+\n+        outputStream = localSerialPort.getOutputStream();\n+        inputStream = localSerialPort.getInputStream();\n+\n+        if (inputStream == null || outputStream == null) {\n+            throw new IOException(\"Could not create input or outputstream for the port\");\n+        }\n+\n+        // wake up the device\n+        initSuccessful &= sendSleep(false);\n+        initSuccessful &= getFirmware();\n+\n+        if (mode == WorkMode.POLLING) {\n+            initSuccessful &= setMode(WorkMode.POLLING);\n+            initSuccessful &= setWorkingPeriod((byte) 0);\n+        } else {\n+            // reporting\n+            initSuccessful &= setWorkingPeriod((byte) interval.toMinutes());\n+            initSuccessful &= setMode(WorkMode.REPORTING);\n+        }\n+\n+        // enable listeners only after we have configured the sensor above because for configuring we send and read data\n+        // sequentially\n+        localSerialPort.notifyOnDataAvailable(true);\n+        localSerialPort.addEventListener(this);\n+        this.serialPort = localSerialPort;\n+\n+        return initSuccessful;\n+    }\n+\n+    private @Nullable SensorReply sendCommand(CommandMessage message) throws IOException {\n+        byte[] commandData = message.getBytes();\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Will send command: {} ({})\", Helper.toHexString(commandData), Arrays.toString(commandData));\n+        }\n+        outputStream.write(commandData, 0, commandData.length);\n+        outputStream.flush();\n+        try {\n+            // Give the sensor some time to handle the command\n+            Thread.sleep(500);\n+        } catch (InterruptedException e) {\n+            logger.warn(\"Problem while waiting for reading a reply to our command.\");\n+            Thread.currentThread().interrupt();\n+        }\n+        SensorReply reply = readReply();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d2971b437b5c6dffb681d35908a946d857530be"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU4NDk5NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t<parameter name=\"reportingInterval\" type=\"integer\" min=\"0\" max=\"30\">\n          \n          \n            \n            \t\t\t<parameter name=\"reportingInterval\" type=\"integer\" min=\"0\" max=\"30\" unit=\"min\">", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r429584994", "createdAt": "2020-05-23T23:10:07Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,57 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"novafinedust\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"SDS011\">\n+\t\t<label>Nova SDS011 Fine Dust Sensor</label>\n+\t\t<description>Nova SDS011 Fine Dust Sensor connected via USB</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"pm10\" typeId=\"pm10-type\" />\n+\t\t\t<channel id=\"pm25\" typeId=\"pm25-type\" />\n+\t\t</channels>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"port\" type=\"text\" required=\"true\">\n+\t\t\t\t<context>serial-port</context>\n+\t\t\t\t<label>USB Port</label>\n+\t\t\t\t<description>USB port the device is connected to i.e. /dev/ttyUSB0</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"reporting\" type=\"boolean\">\n+\t\t\t\t<default>true</default>\n+\t\t\t\t<label>Reporting if true, otherwise polling</label>\n+\t\t\t\t<description>Reporting is strongly recommended to increase sensor lifetime</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"reportingInterval\" type=\"integer\" min=\"0\" max=\"30\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d2971b437b5c6dffb681d35908a946d857530be"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU4NTAwNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t<parameter name=\"pollingInterval\" type=\"integer\" min=\"3\" max=\"3600\">\n          \n          \n            \n            \t\t\t<parameter name=\"pollingInterval\" type=\"integer\" min=\"3\" max=\"3600\" unit=\"s\">", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r429585007", "createdAt": "2020-05-23T23:10:24Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,57 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"novafinedust\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"SDS011\">\n+\t\t<label>Nova SDS011 Fine Dust Sensor</label>\n+\t\t<description>Nova SDS011 Fine Dust Sensor connected via USB</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"pm10\" typeId=\"pm10-type\" />\n+\t\t\t<channel id=\"pm25\" typeId=\"pm25-type\" />\n+\t\t</channels>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"port\" type=\"text\" required=\"true\">\n+\t\t\t\t<context>serial-port</context>\n+\t\t\t\t<label>USB Port</label>\n+\t\t\t\t<description>USB port the device is connected to i.e. /dev/ttyUSB0</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"reporting\" type=\"boolean\">\n+\t\t\t\t<default>true</default>\n+\t\t\t\t<label>Reporting if true, otherwise polling</label>\n+\t\t\t\t<description>Reporting is strongly recommended to increase sensor lifetime</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"reportingInterval\" type=\"integer\" min=\"0\" max=\"30\">\n+\t\t\t\t<default>1</default>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t\t<label>Time in minutes when a value will be reported</label>\n+\t\t\t\t<description>Device will report every x minutes and sleep for x*60 - 30 seconds afterwards, 0 = as fast as possible without sleep</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"pollingInterval\" type=\"integer\" min=\"3\" max=\"3600\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d2971b437b5c6dffb681d35908a946d857530be"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU4NTA0OA==", "bodyText": "The first letter of every word in a label should be capitalized.", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r429585048", "createdAt": "2020-05-23T23:11:01Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,57 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"novafinedust\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"SDS011\">\n+\t\t<label>Nova SDS011 Fine Dust Sensor</label>\n+\t\t<description>Nova SDS011 Fine Dust Sensor connected via USB</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"pm10\" typeId=\"pm10-type\" />\n+\t\t\t<channel id=\"pm25\" typeId=\"pm25-type\" />\n+\t\t</channels>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"port\" type=\"text\" required=\"true\">\n+\t\t\t\t<context>serial-port</context>\n+\t\t\t\t<label>USB Port</label>\n+\t\t\t\t<description>USB port the device is connected to i.e. /dev/ttyUSB0</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"reporting\" type=\"boolean\">\n+\t\t\t\t<default>true</default>\n+\t\t\t\t<label>Reporting if true, otherwise polling</label>\n+\t\t\t\t<description>Reporting is strongly recommended to increase sensor lifetime</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"reportingInterval\" type=\"integer\" min=\"0\" max=\"30\">\n+\t\t\t\t<default>1</default>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t\t<label>Time in minutes when a value will be reported</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d2971b437b5c6dffb681d35908a946d857530be"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU4NTA1Mw==", "bodyText": "The first letter of every word in a label should be capitalized.", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r429585053", "createdAt": "2020-05-23T23:11:12Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,57 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"novafinedust\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"SDS011\">\n+\t\t<label>Nova SDS011 Fine Dust Sensor</label>\n+\t\t<description>Nova SDS011 Fine Dust Sensor connected via USB</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"pm10\" typeId=\"pm10-type\" />\n+\t\t\t<channel id=\"pm25\" typeId=\"pm25-type\" />\n+\t\t</channels>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"port\" type=\"text\" required=\"true\">\n+\t\t\t\t<context>serial-port</context>\n+\t\t\t\t<label>USB Port</label>\n+\t\t\t\t<description>USB port the device is connected to i.e. /dev/ttyUSB0</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"reporting\" type=\"boolean\">\n+\t\t\t\t<default>true</default>\n+\t\t\t\t<label>Reporting if true, otherwise polling</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d2971b437b5c6dffb681d35908a946d857530be"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU4NTA2MQ==", "bodyText": "The first letter of every word in a label should be capitalized.", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r429585061", "createdAt": "2020-05-23T23:11:29Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,57 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"novafinedust\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"SDS011\">\n+\t\t<label>Nova SDS011 Fine Dust Sensor</label>\n+\t\t<description>Nova SDS011 Fine Dust Sensor connected via USB</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"pm10\" typeId=\"pm10-type\" />\n+\t\t\t<channel id=\"pm25\" typeId=\"pm25-type\" />\n+\t\t</channels>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"port\" type=\"text\" required=\"true\">\n+\t\t\t\t<context>serial-port</context>\n+\t\t\t\t<label>USB Port</label>\n+\t\t\t\t<description>USB port the device is connected to i.e. /dev/ttyUSB0</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"reporting\" type=\"boolean\">\n+\t\t\t\t<default>true</default>\n+\t\t\t\t<label>Reporting if true, otherwise polling</label>\n+\t\t\t\t<description>Reporting is strongly recommended to increase sensor lifetime</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"reportingInterval\" type=\"integer\" min=\"0\" max=\"30\">\n+\t\t\t\t<default>1</default>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t\t<label>Time in minutes when a value will be reported</label>\n+\t\t\t\t<description>Device will report every x minutes and sleep for x*60 - 30 seconds afterwards, 0 = as fast as possible without sleep</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"pollingInterval\" type=\"integer\" min=\"3\" max=\"3600\">\n+\t\t\t\t<default>10</default>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t\t<label>Time in seconds when a value will be polled from the device (min 3 seconds)</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d2971b437b5c6dffb681d35908a946d857530be"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU4NTA4OQ==", "bodyText": "Please add @NonNullByDefault", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r429585089", "createdAt": "2020-05-23T23:12:27Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/WorkMode.java", "diffHunk": "@@ -0,0 +1,24 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal.sds011protocol;\n+\n+/**\n+ * Enum for the different sensor modes\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ *\n+ */\n+public enum WorkMode {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d2971b437b5c6dffb681d35908a946d857530be"}, "originalPosition": 21}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "127335070aeacdb456c41b6c1ddc1c3ba4a27b6e", "author": {"user": {"login": "t2000", "name": "Stefan Triller"}}, "url": "https://github.com/openhab/openhab-addons/commit/127335070aeacdb456c41b6c1ddc1c3ba4a27b6e", "committedDate": "2020-05-25T16:05:38Z", "message": "Address review comments from second reviewer\n\nSigned-off-by: Stefan Triller <github@stefantriller.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "78275e3df58da1567b75c9b1b2b6ef36af1bc404", "author": {"user": {"login": "t2000", "name": "Stefan Triller"}}, "url": "https://github.com/openhab/openhab-addons/commit/78275e3df58da1567b75c9b1b2b6ef36af1bc404", "committedDate": "2020-05-25T16:26:13Z", "message": "Fix compilation error\n\nSigned-off-by: Stefan Triller <github@stefantriller.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3b594394ec2080ca6bb8de2fd3710720612a5d20", "author": {"user": {"login": "t2000", "name": "Stefan Triller"}}, "url": "https://github.com/openhab/openhab-addons/commit/3b594394ec2080ca6bb8de2fd3710720612a5d20", "committedDate": "2020-05-26T16:21:26Z", "message": "Revert config validation\n\nSigned-off-by: Stefan Triller <github@stefantriller.de>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE4NDYxMjU2", "url": "https://github.com/openhab/openhab-addons/pull/7528#pullrequestreview-418461256", "createdAt": "2020-05-26T16:15:53Z", "commit": {"oid": "78275e3df58da1567b75c9b1b2b6ef36af1bc404"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxNjoxNTo1M1rOGal8Hw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQxNjoyMjozN1rOGamOFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDUzNzc1OQ==", "bodyText": "Please make these final if possible", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r430537759", "createdAt": "2020-05-26T16:15:53Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/messages/SensorReply.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal.sds011protocol.messages;\n+\n+import java.util.Arrays;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.util.HexUtils;\n+\n+/**\n+ * Base class holding information sent by the sensor to us\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class SensorReply {\n+\n+    protected byte header;\n+    protected byte commandID;\n+    protected byte[] payLoad = new byte[4];\n+    protected byte[] deviceID = new byte[2];\n+    protected byte checksum;\n+    protected byte messageTail;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78275e3df58da1567b75c9b1b2b6ef36af1bc404"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDUzOTM2Ng==", "bodyText": "Please make these final if possible", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r430539366", "createdAt": "2020-05-26T16:18:15Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/messages/SensorMeasuredDataReply.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal.sds011protocol.messages;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.util.HexUtils;\n+\n+/**\n+ * Class containing the actual measured values from the sensor\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class SensorMeasuredDataReply extends SensorReply {\n+    private byte pm25lowByte;\n+    private byte pm25highByte;\n+    private byte pm10lowByte;\n+    private byte pm10highByte;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78275e3df58da1567b75c9b1b2b6ef36af1bc404"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDU0MjM1OQ==", "bodyText": "please make this final", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r430542359", "createdAt": "2020-05-26T16:22:37Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/messages/CommandMessage.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal.sds011protocol.messages;\n+\n+import java.io.ByteArrayOutputStream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.util.HexUtils;\n+\n+/**\n+ * Message to be send to the device\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class CommandMessage {\n+    private static final byte HEAD = -86; // AA\n+    private static final byte COMMAND_ID = -76; // B4\n+    private static final byte TAIL = -85; // AB\n+\n+    private static final int DATA_BYTES_AFTER_FIRST_DATA_BYTE = 12;\n+\n+    private byte firstDataByte;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "78275e3df58da1567b75c9b1b2b6ef36af1bc404"}, "originalPosition": 34}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE4NzQxODg4", "url": "https://github.com/openhab/openhab-addons/pull/7528#pullrequestreview-418741888", "createdAt": "2020-05-26T23:17:50Z", "commit": {"oid": "3b594394ec2080ca6bb8de2fd3710720612a5d20"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQyMzoxNzo1MFrOGazbMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQyMzoxNzo1MFrOGazbMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc1ODcwNA==", "bodyText": "shouldn't you remove the event listener before you call this?", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r430758704", "createdAt": "2020-05-26T23:17:50Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/SDS011Communicator.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal.sds011protocol;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.TooManyListenersException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.util.HexUtils;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.SDS011Handler;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.CommandMessage;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.Constants;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.ModeReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorFirmwareReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SleepReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.WorkingPeriodReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Central instance to communicate with the device, i.e. receive data from it and send commands to it\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class SDS011Communicator implements SerialPortEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Communicator.class);\n+\n+    private SerialPortIdentifier portId;\n+    private SDS011Handler thingHandler;\n+    private @NonNullByDefault({}) SerialPort serialPort;\n+\n+    private @Nullable OutputStream outputStream;\n+    private @Nullable InputStream inputStream;\n+\n+    public SDS011Communicator(SDS011Handler thingHandler, SerialPortIdentifier portId) {\n+        this.thingHandler = thingHandler;\n+        this.portId = portId;\n+    }\n+\n+    /**\n+     * Initialize the communication with the device, i.e. open the serial port etc.\n+     *\n+     * @param mode the {@link WorkMode} if we want to use polling or reporting\n+     * @param interval the time between polling or reportings\n+     * @return {@code true} if we can communicate with the device\n+     * @throws PortInUseException\n+     * @throws TooManyListenersException\n+     * @throws IOException\n+     * @throws UnsupportedCommOperationException\n+     */\n+    public boolean initialize(WorkMode mode, Duration interval)\n+            throws PortInUseException, TooManyListenersException, IOException, UnsupportedCommOperationException {\n+        boolean initSuccessful = true;\n+\n+        SerialPort localSerialPort = portId.open(thingHandler.getThing().getUID().toString(), 2000);\n+        localSerialPort.setSerialPortParams(9600, 8, 1, 0);\n+\n+        outputStream = localSerialPort.getOutputStream();\n+        inputStream = localSerialPort.getInputStream();\n+\n+        if (inputStream == null || outputStream == null) {\n+            throw new IOException(\"Could not create input or outputstream for the port\");\n+        }\n+\n+        // wake up the device\n+        initSuccessful &= sendSleep(false);\n+        initSuccessful &= getFirmware();\n+\n+        if (mode == WorkMode.POLLING) {\n+            initSuccessful &= setMode(WorkMode.POLLING);\n+            initSuccessful &= setWorkingPeriod((byte) 0);\n+        } else {\n+            // reporting\n+            initSuccessful &= setWorkingPeriod((byte) interval.toMinutes());\n+            initSuccessful &= setMode(WorkMode.REPORTING);\n+        }\n+\n+        // enable listeners only after we have configured the sensor above because for configuring we send and read data\n+        // sequentially\n+        localSerialPort.notifyOnDataAvailable(true);\n+        localSerialPort.addEventListener(this);\n+        this.serialPort = localSerialPort;\n+\n+        return initSuccessful;\n+    }\n+\n+    private @Nullable SensorReply sendCommand(CommandMessage message) throws IOException {\n+        byte[] commandData = message.getBytes();\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Will send command: {} ({})\", HexUtils.bytesToHex(commandData), Arrays.toString(commandData));\n+        }\n+        outputStream.write(commandData, 0, commandData.length);\n+        outputStream.flush();\n+        try {\n+            // Give the sensor some time to handle the command\n+            Thread.sleep(500);\n+        } catch (InterruptedException e) {\n+            logger.warn(\"Problem while waiting for reading a reply to our command.\");\n+            Thread.currentThread().interrupt();\n+        }\n+        SensorReply reply = readReply();\n+        // in case there is still another reporting active, we want to discard the sensor data and read the reply to our\n+        // command again\n+        if (reply instanceof SensorMeasuredDataReply) {\n+            reply = readReply();\n+        }\n+        return reply;\n+    }\n+\n+    private boolean setWorkingPeriod(byte period) throws IOException {\n+        CommandMessage m = new CommandMessage(Command.WORKING_PERIOD, new byte[] { Constants.SET_ACTION, period });\n+        logger.debug(\"Sending work period: {}\", period);\n+        SensorReply reply = sendCommand(m);\n+        logger.debug(\"Got reply to setWorkingPeriod command: {}\", reply);\n+        if (reply instanceof WorkingPeriodReply) {\n+            WorkingPeriodReply wpReply = (WorkingPeriodReply) reply;\n+            if (wpReply.getPeriod() == period && wpReply.getActionType() == Constants.SET_ACTION) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean setMode(WorkMode workMode) throws IOException {\n+        byte haveToRequestData = 0;\n+        if (workMode == WorkMode.POLLING) {\n+            haveToRequestData = 1;\n+        }\n+\n+        CommandMessage m = new CommandMessage(Command.MODE, new byte[] { Constants.SET_ACTION, haveToRequestData });\n+        logger.debug(\"Sending mode: {}\", workMode);\n+        SensorReply reply = sendCommand(m);\n+        logger.debug(\"Got reply to setMode command: {}\", reply);\n+        if (reply instanceof ModeReply) {\n+            ModeReply mr = (ModeReply) reply;\n+            if (mr.getActionType() == Constants.SET_ACTION && mr.getMode() == workMode) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean sendSleep(boolean doSleep) throws IOException {\n+        byte payload = (byte) 1;\n+        if (doSleep) {\n+            payload = (byte) 0;\n+        }\n+\n+        CommandMessage m = new CommandMessage(Command.SLEEP, new byte[] { Constants.SET_ACTION, payload });\n+        logger.debug(\"Sending doSleep: {}\", doSleep);\n+        SensorReply reply = sendCommand(m);\n+        logger.debug(\"Got reply to sendSleep command: {}\", reply);\n+\n+        if (!doSleep) {\n+            // sometimes the sensor does not wakeup on the first attempt, thus we try again\n+            for (int i = 0; reply == null && i < 3; i++) {\n+                reply = sendCommand(m);\n+                logger.debug(\"Got reply to sendSleep command after retry#{}: {}\", i + 1, reply);\n+            }\n+        }\n+\n+        if (reply instanceof SleepReply) {\n+            SleepReply sr = (SleepReply) reply;\n+            if (sr.getActionType() == Constants.SET_ACTION && sr.getSleep() == payload) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean getFirmware() throws IOException {\n+        CommandMessage m = new CommandMessage(Command.FIRMWARE, new byte[] {});\n+        logger.debug(\"Sending get firmware request\");\n+        SensorReply reply = sendCommand(m);\n+        logger.debug(\"Got reply to getFirmware command: {}\", reply);\n+\n+        if (reply instanceof SensorFirmwareReply) {\n+            SensorFirmwareReply fwReply = (SensorFirmwareReply) reply;\n+            thingHandler.setFirmware(fwReply.getFirmware());\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Request data from the device, they will be returned via the serialEvent callback\n+     *\n+     * @throws IOException\n+     */\n+    public void requestSensorData() throws IOException {\n+        CommandMessage m = new CommandMessage(Command.REQUEST_DATA, new byte[] {});\n+        byte[] data = m.getBytes();\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Requesting sensor data, will send: {}\", HexUtils.bytesToHex(data));\n+        }\n+        outputStream.write(data, 0, data.length);\n+    }\n+\n+    private @Nullable SensorReply readReply() throws IOException {\n+        byte[] readBuffer = new byte[Constants.REPLY_LENGTH];\n+\n+        int b = -1;\n+        if (inputStream.available() > 0) {\n+            while ((b = inputStream.read()) != Constants.MESSAGE_START_AS_INT) {\n+                logger.debug(\"Trying to find first reply byte now...\");\n+            }\n+            readBuffer[0] = (byte) b;\n+            int remainingBytesRead = inputStream.read(readBuffer, 1, Constants.REPLY_LENGTH - 1);\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"Read remaining bytes: {}, full reply={}\", remainingBytesRead,\n+                        HexUtils.bytesToHex(readBuffer));\n+            }\n+            return ReplyFactory.create(readBuffer);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Data from the device is arriving and will be parsed accordingly\n+     */\n+    @Override\n+    public void serialEvent(SerialPortEvent event) {\n+        if (event.getEventType() == SerialPortEvent.DATA_AVAILABLE) {\n+            // we get here if data has been received\n+            SensorReply reply = null;\n+            try {\n+                reply = readReply();\n+                logger.debug(\"Got data from sensor: {}\", reply);\n+            } catch (IOException e) {\n+                logger.warn(\"Could not read available data from the serial port: {}\", e.getMessage());\n+            }\n+            if (reply instanceof SensorMeasuredDataReply) {\n+                SensorMeasuredDataReply sensorData = (SensorMeasuredDataReply) reply;\n+                if (sensorData.isValidData()) {\n+                    thingHandler.updateChannels(sensorData);\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Shutdown the communication, i.e. send the device to sleep and close the serial port\n+     */\n+    public void dispose() {\n+        if (serialPort != null) {\n+            try {\n+                // send the device to sleep to preserve power and extend the lifetime of the sensor\n+                sendSleep(true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b594394ec2080ca6bb8de2fd3710720612a5d20"}, "originalPosition": 274}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE4NzQzNDIx", "url": "https://github.com/openhab/openhab-addons/pull/7528#pullrequestreview-418743421", "createdAt": "2020-05-26T23:22:14Z", "commit": {"oid": "3b594394ec2080ca6bb8de2fd3710720612a5d20"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQyMzoyMjoxNVrOGazgNw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNlQyMzoyMjozM1rOGazgog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc1OTk5MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    outputStream.write(commandData, 0, commandData.length);\n          \n          \n            \n                    outputStream.write(commandData);", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r430759991", "createdAt": "2020-05-26T23:22:15Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/SDS011Communicator.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal.sds011protocol;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.TooManyListenersException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.util.HexUtils;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.SDS011Handler;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.CommandMessage;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.Constants;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.ModeReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorFirmwareReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SleepReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.WorkingPeriodReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Central instance to communicate with the device, i.e. receive data from it and send commands to it\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class SDS011Communicator implements SerialPortEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Communicator.class);\n+\n+    private SerialPortIdentifier portId;\n+    private SDS011Handler thingHandler;\n+    private @NonNullByDefault({}) SerialPort serialPort;\n+\n+    private @Nullable OutputStream outputStream;\n+    private @Nullable InputStream inputStream;\n+\n+    public SDS011Communicator(SDS011Handler thingHandler, SerialPortIdentifier portId) {\n+        this.thingHandler = thingHandler;\n+        this.portId = portId;\n+    }\n+\n+    /**\n+     * Initialize the communication with the device, i.e. open the serial port etc.\n+     *\n+     * @param mode the {@link WorkMode} if we want to use polling or reporting\n+     * @param interval the time between polling or reportings\n+     * @return {@code true} if we can communicate with the device\n+     * @throws PortInUseException\n+     * @throws TooManyListenersException\n+     * @throws IOException\n+     * @throws UnsupportedCommOperationException\n+     */\n+    public boolean initialize(WorkMode mode, Duration interval)\n+            throws PortInUseException, TooManyListenersException, IOException, UnsupportedCommOperationException {\n+        boolean initSuccessful = true;\n+\n+        SerialPort localSerialPort = portId.open(thingHandler.getThing().getUID().toString(), 2000);\n+        localSerialPort.setSerialPortParams(9600, 8, 1, 0);\n+\n+        outputStream = localSerialPort.getOutputStream();\n+        inputStream = localSerialPort.getInputStream();\n+\n+        if (inputStream == null || outputStream == null) {\n+            throw new IOException(\"Could not create input or outputstream for the port\");\n+        }\n+\n+        // wake up the device\n+        initSuccessful &= sendSleep(false);\n+        initSuccessful &= getFirmware();\n+\n+        if (mode == WorkMode.POLLING) {\n+            initSuccessful &= setMode(WorkMode.POLLING);\n+            initSuccessful &= setWorkingPeriod((byte) 0);\n+        } else {\n+            // reporting\n+            initSuccessful &= setWorkingPeriod((byte) interval.toMinutes());\n+            initSuccessful &= setMode(WorkMode.REPORTING);\n+        }\n+\n+        // enable listeners only after we have configured the sensor above because for configuring we send and read data\n+        // sequentially\n+        localSerialPort.notifyOnDataAvailable(true);\n+        localSerialPort.addEventListener(this);\n+        this.serialPort = localSerialPort;\n+\n+        return initSuccessful;\n+    }\n+\n+    private @Nullable SensorReply sendCommand(CommandMessage message) throws IOException {\n+        byte[] commandData = message.getBytes();\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Will send command: {} ({})\", HexUtils.bytesToHex(commandData), Arrays.toString(commandData));\n+        }\n+        outputStream.write(commandData, 0, commandData.length);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b594394ec2080ca6bb8de2fd3710720612a5d20"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDc2MDA5OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    outputStream.write(data, 0, data.length);\n          \n          \n            \n                    outputStream.write(data);\n          \n          \n            \n                    outputStream.flush();", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r430760098", "createdAt": "2020-05-26T23:22:33Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/SDS011Communicator.java", "diffHunk": "@@ -0,0 +1,297 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal.sds011protocol;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.TooManyListenersException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.util.HexUtils;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.SDS011Handler;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.CommandMessage;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.Constants;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.ModeReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorFirmwareReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SleepReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.WorkingPeriodReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Central instance to communicate with the device, i.e. receive data from it and send commands to it\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class SDS011Communicator implements SerialPortEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Communicator.class);\n+\n+    private SerialPortIdentifier portId;\n+    private SDS011Handler thingHandler;\n+    private @NonNullByDefault({}) SerialPort serialPort;\n+\n+    private @Nullable OutputStream outputStream;\n+    private @Nullable InputStream inputStream;\n+\n+    public SDS011Communicator(SDS011Handler thingHandler, SerialPortIdentifier portId) {\n+        this.thingHandler = thingHandler;\n+        this.portId = portId;\n+    }\n+\n+    /**\n+     * Initialize the communication with the device, i.e. open the serial port etc.\n+     *\n+     * @param mode the {@link WorkMode} if we want to use polling or reporting\n+     * @param interval the time between polling or reportings\n+     * @return {@code true} if we can communicate with the device\n+     * @throws PortInUseException\n+     * @throws TooManyListenersException\n+     * @throws IOException\n+     * @throws UnsupportedCommOperationException\n+     */\n+    public boolean initialize(WorkMode mode, Duration interval)\n+            throws PortInUseException, TooManyListenersException, IOException, UnsupportedCommOperationException {\n+        boolean initSuccessful = true;\n+\n+        SerialPort localSerialPort = portId.open(thingHandler.getThing().getUID().toString(), 2000);\n+        localSerialPort.setSerialPortParams(9600, 8, 1, 0);\n+\n+        outputStream = localSerialPort.getOutputStream();\n+        inputStream = localSerialPort.getInputStream();\n+\n+        if (inputStream == null || outputStream == null) {\n+            throw new IOException(\"Could not create input or outputstream for the port\");\n+        }\n+\n+        // wake up the device\n+        initSuccessful &= sendSleep(false);\n+        initSuccessful &= getFirmware();\n+\n+        if (mode == WorkMode.POLLING) {\n+            initSuccessful &= setMode(WorkMode.POLLING);\n+            initSuccessful &= setWorkingPeriod((byte) 0);\n+        } else {\n+            // reporting\n+            initSuccessful &= setWorkingPeriod((byte) interval.toMinutes());\n+            initSuccessful &= setMode(WorkMode.REPORTING);\n+        }\n+\n+        // enable listeners only after we have configured the sensor above because for configuring we send and read data\n+        // sequentially\n+        localSerialPort.notifyOnDataAvailable(true);\n+        localSerialPort.addEventListener(this);\n+        this.serialPort = localSerialPort;\n+\n+        return initSuccessful;\n+    }\n+\n+    private @Nullable SensorReply sendCommand(CommandMessage message) throws IOException {\n+        byte[] commandData = message.getBytes();\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Will send command: {} ({})\", HexUtils.bytesToHex(commandData), Arrays.toString(commandData));\n+        }\n+        outputStream.write(commandData, 0, commandData.length);\n+        outputStream.flush();\n+        try {\n+            // Give the sensor some time to handle the command\n+            Thread.sleep(500);\n+        } catch (InterruptedException e) {\n+            logger.warn(\"Problem while waiting for reading a reply to our command.\");\n+            Thread.currentThread().interrupt();\n+        }\n+        SensorReply reply = readReply();\n+        // in case there is still another reporting active, we want to discard the sensor data and read the reply to our\n+        // command again\n+        if (reply instanceof SensorMeasuredDataReply) {\n+            reply = readReply();\n+        }\n+        return reply;\n+    }\n+\n+    private boolean setWorkingPeriod(byte period) throws IOException {\n+        CommandMessage m = new CommandMessage(Command.WORKING_PERIOD, new byte[] { Constants.SET_ACTION, period });\n+        logger.debug(\"Sending work period: {}\", period);\n+        SensorReply reply = sendCommand(m);\n+        logger.debug(\"Got reply to setWorkingPeriod command: {}\", reply);\n+        if (reply instanceof WorkingPeriodReply) {\n+            WorkingPeriodReply wpReply = (WorkingPeriodReply) reply;\n+            if (wpReply.getPeriod() == period && wpReply.getActionType() == Constants.SET_ACTION) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean setMode(WorkMode workMode) throws IOException {\n+        byte haveToRequestData = 0;\n+        if (workMode == WorkMode.POLLING) {\n+            haveToRequestData = 1;\n+        }\n+\n+        CommandMessage m = new CommandMessage(Command.MODE, new byte[] { Constants.SET_ACTION, haveToRequestData });\n+        logger.debug(\"Sending mode: {}\", workMode);\n+        SensorReply reply = sendCommand(m);\n+        logger.debug(\"Got reply to setMode command: {}\", reply);\n+        if (reply instanceof ModeReply) {\n+            ModeReply mr = (ModeReply) reply;\n+            if (mr.getActionType() == Constants.SET_ACTION && mr.getMode() == workMode) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean sendSleep(boolean doSleep) throws IOException {\n+        byte payload = (byte) 1;\n+        if (doSleep) {\n+            payload = (byte) 0;\n+        }\n+\n+        CommandMessage m = new CommandMessage(Command.SLEEP, new byte[] { Constants.SET_ACTION, payload });\n+        logger.debug(\"Sending doSleep: {}\", doSleep);\n+        SensorReply reply = sendCommand(m);\n+        logger.debug(\"Got reply to sendSleep command: {}\", reply);\n+\n+        if (!doSleep) {\n+            // sometimes the sensor does not wakeup on the first attempt, thus we try again\n+            for (int i = 0; reply == null && i < 3; i++) {\n+                reply = sendCommand(m);\n+                logger.debug(\"Got reply to sendSleep command after retry#{}: {}\", i + 1, reply);\n+            }\n+        }\n+\n+        if (reply instanceof SleepReply) {\n+            SleepReply sr = (SleepReply) reply;\n+            if (sr.getActionType() == Constants.SET_ACTION && sr.getSleep() == payload) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private boolean getFirmware() throws IOException {\n+        CommandMessage m = new CommandMessage(Command.FIRMWARE, new byte[] {});\n+        logger.debug(\"Sending get firmware request\");\n+        SensorReply reply = sendCommand(m);\n+        logger.debug(\"Got reply to getFirmware command: {}\", reply);\n+\n+        if (reply instanceof SensorFirmwareReply) {\n+            SensorFirmwareReply fwReply = (SensorFirmwareReply) reply;\n+            thingHandler.setFirmware(fwReply.getFirmware());\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Request data from the device, they will be returned via the serialEvent callback\n+     *\n+     * @throws IOException\n+     */\n+    public void requestSensorData() throws IOException {\n+        CommandMessage m = new CommandMessage(Command.REQUEST_DATA, new byte[] {});\n+        byte[] data = m.getBytes();\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"Requesting sensor data, will send: {}\", HexUtils.bytesToHex(data));\n+        }\n+        outputStream.write(data, 0, data.length);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3b594394ec2080ca6bb8de2fd3710720612a5d20"}, "originalPosition": 222}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9ffd0c160059738fff9299756eeb48e25f349c93", "author": {"user": {"login": "t2000", "name": "Stefan Triller"}}, "url": "https://github.com/openhab/openhab-addons/commit/9ffd0c160059738fff9299756eeb48e25f349c93", "committedDate": "2020-05-27T15:46:32Z", "message": "Address further review comments\n\nSigned-off-by: Stefan Triller <github@stefantriller.de>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE5NDgxODA2", "url": "https://github.com/openhab/openhab-addons/pull/7528#pullrequestreview-419481806", "createdAt": "2020-05-27T18:04:41Z", "commit": {"oid": "9ffd0c160059738fff9299756eeb48e25f349c93"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxODowNDo0MVrOGbXBxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxODowNjowMVrOGbXEww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM0MjAyMw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private byte actionType;\n          \n          \n            \n                private WorkMode mode;\n          \n          \n            \n                private final byte actionType;\n          \n          \n            \n                private final WorkMode mode;", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r431342023", "createdAt": "2020-05-27T18:04:41Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/messages/ModeReply.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal.sds011protocol.messages;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.WorkMode;\n+\n+/**\n+ * Reply from sensor to a set mode command\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class ModeReply extends SensorReply {\n+\n+    private byte actionType;\n+    private WorkMode mode;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ffd0c160059738fff9299756eeb48e25f349c93"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM0MjMwOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private byte actionType;\n          \n          \n            \n                private byte sleep;\n          \n          \n            \n                private final byte actionType;\n          \n          \n            \n                private final byte sleep;", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r431342309", "createdAt": "2020-05-27T18:05:10Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/messages/SleepReply.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal.sds011protocol.messages;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * Reply from sensor to a set sleep command\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class SleepReply extends SensorReply {\n+\n+    private byte actionType;\n+    private byte sleep;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ffd0c160059738fff9299756eeb48e25f349c93"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM0MjUzMQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private byte year;\n          \n          \n            \n                private byte month;\n          \n          \n            \n                private byte day;\n          \n          \n            \n                private final byte year;\n          \n          \n            \n                private final byte month;\n          \n          \n            \n                private final byte day;", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r431342531", "createdAt": "2020-05-27T18:05:34Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/messages/SensorFirmwareReply.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal.sds011protocol.messages;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * Data from the sensor containing information about the installed firmware\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class SensorFirmwareReply extends SensorReply {\n+\n+    private byte year;\n+    private byte month;\n+    private byte day;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ffd0c160059738fff9299756eeb48e25f349c93"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM0Mjc4Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private byte actionType;\n          \n          \n            \n                private byte period;\n          \n          \n            \n                private final byte actionType;\n          \n          \n            \n                private final byte period;", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r431342787", "createdAt": "2020-05-27T18:06:01Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/messages/WorkingPeriodReply.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal.sds011protocol.messages;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * Reply from sensor to a set working period command\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class WorkingPeriodReply extends SensorReply {\n+\n+    private byte actionType;\n+    private byte period;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9ffd0c160059738fff9299756eeb48e25f349c93"}, "originalPosition": 27}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "57ed8c622051f16ef63902c4af6a810b1908ee83", "author": {"user": {"login": "t2000", "name": "Stefan Triller"}}, "url": "https://github.com/openhab/openhab-addons/commit/57ed8c622051f16ef63902c4af6a810b1908ee83", "committedDate": "2020-05-27T21:22:10Z", "message": "Addressed further review comments\n\nSigned-off-by: Stefan Triller <github@stefantriller.de>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIwNTM2Mjc2", "url": "https://github.com/openhab/openhab-addons/pull/7528#pullrequestreview-420536276", "createdAt": "2020-05-28T22:28:20Z", "commit": {"oid": "57ed8c622051f16ef63902c4af6a810b1908ee83"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMjoyODoyMFrOGcI5EQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQyMjoyOToxM1rOGcI6YA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE1ODk5Mw==", "bodyText": "Either make this nullable or initialize it to some default configuration.", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r432158993", "createdAt": "2020-05-28T22:28:20Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/SDS011Handler.java", "diffHunk": "@@ -0,0 +1,258 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.ZonedDateTime;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.dimension.Density;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.SDS011Communicator;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.WorkMode;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SDS011Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SDS011Handler extends BaseThingHandler {\n+    private static final Duration CONNECTION_MONITOR_START_DELAY_OFFSET = Duration.ofSeconds(10);\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Handler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    private @NonNullByDefault({}) NovaFineDustConfiguration config;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "57ed8c622051f16ef63902c4af6a810b1908ee83"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE1OTMyOA==", "bodyText": "Please make this nullable. I've had times in my own bindings that this ended up null unexpectedly.", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r432159328", "createdAt": "2020-05-28T22:29:13Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/SDS011Handler.java", "diffHunk": "@@ -0,0 +1,258 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.ZonedDateTime;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.dimension.Density;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.SDS011Communicator;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.WorkMode;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SDS011Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SDS011Handler extends BaseThingHandler {\n+    private static final Duration CONNECTION_MONITOR_START_DELAY_OFFSET = Duration.ofSeconds(10);\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Handler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    private @NonNullByDefault({}) NovaFineDustConfiguration config;\n+    private @NonNullByDefault({}) SDS011Communicator communicator;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "57ed8c622051f16ef63902c4af6a810b1908ee83"}, "originalPosition": 60}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "36cfe9f558a43f29e09c5da567dc9c0f3479d728", "author": {"user": {"login": "t2000", "name": "Stefan Triller"}}, "url": "https://github.com/openhab/openhab-addons/commit/36cfe9f558a43f29e09c5da567dc9c0f3479d728", "committedDate": "2020-05-29T06:49:54Z", "message": "More review comments\n\nSigned-off-by: Stefan Triller <github@stefantriller.de>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxNDM5NDEy", "url": "https://github.com/openhab/openhab-addons/pull/7528#pullrequestreview-421439412", "createdAt": "2020-05-30T20:03:13Z", "commit": {"oid": "36cfe9f558a43f29e09c5da567dc9c0f3479d728"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQyMDowMzoxM1rOGc1EmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQyMDowOTozMFrOGc1GUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4Mjg0MQ==", "bodyText": "To avoid null issues with the configs, you can change your config to be non-null and just populate the config with an instance that contains default values:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private @Nullable NovaFineDustConfiguration config;\n          \n          \n            \n                private NovaFineDustConfiguration config = new NovaFineDustConfiguration();", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r432882841", "createdAt": "2020-05-30T20:03:13Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/SDS011Handler.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.ZonedDateTime;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.dimension.Density;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.SDS011Communicator;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.WorkMode;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SDS011Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SDS011Handler extends BaseThingHandler {\n+    private static final Duration CONNECTION_MONITOR_START_DELAY_OFFSET = Duration.ofSeconds(10);\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Handler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    private @Nullable NovaFineDustConfiguration config;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36cfe9f558a43f29e09c5da567dc9c0f3479d728"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MzA3OQ==", "bodyText": "Please don't use @NonNullByDefault({}) if possible.", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r432883079", "createdAt": "2020-05-30T20:06:37Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/SDS011Communicator.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal.sds011protocol;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.TooManyListenersException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.util.HexUtils;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.SDS011Handler;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.CommandMessage;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.Constants;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.ModeReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorFirmwareReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SleepReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.WorkingPeriodReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Central instance to communicate with the device, i.e. receive data from it and send commands to it\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class SDS011Communicator implements SerialPortEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Communicator.class);\n+\n+    private SerialPortIdentifier portId;\n+    private SDS011Handler thingHandler;\n+    private @NonNullByDefault({}) SerialPort serialPort;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36cfe9f558a43f29e09c5da567dc9c0f3479d728"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4MzI4MA==", "bodyText": "If you want another way to get around the null checks. You could make these fields get populated from the constructor so you could make them non-null and final.\nYou would then turn your initialize method into a static factory method for SDS011Communicator instances.", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r432883280", "createdAt": "2020-05-30T20:09:30Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/sds011protocol/SDS011Communicator.java", "diffHunk": "@@ -0,0 +1,298 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal.sds011protocol;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.TooManyListenersException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.util.HexUtils;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.SDS011Handler;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.CommandMessage;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.Constants;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.ModeReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorFirmwareReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SleepReply;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.WorkingPeriodReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Central instance to communicate with the device, i.e. receive data from it and send commands to it\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class SDS011Communicator implements SerialPortEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Communicator.class);\n+\n+    private SerialPortIdentifier portId;\n+    private SDS011Handler thingHandler;\n+    private @NonNullByDefault({}) SerialPort serialPort;\n+\n+    private @Nullable OutputStream outputStream;\n+    private @Nullable InputStream inputStream;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36cfe9f558a43f29e09c5da567dc9c0f3479d728"}, "originalPosition": 59}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIxNDQxNTUy", "url": "https://github.com/openhab/openhab-addons/pull/7528#pullrequestreview-421441552", "createdAt": "2020-05-30T20:28:30Z", "commit": {"oid": "36cfe9f558a43f29e09c5da567dc9c0f3479d728"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQyMDoyODozMFrOGc1M9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQyMDoyODozMFrOGc1M9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg4NDk4Mw==", "bodyText": "Another example here of how to easily deal with the null warnings.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (pollingJob != null) {\n          \n          \n            \n                        pollingJob.cancel(true);\n          \n          \n            \n                        pollingJob = null;\n          \n          \n            \n                    }\n          \n          \n            \n                    Future<?> pollingJob = this.pollingJob;\n          \n          \n            \n                    if (pollingJob != null) {\n          \n          \n            \n                        pollingJob.cancel(true);\n          \n          \n            \n                        this.pollingJob = null;\n          \n          \n            \n                    }", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r432884983", "createdAt": "2020-05-30T20:28:30Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/SDS011Handler.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.ZonedDateTime;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.dimension.Density;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.SDS011Communicator;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.WorkMode;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SDS011Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SDS011Handler extends BaseThingHandler {\n+    private static final Duration CONNECTION_MONITOR_START_DELAY_OFFSET = Duration.ofSeconds(10);\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Handler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    private @Nullable NovaFineDustConfiguration config;\n+    private @Nullable SDS011Communicator communicator;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable ScheduledFuture<?> connectionMonitor;\n+\n+    private ZonedDateTime lastCommunication = ZonedDateTime.now();\n+\n+    // initialize timeBetweenDataShouldArrive with a large number\n+    private Duration timeBetweenDataShouldArrive = Duration.ofDays(1);\n+    private final Duration dataCanBeLateTolerance = Duration.ofSeconds(5);\n+\n+    // cached values fro refresh command\n+    private State statePM10 = UnDefType.UNDEF;\n+    private State statePM25 = UnDefType.UNDEF;\n+\n+    public SDS011Handler(Thing thing, SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // refresh channels with last received values from cache\n+        if (RefreshType.REFRESH.equals(command)) {\n+            if (NovaFineDustBindingConstants.CHANNEL_PM25.equals(channelUID.getId()) && statePM25 != UnDefType.UNDEF) {\n+                updateState(NovaFineDustBindingConstants.CHANNEL_PM25, statePM25);\n+            }\n+            if (NovaFineDustBindingConstants.CHANNEL_PM10.equals(channelUID.getId()) && statePM10 != UnDefType.UNDEF) {\n+                updateState(NovaFineDustBindingConstants.CHANNEL_PM10, statePM10);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        config = getConfigAs(NovaFineDustConfiguration.class);\n+\n+        if (!validateConfiguration()) {\n+            return;\n+        }\n+\n+        // parse ports and if the port is found, initialize the reader\n+        SerialPortIdentifier portId = serialPortManager.getIdentifier(config.port);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port is not known!\");\n+            return;\n+        }\n+\n+        this.communicator = new SDS011Communicator(this, portId);\n+\n+        if (config.reporting) {\n+            timeBetweenDataShouldArrive = Duration.ofMinutes(config.reportingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.REPORTING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        } else {\n+            timeBetweenDataShouldArrive = Duration.ofSeconds(config.pollingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.POLLING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        }\n+\n+        Duration connectionMonitorStartDelay = timeBetweenDataShouldArrive.plus(CONNECTION_MONITOR_START_DELAY_OFFSET);\n+        connectionMonitor = scheduler.scheduleWithFixedDelay(this::verifyIfStillConnected,\n+                connectionMonitorStartDelay.getSeconds(), timeBetweenDataShouldArrive.getSeconds(), TimeUnit.SECONDS);\n+    }\n+\n+    private void initializeCommunicator(WorkMode mode, Duration interval) {\n+        boolean initSuccessful = false;\n+        try {\n+            initSuccessful = communicator.initialize(mode, interval);\n+        } catch (final IOException ex) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"I/O error!\");\n+            return;\n+        } catch (PortInUseException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"Port is in use!\");\n+            return;\n+        } catch (TooManyListenersException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Cannot attach listener to port!\");\n+            return;\n+        } catch (UnsupportedCommOperationException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Cannot set serial port parameters\");\n+            return;\n+        }\n+\n+        if (initSuccessful) {\n+            lastCommunication = ZonedDateTime.now();\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            if (mode == WorkMode.POLLING) {\n+                pollingJob = scheduler.scheduleWithFixedDelay(() -> {\n+                    try {\n+                        communicator.requestSensorData();\n+                    } catch (IOException e) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                                \"Cannot query data from device\");\n+                    }\n+                }, 2, config.pollingInterval, TimeUnit.SECONDS);\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                    \"Commands and replies from the device don't seem to match\");\n+            logger.debug(\"Could not configure sensor -> setting Thing to OFFLINE and disposing the handler\");\n+            dispose();\n+        }\n+    }\n+\n+    private boolean validateConfiguration() {\n+        if (config == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Configuration could not be parsed\");\n+            return false;\n+        }\n+\n+        if (config.port == null || config.port.isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port must be set!\");\n+            return false;\n+        }\n+        if (config.reporting) {\n+            if (config.reportingInterval < 0 || config.reportingInterval > 30) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Reporting interval has to be between 0 and 30 minutes\");\n+                return false;\n+            }\n+        } else {\n+            if (config.pollingInterval < 3 || config.pollingInterval > 3600) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Polling interval has to be between 3 and 3600 seconds\");\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (pollingJob != null) {\n+            pollingJob.cancel(true);\n+            pollingJob = null;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "36cfe9f558a43f29e09c5da567dc9c0f3479d728"}, "originalPosition": 201}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e685099b38e6dda40cf3326a1182d394983790ac", "author": {"user": {"login": "t2000", "name": "Stefan Triller"}}, "url": "https://github.com/openhab/openhab-addons/commit/e685099b38e6dda40cf3326a1182d394983790ac", "committedDate": "2020-05-31T10:37:38Z", "message": "Make null analysis happy\n\nSigned-off-by: Stefan Triller <github@stefantriller.de>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyMDU1NTg1", "url": "https://github.com/openhab/openhab-addons/pull/7528#pullrequestreview-422055585", "createdAt": "2020-06-01T17:52:13Z", "commit": {"oid": "e685099b38e6dda40cf3326a1182d394983790ac"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxNzo1MjoxM1rOGdUL4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQxNzo1NzoxN1rOGdUWgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM5MjYwOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        scheduler.schedule(() -> initializeCommunicator(WorkMode.REPORTING, timeBetweenDataShouldArrive), 0,\n          \n          \n            \n                                TimeUnit.SECONDS);\n          \n          \n            \n                        scheduler.submit(() -> initializeCommunicator(WorkMode.REPORTING, timeBetweenDataShouldArrive));", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r433392608", "createdAt": "2020-06-01T17:52:13Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/SDS011Handler.java", "diffHunk": "@@ -0,0 +1,270 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.ZonedDateTime;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.dimension.Density;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.SDS011Communicator;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.WorkMode;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SDS011Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SDS011Handler extends BaseThingHandler {\n+    private static final Duration CONNECTION_MONITOR_START_DELAY_OFFSET = Duration.ofSeconds(10);\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Handler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    private NovaFineDustConfiguration config = new NovaFineDustConfiguration();\n+    private @Nullable SDS011Communicator communicator;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable ScheduledFuture<?> connectionMonitor;\n+\n+    private ZonedDateTime lastCommunication = ZonedDateTime.now();\n+\n+    // initialize timeBetweenDataShouldArrive with a large number\n+    private Duration timeBetweenDataShouldArrive = Duration.ofDays(1);\n+    private final Duration dataCanBeLateTolerance = Duration.ofSeconds(5);\n+\n+    // cached values for refresh command\n+    private State statePM10 = UnDefType.UNDEF;\n+    private State statePM25 = UnDefType.UNDEF;\n+\n+    public SDS011Handler(Thing thing, SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // refresh channels with last received values from cache\n+        if (RefreshType.REFRESH.equals(command)) {\n+            if (NovaFineDustBindingConstants.CHANNEL_PM25.equals(channelUID.getId()) && statePM25 != UnDefType.UNDEF) {\n+                updateState(NovaFineDustBindingConstants.CHANNEL_PM25, statePM25);\n+            }\n+            if (NovaFineDustBindingConstants.CHANNEL_PM10.equals(channelUID.getId()) && statePM10 != UnDefType.UNDEF) {\n+                updateState(NovaFineDustBindingConstants.CHANNEL_PM10, statePM10);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        config = getConfigAs(NovaFineDustConfiguration.class);\n+\n+        if (!validateConfiguration()) {\n+            return;\n+        }\n+\n+        // parse ports and if the port is found, initialize the reader\n+        SerialPortIdentifier portId = serialPortManager.getIdentifier(config.port);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port is not known!\");\n+            return;\n+        }\n+\n+        this.communicator = new SDS011Communicator(this, portId);\n+\n+        if (config.reporting) {\n+            timeBetweenDataShouldArrive = Duration.ofMinutes(config.reportingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.REPORTING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e685099b38e6dda40cf3326a1182d394983790ac"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM5MjcwMQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        scheduler.schedule(() -> initializeCommunicator(WorkMode.POLLING, timeBetweenDataShouldArrive), 0,\n          \n          \n            \n                                TimeUnit.SECONDS);\n          \n          \n            \n                        scheduler.submit(() -> initializeCommunicator(WorkMode.POLLING, timeBetweenDataShouldArrive));", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r433392701", "createdAt": "2020-06-01T17:52:26Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/SDS011Handler.java", "diffHunk": "@@ -0,0 +1,270 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.ZonedDateTime;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.dimension.Density;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.SDS011Communicator;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.WorkMode;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SDS011Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SDS011Handler extends BaseThingHandler {\n+    private static final Duration CONNECTION_MONITOR_START_DELAY_OFFSET = Duration.ofSeconds(10);\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Handler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    private NovaFineDustConfiguration config = new NovaFineDustConfiguration();\n+    private @Nullable SDS011Communicator communicator;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable ScheduledFuture<?> connectionMonitor;\n+\n+    private ZonedDateTime lastCommunication = ZonedDateTime.now();\n+\n+    // initialize timeBetweenDataShouldArrive with a large number\n+    private Duration timeBetweenDataShouldArrive = Duration.ofDays(1);\n+    private final Duration dataCanBeLateTolerance = Duration.ofSeconds(5);\n+\n+    // cached values for refresh command\n+    private State statePM10 = UnDefType.UNDEF;\n+    private State statePM25 = UnDefType.UNDEF;\n+\n+    public SDS011Handler(Thing thing, SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // refresh channels with last received values from cache\n+        if (RefreshType.REFRESH.equals(command)) {\n+            if (NovaFineDustBindingConstants.CHANNEL_PM25.equals(channelUID.getId()) && statePM25 != UnDefType.UNDEF) {\n+                updateState(NovaFineDustBindingConstants.CHANNEL_PM25, statePM25);\n+            }\n+            if (NovaFineDustBindingConstants.CHANNEL_PM10.equals(channelUID.getId()) && statePM10 != UnDefType.UNDEF) {\n+                updateState(NovaFineDustBindingConstants.CHANNEL_PM10, statePM10);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        config = getConfigAs(NovaFineDustConfiguration.class);\n+\n+        if (!validateConfiguration()) {\n+            return;\n+        }\n+\n+        // parse ports and if the port is found, initialize the reader\n+        SerialPortIdentifier portId = serialPortManager.getIdentifier(config.port);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port is not known!\");\n+            return;\n+        }\n+\n+        this.communicator = new SDS011Communicator(this, portId);\n+\n+        if (config.reporting) {\n+            timeBetweenDataShouldArrive = Duration.ofMinutes(config.reportingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.REPORTING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        } else {\n+            timeBetweenDataShouldArrive = Duration.ofSeconds(config.pollingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.POLLING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e685099b38e6dda40cf3326a1182d394983790ac"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM5NTMzMQ==", "bodyText": "Just to be safe, I would make sure that initialize, dispose, and initializeCommunicator are synchronized.", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r433395331", "createdAt": "2020-06-01T17:57:17Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/java/org/openhab/binding/novafinedust/internal/SDS011Handler.java", "diffHunk": "@@ -0,0 +1,270 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.novafinedust.internal;\n+\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.ZonedDateTime;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.dimension.Density;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.SDS011Communicator;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.WorkMode;\n+import org.openhab.binding.novafinedust.internal.sds011protocol.messages.SensorMeasuredDataReply;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SDS011Handler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Stefan Triller - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SDS011Handler extends BaseThingHandler {\n+    private static final Duration CONNECTION_MONITOR_START_DELAY_OFFSET = Duration.ofSeconds(10);\n+\n+    private final Logger logger = LoggerFactory.getLogger(SDS011Handler.class);\n+    private final SerialPortManager serialPortManager;\n+\n+    private NovaFineDustConfiguration config = new NovaFineDustConfiguration();\n+    private @Nullable SDS011Communicator communicator;\n+\n+    private @Nullable ScheduledFuture<?> pollingJob;\n+    private @Nullable ScheduledFuture<?> connectionMonitor;\n+\n+    private ZonedDateTime lastCommunication = ZonedDateTime.now();\n+\n+    // initialize timeBetweenDataShouldArrive with a large number\n+    private Duration timeBetweenDataShouldArrive = Duration.ofDays(1);\n+    private final Duration dataCanBeLateTolerance = Duration.ofSeconds(5);\n+\n+    // cached values for refresh command\n+    private State statePM10 = UnDefType.UNDEF;\n+    private State statePM25 = UnDefType.UNDEF;\n+\n+    public SDS011Handler(Thing thing, SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        // refresh channels with last received values from cache\n+        if (RefreshType.REFRESH.equals(command)) {\n+            if (NovaFineDustBindingConstants.CHANNEL_PM25.equals(channelUID.getId()) && statePM25 != UnDefType.UNDEF) {\n+                updateState(NovaFineDustBindingConstants.CHANNEL_PM25, statePM25);\n+            }\n+            if (NovaFineDustBindingConstants.CHANNEL_PM10.equals(channelUID.getId()) && statePM10 != UnDefType.UNDEF) {\n+                updateState(NovaFineDustBindingConstants.CHANNEL_PM10, statePM10);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        config = getConfigAs(NovaFineDustConfiguration.class);\n+\n+        if (!validateConfiguration()) {\n+            return;\n+        }\n+\n+        // parse ports and if the port is found, initialize the reader\n+        SerialPortIdentifier portId = serialPortManager.getIdentifier(config.port);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port is not known!\");\n+            return;\n+        }\n+\n+        this.communicator = new SDS011Communicator(this, portId);\n+\n+        if (config.reporting) {\n+            timeBetweenDataShouldArrive = Duration.ofMinutes(config.reportingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.REPORTING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        } else {\n+            timeBetweenDataShouldArrive = Duration.ofSeconds(config.pollingInterval);\n+            scheduler.schedule(() -> initializeCommunicator(WorkMode.POLLING, timeBetweenDataShouldArrive), 0,\n+                    TimeUnit.SECONDS);\n+        }\n+\n+        Duration connectionMonitorStartDelay = timeBetweenDataShouldArrive.plus(CONNECTION_MONITOR_START_DELAY_OFFSET);\n+        connectionMonitor = scheduler.scheduleWithFixedDelay(this::verifyIfStillConnected,\n+                connectionMonitorStartDelay.getSeconds(), timeBetweenDataShouldArrive.getSeconds(), TimeUnit.SECONDS);\n+    }\n+\n+    private void initializeCommunicator(WorkMode mode, Duration interval) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e685099b38e6dda40cf3326a1182d394983790ac"}, "originalPosition": 127}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d94ddb4ba25efe4248d2a174b64f1be2db773484", "author": {"user": {"login": "t2000", "name": "Stefan Triller"}}, "url": "https://github.com/openhab/openhab-addons/commit/d94ddb4ba25efe4248d2a174b64f1be2db773484", "committedDate": "2020-06-02T18:34:46Z", "message": "Small review changes\n\nSigned-off-by: Stefan Triller <github@stefantriller.de>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzMDk4NDkx", "url": "https://github.com/openhab/openhab-addons/pull/7528#pullrequestreview-423098491", "createdAt": "2020-06-02T22:24:21Z", "commit": {"oid": "d94ddb4ba25efe4248d2a174b64f1be2db773484"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwMTY1MzE4", "url": "https://github.com/openhab/openhab-addons/pull/7528#pullrequestreview-430165318", "createdAt": "2020-06-13T20:32:17Z", "commit": {"oid": "d94ddb4ba25efe4248d2a174b64f1be2db773484"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QyMDozMjoxN1rOGjZQ3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QyMDo0ODo1OFrOGjZUnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc2NzI2MQ==", "bodyText": "Please add a newline after every sentence throughout the README.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            This binding is for the fine dust sensor (PM Sensor) from Nova Fitness. Currently only one model is supported, the SDS011.\n          \n          \n            \n            This binding is for the fine dust sensor (PM Sensor) from Nova Fitness.\n          \n          \n            \n            Currently only one model is supported, the SDS011.", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r439767261", "createdAt": "2020-06-13T20:32:17Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.novafinedust/README.md", "diffHunk": "@@ -0,0 +1,78 @@\n+# NovaFineDust Binding\n+\n+This binding is for the fine dust sensor (PM Sensor) from Nova Fitness. Currently only one model is supported, the SDS011.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d94ddb4ba25efe4248d2a174b64f1be2db773484"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc2NzI5OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            There is only one Thing for this binding is `SDS011`.\n          \n          \n            \n            There is only one Thing type for this binding, which is `SDS011`.", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r439767299", "createdAt": "2020-06-13T20:32:50Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.novafinedust/README.md", "diffHunk": "@@ -0,0 +1,78 @@\n+# NovaFineDust Binding\n+\n+This binding is for the fine dust sensor (PM Sensor) from Nova Fitness. Currently only one model is supported, the SDS011.\n+\n+It basically implements the protocol specified in [this document](https://cdn.sparkfun.com/assets/parts/1/2/2/7/5/Laser_Dust_Sensor_Control_Protocol_V1.3.pdf).\n+One can measure the PM 2.5 and PM 10 values with this device. It comes very handy for detecting air pollution like neighbors firing their oven with wet wood etc. so one can deactivate the ventilation system. \n+\n+## Supported Things\n+\n+There is only one Thing for this binding is `SDS011`.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d94ddb4ba25efe4248d2a174b64f1be2db773484"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc2NzMyOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            There is no automatic discovery. The Thing has to be added manually via the `.things` configuration file or via (Paper) UI.\n          \n          \n            \n            There is no automatic discovery.", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r439767328", "createdAt": "2020-06-13T20:33:17Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.novafinedust/README.md", "diffHunk": "@@ -0,0 +1,78 @@\n+# NovaFineDust Binding\n+\n+This binding is for the fine dust sensor (PM Sensor) from Nova Fitness. Currently only one model is supported, the SDS011.\n+\n+It basically implements the protocol specified in [this document](https://cdn.sparkfun.com/assets/parts/1/2/2/7/5/Laser_Dust_Sensor_Control_Protocol_V1.3.pdf).\n+One can measure the PM 2.5 and PM 10 values with this device. It comes very handy for detecting air pollution like neighbors firing their oven with wet wood etc. so one can deactivate the ventilation system. \n+\n+## Supported Things\n+\n+There is only one Thing for this binding is `SDS011`.\n+\n+## Discovery\n+\n+There is no automatic discovery. The Thing has to be added manually via the `.things` configuration file or via (Paper) UI.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d94ddb4ba25efe4248d2a174b64f1be2db773484"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc2NzQyMA==", "bodyText": "Above you say that \"reporting\" is the default mode. If there's a default, the parameter is not mandatory, but optional.", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r439767420", "createdAt": "2020-06-13T20:35:03Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.novafinedust/README.md", "diffHunk": "@@ -0,0 +1,78 @@\n+# NovaFineDust Binding\n+\n+This binding is for the fine dust sensor (PM Sensor) from Nova Fitness. Currently only one model is supported, the SDS011.\n+\n+It basically implements the protocol specified in [this document](https://cdn.sparkfun.com/assets/parts/1/2/2/7/5/Laser_Dust_Sensor_Control_Protocol_V1.3.pdf).\n+One can measure the PM 2.5 and PM 10 values with this device. It comes very handy for detecting air pollution like neighbors firing their oven with wet wood etc. so one can deactivate the ventilation system. \n+\n+## Supported Things\n+\n+There is only one Thing for this binding is `SDS011`.\n+\n+## Discovery\n+\n+There is no automatic discovery. The Thing has to be added manually via the `.things` configuration file or via (Paper) UI.\n+\n+## Thing Configuration\n+\n+There are 2 different working modes for the `SDS011` thing: Reporting and Polling.\n+\n+### Reporting\n+\n+This is the preferred mode and thus also configured as a default. In this mode the sensor wakes up every `reportingInterval` minutes, performs a measurement for 30 seconds and sleeps for `reportingInterval` minus 30 seconds. Remember: According to the [datasheet](https://www-sd-nf.oss-cn-beijing.aliyuncs.com/%E5%AE%98%E7%BD%91%E4%B8%8B%E8%BD%BD/SDS011%20laser%20PM2.5%20sensor%20specification-V1.4.pdf) the sensor has a lifetime of 8000 hours. Using a 0 as `reportingInterval` will make the sensor report its data as fast as possible.\n+\n+### Polling\n+\n+If one needs data in different intervals, i.e. not as fast as possible and not in intervals that are a multiple of full minutes, polling can be configured. The `pollingInterval` parameter specifies the time in seconds when data will be polled from the sensor.\n+\n+In addition to the mode one has to provide the port to which the device is connected.\n+\n+A full overview about the parameters of the `SDS011` thing is given in the following table:\n+\n+| parameter name    | mandatory | description                                                                           |\n+|-------------------|-----------|---------------------------------------------------------------------------------------|\n+| port              | yes       | the port the sensor is connected to, i.e. /dev/ttyUSB0.                              |\n+| reporting         | yes       | whether the reporting mode (value=true) or polling mode should be used.               |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d94ddb4ba25efe4248d2a174b64f1be2db773484"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc2NzU2Mw==", "bodyText": "You mean there could be multiple sensors on the same port, right?\nI very much hope that it is possible to have multiple SDS011 things that use different ports.\nMaybe you can clarify this in the statement here a bit.", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r439767563", "createdAt": "2020-06-13T20:37:37Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.novafinedust/README.md", "diffHunk": "@@ -0,0 +1,78 @@\n+# NovaFineDust Binding\n+\n+This binding is for the fine dust sensor (PM Sensor) from Nova Fitness. Currently only one model is supported, the SDS011.\n+\n+It basically implements the protocol specified in [this document](https://cdn.sparkfun.com/assets/parts/1/2/2/7/5/Laser_Dust_Sensor_Control_Protocol_V1.3.pdf).\n+One can measure the PM 2.5 and PM 10 values with this device. It comes very handy for detecting air pollution like neighbors firing their oven with wet wood etc. so one can deactivate the ventilation system. \n+\n+## Supported Things\n+\n+There is only one Thing for this binding is `SDS011`.\n+\n+## Discovery\n+\n+There is no automatic discovery. The Thing has to be added manually via the `.things` configuration file or via (Paper) UI.\n+\n+## Thing Configuration\n+\n+There are 2 different working modes for the `SDS011` thing: Reporting and Polling.\n+\n+### Reporting\n+\n+This is the preferred mode and thus also configured as a default. In this mode the sensor wakes up every `reportingInterval` minutes, performs a measurement for 30 seconds and sleeps for `reportingInterval` minus 30 seconds. Remember: According to the [datasheet](https://www-sd-nf.oss-cn-beijing.aliyuncs.com/%E5%AE%98%E7%BD%91%E4%B8%8B%E8%BD%BD/SDS011%20laser%20PM2.5%20sensor%20specification-V1.4.pdf) the sensor has a lifetime of 8000 hours. Using a 0 as `reportingInterval` will make the sensor report its data as fast as possible.\n+\n+### Polling\n+\n+If one needs data in different intervals, i.e. not as fast as possible and not in intervals that are a multiple of full minutes, polling can be configured. The `pollingInterval` parameter specifies the time in seconds when data will be polled from the sensor.\n+\n+In addition to the mode one has to provide the port to which the device is connected.\n+\n+A full overview about the parameters of the `SDS011` thing is given in the following table:\n+\n+| parameter name    | mandatory | description                                                                           |\n+|-------------------|-----------|---------------------------------------------------------------------------------------|\n+| port              | yes       | the port the sensor is connected to, i.e. /dev/ttyUSB0.                              |\n+| reporting         | yes       | whether the reporting mode (value=true) or polling mode should be used.               |\n+| reportingInterval | no        | the time in minutes between reportings from the sensor (default=1, min=0, max=30).    |\n+| pollingInterval   | no        | the time in seconds between data polls from the device. (default=10, min=3, max=3600) |\n+\n+## Channels\n+\n+Since the supported device is a sensor, both channels are read-only channels. \n+\n+| channel  | type           | description                   |\n+|----------|----------------|-------------------------------|\n+| pm25     | Number:Density | This provides the PM2.5 value |\n+| pm10     | Number:Density | This provides the PM10 value  |\n+\n+## Full Example\n+\n+demo.things:\n+\n+```\n+Thing novafinedust:SDS011:mySDS011Report \"My SDS011 Fine Dust Sensor with reporting\" [ port=\"/dev/ttyUSB0\", reporting=true, reportingInterval=1 ]\n+Thing novafinedust:SDS011:mySDS011Poll \"My SDS011 Fine Dust Sensor with polling\" [ port=\"/dev/ttyUSB0\", reporting=false, pollingInterval=10 ]\n+```\n+\n+demo.items:\n+\n+```\n+Number:Density PM25 \"My PM 2.5 value\" { channel=\"novafinedust:SDS011:mySDS011Report:pm25\" }\n+Number:Density PM10 \"My PM 10 value\" { channel=\"novafinedust:SDS011:mySDS011Report:pm10\" }\n+```\n+\n+demo.sitemap:\n+\n+```\n+sitemap demo label=\"Main Menu\"\n+{\n+    Frame {\n+        Text item=PM25 label=\"My PM 2.5 value\"\n+        Text item=PM10 label=\"My PM 10 value\"\n+    }\n+}\n+```\n+\n+## Limitations\n+\n+In theory once can have multiple sensors connected and distinguish them via their device ID. However, this is currently not implemented and the binding always configures any device and accepts data reportings from any device too.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d94ddb4ba25efe4248d2a174b64f1be2db773484"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc2NzYzOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            In theory once can have multiple sensors connected and distinguish them via their device ID. However, this is currently not implemented and the binding always configures any device and accepts data reportings from any device too.\n          \n          \n            \n            In theory one can have multiple sensors connected and distinguish them via their device ID. However, this is currently not implemented and the binding always configures any device and accepts data reportings from any device too.", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r439767639", "createdAt": "2020-06-13T20:38:41Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.novafinedust/README.md", "diffHunk": "@@ -0,0 +1,78 @@\n+# NovaFineDust Binding\n+\n+This binding is for the fine dust sensor (PM Sensor) from Nova Fitness. Currently only one model is supported, the SDS011.\n+\n+It basically implements the protocol specified in [this document](https://cdn.sparkfun.com/assets/parts/1/2/2/7/5/Laser_Dust_Sensor_Control_Protocol_V1.3.pdf).\n+One can measure the PM 2.5 and PM 10 values with this device. It comes very handy for detecting air pollution like neighbors firing their oven with wet wood etc. so one can deactivate the ventilation system. \n+\n+## Supported Things\n+\n+There is only one Thing for this binding is `SDS011`.\n+\n+## Discovery\n+\n+There is no automatic discovery. The Thing has to be added manually via the `.things` configuration file or via (Paper) UI.\n+\n+## Thing Configuration\n+\n+There are 2 different working modes for the `SDS011` thing: Reporting and Polling.\n+\n+### Reporting\n+\n+This is the preferred mode and thus also configured as a default. In this mode the sensor wakes up every `reportingInterval` minutes, performs a measurement for 30 seconds and sleeps for `reportingInterval` minus 30 seconds. Remember: According to the [datasheet](https://www-sd-nf.oss-cn-beijing.aliyuncs.com/%E5%AE%98%E7%BD%91%E4%B8%8B%E8%BD%BD/SDS011%20laser%20PM2.5%20sensor%20specification-V1.4.pdf) the sensor has a lifetime of 8000 hours. Using a 0 as `reportingInterval` will make the sensor report its data as fast as possible.\n+\n+### Polling\n+\n+If one needs data in different intervals, i.e. not as fast as possible and not in intervals that are a multiple of full minutes, polling can be configured. The `pollingInterval` parameter specifies the time in seconds when data will be polled from the sensor.\n+\n+In addition to the mode one has to provide the port to which the device is connected.\n+\n+A full overview about the parameters of the `SDS011` thing is given in the following table:\n+\n+| parameter name    | mandatory | description                                                                           |\n+|-------------------|-----------|---------------------------------------------------------------------------------------|\n+| port              | yes       | the port the sensor is connected to, i.e. /dev/ttyUSB0.                              |\n+| reporting         | yes       | whether the reporting mode (value=true) or polling mode should be used.               |\n+| reportingInterval | no        | the time in minutes between reportings from the sensor (default=1, min=0, max=30).    |\n+| pollingInterval   | no        | the time in seconds between data polls from the device. (default=10, min=3, max=3600) |\n+\n+## Channels\n+\n+Since the supported device is a sensor, both channels are read-only channels. \n+\n+| channel  | type           | description                   |\n+|----------|----------------|-------------------------------|\n+| pm25     | Number:Density | This provides the PM2.5 value |\n+| pm10     | Number:Density | This provides the PM10 value  |\n+\n+## Full Example\n+\n+demo.things:\n+\n+```\n+Thing novafinedust:SDS011:mySDS011Report \"My SDS011 Fine Dust Sensor with reporting\" [ port=\"/dev/ttyUSB0\", reporting=true, reportingInterval=1 ]\n+Thing novafinedust:SDS011:mySDS011Poll \"My SDS011 Fine Dust Sensor with polling\" [ port=\"/dev/ttyUSB0\", reporting=false, pollingInterval=10 ]\n+```\n+\n+demo.items:\n+\n+```\n+Number:Density PM25 \"My PM 2.5 value\" { channel=\"novafinedust:SDS011:mySDS011Report:pm25\" }\n+Number:Density PM10 \"My PM 10 value\" { channel=\"novafinedust:SDS011:mySDS011Report:pm10\" }\n+```\n+\n+demo.sitemap:\n+\n+```\n+sitemap demo label=\"Main Menu\"\n+{\n+    Frame {\n+        Text item=PM25 label=\"My PM 2.5 value\"\n+        Text item=PM10 label=\"My PM 10 value\"\n+    }\n+}\n+```\n+\n+## Limitations\n+\n+In theory once can have multiple sensors connected and distinguish them via their device ID. However, this is currently not implemented and the binding always configures any device and accepts data reportings from any device too.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d94ddb4ba25efe4248d2a174b64f1be2db773484"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc2ODE0MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t<label>Reporting If True, Otherwise Polling</label>\n          \n          \n            \n            \t\t\t\t<label>Mode</label>\n          \n          \n            \n            \t\t\t\t<options>\n          \n          \n            \n            \t\t\t\t\t<option value=\"true\">Reporting</option>\n          \n          \n            \n            \t\t\t\t\t<option value=\"false\">Polling</option>\n          \n          \n            \n            \t\t\t\t</options>", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r439768141", "createdAt": "2020-06-13T20:47:22Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,57 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"novafinedust\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"SDS011\">\n+\t\t<label>Nova SDS011 Fine Dust Sensor</label>\n+\t\t<description>Nova SDS011 Fine Dust Sensor connected via USB</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"pm10\" typeId=\"pm10-type\" />\n+\t\t\t<channel id=\"pm25\" typeId=\"pm25-type\" />\n+\t\t</channels>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"port\" type=\"text\" required=\"true\">\n+\t\t\t\t<context>serial-port</context>\n+\t\t\t\t<label>USB Port</label>\n+\t\t\t\t<description>USB port the device is connected to i.e. /dev/ttyUSB0</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"reporting\" type=\"boolean\">\n+\t\t\t\t<default>true</default>\n+\t\t\t\t<label>Reporting If True, Otherwise Polling</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d94ddb4ba25efe4248d2a174b64f1be2db773484"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc2ODIwMw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t<label>Time In Minutes When A Value Will Be Reported</label>\n          \n          \n            \n            \t\t\t\t<label>Reporting Interval</label>", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r439768203", "createdAt": "2020-06-13T20:48:23Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,57 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"novafinedust\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"SDS011\">\n+\t\t<label>Nova SDS011 Fine Dust Sensor</label>\n+\t\t<description>Nova SDS011 Fine Dust Sensor connected via USB</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"pm10\" typeId=\"pm10-type\" />\n+\t\t\t<channel id=\"pm25\" typeId=\"pm25-type\" />\n+\t\t</channels>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"port\" type=\"text\" required=\"true\">\n+\t\t\t\t<context>serial-port</context>\n+\t\t\t\t<label>USB Port</label>\n+\t\t\t\t<description>USB port the device is connected to i.e. /dev/ttyUSB0</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"reporting\" type=\"boolean\">\n+\t\t\t\t<default>true</default>\n+\t\t\t\t<label>Reporting If True, Otherwise Polling</label>\n+\t\t\t\t<description>Reporting is strongly recommended to increase sensor lifetime</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"reportingInterval\" type=\"integer\" min=\"0\" max=\"30\" unit=\"min\">\n+\t\t\t\t<default>1</default>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t\t<label>Time In Minutes When A Value Will Be Reported</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d94ddb4ba25efe4248d2a174b64f1be2db773484"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc2ODIxMA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t<label>Time In Seconds When A Value Will Be Polled From The Device (Min 3 Seconds)</label>\n          \n          \n            \n            \t\t\t\t<label>Polling Interval</label>", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r439768210", "createdAt": "2020-06-13T20:48:38Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,57 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"novafinedust\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"SDS011\">\n+\t\t<label>Nova SDS011 Fine Dust Sensor</label>\n+\t\t<description>Nova SDS011 Fine Dust Sensor connected via USB</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"pm10\" typeId=\"pm10-type\" />\n+\t\t\t<channel id=\"pm25\" typeId=\"pm25-type\" />\n+\t\t</channels>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"port\" type=\"text\" required=\"true\">\n+\t\t\t\t<context>serial-port</context>\n+\t\t\t\t<label>USB Port</label>\n+\t\t\t\t<description>USB port the device is connected to i.e. /dev/ttyUSB0</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"reporting\" type=\"boolean\">\n+\t\t\t\t<default>true</default>\n+\t\t\t\t<label>Reporting If True, Otherwise Polling</label>\n+\t\t\t\t<description>Reporting is strongly recommended to increase sensor lifetime</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"reportingInterval\" type=\"integer\" min=\"0\" max=\"30\" unit=\"min\">\n+\t\t\t\t<default>1</default>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t\t<label>Time In Minutes When A Value Will Be Reported</label>\n+\t\t\t\t<description>Device will report every x minutes and sleep for x*60 - 30 seconds afterwards, 0 = as fast as possible without sleep</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"pollingInterval\" type=\"integer\" min=\"3\" max=\"3600\" unit=\"s\">\n+\t\t\t\t<default>10</default>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t\t<label>Time In Seconds When A Value Will Be Polled From The Device (Min 3 Seconds)</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d94ddb4ba25efe4248d2a174b64f1be2db773484"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc2ODIyMQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t<label>PM10</label>\n          \n          \n            \n            \t\t<label>PM 10</label>", "url": "https://github.com/openhab/openhab-addons/pull/7528#discussion_r439768221", "createdAt": "2020-06-13T20:48:58Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.novafinedust/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,57 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"novafinedust\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"SDS011\">\n+\t\t<label>Nova SDS011 Fine Dust Sensor</label>\n+\t\t<description>Nova SDS011 Fine Dust Sensor connected via USB</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"pm10\" typeId=\"pm10-type\" />\n+\t\t\t<channel id=\"pm25\" typeId=\"pm25-type\" />\n+\t\t</channels>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"port\" type=\"text\" required=\"true\">\n+\t\t\t\t<context>serial-port</context>\n+\t\t\t\t<label>USB Port</label>\n+\t\t\t\t<description>USB port the device is connected to i.e. /dev/ttyUSB0</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"reporting\" type=\"boolean\">\n+\t\t\t\t<default>true</default>\n+\t\t\t\t<label>Reporting If True, Otherwise Polling</label>\n+\t\t\t\t<description>Reporting is strongly recommended to increase sensor lifetime</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"reportingInterval\" type=\"integer\" min=\"0\" max=\"30\" unit=\"min\">\n+\t\t\t\t<default>1</default>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t\t<label>Time In Minutes When A Value Will Be Reported</label>\n+\t\t\t\t<description>Device will report every x minutes and sleep for x*60 - 30 seconds afterwards, 0 = as fast as possible without sleep</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"pollingInterval\" type=\"integer\" min=\"3\" max=\"3600\" unit=\"s\">\n+\t\t\t\t<default>10</default>\n+\t\t\t\t<advanced>true</advanced>\n+\t\t\t\t<label>Time In Seconds When A Value Will Be Polled From The Device (Min 3 Seconds)</label>\n+\t\t\t\t<description>Device will be polled every x seconds (polling is not recommended)</description>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\n+\t</thing-type>\n+\n+\t<channel-type id=\"pm25-type\">\n+\t\t<item-type>Number:Density</item-type>\n+\t\t<label>PM 2.5</label>\n+\t\t<description>The PM 2.5 value</description>\n+\t\t<state readOnly=\"true\" pattern=\"%.1f %unit%\"></state>\n+\t</channel-type>\n+\n+\t<channel-type id=\"pm10-type\">\n+\t\t<item-type>Number:Density</item-type>\n+\t\t<label>PM10</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d94ddb4ba25efe4248d2a174b64f1be2db773484"}, "originalPosition": 52}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "00642f2333a2ad2766f8a29175e21ba142b3beca", "author": {"user": {"login": "t2000", "name": "Stefan Triller"}}, "url": "https://github.com/openhab/openhab-addons/commit/00642f2333a2ad2766f8a29175e21ba142b3beca", "committedDate": "2020-06-14T09:49:13Z", "message": "Apply suggestions from code review\n\nThanks Kai for your suggestions, I have accepted them all and will take care of the few others in an additional commit.\n\nCo-authored-by: Kai Kreuzer <kai@openhab.org>\nSigned-off-by: Stefan Triller <github@stefantriller.de>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4c82b6c69b5a8c1726de9ed4ef6e15ea28cb0f1d", "author": {"user": {"login": "t2000", "name": "Stefan Triller"}}, "url": "https://github.com/openhab/openhab-addons/commit/4c82b6c69b5a8c1726de9ed4ef6e15ea28cb0f1d", "committedDate": "2020-06-14T09:45:29Z", "message": "Apply suggestions from code review\r\n\r\nThanks Kai for your suggestions, I have accepted them all and will take care of the few others in an additional commit.\n\nCo-authored-by: Kai Kreuzer <kai@openhab.org>"}, "afterCommit": {"oid": "00642f2333a2ad2766f8a29175e21ba142b3beca", "author": {"user": {"login": "t2000", "name": "Stefan Triller"}}, "url": "https://github.com/openhab/openhab-addons/commit/00642f2333a2ad2766f8a29175e21ba142b3beca", "committedDate": "2020-06-14T09:49:13Z", "message": "Apply suggestions from code review\n\nThanks Kai for your suggestions, I have accepted them all and will take care of the few others in an additional commit.\n\nCo-authored-by: Kai Kreuzer <kai@openhab.org>\nSigned-off-by: Stefan Triller <github@stefantriller.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4abf72848a9ffffb7e922053865ccb11260c113b", "author": {"user": {"login": "t2000", "name": "Stefan Triller"}}, "url": "https://github.com/openhab/openhab-addons/commit/4abf72848a9ffffb7e922053865ccb11260c113b", "committedDate": "2020-06-14T09:57:09Z", "message": "README clarifications\n\nSigned-off-by: Stefan Triller <github@stefantriller.de>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwMjA2MTA3", "url": "https://github.com/openhab/openhab-addons/pull/7528#pullrequestreview-430206107", "createdAt": "2020-06-14T10:23:53Z", "commit": {"oid": "4abf72848a9ffffb7e922053865ccb11260c113b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 706, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}