{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAxMDMzNjM3", "number": 8723, "reviewThreads": {"totalCount": 73, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMDoxNTowMFrOEv9ZXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yOVQwNTowMToxMVrOE-Wg3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NzI0NDQ2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.ambientweather/src/main/feature/feature.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMDoxNTowMFrOHlPTcw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQxMDo0MDo1M1rOHnsqbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgxMDA5OQ==", "bodyText": "Can you remove this change from your PR?", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r508810099", "createdAt": "2020-10-20T20:15:00Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.ambientweather/src/main/feature/feature.xml", "diffHunk": "@@ -1,4 +1,18 @@\n <?xml version=\"1.0\" encoding=\"UTF-8\"?>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a38f97cb3c7d7e3e94161bfaed485b4de24f498b"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM4ODI2OA==", "bodyText": "Woops, sorry. Spotless' job i guess.", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r511388268", "createdAt": "2020-10-24T10:40:53Z", "author": {"login": "Sonic-Amiga"}, "path": "bundles/org.openhab.binding.ambientweather/src/main/feature/feature.xml", "diffHunk": "@@ -1,4 +1,18 @@\n <?xml version=\"1.0\" encoding=\"UTF-8\"?>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgxMDA5OQ=="}, "originalCommit": {"oid": "a38f97cb3c7d7e3e94161bfaed485b4de24f498b"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NzI0NTcxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.irobot/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMDoxNToyMlrOHlPUNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMDoxNToyMlrOHlPUNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgxMDI5Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            # iRobot binding\n          \n          \n            \n            # iRobot Binding", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r508810292", "createdAt": "2020-10-20T20:15:22Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.irobot/README.md", "diffHunk": "@@ -0,0 +1,154 @@\n+# iRobot binding", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a38f97cb3c7d7e3e94161bfaed485b4de24f498b"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NzI0NjgwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.irobot/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMDoxNTo0MlrOHlPU6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMDoxNTo0MlrOHlPU6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgxMDQ3NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            This binding provides for integration of products by iRobot company (http://www.irobot.com/). It is currently developed to support Roomba 900\n          \n          \n            \n            This binding provides integration of products by iRobot company (http://www.irobot.com/). It is currently developed to support Roomba 900", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r508810474", "createdAt": "2020-10-20T20:15:42Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.irobot/README.md", "diffHunk": "@@ -0,0 +1,154 @@\n+# iRobot binding\n+\n+This binding provides for integration of products by iRobot company (http://www.irobot.com/). It is currently developed to support Roomba 900", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a38f97cb3c7d7e3e94161bfaed485b4de24f498b"}, "originalPosition": 3}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NzI1NjIxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.irobot/README.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMDoxODoyMVrOHlPadw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQxMDo0NToyOVrOHnsxBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgxMTg5NQ==", "bodyText": "This could be moved to the end of the readme or moved to the PR description and removed completely from here.", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r508811895", "createdAt": "2020-10-20T20:18:21Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.irobot/README.md", "diffHunk": "@@ -0,0 +1,154 @@\n+# iRobot binding\n+\n+This binding provides for integration of products by iRobot company (http://www.irobot.com/). It is currently developed to support Roomba 900\n+series robotic vacuum cleaner with built-in Wi-Fi module. The binding interfaces to the robot directly without any need for a dedicated MQTT server.\n+\n+The development starts with an abandoned draft by hkunh42 (http://github.com/hkuhn42/openhab2.roomba) and heavily uses the following\n+projects as a reference:\n+\n+- Roomba980-Python by Nick Waterton (http://github.com/NickWaterton/Roomba980-Python)\n+- Dorita980 by Facu ZAK (https://github.com/koalazak/dorita980)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a38f97cb3c7d7e3e94161bfaed485b4de24f498b"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM4OTk1Nw==", "bodyText": "Moved to the end, to Credits section. Will this suffice ?", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r511389957", "createdAt": "2020-10-24T10:45:29Z", "author": {"login": "Sonic-Amiga"}, "path": "bundles/org.openhab.binding.irobot/README.md", "diffHunk": "@@ -0,0 +1,154 @@\n+# iRobot binding\n+\n+This binding provides for integration of products by iRobot company (http://www.irobot.com/). It is currently developed to support Roomba 900\n+series robotic vacuum cleaner with built-in Wi-Fi module. The binding interfaces to the robot directly without any need for a dedicated MQTT server.\n+\n+The development starts with an abandoned draft by hkunh42 (http://github.com/hkuhn42/openhab2.roomba) and heavily uses the following\n+projects as a reference:\n+\n+- Roomba980-Python by Nick Waterton (http://github.com/NickWaterton/Roomba980-Python)\n+- Dorita980 by Facu ZAK (https://github.com/koalazak/dorita980)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgxMTg5NQ=="}, "originalCommit": {"oid": "a38f97cb3c7d7e3e94161bfaed485b4de24f498b"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NzI1ODc1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.irobot/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMDoxOToxM1rOHlPcGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMDoxOToxM1rOHlPcGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgxMjMxNQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Roombas on current network will be discovered automatically, however in order to connect to them a password is needed. The\n          \n          \n            \n            Roombas on the same network will be discovered automatically, however in order to connect to them a password is needed. The", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r508812315", "createdAt": "2020-10-20T20:19:13Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.irobot/README.md", "diffHunk": "@@ -0,0 +1,154 @@\n+# iRobot binding\n+\n+This binding provides for integration of products by iRobot company (http://www.irobot.com/). It is currently developed to support Roomba 900\n+series robotic vacuum cleaner with built-in Wi-Fi module. The binding interfaces to the robot directly without any need for a dedicated MQTT server.\n+\n+The development starts with an abandoned draft by hkunh42 (http://github.com/hkuhn42/openhab2.roomba) and heavily uses the following\n+projects as a reference:\n+\n+- Roomba980-Python by Nick Waterton (http://github.com/NickWaterton/Roomba980-Python)\n+- Dorita980 by Facu ZAK (https://github.com/koalazak/dorita980)\n+\n+## Supported Things\n+\n+- iRobot Roomba robotic vacuum cleaner (https://www.irobot.com/roomba). The binding has been developed and tested with Roomba 930.\n+- iRobot Braava has also been reported to work except Braava-specific cycles and automatic password retrieval.\n+\n+## Discovery\n+\n+Roombas on current network will be discovered automatically, however in order to connect to them a password is needed. The", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a38f97cb3c7d7e3e94161bfaed485b4de24f498b"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NzI2MzM3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.irobot/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMDoyMDoyOFrOHlPe0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMDoyMDoyOFrOHlPe0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgxMzAwOA==", "bodyText": "This could be removed.", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r508813008", "createdAt": "2020-10-20T20:20:28Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.irobot/README.md", "diffHunk": "@@ -0,0 +1,154 @@\n+# iRobot binding\n+\n+This binding provides for integration of products by iRobot company (http://www.irobot.com/). It is currently developed to support Roomba 900\n+series robotic vacuum cleaner with built-in Wi-Fi module. The binding interfaces to the robot directly without any need for a dedicated MQTT server.\n+\n+The development starts with an abandoned draft by hkunh42 (http://github.com/hkuhn42/openhab2.roomba) and heavily uses the following\n+projects as a reference:\n+\n+- Roomba980-Python by Nick Waterton (http://github.com/NickWaterton/Roomba980-Python)\n+- Dorita980 by Facu ZAK (https://github.com/koalazak/dorita980)\n+\n+## Supported Things\n+\n+- iRobot Roomba robotic vacuum cleaner (https://www.irobot.com/roomba). The binding has been developed and tested with Roomba 930.\n+- iRobot Braava has also been reported to work except Braava-specific cycles and automatic password retrieval.\n+\n+## Discovery\n+\n+Roombas on current network will be discovered automatically, however in order to connect to them a password is needed. The\n+password is a machine-generated string, which is unfortunately not exposed by the original iRobot smartphone application, but\n+it can be downloaded from the robot itself. If no password is configured, the Thing enters \"CONFIGURATION PENDING\" state.\n+Now you need to perform authorization by pressing and holding the HOME button on your robot until it plays series of tones\n+(approximately 2 seconds). The Wi-Fi indicator on the robot will flash for 30 seconds, the binding should automatically\n+receive the password and go ONLINE.\n+\n+After you've done this procedure you can write the password somewhere in case if you need to reconfigure your binding. It's not\n+known, however, whether the password is eternal or can change during factory reset.\n+\n+## Binding Configuration\n+\n+There's no global configuration for this binding.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a38f97cb3c7d7e3e94161bfaed485b4de24f498b"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NzI3MjcxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.irobot/README.md", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMDoyMzoxMFrOHlPknA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQxMDo1Nzo1MVrOHntEOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgxNDQ5Mg==", "bodyText": "You could rename the Channel to \"bin_full\" and change the type to Switch.", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r508814492", "createdAt": "2020-10-20T20:23:10Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.irobot/README.md", "diffHunk": "@@ -0,0 +1,154 @@\n+# iRobot binding\n+\n+This binding provides for integration of products by iRobot company (http://www.irobot.com/). It is currently developed to support Roomba 900\n+series robotic vacuum cleaner with built-in Wi-Fi module. The binding interfaces to the robot directly without any need for a dedicated MQTT server.\n+\n+The development starts with an abandoned draft by hkunh42 (http://github.com/hkuhn42/openhab2.roomba) and heavily uses the following\n+projects as a reference:\n+\n+- Roomba980-Python by Nick Waterton (http://github.com/NickWaterton/Roomba980-Python)\n+- Dorita980 by Facu ZAK (https://github.com/koalazak/dorita980)\n+\n+## Supported Things\n+\n+- iRobot Roomba robotic vacuum cleaner (https://www.irobot.com/roomba). The binding has been developed and tested with Roomba 930.\n+- iRobot Braava has also been reported to work except Braava-specific cycles and automatic password retrieval.\n+\n+## Discovery\n+\n+Roombas on current network will be discovered automatically, however in order to connect to them a password is needed. The\n+password is a machine-generated string, which is unfortunately not exposed by the original iRobot smartphone application, but\n+it can be downloaded from the robot itself. If no password is configured, the Thing enters \"CONFIGURATION PENDING\" state.\n+Now you need to perform authorization by pressing and holding the HOME button on your robot until it plays series of tones\n+(approximately 2 seconds). The Wi-Fi indicator on the robot will flash for 30 seconds, the binding should automatically\n+receive the password and go ONLINE.\n+\n+After you've done this procedure you can write the password somewhere in case if you need to reconfigure your binding. It's not\n+known, however, whether the password is eternal or can change during factory reset.\n+\n+## Binding Configuration\n+\n+There's no global configuration for this binding.\n+\n+## Thing Configuration\n+\n+\n+| Parameter | Meaning                                |\n+|-----------|----------------------------------------|\n+| ipaddress | IP address (or hostname) of your robot |\n+| password  | Password for the robot                 |\n+\n+## Channels\n+\n+| channel       | type   | description                                        | Read-only |\n+|---------------|--------|----------------------------------------------------|-----------|\n+| command       | String | Command to execute: clean, spot, dock, pause, stop | N |\n+| cycle         | String | Current mission: none, clean, spot                 | Y |\n+| phase         | String | Current phase of the mission; see below.           | Y |\n+| battery       | Number | Battery charge in percents                         | Y |\n+| bin           | String | Bin status: ok, removed, full                      | Y |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a38f97cb3c7d7e3e94161bfaed485b4de24f498b"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM5MTU2NQ==", "bodyText": "It's tristate, with mutually exclusive states. The bin cannot be both removed and full. I am following original smartphone app's semantics here. Are you mandating this change ?", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r511391565", "createdAt": "2020-10-24T10:50:19Z", "author": {"login": "Sonic-Amiga"}, "path": "bundles/org.openhab.binding.irobot/README.md", "diffHunk": "@@ -0,0 +1,154 @@\n+# iRobot binding\n+\n+This binding provides for integration of products by iRobot company (http://www.irobot.com/). It is currently developed to support Roomba 900\n+series robotic vacuum cleaner with built-in Wi-Fi module. The binding interfaces to the robot directly without any need for a dedicated MQTT server.\n+\n+The development starts with an abandoned draft by hkunh42 (http://github.com/hkuhn42/openhab2.roomba) and heavily uses the following\n+projects as a reference:\n+\n+- Roomba980-Python by Nick Waterton (http://github.com/NickWaterton/Roomba980-Python)\n+- Dorita980 by Facu ZAK (https://github.com/koalazak/dorita980)\n+\n+## Supported Things\n+\n+- iRobot Roomba robotic vacuum cleaner (https://www.irobot.com/roomba). The binding has been developed and tested with Roomba 930.\n+- iRobot Braava has also been reported to work except Braava-specific cycles and automatic password retrieval.\n+\n+## Discovery\n+\n+Roombas on current network will be discovered automatically, however in order to connect to them a password is needed. The\n+password is a machine-generated string, which is unfortunately not exposed by the original iRobot smartphone application, but\n+it can be downloaded from the robot itself. If no password is configured, the Thing enters \"CONFIGURATION PENDING\" state.\n+Now you need to perform authorization by pressing and holding the HOME button on your robot until it plays series of tones\n+(approximately 2 seconds). The Wi-Fi indicator on the robot will flash for 30 seconds, the binding should automatically\n+receive the password and go ONLINE.\n+\n+After you've done this procedure you can write the password somewhere in case if you need to reconfigure your binding. It's not\n+known, however, whether the password is eternal or can change during factory reset.\n+\n+## Binding Configuration\n+\n+There's no global configuration for this binding.\n+\n+## Thing Configuration\n+\n+\n+| Parameter | Meaning                                |\n+|-----------|----------------------------------------|\n+| ipaddress | IP address (or hostname) of your robot |\n+| password  | Password for the robot                 |\n+\n+## Channels\n+\n+| channel       | type   | description                                        | Read-only |\n+|---------------|--------|----------------------------------------------------|-----------|\n+| command       | String | Command to execute: clean, spot, dock, pause, stop | N |\n+| cycle         | String | Current mission: none, clean, spot                 | Y |\n+| phase         | String | Current phase of the mission; see below.           | Y |\n+| battery       | Number | Battery charge in percents                         | Y |\n+| bin           | String | Bin status: ok, removed, full                      | Y |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgxNDQ5Mg=="}, "originalCommit": {"oid": "a38f97cb3c7d7e3e94161bfaed485b4de24f498b"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM5NDg3Mg==", "bodyText": "Sorry, for some reason I overlooked the \"removed\". Please ignore my comment.", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r511394872", "createdAt": "2020-10-24T10:57:51Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.irobot/README.md", "diffHunk": "@@ -0,0 +1,154 @@\n+# iRobot binding\n+\n+This binding provides for integration of products by iRobot company (http://www.irobot.com/). It is currently developed to support Roomba 900\n+series robotic vacuum cleaner with built-in Wi-Fi module. The binding interfaces to the robot directly without any need for a dedicated MQTT server.\n+\n+The development starts with an abandoned draft by hkunh42 (http://github.com/hkuhn42/openhab2.roomba) and heavily uses the following\n+projects as a reference:\n+\n+- Roomba980-Python by Nick Waterton (http://github.com/NickWaterton/Roomba980-Python)\n+- Dorita980 by Facu ZAK (https://github.com/koalazak/dorita980)\n+\n+## Supported Things\n+\n+- iRobot Roomba robotic vacuum cleaner (https://www.irobot.com/roomba). The binding has been developed and tested with Roomba 930.\n+- iRobot Braava has also been reported to work except Braava-specific cycles and automatic password retrieval.\n+\n+## Discovery\n+\n+Roombas on current network will be discovered automatically, however in order to connect to them a password is needed. The\n+password is a machine-generated string, which is unfortunately not exposed by the original iRobot smartphone application, but\n+it can be downloaded from the robot itself. If no password is configured, the Thing enters \"CONFIGURATION PENDING\" state.\n+Now you need to perform authorization by pressing and holding the HOME button on your robot until it plays series of tones\n+(approximately 2 seconds). The Wi-Fi indicator on the robot will flash for 30 seconds, the binding should automatically\n+receive the password and go ONLINE.\n+\n+After you've done this procedure you can write the password somewhere in case if you need to reconfigure your binding. It's not\n+known, however, whether the password is eternal or can change during factory reset.\n+\n+## Binding Configuration\n+\n+There's no global configuration for this binding.\n+\n+## Thing Configuration\n+\n+\n+| Parameter | Meaning                                |\n+|-----------|----------------------------------------|\n+| ipaddress | IP address (or hostname) of your robot |\n+| password  | Password for the robot                 |\n+\n+## Channels\n+\n+| channel       | type   | description                                        | Read-only |\n+|---------------|--------|----------------------------------------------------|-----------|\n+| command       | String | Command to execute: clean, spot, dock, pause, stop | N |\n+| cycle         | String | Current mission: none, clean, spot                 | Y |\n+| phase         | String | Current phase of the mission; see below.           | Y |\n+| battery       | Number | Battery charge in percents                         | Y |\n+| bin           | String | Bin status: ok, removed, full                      | Y |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgxNDQ5Mg=="}, "originalCommit": {"oid": "a38f97cb3c7d7e3e94161bfaed485b4de24f498b"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NzI3OTE4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.irobot/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMDoyNDo0MlrOHlPorw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMDoyNDo0MlrOHlPorw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgxNTUzNQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            3. Roomba's built-in MQTT server, used for communication, supports only a single local connection at a time. Bear this in mind when you want to do something that requires local connection from your phone, like reconfiguring the network. Disable OpenHAB Thing before doing this.\n          \n          \n            \n            3. Roomba's built-in MQTT server, used for communication, supports only a single local connection at a time. Bear this in mind when you want to do something that requires local connection from your phone, like reconfiguring the network. Disable openHAB Thing before doing this.", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r508815535", "createdAt": "2020-10-20T20:24:42Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.irobot/README.md", "diffHunk": "@@ -0,0 +1,154 @@\n+# iRobot binding\n+\n+This binding provides for integration of products by iRobot company (http://www.irobot.com/). It is currently developed to support Roomba 900\n+series robotic vacuum cleaner with built-in Wi-Fi module. The binding interfaces to the robot directly without any need for a dedicated MQTT server.\n+\n+The development starts with an abandoned draft by hkunh42 (http://github.com/hkuhn42/openhab2.roomba) and heavily uses the following\n+projects as a reference:\n+\n+- Roomba980-Python by Nick Waterton (http://github.com/NickWaterton/Roomba980-Python)\n+- Dorita980 by Facu ZAK (https://github.com/koalazak/dorita980)\n+\n+## Supported Things\n+\n+- iRobot Roomba robotic vacuum cleaner (https://www.irobot.com/roomba). The binding has been developed and tested with Roomba 930.\n+- iRobot Braava has also been reported to work except Braava-specific cycles and automatic password retrieval.\n+\n+## Discovery\n+\n+Roombas on current network will be discovered automatically, however in order to connect to them a password is needed. The\n+password is a machine-generated string, which is unfortunately not exposed by the original iRobot smartphone application, but\n+it can be downloaded from the robot itself. If no password is configured, the Thing enters \"CONFIGURATION PENDING\" state.\n+Now you need to perform authorization by pressing and holding the HOME button on your robot until it plays series of tones\n+(approximately 2 seconds). The Wi-Fi indicator on the robot will flash for 30 seconds, the binding should automatically\n+receive the password and go ONLINE.\n+\n+After you've done this procedure you can write the password somewhere in case if you need to reconfigure your binding. It's not\n+known, however, whether the password is eternal or can change during factory reset.\n+\n+## Binding Configuration\n+\n+There's no global configuration for this binding.\n+\n+## Thing Configuration\n+\n+\n+| Parameter | Meaning                                |\n+|-----------|----------------------------------------|\n+| ipaddress | IP address (or hostname) of your robot |\n+| password  | Password for the robot                 |\n+\n+## Channels\n+\n+| channel       | type   | description                                        | Read-only |\n+|---------------|--------|----------------------------------------------------|-----------|\n+| command       | String | Command to execute: clean, spot, dock, pause, stop | N |\n+| cycle         | String | Current mission: none, clean, spot                 | Y |\n+| phase         | String | Current phase of the mission; see below.           | Y |\n+| battery       | Number | Battery charge in percents                         | Y |\n+| bin           | String | Bin status: ok, removed, full                      | Y |\n+| error         | String | Error code; see below                              | Y |\n+| rssi          | Number | Wi-Fi Received Signal Strength indicator in db     | Y |\n+| snr           | Number | Wi-Fi Signal to noise ratio                        | Y |\n+| sched_mon     | Switch | Scheduled clean enabled for Monday                 | N |\n+| sched_tue     | Switch | Scheduled clean enabled for Tuesday                | N |\n+| sched_wed     | Switch | Scheduled clean enabled for Wednesday              | N |\n+| sched_thu     | Switch | Scheduled clean enabled for Thursday               | N |\n+| sched_fri     | Switch | Scheduled clean enabled for Friday                 | N |\n+| sched_sat     | Switch | Scheduled clean enabled for Saturday               | N |\n+| sched_sun     | Switch | Scheduled clean enabled for Sunday                 | N |\n+| schedule      | Number | Schedule bitmask for use in scripts. 7 bits, bit #0 corresponds to Sunday | N |\n+| edge_clean    | Switch | Seek out and clean along walls and furniture legs  | N |\n+| always_finish | Switch | Whether to keep cleaning if the bin becomes full   | N |\n+| power_boost   | String | Power boost mode: \"auto\", \"performance\", \"eco\"     | N |\n+| clean_passes  | String | Number of cleaning passes: \"auto\", \"1\", \"2\"        | N |\n+\n+Known phase strings and their meanings:\n+\n+| phase     | Meaning                           |\n+|-----------|-----------------------------------|\n+| charge    | Charging                          |\n+| new       | New Mission (*)                   |\n+| run       | Running                           |\n+| resume    | Resumed (*)                       |\n+| hmMidMsn  | Going for recharge during mission |\n+| recharge  | Recharging                        |\n+| stuck     | Stuck                             |\n+| mUsrDock  | Going home (on user command)      |\n+| dock      | Docking (*)                       |\n+| dockend   | Docking - End Mission (*)         |\n+| cancelled | Cancelled (*)                     |\n+| stop      | Stopped                           |\n+| pause     | Paused (*)                        |\n+| hmPostMsn | Going home after mission          |\n+| \"\" (empty string) | None (*)                  |\n+\n+Phases, marked with asterisk (*), have not been seen being reported by Roomba 930. All the definitions\n+are taken from Roomba980-Python.\n+\n+Error codes. Data type is string in order to be able to utilize mapping to human-readable strings.\n+\n+| Code | Meaning                    |\n+|------|----------------------------|\n+| 0    | None                       |\n+| 1    | Left wheel off floor       |\n+| 2    | Main Brushes stuck    |\n+| 3    | Right wheel off floor      |\n+| 4    | Left wheel stuck    |\n+| 5    | Right wheel stuck    |\n+| 6    | Stuck near a cliff    |\n+| 7    | Left wheel error    |\n+| 8    | Bin error    |\n+| 9    | Bumper stuck    |\n+| 10    | Right wheel error    |\n+| 11    | Bin error    |\n+| 12    | Cliff sensor issue    |\n+| 13    | Both wheels off floor    |\n+| 14    | Bin missing    |\n+| 15    | Reboot required    |\n+| 16    | Bumped unexpectedly    |\n+| 17    | Path blocked    |\n+| 18    | Docking issue    |\n+| 19    | Undocking issue    |\n+| 20    | Docking issue    |\n+| 21    | Navigation problem    |\n+| 22    | Navigation problem    | \n+| 23    | Battery issue    |\n+| 24    | Navigation problem    |\n+| 25    | Reboot required    |\n+| 26    | Vacuum problem    |\n+| 27    | Vacuum problem    |\n+| 29    | Software update needed    |\n+| 30    | Vacuum problem    |\n+| 31    | Reboot required    |\n+| 32    | Smart map problem    |\n+| 33    | Path blocked    |\n+| 34    | Reboot required    |\n+| 35    | Unrecognized cleaning pad |\n+| 36    | Bin full    |\n+| 37    | Tank needed refilling    |\n+| 38    | Vacuum problem    |\n+| 39    | Reboot required    |\n+| 40    | Navigation problem    |\n+| 41    | Timed out    |\n+| 42    | Localization problem    |\n+| 43    | Navigation problem    |\n+| 44    | Pump issue    |\n+| 45    | Lid open    |\n+| 46    | Low battery    |\n+| 47    | Reboot required    |\n+| 48    | Path blocked              |\n+| 52    | Pad required attention    |\n+| 65    | Hardware problem detected |\n+| 66    | Low memory                |\n+| 68    | Hardware problem detected |\n+| 73    | Pad type changed          |\n+| 74    | Max area reached          |\n+| 75    | Navigation problem        |\n+| 76    | Hardware problem detected |\n+\n+NOTES:\n+\n+1. Sending \"pause\" command during missions other than \"clean\" is equivalent to sending \"stop\"\n+2. Switching to \"spot\" mission is possible only in \"stop\" state. Attempt to do it otherwise causes error: the command is rejected and error tones are played.\n+3. Roomba's built-in MQTT server, used for communication, supports only a single local connection at a time. Bear this in mind when you want to do something that requires local connection from your phone, like reconfiguring the network. Disable OpenHAB Thing before doing this.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a38f97cb3c7d7e3e94161bfaed485b4de24f498b"}, "originalPosition": 154}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NzI4MTU0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.irobot/README.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMDoyNTowOVrOHlPp5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQxMDo1MTozNlrOHns5hg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgxNTg0NQ==", "bodyText": "Can you add example configurations? See other bindings for reference.", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r508815845", "createdAt": "2020-10-20T20:25:09Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.irobot/README.md", "diffHunk": "@@ -0,0 +1,154 @@\n+# iRobot binding\n+\n+This binding provides for integration of products by iRobot company (http://www.irobot.com/). It is currently developed to support Roomba 900\n+series robotic vacuum cleaner with built-in Wi-Fi module. The binding interfaces to the robot directly without any need for a dedicated MQTT server.\n+\n+The development starts with an abandoned draft by hkunh42 (http://github.com/hkuhn42/openhab2.roomba) and heavily uses the following\n+projects as a reference:\n+\n+- Roomba980-Python by Nick Waterton (http://github.com/NickWaterton/Roomba980-Python)\n+- Dorita980 by Facu ZAK (https://github.com/koalazak/dorita980)\n+\n+## Supported Things\n+\n+- iRobot Roomba robotic vacuum cleaner (https://www.irobot.com/roomba). The binding has been developed and tested with Roomba 930.\n+- iRobot Braava has also been reported to work except Braava-specific cycles and automatic password retrieval.\n+\n+## Discovery\n+\n+Roombas on current network will be discovered automatically, however in order to connect to them a password is needed. The\n+password is a machine-generated string, which is unfortunately not exposed by the original iRobot smartphone application, but\n+it can be downloaded from the robot itself. If no password is configured, the Thing enters \"CONFIGURATION PENDING\" state.\n+Now you need to perform authorization by pressing and holding the HOME button on your robot until it plays series of tones\n+(approximately 2 seconds). The Wi-Fi indicator on the robot will flash for 30 seconds, the binding should automatically\n+receive the password and go ONLINE.\n+\n+After you've done this procedure you can write the password somewhere in case if you need to reconfigure your binding. It's not\n+known, however, whether the password is eternal or can change during factory reset.\n+\n+## Binding Configuration\n+\n+There's no global configuration for this binding.\n+\n+## Thing Configuration\n+\n+\n+| Parameter | Meaning                                |\n+|-----------|----------------------------------------|\n+| ipaddress | IP address (or hostname) of your robot |\n+| password  | Password for the robot                 |\n+\n+## Channels\n+\n+| channel       | type   | description                                        | Read-only |\n+|---------------|--------|----------------------------------------------------|-----------|\n+| command       | String | Command to execute: clean, spot, dock, pause, stop | N |\n+| cycle         | String | Current mission: none, clean, spot                 | Y |\n+| phase         | String | Current phase of the mission; see below.           | Y |\n+| battery       | Number | Battery charge in percents                         | Y |\n+| bin           | String | Bin status: ok, removed, full                      | Y |\n+| error         | String | Error code; see below                              | Y |\n+| rssi          | Number | Wi-Fi Received Signal Strength indicator in db     | Y |\n+| snr           | Number | Wi-Fi Signal to noise ratio                        | Y |\n+| sched_mon     | Switch | Scheduled clean enabled for Monday                 | N |\n+| sched_tue     | Switch | Scheduled clean enabled for Tuesday                | N |\n+| sched_wed     | Switch | Scheduled clean enabled for Wednesday              | N |\n+| sched_thu     | Switch | Scheduled clean enabled for Thursday               | N |\n+| sched_fri     | Switch | Scheduled clean enabled for Friday                 | N |\n+| sched_sat     | Switch | Scheduled clean enabled for Saturday               | N |\n+| sched_sun     | Switch | Scheduled clean enabled for Sunday                 | N |\n+| schedule      | Number | Schedule bitmask for use in scripts. 7 bits, bit #0 corresponds to Sunday | N |\n+| edge_clean    | Switch | Seek out and clean along walls and furniture legs  | N |\n+| always_finish | Switch | Whether to keep cleaning if the bin becomes full   | N |\n+| power_boost   | String | Power boost mode: \"auto\", \"performance\", \"eco\"     | N |\n+| clean_passes  | String | Number of cleaning passes: \"auto\", \"1\", \"2\"        | N |\n+\n+Known phase strings and their meanings:\n+\n+| phase     | Meaning                           |\n+|-----------|-----------------------------------|\n+| charge    | Charging                          |\n+| new       | New Mission (*)                   |\n+| run       | Running                           |\n+| resume    | Resumed (*)                       |\n+| hmMidMsn  | Going for recharge during mission |\n+| recharge  | Recharging                        |\n+| stuck     | Stuck                             |\n+| mUsrDock  | Going home (on user command)      |\n+| dock      | Docking (*)                       |\n+| dockend   | Docking - End Mission (*)         |\n+| cancelled | Cancelled (*)                     |\n+| stop      | Stopped                           |\n+| pause     | Paused (*)                        |\n+| hmPostMsn | Going home after mission          |\n+| \"\" (empty string) | None (*)                  |\n+\n+Phases, marked with asterisk (*), have not been seen being reported by Roomba 930. All the definitions\n+are taken from Roomba980-Python.\n+\n+Error codes. Data type is string in order to be able to utilize mapping to human-readable strings.\n+\n+| Code | Meaning                    |\n+|------|----------------------------|\n+| 0    | None                       |\n+| 1    | Left wheel off floor       |\n+| 2    | Main Brushes stuck    |\n+| 3    | Right wheel off floor      |\n+| 4    | Left wheel stuck    |\n+| 5    | Right wheel stuck    |\n+| 6    | Stuck near a cliff    |\n+| 7    | Left wheel error    |\n+| 8    | Bin error    |\n+| 9    | Bumper stuck    |\n+| 10    | Right wheel error    |\n+| 11    | Bin error    |\n+| 12    | Cliff sensor issue    |\n+| 13    | Both wheels off floor    |\n+| 14    | Bin missing    |\n+| 15    | Reboot required    |\n+| 16    | Bumped unexpectedly    |\n+| 17    | Path blocked    |\n+| 18    | Docking issue    |\n+| 19    | Undocking issue    |\n+| 20    | Docking issue    |\n+| 21    | Navigation problem    |\n+| 22    | Navigation problem    | \n+| 23    | Battery issue    |\n+| 24    | Navigation problem    |\n+| 25    | Reboot required    |\n+| 26    | Vacuum problem    |\n+| 27    | Vacuum problem    |\n+| 29    | Software update needed    |\n+| 30    | Vacuum problem    |\n+| 31    | Reboot required    |\n+| 32    | Smart map problem    |\n+| 33    | Path blocked    |\n+| 34    | Reboot required    |\n+| 35    | Unrecognized cleaning pad |\n+| 36    | Bin full    |\n+| 37    | Tank needed refilling    |\n+| 38    | Vacuum problem    |\n+| 39    | Reboot required    |\n+| 40    | Navigation problem    |\n+| 41    | Timed out    |\n+| 42    | Localization problem    |\n+| 43    | Navigation problem    |\n+| 44    | Pump issue    |\n+| 45    | Lid open    |\n+| 46    | Low battery    |\n+| 47    | Reboot required    |\n+| 48    | Path blocked              |\n+| 52    | Pad required attention    |\n+| 65    | Hardware problem detected |\n+| 66    | Low memory                |\n+| 68    | Hardware problem detected |\n+| 73    | Pad type changed          |\n+| 74    | Max area reached          |\n+| 75    | Navigation problem        |\n+| 76    | Hardware problem detected |\n+\n+NOTES:\n+\n+1. Sending \"pause\" command during missions other than \"clean\" is equivalent to sending \"stop\"\n+2. Switching to \"spot\" mission is possible only in \"stop\" state. Attempt to do it otherwise causes error: the command is rejected and error tones are played.\n+3. Roomba's built-in MQTT server, used for communication, supports only a single local connection at a time. Bear this in mind when you want to do something that requires local connection from your phone, like reconfiguring the network. Disable OpenHAB Thing before doing this.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a38f97cb3c7d7e3e94161bfaed485b4de24f498b"}, "originalPosition": 154}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM5MjEzNA==", "bodyText": "Ok, i will try to make something up, despite i don't have it myself because i don't use text configs, only PaperUI.", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r511392134", "createdAt": "2020-10-24T10:51:36Z", "author": {"login": "Sonic-Amiga"}, "path": "bundles/org.openhab.binding.irobot/README.md", "diffHunk": "@@ -0,0 +1,154 @@\n+# iRobot binding\n+\n+This binding provides for integration of products by iRobot company (http://www.irobot.com/). It is currently developed to support Roomba 900\n+series robotic vacuum cleaner with built-in Wi-Fi module. The binding interfaces to the robot directly without any need for a dedicated MQTT server.\n+\n+The development starts with an abandoned draft by hkunh42 (http://github.com/hkuhn42/openhab2.roomba) and heavily uses the following\n+projects as a reference:\n+\n+- Roomba980-Python by Nick Waterton (http://github.com/NickWaterton/Roomba980-Python)\n+- Dorita980 by Facu ZAK (https://github.com/koalazak/dorita980)\n+\n+## Supported Things\n+\n+- iRobot Roomba robotic vacuum cleaner (https://www.irobot.com/roomba). The binding has been developed and tested with Roomba 930.\n+- iRobot Braava has also been reported to work except Braava-specific cycles and automatic password retrieval.\n+\n+## Discovery\n+\n+Roombas on current network will be discovered automatically, however in order to connect to them a password is needed. The\n+password is a machine-generated string, which is unfortunately not exposed by the original iRobot smartphone application, but\n+it can be downloaded from the robot itself. If no password is configured, the Thing enters \"CONFIGURATION PENDING\" state.\n+Now you need to perform authorization by pressing and holding the HOME button on your robot until it plays series of tones\n+(approximately 2 seconds). The Wi-Fi indicator on the robot will flash for 30 seconds, the binding should automatically\n+receive the password and go ONLINE.\n+\n+After you've done this procedure you can write the password somewhere in case if you need to reconfigure your binding. It's not\n+known, however, whether the password is eternal or can change during factory reset.\n+\n+## Binding Configuration\n+\n+There's no global configuration for this binding.\n+\n+## Thing Configuration\n+\n+\n+| Parameter | Meaning                                |\n+|-----------|----------------------------------------|\n+| ipaddress | IP address (or hostname) of your robot |\n+| password  | Password for the robot                 |\n+\n+## Channels\n+\n+| channel       | type   | description                                        | Read-only |\n+|---------------|--------|----------------------------------------------------|-----------|\n+| command       | String | Command to execute: clean, spot, dock, pause, stop | N |\n+| cycle         | String | Current mission: none, clean, spot                 | Y |\n+| phase         | String | Current phase of the mission; see below.           | Y |\n+| battery       | Number | Battery charge in percents                         | Y |\n+| bin           | String | Bin status: ok, removed, full                      | Y |\n+| error         | String | Error code; see below                              | Y |\n+| rssi          | Number | Wi-Fi Received Signal Strength indicator in db     | Y |\n+| snr           | Number | Wi-Fi Signal to noise ratio                        | Y |\n+| sched_mon     | Switch | Scheduled clean enabled for Monday                 | N |\n+| sched_tue     | Switch | Scheduled clean enabled for Tuesday                | N |\n+| sched_wed     | Switch | Scheduled clean enabled for Wednesday              | N |\n+| sched_thu     | Switch | Scheduled clean enabled for Thursday               | N |\n+| sched_fri     | Switch | Scheduled clean enabled for Friday                 | N |\n+| sched_sat     | Switch | Scheduled clean enabled for Saturday               | N |\n+| sched_sun     | Switch | Scheduled clean enabled for Sunday                 | N |\n+| schedule      | Number | Schedule bitmask for use in scripts. 7 bits, bit #0 corresponds to Sunday | N |\n+| edge_clean    | Switch | Seek out and clean along walls and furniture legs  | N |\n+| always_finish | Switch | Whether to keep cleaning if the bin becomes full   | N |\n+| power_boost   | String | Power boost mode: \"auto\", \"performance\", \"eco\"     | N |\n+| clean_passes  | String | Number of cleaning passes: \"auto\", \"1\", \"2\"        | N |\n+\n+Known phase strings and their meanings:\n+\n+| phase     | Meaning                           |\n+|-----------|-----------------------------------|\n+| charge    | Charging                          |\n+| new       | New Mission (*)                   |\n+| run       | Running                           |\n+| resume    | Resumed (*)                       |\n+| hmMidMsn  | Going for recharge during mission |\n+| recharge  | Recharging                        |\n+| stuck     | Stuck                             |\n+| mUsrDock  | Going home (on user command)      |\n+| dock      | Docking (*)                       |\n+| dockend   | Docking - End Mission (*)         |\n+| cancelled | Cancelled (*)                     |\n+| stop      | Stopped                           |\n+| pause     | Paused (*)                        |\n+| hmPostMsn | Going home after mission          |\n+| \"\" (empty string) | None (*)                  |\n+\n+Phases, marked with asterisk (*), have not been seen being reported by Roomba 930. All the definitions\n+are taken from Roomba980-Python.\n+\n+Error codes. Data type is string in order to be able to utilize mapping to human-readable strings.\n+\n+| Code | Meaning                    |\n+|------|----------------------------|\n+| 0    | None                       |\n+| 1    | Left wheel off floor       |\n+| 2    | Main Brushes stuck    |\n+| 3    | Right wheel off floor      |\n+| 4    | Left wheel stuck    |\n+| 5    | Right wheel stuck    |\n+| 6    | Stuck near a cliff    |\n+| 7    | Left wheel error    |\n+| 8    | Bin error    |\n+| 9    | Bumper stuck    |\n+| 10    | Right wheel error    |\n+| 11    | Bin error    |\n+| 12    | Cliff sensor issue    |\n+| 13    | Both wheels off floor    |\n+| 14    | Bin missing    |\n+| 15    | Reboot required    |\n+| 16    | Bumped unexpectedly    |\n+| 17    | Path blocked    |\n+| 18    | Docking issue    |\n+| 19    | Undocking issue    |\n+| 20    | Docking issue    |\n+| 21    | Navigation problem    |\n+| 22    | Navigation problem    | \n+| 23    | Battery issue    |\n+| 24    | Navigation problem    |\n+| 25    | Reboot required    |\n+| 26    | Vacuum problem    |\n+| 27    | Vacuum problem    |\n+| 29    | Software update needed    |\n+| 30    | Vacuum problem    |\n+| 31    | Reboot required    |\n+| 32    | Smart map problem    |\n+| 33    | Path blocked    |\n+| 34    | Reboot required    |\n+| 35    | Unrecognized cleaning pad |\n+| 36    | Bin full    |\n+| 37    | Tank needed refilling    |\n+| 38    | Vacuum problem    |\n+| 39    | Reboot required    |\n+| 40    | Navigation problem    |\n+| 41    | Timed out    |\n+| 42    | Localization problem    |\n+| 43    | Navigation problem    |\n+| 44    | Pump issue    |\n+| 45    | Lid open    |\n+| 46    | Low battery    |\n+| 47    | Reboot required    |\n+| 48    | Path blocked              |\n+| 52    | Pad required attention    |\n+| 65    | Hardware problem detected |\n+| 66    | Low memory                |\n+| 68    | Hardware problem detected |\n+| 73    | Pad type changed          |\n+| 74    | Max area reached          |\n+| 75    | Navigation problem        |\n+| 76    | Hardware problem detected |\n+\n+NOTES:\n+\n+1. Sending \"pause\" command during missions other than \"clean\" is equivalent to sending \"stop\"\n+2. Switching to \"spot\" mission is possible only in \"stop\" state. Attempt to do it otherwise causes error: the command is rejected and error tones are played.\n+3. Roomba's built-in MQTT server, used for communication, supports only a single local connection at a time. Bear this in mind when you want to do something that requires local connection from your phone, like reconfiguring the network. Disable OpenHAB Thing before doing this.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgxNTg0NQ=="}, "originalCommit": {"oid": "a38f97cb3c7d7e3e94161bfaed485b4de24f498b"}, "originalPosition": 154}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NzI4NDEzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.irobot/src/main/feature/feature.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMDoyNTo0NVrOHlProA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMDoyNTo0NVrOHlProA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgxNjI4OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t<feature name=\"openhab-binding-irobot\" description=\"irobot Binding\" version=\"${project.version}\">\n          \n          \n            \n            \t<feature name=\"openhab-binding-irobot\" description=\"iRobot Binding\" version=\"${project.version}\">", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r508816288", "createdAt": "2020-10-20T20:25:45Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.irobot/src/main/feature/feature.xml", "diffHunk": "@@ -0,0 +1,25 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<!--\n+\n+\tCopyright (c) 2010-2020 Contributors to the openHAB project\n+\n+\tSee the NOTICE file(s) distributed with this work for additional\n+\tinformation.\n+\n+\tThis program and the accompanying materials are made available under the\n+\tterms of the Eclipse Public License 2.0 which is available at\n+\thttp://www.eclipse.org/legal/epl-2.0\n+\n+\tSPDX-License-Identifier: EPL-2.0\n+\n+-->\n+<features name=\"org.openhab.binding.irobot-${project.version}\" xmlns=\"http://karaf.apache.org/xmlns/features/v1.4.0\">\n+\t<repository>mvn:org.openhab.core.features.karaf/org.openhab.core.features.karaf.openhab-core/${ohc.version}/xml/features</repository>\n+\n+\t<feature name=\"openhab-binding-irobot\" description=\"irobot Binding\" version=\"${project.version}\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a38f97cb3c7d7e3e94161bfaed485b4de24f498b"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NzI5Njc4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.irobot/README.md", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMDoyODoyM1rOHlPzPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQxMjoxODo0MlrOHnu7ew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgxODIzNw==", "bodyText": "Can you add the ThingTypeID?", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r508818237", "createdAt": "2020-10-20T20:28:23Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.irobot/README.md", "diffHunk": "@@ -0,0 +1,154 @@\n+# iRobot binding\n+\n+This binding provides for integration of products by iRobot company (http://www.irobot.com/). It is currently developed to support Roomba 900\n+series robotic vacuum cleaner with built-in Wi-Fi module. The binding interfaces to the robot directly without any need for a dedicated MQTT server.\n+\n+The development starts with an abandoned draft by hkunh42 (http://github.com/hkuhn42/openhab2.roomba) and heavily uses the following\n+projects as a reference:\n+\n+- Roomba980-Python by Nick Waterton (http://github.com/NickWaterton/Roomba980-Python)\n+- Dorita980 by Facu ZAK (https://github.com/koalazak/dorita980)\n+\n+## Supported Things\n+\n+- iRobot Roomba robotic vacuum cleaner (https://www.irobot.com/roomba). The binding has been developed and tested with Roomba 930.\n+- iRobot Braava has also been reported to work except Braava-specific cycles and automatic password retrieval.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a38f97cb3c7d7e3e94161bfaed485b4de24f498b"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM5MTA5OA==", "bodyText": "No, sorry. In fact Braava works by being manually added as Roomba. Of course this implies that Braava-specific functionality is not supported. Unfortunately i cannot easily add it now because i don't own Braava and i don't have its identification details.\nI could contact its user and ask him to retrieve some logs, but it will mean further development, it will take more time. Can we proceed without it ?\nOr i can remove Braava mentioning if you think it's inappropriate.", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r511391098", "createdAt": "2020-10-24T10:48:54Z", "author": {"login": "Sonic-Amiga"}, "path": "bundles/org.openhab.binding.irobot/README.md", "diffHunk": "@@ -0,0 +1,154 @@\n+# iRobot binding\n+\n+This binding provides for integration of products by iRobot company (http://www.irobot.com/). It is currently developed to support Roomba 900\n+series robotic vacuum cleaner with built-in Wi-Fi module. The binding interfaces to the robot directly without any need for a dedicated MQTT server.\n+\n+The development starts with an abandoned draft by hkunh42 (http://github.com/hkuhn42/openhab2.roomba) and heavily uses the following\n+projects as a reference:\n+\n+- Roomba980-Python by Nick Waterton (http://github.com/NickWaterton/Roomba980-Python)\n+- Dorita980 by Facu ZAK (https://github.com/koalazak/dorita980)\n+\n+## Supported Things\n+\n+- iRobot Roomba robotic vacuum cleaner (https://www.irobot.com/roomba). The binding has been developed and tested with Roomba 930.\n+- iRobot Braava has also been reported to work except Braava-specific cycles and automatic password retrieval.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgxODIzNw=="}, "originalCommit": {"oid": "a38f97cb3c7d7e3e94161bfaed485b4de24f498b"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM5Mzc2Nw==", "bodyText": "You could mention the Roomba ThingTypeID and that it's the same for Braava with caveat.", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r511393767", "createdAt": "2020-10-24T10:55:22Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.irobot/README.md", "diffHunk": "@@ -0,0 +1,154 @@\n+# iRobot binding\n+\n+This binding provides for integration of products by iRobot company (http://www.irobot.com/). It is currently developed to support Roomba 900\n+series robotic vacuum cleaner with built-in Wi-Fi module. The binding interfaces to the robot directly without any need for a dedicated MQTT server.\n+\n+The development starts with an abandoned draft by hkunh42 (http://github.com/hkuhn42/openhab2.roomba) and heavily uses the following\n+projects as a reference:\n+\n+- Roomba980-Python by Nick Waterton (http://github.com/NickWaterton/Roomba980-Python)\n+- Dorita980 by Facu ZAK (https://github.com/koalazak/dorita980)\n+\n+## Supported Things\n+\n+- iRobot Roomba robotic vacuum cleaner (https://www.irobot.com/roomba). The binding has been developed and tested with Roomba 930.\n+- iRobot Braava has also been reported to work except Braava-specific cycles and automatic password retrieval.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgxODIzNw=="}, "originalCommit": {"oid": "a38f97cb3c7d7e3e94161bfaed485b4de24f498b"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTQyNTQwMw==", "bodyText": "Updated the description by noting this explicitly, hope you'll like it.", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r511425403", "createdAt": "2020-10-24T12:18:42Z", "author": {"login": "Sonic-Amiga"}, "path": "bundles/org.openhab.binding.irobot/README.md", "diffHunk": "@@ -0,0 +1,154 @@\n+# iRobot binding\n+\n+This binding provides for integration of products by iRobot company (http://www.irobot.com/). It is currently developed to support Roomba 900\n+series robotic vacuum cleaner with built-in Wi-Fi module. The binding interfaces to the robot directly without any need for a dedicated MQTT server.\n+\n+The development starts with an abandoned draft by hkunh42 (http://github.com/hkuhn42/openhab2.roomba) and heavily uses the following\n+projects as a reference:\n+\n+- Roomba980-Python by Nick Waterton (http://github.com/NickWaterton/Roomba980-Python)\n+- Dorita980 by Facu ZAK (https://github.com/koalazak/dorita980)\n+\n+## Supported Things\n+\n+- iRobot Roomba robotic vacuum cleaner (https://www.irobot.com/roomba). The binding has been developed and tested with Roomba 930.\n+- iRobot Braava has also been reported to work except Braava-specific cycles and automatic password retrieval.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgxODIzNw=="}, "originalCommit": {"oid": "a38f97cb3c7d7e3e94161bfaed485b4de24f498b"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NzI5OTMzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/discovery/IRobotDiscoveryService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMDoyOToxMVrOHlP0yQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQxMDo1MjoyNFrOHns66Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgxODYzMw==", "bodyText": "Please remove the email adress.", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r508818633", "createdAt": "2020-10-20T20:29:11Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/discovery/IRobotDiscoveryService.java", "diffHunk": "@@ -0,0 +1,167 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.discovery;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.json.JSONException;\n+import org.openhab.binding.irobot.IRobotBindingConstants;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.net.NetUtil;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Discovery service for iRobot's\n+ *\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Initial contribution", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a38f97cb3c7d7e3e94161bfaed485b4de24f498b"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM5MjQ4OQ==", "bodyText": "ACK", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r511392489", "createdAt": "2020-10-24T10:52:24Z", "author": {"login": "Sonic-Amiga"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/discovery/IRobotDiscoveryService.java", "diffHunk": "@@ -0,0 +1,167 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.discovery;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.json.JSONException;\n+import org.openhab.binding.irobot.IRobotBindingConstants;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.net.NetUtil;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Discovery service for iRobot's\n+ *\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Initial contribution", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgxODYzMw=="}, "originalCommit": {"oid": "a38f97cb3c7d7e3e94161bfaed485b4de24f498b"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NzMwMDAyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/discovery/IRobotDiscoveryService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMDoyOToyMlrOHlP1Mw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMDoyOToyMlrOHlP1Mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgxODczOQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Discovery service for iRobot's\n          \n          \n            \n             * Discovery service for iRobots", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r508818739", "createdAt": "2020-10-20T20:29:22Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/discovery/IRobotDiscoveryService.java", "diffHunk": "@@ -0,0 +1,167 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.discovery;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.json.JSONException;\n+import org.openhab.binding.irobot.IRobotBindingConstants;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.net.NetUtil;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Discovery service for iRobot's", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a38f97cb3c7d7e3e94161bfaed485b4de24f498b"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NzMwMzY5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/discovery/IRobotDiscoveryService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMDozMDoyMFrOHlP3Ww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQxMDo1NToxMVrOHns_pg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgxOTI5MQ==", "bodyText": "Can this message be replaced by using the debugger or by increasing the framework's log level? See point 4 https://www.openhab.org/docs/developer/guidelines.html#f-logging", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r508819291", "createdAt": "2020-10-20T20:30:20Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/discovery/IRobotDiscoveryService.java", "diffHunk": "@@ -0,0 +1,167 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.discovery;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.json.JSONException;\n+import org.openhab.binding.irobot.IRobotBindingConstants;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.net.NetUtil;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Discovery service for iRobot's\n+ *\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Initial contribution\n+ *\n+ */\n+@Component(service = DiscoveryService.class)\n+@NonNullByDefault\n+public class IRobotDiscoveryService extends AbstractDiscoveryService {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IRobotDiscoveryService.class);\n+    private final Runnable scanner;\n+    private @Nullable ScheduledFuture<?> backgroundFuture;\n+\n+    public IRobotDiscoveryService() {\n+        super(Collections.singleton(IRobotBindingConstants.THING_TYPE_ROOMBA), 30, true);\n+        scanner = createScanner();\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.trace(\"Starting background discovery\");\n+        stopBackgroundScan();\n+        backgroundFuture = scheduler.scheduleWithFixedDelay(scanner, 0, 60, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        logger.trace(\"Stopping background discovery\");\n+        stopBackgroundScan();\n+        super.stopBackgroundDiscovery();\n+    }\n+\n+    private void stopBackgroundScan() {\n+        ScheduledFuture<?> scan = backgroundFuture;\n+\n+        if (scan != null && !scan.isDone()) {\n+            scan.cancel(true);\n+            backgroundFuture = null;\n+        }\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.trace(\"startScan\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a38f97cb3c7d7e3e94161bfaed485b4de24f498b"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM5MzcwMg==", "bodyText": "Yes, i remember this. To tell the truth i don't know framework's own logging facilities, and there could be tons of other output there, so for debugging it's just easier to have this here. And this line does not produce a lot of output, it's triggered only on startup. Also it helps to make sure that everything is OK on user's side, you can simply ask to crank up your binding logs to TRACE.\nBut, OK, i'll remove it because this is the requirement.", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r511393702", "createdAt": "2020-10-24T10:55:11Z", "author": {"login": "Sonic-Amiga"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/discovery/IRobotDiscoveryService.java", "diffHunk": "@@ -0,0 +1,167 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.discovery;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.json.JSONException;\n+import org.openhab.binding.irobot.IRobotBindingConstants;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.net.NetUtil;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Discovery service for iRobot's\n+ *\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Initial contribution\n+ *\n+ */\n+@Component(service = DiscoveryService.class)\n+@NonNullByDefault\n+public class IRobotDiscoveryService extends AbstractDiscoveryService {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IRobotDiscoveryService.class);\n+    private final Runnable scanner;\n+    private @Nullable ScheduledFuture<?> backgroundFuture;\n+\n+    public IRobotDiscoveryService() {\n+        super(Collections.singleton(IRobotBindingConstants.THING_TYPE_ROOMBA), 30, true);\n+        scanner = createScanner();\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.trace(\"Starting background discovery\");\n+        stopBackgroundScan();\n+        backgroundFuture = scheduler.scheduleWithFixedDelay(scanner, 0, 60, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        logger.trace(\"Stopping background discovery\");\n+        stopBackgroundScan();\n+        super.stopBackgroundDiscovery();\n+    }\n+\n+    private void stopBackgroundScan() {\n+        ScheduledFuture<?> scan = backgroundFuture;\n+\n+        if (scan != null && !scan.isDone()) {\n+            scan.cancel(true);\n+            backgroundFuture = null;\n+        }\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.trace(\"startScan\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgxOTI5MQ=="}, "originalCommit": {"oid": "a38f97cb3c7d7e3e94161bfaed485b4de24f498b"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NzMwNTAwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/discovery/IRobotDiscoveryService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMDozMDo0M1rOHlP4LA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMDozMDo0M1rOHlP4LA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgxOTUwMA==", "bodyText": "No harm in canceling a task that is already cancelled.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (scan != null && !scan.isDone()) {\n          \n          \n            \n                    if (scan != null) {", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r508819500", "createdAt": "2020-10-20T20:30:43Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/discovery/IRobotDiscoveryService.java", "diffHunk": "@@ -0,0 +1,167 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.discovery;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.json.JSONException;\n+import org.openhab.binding.irobot.IRobotBindingConstants;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.net.NetUtil;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Discovery service for iRobot's\n+ *\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Initial contribution\n+ *\n+ */\n+@Component(service = DiscoveryService.class)\n+@NonNullByDefault\n+public class IRobotDiscoveryService extends AbstractDiscoveryService {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IRobotDiscoveryService.class);\n+    private final Runnable scanner;\n+    private @Nullable ScheduledFuture<?> backgroundFuture;\n+\n+    public IRobotDiscoveryService() {\n+        super(Collections.singleton(IRobotBindingConstants.THING_TYPE_ROOMBA), 30, true);\n+        scanner = createScanner();\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.trace(\"Starting background discovery\");\n+        stopBackgroundScan();\n+        backgroundFuture = scheduler.scheduleWithFixedDelay(scanner, 0, 60, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        logger.trace(\"Stopping background discovery\");\n+        stopBackgroundScan();\n+        super.stopBackgroundDiscovery();\n+    }\n+\n+    private void stopBackgroundScan() {\n+        ScheduledFuture<?> scan = backgroundFuture;\n+\n+        if (scan != null && !scan.isDone()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a38f97cb3c7d7e3e94161bfaed485b4de24f498b"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMDg4NDAwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/discovery/IRobotDiscoveryService.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNTo0MDo0MFrOHnTUzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxNToyNzoxN1rOHuyjCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk3MzEzMg==", "bodyText": "Are you logging the stack trace by intention? Also, network errors should be treated as expected behavior, so this could be debug.", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r510973132", "createdAt": "2020-10-23T15:40:40Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/discovery/IRobotDiscoveryService.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.discovery;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.IRobotBindingConstants;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.net.NetUtil;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * Discovery service for iRobot's\n+ *\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Initial contribution\n+ *\n+ */\n+@Component(service = DiscoveryService.class)\n+@NonNullByDefault\n+public class IRobotDiscoveryService extends AbstractDiscoveryService {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IRobotDiscoveryService.class);\n+    private final Runnable scanner;\n+    private @Nullable ScheduledFuture<?> backgroundFuture;\n+\n+    public IRobotDiscoveryService() {\n+        super(Collections.singleton(IRobotBindingConstants.THING_TYPE_ROOMBA), 30, true);\n+        scanner = createScanner();\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.trace(\"Starting background discovery\");\n+        stopBackgroundScan();\n+        backgroundFuture = scheduler.scheduleWithFixedDelay(scanner, 0, 60, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        logger.trace(\"Stopping background discovery\");\n+        stopBackgroundScan();\n+        super.stopBackgroundDiscovery();\n+    }\n+\n+    private void stopBackgroundScan() {\n+        ScheduledFuture<?> scan = backgroundFuture;\n+\n+        if (scan != null && !scan.isDone()) {\n+            scan.cancel(true);\n+            backgroundFuture = null;\n+        }\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.trace(\"startScan\");\n+        scheduler.execute(scanner);\n+    }\n+\n+    private Runnable createScanner() {\n+        return () -> {\n+            long timestampOfLastScan = getTimestampOfLastScan();\n+            for (InetAddress broadcastAddress : getBroadcastAddresses()) {\n+                logger.debug(\"Starting broadcast for {}\", broadcastAddress.toString());\n+\n+                DatagramSocket socket;\n+                try {\n+                    socket = IdentProtocol.sendRequest(broadcastAddress);\n+                    while (receivePacketAndDiscover(socket)) {\n+                    }\n+                } catch (IOException e) {\n+                    logger.warn(\"Error sending broadcast: {}\", e.toString());\n+                }\n+            }\n+\n+            removeOlderResults(timestampOfLastScan);\n+        };\n+    }\n+\n+    private List<InetAddress> getBroadcastAddresses() {\n+        ArrayList<InetAddress> addresses = new ArrayList<>();\n+\n+        for (String broadcastAddress : NetUtil.getAllBroadcastAddresses()) {\n+            try {\n+                addresses.add(InetAddress.getByName(broadcastAddress));\n+            } catch (UnknownHostException e) {\n+                logger.warn(\"Error broadcasting to {}\", broadcastAddress, e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9674556c16225cbbe635a06414cbf94eda1ea4c"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM5NTM2MA==", "bodyText": "In formatting an exception via {} doesn't dump the full trace on my side, just the message\nThe address is supposed to be raw IP, not a hostname, like 192.168.0.255. Getting UnknownHost on it would be totally strange, some internal system error. I wrote it here only because the IDE forces me to do so.\nI will add the comment in the code.", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r511395360", "createdAt": "2020-10-24T10:59:03Z", "author": {"login": "Sonic-Amiga"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/discovery/IRobotDiscoveryService.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.discovery;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.IRobotBindingConstants;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.net.NetUtil;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * Discovery service for iRobot's\n+ *\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Initial contribution\n+ *\n+ */\n+@Component(service = DiscoveryService.class)\n+@NonNullByDefault\n+public class IRobotDiscoveryService extends AbstractDiscoveryService {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IRobotDiscoveryService.class);\n+    private final Runnable scanner;\n+    private @Nullable ScheduledFuture<?> backgroundFuture;\n+\n+    public IRobotDiscoveryService() {\n+        super(Collections.singleton(IRobotBindingConstants.THING_TYPE_ROOMBA), 30, true);\n+        scanner = createScanner();\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.trace(\"Starting background discovery\");\n+        stopBackgroundScan();\n+        backgroundFuture = scheduler.scheduleWithFixedDelay(scanner, 0, 60, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        logger.trace(\"Stopping background discovery\");\n+        stopBackgroundScan();\n+        super.stopBackgroundDiscovery();\n+    }\n+\n+    private void stopBackgroundScan() {\n+        ScheduledFuture<?> scan = backgroundFuture;\n+\n+        if (scan != null && !scan.isDone()) {\n+            scan.cancel(true);\n+            backgroundFuture = null;\n+        }\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.trace(\"startScan\");\n+        scheduler.execute(scanner);\n+    }\n+\n+    private Runnable createScanner() {\n+        return () -> {\n+            long timestampOfLastScan = getTimestampOfLastScan();\n+            for (InetAddress broadcastAddress : getBroadcastAddresses()) {\n+                logger.debug(\"Starting broadcast for {}\", broadcastAddress.toString());\n+\n+                DatagramSocket socket;\n+                try {\n+                    socket = IdentProtocol.sendRequest(broadcastAddress);\n+                    while (receivePacketAndDiscover(socket)) {\n+                    }\n+                } catch (IOException e) {\n+                    logger.warn(\"Error sending broadcast: {}\", e.toString());\n+                }\n+            }\n+\n+            removeOlderResults(timestampOfLastScan);\n+        };\n+    }\n+\n+    private List<InetAddress> getBroadcastAddresses() {\n+        ArrayList<InetAddress> addresses = new ArrayList<>();\n+\n+        for (String broadcastAddress : NetUtil.getAllBroadcastAddresses()) {\n+            try {\n+                addresses.add(InetAddress.getByName(broadcastAddress));\n+            } catch (UnknownHostException e) {\n+                logger.warn(\"Error broadcasting to {}\", broadcastAddress, e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk3MzEzMg=="}, "originalCommit": {"oid": "e9674556c16225cbbe635a06414cbf94eda1ea4c"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM5NjQ0MA==", "bodyText": "1. In formatting an exception via {} doesn't dump the full trace on my side, just the message\n\n\nThe third parameter e will lead to dumping the full stack trace.\n\n2. The address is supposed to be raw IP, not a hostname, like 192.168.0.255. Getting UnknownHost on it would be totally strange, some internal system error. I wrote it here only because the IDE forces me to do so.\n   I will add the comment in the code.\n\n\nOK", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r511396440", "createdAt": "2020-10-24T11:02:07Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/discovery/IRobotDiscoveryService.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.discovery;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.IRobotBindingConstants;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.net.NetUtil;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * Discovery service for iRobot's\n+ *\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Initial contribution\n+ *\n+ */\n+@Component(service = DiscoveryService.class)\n+@NonNullByDefault\n+public class IRobotDiscoveryService extends AbstractDiscoveryService {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IRobotDiscoveryService.class);\n+    private final Runnable scanner;\n+    private @Nullable ScheduledFuture<?> backgroundFuture;\n+\n+    public IRobotDiscoveryService() {\n+        super(Collections.singleton(IRobotBindingConstants.THING_TYPE_ROOMBA), 30, true);\n+        scanner = createScanner();\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.trace(\"Starting background discovery\");\n+        stopBackgroundScan();\n+        backgroundFuture = scheduler.scheduleWithFixedDelay(scanner, 0, 60, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        logger.trace(\"Stopping background discovery\");\n+        stopBackgroundScan();\n+        super.stopBackgroundDiscovery();\n+    }\n+\n+    private void stopBackgroundScan() {\n+        ScheduledFuture<?> scan = backgroundFuture;\n+\n+        if (scan != null && !scan.isDone()) {\n+            scan.cancel(true);\n+            backgroundFuture = null;\n+        }\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.trace(\"startScan\");\n+        scheduler.execute(scanner);\n+    }\n+\n+    private Runnable createScanner() {\n+        return () -> {\n+            long timestampOfLastScan = getTimestampOfLastScan();\n+            for (InetAddress broadcastAddress : getBroadcastAddresses()) {\n+                logger.debug(\"Starting broadcast for {}\", broadcastAddress.toString());\n+\n+                DatagramSocket socket;\n+                try {\n+                    socket = IdentProtocol.sendRequest(broadcastAddress);\n+                    while (receivePacketAndDiscover(socket)) {\n+                    }\n+                } catch (IOException e) {\n+                    logger.warn(\"Error sending broadcast: {}\", e.toString());\n+                }\n+            }\n+\n+            removeOlderResults(timestampOfLastScan);\n+        };\n+    }\n+\n+    private List<InetAddress> getBroadcastAddresses() {\n+        ArrayList<InetAddress> addresses = new ArrayList<>();\n+\n+        for (String broadcastAddress : NetUtil.getAllBroadcastAddresses()) {\n+            try {\n+                addresses.add(InetAddress.getByName(broadcastAddress));\n+            } catch (UnknownHostException e) {\n+                logger.warn(\"Error broadcasting to {}\", broadcastAddress, e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk3MzEzMg=="}, "originalCommit": {"oid": "e9674556c16225cbbe635a06414cbf94eda1ea4c"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTQyNTgxNQ==", "bodyText": "The third parameter e will lead to dumping the full stack trace.\nWell, may be i never got this exception so i was just thinking so... Thanks for teaching me some Java :)", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r511425815", "createdAt": "2020-10-24T12:19:35Z", "author": {"login": "Sonic-Amiga"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/discovery/IRobotDiscoveryService.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.discovery;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.IRobotBindingConstants;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.net.NetUtil;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * Discovery service for iRobot's\n+ *\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Initial contribution\n+ *\n+ */\n+@Component(service = DiscoveryService.class)\n+@NonNullByDefault\n+public class IRobotDiscoveryService extends AbstractDiscoveryService {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IRobotDiscoveryService.class);\n+    private final Runnable scanner;\n+    private @Nullable ScheduledFuture<?> backgroundFuture;\n+\n+    public IRobotDiscoveryService() {\n+        super(Collections.singleton(IRobotBindingConstants.THING_TYPE_ROOMBA), 30, true);\n+        scanner = createScanner();\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.trace(\"Starting background discovery\");\n+        stopBackgroundScan();\n+        backgroundFuture = scheduler.scheduleWithFixedDelay(scanner, 0, 60, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        logger.trace(\"Stopping background discovery\");\n+        stopBackgroundScan();\n+        super.stopBackgroundDiscovery();\n+    }\n+\n+    private void stopBackgroundScan() {\n+        ScheduledFuture<?> scan = backgroundFuture;\n+\n+        if (scan != null && !scan.isDone()) {\n+            scan.cancel(true);\n+            backgroundFuture = null;\n+        }\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.trace(\"startScan\");\n+        scheduler.execute(scanner);\n+    }\n+\n+    private Runnable createScanner() {\n+        return () -> {\n+            long timestampOfLastScan = getTimestampOfLastScan();\n+            for (InetAddress broadcastAddress : getBroadcastAddresses()) {\n+                logger.debug(\"Starting broadcast for {}\", broadcastAddress.toString());\n+\n+                DatagramSocket socket;\n+                try {\n+                    socket = IdentProtocol.sendRequest(broadcastAddress);\n+                    while (receivePacketAndDiscover(socket)) {\n+                    }\n+                } catch (IOException e) {\n+                    logger.warn(\"Error sending broadcast: {}\", e.toString());\n+                }\n+            }\n+\n+            removeOlderResults(timestampOfLastScan);\n+        };\n+    }\n+\n+    private List<InetAddress> getBroadcastAddresses() {\n+        ArrayList<InetAddress> addresses = new ArrayList<>();\n+\n+        for (String broadcastAddress : NetUtil.getAllBroadcastAddresses()) {\n+            try {\n+                addresses.add(InetAddress.getByName(broadcastAddress));\n+            } catch (UnknownHostException e) {\n+                logger.warn(\"Error broadcasting to {}\", broadcastAddress, e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk3MzEzMg=="}, "originalCommit": {"oid": "e9674556c16225cbbe635a06414cbf94eda1ea4c"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODgyNDcxMg==", "bodyText": "The third parameter is still there.", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r518824712", "createdAt": "2020-11-06T15:27:17Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/discovery/IRobotDiscoveryService.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.discovery;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.IRobotBindingConstants;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.net.NetUtil;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * Discovery service for iRobot's\n+ *\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Initial contribution\n+ *\n+ */\n+@Component(service = DiscoveryService.class)\n+@NonNullByDefault\n+public class IRobotDiscoveryService extends AbstractDiscoveryService {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IRobotDiscoveryService.class);\n+    private final Runnable scanner;\n+    private @Nullable ScheduledFuture<?> backgroundFuture;\n+\n+    public IRobotDiscoveryService() {\n+        super(Collections.singleton(IRobotBindingConstants.THING_TYPE_ROOMBA), 30, true);\n+        scanner = createScanner();\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.trace(\"Starting background discovery\");\n+        stopBackgroundScan();\n+        backgroundFuture = scheduler.scheduleWithFixedDelay(scanner, 0, 60, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        logger.trace(\"Stopping background discovery\");\n+        stopBackgroundScan();\n+        super.stopBackgroundDiscovery();\n+    }\n+\n+    private void stopBackgroundScan() {\n+        ScheduledFuture<?> scan = backgroundFuture;\n+\n+        if (scan != null && !scan.isDone()) {\n+            scan.cancel(true);\n+            backgroundFuture = null;\n+        }\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.trace(\"startScan\");\n+        scheduler.execute(scanner);\n+    }\n+\n+    private Runnable createScanner() {\n+        return () -> {\n+            long timestampOfLastScan = getTimestampOfLastScan();\n+            for (InetAddress broadcastAddress : getBroadcastAddresses()) {\n+                logger.debug(\"Starting broadcast for {}\", broadcastAddress.toString());\n+\n+                DatagramSocket socket;\n+                try {\n+                    socket = IdentProtocol.sendRequest(broadcastAddress);\n+                    while (receivePacketAndDiscover(socket)) {\n+                    }\n+                } catch (IOException e) {\n+                    logger.warn(\"Error sending broadcast: {}\", e.toString());\n+                }\n+            }\n+\n+            removeOlderResults(timestampOfLastScan);\n+        };\n+    }\n+\n+    private List<InetAddress> getBroadcastAddresses() {\n+        ArrayList<InetAddress> addresses = new ArrayList<>();\n+\n+        for (String broadcastAddress : NetUtil.getAllBroadcastAddresses()) {\n+            try {\n+                addresses.add(InetAddress.getByName(broadcastAddress));\n+            } catch (UnknownHostException e) {\n+                logger.warn(\"Error broadcasting to {}\", broadcastAddress, e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk3MzEzMg=="}, "originalCommit": {"oid": "e9674556c16225cbbe635a06414cbf94eda1ea4c"}, "originalPosition": 119}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMDkwMTg5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/discovery/IRobotDiscoveryService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNTo0NToyM1rOHnTgJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNTo0NToyM1rOHnTgJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk3NjAzNw==", "bodyText": "See above. Use the debugger.", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r510976037", "createdAt": "2020-10-23T15:45:23Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/discovery/IRobotDiscoveryService.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.discovery;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.IRobotBindingConstants;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.net.NetUtil;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * Discovery service for iRobot's\n+ *\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Initial contribution\n+ *\n+ */\n+@Component(service = DiscoveryService.class)\n+@NonNullByDefault\n+public class IRobotDiscoveryService extends AbstractDiscoveryService {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IRobotDiscoveryService.class);\n+    private final Runnable scanner;\n+    private @Nullable ScheduledFuture<?> backgroundFuture;\n+\n+    public IRobotDiscoveryService() {\n+        super(Collections.singleton(IRobotBindingConstants.THING_TYPE_ROOMBA), 30, true);\n+        scanner = createScanner();\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.trace(\"Starting background discovery\");\n+        stopBackgroundScan();\n+        backgroundFuture = scheduler.scheduleWithFixedDelay(scanner, 0, 60, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        logger.trace(\"Stopping background discovery\");\n+        stopBackgroundScan();\n+        super.stopBackgroundDiscovery();\n+    }\n+\n+    private void stopBackgroundScan() {\n+        ScheduledFuture<?> scan = backgroundFuture;\n+\n+        if (scan != null && !scan.isDone()) {\n+            scan.cancel(true);\n+            backgroundFuture = null;\n+        }\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.trace(\"startScan\");\n+        scheduler.execute(scanner);\n+    }\n+\n+    private Runnable createScanner() {\n+        return () -> {\n+            long timestampOfLastScan = getTimestampOfLastScan();\n+            for (InetAddress broadcastAddress : getBroadcastAddresses()) {\n+                logger.debug(\"Starting broadcast for {}\", broadcastAddress.toString());\n+\n+                DatagramSocket socket;\n+                try {\n+                    socket = IdentProtocol.sendRequest(broadcastAddress);\n+                    while (receivePacketAndDiscover(socket)) {\n+                    }\n+                } catch (IOException e) {\n+                    logger.warn(\"Error sending broadcast: {}\", e.toString());\n+                }\n+            }\n+\n+            removeOlderResults(timestampOfLastScan);\n+        };\n+    }\n+\n+    private List<InetAddress> getBroadcastAddresses() {\n+        ArrayList<InetAddress> addresses = new ArrayList<>();\n+\n+        for (String broadcastAddress : NetUtil.getAllBroadcastAddresses()) {\n+            try {\n+                addresses.add(InetAddress.getByName(broadcastAddress));\n+            } catch (UnknownHostException e) {\n+                logger.warn(\"Error broadcasting to {}\", broadcastAddress, e);\n+            }\n+        }\n+\n+        return addresses;\n+    }\n+\n+    private boolean receivePacketAndDiscover(DatagramSocket socket) {\n+        DatagramPacket incomingPacket;\n+\n+        try {\n+            incomingPacket = IdentProtocol.receiveResponse(socket);\n+        } catch (Exception e) {\n+            // This is not really an error, eventually we get a timeout\n+            // due to a loop in the caller\n+            return false;\n+        }\n+\n+        String host = incomingPacket.getAddress().toString().substring(1);\n+\n+        logger.debug(\"Received reply from {}\", host);\n+        logger.trace(\"{}\", new String(incomingPacket.getData()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9674556c16225cbbe635a06414cbf94eda1ea4c"}, "originalPosition": 140}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMDkwNDQwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/discovery/IRobotDiscoveryService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNTo0NjowM1rOHnThvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQxMTowNDoxMVrOHntNUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk3NjQ0NA==", "bodyText": "Bindings should only log to error if something severe happened, like the detection of a bug in your code. This could be warn. See this link for a description of the log levels: https://www.openhab.org/docs/developer/guidelines.html#f-logging", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r510976444", "createdAt": "2020-10-23T15:46:03Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/discovery/IRobotDiscoveryService.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.discovery;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.IRobotBindingConstants;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.net.NetUtil;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * Discovery service for iRobot's\n+ *\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Initial contribution\n+ *\n+ */\n+@Component(service = DiscoveryService.class)\n+@NonNullByDefault\n+public class IRobotDiscoveryService extends AbstractDiscoveryService {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IRobotDiscoveryService.class);\n+    private final Runnable scanner;\n+    private @Nullable ScheduledFuture<?> backgroundFuture;\n+\n+    public IRobotDiscoveryService() {\n+        super(Collections.singleton(IRobotBindingConstants.THING_TYPE_ROOMBA), 30, true);\n+        scanner = createScanner();\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.trace(\"Starting background discovery\");\n+        stopBackgroundScan();\n+        backgroundFuture = scheduler.scheduleWithFixedDelay(scanner, 0, 60, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        logger.trace(\"Stopping background discovery\");\n+        stopBackgroundScan();\n+        super.stopBackgroundDiscovery();\n+    }\n+\n+    private void stopBackgroundScan() {\n+        ScheduledFuture<?> scan = backgroundFuture;\n+\n+        if (scan != null && !scan.isDone()) {\n+            scan.cancel(true);\n+            backgroundFuture = null;\n+        }\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.trace(\"startScan\");\n+        scheduler.execute(scanner);\n+    }\n+\n+    private Runnable createScanner() {\n+        return () -> {\n+            long timestampOfLastScan = getTimestampOfLastScan();\n+            for (InetAddress broadcastAddress : getBroadcastAddresses()) {\n+                logger.debug(\"Starting broadcast for {}\", broadcastAddress.toString());\n+\n+                DatagramSocket socket;\n+                try {\n+                    socket = IdentProtocol.sendRequest(broadcastAddress);\n+                    while (receivePacketAndDiscover(socket)) {\n+                    }\n+                } catch (IOException e) {\n+                    logger.warn(\"Error sending broadcast: {}\", e.toString());\n+                }\n+            }\n+\n+            removeOlderResults(timestampOfLastScan);\n+        };\n+    }\n+\n+    private List<InetAddress> getBroadcastAddresses() {\n+        ArrayList<InetAddress> addresses = new ArrayList<>();\n+\n+        for (String broadcastAddress : NetUtil.getAllBroadcastAddresses()) {\n+            try {\n+                addresses.add(InetAddress.getByName(broadcastAddress));\n+            } catch (UnknownHostException e) {\n+                logger.warn(\"Error broadcasting to {}\", broadcastAddress, e);\n+            }\n+        }\n+\n+        return addresses;\n+    }\n+\n+    private boolean receivePacketAndDiscover(DatagramSocket socket) {\n+        DatagramPacket incomingPacket;\n+\n+        try {\n+            incomingPacket = IdentProtocol.receiveResponse(socket);\n+        } catch (Exception e) {\n+            // This is not really an error, eventually we get a timeout\n+            // due to a loop in the caller\n+            return false;\n+        }\n+\n+        String host = incomingPacket.getAddress().toString().substring(1);\n+\n+        logger.debug(\"Received reply from {}\", host);\n+        logger.trace(\"{}\", new String(incomingPacket.getData()));\n+\n+        IdentProtocol.IdentData ident;\n+\n+        try {\n+            ident = IdentProtocol.decodeResponse(incomingPacket);\n+        } catch (JsonParseException e) {\n+            logger.error(\"Malformed IDENT reply from {}!\", host);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9674556c16225cbbe635a06414cbf94eda1ea4c"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM5NzIwMQ==", "bodyText": "Ok", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r511397201", "createdAt": "2020-10-24T11:04:11Z", "author": {"login": "Sonic-Amiga"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/discovery/IRobotDiscoveryService.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.discovery;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.IRobotBindingConstants;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.net.NetUtil;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * Discovery service for iRobot's\n+ *\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Initial contribution\n+ *\n+ */\n+@Component(service = DiscoveryService.class)\n+@NonNullByDefault\n+public class IRobotDiscoveryService extends AbstractDiscoveryService {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IRobotDiscoveryService.class);\n+    private final Runnable scanner;\n+    private @Nullable ScheduledFuture<?> backgroundFuture;\n+\n+    public IRobotDiscoveryService() {\n+        super(Collections.singleton(IRobotBindingConstants.THING_TYPE_ROOMBA), 30, true);\n+        scanner = createScanner();\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.trace(\"Starting background discovery\");\n+        stopBackgroundScan();\n+        backgroundFuture = scheduler.scheduleWithFixedDelay(scanner, 0, 60, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        logger.trace(\"Stopping background discovery\");\n+        stopBackgroundScan();\n+        super.stopBackgroundDiscovery();\n+    }\n+\n+    private void stopBackgroundScan() {\n+        ScheduledFuture<?> scan = backgroundFuture;\n+\n+        if (scan != null && !scan.isDone()) {\n+            scan.cancel(true);\n+            backgroundFuture = null;\n+        }\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.trace(\"startScan\");\n+        scheduler.execute(scanner);\n+    }\n+\n+    private Runnable createScanner() {\n+        return () -> {\n+            long timestampOfLastScan = getTimestampOfLastScan();\n+            for (InetAddress broadcastAddress : getBroadcastAddresses()) {\n+                logger.debug(\"Starting broadcast for {}\", broadcastAddress.toString());\n+\n+                DatagramSocket socket;\n+                try {\n+                    socket = IdentProtocol.sendRequest(broadcastAddress);\n+                    while (receivePacketAndDiscover(socket)) {\n+                    }\n+                } catch (IOException e) {\n+                    logger.warn(\"Error sending broadcast: {}\", e.toString());\n+                }\n+            }\n+\n+            removeOlderResults(timestampOfLastScan);\n+        };\n+    }\n+\n+    private List<InetAddress> getBroadcastAddresses() {\n+        ArrayList<InetAddress> addresses = new ArrayList<>();\n+\n+        for (String broadcastAddress : NetUtil.getAllBroadcastAddresses()) {\n+            try {\n+                addresses.add(InetAddress.getByName(broadcastAddress));\n+            } catch (UnknownHostException e) {\n+                logger.warn(\"Error broadcasting to {}\", broadcastAddress, e);\n+            }\n+        }\n+\n+        return addresses;\n+    }\n+\n+    private boolean receivePacketAndDiscover(DatagramSocket socket) {\n+        DatagramPacket incomingPacket;\n+\n+        try {\n+            incomingPacket = IdentProtocol.receiveResponse(socket);\n+        } catch (Exception e) {\n+            // This is not really an error, eventually we get a timeout\n+            // due to a loop in the caller\n+            return false;\n+        }\n+\n+        String host = incomingPacket.getAddress().toString().substring(1);\n+\n+        logger.debug(\"Received reply from {}\", host);\n+        logger.trace(\"{}\", new String(incomingPacket.getData()));\n+\n+        IdentProtocol.IdentData ident;\n+\n+        try {\n+            ident = IdentProtocol.decodeResponse(incomingPacket);\n+        } catch (JsonParseException e) {\n+            logger.error(\"Malformed IDENT reply from {}!\", host);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk3NjQ0NA=="}, "originalCommit": {"oid": "e9674556c16225cbbe635a06414cbf94eda1ea4c"}, "originalPosition": 147}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMDkwNTQ1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/discovery/IRobotDiscoveryService.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNTo0NjoyMVrOHnTiYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQxMjoyMToxNlrOHnu_xw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk3NjYxMA==", "bodyText": "Logging to info should be used sparsely e.g. a newly started component or a user file that has been loaded. This could be debug.", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r510976610", "createdAt": "2020-10-23T15:46:21Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/discovery/IRobotDiscoveryService.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.discovery;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.IRobotBindingConstants;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.net.NetUtil;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * Discovery service for iRobot's\n+ *\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Initial contribution\n+ *\n+ */\n+@Component(service = DiscoveryService.class)\n+@NonNullByDefault\n+public class IRobotDiscoveryService extends AbstractDiscoveryService {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IRobotDiscoveryService.class);\n+    private final Runnable scanner;\n+    private @Nullable ScheduledFuture<?> backgroundFuture;\n+\n+    public IRobotDiscoveryService() {\n+        super(Collections.singleton(IRobotBindingConstants.THING_TYPE_ROOMBA), 30, true);\n+        scanner = createScanner();\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.trace(\"Starting background discovery\");\n+        stopBackgroundScan();\n+        backgroundFuture = scheduler.scheduleWithFixedDelay(scanner, 0, 60, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        logger.trace(\"Stopping background discovery\");\n+        stopBackgroundScan();\n+        super.stopBackgroundDiscovery();\n+    }\n+\n+    private void stopBackgroundScan() {\n+        ScheduledFuture<?> scan = backgroundFuture;\n+\n+        if (scan != null && !scan.isDone()) {\n+            scan.cancel(true);\n+            backgroundFuture = null;\n+        }\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.trace(\"startScan\");\n+        scheduler.execute(scanner);\n+    }\n+\n+    private Runnable createScanner() {\n+        return () -> {\n+            long timestampOfLastScan = getTimestampOfLastScan();\n+            for (InetAddress broadcastAddress : getBroadcastAddresses()) {\n+                logger.debug(\"Starting broadcast for {}\", broadcastAddress.toString());\n+\n+                DatagramSocket socket;\n+                try {\n+                    socket = IdentProtocol.sendRequest(broadcastAddress);\n+                    while (receivePacketAndDiscover(socket)) {\n+                    }\n+                } catch (IOException e) {\n+                    logger.warn(\"Error sending broadcast: {}\", e.toString());\n+                }\n+            }\n+\n+            removeOlderResults(timestampOfLastScan);\n+        };\n+    }\n+\n+    private List<InetAddress> getBroadcastAddresses() {\n+        ArrayList<InetAddress> addresses = new ArrayList<>();\n+\n+        for (String broadcastAddress : NetUtil.getAllBroadcastAddresses()) {\n+            try {\n+                addresses.add(InetAddress.getByName(broadcastAddress));\n+            } catch (UnknownHostException e) {\n+                logger.warn(\"Error broadcasting to {}\", broadcastAddress, e);\n+            }\n+        }\n+\n+        return addresses;\n+    }\n+\n+    private boolean receivePacketAndDiscover(DatagramSocket socket) {\n+        DatagramPacket incomingPacket;\n+\n+        try {\n+            incomingPacket = IdentProtocol.receiveResponse(socket);\n+        } catch (Exception e) {\n+            // This is not really an error, eventually we get a timeout\n+            // due to a loop in the caller\n+            return false;\n+        }\n+\n+        String host = incomingPacket.getAddress().toString().substring(1);\n+\n+        logger.debug(\"Received reply from {}\", host);\n+        logger.trace(\"{}\", new String(incomingPacket.getData()));\n+\n+        IdentProtocol.IdentData ident;\n+\n+        try {\n+            ident = IdentProtocol.decodeResponse(incomingPacket);\n+        } catch (JsonParseException e) {\n+            logger.error(\"Malformed IDENT reply from {}!\", host);\n+            return true;\n+        }\n+\n+        // This check comes from Roomba980-Python\n+        if (ident.ver < IdentData.MIN_SUPPORTED_VERSION) {\n+            logger.info(\"Found unsupported iRobot \\\"{}\\\" version {} at {}\", ident.robotname, ident.ver, host);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9674556c16225cbbe635a06414cbf94eda1ea4c"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM5ODMzNg==", "bodyText": "This is also a way to tell the user that the robot is there but unsupported. This check comes from Roomba980Python, to tell the truth i don't even know why exactly it cannot be supported. Perhaps some protocol differences. Could be figured out if someone actually steps on it.\nIf you're insisting, tell me, i'll change.", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r511398336", "createdAt": "2020-10-24T11:06:59Z", "author": {"login": "Sonic-Amiga"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/discovery/IRobotDiscoveryService.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.discovery;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.IRobotBindingConstants;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.net.NetUtil;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * Discovery service for iRobot's\n+ *\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Initial contribution\n+ *\n+ */\n+@Component(service = DiscoveryService.class)\n+@NonNullByDefault\n+public class IRobotDiscoveryService extends AbstractDiscoveryService {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IRobotDiscoveryService.class);\n+    private final Runnable scanner;\n+    private @Nullable ScheduledFuture<?> backgroundFuture;\n+\n+    public IRobotDiscoveryService() {\n+        super(Collections.singleton(IRobotBindingConstants.THING_TYPE_ROOMBA), 30, true);\n+        scanner = createScanner();\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.trace(\"Starting background discovery\");\n+        stopBackgroundScan();\n+        backgroundFuture = scheduler.scheduleWithFixedDelay(scanner, 0, 60, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        logger.trace(\"Stopping background discovery\");\n+        stopBackgroundScan();\n+        super.stopBackgroundDiscovery();\n+    }\n+\n+    private void stopBackgroundScan() {\n+        ScheduledFuture<?> scan = backgroundFuture;\n+\n+        if (scan != null && !scan.isDone()) {\n+            scan.cancel(true);\n+            backgroundFuture = null;\n+        }\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.trace(\"startScan\");\n+        scheduler.execute(scanner);\n+    }\n+\n+    private Runnable createScanner() {\n+        return () -> {\n+            long timestampOfLastScan = getTimestampOfLastScan();\n+            for (InetAddress broadcastAddress : getBroadcastAddresses()) {\n+                logger.debug(\"Starting broadcast for {}\", broadcastAddress.toString());\n+\n+                DatagramSocket socket;\n+                try {\n+                    socket = IdentProtocol.sendRequest(broadcastAddress);\n+                    while (receivePacketAndDiscover(socket)) {\n+                    }\n+                } catch (IOException e) {\n+                    logger.warn(\"Error sending broadcast: {}\", e.toString());\n+                }\n+            }\n+\n+            removeOlderResults(timestampOfLastScan);\n+        };\n+    }\n+\n+    private List<InetAddress> getBroadcastAddresses() {\n+        ArrayList<InetAddress> addresses = new ArrayList<>();\n+\n+        for (String broadcastAddress : NetUtil.getAllBroadcastAddresses()) {\n+            try {\n+                addresses.add(InetAddress.getByName(broadcastAddress));\n+            } catch (UnknownHostException e) {\n+                logger.warn(\"Error broadcasting to {}\", broadcastAddress, e);\n+            }\n+        }\n+\n+        return addresses;\n+    }\n+\n+    private boolean receivePacketAndDiscover(DatagramSocket socket) {\n+        DatagramPacket incomingPacket;\n+\n+        try {\n+            incomingPacket = IdentProtocol.receiveResponse(socket);\n+        } catch (Exception e) {\n+            // This is not really an error, eventually we get a timeout\n+            // due to a loop in the caller\n+            return false;\n+        }\n+\n+        String host = incomingPacket.getAddress().toString().substring(1);\n+\n+        logger.debug(\"Received reply from {}\", host);\n+        logger.trace(\"{}\", new String(incomingPacket.getData()));\n+\n+        IdentProtocol.IdentData ident;\n+\n+        try {\n+            ident = IdentProtocol.decodeResponse(incomingPacket);\n+        } catch (JsonParseException e) {\n+            logger.error(\"Malformed IDENT reply from {}!\", host);\n+            return true;\n+        }\n+\n+        // This check comes from Roomba980-Python\n+        if (ident.ver < IdentData.MIN_SUPPORTED_VERSION) {\n+            logger.info(\"Found unsupported iRobot \\\"{}\\\" version {} at {}\", ident.robotname, ident.ver, host);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk3NjYxMA=="}, "originalCommit": {"oid": "e9674556c16225cbbe635a06414cbf94eda1ea4c"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM5OTgwNw==", "bodyText": "I leave it up to you choosing debug or warn. In any case, info is slightly incorrect.", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r511399807", "createdAt": "2020-10-24T11:10:11Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/discovery/IRobotDiscoveryService.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.discovery;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.IRobotBindingConstants;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.net.NetUtil;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * Discovery service for iRobot's\n+ *\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Initial contribution\n+ *\n+ */\n+@Component(service = DiscoveryService.class)\n+@NonNullByDefault\n+public class IRobotDiscoveryService extends AbstractDiscoveryService {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IRobotDiscoveryService.class);\n+    private final Runnable scanner;\n+    private @Nullable ScheduledFuture<?> backgroundFuture;\n+\n+    public IRobotDiscoveryService() {\n+        super(Collections.singleton(IRobotBindingConstants.THING_TYPE_ROOMBA), 30, true);\n+        scanner = createScanner();\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.trace(\"Starting background discovery\");\n+        stopBackgroundScan();\n+        backgroundFuture = scheduler.scheduleWithFixedDelay(scanner, 0, 60, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        logger.trace(\"Stopping background discovery\");\n+        stopBackgroundScan();\n+        super.stopBackgroundDiscovery();\n+    }\n+\n+    private void stopBackgroundScan() {\n+        ScheduledFuture<?> scan = backgroundFuture;\n+\n+        if (scan != null && !scan.isDone()) {\n+            scan.cancel(true);\n+            backgroundFuture = null;\n+        }\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.trace(\"startScan\");\n+        scheduler.execute(scanner);\n+    }\n+\n+    private Runnable createScanner() {\n+        return () -> {\n+            long timestampOfLastScan = getTimestampOfLastScan();\n+            for (InetAddress broadcastAddress : getBroadcastAddresses()) {\n+                logger.debug(\"Starting broadcast for {}\", broadcastAddress.toString());\n+\n+                DatagramSocket socket;\n+                try {\n+                    socket = IdentProtocol.sendRequest(broadcastAddress);\n+                    while (receivePacketAndDiscover(socket)) {\n+                    }\n+                } catch (IOException e) {\n+                    logger.warn(\"Error sending broadcast: {}\", e.toString());\n+                }\n+            }\n+\n+            removeOlderResults(timestampOfLastScan);\n+        };\n+    }\n+\n+    private List<InetAddress> getBroadcastAddresses() {\n+        ArrayList<InetAddress> addresses = new ArrayList<>();\n+\n+        for (String broadcastAddress : NetUtil.getAllBroadcastAddresses()) {\n+            try {\n+                addresses.add(InetAddress.getByName(broadcastAddress));\n+            } catch (UnknownHostException e) {\n+                logger.warn(\"Error broadcasting to {}\", broadcastAddress, e);\n+            }\n+        }\n+\n+        return addresses;\n+    }\n+\n+    private boolean receivePacketAndDiscover(DatagramSocket socket) {\n+        DatagramPacket incomingPacket;\n+\n+        try {\n+            incomingPacket = IdentProtocol.receiveResponse(socket);\n+        } catch (Exception e) {\n+            // This is not really an error, eventually we get a timeout\n+            // due to a loop in the caller\n+            return false;\n+        }\n+\n+        String host = incomingPacket.getAddress().toString().substring(1);\n+\n+        logger.debug(\"Received reply from {}\", host);\n+        logger.trace(\"{}\", new String(incomingPacket.getData()));\n+\n+        IdentProtocol.IdentData ident;\n+\n+        try {\n+            ident = IdentProtocol.decodeResponse(incomingPacket);\n+        } catch (JsonParseException e) {\n+            logger.error(\"Malformed IDENT reply from {}!\", host);\n+            return true;\n+        }\n+\n+        // This check comes from Roomba980-Python\n+        if (ident.ver < IdentData.MIN_SUPPORTED_VERSION) {\n+            logger.info(\"Found unsupported iRobot \\\"{}\\\" version {} at {}\", ident.robotname, ident.ver, host);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk3NjYxMA=="}, "originalCommit": {"oid": "e9674556c16225cbbe635a06414cbf94eda1ea4c"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTQyNjUwMw==", "bodyText": "warn because debug is disabled by default on user's side.", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r511426503", "createdAt": "2020-10-24T12:21:16Z", "author": {"login": "Sonic-Amiga"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/discovery/IRobotDiscoveryService.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.discovery;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.IRobotBindingConstants;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.net.NetUtil;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * Discovery service for iRobot's\n+ *\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Initial contribution\n+ *\n+ */\n+@Component(service = DiscoveryService.class)\n+@NonNullByDefault\n+public class IRobotDiscoveryService extends AbstractDiscoveryService {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IRobotDiscoveryService.class);\n+    private final Runnable scanner;\n+    private @Nullable ScheduledFuture<?> backgroundFuture;\n+\n+    public IRobotDiscoveryService() {\n+        super(Collections.singleton(IRobotBindingConstants.THING_TYPE_ROOMBA), 30, true);\n+        scanner = createScanner();\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.trace(\"Starting background discovery\");\n+        stopBackgroundScan();\n+        backgroundFuture = scheduler.scheduleWithFixedDelay(scanner, 0, 60, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        logger.trace(\"Stopping background discovery\");\n+        stopBackgroundScan();\n+        super.stopBackgroundDiscovery();\n+    }\n+\n+    private void stopBackgroundScan() {\n+        ScheduledFuture<?> scan = backgroundFuture;\n+\n+        if (scan != null && !scan.isDone()) {\n+            scan.cancel(true);\n+            backgroundFuture = null;\n+        }\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.trace(\"startScan\");\n+        scheduler.execute(scanner);\n+    }\n+\n+    private Runnable createScanner() {\n+        return () -> {\n+            long timestampOfLastScan = getTimestampOfLastScan();\n+            for (InetAddress broadcastAddress : getBroadcastAddresses()) {\n+                logger.debug(\"Starting broadcast for {}\", broadcastAddress.toString());\n+\n+                DatagramSocket socket;\n+                try {\n+                    socket = IdentProtocol.sendRequest(broadcastAddress);\n+                    while (receivePacketAndDiscover(socket)) {\n+                    }\n+                } catch (IOException e) {\n+                    logger.warn(\"Error sending broadcast: {}\", e.toString());\n+                }\n+            }\n+\n+            removeOlderResults(timestampOfLastScan);\n+        };\n+    }\n+\n+    private List<InetAddress> getBroadcastAddresses() {\n+        ArrayList<InetAddress> addresses = new ArrayList<>();\n+\n+        for (String broadcastAddress : NetUtil.getAllBroadcastAddresses()) {\n+            try {\n+                addresses.add(InetAddress.getByName(broadcastAddress));\n+            } catch (UnknownHostException e) {\n+                logger.warn(\"Error broadcasting to {}\", broadcastAddress, e);\n+            }\n+        }\n+\n+        return addresses;\n+    }\n+\n+    private boolean receivePacketAndDiscover(DatagramSocket socket) {\n+        DatagramPacket incomingPacket;\n+\n+        try {\n+            incomingPacket = IdentProtocol.receiveResponse(socket);\n+        } catch (Exception e) {\n+            // This is not really an error, eventually we get a timeout\n+            // due to a loop in the caller\n+            return false;\n+        }\n+\n+        String host = incomingPacket.getAddress().toString().substring(1);\n+\n+        logger.debug(\"Received reply from {}\", host);\n+        logger.trace(\"{}\", new String(incomingPacket.getData()));\n+\n+        IdentProtocol.IdentData ident;\n+\n+        try {\n+            ident = IdentProtocol.decodeResponse(incomingPacket);\n+        } catch (JsonParseException e) {\n+            logger.error(\"Malformed IDENT reply from {}!\", host);\n+            return true;\n+        }\n+\n+        // This check comes from Roomba980-Python\n+        if (ident.ver < IdentData.MIN_SUPPORTED_VERSION) {\n+            logger.info(\"Found unsupported iRobot \\\"{}\\\" version {} at {}\", ident.robotname, ident.ver, host);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk3NjYxMA=="}, "originalCommit": {"oid": "e9674556c16225cbbe635a06414cbf94eda1ea4c"}, "originalPosition": 153}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMDkwNjU2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/discovery/IRobotDiscoveryService.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNTo0NjozNlrOHnTjGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQxMToxMTo1N1rOHntawA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk3Njc5Mg==", "bodyText": "Can you add the representation property?", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r510976792", "createdAt": "2020-10-23T15:46:36Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/discovery/IRobotDiscoveryService.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.discovery;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.IRobotBindingConstants;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.net.NetUtil;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * Discovery service for iRobot's\n+ *\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Initial contribution\n+ *\n+ */\n+@Component(service = DiscoveryService.class)\n+@NonNullByDefault\n+public class IRobotDiscoveryService extends AbstractDiscoveryService {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IRobotDiscoveryService.class);\n+    private final Runnable scanner;\n+    private @Nullable ScheduledFuture<?> backgroundFuture;\n+\n+    public IRobotDiscoveryService() {\n+        super(Collections.singleton(IRobotBindingConstants.THING_TYPE_ROOMBA), 30, true);\n+        scanner = createScanner();\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.trace(\"Starting background discovery\");\n+        stopBackgroundScan();\n+        backgroundFuture = scheduler.scheduleWithFixedDelay(scanner, 0, 60, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        logger.trace(\"Stopping background discovery\");\n+        stopBackgroundScan();\n+        super.stopBackgroundDiscovery();\n+    }\n+\n+    private void stopBackgroundScan() {\n+        ScheduledFuture<?> scan = backgroundFuture;\n+\n+        if (scan != null && !scan.isDone()) {\n+            scan.cancel(true);\n+            backgroundFuture = null;\n+        }\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.trace(\"startScan\");\n+        scheduler.execute(scanner);\n+    }\n+\n+    private Runnable createScanner() {\n+        return () -> {\n+            long timestampOfLastScan = getTimestampOfLastScan();\n+            for (InetAddress broadcastAddress : getBroadcastAddresses()) {\n+                logger.debug(\"Starting broadcast for {}\", broadcastAddress.toString());\n+\n+                DatagramSocket socket;\n+                try {\n+                    socket = IdentProtocol.sendRequest(broadcastAddress);\n+                    while (receivePacketAndDiscover(socket)) {\n+                    }\n+                } catch (IOException e) {\n+                    logger.warn(\"Error sending broadcast: {}\", e.toString());\n+                }\n+            }\n+\n+            removeOlderResults(timestampOfLastScan);\n+        };\n+    }\n+\n+    private List<InetAddress> getBroadcastAddresses() {\n+        ArrayList<InetAddress> addresses = new ArrayList<>();\n+\n+        for (String broadcastAddress : NetUtil.getAllBroadcastAddresses()) {\n+            try {\n+                addresses.add(InetAddress.getByName(broadcastAddress));\n+            } catch (UnknownHostException e) {\n+                logger.warn(\"Error broadcasting to {}\", broadcastAddress, e);\n+            }\n+        }\n+\n+        return addresses;\n+    }\n+\n+    private boolean receivePacketAndDiscover(DatagramSocket socket) {\n+        DatagramPacket incomingPacket;\n+\n+        try {\n+            incomingPacket = IdentProtocol.receiveResponse(socket);\n+        } catch (Exception e) {\n+            // This is not really an error, eventually we get a timeout\n+            // due to a loop in the caller\n+            return false;\n+        }\n+\n+        String host = incomingPacket.getAddress().toString().substring(1);\n+\n+        logger.debug(\"Received reply from {}\", host);\n+        logger.trace(\"{}\", new String(incomingPacket.getData()));\n+\n+        IdentProtocol.IdentData ident;\n+\n+        try {\n+            ident = IdentProtocol.decodeResponse(incomingPacket);\n+        } catch (JsonParseException e) {\n+            logger.error(\"Malformed IDENT reply from {}!\", host);\n+            return true;\n+        }\n+\n+        // This check comes from Roomba980-Python\n+        if (ident.ver < IdentData.MIN_SUPPORTED_VERSION) {\n+            logger.info(\"Found unsupported iRobot \\\"{}\\\" version {} at {}\", ident.robotname, ident.ver, host);\n+            return true;\n+        }\n+\n+        if (ident.product.equals(IdentData.PRODUCT_ROOMBA)) {\n+            ThingUID thingUID = new ThingUID(IRobotBindingConstants.THING_TYPE_ROOMBA, host.replace('.', '_'));\n+            DiscoveryResult result = DiscoveryResultBuilder.create(thingUID)\n+                    .withProperty(RoombaConfiguration.FIELD_IPADDRESS, host).withLabel(\"iRobot \" + ident.robotname)\n+                    .build();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9674556c16225cbbe635a06414cbf94eda1ea4c"}, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM5ODQxNg==", "bodyText": "Sorry for dumb question, what is it ?", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r511398416", "createdAt": "2020-10-24T11:07:13Z", "author": {"login": "Sonic-Amiga"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/discovery/IRobotDiscoveryService.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.discovery;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.IRobotBindingConstants;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.net.NetUtil;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * Discovery service for iRobot's\n+ *\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Initial contribution\n+ *\n+ */\n+@Component(service = DiscoveryService.class)\n+@NonNullByDefault\n+public class IRobotDiscoveryService extends AbstractDiscoveryService {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IRobotDiscoveryService.class);\n+    private final Runnable scanner;\n+    private @Nullable ScheduledFuture<?> backgroundFuture;\n+\n+    public IRobotDiscoveryService() {\n+        super(Collections.singleton(IRobotBindingConstants.THING_TYPE_ROOMBA), 30, true);\n+        scanner = createScanner();\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.trace(\"Starting background discovery\");\n+        stopBackgroundScan();\n+        backgroundFuture = scheduler.scheduleWithFixedDelay(scanner, 0, 60, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        logger.trace(\"Stopping background discovery\");\n+        stopBackgroundScan();\n+        super.stopBackgroundDiscovery();\n+    }\n+\n+    private void stopBackgroundScan() {\n+        ScheduledFuture<?> scan = backgroundFuture;\n+\n+        if (scan != null && !scan.isDone()) {\n+            scan.cancel(true);\n+            backgroundFuture = null;\n+        }\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.trace(\"startScan\");\n+        scheduler.execute(scanner);\n+    }\n+\n+    private Runnable createScanner() {\n+        return () -> {\n+            long timestampOfLastScan = getTimestampOfLastScan();\n+            for (InetAddress broadcastAddress : getBroadcastAddresses()) {\n+                logger.debug(\"Starting broadcast for {}\", broadcastAddress.toString());\n+\n+                DatagramSocket socket;\n+                try {\n+                    socket = IdentProtocol.sendRequest(broadcastAddress);\n+                    while (receivePacketAndDiscover(socket)) {\n+                    }\n+                } catch (IOException e) {\n+                    logger.warn(\"Error sending broadcast: {}\", e.toString());\n+                }\n+            }\n+\n+            removeOlderResults(timestampOfLastScan);\n+        };\n+    }\n+\n+    private List<InetAddress> getBroadcastAddresses() {\n+        ArrayList<InetAddress> addresses = new ArrayList<>();\n+\n+        for (String broadcastAddress : NetUtil.getAllBroadcastAddresses()) {\n+            try {\n+                addresses.add(InetAddress.getByName(broadcastAddress));\n+            } catch (UnknownHostException e) {\n+                logger.warn(\"Error broadcasting to {}\", broadcastAddress, e);\n+            }\n+        }\n+\n+        return addresses;\n+    }\n+\n+    private boolean receivePacketAndDiscover(DatagramSocket socket) {\n+        DatagramPacket incomingPacket;\n+\n+        try {\n+            incomingPacket = IdentProtocol.receiveResponse(socket);\n+        } catch (Exception e) {\n+            // This is not really an error, eventually we get a timeout\n+            // due to a loop in the caller\n+            return false;\n+        }\n+\n+        String host = incomingPacket.getAddress().toString().substring(1);\n+\n+        logger.debug(\"Received reply from {}\", host);\n+        logger.trace(\"{}\", new String(incomingPacket.getData()));\n+\n+        IdentProtocol.IdentData ident;\n+\n+        try {\n+            ident = IdentProtocol.decodeResponse(incomingPacket);\n+        } catch (JsonParseException e) {\n+            logger.error(\"Malformed IDENT reply from {}!\", host);\n+            return true;\n+        }\n+\n+        // This check comes from Roomba980-Python\n+        if (ident.ver < IdentData.MIN_SUPPORTED_VERSION) {\n+            logger.info(\"Found unsupported iRobot \\\"{}\\\" version {} at {}\", ident.robotname, ident.ver, host);\n+            return true;\n+        }\n+\n+        if (ident.product.equals(IdentData.PRODUCT_ROOMBA)) {\n+            ThingUID thingUID = new ThingUID(IRobotBindingConstants.THING_TYPE_ROOMBA, host.replace('.', '_'));\n+            DiscoveryResult result = DiscoveryResultBuilder.create(thingUID)\n+                    .withProperty(RoombaConfiguration.FIELD_IPADDRESS, host).withLabel(\"iRobot \" + ident.robotname)\n+                    .build();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk3Njc5Mg=="}, "originalCommit": {"oid": "e9674556c16225cbbe635a06414cbf94eda1ea4c"}, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTQwMDY0MA==", "bodyText": "See https://www.openhab.org/docs/developer/bindings/thing-xml.html#representation-property", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r511400640", "createdAt": "2020-10-24T11:11:57Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/discovery/IRobotDiscoveryService.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.discovery;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.IRobotBindingConstants;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.net.NetUtil;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * Discovery service for iRobot's\n+ *\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Initial contribution\n+ *\n+ */\n+@Component(service = DiscoveryService.class)\n+@NonNullByDefault\n+public class IRobotDiscoveryService extends AbstractDiscoveryService {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IRobotDiscoveryService.class);\n+    private final Runnable scanner;\n+    private @Nullable ScheduledFuture<?> backgroundFuture;\n+\n+    public IRobotDiscoveryService() {\n+        super(Collections.singleton(IRobotBindingConstants.THING_TYPE_ROOMBA), 30, true);\n+        scanner = createScanner();\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.trace(\"Starting background discovery\");\n+        stopBackgroundScan();\n+        backgroundFuture = scheduler.scheduleWithFixedDelay(scanner, 0, 60, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        logger.trace(\"Stopping background discovery\");\n+        stopBackgroundScan();\n+        super.stopBackgroundDiscovery();\n+    }\n+\n+    private void stopBackgroundScan() {\n+        ScheduledFuture<?> scan = backgroundFuture;\n+\n+        if (scan != null && !scan.isDone()) {\n+            scan.cancel(true);\n+            backgroundFuture = null;\n+        }\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.trace(\"startScan\");\n+        scheduler.execute(scanner);\n+    }\n+\n+    private Runnable createScanner() {\n+        return () -> {\n+            long timestampOfLastScan = getTimestampOfLastScan();\n+            for (InetAddress broadcastAddress : getBroadcastAddresses()) {\n+                logger.debug(\"Starting broadcast for {}\", broadcastAddress.toString());\n+\n+                DatagramSocket socket;\n+                try {\n+                    socket = IdentProtocol.sendRequest(broadcastAddress);\n+                    while (receivePacketAndDiscover(socket)) {\n+                    }\n+                } catch (IOException e) {\n+                    logger.warn(\"Error sending broadcast: {}\", e.toString());\n+                }\n+            }\n+\n+            removeOlderResults(timestampOfLastScan);\n+        };\n+    }\n+\n+    private List<InetAddress> getBroadcastAddresses() {\n+        ArrayList<InetAddress> addresses = new ArrayList<>();\n+\n+        for (String broadcastAddress : NetUtil.getAllBroadcastAddresses()) {\n+            try {\n+                addresses.add(InetAddress.getByName(broadcastAddress));\n+            } catch (UnknownHostException e) {\n+                logger.warn(\"Error broadcasting to {}\", broadcastAddress, e);\n+            }\n+        }\n+\n+        return addresses;\n+    }\n+\n+    private boolean receivePacketAndDiscover(DatagramSocket socket) {\n+        DatagramPacket incomingPacket;\n+\n+        try {\n+            incomingPacket = IdentProtocol.receiveResponse(socket);\n+        } catch (Exception e) {\n+            // This is not really an error, eventually we get a timeout\n+            // due to a loop in the caller\n+            return false;\n+        }\n+\n+        String host = incomingPacket.getAddress().toString().substring(1);\n+\n+        logger.debug(\"Received reply from {}\", host);\n+        logger.trace(\"{}\", new String(incomingPacket.getData()));\n+\n+        IdentProtocol.IdentData ident;\n+\n+        try {\n+            ident = IdentProtocol.decodeResponse(incomingPacket);\n+        } catch (JsonParseException e) {\n+            logger.error(\"Malformed IDENT reply from {}!\", host);\n+            return true;\n+        }\n+\n+        // This check comes from Roomba980-Python\n+        if (ident.ver < IdentData.MIN_SUPPORTED_VERSION) {\n+            logger.info(\"Found unsupported iRobot \\\"{}\\\" version {} at {}\", ident.robotname, ident.ver, host);\n+            return true;\n+        }\n+\n+        if (ident.product.equals(IdentData.PRODUCT_ROOMBA)) {\n+            ThingUID thingUID = new ThingUID(IRobotBindingConstants.THING_TYPE_ROOMBA, host.replace('.', '_'));\n+            DiscoveryResult result = DiscoveryResultBuilder.create(thingUID)\n+                    .withProperty(RoombaConfiguration.FIELD_IPADDRESS, host).withLabel(\"iRobot \" + ident.robotname)\n+                    .build();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk3Njc5Mg=="}, "originalCommit": {"oid": "e9674556c16225cbbe635a06414cbf94eda1ea4c"}, "originalPosition": 161}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMDkxNDUyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/discovery/IRobotDiscoveryService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNTo0ODo0OFrOHnToOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQxMTowMDo1MVrOHntIqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk3ODEwNw==", "bodyText": "You should specify the concrete exception you want to catch, since catching Exception catches also all runtime exceptions.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    } catch (Exception e) {\n          \n          \n            \n                    } catch (IOException e) {", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r510978107", "createdAt": "2020-10-23T15:48:48Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/discovery/IRobotDiscoveryService.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.discovery;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.IRobotBindingConstants;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.net.NetUtil;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * Discovery service for iRobot's\n+ *\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Initial contribution\n+ *\n+ */\n+@Component(service = DiscoveryService.class)\n+@NonNullByDefault\n+public class IRobotDiscoveryService extends AbstractDiscoveryService {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IRobotDiscoveryService.class);\n+    private final Runnable scanner;\n+    private @Nullable ScheduledFuture<?> backgroundFuture;\n+\n+    public IRobotDiscoveryService() {\n+        super(Collections.singleton(IRobotBindingConstants.THING_TYPE_ROOMBA), 30, true);\n+        scanner = createScanner();\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.trace(\"Starting background discovery\");\n+        stopBackgroundScan();\n+        backgroundFuture = scheduler.scheduleWithFixedDelay(scanner, 0, 60, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        logger.trace(\"Stopping background discovery\");\n+        stopBackgroundScan();\n+        super.stopBackgroundDiscovery();\n+    }\n+\n+    private void stopBackgroundScan() {\n+        ScheduledFuture<?> scan = backgroundFuture;\n+\n+        if (scan != null && !scan.isDone()) {\n+            scan.cancel(true);\n+            backgroundFuture = null;\n+        }\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.trace(\"startScan\");\n+        scheduler.execute(scanner);\n+    }\n+\n+    private Runnable createScanner() {\n+        return () -> {\n+            long timestampOfLastScan = getTimestampOfLastScan();\n+            for (InetAddress broadcastAddress : getBroadcastAddresses()) {\n+                logger.debug(\"Starting broadcast for {}\", broadcastAddress.toString());\n+\n+                DatagramSocket socket;\n+                try {\n+                    socket = IdentProtocol.sendRequest(broadcastAddress);\n+                    while (receivePacketAndDiscover(socket)) {\n+                    }\n+                } catch (IOException e) {\n+                    logger.warn(\"Error sending broadcast: {}\", e.toString());\n+                }\n+            }\n+\n+            removeOlderResults(timestampOfLastScan);\n+        };\n+    }\n+\n+    private List<InetAddress> getBroadcastAddresses() {\n+        ArrayList<InetAddress> addresses = new ArrayList<>();\n+\n+        for (String broadcastAddress : NetUtil.getAllBroadcastAddresses()) {\n+            try {\n+                addresses.add(InetAddress.getByName(broadcastAddress));\n+            } catch (UnknownHostException e) {\n+                logger.warn(\"Error broadcasting to {}\", broadcastAddress, e);\n+            }\n+        }\n+\n+        return addresses;\n+    }\n+\n+    private boolean receivePacketAndDiscover(DatagramSocket socket) {\n+        DatagramPacket incomingPacket;\n+\n+        try {\n+            incomingPacket = IdentProtocol.receiveResponse(socket);\n+        } catch (Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9674556c16225cbbe635a06414cbf94eda1ea4c"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM5NjAwOA==", "bodyText": "I know, overlooked, sorrry", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r511396008", "createdAt": "2020-10-24T11:00:51Z", "author": {"login": "Sonic-Amiga"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/discovery/IRobotDiscoveryService.java", "diffHunk": "@@ -0,0 +1,168 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.discovery;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.IRobotBindingConstants;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.net.NetUtil;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * Discovery service for iRobot's\n+ *\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Initial contribution\n+ *\n+ */\n+@Component(service = DiscoveryService.class)\n+@NonNullByDefault\n+public class IRobotDiscoveryService extends AbstractDiscoveryService {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IRobotDiscoveryService.class);\n+    private final Runnable scanner;\n+    private @Nullable ScheduledFuture<?> backgroundFuture;\n+\n+    public IRobotDiscoveryService() {\n+        super(Collections.singleton(IRobotBindingConstants.THING_TYPE_ROOMBA), 30, true);\n+        scanner = createScanner();\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        logger.trace(\"Starting background discovery\");\n+        stopBackgroundScan();\n+        backgroundFuture = scheduler.scheduleWithFixedDelay(scanner, 0, 60, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        logger.trace(\"Stopping background discovery\");\n+        stopBackgroundScan();\n+        super.stopBackgroundDiscovery();\n+    }\n+\n+    private void stopBackgroundScan() {\n+        ScheduledFuture<?> scan = backgroundFuture;\n+\n+        if (scan != null && !scan.isDone()) {\n+            scan.cancel(true);\n+            backgroundFuture = null;\n+        }\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        logger.trace(\"startScan\");\n+        scheduler.execute(scanner);\n+    }\n+\n+    private Runnable createScanner() {\n+        return () -> {\n+            long timestampOfLastScan = getTimestampOfLastScan();\n+            for (InetAddress broadcastAddress : getBroadcastAddresses()) {\n+                logger.debug(\"Starting broadcast for {}\", broadcastAddress.toString());\n+\n+                DatagramSocket socket;\n+                try {\n+                    socket = IdentProtocol.sendRequest(broadcastAddress);\n+                    while (receivePacketAndDiscover(socket)) {\n+                    }\n+                } catch (IOException e) {\n+                    logger.warn(\"Error sending broadcast: {}\", e.toString());\n+                }\n+            }\n+\n+            removeOlderResults(timestampOfLastScan);\n+        };\n+    }\n+\n+    private List<InetAddress> getBroadcastAddresses() {\n+        ArrayList<InetAddress> addresses = new ArrayList<>();\n+\n+        for (String broadcastAddress : NetUtil.getAllBroadcastAddresses()) {\n+            try {\n+                addresses.add(InetAddress.getByName(broadcastAddress));\n+            } catch (UnknownHostException e) {\n+                logger.warn(\"Error broadcasting to {}\", broadcastAddress, e);\n+            }\n+        }\n+\n+        return addresses;\n+    }\n+\n+    private boolean receivePacketAndDiscover(DatagramSocket socket) {\n+        DatagramPacket incomingPacket;\n+\n+        try {\n+            incomingPacket = IdentProtocol.receiveResponse(socket);\n+        } catch (Exception e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk3ODEwNw=="}, "originalCommit": {"oid": "e9674556c16225cbbe635a06414cbf94eda1ea4c"}, "originalPosition": 131}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMDkyMTM1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNTo1MDozNFrOHnTseQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQxMTowOToxOFrOHntV5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk3OTE5Mw==", "bodyText": "Is there a reason why you don't use the scheduler of BaseThingHandler?", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r510979193", "createdAt": "2020-10-23T15:50:34Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.handler;\n+\n+import static org.openhab.binding.irobot.IRobotBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Hashtable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.internal.MQTTProtocol;\n+import org.openhab.binding.irobot.internal.RawMQTT;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.binding.irobot.roomba.RoombaMqttBrokerConnection;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The {@link RoombaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author hkuhn42 - Initial contribution\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Rewrite for 900 series\n+ */\n+@NonNullByDefault\n+public class RoombaHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(RoombaHandler.class);\n+    private final ExecutorService singleThread = Executors.newSingleThreadExecutor();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9674556c16225cbbe635a06414cbf94eda1ea4c"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM5OTM5OA==", "bodyText": "Because i want to be sure that all the commands are serialized and come in order, and \"scheduler\" doesn't guarantee that, it can execute multiple requests in parallel in different threads. And i'm not sure if HiveMQ calls are reentrant.", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r511399398", "createdAt": "2020-10-24T11:09:18Z", "author": {"login": "Sonic-Amiga"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.handler;\n+\n+import static org.openhab.binding.irobot.IRobotBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Hashtable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.internal.MQTTProtocol;\n+import org.openhab.binding.irobot.internal.RawMQTT;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.binding.irobot.roomba.RoombaMqttBrokerConnection;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The {@link RoombaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author hkuhn42 - Initial contribution\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Rewrite for 900 series\n+ */\n+@NonNullByDefault\n+public class RoombaHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(RoombaHandler.class);\n+    private final ExecutorService singleThread = Executors.newSingleThreadExecutor();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk3OTE5Mw=="}, "originalCommit": {"oid": "e9674556c16225cbbe635a06414cbf94eda1ea4c"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMDkyNDAxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNTo1MToxM1rOHnTuFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQxMToxMDoxN1rOHntXqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk3OTYwNQ==", "bodyText": "It's good practice to append the unit to the field name e.g. TIMEOUT_SEC.\nAlso, static fields should be all upper case.", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r510979605", "createdAt": "2020-10-23T15:51:13Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.handler;\n+\n+import static org.openhab.binding.irobot.IRobotBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Hashtable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.internal.MQTTProtocol;\n+import org.openhab.binding.irobot.internal.RawMQTT;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.binding.irobot.roomba.RoombaMqttBrokerConnection;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The {@link RoombaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author hkuhn42 - Initial contribution\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Rewrite for 900 series\n+ */\n+@NonNullByDefault\n+public class RoombaHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(RoombaHandler.class);\n+    private final ExecutorService singleThread = Executors.newSingleThreadExecutor();\n+    private static final int reconnectDelay = 5; // In seconds", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9674556c16225cbbe635a06414cbf94eda1ea4c"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTM5OTg0OA==", "bodyText": "Enjoy", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r511399848", "createdAt": "2020-10-24T11:10:17Z", "author": {"login": "Sonic-Amiga"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.handler;\n+\n+import static org.openhab.binding.irobot.IRobotBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Hashtable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.internal.MQTTProtocol;\n+import org.openhab.binding.irobot.internal.RawMQTT;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.binding.irobot.roomba.RoombaMqttBrokerConnection;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The {@link RoombaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author hkuhn42 - Initial contribution\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Rewrite for 900 series\n+ */\n+@NonNullByDefault\n+public class RoombaHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(RoombaHandler.class);\n+    private final ExecutorService singleThread = Executors.newSingleThreadExecutor();\n+    private static final int reconnectDelay = 5; // In seconds", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk3OTYwNQ=="}, "originalCommit": {"oid": "e9674556c16225cbbe635a06414cbf94eda1ea4c"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMDkyNTYyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNTo1MTozOFrOHnTvHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNTo1MTozOFrOHnTvHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk3OTg2OA==", "bodyText": "Syntactical sugar\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Hashtable<String, State> lastState = new Hashtable<String, State>();\n          \n          \n            \n                private Hashtable<String, State> lastState = new Hashtable<>();", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r510979868", "createdAt": "2020-10-23T15:51:38Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.handler;\n+\n+import static org.openhab.binding.irobot.IRobotBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Hashtable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.internal.MQTTProtocol;\n+import org.openhab.binding.irobot.internal.RawMQTT;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.binding.irobot.roomba.RoombaMqttBrokerConnection;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The {@link RoombaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author hkuhn42 - Initial contribution\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Rewrite for 900 series\n+ */\n+@NonNullByDefault\n+public class RoombaHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(RoombaHandler.class);\n+    private final ExecutorService singleThread = Executors.newSingleThreadExecutor();\n+    private static final int reconnectDelay = 5; // In seconds\n+    private @Nullable Future<?> reconnectReq;\n+    // Dummy RoombaConfiguration object in order to shut up Eclipse warnings\n+    // The real one is set in initialize()\n+    private RoombaConfiguration config = new RoombaConfiguration();\n+    private @Nullable String blid = null;\n+    private @Nullable RoombaMqttBrokerConnection connection;\n+    private Hashtable<String, State> lastState = new Hashtable<String, State>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9674556c16225cbbe635a06414cbf94eda1ea4c"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMDkyNzIwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNTo1MjowMlrOHnTwGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNTo1MjowMlrOHnTwGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk4MDEyMA==", "bodyText": "Please use camelCase.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private boolean auto_passes = true;\n          \n          \n            \n                private boolean autoPasses = true;", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r510980120", "createdAt": "2020-10-23T15:52:02Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.handler;\n+\n+import static org.openhab.binding.irobot.IRobotBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Hashtable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.internal.MQTTProtocol;\n+import org.openhab.binding.irobot.internal.RawMQTT;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.binding.irobot.roomba.RoombaMqttBrokerConnection;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The {@link RoombaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author hkuhn42 - Initial contribution\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Rewrite for 900 series\n+ */\n+@NonNullByDefault\n+public class RoombaHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(RoombaHandler.class);\n+    private final ExecutorService singleThread = Executors.newSingleThreadExecutor();\n+    private static final int reconnectDelay = 5; // In seconds\n+    private @Nullable Future<?> reconnectReq;\n+    // Dummy RoombaConfiguration object in order to shut up Eclipse warnings\n+    // The real one is set in initialize()\n+    private RoombaConfiguration config = new RoombaConfiguration();\n+    private @Nullable String blid = null;\n+    private @Nullable RoombaMqttBrokerConnection connection;\n+    private Hashtable<String, State> lastState = new Hashtable<String, State>();\n+    private MQTTProtocol.@Nullable Schedule lastSchedule = null;\n+    private boolean auto_passes = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9674556c16225cbbe635a06414cbf94eda1ea4c"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMDkyOTIxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNTo1MjozM1rOHnTxUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNTo1MjozM1rOHnTxUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk4MDQzMg==", "bodyText": "This is already logged by the framework and could be removed.", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r510980432", "createdAt": "2020-10-23T15:52:33Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.handler;\n+\n+import static org.openhab.binding.irobot.IRobotBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Hashtable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.internal.MQTTProtocol;\n+import org.openhab.binding.irobot.internal.RawMQTT;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.binding.irobot.roomba.RoombaMqttBrokerConnection;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The {@link RoombaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author hkuhn42 - Initial contribution\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Rewrite for 900 series\n+ */\n+@NonNullByDefault\n+public class RoombaHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(RoombaHandler.class);\n+    private final ExecutorService singleThread = Executors.newSingleThreadExecutor();\n+    private static final int reconnectDelay = 5; // In seconds\n+    private @Nullable Future<?> reconnectReq;\n+    // Dummy RoombaConfiguration object in order to shut up Eclipse warnings\n+    // The real one is set in initialize()\n+    private RoombaConfiguration config = new RoombaConfiguration();\n+    private @Nullable String blid = null;\n+    private @Nullable RoombaMqttBrokerConnection connection;\n+    private Hashtable<String, State> lastState = new Hashtable<String, State>();\n+    private MQTTProtocol.@Nullable Schedule lastSchedule = null;\n+    private boolean auto_passes = true;\n+    private @Nullable Boolean two_passes = null;\n+    private boolean carpet_boost = true;\n+    private @Nullable Boolean vac_high = null;\n+    private boolean isPaused = false;\n+\n+    public RoombaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.trace(\"initialize()\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9674556c16225cbbe635a06414cbf94eda1ea4c"}, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMDkzMDAyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNTo1Mjo0NlrOHnTxzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNTo1Mjo0NlrOHnTxzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk4MDU1Nw==", "bodyText": "See above.", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r510980557", "createdAt": "2020-10-23T15:52:46Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.handler;\n+\n+import static org.openhab.binding.irobot.IRobotBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Hashtable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.internal.MQTTProtocol;\n+import org.openhab.binding.irobot.internal.RawMQTT;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.binding.irobot.roomba.RoombaMqttBrokerConnection;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The {@link RoombaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author hkuhn42 - Initial contribution\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Rewrite for 900 series\n+ */\n+@NonNullByDefault\n+public class RoombaHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(RoombaHandler.class);\n+    private final ExecutorService singleThread = Executors.newSingleThreadExecutor();\n+    private static final int reconnectDelay = 5; // In seconds\n+    private @Nullable Future<?> reconnectReq;\n+    // Dummy RoombaConfiguration object in order to shut up Eclipse warnings\n+    // The real one is set in initialize()\n+    private RoombaConfiguration config = new RoombaConfiguration();\n+    private @Nullable String blid = null;\n+    private @Nullable RoombaMqttBrokerConnection connection;\n+    private Hashtable<String, State> lastState = new Hashtable<String, State>();\n+    private MQTTProtocol.@Nullable Schedule lastSchedule = null;\n+    private boolean auto_passes = true;\n+    private @Nullable Boolean two_passes = null;\n+    private boolean carpet_boost = true;\n+    private @Nullable Boolean vac_high = null;\n+    private boolean isPaused = false;\n+\n+    public RoombaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.trace(\"initialize()\");\n+        config = getConfigAs(RoombaConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+        connect();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.trace(\"dispose()\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9674556c16225cbbe635a06414cbf94eda1ea4c"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMDkzMTMwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNTo1MzowOFrOHnTylw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxOTowMTozOVrOHwrYOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk4MDc1OQ==", "bodyText": "Why is this executed asynchronously?", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r510980759", "createdAt": "2020-10-23T15:53:08Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.handler;\n+\n+import static org.openhab.binding.irobot.IRobotBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Hashtable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.internal.MQTTProtocol;\n+import org.openhab.binding.irobot.internal.RawMQTT;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.binding.irobot.roomba.RoombaMqttBrokerConnection;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The {@link RoombaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author hkuhn42 - Initial contribution\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Rewrite for 900 series\n+ */\n+@NonNullByDefault\n+public class RoombaHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(RoombaHandler.class);\n+    private final ExecutorService singleThread = Executors.newSingleThreadExecutor();\n+    private static final int reconnectDelay = 5; // In seconds\n+    private @Nullable Future<?> reconnectReq;\n+    // Dummy RoombaConfiguration object in order to shut up Eclipse warnings\n+    // The real one is set in initialize()\n+    private RoombaConfiguration config = new RoombaConfiguration();\n+    private @Nullable String blid = null;\n+    private @Nullable RoombaMqttBrokerConnection connection;\n+    private Hashtable<String, State> lastState = new Hashtable<String, State>();\n+    private MQTTProtocol.@Nullable Schedule lastSchedule = null;\n+    private boolean auto_passes = true;\n+    private @Nullable Boolean two_passes = null;\n+    private boolean carpet_boost = true;\n+    private @Nullable Boolean vac_high = null;\n+    private boolean isPaused = false;\n+\n+    public RoombaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.trace(\"initialize()\");\n+        config = getConfigAs(RoombaConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+        connect();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.trace(\"dispose()\");\n+\n+        singleThread.execute(() -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9674556c16225cbbe635a06414cbf94eda1ea4c"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTQwMTI4NA==", "bodyText": "In order to run in the same thread where connect requests are handled, in order to avoid race conditions. Is it OK to call connection.stop() while connection.start() is running? I suggest the MQTT client would badly screw up\nPerhaps Java has a different view on it, then teach me please. I come from C world, and there this would be the right way to do things, if you don't know where initial requests come from.", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r511401284", "createdAt": "2020-10-24T11:13:31Z", "author": {"login": "Sonic-Amiga"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.handler;\n+\n+import static org.openhab.binding.irobot.IRobotBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Hashtable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.internal.MQTTProtocol;\n+import org.openhab.binding.irobot.internal.RawMQTT;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.binding.irobot.roomba.RoombaMqttBrokerConnection;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The {@link RoombaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author hkuhn42 - Initial contribution\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Rewrite for 900 series\n+ */\n+@NonNullByDefault\n+public class RoombaHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(RoombaHandler.class);\n+    private final ExecutorService singleThread = Executors.newSingleThreadExecutor();\n+    private static final int reconnectDelay = 5; // In seconds\n+    private @Nullable Future<?> reconnectReq;\n+    // Dummy RoombaConfiguration object in order to shut up Eclipse warnings\n+    // The real one is set in initialize()\n+    private RoombaConfiguration config = new RoombaConfiguration();\n+    private @Nullable String blid = null;\n+    private @Nullable RoombaMqttBrokerConnection connection;\n+    private Hashtable<String, State> lastState = new Hashtable<String, State>();\n+    private MQTTProtocol.@Nullable Schedule lastSchedule = null;\n+    private boolean auto_passes = true;\n+    private @Nullable Boolean two_passes = null;\n+    private boolean carpet_boost = true;\n+    private @Nullable Boolean vac_high = null;\n+    private boolean isPaused = false;\n+\n+    public RoombaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.trace(\"initialize()\");\n+        config = getConfigAs(RoombaConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+        connect();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.trace(\"dispose()\");\n+\n+        singleThread.execute(() -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk4MDc1OQ=="}, "originalCommit": {"oid": "e9674556c16225cbbe635a06414cbf94eda1ea4c"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjIwNDE4MQ==", "bodyText": "Invoking it asynchronsously doesn't prevent start() and stop() to be run concurrently. You could make the two methods synchronized in RoombaMqttBrokerConnection to achieve this.", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r512204181", "createdAt": "2020-10-26T19:09:40Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.handler;\n+\n+import static org.openhab.binding.irobot.IRobotBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Hashtable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.internal.MQTTProtocol;\n+import org.openhab.binding.irobot.internal.RawMQTT;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.binding.irobot.roomba.RoombaMqttBrokerConnection;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The {@link RoombaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author hkuhn42 - Initial contribution\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Rewrite for 900 series\n+ */\n+@NonNullByDefault\n+public class RoombaHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(RoombaHandler.class);\n+    private final ExecutorService singleThread = Executors.newSingleThreadExecutor();\n+    private static final int reconnectDelay = 5; // In seconds\n+    private @Nullable Future<?> reconnectReq;\n+    // Dummy RoombaConfiguration object in order to shut up Eclipse warnings\n+    // The real one is set in initialize()\n+    private RoombaConfiguration config = new RoombaConfiguration();\n+    private @Nullable String blid = null;\n+    private @Nullable RoombaMqttBrokerConnection connection;\n+    private Hashtable<String, State> lastState = new Hashtable<String, State>();\n+    private MQTTProtocol.@Nullable Schedule lastSchedule = null;\n+    private boolean auto_passes = true;\n+    private @Nullable Boolean two_passes = null;\n+    private boolean carpet_boost = true;\n+    private @Nullable Boolean vac_high = null;\n+    private boolean isPaused = false;\n+\n+    public RoombaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.trace(\"initialize()\");\n+        config = getConfigAs(RoombaConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+        connect();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.trace(\"dispose()\");\n+\n+        singleThread.execute(() -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk4MDc1OQ=="}, "originalCommit": {"oid": "e9674556c16225cbbe635a06414cbf94eda1ea4c"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjkxOTYzNg==", "bodyText": "How comes? They are called only from within singleThreadExecutor. It's supposed to be single thread, isn't it ?", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r512919636", "createdAt": "2020-10-27T18:09:17Z", "author": {"login": "Sonic-Amiga"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.handler;\n+\n+import static org.openhab.binding.irobot.IRobotBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Hashtable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.internal.MQTTProtocol;\n+import org.openhab.binding.irobot.internal.RawMQTT;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.binding.irobot.roomba.RoombaMqttBrokerConnection;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The {@link RoombaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author hkuhn42 - Initial contribution\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Rewrite for 900 series\n+ */\n+@NonNullByDefault\n+public class RoombaHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(RoombaHandler.class);\n+    private final ExecutorService singleThread = Executors.newSingleThreadExecutor();\n+    private static final int reconnectDelay = 5; // In seconds\n+    private @Nullable Future<?> reconnectReq;\n+    // Dummy RoombaConfiguration object in order to shut up Eclipse warnings\n+    // The real one is set in initialize()\n+    private RoombaConfiguration config = new RoombaConfiguration();\n+    private @Nullable String blid = null;\n+    private @Nullable RoombaMqttBrokerConnection connection;\n+    private Hashtable<String, State> lastState = new Hashtable<String, State>();\n+    private MQTTProtocol.@Nullable Schedule lastSchedule = null;\n+    private boolean auto_passes = true;\n+    private @Nullable Boolean two_passes = null;\n+    private boolean carpet_boost = true;\n+    private @Nullable Boolean vac_high = null;\n+    private boolean isPaused = false;\n+\n+    public RoombaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.trace(\"initialize()\");\n+        config = getConfigAs(RoombaConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+        connect();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.trace(\"dispose()\");\n+\n+        singleThread.execute(() -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk4MDc1OQ=="}, "originalCommit": {"oid": "e9674556c16225cbbe635a06414cbf94eda1ea4c"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTYxMjg5Ng==", "bodyText": "You're right, but spawning a thread only to achieve synchronization is a bit unreasonable. Bindings should only create new threads if necessary. In this case you could simply add the synchronized modifier to the methods you want to synchronize.", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r515612896", "createdAt": "2020-11-01T11:58:55Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.handler;\n+\n+import static org.openhab.binding.irobot.IRobotBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Hashtable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.internal.MQTTProtocol;\n+import org.openhab.binding.irobot.internal.RawMQTT;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.binding.irobot.roomba.RoombaMqttBrokerConnection;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The {@link RoombaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author hkuhn42 - Initial contribution\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Rewrite for 900 series\n+ */\n+@NonNullByDefault\n+public class RoombaHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(RoombaHandler.class);\n+    private final ExecutorService singleThread = Executors.newSingleThreadExecutor();\n+    private static final int reconnectDelay = 5; // In seconds\n+    private @Nullable Future<?> reconnectReq;\n+    // Dummy RoombaConfiguration object in order to shut up Eclipse warnings\n+    // The real one is set in initialize()\n+    private RoombaConfiguration config = new RoombaConfiguration();\n+    private @Nullable String blid = null;\n+    private @Nullable RoombaMqttBrokerConnection connection;\n+    private Hashtable<String, State> lastState = new Hashtable<String, State>();\n+    private MQTTProtocol.@Nullable Schedule lastSchedule = null;\n+    private boolean auto_passes = true;\n+    private @Nullable Boolean two_passes = null;\n+    private boolean carpet_boost = true;\n+    private @Nullable Boolean vac_high = null;\n+    private boolean isPaused = false;\n+\n+    public RoombaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.trace(\"initialize()\");\n+        config = getConfigAs(RoombaConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+        connect();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.trace(\"dispose()\");\n+\n+        singleThread.execute(() -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk4MDc1OQ=="}, "originalCommit": {"oid": "e9674556c16225cbbe635a06414cbf94eda1ea4c"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDgwNDQwOQ==", "bodyText": "As far as i understand, scheduler provided by the base class does the same, but it can run more than one thread if it feels up to, as it doesn't guarantee any ordering of scheduled tasks. But OK, as you wish, here's your synchronized, let's learn some java :)", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r520804409", "createdAt": "2020-11-10T19:01:39Z", "author": {"login": "Sonic-Amiga"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.handler;\n+\n+import static org.openhab.binding.irobot.IRobotBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Hashtable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.internal.MQTTProtocol;\n+import org.openhab.binding.irobot.internal.RawMQTT;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.binding.irobot.roomba.RoombaMqttBrokerConnection;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The {@link RoombaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author hkuhn42 - Initial contribution\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Rewrite for 900 series\n+ */\n+@NonNullByDefault\n+public class RoombaHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(RoombaHandler.class);\n+    private final ExecutorService singleThread = Executors.newSingleThreadExecutor();\n+    private static final int reconnectDelay = 5; // In seconds\n+    private @Nullable Future<?> reconnectReq;\n+    // Dummy RoombaConfiguration object in order to shut up Eclipse warnings\n+    // The real one is set in initialize()\n+    private RoombaConfiguration config = new RoombaConfiguration();\n+    private @Nullable String blid = null;\n+    private @Nullable RoombaMqttBrokerConnection connection;\n+    private Hashtable<String, State> lastState = new Hashtable<String, State>();\n+    private MQTTProtocol.@Nullable Schedule lastSchedule = null;\n+    private boolean auto_passes = true;\n+    private @Nullable Boolean two_passes = null;\n+    private boolean carpet_boost = true;\n+    private @Nullable Boolean vac_high = null;\n+    private boolean isPaused = false;\n+\n+    public RoombaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.trace(\"initialize()\");\n+        config = getConfigAs(RoombaConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+        connect();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.trace(\"dispose()\");\n+\n+        singleThread.execute(() -> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk4MDc1OQ=="}, "originalCommit": {"oid": "e9674556c16225cbbe635a06414cbf94eda1ea4c"}, "originalPosition": 101}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMDk0NDA2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNTo1NjoyOFrOHnT6bw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QxODoxNjowNlrOHpKb0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk4Mjc2Nw==", "bodyText": "You could invoke equals() directly on command. No need to call toString().", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r510982767", "createdAt": "2020-10-23T15:56:28Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.handler;\n+\n+import static org.openhab.binding.irobot.IRobotBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Hashtable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.internal.MQTTProtocol;\n+import org.openhab.binding.irobot.internal.RawMQTT;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.binding.irobot.roomba.RoombaMqttBrokerConnection;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The {@link RoombaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author hkuhn42 - Initial contribution\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Rewrite for 900 series\n+ */\n+@NonNullByDefault\n+public class RoombaHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(RoombaHandler.class);\n+    private final ExecutorService singleThread = Executors.newSingleThreadExecutor();\n+    private static final int reconnectDelay = 5; // In seconds\n+    private @Nullable Future<?> reconnectReq;\n+    // Dummy RoombaConfiguration object in order to shut up Eclipse warnings\n+    // The real one is set in initialize()\n+    private RoombaConfiguration config = new RoombaConfiguration();\n+    private @Nullable String blid = null;\n+    private @Nullable RoombaMqttBrokerConnection connection;\n+    private Hashtable<String, State> lastState = new Hashtable<String, State>();\n+    private MQTTProtocol.@Nullable Schedule lastSchedule = null;\n+    private boolean auto_passes = true;\n+    private @Nullable Boolean two_passes = null;\n+    private boolean carpet_boost = true;\n+    private @Nullable Boolean vac_high = null;\n+    private boolean isPaused = false;\n+\n+    public RoombaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.trace(\"initialize()\");\n+        config = getConfigAs(RoombaConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+        connect();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.trace(\"dispose()\");\n+\n+        singleThread.execute(() -> {\n+            if (reconnectReq != null) {\n+                reconnectReq.cancel(false);\n+                reconnectReq = null;\n+            }\n+\n+            if (connection != null) {\n+                connection.stop();\n+                connection = null;\n+            }\n+        });\n+    }\n+\n+    // lastState.get() can return null if the key is not found according\n+    // to the documentation\n+    @SuppressWarnings(\"null\")\n+    private void handleRefresh(String ch) {\n+        State value = lastState.get(ch);\n+\n+        if (value != null) {\n+            updateState(ch, value);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String ch = channelUID.getId();\n+        if (command instanceof RefreshType) {\n+            handleRefresh(ch);\n+            return;\n+        }\n+\n+        if (ch.equals(CHANNEL_COMMAND)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+\n+                if (cmd.equals(CMD_CLEAN)) {\n+                    cmd = isPaused ? \"resume\" : \"start\";\n+                }\n+\n+                sendRequest(new MQTTProtocol.CommandRequest(cmd));\n+            }\n+        } else if (ch.startsWith(CHANNEL_SCHED_SWITCH_PREFIX)) {\n+            MQTTProtocol.Schedule schedule = lastSchedule;\n+\n+            // Schedule can only be updated in a bulk, so we have to store current\n+            // schedule and modify components.\n+            if (command instanceof OnOffType && schedule != null && schedule.cycle != null) {\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    if (ch.equals(CHANNEL_SCHED_SWITCH[i])) {\n+                        MQTTProtocol.Schedule newSchedule = new MQTTProtocol.Schedule(schedule.cycle);\n+\n+                        newSchedule.enableCycle(i, command.equals(OnOffType.ON));\n+                        sendSchedule(newSchedule);\n+                        break;\n+                    }\n+                }\n+            }\n+        } else if (ch.equals(CHANNEL_SCHEDULE)) {\n+            if (command instanceof DecimalType) {\n+                int bitmask = ((DecimalType) command).intValue();\n+                JsonArray cycle = new JsonArray();\n+\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    enableCycle(cycle, i, (bitmask & (1 << i)) != 0);\n+                }\n+\n+                sendSchedule(new MQTTProtocol.Schedule(bitmask));\n+            }\n+        } else if (ch.equals(CHANNEL_EDGE_CLEAN)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.OpenOnly(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_ALWAYS_FINISH)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.BinPause(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_POWER_BOOST)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+                sendDelta(new MQTTProtocol.PowerBoost(cmd.equals(BOOST_AUTO), cmd.equals(BOOST_PERFORMANCE)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9674556c16225cbbe635a06414cbf94eda1ea4c"}, "originalPosition": 181}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTQwMTQ4OQ==", "bodyText": "Thanks for hinting, i was not sure.", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r511401489", "createdAt": "2020-10-24T11:14:04Z", "author": {"login": "Sonic-Amiga"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.handler;\n+\n+import static org.openhab.binding.irobot.IRobotBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Hashtable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.internal.MQTTProtocol;\n+import org.openhab.binding.irobot.internal.RawMQTT;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.binding.irobot.roomba.RoombaMqttBrokerConnection;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The {@link RoombaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author hkuhn42 - Initial contribution\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Rewrite for 900 series\n+ */\n+@NonNullByDefault\n+public class RoombaHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(RoombaHandler.class);\n+    private final ExecutorService singleThread = Executors.newSingleThreadExecutor();\n+    private static final int reconnectDelay = 5; // In seconds\n+    private @Nullable Future<?> reconnectReq;\n+    // Dummy RoombaConfiguration object in order to shut up Eclipse warnings\n+    // The real one is set in initialize()\n+    private RoombaConfiguration config = new RoombaConfiguration();\n+    private @Nullable String blid = null;\n+    private @Nullable RoombaMqttBrokerConnection connection;\n+    private Hashtable<String, State> lastState = new Hashtable<String, State>();\n+    private MQTTProtocol.@Nullable Schedule lastSchedule = null;\n+    private boolean auto_passes = true;\n+    private @Nullable Boolean two_passes = null;\n+    private boolean carpet_boost = true;\n+    private @Nullable Boolean vac_high = null;\n+    private boolean isPaused = false;\n+\n+    public RoombaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.trace(\"initialize()\");\n+        config = getConfigAs(RoombaConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+        connect();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.trace(\"dispose()\");\n+\n+        singleThread.execute(() -> {\n+            if (reconnectReq != null) {\n+                reconnectReq.cancel(false);\n+                reconnectReq = null;\n+            }\n+\n+            if (connection != null) {\n+                connection.stop();\n+                connection = null;\n+            }\n+        });\n+    }\n+\n+    // lastState.get() can return null if the key is not found according\n+    // to the documentation\n+    @SuppressWarnings(\"null\")\n+    private void handleRefresh(String ch) {\n+        State value = lastState.get(ch);\n+\n+        if (value != null) {\n+            updateState(ch, value);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String ch = channelUID.getId();\n+        if (command instanceof RefreshType) {\n+            handleRefresh(ch);\n+            return;\n+        }\n+\n+        if (ch.equals(CHANNEL_COMMAND)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+\n+                if (cmd.equals(CMD_CLEAN)) {\n+                    cmd = isPaused ? \"resume\" : \"start\";\n+                }\n+\n+                sendRequest(new MQTTProtocol.CommandRequest(cmd));\n+            }\n+        } else if (ch.startsWith(CHANNEL_SCHED_SWITCH_PREFIX)) {\n+            MQTTProtocol.Schedule schedule = lastSchedule;\n+\n+            // Schedule can only be updated in a bulk, so we have to store current\n+            // schedule and modify components.\n+            if (command instanceof OnOffType && schedule != null && schedule.cycle != null) {\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    if (ch.equals(CHANNEL_SCHED_SWITCH[i])) {\n+                        MQTTProtocol.Schedule newSchedule = new MQTTProtocol.Schedule(schedule.cycle);\n+\n+                        newSchedule.enableCycle(i, command.equals(OnOffType.ON));\n+                        sendSchedule(newSchedule);\n+                        break;\n+                    }\n+                }\n+            }\n+        } else if (ch.equals(CHANNEL_SCHEDULE)) {\n+            if (command instanceof DecimalType) {\n+                int bitmask = ((DecimalType) command).intValue();\n+                JsonArray cycle = new JsonArray();\n+\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    enableCycle(cycle, i, (bitmask & (1 << i)) != 0);\n+                }\n+\n+                sendSchedule(new MQTTProtocol.Schedule(bitmask));\n+            }\n+        } else if (ch.equals(CHANNEL_EDGE_CLEAN)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.OpenOnly(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_ALWAYS_FINISH)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.BinPause(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_POWER_BOOST)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+                sendDelta(new MQTTProtocol.PowerBoost(cmd.equals(BOOST_AUTO), cmd.equals(BOOST_PERFORMANCE)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk4Mjc2Nw=="}, "originalCommit": {"oid": "e9674556c16225cbbe635a06414cbf94eda1ea4c"}, "originalPosition": 181}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTQzMTAzMw==", "bodyText": "By the way, Eclipse starts complaining:\nUnlikely argument type for equals(): String seems to be unrelated to Command", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r511431033", "createdAt": "2020-10-24T12:33:05Z", "author": {"login": "Sonic-Amiga"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.handler;\n+\n+import static org.openhab.binding.irobot.IRobotBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Hashtable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.internal.MQTTProtocol;\n+import org.openhab.binding.irobot.internal.RawMQTT;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.binding.irobot.roomba.RoombaMqttBrokerConnection;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The {@link RoombaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author hkuhn42 - Initial contribution\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Rewrite for 900 series\n+ */\n+@NonNullByDefault\n+public class RoombaHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(RoombaHandler.class);\n+    private final ExecutorService singleThread = Executors.newSingleThreadExecutor();\n+    private static final int reconnectDelay = 5; // In seconds\n+    private @Nullable Future<?> reconnectReq;\n+    // Dummy RoombaConfiguration object in order to shut up Eclipse warnings\n+    // The real one is set in initialize()\n+    private RoombaConfiguration config = new RoombaConfiguration();\n+    private @Nullable String blid = null;\n+    private @Nullable RoombaMqttBrokerConnection connection;\n+    private Hashtable<String, State> lastState = new Hashtable<String, State>();\n+    private MQTTProtocol.@Nullable Schedule lastSchedule = null;\n+    private boolean auto_passes = true;\n+    private @Nullable Boolean two_passes = null;\n+    private boolean carpet_boost = true;\n+    private @Nullable Boolean vac_high = null;\n+    private boolean isPaused = false;\n+\n+    public RoombaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.trace(\"initialize()\");\n+        config = getConfigAs(RoombaConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+        connect();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.trace(\"dispose()\");\n+\n+        singleThread.execute(() -> {\n+            if (reconnectReq != null) {\n+                reconnectReq.cancel(false);\n+                reconnectReq = null;\n+            }\n+\n+            if (connection != null) {\n+                connection.stop();\n+                connection = null;\n+            }\n+        });\n+    }\n+\n+    // lastState.get() can return null if the key is not found according\n+    // to the documentation\n+    @SuppressWarnings(\"null\")\n+    private void handleRefresh(String ch) {\n+        State value = lastState.get(ch);\n+\n+        if (value != null) {\n+            updateState(ch, value);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String ch = channelUID.getId();\n+        if (command instanceof RefreshType) {\n+            handleRefresh(ch);\n+            return;\n+        }\n+\n+        if (ch.equals(CHANNEL_COMMAND)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+\n+                if (cmd.equals(CMD_CLEAN)) {\n+                    cmd = isPaused ? \"resume\" : \"start\";\n+                }\n+\n+                sendRequest(new MQTTProtocol.CommandRequest(cmd));\n+            }\n+        } else if (ch.startsWith(CHANNEL_SCHED_SWITCH_PREFIX)) {\n+            MQTTProtocol.Schedule schedule = lastSchedule;\n+\n+            // Schedule can only be updated in a bulk, so we have to store current\n+            // schedule and modify components.\n+            if (command instanceof OnOffType && schedule != null && schedule.cycle != null) {\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    if (ch.equals(CHANNEL_SCHED_SWITCH[i])) {\n+                        MQTTProtocol.Schedule newSchedule = new MQTTProtocol.Schedule(schedule.cycle);\n+\n+                        newSchedule.enableCycle(i, command.equals(OnOffType.ON));\n+                        sendSchedule(newSchedule);\n+                        break;\n+                    }\n+                }\n+            }\n+        } else if (ch.equals(CHANNEL_SCHEDULE)) {\n+            if (command instanceof DecimalType) {\n+                int bitmask = ((DecimalType) command).intValue();\n+                JsonArray cycle = new JsonArray();\n+\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    enableCycle(cycle, i, (bitmask & (1 << i)) != 0);\n+                }\n+\n+                sendSchedule(new MQTTProtocol.Schedule(bitmask));\n+            }\n+        } else if (ch.equals(CHANNEL_EDGE_CLEAN)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.OpenOnly(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_ALWAYS_FINISH)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.BinPause(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_POWER_BOOST)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+                sendDelta(new MQTTProtocol.PowerBoost(cmd.equals(BOOST_AUTO), cmd.equals(BOOST_PERFORMANCE)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk4Mjc2Nw=="}, "originalCommit": {"oid": "e9674556c16225cbbe635a06414cbf94eda1ea4c"}, "originalPosition": 181}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjIwODE1MQ==", "bodyText": "Yes, I see. But it's only an information, not a warning.\nYou could remove the instanceof check, too.", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r512208151", "createdAt": "2020-10-26T19:16:52Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.handler;\n+\n+import static org.openhab.binding.irobot.IRobotBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Hashtable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.internal.MQTTProtocol;\n+import org.openhab.binding.irobot.internal.RawMQTT;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.binding.irobot.roomba.RoombaMqttBrokerConnection;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The {@link RoombaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author hkuhn42 - Initial contribution\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Rewrite for 900 series\n+ */\n+@NonNullByDefault\n+public class RoombaHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(RoombaHandler.class);\n+    private final ExecutorService singleThread = Executors.newSingleThreadExecutor();\n+    private static final int reconnectDelay = 5; // In seconds\n+    private @Nullable Future<?> reconnectReq;\n+    // Dummy RoombaConfiguration object in order to shut up Eclipse warnings\n+    // The real one is set in initialize()\n+    private RoombaConfiguration config = new RoombaConfiguration();\n+    private @Nullable String blid = null;\n+    private @Nullable RoombaMqttBrokerConnection connection;\n+    private Hashtable<String, State> lastState = new Hashtable<String, State>();\n+    private MQTTProtocol.@Nullable Schedule lastSchedule = null;\n+    private boolean auto_passes = true;\n+    private @Nullable Boolean two_passes = null;\n+    private boolean carpet_boost = true;\n+    private @Nullable Boolean vac_high = null;\n+    private boolean isPaused = false;\n+\n+    public RoombaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.trace(\"initialize()\");\n+        config = getConfigAs(RoombaConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+        connect();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.trace(\"dispose()\");\n+\n+        singleThread.execute(() -> {\n+            if (reconnectReq != null) {\n+                reconnectReq.cancel(false);\n+                reconnectReq = null;\n+            }\n+\n+            if (connection != null) {\n+                connection.stop();\n+                connection = null;\n+            }\n+        });\n+    }\n+\n+    // lastState.get() can return null if the key is not found according\n+    // to the documentation\n+    @SuppressWarnings(\"null\")\n+    private void handleRefresh(String ch) {\n+        State value = lastState.get(ch);\n+\n+        if (value != null) {\n+            updateState(ch, value);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String ch = channelUID.getId();\n+        if (command instanceof RefreshType) {\n+            handleRefresh(ch);\n+            return;\n+        }\n+\n+        if (ch.equals(CHANNEL_COMMAND)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+\n+                if (cmd.equals(CMD_CLEAN)) {\n+                    cmd = isPaused ? \"resume\" : \"start\";\n+                }\n+\n+                sendRequest(new MQTTProtocol.CommandRequest(cmd));\n+            }\n+        } else if (ch.startsWith(CHANNEL_SCHED_SWITCH_PREFIX)) {\n+            MQTTProtocol.Schedule schedule = lastSchedule;\n+\n+            // Schedule can only be updated in a bulk, so we have to store current\n+            // schedule and modify components.\n+            if (command instanceof OnOffType && schedule != null && schedule.cycle != null) {\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    if (ch.equals(CHANNEL_SCHED_SWITCH[i])) {\n+                        MQTTProtocol.Schedule newSchedule = new MQTTProtocol.Schedule(schedule.cycle);\n+\n+                        newSchedule.enableCycle(i, command.equals(OnOffType.ON));\n+                        sendSchedule(newSchedule);\n+                        break;\n+                    }\n+                }\n+            }\n+        } else if (ch.equals(CHANNEL_SCHEDULE)) {\n+            if (command instanceof DecimalType) {\n+                int bitmask = ((DecimalType) command).intValue();\n+                JsonArray cycle = new JsonArray();\n+\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    enableCycle(cycle, i, (bitmask & (1 << i)) != 0);\n+                }\n+\n+                sendSchedule(new MQTTProtocol.Schedule(bitmask));\n+            }\n+        } else if (ch.equals(CHANNEL_EDGE_CLEAN)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.OpenOnly(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_ALWAYS_FINISH)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.BinPause(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_POWER_BOOST)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+                sendDelta(new MQTTProtocol.PowerBoost(cmd.equals(BOOST_AUTO), cmd.equals(BOOST_PERFORMANCE)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk4Mjc2Nw=="}, "originalCommit": {"oid": "e9674556c16225cbbe635a06414cbf94eda1ea4c"}, "originalPosition": 181}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjkyNDYyNw==", "bodyText": "Done", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r512924627", "createdAt": "2020-10-27T18:16:06Z", "author": {"login": "Sonic-Amiga"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.handler;\n+\n+import static org.openhab.binding.irobot.IRobotBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Hashtable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.internal.MQTTProtocol;\n+import org.openhab.binding.irobot.internal.RawMQTT;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.binding.irobot.roomba.RoombaMqttBrokerConnection;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The {@link RoombaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author hkuhn42 - Initial contribution\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Rewrite for 900 series\n+ */\n+@NonNullByDefault\n+public class RoombaHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(RoombaHandler.class);\n+    private final ExecutorService singleThread = Executors.newSingleThreadExecutor();\n+    private static final int reconnectDelay = 5; // In seconds\n+    private @Nullable Future<?> reconnectReq;\n+    // Dummy RoombaConfiguration object in order to shut up Eclipse warnings\n+    // The real one is set in initialize()\n+    private RoombaConfiguration config = new RoombaConfiguration();\n+    private @Nullable String blid = null;\n+    private @Nullable RoombaMqttBrokerConnection connection;\n+    private Hashtable<String, State> lastState = new Hashtable<String, State>();\n+    private MQTTProtocol.@Nullable Schedule lastSchedule = null;\n+    private boolean auto_passes = true;\n+    private @Nullable Boolean two_passes = null;\n+    private boolean carpet_boost = true;\n+    private @Nullable Boolean vac_high = null;\n+    private boolean isPaused = false;\n+\n+    public RoombaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.trace(\"initialize()\");\n+        config = getConfigAs(RoombaConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+        connect();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.trace(\"dispose()\");\n+\n+        singleThread.execute(() -> {\n+            if (reconnectReq != null) {\n+                reconnectReq.cancel(false);\n+                reconnectReq = null;\n+            }\n+\n+            if (connection != null) {\n+                connection.stop();\n+                connection = null;\n+            }\n+        });\n+    }\n+\n+    // lastState.get() can return null if the key is not found according\n+    // to the documentation\n+    @SuppressWarnings(\"null\")\n+    private void handleRefresh(String ch) {\n+        State value = lastState.get(ch);\n+\n+        if (value != null) {\n+            updateState(ch, value);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String ch = channelUID.getId();\n+        if (command instanceof RefreshType) {\n+            handleRefresh(ch);\n+            return;\n+        }\n+\n+        if (ch.equals(CHANNEL_COMMAND)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+\n+                if (cmd.equals(CMD_CLEAN)) {\n+                    cmd = isPaused ? \"resume\" : \"start\";\n+                }\n+\n+                sendRequest(new MQTTProtocol.CommandRequest(cmd));\n+            }\n+        } else if (ch.startsWith(CHANNEL_SCHED_SWITCH_PREFIX)) {\n+            MQTTProtocol.Schedule schedule = lastSchedule;\n+\n+            // Schedule can only be updated in a bulk, so we have to store current\n+            // schedule and modify components.\n+            if (command instanceof OnOffType && schedule != null && schedule.cycle != null) {\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    if (ch.equals(CHANNEL_SCHED_SWITCH[i])) {\n+                        MQTTProtocol.Schedule newSchedule = new MQTTProtocol.Schedule(schedule.cycle);\n+\n+                        newSchedule.enableCycle(i, command.equals(OnOffType.ON));\n+                        sendSchedule(newSchedule);\n+                        break;\n+                    }\n+                }\n+            }\n+        } else if (ch.equals(CHANNEL_SCHEDULE)) {\n+            if (command instanceof DecimalType) {\n+                int bitmask = ((DecimalType) command).intValue();\n+                JsonArray cycle = new JsonArray();\n+\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    enableCycle(cycle, i, (bitmask & (1 << i)) != 0);\n+                }\n+\n+                sendSchedule(new MQTTProtocol.Schedule(bitmask));\n+            }\n+        } else if (ch.equals(CHANNEL_EDGE_CLEAN)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.OpenOnly(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_ALWAYS_FINISH)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.BinPause(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_POWER_BOOST)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+                sendDelta(new MQTTProtocol.PowerBoost(cmd.equals(BOOST_AUTO), cmd.equals(BOOST_PERFORMANCE)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk4Mjc2Nw=="}, "originalCommit": {"oid": "e9674556c16225cbbe635a06414cbf94eda1ea4c"}, "originalPosition": 181}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMDk0ODM0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNTo1NzozN1rOHnT9Mg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxOToxMDo0NFrOHoefvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk4MzQ3NA==", "bodyText": "You could store the Gson object to a final member variable to save resources.", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r510983474", "createdAt": "2020-10-23T15:57:37Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.handler;\n+\n+import static org.openhab.binding.irobot.IRobotBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Hashtable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.internal.MQTTProtocol;\n+import org.openhab.binding.irobot.internal.RawMQTT;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.binding.irobot.roomba.RoombaMqttBrokerConnection;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The {@link RoombaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author hkuhn42 - Initial contribution\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Rewrite for 900 series\n+ */\n+@NonNullByDefault\n+public class RoombaHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(RoombaHandler.class);\n+    private final ExecutorService singleThread = Executors.newSingleThreadExecutor();\n+    private static final int reconnectDelay = 5; // In seconds\n+    private @Nullable Future<?> reconnectReq;\n+    // Dummy RoombaConfiguration object in order to shut up Eclipse warnings\n+    // The real one is set in initialize()\n+    private RoombaConfiguration config = new RoombaConfiguration();\n+    private @Nullable String blid = null;\n+    private @Nullable RoombaMqttBrokerConnection connection;\n+    private Hashtable<String, State> lastState = new Hashtable<String, State>();\n+    private MQTTProtocol.@Nullable Schedule lastSchedule = null;\n+    private boolean auto_passes = true;\n+    private @Nullable Boolean two_passes = null;\n+    private boolean carpet_boost = true;\n+    private @Nullable Boolean vac_high = null;\n+    private boolean isPaused = false;\n+\n+    public RoombaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.trace(\"initialize()\");\n+        config = getConfigAs(RoombaConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+        connect();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.trace(\"dispose()\");\n+\n+        singleThread.execute(() -> {\n+            if (reconnectReq != null) {\n+                reconnectReq.cancel(false);\n+                reconnectReq = null;\n+            }\n+\n+            if (connection != null) {\n+                connection.stop();\n+                connection = null;\n+            }\n+        });\n+    }\n+\n+    // lastState.get() can return null if the key is not found according\n+    // to the documentation\n+    @SuppressWarnings(\"null\")\n+    private void handleRefresh(String ch) {\n+        State value = lastState.get(ch);\n+\n+        if (value != null) {\n+            updateState(ch, value);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String ch = channelUID.getId();\n+        if (command instanceof RefreshType) {\n+            handleRefresh(ch);\n+            return;\n+        }\n+\n+        if (ch.equals(CHANNEL_COMMAND)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+\n+                if (cmd.equals(CMD_CLEAN)) {\n+                    cmd = isPaused ? \"resume\" : \"start\";\n+                }\n+\n+                sendRequest(new MQTTProtocol.CommandRequest(cmd));\n+            }\n+        } else if (ch.startsWith(CHANNEL_SCHED_SWITCH_PREFIX)) {\n+            MQTTProtocol.Schedule schedule = lastSchedule;\n+\n+            // Schedule can only be updated in a bulk, so we have to store current\n+            // schedule and modify components.\n+            if (command instanceof OnOffType && schedule != null && schedule.cycle != null) {\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    if (ch.equals(CHANNEL_SCHED_SWITCH[i])) {\n+                        MQTTProtocol.Schedule newSchedule = new MQTTProtocol.Schedule(schedule.cycle);\n+\n+                        newSchedule.enableCycle(i, command.equals(OnOffType.ON));\n+                        sendSchedule(newSchedule);\n+                        break;\n+                    }\n+                }\n+            }\n+        } else if (ch.equals(CHANNEL_SCHEDULE)) {\n+            if (command instanceof DecimalType) {\n+                int bitmask = ((DecimalType) command).intValue();\n+                JsonArray cycle = new JsonArray();\n+\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    enableCycle(cycle, i, (bitmask & (1 << i)) != 0);\n+                }\n+\n+                sendSchedule(new MQTTProtocol.Schedule(bitmask));\n+            }\n+        } else if (ch.equals(CHANNEL_EDGE_CLEAN)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.OpenOnly(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_ALWAYS_FINISH)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.BinPause(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_POWER_BOOST)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+                sendDelta(new MQTTProtocol.PowerBoost(cmd.equals(BOOST_AUTO), cmd.equals(BOOST_PERFORMANCE)));\n+            }\n+        } else if (ch.equals(CHANNEL_CLEAN_PASSES)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+                sendDelta(new MQTTProtocol.CleanPasses(!cmd.equals(PASSES_AUTO), cmd.equals(PASSES_2)));\n+            }\n+        }\n+    }\n+\n+    private void enableCycle(JsonArray cycle, int i, boolean enable) {\n+        JsonPrimitive value = new JsonPrimitive(enable ? \"start\" : \"none\");\n+        cycle.set(i, value);\n+    }\n+\n+    private void sendSchedule(MQTTProtocol.Schedule schedule) {\n+        sendDelta(new MQTTProtocol.CleanSchedule(schedule));\n+    }\n+\n+    private void sendDelta(MQTTProtocol.StateValue state) {\n+        sendRequest(new MQTTProtocol.DeltaRequest(state));\n+    }\n+\n+    private void sendRequest(MQTTProtocol.Request request) {\n+        RoombaMqttBrokerConnection conn = connection;\n+\n+        if (conn != null) {\n+            String json = new Gson().toJson(request);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9674556c16225cbbe635a06414cbf94eda1ea4c"}, "originalPosition": 208}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTQwMTk1NQ==", "bodyText": "Is it thread-safe, just in case ?", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r511401955", "createdAt": "2020-10-24T11:15:19Z", "author": {"login": "Sonic-Amiga"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.handler;\n+\n+import static org.openhab.binding.irobot.IRobotBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Hashtable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.internal.MQTTProtocol;\n+import org.openhab.binding.irobot.internal.RawMQTT;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.binding.irobot.roomba.RoombaMqttBrokerConnection;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The {@link RoombaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author hkuhn42 - Initial contribution\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Rewrite for 900 series\n+ */\n+@NonNullByDefault\n+public class RoombaHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(RoombaHandler.class);\n+    private final ExecutorService singleThread = Executors.newSingleThreadExecutor();\n+    private static final int reconnectDelay = 5; // In seconds\n+    private @Nullable Future<?> reconnectReq;\n+    // Dummy RoombaConfiguration object in order to shut up Eclipse warnings\n+    // The real one is set in initialize()\n+    private RoombaConfiguration config = new RoombaConfiguration();\n+    private @Nullable String blid = null;\n+    private @Nullable RoombaMqttBrokerConnection connection;\n+    private Hashtable<String, State> lastState = new Hashtable<String, State>();\n+    private MQTTProtocol.@Nullable Schedule lastSchedule = null;\n+    private boolean auto_passes = true;\n+    private @Nullable Boolean two_passes = null;\n+    private boolean carpet_boost = true;\n+    private @Nullable Boolean vac_high = null;\n+    private boolean isPaused = false;\n+\n+    public RoombaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.trace(\"initialize()\");\n+        config = getConfigAs(RoombaConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+        connect();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.trace(\"dispose()\");\n+\n+        singleThread.execute(() -> {\n+            if (reconnectReq != null) {\n+                reconnectReq.cancel(false);\n+                reconnectReq = null;\n+            }\n+\n+            if (connection != null) {\n+                connection.stop();\n+                connection = null;\n+            }\n+        });\n+    }\n+\n+    // lastState.get() can return null if the key is not found according\n+    // to the documentation\n+    @SuppressWarnings(\"null\")\n+    private void handleRefresh(String ch) {\n+        State value = lastState.get(ch);\n+\n+        if (value != null) {\n+            updateState(ch, value);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String ch = channelUID.getId();\n+        if (command instanceof RefreshType) {\n+            handleRefresh(ch);\n+            return;\n+        }\n+\n+        if (ch.equals(CHANNEL_COMMAND)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+\n+                if (cmd.equals(CMD_CLEAN)) {\n+                    cmd = isPaused ? \"resume\" : \"start\";\n+                }\n+\n+                sendRequest(new MQTTProtocol.CommandRequest(cmd));\n+            }\n+        } else if (ch.startsWith(CHANNEL_SCHED_SWITCH_PREFIX)) {\n+            MQTTProtocol.Schedule schedule = lastSchedule;\n+\n+            // Schedule can only be updated in a bulk, so we have to store current\n+            // schedule and modify components.\n+            if (command instanceof OnOffType && schedule != null && schedule.cycle != null) {\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    if (ch.equals(CHANNEL_SCHED_SWITCH[i])) {\n+                        MQTTProtocol.Schedule newSchedule = new MQTTProtocol.Schedule(schedule.cycle);\n+\n+                        newSchedule.enableCycle(i, command.equals(OnOffType.ON));\n+                        sendSchedule(newSchedule);\n+                        break;\n+                    }\n+                }\n+            }\n+        } else if (ch.equals(CHANNEL_SCHEDULE)) {\n+            if (command instanceof DecimalType) {\n+                int bitmask = ((DecimalType) command).intValue();\n+                JsonArray cycle = new JsonArray();\n+\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    enableCycle(cycle, i, (bitmask & (1 << i)) != 0);\n+                }\n+\n+                sendSchedule(new MQTTProtocol.Schedule(bitmask));\n+            }\n+        } else if (ch.equals(CHANNEL_EDGE_CLEAN)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.OpenOnly(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_ALWAYS_FINISH)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.BinPause(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_POWER_BOOST)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+                sendDelta(new MQTTProtocol.PowerBoost(cmd.equals(BOOST_AUTO), cmd.equals(BOOST_PERFORMANCE)));\n+            }\n+        } else if (ch.equals(CHANNEL_CLEAN_PASSES)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+                sendDelta(new MQTTProtocol.CleanPasses(!cmd.equals(PASSES_AUTO), cmd.equals(PASSES_2)));\n+            }\n+        }\n+    }\n+\n+    private void enableCycle(JsonArray cycle, int i, boolean enable) {\n+        JsonPrimitive value = new JsonPrimitive(enable ? \"start\" : \"none\");\n+        cycle.set(i, value);\n+    }\n+\n+    private void sendSchedule(MQTTProtocol.Schedule schedule) {\n+        sendDelta(new MQTTProtocol.CleanSchedule(schedule));\n+    }\n+\n+    private void sendDelta(MQTTProtocol.StateValue state) {\n+        sendRequest(new MQTTProtocol.DeltaRequest(state));\n+    }\n+\n+    private void sendRequest(MQTTProtocol.Request request) {\n+        RoombaMqttBrokerConnection conn = connection;\n+\n+        if (conn != null) {\n+            String json = new Gson().toJson(request);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk4MzQ3NA=="}, "originalCommit": {"oid": "e9674556c16225cbbe635a06414cbf94eda1ea4c"}, "originalPosition": 208}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjIwNDczNQ==", "bodyText": "Yes, it is.", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r512204735", "createdAt": "2020-10-26T19:10:44Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.handler;\n+\n+import static org.openhab.binding.irobot.IRobotBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Hashtable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.internal.MQTTProtocol;\n+import org.openhab.binding.irobot.internal.RawMQTT;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.binding.irobot.roomba.RoombaMqttBrokerConnection;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The {@link RoombaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author hkuhn42 - Initial contribution\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Rewrite for 900 series\n+ */\n+@NonNullByDefault\n+public class RoombaHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(RoombaHandler.class);\n+    private final ExecutorService singleThread = Executors.newSingleThreadExecutor();\n+    private static final int reconnectDelay = 5; // In seconds\n+    private @Nullable Future<?> reconnectReq;\n+    // Dummy RoombaConfiguration object in order to shut up Eclipse warnings\n+    // The real one is set in initialize()\n+    private RoombaConfiguration config = new RoombaConfiguration();\n+    private @Nullable String blid = null;\n+    private @Nullable RoombaMqttBrokerConnection connection;\n+    private Hashtable<String, State> lastState = new Hashtable<String, State>();\n+    private MQTTProtocol.@Nullable Schedule lastSchedule = null;\n+    private boolean auto_passes = true;\n+    private @Nullable Boolean two_passes = null;\n+    private boolean carpet_boost = true;\n+    private @Nullable Boolean vac_high = null;\n+    private boolean isPaused = false;\n+\n+    public RoombaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.trace(\"initialize()\");\n+        config = getConfigAs(RoombaConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+        connect();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.trace(\"dispose()\");\n+\n+        singleThread.execute(() -> {\n+            if (reconnectReq != null) {\n+                reconnectReq.cancel(false);\n+                reconnectReq = null;\n+            }\n+\n+            if (connection != null) {\n+                connection.stop();\n+                connection = null;\n+            }\n+        });\n+    }\n+\n+    // lastState.get() can return null if the key is not found according\n+    // to the documentation\n+    @SuppressWarnings(\"null\")\n+    private void handleRefresh(String ch) {\n+        State value = lastState.get(ch);\n+\n+        if (value != null) {\n+            updateState(ch, value);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String ch = channelUID.getId();\n+        if (command instanceof RefreshType) {\n+            handleRefresh(ch);\n+            return;\n+        }\n+\n+        if (ch.equals(CHANNEL_COMMAND)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+\n+                if (cmd.equals(CMD_CLEAN)) {\n+                    cmd = isPaused ? \"resume\" : \"start\";\n+                }\n+\n+                sendRequest(new MQTTProtocol.CommandRequest(cmd));\n+            }\n+        } else if (ch.startsWith(CHANNEL_SCHED_SWITCH_PREFIX)) {\n+            MQTTProtocol.Schedule schedule = lastSchedule;\n+\n+            // Schedule can only be updated in a bulk, so we have to store current\n+            // schedule and modify components.\n+            if (command instanceof OnOffType && schedule != null && schedule.cycle != null) {\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    if (ch.equals(CHANNEL_SCHED_SWITCH[i])) {\n+                        MQTTProtocol.Schedule newSchedule = new MQTTProtocol.Schedule(schedule.cycle);\n+\n+                        newSchedule.enableCycle(i, command.equals(OnOffType.ON));\n+                        sendSchedule(newSchedule);\n+                        break;\n+                    }\n+                }\n+            }\n+        } else if (ch.equals(CHANNEL_SCHEDULE)) {\n+            if (command instanceof DecimalType) {\n+                int bitmask = ((DecimalType) command).intValue();\n+                JsonArray cycle = new JsonArray();\n+\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    enableCycle(cycle, i, (bitmask & (1 << i)) != 0);\n+                }\n+\n+                sendSchedule(new MQTTProtocol.Schedule(bitmask));\n+            }\n+        } else if (ch.equals(CHANNEL_EDGE_CLEAN)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.OpenOnly(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_ALWAYS_FINISH)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.BinPause(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_POWER_BOOST)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+                sendDelta(new MQTTProtocol.PowerBoost(cmd.equals(BOOST_AUTO), cmd.equals(BOOST_PERFORMANCE)));\n+            }\n+        } else if (ch.equals(CHANNEL_CLEAN_PASSES)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+                sendDelta(new MQTTProtocol.CleanPasses(!cmd.equals(PASSES_AUTO), cmd.equals(PASSES_2)));\n+            }\n+        }\n+    }\n+\n+    private void enableCycle(JsonArray cycle, int i, boolean enable) {\n+        JsonPrimitive value = new JsonPrimitive(enable ? \"start\" : \"none\");\n+        cycle.set(i, value);\n+    }\n+\n+    private void sendSchedule(MQTTProtocol.Schedule schedule) {\n+        sendDelta(new MQTTProtocol.CleanSchedule(schedule));\n+    }\n+\n+    private void sendDelta(MQTTProtocol.StateValue state) {\n+        sendRequest(new MQTTProtocol.DeltaRequest(state));\n+    }\n+\n+    private void sendRequest(MQTTProtocol.Request request) {\n+        RoombaMqttBrokerConnection conn = connection;\n+\n+        if (conn != null) {\n+            String json = new Gson().toJson(request);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk4MzQ3NA=="}, "originalCommit": {"oid": "e9674556c16225cbbe635a06414cbf94eda1ea4c"}, "originalPosition": 208}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMDk0OTc0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNTo1Nzo1N1rOHnT-DQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QxODoxMToyNVrOHpKOlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk4MzY5Mw==", "bodyText": "See above. Logging to info.", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r510983693", "createdAt": "2020-10-23T15:57:57Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.handler;\n+\n+import static org.openhab.binding.irobot.IRobotBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Hashtable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.internal.MQTTProtocol;\n+import org.openhab.binding.irobot.internal.RawMQTT;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.binding.irobot.roomba.RoombaMqttBrokerConnection;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The {@link RoombaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author hkuhn42 - Initial contribution\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Rewrite for 900 series\n+ */\n+@NonNullByDefault\n+public class RoombaHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(RoombaHandler.class);\n+    private final ExecutorService singleThread = Executors.newSingleThreadExecutor();\n+    private static final int reconnectDelay = 5; // In seconds\n+    private @Nullable Future<?> reconnectReq;\n+    // Dummy RoombaConfiguration object in order to shut up Eclipse warnings\n+    // The real one is set in initialize()\n+    private RoombaConfiguration config = new RoombaConfiguration();\n+    private @Nullable String blid = null;\n+    private @Nullable RoombaMqttBrokerConnection connection;\n+    private Hashtable<String, State> lastState = new Hashtable<String, State>();\n+    private MQTTProtocol.@Nullable Schedule lastSchedule = null;\n+    private boolean auto_passes = true;\n+    private @Nullable Boolean two_passes = null;\n+    private boolean carpet_boost = true;\n+    private @Nullable Boolean vac_high = null;\n+    private boolean isPaused = false;\n+\n+    public RoombaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.trace(\"initialize()\");\n+        config = getConfigAs(RoombaConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+        connect();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.trace(\"dispose()\");\n+\n+        singleThread.execute(() -> {\n+            if (reconnectReq != null) {\n+                reconnectReq.cancel(false);\n+                reconnectReq = null;\n+            }\n+\n+            if (connection != null) {\n+                connection.stop();\n+                connection = null;\n+            }\n+        });\n+    }\n+\n+    // lastState.get() can return null if the key is not found according\n+    // to the documentation\n+    @SuppressWarnings(\"null\")\n+    private void handleRefresh(String ch) {\n+        State value = lastState.get(ch);\n+\n+        if (value != null) {\n+            updateState(ch, value);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String ch = channelUID.getId();\n+        if (command instanceof RefreshType) {\n+            handleRefresh(ch);\n+            return;\n+        }\n+\n+        if (ch.equals(CHANNEL_COMMAND)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+\n+                if (cmd.equals(CMD_CLEAN)) {\n+                    cmd = isPaused ? \"resume\" : \"start\";\n+                }\n+\n+                sendRequest(new MQTTProtocol.CommandRequest(cmd));\n+            }\n+        } else if (ch.startsWith(CHANNEL_SCHED_SWITCH_PREFIX)) {\n+            MQTTProtocol.Schedule schedule = lastSchedule;\n+\n+            // Schedule can only be updated in a bulk, so we have to store current\n+            // schedule and modify components.\n+            if (command instanceof OnOffType && schedule != null && schedule.cycle != null) {\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    if (ch.equals(CHANNEL_SCHED_SWITCH[i])) {\n+                        MQTTProtocol.Schedule newSchedule = new MQTTProtocol.Schedule(schedule.cycle);\n+\n+                        newSchedule.enableCycle(i, command.equals(OnOffType.ON));\n+                        sendSchedule(newSchedule);\n+                        break;\n+                    }\n+                }\n+            }\n+        } else if (ch.equals(CHANNEL_SCHEDULE)) {\n+            if (command instanceof DecimalType) {\n+                int bitmask = ((DecimalType) command).intValue();\n+                JsonArray cycle = new JsonArray();\n+\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    enableCycle(cycle, i, (bitmask & (1 << i)) != 0);\n+                }\n+\n+                sendSchedule(new MQTTProtocol.Schedule(bitmask));\n+            }\n+        } else if (ch.equals(CHANNEL_EDGE_CLEAN)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.OpenOnly(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_ALWAYS_FINISH)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.BinPause(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_POWER_BOOST)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+                sendDelta(new MQTTProtocol.PowerBoost(cmd.equals(BOOST_AUTO), cmd.equals(BOOST_PERFORMANCE)));\n+            }\n+        } else if (ch.equals(CHANNEL_CLEAN_PASSES)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+                sendDelta(new MQTTProtocol.CleanPasses(!cmd.equals(PASSES_AUTO), cmd.equals(PASSES_2)));\n+            }\n+        }\n+    }\n+\n+    private void enableCycle(JsonArray cycle, int i, boolean enable) {\n+        JsonPrimitive value = new JsonPrimitive(enable ? \"start\" : \"none\");\n+        cycle.set(i, value);\n+    }\n+\n+    private void sendSchedule(MQTTProtocol.Schedule schedule) {\n+        sendDelta(new MQTTProtocol.CleanSchedule(schedule));\n+    }\n+\n+    private void sendDelta(MQTTProtocol.StateValue state) {\n+        sendRequest(new MQTTProtocol.DeltaRequest(state));\n+    }\n+\n+    private void sendRequest(MQTTProtocol.Request request) {\n+        RoombaMqttBrokerConnection conn = connection;\n+\n+        if (conn != null) {\n+            String json = new Gson().toJson(request);\n+            logger.trace(\"Sending {}: {}\", request.getTopic(), json);\n+            conn.publish(request.getTopic(), json.getBytes());\n+        }\n+    }\n+\n+    private void connect() {\n+        // In order not to mess up our connection state we need to make sure\n+        // that any two calls are never running concurrently. We use\n+        // singleThreadExecutorService for this purpose\n+        singleThread.execute(() -> {\n+            String error = null;\n+\n+            logger.info(\"Connecting to {}\", config.ipaddress);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9674556c16225cbbe635a06414cbf94eda1ea4c"}, "originalPosition": 221}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTQwMzE5Nw==", "bodyText": "Well, it is newly started connection, it is sparse, it will not flood. Are you insisting ?", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r511403197", "createdAt": "2020-10-24T11:18:27Z", "author": {"login": "Sonic-Amiga"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.handler;\n+\n+import static org.openhab.binding.irobot.IRobotBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Hashtable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.internal.MQTTProtocol;\n+import org.openhab.binding.irobot.internal.RawMQTT;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.binding.irobot.roomba.RoombaMqttBrokerConnection;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The {@link RoombaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author hkuhn42 - Initial contribution\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Rewrite for 900 series\n+ */\n+@NonNullByDefault\n+public class RoombaHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(RoombaHandler.class);\n+    private final ExecutorService singleThread = Executors.newSingleThreadExecutor();\n+    private static final int reconnectDelay = 5; // In seconds\n+    private @Nullable Future<?> reconnectReq;\n+    // Dummy RoombaConfiguration object in order to shut up Eclipse warnings\n+    // The real one is set in initialize()\n+    private RoombaConfiguration config = new RoombaConfiguration();\n+    private @Nullable String blid = null;\n+    private @Nullable RoombaMqttBrokerConnection connection;\n+    private Hashtable<String, State> lastState = new Hashtable<String, State>();\n+    private MQTTProtocol.@Nullable Schedule lastSchedule = null;\n+    private boolean auto_passes = true;\n+    private @Nullable Boolean two_passes = null;\n+    private boolean carpet_boost = true;\n+    private @Nullable Boolean vac_high = null;\n+    private boolean isPaused = false;\n+\n+    public RoombaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.trace(\"initialize()\");\n+        config = getConfigAs(RoombaConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+        connect();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.trace(\"dispose()\");\n+\n+        singleThread.execute(() -> {\n+            if (reconnectReq != null) {\n+                reconnectReq.cancel(false);\n+                reconnectReq = null;\n+            }\n+\n+            if (connection != null) {\n+                connection.stop();\n+                connection = null;\n+            }\n+        });\n+    }\n+\n+    // lastState.get() can return null if the key is not found according\n+    // to the documentation\n+    @SuppressWarnings(\"null\")\n+    private void handleRefresh(String ch) {\n+        State value = lastState.get(ch);\n+\n+        if (value != null) {\n+            updateState(ch, value);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String ch = channelUID.getId();\n+        if (command instanceof RefreshType) {\n+            handleRefresh(ch);\n+            return;\n+        }\n+\n+        if (ch.equals(CHANNEL_COMMAND)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+\n+                if (cmd.equals(CMD_CLEAN)) {\n+                    cmd = isPaused ? \"resume\" : \"start\";\n+                }\n+\n+                sendRequest(new MQTTProtocol.CommandRequest(cmd));\n+            }\n+        } else if (ch.startsWith(CHANNEL_SCHED_SWITCH_PREFIX)) {\n+            MQTTProtocol.Schedule schedule = lastSchedule;\n+\n+            // Schedule can only be updated in a bulk, so we have to store current\n+            // schedule and modify components.\n+            if (command instanceof OnOffType && schedule != null && schedule.cycle != null) {\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    if (ch.equals(CHANNEL_SCHED_SWITCH[i])) {\n+                        MQTTProtocol.Schedule newSchedule = new MQTTProtocol.Schedule(schedule.cycle);\n+\n+                        newSchedule.enableCycle(i, command.equals(OnOffType.ON));\n+                        sendSchedule(newSchedule);\n+                        break;\n+                    }\n+                }\n+            }\n+        } else if (ch.equals(CHANNEL_SCHEDULE)) {\n+            if (command instanceof DecimalType) {\n+                int bitmask = ((DecimalType) command).intValue();\n+                JsonArray cycle = new JsonArray();\n+\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    enableCycle(cycle, i, (bitmask & (1 << i)) != 0);\n+                }\n+\n+                sendSchedule(new MQTTProtocol.Schedule(bitmask));\n+            }\n+        } else if (ch.equals(CHANNEL_EDGE_CLEAN)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.OpenOnly(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_ALWAYS_FINISH)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.BinPause(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_POWER_BOOST)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+                sendDelta(new MQTTProtocol.PowerBoost(cmd.equals(BOOST_AUTO), cmd.equals(BOOST_PERFORMANCE)));\n+            }\n+        } else if (ch.equals(CHANNEL_CLEAN_PASSES)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+                sendDelta(new MQTTProtocol.CleanPasses(!cmd.equals(PASSES_AUTO), cmd.equals(PASSES_2)));\n+            }\n+        }\n+    }\n+\n+    private void enableCycle(JsonArray cycle, int i, boolean enable) {\n+        JsonPrimitive value = new JsonPrimitive(enable ? \"start\" : \"none\");\n+        cycle.set(i, value);\n+    }\n+\n+    private void sendSchedule(MQTTProtocol.Schedule schedule) {\n+        sendDelta(new MQTTProtocol.CleanSchedule(schedule));\n+    }\n+\n+    private void sendDelta(MQTTProtocol.StateValue state) {\n+        sendRequest(new MQTTProtocol.DeltaRequest(state));\n+    }\n+\n+    private void sendRequest(MQTTProtocol.Request request) {\n+        RoombaMqttBrokerConnection conn = connection;\n+\n+        if (conn != null) {\n+            String json = new Gson().toJson(request);\n+            logger.trace(\"Sending {}: {}\", request.getTopic(), json);\n+            conn.publish(request.getTopic(), json.getBytes());\n+        }\n+    }\n+\n+    private void connect() {\n+        // In order not to mess up our connection state we need to make sure\n+        // that any two calls are never running concurrently. We use\n+        // singleThreadExecutorService for this purpose\n+        singleThread.execute(() -> {\n+            String error = null;\n+\n+            logger.info(\"Connecting to {}\", config.ipaddress);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk4MzY5Mw=="}, "originalCommit": {"oid": "e9674556c16225cbbe635a06414cbf94eda1ea4c"}, "originalPosition": 221}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjIwNjEwNw==", "bodyText": "It isn't compliant to the coding guidelines, as a \"newly started component\" is very different from the initiation of a network connection. See https://www.openhab.org/docs/developer/guidelines.html#f-logging", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r512206107", "createdAt": "2020-10-26T19:13:15Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.handler;\n+\n+import static org.openhab.binding.irobot.IRobotBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Hashtable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.internal.MQTTProtocol;\n+import org.openhab.binding.irobot.internal.RawMQTT;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.binding.irobot.roomba.RoombaMqttBrokerConnection;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The {@link RoombaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author hkuhn42 - Initial contribution\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Rewrite for 900 series\n+ */\n+@NonNullByDefault\n+public class RoombaHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(RoombaHandler.class);\n+    private final ExecutorService singleThread = Executors.newSingleThreadExecutor();\n+    private static final int reconnectDelay = 5; // In seconds\n+    private @Nullable Future<?> reconnectReq;\n+    // Dummy RoombaConfiguration object in order to shut up Eclipse warnings\n+    // The real one is set in initialize()\n+    private RoombaConfiguration config = new RoombaConfiguration();\n+    private @Nullable String blid = null;\n+    private @Nullable RoombaMqttBrokerConnection connection;\n+    private Hashtable<String, State> lastState = new Hashtable<String, State>();\n+    private MQTTProtocol.@Nullable Schedule lastSchedule = null;\n+    private boolean auto_passes = true;\n+    private @Nullable Boolean two_passes = null;\n+    private boolean carpet_boost = true;\n+    private @Nullable Boolean vac_high = null;\n+    private boolean isPaused = false;\n+\n+    public RoombaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.trace(\"initialize()\");\n+        config = getConfigAs(RoombaConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+        connect();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.trace(\"dispose()\");\n+\n+        singleThread.execute(() -> {\n+            if (reconnectReq != null) {\n+                reconnectReq.cancel(false);\n+                reconnectReq = null;\n+            }\n+\n+            if (connection != null) {\n+                connection.stop();\n+                connection = null;\n+            }\n+        });\n+    }\n+\n+    // lastState.get() can return null if the key is not found according\n+    // to the documentation\n+    @SuppressWarnings(\"null\")\n+    private void handleRefresh(String ch) {\n+        State value = lastState.get(ch);\n+\n+        if (value != null) {\n+            updateState(ch, value);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String ch = channelUID.getId();\n+        if (command instanceof RefreshType) {\n+            handleRefresh(ch);\n+            return;\n+        }\n+\n+        if (ch.equals(CHANNEL_COMMAND)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+\n+                if (cmd.equals(CMD_CLEAN)) {\n+                    cmd = isPaused ? \"resume\" : \"start\";\n+                }\n+\n+                sendRequest(new MQTTProtocol.CommandRequest(cmd));\n+            }\n+        } else if (ch.startsWith(CHANNEL_SCHED_SWITCH_PREFIX)) {\n+            MQTTProtocol.Schedule schedule = lastSchedule;\n+\n+            // Schedule can only be updated in a bulk, so we have to store current\n+            // schedule and modify components.\n+            if (command instanceof OnOffType && schedule != null && schedule.cycle != null) {\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    if (ch.equals(CHANNEL_SCHED_SWITCH[i])) {\n+                        MQTTProtocol.Schedule newSchedule = new MQTTProtocol.Schedule(schedule.cycle);\n+\n+                        newSchedule.enableCycle(i, command.equals(OnOffType.ON));\n+                        sendSchedule(newSchedule);\n+                        break;\n+                    }\n+                }\n+            }\n+        } else if (ch.equals(CHANNEL_SCHEDULE)) {\n+            if (command instanceof DecimalType) {\n+                int bitmask = ((DecimalType) command).intValue();\n+                JsonArray cycle = new JsonArray();\n+\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    enableCycle(cycle, i, (bitmask & (1 << i)) != 0);\n+                }\n+\n+                sendSchedule(new MQTTProtocol.Schedule(bitmask));\n+            }\n+        } else if (ch.equals(CHANNEL_EDGE_CLEAN)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.OpenOnly(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_ALWAYS_FINISH)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.BinPause(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_POWER_BOOST)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+                sendDelta(new MQTTProtocol.PowerBoost(cmd.equals(BOOST_AUTO), cmd.equals(BOOST_PERFORMANCE)));\n+            }\n+        } else if (ch.equals(CHANNEL_CLEAN_PASSES)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+                sendDelta(new MQTTProtocol.CleanPasses(!cmd.equals(PASSES_AUTO), cmd.equals(PASSES_2)));\n+            }\n+        }\n+    }\n+\n+    private void enableCycle(JsonArray cycle, int i, boolean enable) {\n+        JsonPrimitive value = new JsonPrimitive(enable ? \"start\" : \"none\");\n+        cycle.set(i, value);\n+    }\n+\n+    private void sendSchedule(MQTTProtocol.Schedule schedule) {\n+        sendDelta(new MQTTProtocol.CleanSchedule(schedule));\n+    }\n+\n+    private void sendDelta(MQTTProtocol.StateValue state) {\n+        sendRequest(new MQTTProtocol.DeltaRequest(state));\n+    }\n+\n+    private void sendRequest(MQTTProtocol.Request request) {\n+        RoombaMqttBrokerConnection conn = connection;\n+\n+        if (conn != null) {\n+            String json = new Gson().toJson(request);\n+            logger.trace(\"Sending {}: {}\", request.getTopic(), json);\n+            conn.publish(request.getTopic(), json.getBytes());\n+        }\n+    }\n+\n+    private void connect() {\n+        // In order not to mess up our connection state we need to make sure\n+        // that any two calls are never running concurrently. We use\n+        // singleThreadExecutorService for this purpose\n+        singleThread.execute(() -> {\n+            String error = null;\n+\n+            logger.info(\"Connecting to {}\", config.ipaddress);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk4MzY5Mw=="}, "originalCommit": {"oid": "e9674556c16225cbbe635a06414cbf94eda1ea4c"}, "originalPosition": 221}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjkyMTIzOQ==", "bodyText": "Ok, you're the Boss here. I hope it's OK to have debug level here.", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r512921239", "createdAt": "2020-10-27T18:11:25Z", "author": {"login": "Sonic-Amiga"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.handler;\n+\n+import static org.openhab.binding.irobot.IRobotBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Hashtable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.internal.MQTTProtocol;\n+import org.openhab.binding.irobot.internal.RawMQTT;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.binding.irobot.roomba.RoombaMqttBrokerConnection;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The {@link RoombaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author hkuhn42 - Initial contribution\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Rewrite for 900 series\n+ */\n+@NonNullByDefault\n+public class RoombaHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(RoombaHandler.class);\n+    private final ExecutorService singleThread = Executors.newSingleThreadExecutor();\n+    private static final int reconnectDelay = 5; // In seconds\n+    private @Nullable Future<?> reconnectReq;\n+    // Dummy RoombaConfiguration object in order to shut up Eclipse warnings\n+    // The real one is set in initialize()\n+    private RoombaConfiguration config = new RoombaConfiguration();\n+    private @Nullable String blid = null;\n+    private @Nullable RoombaMqttBrokerConnection connection;\n+    private Hashtable<String, State> lastState = new Hashtable<String, State>();\n+    private MQTTProtocol.@Nullable Schedule lastSchedule = null;\n+    private boolean auto_passes = true;\n+    private @Nullable Boolean two_passes = null;\n+    private boolean carpet_boost = true;\n+    private @Nullable Boolean vac_high = null;\n+    private boolean isPaused = false;\n+\n+    public RoombaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.trace(\"initialize()\");\n+        config = getConfigAs(RoombaConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+        connect();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.trace(\"dispose()\");\n+\n+        singleThread.execute(() -> {\n+            if (reconnectReq != null) {\n+                reconnectReq.cancel(false);\n+                reconnectReq = null;\n+            }\n+\n+            if (connection != null) {\n+                connection.stop();\n+                connection = null;\n+            }\n+        });\n+    }\n+\n+    // lastState.get() can return null if the key is not found according\n+    // to the documentation\n+    @SuppressWarnings(\"null\")\n+    private void handleRefresh(String ch) {\n+        State value = lastState.get(ch);\n+\n+        if (value != null) {\n+            updateState(ch, value);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String ch = channelUID.getId();\n+        if (command instanceof RefreshType) {\n+            handleRefresh(ch);\n+            return;\n+        }\n+\n+        if (ch.equals(CHANNEL_COMMAND)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+\n+                if (cmd.equals(CMD_CLEAN)) {\n+                    cmd = isPaused ? \"resume\" : \"start\";\n+                }\n+\n+                sendRequest(new MQTTProtocol.CommandRequest(cmd));\n+            }\n+        } else if (ch.startsWith(CHANNEL_SCHED_SWITCH_PREFIX)) {\n+            MQTTProtocol.Schedule schedule = lastSchedule;\n+\n+            // Schedule can only be updated in a bulk, so we have to store current\n+            // schedule and modify components.\n+            if (command instanceof OnOffType && schedule != null && schedule.cycle != null) {\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    if (ch.equals(CHANNEL_SCHED_SWITCH[i])) {\n+                        MQTTProtocol.Schedule newSchedule = new MQTTProtocol.Schedule(schedule.cycle);\n+\n+                        newSchedule.enableCycle(i, command.equals(OnOffType.ON));\n+                        sendSchedule(newSchedule);\n+                        break;\n+                    }\n+                }\n+            }\n+        } else if (ch.equals(CHANNEL_SCHEDULE)) {\n+            if (command instanceof DecimalType) {\n+                int bitmask = ((DecimalType) command).intValue();\n+                JsonArray cycle = new JsonArray();\n+\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    enableCycle(cycle, i, (bitmask & (1 << i)) != 0);\n+                }\n+\n+                sendSchedule(new MQTTProtocol.Schedule(bitmask));\n+            }\n+        } else if (ch.equals(CHANNEL_EDGE_CLEAN)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.OpenOnly(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_ALWAYS_FINISH)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.BinPause(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_POWER_BOOST)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+                sendDelta(new MQTTProtocol.PowerBoost(cmd.equals(BOOST_AUTO), cmd.equals(BOOST_PERFORMANCE)));\n+            }\n+        } else if (ch.equals(CHANNEL_CLEAN_PASSES)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+                sendDelta(new MQTTProtocol.CleanPasses(!cmd.equals(PASSES_AUTO), cmd.equals(PASSES_2)));\n+            }\n+        }\n+    }\n+\n+    private void enableCycle(JsonArray cycle, int i, boolean enable) {\n+        JsonPrimitive value = new JsonPrimitive(enable ? \"start\" : \"none\");\n+        cycle.set(i, value);\n+    }\n+\n+    private void sendSchedule(MQTTProtocol.Schedule schedule) {\n+        sendDelta(new MQTTProtocol.CleanSchedule(schedule));\n+    }\n+\n+    private void sendDelta(MQTTProtocol.StateValue state) {\n+        sendRequest(new MQTTProtocol.DeltaRequest(state));\n+    }\n+\n+    private void sendRequest(MQTTProtocol.Request request) {\n+        RoombaMqttBrokerConnection conn = connection;\n+\n+        if (conn != null) {\n+            String json = new Gson().toJson(request);\n+            logger.trace(\"Sending {}: {}\", request.getTopic(), json);\n+            conn.publish(request.getTopic(), json.getBytes());\n+        }\n+    }\n+\n+    private void connect() {\n+        // In order not to mess up our connection state we need to make sure\n+        // that any two calls are never running concurrently. We use\n+        // singleThreadExecutorService for this purpose\n+        singleThread.execute(() -> {\n+            String error = null;\n+\n+            logger.info(\"Connecting to {}\", config.ipaddress);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk4MzY5Mw=="}, "originalCommit": {"oid": "e9674556c16225cbbe635a06414cbf94eda1ea4c"}, "originalPosition": 221}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMDk1NzMxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNTo1OTo1NFrOHnUCyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QxODoxMzozNVrOHpKUqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk4NDkwNA==", "bodyText": "Is it secure to write the password into the logs?", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r510984904", "createdAt": "2020-10-23T15:59:54Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.handler;\n+\n+import static org.openhab.binding.irobot.IRobotBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Hashtable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.internal.MQTTProtocol;\n+import org.openhab.binding.irobot.internal.RawMQTT;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.binding.irobot.roomba.RoombaMqttBrokerConnection;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The {@link RoombaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author hkuhn42 - Initial contribution\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Rewrite for 900 series\n+ */\n+@NonNullByDefault\n+public class RoombaHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(RoombaHandler.class);\n+    private final ExecutorService singleThread = Executors.newSingleThreadExecutor();\n+    private static final int reconnectDelay = 5; // In seconds\n+    private @Nullable Future<?> reconnectReq;\n+    // Dummy RoombaConfiguration object in order to shut up Eclipse warnings\n+    // The real one is set in initialize()\n+    private RoombaConfiguration config = new RoombaConfiguration();\n+    private @Nullable String blid = null;\n+    private @Nullable RoombaMqttBrokerConnection connection;\n+    private Hashtable<String, State> lastState = new Hashtable<String, State>();\n+    private MQTTProtocol.@Nullable Schedule lastSchedule = null;\n+    private boolean auto_passes = true;\n+    private @Nullable Boolean two_passes = null;\n+    private boolean carpet_boost = true;\n+    private @Nullable Boolean vac_high = null;\n+    private boolean isPaused = false;\n+\n+    public RoombaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.trace(\"initialize()\");\n+        config = getConfigAs(RoombaConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+        connect();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.trace(\"dispose()\");\n+\n+        singleThread.execute(() -> {\n+            if (reconnectReq != null) {\n+                reconnectReq.cancel(false);\n+                reconnectReq = null;\n+            }\n+\n+            if (connection != null) {\n+                connection.stop();\n+                connection = null;\n+            }\n+        });\n+    }\n+\n+    // lastState.get() can return null if the key is not found according\n+    // to the documentation\n+    @SuppressWarnings(\"null\")\n+    private void handleRefresh(String ch) {\n+        State value = lastState.get(ch);\n+\n+        if (value != null) {\n+            updateState(ch, value);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String ch = channelUID.getId();\n+        if (command instanceof RefreshType) {\n+            handleRefresh(ch);\n+            return;\n+        }\n+\n+        if (ch.equals(CHANNEL_COMMAND)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+\n+                if (cmd.equals(CMD_CLEAN)) {\n+                    cmd = isPaused ? \"resume\" : \"start\";\n+                }\n+\n+                sendRequest(new MQTTProtocol.CommandRequest(cmd));\n+            }\n+        } else if (ch.startsWith(CHANNEL_SCHED_SWITCH_PREFIX)) {\n+            MQTTProtocol.Schedule schedule = lastSchedule;\n+\n+            // Schedule can only be updated in a bulk, so we have to store current\n+            // schedule and modify components.\n+            if (command instanceof OnOffType && schedule != null && schedule.cycle != null) {\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    if (ch.equals(CHANNEL_SCHED_SWITCH[i])) {\n+                        MQTTProtocol.Schedule newSchedule = new MQTTProtocol.Schedule(schedule.cycle);\n+\n+                        newSchedule.enableCycle(i, command.equals(OnOffType.ON));\n+                        sendSchedule(newSchedule);\n+                        break;\n+                    }\n+                }\n+            }\n+        } else if (ch.equals(CHANNEL_SCHEDULE)) {\n+            if (command instanceof DecimalType) {\n+                int bitmask = ((DecimalType) command).intValue();\n+                JsonArray cycle = new JsonArray();\n+\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    enableCycle(cycle, i, (bitmask & (1 << i)) != 0);\n+                }\n+\n+                sendSchedule(new MQTTProtocol.Schedule(bitmask));\n+            }\n+        } else if (ch.equals(CHANNEL_EDGE_CLEAN)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.OpenOnly(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_ALWAYS_FINISH)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.BinPause(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_POWER_BOOST)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+                sendDelta(new MQTTProtocol.PowerBoost(cmd.equals(BOOST_AUTO), cmd.equals(BOOST_PERFORMANCE)));\n+            }\n+        } else if (ch.equals(CHANNEL_CLEAN_PASSES)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+                sendDelta(new MQTTProtocol.CleanPasses(!cmd.equals(PASSES_AUTO), cmd.equals(PASSES_2)));\n+            }\n+        }\n+    }\n+\n+    private void enableCycle(JsonArray cycle, int i, boolean enable) {\n+        JsonPrimitive value = new JsonPrimitive(enable ? \"start\" : \"none\");\n+        cycle.set(i, value);\n+    }\n+\n+    private void sendSchedule(MQTTProtocol.Schedule schedule) {\n+        sendDelta(new MQTTProtocol.CleanSchedule(schedule));\n+    }\n+\n+    private void sendDelta(MQTTProtocol.StateValue state) {\n+        sendRequest(new MQTTProtocol.DeltaRequest(state));\n+    }\n+\n+    private void sendRequest(MQTTProtocol.Request request) {\n+        RoombaMqttBrokerConnection conn = connection;\n+\n+        if (conn != null) {\n+            String json = new Gson().toJson(request);\n+            logger.trace(\"Sending {}: {}\", request.getTopic(), json);\n+            conn.publish(request.getTopic(), json.getBytes());\n+        }\n+    }\n+\n+    private void connect() {\n+        // In order not to mess up our connection state we need to make sure\n+        // that any two calls are never running concurrently. We use\n+        // singleThreadExecutorService for this purpose\n+        singleThread.execute(() -> {\n+            String error = null;\n+\n+            logger.info(\"Connecting to {}\", config.ipaddress);\n+\n+            try {\n+                InetAddress host = InetAddress.getByName(config.ipaddress);\n+                String blid = this.blid;\n+\n+                if (blid == null) {\n+                    DatagramSocket identSocket = IdentProtocol.sendRequest(host);\n+                    DatagramPacket identPacket = IdentProtocol.receiveResponse(identSocket);\n+                    IdentProtocol.IdentData ident;\n+\n+                    identSocket.close();\n+\n+                    try {\n+                        ident = IdentProtocol.decodeResponse(identPacket);\n+                    } catch (JsonParseException e) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Malformed IDENT response\");\n+                        return;\n+                    }\n+\n+                    if (ident.ver < IdentData.MIN_SUPPORTED_VERSION) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                \"Unsupported version \" + ident.ver);\n+                        return;\n+                    }\n+\n+                    if (!ident.product.equals(IdentData.PRODUCT_ROOMBA)) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                \"Not a Roomba: \" + ident.product);\n+                        return;\n+                    }\n+\n+                    blid = ident.blid;\n+                    this.blid = blid;\n+                }\n+\n+                logger.debug(\"BLID is: {}\", blid);\n+\n+                if (!config.havePassword()) {\n+                    RawMQTT mqtt;\n+\n+                    try {\n+                        mqtt = new RawMQTT(host, 8883);\n+                    } catch (KeyManagementException | NoSuchAlgorithmException e1) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e1.toString());\n+                        return; // This is internal system error, no retry\n+                    }\n+\n+                    mqtt.requestPassword();\n+                    RawMQTT.Packet response = mqtt.readPacket();\n+                    mqtt.close();\n+\n+                    if (response != null && response.isValidPasswdPacket()) {\n+                        RawMQTT.PasswdPacket passwdPacket = new RawMQTT.PasswdPacket(response);\n+\n+                        config.password = passwdPacket.getPassword();\n+                        if (config.havePassword()) {\n+                            Configuration configuration = editConfiguration();\n+\n+                            configuration.put(RoombaConfiguration.FIELD_PASSWORD, config.password);\n+                            updateConfiguration(configuration);\n+                        }\n+                    }\n+                }\n+\n+                if (!config.havePassword()) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING,\n+                            \"Authentication on the robot is required\");\n+                    scheduleReconnect();\n+                    return;\n+                }\n+\n+                logger.debug(\"Password is: {}\", config.password);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9674556c16225cbbe635a06414cbf94eda1ea4c"}, "originalPosition": 294}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTQwNDU3MA==", "bodyText": "Well, it can be looked up in Thing configuration anyways.\nThis is not a password in traditional sense. It's not defined by the user, neither it can be changed. It is hardcoded inside the robot instead, and it is supposed to be discovered. The robot gives it away when a button on it is pressed. Official app also used this discovery algorithm. The password is considered \"technical\", it's not written anywhere in the manual, on some card or on the robot itself.\nBut OK, your wish...", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r511404570", "createdAt": "2020-10-24T11:21:37Z", "author": {"login": "Sonic-Amiga"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.handler;\n+\n+import static org.openhab.binding.irobot.IRobotBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Hashtable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.internal.MQTTProtocol;\n+import org.openhab.binding.irobot.internal.RawMQTT;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.binding.irobot.roomba.RoombaMqttBrokerConnection;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The {@link RoombaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author hkuhn42 - Initial contribution\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Rewrite for 900 series\n+ */\n+@NonNullByDefault\n+public class RoombaHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(RoombaHandler.class);\n+    private final ExecutorService singleThread = Executors.newSingleThreadExecutor();\n+    private static final int reconnectDelay = 5; // In seconds\n+    private @Nullable Future<?> reconnectReq;\n+    // Dummy RoombaConfiguration object in order to shut up Eclipse warnings\n+    // The real one is set in initialize()\n+    private RoombaConfiguration config = new RoombaConfiguration();\n+    private @Nullable String blid = null;\n+    private @Nullable RoombaMqttBrokerConnection connection;\n+    private Hashtable<String, State> lastState = new Hashtable<String, State>();\n+    private MQTTProtocol.@Nullable Schedule lastSchedule = null;\n+    private boolean auto_passes = true;\n+    private @Nullable Boolean two_passes = null;\n+    private boolean carpet_boost = true;\n+    private @Nullable Boolean vac_high = null;\n+    private boolean isPaused = false;\n+\n+    public RoombaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.trace(\"initialize()\");\n+        config = getConfigAs(RoombaConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+        connect();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.trace(\"dispose()\");\n+\n+        singleThread.execute(() -> {\n+            if (reconnectReq != null) {\n+                reconnectReq.cancel(false);\n+                reconnectReq = null;\n+            }\n+\n+            if (connection != null) {\n+                connection.stop();\n+                connection = null;\n+            }\n+        });\n+    }\n+\n+    // lastState.get() can return null if the key is not found according\n+    // to the documentation\n+    @SuppressWarnings(\"null\")\n+    private void handleRefresh(String ch) {\n+        State value = lastState.get(ch);\n+\n+        if (value != null) {\n+            updateState(ch, value);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String ch = channelUID.getId();\n+        if (command instanceof RefreshType) {\n+            handleRefresh(ch);\n+            return;\n+        }\n+\n+        if (ch.equals(CHANNEL_COMMAND)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+\n+                if (cmd.equals(CMD_CLEAN)) {\n+                    cmd = isPaused ? \"resume\" : \"start\";\n+                }\n+\n+                sendRequest(new MQTTProtocol.CommandRequest(cmd));\n+            }\n+        } else if (ch.startsWith(CHANNEL_SCHED_SWITCH_PREFIX)) {\n+            MQTTProtocol.Schedule schedule = lastSchedule;\n+\n+            // Schedule can only be updated in a bulk, so we have to store current\n+            // schedule and modify components.\n+            if (command instanceof OnOffType && schedule != null && schedule.cycle != null) {\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    if (ch.equals(CHANNEL_SCHED_SWITCH[i])) {\n+                        MQTTProtocol.Schedule newSchedule = new MQTTProtocol.Schedule(schedule.cycle);\n+\n+                        newSchedule.enableCycle(i, command.equals(OnOffType.ON));\n+                        sendSchedule(newSchedule);\n+                        break;\n+                    }\n+                }\n+            }\n+        } else if (ch.equals(CHANNEL_SCHEDULE)) {\n+            if (command instanceof DecimalType) {\n+                int bitmask = ((DecimalType) command).intValue();\n+                JsonArray cycle = new JsonArray();\n+\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    enableCycle(cycle, i, (bitmask & (1 << i)) != 0);\n+                }\n+\n+                sendSchedule(new MQTTProtocol.Schedule(bitmask));\n+            }\n+        } else if (ch.equals(CHANNEL_EDGE_CLEAN)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.OpenOnly(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_ALWAYS_FINISH)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.BinPause(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_POWER_BOOST)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+                sendDelta(new MQTTProtocol.PowerBoost(cmd.equals(BOOST_AUTO), cmd.equals(BOOST_PERFORMANCE)));\n+            }\n+        } else if (ch.equals(CHANNEL_CLEAN_PASSES)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+                sendDelta(new MQTTProtocol.CleanPasses(!cmd.equals(PASSES_AUTO), cmd.equals(PASSES_2)));\n+            }\n+        }\n+    }\n+\n+    private void enableCycle(JsonArray cycle, int i, boolean enable) {\n+        JsonPrimitive value = new JsonPrimitive(enable ? \"start\" : \"none\");\n+        cycle.set(i, value);\n+    }\n+\n+    private void sendSchedule(MQTTProtocol.Schedule schedule) {\n+        sendDelta(new MQTTProtocol.CleanSchedule(schedule));\n+    }\n+\n+    private void sendDelta(MQTTProtocol.StateValue state) {\n+        sendRequest(new MQTTProtocol.DeltaRequest(state));\n+    }\n+\n+    private void sendRequest(MQTTProtocol.Request request) {\n+        RoombaMqttBrokerConnection conn = connection;\n+\n+        if (conn != null) {\n+            String json = new Gson().toJson(request);\n+            logger.trace(\"Sending {}: {}\", request.getTopic(), json);\n+            conn.publish(request.getTopic(), json.getBytes());\n+        }\n+    }\n+\n+    private void connect() {\n+        // In order not to mess up our connection state we need to make sure\n+        // that any two calls are never running concurrently. We use\n+        // singleThreadExecutorService for this purpose\n+        singleThread.execute(() -> {\n+            String error = null;\n+\n+            logger.info(\"Connecting to {}\", config.ipaddress);\n+\n+            try {\n+                InetAddress host = InetAddress.getByName(config.ipaddress);\n+                String blid = this.blid;\n+\n+                if (blid == null) {\n+                    DatagramSocket identSocket = IdentProtocol.sendRequest(host);\n+                    DatagramPacket identPacket = IdentProtocol.receiveResponse(identSocket);\n+                    IdentProtocol.IdentData ident;\n+\n+                    identSocket.close();\n+\n+                    try {\n+                        ident = IdentProtocol.decodeResponse(identPacket);\n+                    } catch (JsonParseException e) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Malformed IDENT response\");\n+                        return;\n+                    }\n+\n+                    if (ident.ver < IdentData.MIN_SUPPORTED_VERSION) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                \"Unsupported version \" + ident.ver);\n+                        return;\n+                    }\n+\n+                    if (!ident.product.equals(IdentData.PRODUCT_ROOMBA)) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                \"Not a Roomba: \" + ident.product);\n+                        return;\n+                    }\n+\n+                    blid = ident.blid;\n+                    this.blid = blid;\n+                }\n+\n+                logger.debug(\"BLID is: {}\", blid);\n+\n+                if (!config.havePassword()) {\n+                    RawMQTT mqtt;\n+\n+                    try {\n+                        mqtt = new RawMQTT(host, 8883);\n+                    } catch (KeyManagementException | NoSuchAlgorithmException e1) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e1.toString());\n+                        return; // This is internal system error, no retry\n+                    }\n+\n+                    mqtt.requestPassword();\n+                    RawMQTT.Packet response = mqtt.readPacket();\n+                    mqtt.close();\n+\n+                    if (response != null && response.isValidPasswdPacket()) {\n+                        RawMQTT.PasswdPacket passwdPacket = new RawMQTT.PasswdPacket(response);\n+\n+                        config.password = passwdPacket.getPassword();\n+                        if (config.havePassword()) {\n+                            Configuration configuration = editConfiguration();\n+\n+                            configuration.put(RoombaConfiguration.FIELD_PASSWORD, config.password);\n+                            updateConfiguration(configuration);\n+                        }\n+                    }\n+                }\n+\n+                if (!config.havePassword()) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING,\n+                            \"Authentication on the robot is required\");\n+                    scheduleReconnect();\n+                    return;\n+                }\n+\n+                logger.debug(\"Password is: {}\", config.password);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk4NDkwNA=="}, "originalCommit": {"oid": "e9674556c16225cbbe635a06414cbf94eda1ea4c"}, "originalPosition": 294}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjIwNjU2NQ==", "bodyText": "Just asking. It's up to you.", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r512206565", "createdAt": "2020-10-26T19:14:04Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.handler;\n+\n+import static org.openhab.binding.irobot.IRobotBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Hashtable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.internal.MQTTProtocol;\n+import org.openhab.binding.irobot.internal.RawMQTT;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.binding.irobot.roomba.RoombaMqttBrokerConnection;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The {@link RoombaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author hkuhn42 - Initial contribution\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Rewrite for 900 series\n+ */\n+@NonNullByDefault\n+public class RoombaHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(RoombaHandler.class);\n+    private final ExecutorService singleThread = Executors.newSingleThreadExecutor();\n+    private static final int reconnectDelay = 5; // In seconds\n+    private @Nullable Future<?> reconnectReq;\n+    // Dummy RoombaConfiguration object in order to shut up Eclipse warnings\n+    // The real one is set in initialize()\n+    private RoombaConfiguration config = new RoombaConfiguration();\n+    private @Nullable String blid = null;\n+    private @Nullable RoombaMqttBrokerConnection connection;\n+    private Hashtable<String, State> lastState = new Hashtable<String, State>();\n+    private MQTTProtocol.@Nullable Schedule lastSchedule = null;\n+    private boolean auto_passes = true;\n+    private @Nullable Boolean two_passes = null;\n+    private boolean carpet_boost = true;\n+    private @Nullable Boolean vac_high = null;\n+    private boolean isPaused = false;\n+\n+    public RoombaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.trace(\"initialize()\");\n+        config = getConfigAs(RoombaConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+        connect();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.trace(\"dispose()\");\n+\n+        singleThread.execute(() -> {\n+            if (reconnectReq != null) {\n+                reconnectReq.cancel(false);\n+                reconnectReq = null;\n+            }\n+\n+            if (connection != null) {\n+                connection.stop();\n+                connection = null;\n+            }\n+        });\n+    }\n+\n+    // lastState.get() can return null if the key is not found according\n+    // to the documentation\n+    @SuppressWarnings(\"null\")\n+    private void handleRefresh(String ch) {\n+        State value = lastState.get(ch);\n+\n+        if (value != null) {\n+            updateState(ch, value);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String ch = channelUID.getId();\n+        if (command instanceof RefreshType) {\n+            handleRefresh(ch);\n+            return;\n+        }\n+\n+        if (ch.equals(CHANNEL_COMMAND)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+\n+                if (cmd.equals(CMD_CLEAN)) {\n+                    cmd = isPaused ? \"resume\" : \"start\";\n+                }\n+\n+                sendRequest(new MQTTProtocol.CommandRequest(cmd));\n+            }\n+        } else if (ch.startsWith(CHANNEL_SCHED_SWITCH_PREFIX)) {\n+            MQTTProtocol.Schedule schedule = lastSchedule;\n+\n+            // Schedule can only be updated in a bulk, so we have to store current\n+            // schedule and modify components.\n+            if (command instanceof OnOffType && schedule != null && schedule.cycle != null) {\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    if (ch.equals(CHANNEL_SCHED_SWITCH[i])) {\n+                        MQTTProtocol.Schedule newSchedule = new MQTTProtocol.Schedule(schedule.cycle);\n+\n+                        newSchedule.enableCycle(i, command.equals(OnOffType.ON));\n+                        sendSchedule(newSchedule);\n+                        break;\n+                    }\n+                }\n+            }\n+        } else if (ch.equals(CHANNEL_SCHEDULE)) {\n+            if (command instanceof DecimalType) {\n+                int bitmask = ((DecimalType) command).intValue();\n+                JsonArray cycle = new JsonArray();\n+\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    enableCycle(cycle, i, (bitmask & (1 << i)) != 0);\n+                }\n+\n+                sendSchedule(new MQTTProtocol.Schedule(bitmask));\n+            }\n+        } else if (ch.equals(CHANNEL_EDGE_CLEAN)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.OpenOnly(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_ALWAYS_FINISH)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.BinPause(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_POWER_BOOST)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+                sendDelta(new MQTTProtocol.PowerBoost(cmd.equals(BOOST_AUTO), cmd.equals(BOOST_PERFORMANCE)));\n+            }\n+        } else if (ch.equals(CHANNEL_CLEAN_PASSES)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+                sendDelta(new MQTTProtocol.CleanPasses(!cmd.equals(PASSES_AUTO), cmd.equals(PASSES_2)));\n+            }\n+        }\n+    }\n+\n+    private void enableCycle(JsonArray cycle, int i, boolean enable) {\n+        JsonPrimitive value = new JsonPrimitive(enable ? \"start\" : \"none\");\n+        cycle.set(i, value);\n+    }\n+\n+    private void sendSchedule(MQTTProtocol.Schedule schedule) {\n+        sendDelta(new MQTTProtocol.CleanSchedule(schedule));\n+    }\n+\n+    private void sendDelta(MQTTProtocol.StateValue state) {\n+        sendRequest(new MQTTProtocol.DeltaRequest(state));\n+    }\n+\n+    private void sendRequest(MQTTProtocol.Request request) {\n+        RoombaMqttBrokerConnection conn = connection;\n+\n+        if (conn != null) {\n+            String json = new Gson().toJson(request);\n+            logger.trace(\"Sending {}: {}\", request.getTopic(), json);\n+            conn.publish(request.getTopic(), json.getBytes());\n+        }\n+    }\n+\n+    private void connect() {\n+        // In order not to mess up our connection state we need to make sure\n+        // that any two calls are never running concurrently. We use\n+        // singleThreadExecutorService for this purpose\n+        singleThread.execute(() -> {\n+            String error = null;\n+\n+            logger.info(\"Connecting to {}\", config.ipaddress);\n+\n+            try {\n+                InetAddress host = InetAddress.getByName(config.ipaddress);\n+                String blid = this.blid;\n+\n+                if (blid == null) {\n+                    DatagramSocket identSocket = IdentProtocol.sendRequest(host);\n+                    DatagramPacket identPacket = IdentProtocol.receiveResponse(identSocket);\n+                    IdentProtocol.IdentData ident;\n+\n+                    identSocket.close();\n+\n+                    try {\n+                        ident = IdentProtocol.decodeResponse(identPacket);\n+                    } catch (JsonParseException e) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Malformed IDENT response\");\n+                        return;\n+                    }\n+\n+                    if (ident.ver < IdentData.MIN_SUPPORTED_VERSION) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                \"Unsupported version \" + ident.ver);\n+                        return;\n+                    }\n+\n+                    if (!ident.product.equals(IdentData.PRODUCT_ROOMBA)) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                \"Not a Roomba: \" + ident.product);\n+                        return;\n+                    }\n+\n+                    blid = ident.blid;\n+                    this.blid = blid;\n+                }\n+\n+                logger.debug(\"BLID is: {}\", blid);\n+\n+                if (!config.havePassword()) {\n+                    RawMQTT mqtt;\n+\n+                    try {\n+                        mqtt = new RawMQTT(host, 8883);\n+                    } catch (KeyManagementException | NoSuchAlgorithmException e1) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e1.toString());\n+                        return; // This is internal system error, no retry\n+                    }\n+\n+                    mqtt.requestPassword();\n+                    RawMQTT.Packet response = mqtt.readPacket();\n+                    mqtt.close();\n+\n+                    if (response != null && response.isValidPasswdPacket()) {\n+                        RawMQTT.PasswdPacket passwdPacket = new RawMQTT.PasswdPacket(response);\n+\n+                        config.password = passwdPacket.getPassword();\n+                        if (config.havePassword()) {\n+                            Configuration configuration = editConfiguration();\n+\n+                            configuration.put(RoombaConfiguration.FIELD_PASSWORD, config.password);\n+                            updateConfiguration(configuration);\n+                        }\n+                    }\n+                }\n+\n+                if (!config.havePassword()) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING,\n+                            \"Authentication on the robot is required\");\n+                    scheduleReconnect();\n+                    return;\n+                }\n+\n+                logger.debug(\"Password is: {}\", config.password);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk4NDkwNA=="}, "originalCommit": {"oid": "e9674556c16225cbbe635a06414cbf94eda1ea4c"}, "originalPosition": 294}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjkyMjc5Mg==", "bodyText": "Meanwhile removed :)", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r512922792", "createdAt": "2020-10-27T18:13:35Z", "author": {"login": "Sonic-Amiga"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.handler;\n+\n+import static org.openhab.binding.irobot.IRobotBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Hashtable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.internal.MQTTProtocol;\n+import org.openhab.binding.irobot.internal.RawMQTT;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.binding.irobot.roomba.RoombaMqttBrokerConnection;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The {@link RoombaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author hkuhn42 - Initial contribution\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Rewrite for 900 series\n+ */\n+@NonNullByDefault\n+public class RoombaHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(RoombaHandler.class);\n+    private final ExecutorService singleThread = Executors.newSingleThreadExecutor();\n+    private static final int reconnectDelay = 5; // In seconds\n+    private @Nullable Future<?> reconnectReq;\n+    // Dummy RoombaConfiguration object in order to shut up Eclipse warnings\n+    // The real one is set in initialize()\n+    private RoombaConfiguration config = new RoombaConfiguration();\n+    private @Nullable String blid = null;\n+    private @Nullable RoombaMqttBrokerConnection connection;\n+    private Hashtable<String, State> lastState = new Hashtable<String, State>();\n+    private MQTTProtocol.@Nullable Schedule lastSchedule = null;\n+    private boolean auto_passes = true;\n+    private @Nullable Boolean two_passes = null;\n+    private boolean carpet_boost = true;\n+    private @Nullable Boolean vac_high = null;\n+    private boolean isPaused = false;\n+\n+    public RoombaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.trace(\"initialize()\");\n+        config = getConfigAs(RoombaConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+        connect();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.trace(\"dispose()\");\n+\n+        singleThread.execute(() -> {\n+            if (reconnectReq != null) {\n+                reconnectReq.cancel(false);\n+                reconnectReq = null;\n+            }\n+\n+            if (connection != null) {\n+                connection.stop();\n+                connection = null;\n+            }\n+        });\n+    }\n+\n+    // lastState.get() can return null if the key is not found according\n+    // to the documentation\n+    @SuppressWarnings(\"null\")\n+    private void handleRefresh(String ch) {\n+        State value = lastState.get(ch);\n+\n+        if (value != null) {\n+            updateState(ch, value);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String ch = channelUID.getId();\n+        if (command instanceof RefreshType) {\n+            handleRefresh(ch);\n+            return;\n+        }\n+\n+        if (ch.equals(CHANNEL_COMMAND)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+\n+                if (cmd.equals(CMD_CLEAN)) {\n+                    cmd = isPaused ? \"resume\" : \"start\";\n+                }\n+\n+                sendRequest(new MQTTProtocol.CommandRequest(cmd));\n+            }\n+        } else if (ch.startsWith(CHANNEL_SCHED_SWITCH_PREFIX)) {\n+            MQTTProtocol.Schedule schedule = lastSchedule;\n+\n+            // Schedule can only be updated in a bulk, so we have to store current\n+            // schedule and modify components.\n+            if (command instanceof OnOffType && schedule != null && schedule.cycle != null) {\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    if (ch.equals(CHANNEL_SCHED_SWITCH[i])) {\n+                        MQTTProtocol.Schedule newSchedule = new MQTTProtocol.Schedule(schedule.cycle);\n+\n+                        newSchedule.enableCycle(i, command.equals(OnOffType.ON));\n+                        sendSchedule(newSchedule);\n+                        break;\n+                    }\n+                }\n+            }\n+        } else if (ch.equals(CHANNEL_SCHEDULE)) {\n+            if (command instanceof DecimalType) {\n+                int bitmask = ((DecimalType) command).intValue();\n+                JsonArray cycle = new JsonArray();\n+\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    enableCycle(cycle, i, (bitmask & (1 << i)) != 0);\n+                }\n+\n+                sendSchedule(new MQTTProtocol.Schedule(bitmask));\n+            }\n+        } else if (ch.equals(CHANNEL_EDGE_CLEAN)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.OpenOnly(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_ALWAYS_FINISH)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.BinPause(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_POWER_BOOST)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+                sendDelta(new MQTTProtocol.PowerBoost(cmd.equals(BOOST_AUTO), cmd.equals(BOOST_PERFORMANCE)));\n+            }\n+        } else if (ch.equals(CHANNEL_CLEAN_PASSES)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+                sendDelta(new MQTTProtocol.CleanPasses(!cmd.equals(PASSES_AUTO), cmd.equals(PASSES_2)));\n+            }\n+        }\n+    }\n+\n+    private void enableCycle(JsonArray cycle, int i, boolean enable) {\n+        JsonPrimitive value = new JsonPrimitive(enable ? \"start\" : \"none\");\n+        cycle.set(i, value);\n+    }\n+\n+    private void sendSchedule(MQTTProtocol.Schedule schedule) {\n+        sendDelta(new MQTTProtocol.CleanSchedule(schedule));\n+    }\n+\n+    private void sendDelta(MQTTProtocol.StateValue state) {\n+        sendRequest(new MQTTProtocol.DeltaRequest(state));\n+    }\n+\n+    private void sendRequest(MQTTProtocol.Request request) {\n+        RoombaMqttBrokerConnection conn = connection;\n+\n+        if (conn != null) {\n+            String json = new Gson().toJson(request);\n+            logger.trace(\"Sending {}: {}\", request.getTopic(), json);\n+            conn.publish(request.getTopic(), json.getBytes());\n+        }\n+    }\n+\n+    private void connect() {\n+        // In order not to mess up our connection state we need to make sure\n+        // that any two calls are never running concurrently. We use\n+        // singleThreadExecutorService for this purpose\n+        singleThread.execute(() -> {\n+            String error = null;\n+\n+            logger.info(\"Connecting to {}\", config.ipaddress);\n+\n+            try {\n+                InetAddress host = InetAddress.getByName(config.ipaddress);\n+                String blid = this.blid;\n+\n+                if (blid == null) {\n+                    DatagramSocket identSocket = IdentProtocol.sendRequest(host);\n+                    DatagramPacket identPacket = IdentProtocol.receiveResponse(identSocket);\n+                    IdentProtocol.IdentData ident;\n+\n+                    identSocket.close();\n+\n+                    try {\n+                        ident = IdentProtocol.decodeResponse(identPacket);\n+                    } catch (JsonParseException e) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Malformed IDENT response\");\n+                        return;\n+                    }\n+\n+                    if (ident.ver < IdentData.MIN_SUPPORTED_VERSION) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                \"Unsupported version \" + ident.ver);\n+                        return;\n+                    }\n+\n+                    if (!ident.product.equals(IdentData.PRODUCT_ROOMBA)) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                \"Not a Roomba: \" + ident.product);\n+                        return;\n+                    }\n+\n+                    blid = ident.blid;\n+                    this.blid = blid;\n+                }\n+\n+                logger.debug(\"BLID is: {}\", blid);\n+\n+                if (!config.havePassword()) {\n+                    RawMQTT mqtt;\n+\n+                    try {\n+                        mqtt = new RawMQTT(host, 8883);\n+                    } catch (KeyManagementException | NoSuchAlgorithmException e1) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e1.toString());\n+                        return; // This is internal system error, no retry\n+                    }\n+\n+                    mqtt.requestPassword();\n+                    RawMQTT.Packet response = mqtt.readPacket();\n+                    mqtt.close();\n+\n+                    if (response != null && response.isValidPasswdPacket()) {\n+                        RawMQTT.PasswdPacket passwdPacket = new RawMQTT.PasswdPacket(response);\n+\n+                        config.password = passwdPacket.getPassword();\n+                        if (config.havePassword()) {\n+                            Configuration configuration = editConfiguration();\n+\n+                            configuration.put(RoombaConfiguration.FIELD_PASSWORD, config.password);\n+                            updateConfiguration(configuration);\n+                        }\n+                    }\n+                }\n+\n+                if (!config.havePassword()) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING,\n+                            \"Authentication on the robot is required\");\n+                    scheduleReconnect();\n+                    return;\n+                }\n+\n+                logger.debug(\"Password is: {}\", config.password);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk4NDkwNA=="}, "originalCommit": {"oid": "e9674556c16225cbbe635a06414cbf94eda1ea4c"}, "originalPosition": 294}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMDk1ODkyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNjowMDoxNlrOHnUDwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNjowMDoxNlrOHnUDwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk4NTE1Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            error = e.toString();\n          \n          \n            \n                            error = e.getMessage();", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r510985152", "createdAt": "2020-10-23T16:00:16Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.handler;\n+\n+import static org.openhab.binding.irobot.IRobotBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Hashtable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.internal.MQTTProtocol;\n+import org.openhab.binding.irobot.internal.RawMQTT;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.binding.irobot.roomba.RoombaMqttBrokerConnection;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The {@link RoombaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author hkuhn42 - Initial contribution\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Rewrite for 900 series\n+ */\n+@NonNullByDefault\n+public class RoombaHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(RoombaHandler.class);\n+    private final ExecutorService singleThread = Executors.newSingleThreadExecutor();\n+    private static final int reconnectDelay = 5; // In seconds\n+    private @Nullable Future<?> reconnectReq;\n+    // Dummy RoombaConfiguration object in order to shut up Eclipse warnings\n+    // The real one is set in initialize()\n+    private RoombaConfiguration config = new RoombaConfiguration();\n+    private @Nullable String blid = null;\n+    private @Nullable RoombaMqttBrokerConnection connection;\n+    private Hashtable<String, State> lastState = new Hashtable<String, State>();\n+    private MQTTProtocol.@Nullable Schedule lastSchedule = null;\n+    private boolean auto_passes = true;\n+    private @Nullable Boolean two_passes = null;\n+    private boolean carpet_boost = true;\n+    private @Nullable Boolean vac_high = null;\n+    private boolean isPaused = false;\n+\n+    public RoombaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.trace(\"initialize()\");\n+        config = getConfigAs(RoombaConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+        connect();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.trace(\"dispose()\");\n+\n+        singleThread.execute(() -> {\n+            if (reconnectReq != null) {\n+                reconnectReq.cancel(false);\n+                reconnectReq = null;\n+            }\n+\n+            if (connection != null) {\n+                connection.stop();\n+                connection = null;\n+            }\n+        });\n+    }\n+\n+    // lastState.get() can return null if the key is not found according\n+    // to the documentation\n+    @SuppressWarnings(\"null\")\n+    private void handleRefresh(String ch) {\n+        State value = lastState.get(ch);\n+\n+        if (value != null) {\n+            updateState(ch, value);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String ch = channelUID.getId();\n+        if (command instanceof RefreshType) {\n+            handleRefresh(ch);\n+            return;\n+        }\n+\n+        if (ch.equals(CHANNEL_COMMAND)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+\n+                if (cmd.equals(CMD_CLEAN)) {\n+                    cmd = isPaused ? \"resume\" : \"start\";\n+                }\n+\n+                sendRequest(new MQTTProtocol.CommandRequest(cmd));\n+            }\n+        } else if (ch.startsWith(CHANNEL_SCHED_SWITCH_PREFIX)) {\n+            MQTTProtocol.Schedule schedule = lastSchedule;\n+\n+            // Schedule can only be updated in a bulk, so we have to store current\n+            // schedule and modify components.\n+            if (command instanceof OnOffType && schedule != null && schedule.cycle != null) {\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    if (ch.equals(CHANNEL_SCHED_SWITCH[i])) {\n+                        MQTTProtocol.Schedule newSchedule = new MQTTProtocol.Schedule(schedule.cycle);\n+\n+                        newSchedule.enableCycle(i, command.equals(OnOffType.ON));\n+                        sendSchedule(newSchedule);\n+                        break;\n+                    }\n+                }\n+            }\n+        } else if (ch.equals(CHANNEL_SCHEDULE)) {\n+            if (command instanceof DecimalType) {\n+                int bitmask = ((DecimalType) command).intValue();\n+                JsonArray cycle = new JsonArray();\n+\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    enableCycle(cycle, i, (bitmask & (1 << i)) != 0);\n+                }\n+\n+                sendSchedule(new MQTTProtocol.Schedule(bitmask));\n+            }\n+        } else if (ch.equals(CHANNEL_EDGE_CLEAN)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.OpenOnly(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_ALWAYS_FINISH)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.BinPause(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_POWER_BOOST)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+                sendDelta(new MQTTProtocol.PowerBoost(cmd.equals(BOOST_AUTO), cmd.equals(BOOST_PERFORMANCE)));\n+            }\n+        } else if (ch.equals(CHANNEL_CLEAN_PASSES)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+                sendDelta(new MQTTProtocol.CleanPasses(!cmd.equals(PASSES_AUTO), cmd.equals(PASSES_2)));\n+            }\n+        }\n+    }\n+\n+    private void enableCycle(JsonArray cycle, int i, boolean enable) {\n+        JsonPrimitive value = new JsonPrimitive(enable ? \"start\" : \"none\");\n+        cycle.set(i, value);\n+    }\n+\n+    private void sendSchedule(MQTTProtocol.Schedule schedule) {\n+        sendDelta(new MQTTProtocol.CleanSchedule(schedule));\n+    }\n+\n+    private void sendDelta(MQTTProtocol.StateValue state) {\n+        sendRequest(new MQTTProtocol.DeltaRequest(state));\n+    }\n+\n+    private void sendRequest(MQTTProtocol.Request request) {\n+        RoombaMqttBrokerConnection conn = connection;\n+\n+        if (conn != null) {\n+            String json = new Gson().toJson(request);\n+            logger.trace(\"Sending {}: {}\", request.getTopic(), json);\n+            conn.publish(request.getTopic(), json.getBytes());\n+        }\n+    }\n+\n+    private void connect() {\n+        // In order not to mess up our connection state we need to make sure\n+        // that any two calls are never running concurrently. We use\n+        // singleThreadExecutorService for this purpose\n+        singleThread.execute(() -> {\n+            String error = null;\n+\n+            logger.info(\"Connecting to {}\", config.ipaddress);\n+\n+            try {\n+                InetAddress host = InetAddress.getByName(config.ipaddress);\n+                String blid = this.blid;\n+\n+                if (blid == null) {\n+                    DatagramSocket identSocket = IdentProtocol.sendRequest(host);\n+                    DatagramPacket identPacket = IdentProtocol.receiveResponse(identSocket);\n+                    IdentProtocol.IdentData ident;\n+\n+                    identSocket.close();\n+\n+                    try {\n+                        ident = IdentProtocol.decodeResponse(identPacket);\n+                    } catch (JsonParseException e) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Malformed IDENT response\");\n+                        return;\n+                    }\n+\n+                    if (ident.ver < IdentData.MIN_SUPPORTED_VERSION) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                \"Unsupported version \" + ident.ver);\n+                        return;\n+                    }\n+\n+                    if (!ident.product.equals(IdentData.PRODUCT_ROOMBA)) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                \"Not a Roomba: \" + ident.product);\n+                        return;\n+                    }\n+\n+                    blid = ident.blid;\n+                    this.blid = blid;\n+                }\n+\n+                logger.debug(\"BLID is: {}\", blid);\n+\n+                if (!config.havePassword()) {\n+                    RawMQTT mqtt;\n+\n+                    try {\n+                        mqtt = new RawMQTT(host, 8883);\n+                    } catch (KeyManagementException | NoSuchAlgorithmException e1) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e1.toString());\n+                        return; // This is internal system error, no retry\n+                    }\n+\n+                    mqtt.requestPassword();\n+                    RawMQTT.Packet response = mqtt.readPacket();\n+                    mqtt.close();\n+\n+                    if (response != null && response.isValidPasswdPacket()) {\n+                        RawMQTT.PasswdPacket passwdPacket = new RawMQTT.PasswdPacket(response);\n+\n+                        config.password = passwdPacket.getPassword();\n+                        if (config.havePassword()) {\n+                            Configuration configuration = editConfiguration();\n+\n+                            configuration.put(RoombaConfiguration.FIELD_PASSWORD, config.password);\n+                            updateConfiguration(configuration);\n+                        }\n+                    }\n+                }\n+\n+                if (!config.havePassword()) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING,\n+                            \"Authentication on the robot is required\");\n+                    scheduleReconnect();\n+                    return;\n+                }\n+\n+                logger.debug(\"Password is: {}\", config.password);\n+\n+                // BLID is used as both client ID and username. The name of BLID also came from Roomba980-python\n+                connection = new RoombaMqttBrokerConnection(config.ipaddress, blid, this);\n+                connection.start(blid, config.password);\n+\n+            } catch (IOException e) {\n+                error = e.toString();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9674556c16225cbbe635a06414cbf94eda1ea4c"}, "originalPosition": 301}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMDk2MDE3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNjowMDozNlrOHnUEgg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMVQxMTo1OTowMVrOHrug6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk4NTM0Ng==", "bodyText": "The log message could be removed, as the status update is already logged by the framework.", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r510985346", "createdAt": "2020-10-23T16:00:36Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.handler;\n+\n+import static org.openhab.binding.irobot.IRobotBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Hashtable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.internal.MQTTProtocol;\n+import org.openhab.binding.irobot.internal.RawMQTT;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.binding.irobot.roomba.RoombaMqttBrokerConnection;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The {@link RoombaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author hkuhn42 - Initial contribution\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Rewrite for 900 series\n+ */\n+@NonNullByDefault\n+public class RoombaHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(RoombaHandler.class);\n+    private final ExecutorService singleThread = Executors.newSingleThreadExecutor();\n+    private static final int reconnectDelay = 5; // In seconds\n+    private @Nullable Future<?> reconnectReq;\n+    // Dummy RoombaConfiguration object in order to shut up Eclipse warnings\n+    // The real one is set in initialize()\n+    private RoombaConfiguration config = new RoombaConfiguration();\n+    private @Nullable String blid = null;\n+    private @Nullable RoombaMqttBrokerConnection connection;\n+    private Hashtable<String, State> lastState = new Hashtable<String, State>();\n+    private MQTTProtocol.@Nullable Schedule lastSchedule = null;\n+    private boolean auto_passes = true;\n+    private @Nullable Boolean two_passes = null;\n+    private boolean carpet_boost = true;\n+    private @Nullable Boolean vac_high = null;\n+    private boolean isPaused = false;\n+\n+    public RoombaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.trace(\"initialize()\");\n+        config = getConfigAs(RoombaConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+        connect();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.trace(\"dispose()\");\n+\n+        singleThread.execute(() -> {\n+            if (reconnectReq != null) {\n+                reconnectReq.cancel(false);\n+                reconnectReq = null;\n+            }\n+\n+            if (connection != null) {\n+                connection.stop();\n+                connection = null;\n+            }\n+        });\n+    }\n+\n+    // lastState.get() can return null if the key is not found according\n+    // to the documentation\n+    @SuppressWarnings(\"null\")\n+    private void handleRefresh(String ch) {\n+        State value = lastState.get(ch);\n+\n+        if (value != null) {\n+            updateState(ch, value);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String ch = channelUID.getId();\n+        if (command instanceof RefreshType) {\n+            handleRefresh(ch);\n+            return;\n+        }\n+\n+        if (ch.equals(CHANNEL_COMMAND)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+\n+                if (cmd.equals(CMD_CLEAN)) {\n+                    cmd = isPaused ? \"resume\" : \"start\";\n+                }\n+\n+                sendRequest(new MQTTProtocol.CommandRequest(cmd));\n+            }\n+        } else if (ch.startsWith(CHANNEL_SCHED_SWITCH_PREFIX)) {\n+            MQTTProtocol.Schedule schedule = lastSchedule;\n+\n+            // Schedule can only be updated in a bulk, so we have to store current\n+            // schedule and modify components.\n+            if (command instanceof OnOffType && schedule != null && schedule.cycle != null) {\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    if (ch.equals(CHANNEL_SCHED_SWITCH[i])) {\n+                        MQTTProtocol.Schedule newSchedule = new MQTTProtocol.Schedule(schedule.cycle);\n+\n+                        newSchedule.enableCycle(i, command.equals(OnOffType.ON));\n+                        sendSchedule(newSchedule);\n+                        break;\n+                    }\n+                }\n+            }\n+        } else if (ch.equals(CHANNEL_SCHEDULE)) {\n+            if (command instanceof DecimalType) {\n+                int bitmask = ((DecimalType) command).intValue();\n+                JsonArray cycle = new JsonArray();\n+\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    enableCycle(cycle, i, (bitmask & (1 << i)) != 0);\n+                }\n+\n+                sendSchedule(new MQTTProtocol.Schedule(bitmask));\n+            }\n+        } else if (ch.equals(CHANNEL_EDGE_CLEAN)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.OpenOnly(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_ALWAYS_FINISH)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.BinPause(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_POWER_BOOST)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+                sendDelta(new MQTTProtocol.PowerBoost(cmd.equals(BOOST_AUTO), cmd.equals(BOOST_PERFORMANCE)));\n+            }\n+        } else if (ch.equals(CHANNEL_CLEAN_PASSES)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+                sendDelta(new MQTTProtocol.CleanPasses(!cmd.equals(PASSES_AUTO), cmd.equals(PASSES_2)));\n+            }\n+        }\n+    }\n+\n+    private void enableCycle(JsonArray cycle, int i, boolean enable) {\n+        JsonPrimitive value = new JsonPrimitive(enable ? \"start\" : \"none\");\n+        cycle.set(i, value);\n+    }\n+\n+    private void sendSchedule(MQTTProtocol.Schedule schedule) {\n+        sendDelta(new MQTTProtocol.CleanSchedule(schedule));\n+    }\n+\n+    private void sendDelta(MQTTProtocol.StateValue state) {\n+        sendRequest(new MQTTProtocol.DeltaRequest(state));\n+    }\n+\n+    private void sendRequest(MQTTProtocol.Request request) {\n+        RoombaMqttBrokerConnection conn = connection;\n+\n+        if (conn != null) {\n+            String json = new Gson().toJson(request);\n+            logger.trace(\"Sending {}: {}\", request.getTopic(), json);\n+            conn.publish(request.getTopic(), json.getBytes());\n+        }\n+    }\n+\n+    private void connect() {\n+        // In order not to mess up our connection state we need to make sure\n+        // that any two calls are never running concurrently. We use\n+        // singleThreadExecutorService for this purpose\n+        singleThread.execute(() -> {\n+            String error = null;\n+\n+            logger.info(\"Connecting to {}\", config.ipaddress);\n+\n+            try {\n+                InetAddress host = InetAddress.getByName(config.ipaddress);\n+                String blid = this.blid;\n+\n+                if (blid == null) {\n+                    DatagramSocket identSocket = IdentProtocol.sendRequest(host);\n+                    DatagramPacket identPacket = IdentProtocol.receiveResponse(identSocket);\n+                    IdentProtocol.IdentData ident;\n+\n+                    identSocket.close();\n+\n+                    try {\n+                        ident = IdentProtocol.decodeResponse(identPacket);\n+                    } catch (JsonParseException e) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Malformed IDENT response\");\n+                        return;\n+                    }\n+\n+                    if (ident.ver < IdentData.MIN_SUPPORTED_VERSION) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                \"Unsupported version \" + ident.ver);\n+                        return;\n+                    }\n+\n+                    if (!ident.product.equals(IdentData.PRODUCT_ROOMBA)) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                \"Not a Roomba: \" + ident.product);\n+                        return;\n+                    }\n+\n+                    blid = ident.blid;\n+                    this.blid = blid;\n+                }\n+\n+                logger.debug(\"BLID is: {}\", blid);\n+\n+                if (!config.havePassword()) {\n+                    RawMQTT mqtt;\n+\n+                    try {\n+                        mqtt = new RawMQTT(host, 8883);\n+                    } catch (KeyManagementException | NoSuchAlgorithmException e1) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e1.toString());\n+                        return; // This is internal system error, no retry\n+                    }\n+\n+                    mqtt.requestPassword();\n+                    RawMQTT.Packet response = mqtt.readPacket();\n+                    mqtt.close();\n+\n+                    if (response != null && response.isValidPasswdPacket()) {\n+                        RawMQTT.PasswdPacket passwdPacket = new RawMQTT.PasswdPacket(response);\n+\n+                        config.password = passwdPacket.getPassword();\n+                        if (config.havePassword()) {\n+                            Configuration configuration = editConfiguration();\n+\n+                            configuration.put(RoombaConfiguration.FIELD_PASSWORD, config.password);\n+                            updateConfiguration(configuration);\n+                        }\n+                    }\n+                }\n+\n+                if (!config.havePassword()) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING,\n+                            \"Authentication on the robot is required\");\n+                    scheduleReconnect();\n+                    return;\n+                }\n+\n+                logger.debug(\"Password is: {}\", config.password);\n+\n+                // BLID is used as both client ID and username. The name of BLID also came from Roomba980-python\n+                connection = new RoombaMqttBrokerConnection(config.ipaddress, blid, this);\n+                connection.start(blid, config.password);\n+\n+            } catch (IOException e) {\n+                error = e.toString();\n+            }\n+\n+            if (error != null) {\n+                logger.error(error);\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, error);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9674556c16225cbbe635a06414cbf94eda1ea4c"}, "originalPosition": 306}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTQ3MDc2Nw==", "bodyText": "I'll still leave it under debug level, it has just helped me to find and debug one issue, and it could be used to resolve possible problems on user's side.\nThere seems to be a firmware quirk or bug in Roomba", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r511470767", "createdAt": "2020-10-24T14:26:47Z", "author": {"login": "Sonic-Amiga"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.handler;\n+\n+import static org.openhab.binding.irobot.IRobotBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Hashtable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.internal.MQTTProtocol;\n+import org.openhab.binding.irobot.internal.RawMQTT;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.binding.irobot.roomba.RoombaMqttBrokerConnection;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The {@link RoombaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author hkuhn42 - Initial contribution\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Rewrite for 900 series\n+ */\n+@NonNullByDefault\n+public class RoombaHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(RoombaHandler.class);\n+    private final ExecutorService singleThread = Executors.newSingleThreadExecutor();\n+    private static final int reconnectDelay = 5; // In seconds\n+    private @Nullable Future<?> reconnectReq;\n+    // Dummy RoombaConfiguration object in order to shut up Eclipse warnings\n+    // The real one is set in initialize()\n+    private RoombaConfiguration config = new RoombaConfiguration();\n+    private @Nullable String blid = null;\n+    private @Nullable RoombaMqttBrokerConnection connection;\n+    private Hashtable<String, State> lastState = new Hashtable<String, State>();\n+    private MQTTProtocol.@Nullable Schedule lastSchedule = null;\n+    private boolean auto_passes = true;\n+    private @Nullable Boolean two_passes = null;\n+    private boolean carpet_boost = true;\n+    private @Nullable Boolean vac_high = null;\n+    private boolean isPaused = false;\n+\n+    public RoombaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.trace(\"initialize()\");\n+        config = getConfigAs(RoombaConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+        connect();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.trace(\"dispose()\");\n+\n+        singleThread.execute(() -> {\n+            if (reconnectReq != null) {\n+                reconnectReq.cancel(false);\n+                reconnectReq = null;\n+            }\n+\n+            if (connection != null) {\n+                connection.stop();\n+                connection = null;\n+            }\n+        });\n+    }\n+\n+    // lastState.get() can return null if the key is not found according\n+    // to the documentation\n+    @SuppressWarnings(\"null\")\n+    private void handleRefresh(String ch) {\n+        State value = lastState.get(ch);\n+\n+        if (value != null) {\n+            updateState(ch, value);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String ch = channelUID.getId();\n+        if (command instanceof RefreshType) {\n+            handleRefresh(ch);\n+            return;\n+        }\n+\n+        if (ch.equals(CHANNEL_COMMAND)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+\n+                if (cmd.equals(CMD_CLEAN)) {\n+                    cmd = isPaused ? \"resume\" : \"start\";\n+                }\n+\n+                sendRequest(new MQTTProtocol.CommandRequest(cmd));\n+            }\n+        } else if (ch.startsWith(CHANNEL_SCHED_SWITCH_PREFIX)) {\n+            MQTTProtocol.Schedule schedule = lastSchedule;\n+\n+            // Schedule can only be updated in a bulk, so we have to store current\n+            // schedule and modify components.\n+            if (command instanceof OnOffType && schedule != null && schedule.cycle != null) {\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    if (ch.equals(CHANNEL_SCHED_SWITCH[i])) {\n+                        MQTTProtocol.Schedule newSchedule = new MQTTProtocol.Schedule(schedule.cycle);\n+\n+                        newSchedule.enableCycle(i, command.equals(OnOffType.ON));\n+                        sendSchedule(newSchedule);\n+                        break;\n+                    }\n+                }\n+            }\n+        } else if (ch.equals(CHANNEL_SCHEDULE)) {\n+            if (command instanceof DecimalType) {\n+                int bitmask = ((DecimalType) command).intValue();\n+                JsonArray cycle = new JsonArray();\n+\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    enableCycle(cycle, i, (bitmask & (1 << i)) != 0);\n+                }\n+\n+                sendSchedule(new MQTTProtocol.Schedule(bitmask));\n+            }\n+        } else if (ch.equals(CHANNEL_EDGE_CLEAN)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.OpenOnly(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_ALWAYS_FINISH)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.BinPause(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_POWER_BOOST)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+                sendDelta(new MQTTProtocol.PowerBoost(cmd.equals(BOOST_AUTO), cmd.equals(BOOST_PERFORMANCE)));\n+            }\n+        } else if (ch.equals(CHANNEL_CLEAN_PASSES)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+                sendDelta(new MQTTProtocol.CleanPasses(!cmd.equals(PASSES_AUTO), cmd.equals(PASSES_2)));\n+            }\n+        }\n+    }\n+\n+    private void enableCycle(JsonArray cycle, int i, boolean enable) {\n+        JsonPrimitive value = new JsonPrimitive(enable ? \"start\" : \"none\");\n+        cycle.set(i, value);\n+    }\n+\n+    private void sendSchedule(MQTTProtocol.Schedule schedule) {\n+        sendDelta(new MQTTProtocol.CleanSchedule(schedule));\n+    }\n+\n+    private void sendDelta(MQTTProtocol.StateValue state) {\n+        sendRequest(new MQTTProtocol.DeltaRequest(state));\n+    }\n+\n+    private void sendRequest(MQTTProtocol.Request request) {\n+        RoombaMqttBrokerConnection conn = connection;\n+\n+        if (conn != null) {\n+            String json = new Gson().toJson(request);\n+            logger.trace(\"Sending {}: {}\", request.getTopic(), json);\n+            conn.publish(request.getTopic(), json.getBytes());\n+        }\n+    }\n+\n+    private void connect() {\n+        // In order not to mess up our connection state we need to make sure\n+        // that any two calls are never running concurrently. We use\n+        // singleThreadExecutorService for this purpose\n+        singleThread.execute(() -> {\n+            String error = null;\n+\n+            logger.info(\"Connecting to {}\", config.ipaddress);\n+\n+            try {\n+                InetAddress host = InetAddress.getByName(config.ipaddress);\n+                String blid = this.blid;\n+\n+                if (blid == null) {\n+                    DatagramSocket identSocket = IdentProtocol.sendRequest(host);\n+                    DatagramPacket identPacket = IdentProtocol.receiveResponse(identSocket);\n+                    IdentProtocol.IdentData ident;\n+\n+                    identSocket.close();\n+\n+                    try {\n+                        ident = IdentProtocol.decodeResponse(identPacket);\n+                    } catch (JsonParseException e) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Malformed IDENT response\");\n+                        return;\n+                    }\n+\n+                    if (ident.ver < IdentData.MIN_SUPPORTED_VERSION) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                \"Unsupported version \" + ident.ver);\n+                        return;\n+                    }\n+\n+                    if (!ident.product.equals(IdentData.PRODUCT_ROOMBA)) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                \"Not a Roomba: \" + ident.product);\n+                        return;\n+                    }\n+\n+                    blid = ident.blid;\n+                    this.blid = blid;\n+                }\n+\n+                logger.debug(\"BLID is: {}\", blid);\n+\n+                if (!config.havePassword()) {\n+                    RawMQTT mqtt;\n+\n+                    try {\n+                        mqtt = new RawMQTT(host, 8883);\n+                    } catch (KeyManagementException | NoSuchAlgorithmException e1) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e1.toString());\n+                        return; // This is internal system error, no retry\n+                    }\n+\n+                    mqtt.requestPassword();\n+                    RawMQTT.Packet response = mqtt.readPacket();\n+                    mqtt.close();\n+\n+                    if (response != null && response.isValidPasswdPacket()) {\n+                        RawMQTT.PasswdPacket passwdPacket = new RawMQTT.PasswdPacket(response);\n+\n+                        config.password = passwdPacket.getPassword();\n+                        if (config.havePassword()) {\n+                            Configuration configuration = editConfiguration();\n+\n+                            configuration.put(RoombaConfiguration.FIELD_PASSWORD, config.password);\n+                            updateConfiguration(configuration);\n+                        }\n+                    }\n+                }\n+\n+                if (!config.havePassword()) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING,\n+                            \"Authentication on the robot is required\");\n+                    scheduleReconnect();\n+                    return;\n+                }\n+\n+                logger.debug(\"Password is: {}\", config.password);\n+\n+                // BLID is used as both client ID and username. The name of BLID also came from Roomba980-python\n+                connection = new RoombaMqttBrokerConnection(config.ipaddress, blid, this);\n+                connection.start(blid, config.password);\n+\n+            } catch (IOException e) {\n+                error = e.toString();\n+            }\n+\n+            if (error != null) {\n+                logger.error(error);\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, error);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk4NTM0Ng=="}, "originalCommit": {"oid": "e9674556c16225cbbe635a06414cbf94eda1ea4c"}, "originalPosition": 306}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjIwOTExMQ==", "bodyText": "This is a redundant log message. The state change originated by updateStatus() is logged to events.log. Including the status detail message.", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r512209111", "createdAt": "2020-10-26T19:18:40Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.handler;\n+\n+import static org.openhab.binding.irobot.IRobotBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Hashtable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.internal.MQTTProtocol;\n+import org.openhab.binding.irobot.internal.RawMQTT;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.binding.irobot.roomba.RoombaMqttBrokerConnection;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The {@link RoombaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author hkuhn42 - Initial contribution\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Rewrite for 900 series\n+ */\n+@NonNullByDefault\n+public class RoombaHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(RoombaHandler.class);\n+    private final ExecutorService singleThread = Executors.newSingleThreadExecutor();\n+    private static final int reconnectDelay = 5; // In seconds\n+    private @Nullable Future<?> reconnectReq;\n+    // Dummy RoombaConfiguration object in order to shut up Eclipse warnings\n+    // The real one is set in initialize()\n+    private RoombaConfiguration config = new RoombaConfiguration();\n+    private @Nullable String blid = null;\n+    private @Nullable RoombaMqttBrokerConnection connection;\n+    private Hashtable<String, State> lastState = new Hashtable<String, State>();\n+    private MQTTProtocol.@Nullable Schedule lastSchedule = null;\n+    private boolean auto_passes = true;\n+    private @Nullable Boolean two_passes = null;\n+    private boolean carpet_boost = true;\n+    private @Nullable Boolean vac_high = null;\n+    private boolean isPaused = false;\n+\n+    public RoombaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.trace(\"initialize()\");\n+        config = getConfigAs(RoombaConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+        connect();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.trace(\"dispose()\");\n+\n+        singleThread.execute(() -> {\n+            if (reconnectReq != null) {\n+                reconnectReq.cancel(false);\n+                reconnectReq = null;\n+            }\n+\n+            if (connection != null) {\n+                connection.stop();\n+                connection = null;\n+            }\n+        });\n+    }\n+\n+    // lastState.get() can return null if the key is not found according\n+    // to the documentation\n+    @SuppressWarnings(\"null\")\n+    private void handleRefresh(String ch) {\n+        State value = lastState.get(ch);\n+\n+        if (value != null) {\n+            updateState(ch, value);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String ch = channelUID.getId();\n+        if (command instanceof RefreshType) {\n+            handleRefresh(ch);\n+            return;\n+        }\n+\n+        if (ch.equals(CHANNEL_COMMAND)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+\n+                if (cmd.equals(CMD_CLEAN)) {\n+                    cmd = isPaused ? \"resume\" : \"start\";\n+                }\n+\n+                sendRequest(new MQTTProtocol.CommandRequest(cmd));\n+            }\n+        } else if (ch.startsWith(CHANNEL_SCHED_SWITCH_PREFIX)) {\n+            MQTTProtocol.Schedule schedule = lastSchedule;\n+\n+            // Schedule can only be updated in a bulk, so we have to store current\n+            // schedule and modify components.\n+            if (command instanceof OnOffType && schedule != null && schedule.cycle != null) {\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    if (ch.equals(CHANNEL_SCHED_SWITCH[i])) {\n+                        MQTTProtocol.Schedule newSchedule = new MQTTProtocol.Schedule(schedule.cycle);\n+\n+                        newSchedule.enableCycle(i, command.equals(OnOffType.ON));\n+                        sendSchedule(newSchedule);\n+                        break;\n+                    }\n+                }\n+            }\n+        } else if (ch.equals(CHANNEL_SCHEDULE)) {\n+            if (command instanceof DecimalType) {\n+                int bitmask = ((DecimalType) command).intValue();\n+                JsonArray cycle = new JsonArray();\n+\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    enableCycle(cycle, i, (bitmask & (1 << i)) != 0);\n+                }\n+\n+                sendSchedule(new MQTTProtocol.Schedule(bitmask));\n+            }\n+        } else if (ch.equals(CHANNEL_EDGE_CLEAN)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.OpenOnly(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_ALWAYS_FINISH)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.BinPause(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_POWER_BOOST)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+                sendDelta(new MQTTProtocol.PowerBoost(cmd.equals(BOOST_AUTO), cmd.equals(BOOST_PERFORMANCE)));\n+            }\n+        } else if (ch.equals(CHANNEL_CLEAN_PASSES)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+                sendDelta(new MQTTProtocol.CleanPasses(!cmd.equals(PASSES_AUTO), cmd.equals(PASSES_2)));\n+            }\n+        }\n+    }\n+\n+    private void enableCycle(JsonArray cycle, int i, boolean enable) {\n+        JsonPrimitive value = new JsonPrimitive(enable ? \"start\" : \"none\");\n+        cycle.set(i, value);\n+    }\n+\n+    private void sendSchedule(MQTTProtocol.Schedule schedule) {\n+        sendDelta(new MQTTProtocol.CleanSchedule(schedule));\n+    }\n+\n+    private void sendDelta(MQTTProtocol.StateValue state) {\n+        sendRequest(new MQTTProtocol.DeltaRequest(state));\n+    }\n+\n+    private void sendRequest(MQTTProtocol.Request request) {\n+        RoombaMqttBrokerConnection conn = connection;\n+\n+        if (conn != null) {\n+            String json = new Gson().toJson(request);\n+            logger.trace(\"Sending {}: {}\", request.getTopic(), json);\n+            conn.publish(request.getTopic(), json.getBytes());\n+        }\n+    }\n+\n+    private void connect() {\n+        // In order not to mess up our connection state we need to make sure\n+        // that any two calls are never running concurrently. We use\n+        // singleThreadExecutorService for this purpose\n+        singleThread.execute(() -> {\n+            String error = null;\n+\n+            logger.info(\"Connecting to {}\", config.ipaddress);\n+\n+            try {\n+                InetAddress host = InetAddress.getByName(config.ipaddress);\n+                String blid = this.blid;\n+\n+                if (blid == null) {\n+                    DatagramSocket identSocket = IdentProtocol.sendRequest(host);\n+                    DatagramPacket identPacket = IdentProtocol.receiveResponse(identSocket);\n+                    IdentProtocol.IdentData ident;\n+\n+                    identSocket.close();\n+\n+                    try {\n+                        ident = IdentProtocol.decodeResponse(identPacket);\n+                    } catch (JsonParseException e) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Malformed IDENT response\");\n+                        return;\n+                    }\n+\n+                    if (ident.ver < IdentData.MIN_SUPPORTED_VERSION) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                \"Unsupported version \" + ident.ver);\n+                        return;\n+                    }\n+\n+                    if (!ident.product.equals(IdentData.PRODUCT_ROOMBA)) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                \"Not a Roomba: \" + ident.product);\n+                        return;\n+                    }\n+\n+                    blid = ident.blid;\n+                    this.blid = blid;\n+                }\n+\n+                logger.debug(\"BLID is: {}\", blid);\n+\n+                if (!config.havePassword()) {\n+                    RawMQTT mqtt;\n+\n+                    try {\n+                        mqtt = new RawMQTT(host, 8883);\n+                    } catch (KeyManagementException | NoSuchAlgorithmException e1) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e1.toString());\n+                        return; // This is internal system error, no retry\n+                    }\n+\n+                    mqtt.requestPassword();\n+                    RawMQTT.Packet response = mqtt.readPacket();\n+                    mqtt.close();\n+\n+                    if (response != null && response.isValidPasswdPacket()) {\n+                        RawMQTT.PasswdPacket passwdPacket = new RawMQTT.PasswdPacket(response);\n+\n+                        config.password = passwdPacket.getPassword();\n+                        if (config.havePassword()) {\n+                            Configuration configuration = editConfiguration();\n+\n+                            configuration.put(RoombaConfiguration.FIELD_PASSWORD, config.password);\n+                            updateConfiguration(configuration);\n+                        }\n+                    }\n+                }\n+\n+                if (!config.havePassword()) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING,\n+                            \"Authentication on the robot is required\");\n+                    scheduleReconnect();\n+                    return;\n+                }\n+\n+                logger.debug(\"Password is: {}\", config.password);\n+\n+                // BLID is used as both client ID and username. The name of BLID also came from Roomba980-python\n+                connection = new RoombaMqttBrokerConnection(config.ipaddress, blid, this);\n+                connection.start(blid, config.password);\n+\n+            } catch (IOException e) {\n+                error = e.toString();\n+            }\n+\n+            if (error != null) {\n+                logger.error(error);\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, error);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk4NTM0Ng=="}, "originalCommit": {"oid": "e9674556c16225cbbe635a06414cbf94eda1ea4c"}, "originalPosition": 306}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjkyNjI0Mw==", "bodyText": "Ok, removed, have fun.\nBy the way, what level do they use? I don't know because i never see them. At least on developer's console. But i muted a lot of stuff that deemed unrelated to me.", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r512926243", "createdAt": "2020-10-27T18:18:20Z", "author": {"login": "Sonic-Amiga"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.handler;\n+\n+import static org.openhab.binding.irobot.IRobotBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Hashtable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.internal.MQTTProtocol;\n+import org.openhab.binding.irobot.internal.RawMQTT;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.binding.irobot.roomba.RoombaMqttBrokerConnection;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The {@link RoombaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author hkuhn42 - Initial contribution\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Rewrite for 900 series\n+ */\n+@NonNullByDefault\n+public class RoombaHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(RoombaHandler.class);\n+    private final ExecutorService singleThread = Executors.newSingleThreadExecutor();\n+    private static final int reconnectDelay = 5; // In seconds\n+    private @Nullable Future<?> reconnectReq;\n+    // Dummy RoombaConfiguration object in order to shut up Eclipse warnings\n+    // The real one is set in initialize()\n+    private RoombaConfiguration config = new RoombaConfiguration();\n+    private @Nullable String blid = null;\n+    private @Nullable RoombaMqttBrokerConnection connection;\n+    private Hashtable<String, State> lastState = new Hashtable<String, State>();\n+    private MQTTProtocol.@Nullable Schedule lastSchedule = null;\n+    private boolean auto_passes = true;\n+    private @Nullable Boolean two_passes = null;\n+    private boolean carpet_boost = true;\n+    private @Nullable Boolean vac_high = null;\n+    private boolean isPaused = false;\n+\n+    public RoombaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.trace(\"initialize()\");\n+        config = getConfigAs(RoombaConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+        connect();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.trace(\"dispose()\");\n+\n+        singleThread.execute(() -> {\n+            if (reconnectReq != null) {\n+                reconnectReq.cancel(false);\n+                reconnectReq = null;\n+            }\n+\n+            if (connection != null) {\n+                connection.stop();\n+                connection = null;\n+            }\n+        });\n+    }\n+\n+    // lastState.get() can return null if the key is not found according\n+    // to the documentation\n+    @SuppressWarnings(\"null\")\n+    private void handleRefresh(String ch) {\n+        State value = lastState.get(ch);\n+\n+        if (value != null) {\n+            updateState(ch, value);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String ch = channelUID.getId();\n+        if (command instanceof RefreshType) {\n+            handleRefresh(ch);\n+            return;\n+        }\n+\n+        if (ch.equals(CHANNEL_COMMAND)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+\n+                if (cmd.equals(CMD_CLEAN)) {\n+                    cmd = isPaused ? \"resume\" : \"start\";\n+                }\n+\n+                sendRequest(new MQTTProtocol.CommandRequest(cmd));\n+            }\n+        } else if (ch.startsWith(CHANNEL_SCHED_SWITCH_PREFIX)) {\n+            MQTTProtocol.Schedule schedule = lastSchedule;\n+\n+            // Schedule can only be updated in a bulk, so we have to store current\n+            // schedule and modify components.\n+            if (command instanceof OnOffType && schedule != null && schedule.cycle != null) {\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    if (ch.equals(CHANNEL_SCHED_SWITCH[i])) {\n+                        MQTTProtocol.Schedule newSchedule = new MQTTProtocol.Schedule(schedule.cycle);\n+\n+                        newSchedule.enableCycle(i, command.equals(OnOffType.ON));\n+                        sendSchedule(newSchedule);\n+                        break;\n+                    }\n+                }\n+            }\n+        } else if (ch.equals(CHANNEL_SCHEDULE)) {\n+            if (command instanceof DecimalType) {\n+                int bitmask = ((DecimalType) command).intValue();\n+                JsonArray cycle = new JsonArray();\n+\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    enableCycle(cycle, i, (bitmask & (1 << i)) != 0);\n+                }\n+\n+                sendSchedule(new MQTTProtocol.Schedule(bitmask));\n+            }\n+        } else if (ch.equals(CHANNEL_EDGE_CLEAN)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.OpenOnly(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_ALWAYS_FINISH)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.BinPause(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_POWER_BOOST)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+                sendDelta(new MQTTProtocol.PowerBoost(cmd.equals(BOOST_AUTO), cmd.equals(BOOST_PERFORMANCE)));\n+            }\n+        } else if (ch.equals(CHANNEL_CLEAN_PASSES)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+                sendDelta(new MQTTProtocol.CleanPasses(!cmd.equals(PASSES_AUTO), cmd.equals(PASSES_2)));\n+            }\n+        }\n+    }\n+\n+    private void enableCycle(JsonArray cycle, int i, boolean enable) {\n+        JsonPrimitive value = new JsonPrimitive(enable ? \"start\" : \"none\");\n+        cycle.set(i, value);\n+    }\n+\n+    private void sendSchedule(MQTTProtocol.Schedule schedule) {\n+        sendDelta(new MQTTProtocol.CleanSchedule(schedule));\n+    }\n+\n+    private void sendDelta(MQTTProtocol.StateValue state) {\n+        sendRequest(new MQTTProtocol.DeltaRequest(state));\n+    }\n+\n+    private void sendRequest(MQTTProtocol.Request request) {\n+        RoombaMqttBrokerConnection conn = connection;\n+\n+        if (conn != null) {\n+            String json = new Gson().toJson(request);\n+            logger.trace(\"Sending {}: {}\", request.getTopic(), json);\n+            conn.publish(request.getTopic(), json.getBytes());\n+        }\n+    }\n+\n+    private void connect() {\n+        // In order not to mess up our connection state we need to make sure\n+        // that any two calls are never running concurrently. We use\n+        // singleThreadExecutorService for this purpose\n+        singleThread.execute(() -> {\n+            String error = null;\n+\n+            logger.info(\"Connecting to {}\", config.ipaddress);\n+\n+            try {\n+                InetAddress host = InetAddress.getByName(config.ipaddress);\n+                String blid = this.blid;\n+\n+                if (blid == null) {\n+                    DatagramSocket identSocket = IdentProtocol.sendRequest(host);\n+                    DatagramPacket identPacket = IdentProtocol.receiveResponse(identSocket);\n+                    IdentProtocol.IdentData ident;\n+\n+                    identSocket.close();\n+\n+                    try {\n+                        ident = IdentProtocol.decodeResponse(identPacket);\n+                    } catch (JsonParseException e) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Malformed IDENT response\");\n+                        return;\n+                    }\n+\n+                    if (ident.ver < IdentData.MIN_SUPPORTED_VERSION) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                \"Unsupported version \" + ident.ver);\n+                        return;\n+                    }\n+\n+                    if (!ident.product.equals(IdentData.PRODUCT_ROOMBA)) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                \"Not a Roomba: \" + ident.product);\n+                        return;\n+                    }\n+\n+                    blid = ident.blid;\n+                    this.blid = blid;\n+                }\n+\n+                logger.debug(\"BLID is: {}\", blid);\n+\n+                if (!config.havePassword()) {\n+                    RawMQTT mqtt;\n+\n+                    try {\n+                        mqtt = new RawMQTT(host, 8883);\n+                    } catch (KeyManagementException | NoSuchAlgorithmException e1) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e1.toString());\n+                        return; // This is internal system error, no retry\n+                    }\n+\n+                    mqtt.requestPassword();\n+                    RawMQTT.Packet response = mqtt.readPacket();\n+                    mqtt.close();\n+\n+                    if (response != null && response.isValidPasswdPacket()) {\n+                        RawMQTT.PasswdPacket passwdPacket = new RawMQTT.PasswdPacket(response);\n+\n+                        config.password = passwdPacket.getPassword();\n+                        if (config.havePassword()) {\n+                            Configuration configuration = editConfiguration();\n+\n+                            configuration.put(RoombaConfiguration.FIELD_PASSWORD, config.password);\n+                            updateConfiguration(configuration);\n+                        }\n+                    }\n+                }\n+\n+                if (!config.havePassword()) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING,\n+                            \"Authentication on the robot is required\");\n+                    scheduleReconnect();\n+                    return;\n+                }\n+\n+                logger.debug(\"Password is: {}\", config.password);\n+\n+                // BLID is used as both client ID and username. The name of BLID also came from Roomba980-python\n+                connection = new RoombaMqttBrokerConnection(config.ipaddress, blid, this);\n+                connection.start(blid, config.password);\n+\n+            } catch (IOException e) {\n+                error = e.toString();\n+            }\n+\n+            if (error != null) {\n+                logger.error(error);\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, error);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk4NTM0Ng=="}, "originalCommit": {"oid": "e9674556c16225cbbe635a06414cbf94eda1ea4c"}, "originalPosition": 306}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTYxMjkwNw==", "bodyText": "Adding <logger name=\"smarthome.event.ThingStatusInfoChangedEvent\" level=\"INFO\" /> to logback.xml should make these visible.", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r515612907", "createdAt": "2020-11-01T11:59:01Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.handler;\n+\n+import static org.openhab.binding.irobot.IRobotBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Hashtable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.internal.MQTTProtocol;\n+import org.openhab.binding.irobot.internal.RawMQTT;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.binding.irobot.roomba.RoombaMqttBrokerConnection;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The {@link RoombaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author hkuhn42 - Initial contribution\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Rewrite for 900 series\n+ */\n+@NonNullByDefault\n+public class RoombaHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(RoombaHandler.class);\n+    private final ExecutorService singleThread = Executors.newSingleThreadExecutor();\n+    private static final int reconnectDelay = 5; // In seconds\n+    private @Nullable Future<?> reconnectReq;\n+    // Dummy RoombaConfiguration object in order to shut up Eclipse warnings\n+    // The real one is set in initialize()\n+    private RoombaConfiguration config = new RoombaConfiguration();\n+    private @Nullable String blid = null;\n+    private @Nullable RoombaMqttBrokerConnection connection;\n+    private Hashtable<String, State> lastState = new Hashtable<String, State>();\n+    private MQTTProtocol.@Nullable Schedule lastSchedule = null;\n+    private boolean auto_passes = true;\n+    private @Nullable Boolean two_passes = null;\n+    private boolean carpet_boost = true;\n+    private @Nullable Boolean vac_high = null;\n+    private boolean isPaused = false;\n+\n+    public RoombaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.trace(\"initialize()\");\n+        config = getConfigAs(RoombaConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+        connect();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.trace(\"dispose()\");\n+\n+        singleThread.execute(() -> {\n+            if (reconnectReq != null) {\n+                reconnectReq.cancel(false);\n+                reconnectReq = null;\n+            }\n+\n+            if (connection != null) {\n+                connection.stop();\n+                connection = null;\n+            }\n+        });\n+    }\n+\n+    // lastState.get() can return null if the key is not found according\n+    // to the documentation\n+    @SuppressWarnings(\"null\")\n+    private void handleRefresh(String ch) {\n+        State value = lastState.get(ch);\n+\n+        if (value != null) {\n+            updateState(ch, value);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String ch = channelUID.getId();\n+        if (command instanceof RefreshType) {\n+            handleRefresh(ch);\n+            return;\n+        }\n+\n+        if (ch.equals(CHANNEL_COMMAND)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+\n+                if (cmd.equals(CMD_CLEAN)) {\n+                    cmd = isPaused ? \"resume\" : \"start\";\n+                }\n+\n+                sendRequest(new MQTTProtocol.CommandRequest(cmd));\n+            }\n+        } else if (ch.startsWith(CHANNEL_SCHED_SWITCH_PREFIX)) {\n+            MQTTProtocol.Schedule schedule = lastSchedule;\n+\n+            // Schedule can only be updated in a bulk, so we have to store current\n+            // schedule and modify components.\n+            if (command instanceof OnOffType && schedule != null && schedule.cycle != null) {\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    if (ch.equals(CHANNEL_SCHED_SWITCH[i])) {\n+                        MQTTProtocol.Schedule newSchedule = new MQTTProtocol.Schedule(schedule.cycle);\n+\n+                        newSchedule.enableCycle(i, command.equals(OnOffType.ON));\n+                        sendSchedule(newSchedule);\n+                        break;\n+                    }\n+                }\n+            }\n+        } else if (ch.equals(CHANNEL_SCHEDULE)) {\n+            if (command instanceof DecimalType) {\n+                int bitmask = ((DecimalType) command).intValue();\n+                JsonArray cycle = new JsonArray();\n+\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    enableCycle(cycle, i, (bitmask & (1 << i)) != 0);\n+                }\n+\n+                sendSchedule(new MQTTProtocol.Schedule(bitmask));\n+            }\n+        } else if (ch.equals(CHANNEL_EDGE_CLEAN)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.OpenOnly(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_ALWAYS_FINISH)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.BinPause(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_POWER_BOOST)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+                sendDelta(new MQTTProtocol.PowerBoost(cmd.equals(BOOST_AUTO), cmd.equals(BOOST_PERFORMANCE)));\n+            }\n+        } else if (ch.equals(CHANNEL_CLEAN_PASSES)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+                sendDelta(new MQTTProtocol.CleanPasses(!cmd.equals(PASSES_AUTO), cmd.equals(PASSES_2)));\n+            }\n+        }\n+    }\n+\n+    private void enableCycle(JsonArray cycle, int i, boolean enable) {\n+        JsonPrimitive value = new JsonPrimitive(enable ? \"start\" : \"none\");\n+        cycle.set(i, value);\n+    }\n+\n+    private void sendSchedule(MQTTProtocol.Schedule schedule) {\n+        sendDelta(new MQTTProtocol.CleanSchedule(schedule));\n+    }\n+\n+    private void sendDelta(MQTTProtocol.StateValue state) {\n+        sendRequest(new MQTTProtocol.DeltaRequest(state));\n+    }\n+\n+    private void sendRequest(MQTTProtocol.Request request) {\n+        RoombaMqttBrokerConnection conn = connection;\n+\n+        if (conn != null) {\n+            String json = new Gson().toJson(request);\n+            logger.trace(\"Sending {}: {}\", request.getTopic(), json);\n+            conn.publish(request.getTopic(), json.getBytes());\n+        }\n+    }\n+\n+    private void connect() {\n+        // In order not to mess up our connection state we need to make sure\n+        // that any two calls are never running concurrently. We use\n+        // singleThreadExecutorService for this purpose\n+        singleThread.execute(() -> {\n+            String error = null;\n+\n+            logger.info(\"Connecting to {}\", config.ipaddress);\n+\n+            try {\n+                InetAddress host = InetAddress.getByName(config.ipaddress);\n+                String blid = this.blid;\n+\n+                if (blid == null) {\n+                    DatagramSocket identSocket = IdentProtocol.sendRequest(host);\n+                    DatagramPacket identPacket = IdentProtocol.receiveResponse(identSocket);\n+                    IdentProtocol.IdentData ident;\n+\n+                    identSocket.close();\n+\n+                    try {\n+                        ident = IdentProtocol.decodeResponse(identPacket);\n+                    } catch (JsonParseException e) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Malformed IDENT response\");\n+                        return;\n+                    }\n+\n+                    if (ident.ver < IdentData.MIN_SUPPORTED_VERSION) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                \"Unsupported version \" + ident.ver);\n+                        return;\n+                    }\n+\n+                    if (!ident.product.equals(IdentData.PRODUCT_ROOMBA)) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                \"Not a Roomba: \" + ident.product);\n+                        return;\n+                    }\n+\n+                    blid = ident.blid;\n+                    this.blid = blid;\n+                }\n+\n+                logger.debug(\"BLID is: {}\", blid);\n+\n+                if (!config.havePassword()) {\n+                    RawMQTT mqtt;\n+\n+                    try {\n+                        mqtt = new RawMQTT(host, 8883);\n+                    } catch (KeyManagementException | NoSuchAlgorithmException e1) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e1.toString());\n+                        return; // This is internal system error, no retry\n+                    }\n+\n+                    mqtt.requestPassword();\n+                    RawMQTT.Packet response = mqtt.readPacket();\n+                    mqtt.close();\n+\n+                    if (response != null && response.isValidPasswdPacket()) {\n+                        RawMQTT.PasswdPacket passwdPacket = new RawMQTT.PasswdPacket(response);\n+\n+                        config.password = passwdPacket.getPassword();\n+                        if (config.havePassword()) {\n+                            Configuration configuration = editConfiguration();\n+\n+                            configuration.put(RoombaConfiguration.FIELD_PASSWORD, config.password);\n+                            updateConfiguration(configuration);\n+                        }\n+                    }\n+                }\n+\n+                if (!config.havePassword()) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING,\n+                            \"Authentication on the robot is required\");\n+                    scheduleReconnect();\n+                    return;\n+                }\n+\n+                logger.debug(\"Password is: {}\", config.password);\n+\n+                // BLID is used as both client ID and username. The name of BLID also came from Roomba980-python\n+                connection = new RoombaMqttBrokerConnection(config.ipaddress, blid, this);\n+                connection.start(blid, config.password);\n+\n+            } catch (IOException e) {\n+                error = e.toString();\n+            }\n+\n+            if (error != null) {\n+                logger.error(error);\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, error);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk4NTM0Ng=="}, "originalCommit": {"oid": "e9674556c16225cbbe635a06414cbf94eda1ea4c"}, "originalPosition": 306}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMDk2ODM0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNjowMjo0OFrOHnUJiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNjowMjo0OFrOHnUJiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk4NjYzMw==", "bodyText": "Syntactical sugar.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    reconnectReq = scheduler.schedule(() -> {\n          \n          \n            \n                        connect();\n          \n          \n            \n                    }, reconnectDelay, TimeUnit.SECONDS);\n          \n          \n            \n                    reconnectReq = scheduler.schedule(this::connect, reconnectDelay, TimeUnit.SECONDS);", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r510986633", "createdAt": "2020-10-23T16:02:48Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.handler;\n+\n+import static org.openhab.binding.irobot.IRobotBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Hashtable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.internal.MQTTProtocol;\n+import org.openhab.binding.irobot.internal.RawMQTT;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.binding.irobot.roomba.RoombaMqttBrokerConnection;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The {@link RoombaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author hkuhn42 - Initial contribution\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Rewrite for 900 series\n+ */\n+@NonNullByDefault\n+public class RoombaHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(RoombaHandler.class);\n+    private final ExecutorService singleThread = Executors.newSingleThreadExecutor();\n+    private static final int reconnectDelay = 5; // In seconds\n+    private @Nullable Future<?> reconnectReq;\n+    // Dummy RoombaConfiguration object in order to shut up Eclipse warnings\n+    // The real one is set in initialize()\n+    private RoombaConfiguration config = new RoombaConfiguration();\n+    private @Nullable String blid = null;\n+    private @Nullable RoombaMqttBrokerConnection connection;\n+    private Hashtable<String, State> lastState = new Hashtable<String, State>();\n+    private MQTTProtocol.@Nullable Schedule lastSchedule = null;\n+    private boolean auto_passes = true;\n+    private @Nullable Boolean two_passes = null;\n+    private boolean carpet_boost = true;\n+    private @Nullable Boolean vac_high = null;\n+    private boolean isPaused = false;\n+\n+    public RoombaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.trace(\"initialize()\");\n+        config = getConfigAs(RoombaConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+        connect();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.trace(\"dispose()\");\n+\n+        singleThread.execute(() -> {\n+            if (reconnectReq != null) {\n+                reconnectReq.cancel(false);\n+                reconnectReq = null;\n+            }\n+\n+            if (connection != null) {\n+                connection.stop();\n+                connection = null;\n+            }\n+        });\n+    }\n+\n+    // lastState.get() can return null if the key is not found according\n+    // to the documentation\n+    @SuppressWarnings(\"null\")\n+    private void handleRefresh(String ch) {\n+        State value = lastState.get(ch);\n+\n+        if (value != null) {\n+            updateState(ch, value);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String ch = channelUID.getId();\n+        if (command instanceof RefreshType) {\n+            handleRefresh(ch);\n+            return;\n+        }\n+\n+        if (ch.equals(CHANNEL_COMMAND)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+\n+                if (cmd.equals(CMD_CLEAN)) {\n+                    cmd = isPaused ? \"resume\" : \"start\";\n+                }\n+\n+                sendRequest(new MQTTProtocol.CommandRequest(cmd));\n+            }\n+        } else if (ch.startsWith(CHANNEL_SCHED_SWITCH_PREFIX)) {\n+            MQTTProtocol.Schedule schedule = lastSchedule;\n+\n+            // Schedule can only be updated in a bulk, so we have to store current\n+            // schedule and modify components.\n+            if (command instanceof OnOffType && schedule != null && schedule.cycle != null) {\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    if (ch.equals(CHANNEL_SCHED_SWITCH[i])) {\n+                        MQTTProtocol.Schedule newSchedule = new MQTTProtocol.Schedule(schedule.cycle);\n+\n+                        newSchedule.enableCycle(i, command.equals(OnOffType.ON));\n+                        sendSchedule(newSchedule);\n+                        break;\n+                    }\n+                }\n+            }\n+        } else if (ch.equals(CHANNEL_SCHEDULE)) {\n+            if (command instanceof DecimalType) {\n+                int bitmask = ((DecimalType) command).intValue();\n+                JsonArray cycle = new JsonArray();\n+\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    enableCycle(cycle, i, (bitmask & (1 << i)) != 0);\n+                }\n+\n+                sendSchedule(new MQTTProtocol.Schedule(bitmask));\n+            }\n+        } else if (ch.equals(CHANNEL_EDGE_CLEAN)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.OpenOnly(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_ALWAYS_FINISH)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.BinPause(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_POWER_BOOST)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+                sendDelta(new MQTTProtocol.PowerBoost(cmd.equals(BOOST_AUTO), cmd.equals(BOOST_PERFORMANCE)));\n+            }\n+        } else if (ch.equals(CHANNEL_CLEAN_PASSES)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+                sendDelta(new MQTTProtocol.CleanPasses(!cmd.equals(PASSES_AUTO), cmd.equals(PASSES_2)));\n+            }\n+        }\n+    }\n+\n+    private void enableCycle(JsonArray cycle, int i, boolean enable) {\n+        JsonPrimitive value = new JsonPrimitive(enable ? \"start\" : \"none\");\n+        cycle.set(i, value);\n+    }\n+\n+    private void sendSchedule(MQTTProtocol.Schedule schedule) {\n+        sendDelta(new MQTTProtocol.CleanSchedule(schedule));\n+    }\n+\n+    private void sendDelta(MQTTProtocol.StateValue state) {\n+        sendRequest(new MQTTProtocol.DeltaRequest(state));\n+    }\n+\n+    private void sendRequest(MQTTProtocol.Request request) {\n+        RoombaMqttBrokerConnection conn = connection;\n+\n+        if (conn != null) {\n+            String json = new Gson().toJson(request);\n+            logger.trace(\"Sending {}: {}\", request.getTopic(), json);\n+            conn.publish(request.getTopic(), json.getBytes());\n+        }\n+    }\n+\n+    private void connect() {\n+        // In order not to mess up our connection state we need to make sure\n+        // that any two calls are never running concurrently. We use\n+        // singleThreadExecutorService for this purpose\n+        singleThread.execute(() -> {\n+            String error = null;\n+\n+            logger.info(\"Connecting to {}\", config.ipaddress);\n+\n+            try {\n+                InetAddress host = InetAddress.getByName(config.ipaddress);\n+                String blid = this.blid;\n+\n+                if (blid == null) {\n+                    DatagramSocket identSocket = IdentProtocol.sendRequest(host);\n+                    DatagramPacket identPacket = IdentProtocol.receiveResponse(identSocket);\n+                    IdentProtocol.IdentData ident;\n+\n+                    identSocket.close();\n+\n+                    try {\n+                        ident = IdentProtocol.decodeResponse(identPacket);\n+                    } catch (JsonParseException e) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Malformed IDENT response\");\n+                        return;\n+                    }\n+\n+                    if (ident.ver < IdentData.MIN_SUPPORTED_VERSION) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                \"Unsupported version \" + ident.ver);\n+                        return;\n+                    }\n+\n+                    if (!ident.product.equals(IdentData.PRODUCT_ROOMBA)) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                \"Not a Roomba: \" + ident.product);\n+                        return;\n+                    }\n+\n+                    blid = ident.blid;\n+                    this.blid = blid;\n+                }\n+\n+                logger.debug(\"BLID is: {}\", blid);\n+\n+                if (!config.havePassword()) {\n+                    RawMQTT mqtt;\n+\n+                    try {\n+                        mqtt = new RawMQTT(host, 8883);\n+                    } catch (KeyManagementException | NoSuchAlgorithmException e1) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e1.toString());\n+                        return; // This is internal system error, no retry\n+                    }\n+\n+                    mqtt.requestPassword();\n+                    RawMQTT.Packet response = mqtt.readPacket();\n+                    mqtt.close();\n+\n+                    if (response != null && response.isValidPasswdPacket()) {\n+                        RawMQTT.PasswdPacket passwdPacket = new RawMQTT.PasswdPacket(response);\n+\n+                        config.password = passwdPacket.getPassword();\n+                        if (config.havePassword()) {\n+                            Configuration configuration = editConfiguration();\n+\n+                            configuration.put(RoombaConfiguration.FIELD_PASSWORD, config.password);\n+                            updateConfiguration(configuration);\n+                        }\n+                    }\n+                }\n+\n+                if (!config.havePassword()) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING,\n+                            \"Authentication on the robot is required\");\n+                    scheduleReconnect();\n+                    return;\n+                }\n+\n+                logger.debug(\"Password is: {}\", config.password);\n+\n+                // BLID is used as both client ID and username. The name of BLID also came from Roomba980-python\n+                connection = new RoombaMqttBrokerConnection(config.ipaddress, blid, this);\n+                connection.start(blid, config.password);\n+\n+            } catch (IOException e) {\n+                error = e.toString();\n+            }\n+\n+            if (error != null) {\n+                logger.error(error);\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, error);\n+                scheduleReconnect();\n+            }\n+        });\n+    }\n+\n+    private void scheduleReconnect() {\n+        reconnectReq = scheduler.schedule(() -> {\n+            connect();\n+        }, reconnectDelay, TimeUnit.SECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9674556c16225cbbe635a06414cbf94eda1ea4c"}, "originalPosition": 315}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMDk3MDA0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNjowMzoxNlrOHnUKjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNjowMzoxNlrOHnUKjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk4Njg5Mg==", "bodyText": "See above. Logging to error.", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r510986892", "createdAt": "2020-10-23T16:03:16Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.handler;\n+\n+import static org.openhab.binding.irobot.IRobotBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Hashtable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.internal.MQTTProtocol;\n+import org.openhab.binding.irobot.internal.RawMQTT;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.binding.irobot.roomba.RoombaMqttBrokerConnection;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The {@link RoombaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author hkuhn42 - Initial contribution\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Rewrite for 900 series\n+ */\n+@NonNullByDefault\n+public class RoombaHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(RoombaHandler.class);\n+    private final ExecutorService singleThread = Executors.newSingleThreadExecutor();\n+    private static final int reconnectDelay = 5; // In seconds\n+    private @Nullable Future<?> reconnectReq;\n+    // Dummy RoombaConfiguration object in order to shut up Eclipse warnings\n+    // The real one is set in initialize()\n+    private RoombaConfiguration config = new RoombaConfiguration();\n+    private @Nullable String blid = null;\n+    private @Nullable RoombaMqttBrokerConnection connection;\n+    private Hashtable<String, State> lastState = new Hashtable<String, State>();\n+    private MQTTProtocol.@Nullable Schedule lastSchedule = null;\n+    private boolean auto_passes = true;\n+    private @Nullable Boolean two_passes = null;\n+    private boolean carpet_boost = true;\n+    private @Nullable Boolean vac_high = null;\n+    private boolean isPaused = false;\n+\n+    public RoombaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.trace(\"initialize()\");\n+        config = getConfigAs(RoombaConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+        connect();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.trace(\"dispose()\");\n+\n+        singleThread.execute(() -> {\n+            if (reconnectReq != null) {\n+                reconnectReq.cancel(false);\n+                reconnectReq = null;\n+            }\n+\n+            if (connection != null) {\n+                connection.stop();\n+                connection = null;\n+            }\n+        });\n+    }\n+\n+    // lastState.get() can return null if the key is not found according\n+    // to the documentation\n+    @SuppressWarnings(\"null\")\n+    private void handleRefresh(String ch) {\n+        State value = lastState.get(ch);\n+\n+        if (value != null) {\n+            updateState(ch, value);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String ch = channelUID.getId();\n+        if (command instanceof RefreshType) {\n+            handleRefresh(ch);\n+            return;\n+        }\n+\n+        if (ch.equals(CHANNEL_COMMAND)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+\n+                if (cmd.equals(CMD_CLEAN)) {\n+                    cmd = isPaused ? \"resume\" : \"start\";\n+                }\n+\n+                sendRequest(new MQTTProtocol.CommandRequest(cmd));\n+            }\n+        } else if (ch.startsWith(CHANNEL_SCHED_SWITCH_PREFIX)) {\n+            MQTTProtocol.Schedule schedule = lastSchedule;\n+\n+            // Schedule can only be updated in a bulk, so we have to store current\n+            // schedule and modify components.\n+            if (command instanceof OnOffType && schedule != null && schedule.cycle != null) {\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    if (ch.equals(CHANNEL_SCHED_SWITCH[i])) {\n+                        MQTTProtocol.Schedule newSchedule = new MQTTProtocol.Schedule(schedule.cycle);\n+\n+                        newSchedule.enableCycle(i, command.equals(OnOffType.ON));\n+                        sendSchedule(newSchedule);\n+                        break;\n+                    }\n+                }\n+            }\n+        } else if (ch.equals(CHANNEL_SCHEDULE)) {\n+            if (command instanceof DecimalType) {\n+                int bitmask = ((DecimalType) command).intValue();\n+                JsonArray cycle = new JsonArray();\n+\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    enableCycle(cycle, i, (bitmask & (1 << i)) != 0);\n+                }\n+\n+                sendSchedule(new MQTTProtocol.Schedule(bitmask));\n+            }\n+        } else if (ch.equals(CHANNEL_EDGE_CLEAN)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.OpenOnly(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_ALWAYS_FINISH)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.BinPause(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_POWER_BOOST)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+                sendDelta(new MQTTProtocol.PowerBoost(cmd.equals(BOOST_AUTO), cmd.equals(BOOST_PERFORMANCE)));\n+            }\n+        } else if (ch.equals(CHANNEL_CLEAN_PASSES)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+                sendDelta(new MQTTProtocol.CleanPasses(!cmd.equals(PASSES_AUTO), cmd.equals(PASSES_2)));\n+            }\n+        }\n+    }\n+\n+    private void enableCycle(JsonArray cycle, int i, boolean enable) {\n+        JsonPrimitive value = new JsonPrimitive(enable ? \"start\" : \"none\");\n+        cycle.set(i, value);\n+    }\n+\n+    private void sendSchedule(MQTTProtocol.Schedule schedule) {\n+        sendDelta(new MQTTProtocol.CleanSchedule(schedule));\n+    }\n+\n+    private void sendDelta(MQTTProtocol.StateValue state) {\n+        sendRequest(new MQTTProtocol.DeltaRequest(state));\n+    }\n+\n+    private void sendRequest(MQTTProtocol.Request request) {\n+        RoombaMqttBrokerConnection conn = connection;\n+\n+        if (conn != null) {\n+            String json = new Gson().toJson(request);\n+            logger.trace(\"Sending {}: {}\", request.getTopic(), json);\n+            conn.publish(request.getTopic(), json.getBytes());\n+        }\n+    }\n+\n+    private void connect() {\n+        // In order not to mess up our connection state we need to make sure\n+        // that any two calls are never running concurrently. We use\n+        // singleThreadExecutorService for this purpose\n+        singleThread.execute(() -> {\n+            String error = null;\n+\n+            logger.info(\"Connecting to {}\", config.ipaddress);\n+\n+            try {\n+                InetAddress host = InetAddress.getByName(config.ipaddress);\n+                String blid = this.blid;\n+\n+                if (blid == null) {\n+                    DatagramSocket identSocket = IdentProtocol.sendRequest(host);\n+                    DatagramPacket identPacket = IdentProtocol.receiveResponse(identSocket);\n+                    IdentProtocol.IdentData ident;\n+\n+                    identSocket.close();\n+\n+                    try {\n+                        ident = IdentProtocol.decodeResponse(identPacket);\n+                    } catch (JsonParseException e) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Malformed IDENT response\");\n+                        return;\n+                    }\n+\n+                    if (ident.ver < IdentData.MIN_SUPPORTED_VERSION) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                \"Unsupported version \" + ident.ver);\n+                        return;\n+                    }\n+\n+                    if (!ident.product.equals(IdentData.PRODUCT_ROOMBA)) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                \"Not a Roomba: \" + ident.product);\n+                        return;\n+                    }\n+\n+                    blid = ident.blid;\n+                    this.blid = blid;\n+                }\n+\n+                logger.debug(\"BLID is: {}\", blid);\n+\n+                if (!config.havePassword()) {\n+                    RawMQTT mqtt;\n+\n+                    try {\n+                        mqtt = new RawMQTT(host, 8883);\n+                    } catch (KeyManagementException | NoSuchAlgorithmException e1) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e1.toString());\n+                        return; // This is internal system error, no retry\n+                    }\n+\n+                    mqtt.requestPassword();\n+                    RawMQTT.Packet response = mqtt.readPacket();\n+                    mqtt.close();\n+\n+                    if (response != null && response.isValidPasswdPacket()) {\n+                        RawMQTT.PasswdPacket passwdPacket = new RawMQTT.PasswdPacket(response);\n+\n+                        config.password = passwdPacket.getPassword();\n+                        if (config.havePassword()) {\n+                            Configuration configuration = editConfiguration();\n+\n+                            configuration.put(RoombaConfiguration.FIELD_PASSWORD, config.password);\n+                            updateConfiguration(configuration);\n+                        }\n+                    }\n+                }\n+\n+                if (!config.havePassword()) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING,\n+                            \"Authentication on the robot is required\");\n+                    scheduleReconnect();\n+                    return;\n+                }\n+\n+                logger.debug(\"Password is: {}\", config.password);\n+\n+                // BLID is used as both client ID and username. The name of BLID also came from Roomba980-python\n+                connection = new RoombaMqttBrokerConnection(config.ipaddress, blid, this);\n+                connection.start(blid, config.password);\n+\n+            } catch (IOException e) {\n+                error = e.toString();\n+            }\n+\n+            if (error != null) {\n+                logger.error(error);\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, error);\n+                scheduleReconnect();\n+            }\n+        });\n+    }\n+\n+    private void scheduleReconnect() {\n+        reconnectReq = scheduler.schedule(() -> {\n+            connect();\n+        }, reconnectDelay, TimeUnit.SECONDS);\n+    }\n+\n+    public void onConnected() {\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    public void onDisconnected(Throwable error) {\n+        String message = error.getMessage();\n+\n+        logger.error(\"MQTT connection failed: {}\", message);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9674556c16225cbbe635a06414cbf94eda1ea4c"}, "originalPosition": 325}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMDk3NDM3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNjowNDozNVrOHnUNXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNjowNDozNVrOHnUNXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk4NzYxNA==", "bodyText": "This could be moved into the catch block.", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r510987614", "createdAt": "2020-10-23T16:04:35Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.handler;\n+\n+import static org.openhab.binding.irobot.IRobotBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Hashtable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.internal.MQTTProtocol;\n+import org.openhab.binding.irobot.internal.RawMQTT;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.binding.irobot.roomba.RoombaMqttBrokerConnection;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The {@link RoombaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author hkuhn42 - Initial contribution\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Rewrite for 900 series\n+ */\n+@NonNullByDefault\n+public class RoombaHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(RoombaHandler.class);\n+    private final ExecutorService singleThread = Executors.newSingleThreadExecutor();\n+    private static final int reconnectDelay = 5; // In seconds\n+    private @Nullable Future<?> reconnectReq;\n+    // Dummy RoombaConfiguration object in order to shut up Eclipse warnings\n+    // The real one is set in initialize()\n+    private RoombaConfiguration config = new RoombaConfiguration();\n+    private @Nullable String blid = null;\n+    private @Nullable RoombaMqttBrokerConnection connection;\n+    private Hashtable<String, State> lastState = new Hashtable<String, State>();\n+    private MQTTProtocol.@Nullable Schedule lastSchedule = null;\n+    private boolean auto_passes = true;\n+    private @Nullable Boolean two_passes = null;\n+    private boolean carpet_boost = true;\n+    private @Nullable Boolean vac_high = null;\n+    private boolean isPaused = false;\n+\n+    public RoombaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.trace(\"initialize()\");\n+        config = getConfigAs(RoombaConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+        connect();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.trace(\"dispose()\");\n+\n+        singleThread.execute(() -> {\n+            if (reconnectReq != null) {\n+                reconnectReq.cancel(false);\n+                reconnectReq = null;\n+            }\n+\n+            if (connection != null) {\n+                connection.stop();\n+                connection = null;\n+            }\n+        });\n+    }\n+\n+    // lastState.get() can return null if the key is not found according\n+    // to the documentation\n+    @SuppressWarnings(\"null\")\n+    private void handleRefresh(String ch) {\n+        State value = lastState.get(ch);\n+\n+        if (value != null) {\n+            updateState(ch, value);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String ch = channelUID.getId();\n+        if (command instanceof RefreshType) {\n+            handleRefresh(ch);\n+            return;\n+        }\n+\n+        if (ch.equals(CHANNEL_COMMAND)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+\n+                if (cmd.equals(CMD_CLEAN)) {\n+                    cmd = isPaused ? \"resume\" : \"start\";\n+                }\n+\n+                sendRequest(new MQTTProtocol.CommandRequest(cmd));\n+            }\n+        } else if (ch.startsWith(CHANNEL_SCHED_SWITCH_PREFIX)) {\n+            MQTTProtocol.Schedule schedule = lastSchedule;\n+\n+            // Schedule can only be updated in a bulk, so we have to store current\n+            // schedule and modify components.\n+            if (command instanceof OnOffType && schedule != null && schedule.cycle != null) {\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    if (ch.equals(CHANNEL_SCHED_SWITCH[i])) {\n+                        MQTTProtocol.Schedule newSchedule = new MQTTProtocol.Schedule(schedule.cycle);\n+\n+                        newSchedule.enableCycle(i, command.equals(OnOffType.ON));\n+                        sendSchedule(newSchedule);\n+                        break;\n+                    }\n+                }\n+            }\n+        } else if (ch.equals(CHANNEL_SCHEDULE)) {\n+            if (command instanceof DecimalType) {\n+                int bitmask = ((DecimalType) command).intValue();\n+                JsonArray cycle = new JsonArray();\n+\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    enableCycle(cycle, i, (bitmask & (1 << i)) != 0);\n+                }\n+\n+                sendSchedule(new MQTTProtocol.Schedule(bitmask));\n+            }\n+        } else if (ch.equals(CHANNEL_EDGE_CLEAN)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.OpenOnly(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_ALWAYS_FINISH)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.BinPause(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_POWER_BOOST)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+                sendDelta(new MQTTProtocol.PowerBoost(cmd.equals(BOOST_AUTO), cmd.equals(BOOST_PERFORMANCE)));\n+            }\n+        } else if (ch.equals(CHANNEL_CLEAN_PASSES)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+                sendDelta(new MQTTProtocol.CleanPasses(!cmd.equals(PASSES_AUTO), cmd.equals(PASSES_2)));\n+            }\n+        }\n+    }\n+\n+    private void enableCycle(JsonArray cycle, int i, boolean enable) {\n+        JsonPrimitive value = new JsonPrimitive(enable ? \"start\" : \"none\");\n+        cycle.set(i, value);\n+    }\n+\n+    private void sendSchedule(MQTTProtocol.Schedule schedule) {\n+        sendDelta(new MQTTProtocol.CleanSchedule(schedule));\n+    }\n+\n+    private void sendDelta(MQTTProtocol.StateValue state) {\n+        sendRequest(new MQTTProtocol.DeltaRequest(state));\n+    }\n+\n+    private void sendRequest(MQTTProtocol.Request request) {\n+        RoombaMqttBrokerConnection conn = connection;\n+\n+        if (conn != null) {\n+            String json = new Gson().toJson(request);\n+            logger.trace(\"Sending {}: {}\", request.getTopic(), json);\n+            conn.publish(request.getTopic(), json.getBytes());\n+        }\n+    }\n+\n+    private void connect() {\n+        // In order not to mess up our connection state we need to make sure\n+        // that any two calls are never running concurrently. We use\n+        // singleThreadExecutorService for this purpose\n+        singleThread.execute(() -> {\n+            String error = null;\n+\n+            logger.info(\"Connecting to {}\", config.ipaddress);\n+\n+            try {\n+                InetAddress host = InetAddress.getByName(config.ipaddress);\n+                String blid = this.blid;\n+\n+                if (blid == null) {\n+                    DatagramSocket identSocket = IdentProtocol.sendRequest(host);\n+                    DatagramPacket identPacket = IdentProtocol.receiveResponse(identSocket);\n+                    IdentProtocol.IdentData ident;\n+\n+                    identSocket.close();\n+\n+                    try {\n+                        ident = IdentProtocol.decodeResponse(identPacket);\n+                    } catch (JsonParseException e) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Malformed IDENT response\");\n+                        return;\n+                    }\n+\n+                    if (ident.ver < IdentData.MIN_SUPPORTED_VERSION) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                \"Unsupported version \" + ident.ver);\n+                        return;\n+                    }\n+\n+                    if (!ident.product.equals(IdentData.PRODUCT_ROOMBA)) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                \"Not a Roomba: \" + ident.product);\n+                        return;\n+                    }\n+\n+                    blid = ident.blid;\n+                    this.blid = blid;\n+                }\n+\n+                logger.debug(\"BLID is: {}\", blid);\n+\n+                if (!config.havePassword()) {\n+                    RawMQTT mqtt;\n+\n+                    try {\n+                        mqtt = new RawMQTT(host, 8883);\n+                    } catch (KeyManagementException | NoSuchAlgorithmException e1) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e1.toString());\n+                        return; // This is internal system error, no retry\n+                    }\n+\n+                    mqtt.requestPassword();\n+                    RawMQTT.Packet response = mqtt.readPacket();\n+                    mqtt.close();\n+\n+                    if (response != null && response.isValidPasswdPacket()) {\n+                        RawMQTT.PasswdPacket passwdPacket = new RawMQTT.PasswdPacket(response);\n+\n+                        config.password = passwdPacket.getPassword();\n+                        if (config.havePassword()) {\n+                            Configuration configuration = editConfiguration();\n+\n+                            configuration.put(RoombaConfiguration.FIELD_PASSWORD, config.password);\n+                            updateConfiguration(configuration);\n+                        }\n+                    }\n+                }\n+\n+                if (!config.havePassword()) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING,\n+                            \"Authentication on the robot is required\");\n+                    scheduleReconnect();\n+                    return;\n+                }\n+\n+                logger.debug(\"Password is: {}\", config.password);\n+\n+                // BLID is used as both client ID and username. The name of BLID also came from Roomba980-python\n+                connection = new RoombaMqttBrokerConnection(config.ipaddress, blid, this);\n+                connection.start(blid, config.password);\n+\n+            } catch (IOException e) {\n+                error = e.toString();\n+            }\n+\n+            if (error != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9674556c16225cbbe635a06414cbf94eda1ea4c"}, "originalPosition": 304}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMDk3NjU1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNjowNToxMVrOHnUOyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNjowNToxMVrOHnUOyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk4Nzk3OA==", "bodyText": "See above. Store Gson to member.", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r510987978", "createdAt": "2020-10-23T16:05:11Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.handler;\n+\n+import static org.openhab.binding.irobot.IRobotBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Hashtable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.internal.MQTTProtocol;\n+import org.openhab.binding.irobot.internal.RawMQTT;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.binding.irobot.roomba.RoombaMqttBrokerConnection;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The {@link RoombaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author hkuhn42 - Initial contribution\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Rewrite for 900 series\n+ */\n+@NonNullByDefault\n+public class RoombaHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(RoombaHandler.class);\n+    private final ExecutorService singleThread = Executors.newSingleThreadExecutor();\n+    private static final int reconnectDelay = 5; // In seconds\n+    private @Nullable Future<?> reconnectReq;\n+    // Dummy RoombaConfiguration object in order to shut up Eclipse warnings\n+    // The real one is set in initialize()\n+    private RoombaConfiguration config = new RoombaConfiguration();\n+    private @Nullable String blid = null;\n+    private @Nullable RoombaMqttBrokerConnection connection;\n+    private Hashtable<String, State> lastState = new Hashtable<String, State>();\n+    private MQTTProtocol.@Nullable Schedule lastSchedule = null;\n+    private boolean auto_passes = true;\n+    private @Nullable Boolean two_passes = null;\n+    private boolean carpet_boost = true;\n+    private @Nullable Boolean vac_high = null;\n+    private boolean isPaused = false;\n+\n+    public RoombaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.trace(\"initialize()\");\n+        config = getConfigAs(RoombaConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+        connect();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.trace(\"dispose()\");\n+\n+        singleThread.execute(() -> {\n+            if (reconnectReq != null) {\n+                reconnectReq.cancel(false);\n+                reconnectReq = null;\n+            }\n+\n+            if (connection != null) {\n+                connection.stop();\n+                connection = null;\n+            }\n+        });\n+    }\n+\n+    // lastState.get() can return null if the key is not found according\n+    // to the documentation\n+    @SuppressWarnings(\"null\")\n+    private void handleRefresh(String ch) {\n+        State value = lastState.get(ch);\n+\n+        if (value != null) {\n+            updateState(ch, value);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String ch = channelUID.getId();\n+        if (command instanceof RefreshType) {\n+            handleRefresh(ch);\n+            return;\n+        }\n+\n+        if (ch.equals(CHANNEL_COMMAND)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+\n+                if (cmd.equals(CMD_CLEAN)) {\n+                    cmd = isPaused ? \"resume\" : \"start\";\n+                }\n+\n+                sendRequest(new MQTTProtocol.CommandRequest(cmd));\n+            }\n+        } else if (ch.startsWith(CHANNEL_SCHED_SWITCH_PREFIX)) {\n+            MQTTProtocol.Schedule schedule = lastSchedule;\n+\n+            // Schedule can only be updated in a bulk, so we have to store current\n+            // schedule and modify components.\n+            if (command instanceof OnOffType && schedule != null && schedule.cycle != null) {\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    if (ch.equals(CHANNEL_SCHED_SWITCH[i])) {\n+                        MQTTProtocol.Schedule newSchedule = new MQTTProtocol.Schedule(schedule.cycle);\n+\n+                        newSchedule.enableCycle(i, command.equals(OnOffType.ON));\n+                        sendSchedule(newSchedule);\n+                        break;\n+                    }\n+                }\n+            }\n+        } else if (ch.equals(CHANNEL_SCHEDULE)) {\n+            if (command instanceof DecimalType) {\n+                int bitmask = ((DecimalType) command).intValue();\n+                JsonArray cycle = new JsonArray();\n+\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    enableCycle(cycle, i, (bitmask & (1 << i)) != 0);\n+                }\n+\n+                sendSchedule(new MQTTProtocol.Schedule(bitmask));\n+            }\n+        } else if (ch.equals(CHANNEL_EDGE_CLEAN)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.OpenOnly(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_ALWAYS_FINISH)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.BinPause(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_POWER_BOOST)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+                sendDelta(new MQTTProtocol.PowerBoost(cmd.equals(BOOST_AUTO), cmd.equals(BOOST_PERFORMANCE)));\n+            }\n+        } else if (ch.equals(CHANNEL_CLEAN_PASSES)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+                sendDelta(new MQTTProtocol.CleanPasses(!cmd.equals(PASSES_AUTO), cmd.equals(PASSES_2)));\n+            }\n+        }\n+    }\n+\n+    private void enableCycle(JsonArray cycle, int i, boolean enable) {\n+        JsonPrimitive value = new JsonPrimitive(enable ? \"start\" : \"none\");\n+        cycle.set(i, value);\n+    }\n+\n+    private void sendSchedule(MQTTProtocol.Schedule schedule) {\n+        sendDelta(new MQTTProtocol.CleanSchedule(schedule));\n+    }\n+\n+    private void sendDelta(MQTTProtocol.StateValue state) {\n+        sendRequest(new MQTTProtocol.DeltaRequest(state));\n+    }\n+\n+    private void sendRequest(MQTTProtocol.Request request) {\n+        RoombaMqttBrokerConnection conn = connection;\n+\n+        if (conn != null) {\n+            String json = new Gson().toJson(request);\n+            logger.trace(\"Sending {}: {}\", request.getTopic(), json);\n+            conn.publish(request.getTopic(), json.getBytes());\n+        }\n+    }\n+\n+    private void connect() {\n+        // In order not to mess up our connection state we need to make sure\n+        // that any two calls are never running concurrently. We use\n+        // singleThreadExecutorService for this purpose\n+        singleThread.execute(() -> {\n+            String error = null;\n+\n+            logger.info(\"Connecting to {}\", config.ipaddress);\n+\n+            try {\n+                InetAddress host = InetAddress.getByName(config.ipaddress);\n+                String blid = this.blid;\n+\n+                if (blid == null) {\n+                    DatagramSocket identSocket = IdentProtocol.sendRequest(host);\n+                    DatagramPacket identPacket = IdentProtocol.receiveResponse(identSocket);\n+                    IdentProtocol.IdentData ident;\n+\n+                    identSocket.close();\n+\n+                    try {\n+                        ident = IdentProtocol.decodeResponse(identPacket);\n+                    } catch (JsonParseException e) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Malformed IDENT response\");\n+                        return;\n+                    }\n+\n+                    if (ident.ver < IdentData.MIN_SUPPORTED_VERSION) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                \"Unsupported version \" + ident.ver);\n+                        return;\n+                    }\n+\n+                    if (!ident.product.equals(IdentData.PRODUCT_ROOMBA)) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                \"Not a Roomba: \" + ident.product);\n+                        return;\n+                    }\n+\n+                    blid = ident.blid;\n+                    this.blid = blid;\n+                }\n+\n+                logger.debug(\"BLID is: {}\", blid);\n+\n+                if (!config.havePassword()) {\n+                    RawMQTT mqtt;\n+\n+                    try {\n+                        mqtt = new RawMQTT(host, 8883);\n+                    } catch (KeyManagementException | NoSuchAlgorithmException e1) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e1.toString());\n+                        return; // This is internal system error, no retry\n+                    }\n+\n+                    mqtt.requestPassword();\n+                    RawMQTT.Packet response = mqtt.readPacket();\n+                    mqtt.close();\n+\n+                    if (response != null && response.isValidPasswdPacket()) {\n+                        RawMQTT.PasswdPacket passwdPacket = new RawMQTT.PasswdPacket(response);\n+\n+                        config.password = passwdPacket.getPassword();\n+                        if (config.havePassword()) {\n+                            Configuration configuration = editConfiguration();\n+\n+                            configuration.put(RoombaConfiguration.FIELD_PASSWORD, config.password);\n+                            updateConfiguration(configuration);\n+                        }\n+                    }\n+                }\n+\n+                if (!config.havePassword()) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING,\n+                            \"Authentication on the robot is required\");\n+                    scheduleReconnect();\n+                    return;\n+                }\n+\n+                logger.debug(\"Password is: {}\", config.password);\n+\n+                // BLID is used as both client ID and username. The name of BLID also came from Roomba980-python\n+                connection = new RoombaMqttBrokerConnection(config.ipaddress, blid, this);\n+                connection.start(blid, config.password);\n+\n+            } catch (IOException e) {\n+                error = e.toString();\n+            }\n+\n+            if (error != null) {\n+                logger.error(error);\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, error);\n+                scheduleReconnect();\n+            }\n+        });\n+    }\n+\n+    private void scheduleReconnect() {\n+        reconnectReq = scheduler.schedule(() -> {\n+            connect();\n+        }, reconnectDelay, TimeUnit.SECONDS);\n+    }\n+\n+    public void onConnected() {\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    public void onDisconnected(Throwable error) {\n+        String message = error.getMessage();\n+\n+        logger.error(\"MQTT connection failed: {}\", message);\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, message);\n+        scheduleReconnect();\n+    }\n+\n+    public void processMessage(String topic, byte[] payload) {\n+        String jsonStr = new String(payload);\n+        MQTTProtocol.StateMessage msg;\n+\n+        logger.trace(\"Got topic {} data {}\", topic, jsonStr);\n+\n+        try {\n+            // We are not consuming all the fields, so we have to create the reader explicitly\n+            // If we use fromJson(String) or fromJson(java.util.reader), it will throw\n+            // \"JSON not fully consumed\" exception, because not all the reader's content has been\n+            // used up. We want to avoid that also for compatibility reasons because newer iRobot\n+            // versions may add fields.\n+            JsonReader jsonReader = new JsonReader(new StringReader(jsonStr));\n+            msg = new Gson().fromJson(jsonReader, IdentData.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9674556c16225cbbe635a06414cbf94eda1ea4c"}, "originalPosition": 343}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMDk3ODczOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNjowNTo0MlrOHnUQEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNjowNTo0MlrOHnUQEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk4ODMwNA==", "bodyText": "See above logging to error.", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r510988304", "createdAt": "2020-10-23T16:05:42Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "diffHunk": "@@ -0,0 +1,520 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.handler;\n+\n+import static org.openhab.binding.irobot.IRobotBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Hashtable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.internal.MQTTProtocol;\n+import org.openhab.binding.irobot.internal.RawMQTT;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.binding.irobot.roomba.RoombaMqttBrokerConnection;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The {@link RoombaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author hkuhn42 - Initial contribution\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Rewrite for 900 series\n+ */\n+@NonNullByDefault\n+public class RoombaHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(RoombaHandler.class);\n+    private final ExecutorService singleThread = Executors.newSingleThreadExecutor();\n+    private static final int reconnectDelay = 5; // In seconds\n+    private @Nullable Future<?> reconnectReq;\n+    // Dummy RoombaConfiguration object in order to shut up Eclipse warnings\n+    // The real one is set in initialize()\n+    private RoombaConfiguration config = new RoombaConfiguration();\n+    private @Nullable String blid = null;\n+    private @Nullable RoombaMqttBrokerConnection connection;\n+    private Hashtable<String, State> lastState = new Hashtable<String, State>();\n+    private MQTTProtocol.@Nullable Schedule lastSchedule = null;\n+    private boolean auto_passes = true;\n+    private @Nullable Boolean two_passes = null;\n+    private boolean carpet_boost = true;\n+    private @Nullable Boolean vac_high = null;\n+    private boolean isPaused = false;\n+\n+    public RoombaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.trace(\"initialize()\");\n+        config = getConfigAs(RoombaConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+        connect();\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        logger.trace(\"dispose()\");\n+\n+        singleThread.execute(() -> {\n+            if (reconnectReq != null) {\n+                reconnectReq.cancel(false);\n+                reconnectReq = null;\n+            }\n+\n+            if (connection != null) {\n+                connection.stop();\n+                connection = null;\n+            }\n+        });\n+    }\n+\n+    // lastState.get() can return null if the key is not found according\n+    // to the documentation\n+    @SuppressWarnings(\"null\")\n+    private void handleRefresh(String ch) {\n+        State value = lastState.get(ch);\n+\n+        if (value != null) {\n+            updateState(ch, value);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String ch = channelUID.getId();\n+        if (command instanceof RefreshType) {\n+            handleRefresh(ch);\n+            return;\n+        }\n+\n+        if (ch.equals(CHANNEL_COMMAND)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+\n+                if (cmd.equals(CMD_CLEAN)) {\n+                    cmd = isPaused ? \"resume\" : \"start\";\n+                }\n+\n+                sendRequest(new MQTTProtocol.CommandRequest(cmd));\n+            }\n+        } else if (ch.startsWith(CHANNEL_SCHED_SWITCH_PREFIX)) {\n+            MQTTProtocol.Schedule schedule = lastSchedule;\n+\n+            // Schedule can only be updated in a bulk, so we have to store current\n+            // schedule and modify components.\n+            if (command instanceof OnOffType && schedule != null && schedule.cycle != null) {\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    if (ch.equals(CHANNEL_SCHED_SWITCH[i])) {\n+                        MQTTProtocol.Schedule newSchedule = new MQTTProtocol.Schedule(schedule.cycle);\n+\n+                        newSchedule.enableCycle(i, command.equals(OnOffType.ON));\n+                        sendSchedule(newSchedule);\n+                        break;\n+                    }\n+                }\n+            }\n+        } else if (ch.equals(CHANNEL_SCHEDULE)) {\n+            if (command instanceof DecimalType) {\n+                int bitmask = ((DecimalType) command).intValue();\n+                JsonArray cycle = new JsonArray();\n+\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    enableCycle(cycle, i, (bitmask & (1 << i)) != 0);\n+                }\n+\n+                sendSchedule(new MQTTProtocol.Schedule(bitmask));\n+            }\n+        } else if (ch.equals(CHANNEL_EDGE_CLEAN)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.OpenOnly(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_ALWAYS_FINISH)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.BinPause(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_POWER_BOOST)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+                sendDelta(new MQTTProtocol.PowerBoost(cmd.equals(BOOST_AUTO), cmd.equals(BOOST_PERFORMANCE)));\n+            }\n+        } else if (ch.equals(CHANNEL_CLEAN_PASSES)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+                sendDelta(new MQTTProtocol.CleanPasses(!cmd.equals(PASSES_AUTO), cmd.equals(PASSES_2)));\n+            }\n+        }\n+    }\n+\n+    private void enableCycle(JsonArray cycle, int i, boolean enable) {\n+        JsonPrimitive value = new JsonPrimitive(enable ? \"start\" : \"none\");\n+        cycle.set(i, value);\n+    }\n+\n+    private void sendSchedule(MQTTProtocol.Schedule schedule) {\n+        sendDelta(new MQTTProtocol.CleanSchedule(schedule));\n+    }\n+\n+    private void sendDelta(MQTTProtocol.StateValue state) {\n+        sendRequest(new MQTTProtocol.DeltaRequest(state));\n+    }\n+\n+    private void sendRequest(MQTTProtocol.Request request) {\n+        RoombaMqttBrokerConnection conn = connection;\n+\n+        if (conn != null) {\n+            String json = new Gson().toJson(request);\n+            logger.trace(\"Sending {}: {}\", request.getTopic(), json);\n+            conn.publish(request.getTopic(), json.getBytes());\n+        }\n+    }\n+\n+    private void connect() {\n+        // In order not to mess up our connection state we need to make sure\n+        // that any two calls are never running concurrently. We use\n+        // singleThreadExecutorService for this purpose\n+        singleThread.execute(() -> {\n+            String error = null;\n+\n+            logger.info(\"Connecting to {}\", config.ipaddress);\n+\n+            try {\n+                InetAddress host = InetAddress.getByName(config.ipaddress);\n+                String blid = this.blid;\n+\n+                if (blid == null) {\n+                    DatagramSocket identSocket = IdentProtocol.sendRequest(host);\n+                    DatagramPacket identPacket = IdentProtocol.receiveResponse(identSocket);\n+                    IdentProtocol.IdentData ident;\n+\n+                    identSocket.close();\n+\n+                    try {\n+                        ident = IdentProtocol.decodeResponse(identPacket);\n+                    } catch (JsonParseException e) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Malformed IDENT response\");\n+                        return;\n+                    }\n+\n+                    if (ident.ver < IdentData.MIN_SUPPORTED_VERSION) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                \"Unsupported version \" + ident.ver);\n+                        return;\n+                    }\n+\n+                    if (!ident.product.equals(IdentData.PRODUCT_ROOMBA)) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                \"Not a Roomba: \" + ident.product);\n+                        return;\n+                    }\n+\n+                    blid = ident.blid;\n+                    this.blid = blid;\n+                }\n+\n+                logger.debug(\"BLID is: {}\", blid);\n+\n+                if (!config.havePassword()) {\n+                    RawMQTT mqtt;\n+\n+                    try {\n+                        mqtt = new RawMQTT(host, 8883);\n+                    } catch (KeyManagementException | NoSuchAlgorithmException e1) {\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e1.toString());\n+                        return; // This is internal system error, no retry\n+                    }\n+\n+                    mqtt.requestPassword();\n+                    RawMQTT.Packet response = mqtt.readPacket();\n+                    mqtt.close();\n+\n+                    if (response != null && response.isValidPasswdPacket()) {\n+                        RawMQTT.PasswdPacket passwdPacket = new RawMQTT.PasswdPacket(response);\n+\n+                        config.password = passwdPacket.getPassword();\n+                        if (config.havePassword()) {\n+                            Configuration configuration = editConfiguration();\n+\n+                            configuration.put(RoombaConfiguration.FIELD_PASSWORD, config.password);\n+                            updateConfiguration(configuration);\n+                        }\n+                    }\n+                }\n+\n+                if (!config.havePassword()) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING,\n+                            \"Authentication on the robot is required\");\n+                    scheduleReconnect();\n+                    return;\n+                }\n+\n+                logger.debug(\"Password is: {}\", config.password);\n+\n+                // BLID is used as both client ID and username. The name of BLID also came from Roomba980-python\n+                connection = new RoombaMqttBrokerConnection(config.ipaddress, blid, this);\n+                connection.start(blid, config.password);\n+\n+            } catch (IOException e) {\n+                error = e.toString();\n+            }\n+\n+            if (error != null) {\n+                logger.error(error);\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, error);\n+                scheduleReconnect();\n+            }\n+        });\n+    }\n+\n+    private void scheduleReconnect() {\n+        reconnectReq = scheduler.schedule(() -> {\n+            connect();\n+        }, reconnectDelay, TimeUnit.SECONDS);\n+    }\n+\n+    public void onConnected() {\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    public void onDisconnected(Throwable error) {\n+        String message = error.getMessage();\n+\n+        logger.error(\"MQTT connection failed: {}\", message);\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, message);\n+        scheduleReconnect();\n+    }\n+\n+    public void processMessage(String topic, byte[] payload) {\n+        String jsonStr = new String(payload);\n+        MQTTProtocol.StateMessage msg;\n+\n+        logger.trace(\"Got topic {} data {}\", topic, jsonStr);\n+\n+        try {\n+            // We are not consuming all the fields, so we have to create the reader explicitly\n+            // If we use fromJson(String) or fromJson(java.util.reader), it will throw\n+            // \"JSON not fully consumed\" exception, because not all the reader's content has been\n+            // used up. We want to avoid that also for compatibility reasons because newer iRobot\n+            // versions may add fields.\n+            JsonReader jsonReader = new JsonReader(new StringReader(jsonStr));\n+            msg = new Gson().fromJson(jsonReader, IdentData.class);\n+        } catch (JsonParseException e) {\n+            logger.error(\"Failed to parse JSON message from {}: {}\", config.ipaddress, e.toString());\n+            logger.error(\"Raw contents: {}\", payload);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9674556c16225cbbe635a06414cbf94eda1ea4c"}, "originalPosition": 346}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMDk4NzQwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/internal/IRobotHandlerFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNjowNzo1NVrOHnUVZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQxMTozMzo0MlrOHnt-cw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk4OTY2OQ==", "bodyText": "What's the purpose of this method?", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r510989669", "createdAt": "2020-10-23T16:07:55Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/internal/IRobotHandlerFactory.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.internal;\n+\n+import static org.openhab.binding.irobot.IRobotBindingConstants.THING_TYPE_ROOMBA;\n+\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.handler.RoombaHandler;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.binding.BaseThingHandlerFactory;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerFactory;\n+import org.osgi.service.component.ComponentContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+\n+/**\n+ * The {@link IRobotHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author hkuhn42 - Initial contribution\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - rename and update\n+ */\n+@Component(configurationPid = \"binding.irobot\", service = ThingHandlerFactory.class)\n+@NonNullByDefault\n+public class IRobotHandlerFactory extends BaseThingHandlerFactory {\n+\n+    private final static Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections.singleton(THING_TYPE_ROOMBA);\n+\n+    @Override\n+    public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n+        return SUPPORTED_THING_TYPES_UIDS.contains(thingTypeUID);\n+    }\n+\n+    @Activate\n+    protected void activate(ComponentContext componentContext, Map<String, Object> config) {\n+        super.activate(componentContext);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9674556c16225cbbe635a06414cbf94eda1ea4c"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTQwOTc3OQ==", "bodyText": "I don't remember. :) Probably i was puzzled by the fact that superclass' method has only one argument and subclass' one apparently has two. I have no idea how OSGi figures out what to supply. To me OSGi is a huge magical pandora's box, unbelievably badly documented. Their main page starts with some enterprise blather,  They have a \"Developer\" page, on attempt to download anything they ask me to fill in my personal data and subscribe to god knows what and why. And simple entering \"@activate\" in the search box in the header yields \"Not found\".\nSo i don't know how to navigate their docs, sorry for that.\nOr may be i just don't know what a Java annotation really is and how it maps to some classes / objects / whatever\nAnyways, removed.", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r511409779", "createdAt": "2020-10-24T11:33:42Z", "author": {"login": "Sonic-Amiga"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/internal/IRobotHandlerFactory.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.internal;\n+\n+import static org.openhab.binding.irobot.IRobotBindingConstants.THING_TYPE_ROOMBA;\n+\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.handler.RoombaHandler;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.binding.BaseThingHandlerFactory;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerFactory;\n+import org.osgi.service.component.ComponentContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+\n+/**\n+ * The {@link IRobotHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author hkuhn42 - Initial contribution\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - rename and update\n+ */\n+@Component(configurationPid = \"binding.irobot\", service = ThingHandlerFactory.class)\n+@NonNullByDefault\n+public class IRobotHandlerFactory extends BaseThingHandlerFactory {\n+\n+    private final static Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections.singleton(THING_TYPE_ROOMBA);\n+\n+    @Override\n+    public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n+        return SUPPORTED_THING_TYPES_UIDS.contains(thingTypeUID);\n+    }\n+\n+    @Activate\n+    protected void activate(ComponentContext componentContext, Map<String, Object> config) {\n+        super.activate(componentContext);\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk4OTY2OQ=="}, "originalCommit": {"oid": "e9674556c16225cbbe635a06414cbf94eda1ea4c"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMDk5MzE3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/internal/IdentProtocol.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNjowOTozNVrOHnUY3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNjowOTozNVrOHnUY3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk5MDU1OQ==", "bodyText": "See above. Gson object.", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r510990559", "createdAt": "2020-10-23T16:09:35Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/internal/IdentProtocol.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.internal;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.nio.charset.StandardCharsets;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * iRobot discovery and identification protocol\n+ *\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Initial contribution\n+ *\n+ */\n+public class IdentProtocol {\n+\n+    private static final String UDP_PACKET_CONTENTS = \"irobotmcs\";\n+    private static final int REMOTE_UDP_PORT = 5678;\n+\n+    public static DatagramSocket sendRequest(InetAddress host) throws IOException {\n+        DatagramSocket socket = new DatagramSocket();\n+\n+        socket.setBroadcast(true);\n+        socket.setReuseAddress(true);\n+\n+        byte[] packetContents = UDP_PACKET_CONTENTS.getBytes(StandardCharsets.UTF_8);\n+        DatagramPacket packet = new DatagramPacket(packetContents, packetContents.length, host, REMOTE_UDP_PORT);\n+\n+        socket.send(packet);\n+        return socket;\n+    }\n+\n+    public static DatagramPacket receiveResponse(DatagramSocket socket) throws IOException {\n+        byte[] buffer = new byte[1024];\n+        DatagramPacket incomingPacket = new DatagramPacket(buffer, buffer.length);\n+\n+        socket.setSoTimeout(1000 /* one second */);\n+        socket.receive(incomingPacket);\n+\n+        return incomingPacket;\n+    }\n+\n+    public static IdentData decodeResponse(DatagramPacket packet) throws JsonParseException, ClassCastException {\n+        /*\n+         * packet is a JSON of the following contents (addresses are undisclosed):\n+         * @formatter:off\n+         * {\n+         *   \"ver\":\"3\",\n+         *   \"hostname\":\"Roomba-3168820480607740\",\n+         *   \"robotname\":\"Roomba\",\n+         *   \"ip\":\"XXX.XXX.XXX.XXX\",\n+         *   \"mac\":\"XX:XX:XX:XX:XX:XX\",\n+         *   \"sw\":\"v2.4.6-3\",\n+         *   \"sku\":\"R981040\",\n+         *   \"nc\":0,\n+         *   \"proto\":\"mqtt\",\n+         *   \"cap\":{\n+         *     \"pose\":1,\n+         *     \"ota\":2,\n+         *     \"multiPass\":2,\n+         *     \"carpetBoost\":1,\n+         *     \"pp\":1,\n+         *     \"binFullDetect\":1,\n+         *     \"langOta\":1,\n+         *     \"maps\":1,\n+         *     \"edge\":1,\n+         *     \"eco\":1,\n+         *     \"svcConf\":1\n+         *   }\n+         * }\n+         * @formatter:on\n+         */\n+        String reply = new String(packet.getData());\n+        // We are not consuming all the fields, so we have to create the reader explicitly\n+        // If we use fromJson(String) or fromJson(java.util.reader), it will throw\n+        // \"JSON not fully consumed\" exception, because not all the reader's content has been\n+        // used up. We want to avoid that for compatibility reasons because newer iRobot versions\n+        // may add fields.\n+        JsonReader jsonReader = new JsonReader(new StringReader(reply));\n+        IdentData data = new Gson().fromJson(jsonReader, IdentData.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9674556c16225cbbe635a06414cbf94eda1ea4c"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMDk5NzQ3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/internal/IdentProtocol.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNjoxMDo0NVrOHnUbiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQxMTozNDoxOVrOHnt_DQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk5MTI0MQ==", "bodyText": "What is throwing a ClassCastException here?", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r510991241", "createdAt": "2020-10-23T16:10:45Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/internal/IdentProtocol.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.internal;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.nio.charset.StandardCharsets;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * iRobot discovery and identification protocol\n+ *\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Initial contribution\n+ *\n+ */\n+public class IdentProtocol {\n+\n+    private static final String UDP_PACKET_CONTENTS = \"irobotmcs\";\n+    private static final int REMOTE_UDP_PORT = 5678;\n+\n+    public static DatagramSocket sendRequest(InetAddress host) throws IOException {\n+        DatagramSocket socket = new DatagramSocket();\n+\n+        socket.setBroadcast(true);\n+        socket.setReuseAddress(true);\n+\n+        byte[] packetContents = UDP_PACKET_CONTENTS.getBytes(StandardCharsets.UTF_8);\n+        DatagramPacket packet = new DatagramPacket(packetContents, packetContents.length, host, REMOTE_UDP_PORT);\n+\n+        socket.send(packet);\n+        return socket;\n+    }\n+\n+    public static DatagramPacket receiveResponse(DatagramSocket socket) throws IOException {\n+        byte[] buffer = new byte[1024];\n+        DatagramPacket incomingPacket = new DatagramPacket(buffer, buffer.length);\n+\n+        socket.setSoTimeout(1000 /* one second */);\n+        socket.receive(incomingPacket);\n+\n+        return incomingPacket;\n+    }\n+\n+    public static IdentData decodeResponse(DatagramPacket packet) throws JsonParseException, ClassCastException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9674556c16225cbbe635a06414cbf94eda1ea4c"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTQwOTkzMw==", "bodyText": "Old version of the parser, which doesn't exist any more. :) Thanks for pointing out.", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r511409933", "createdAt": "2020-10-24T11:34:19Z", "author": {"login": "Sonic-Amiga"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/internal/IdentProtocol.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.internal;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.nio.charset.StandardCharsets;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * iRobot discovery and identification protocol\n+ *\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Initial contribution\n+ *\n+ */\n+public class IdentProtocol {\n+\n+    private static final String UDP_PACKET_CONTENTS = \"irobotmcs\";\n+    private static final int REMOTE_UDP_PORT = 5678;\n+\n+    public static DatagramSocket sendRequest(InetAddress host) throws IOException {\n+        DatagramSocket socket = new DatagramSocket();\n+\n+        socket.setBroadcast(true);\n+        socket.setReuseAddress(true);\n+\n+        byte[] packetContents = UDP_PACKET_CONTENTS.getBytes(StandardCharsets.UTF_8);\n+        DatagramPacket packet = new DatagramPacket(packetContents, packetContents.length, host, REMOTE_UDP_PORT);\n+\n+        socket.send(packet);\n+        return socket;\n+    }\n+\n+    public static DatagramPacket receiveResponse(DatagramSocket socket) throws IOException {\n+        byte[] buffer = new byte[1024];\n+        DatagramPacket incomingPacket = new DatagramPacket(buffer, buffer.length);\n+\n+        socket.setSoTimeout(1000 /* one second */);\n+        socket.receive(incomingPacket);\n+\n+        return incomingPacket;\n+    }\n+\n+    public static IdentData decodeResponse(DatagramPacket packet) throws JsonParseException, ClassCastException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk5MTI0MQ=="}, "originalCommit": {"oid": "e9674556c16225cbbe635a06414cbf94eda1ea4c"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMDk5ODI5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/internal/IdentProtocol.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNjoxMDo1NlrOHnUcBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQxMTo0MjoxN1rOHnuK9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk5MTM2NA==", "bodyText": "Can you specify the encoding you expect? E.g. StandardCharsets.UTF_8", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r510991364", "createdAt": "2020-10-23T16:10:56Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/internal/IdentProtocol.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.internal;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.nio.charset.StandardCharsets;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * iRobot discovery and identification protocol\n+ *\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Initial contribution\n+ *\n+ */\n+public class IdentProtocol {\n+\n+    private static final String UDP_PACKET_CONTENTS = \"irobotmcs\";\n+    private static final int REMOTE_UDP_PORT = 5678;\n+\n+    public static DatagramSocket sendRequest(InetAddress host) throws IOException {\n+        DatagramSocket socket = new DatagramSocket();\n+\n+        socket.setBroadcast(true);\n+        socket.setReuseAddress(true);\n+\n+        byte[] packetContents = UDP_PACKET_CONTENTS.getBytes(StandardCharsets.UTF_8);\n+        DatagramPacket packet = new DatagramPacket(packetContents, packetContents.length, host, REMOTE_UDP_PORT);\n+\n+        socket.send(packet);\n+        return socket;\n+    }\n+\n+    public static DatagramPacket receiveResponse(DatagramSocket socket) throws IOException {\n+        byte[] buffer = new byte[1024];\n+        DatagramPacket incomingPacket = new DatagramPacket(buffer, buffer.length);\n+\n+        socket.setSoTimeout(1000 /* one second */);\n+        socket.receive(incomingPacket);\n+\n+        return incomingPacket;\n+    }\n+\n+    public static IdentData decodeResponse(DatagramPacket packet) throws JsonParseException, ClassCastException {\n+        /*\n+         * packet is a JSON of the following contents (addresses are undisclosed):\n+         * @formatter:off\n+         * {\n+         *   \"ver\":\"3\",\n+         *   \"hostname\":\"Roomba-3168820480607740\",\n+         *   \"robotname\":\"Roomba\",\n+         *   \"ip\":\"XXX.XXX.XXX.XXX\",\n+         *   \"mac\":\"XX:XX:XX:XX:XX:XX\",\n+         *   \"sw\":\"v2.4.6-3\",\n+         *   \"sku\":\"R981040\",\n+         *   \"nc\":0,\n+         *   \"proto\":\"mqtt\",\n+         *   \"cap\":{\n+         *     \"pose\":1,\n+         *     \"ota\":2,\n+         *     \"multiPass\":2,\n+         *     \"carpetBoost\":1,\n+         *     \"pp\":1,\n+         *     \"binFullDetect\":1,\n+         *     \"langOta\":1,\n+         *     \"maps\":1,\n+         *     \"edge\":1,\n+         *     \"eco\":1,\n+         *     \"svcConf\":1\n+         *   }\n+         * }\n+         * @formatter:on\n+         */\n+        String reply = new String(packet.getData());\n+        // We are not consuming all the fields, so we have to create the reader explicitly\n+        // If we use fromJson(String) or fromJson(java.util.reader), it will throw\n+        // \"JSON not fully consumed\" exception, because not all the reader's content has been\n+        // used up. We want to avoid that for compatibility reasons because newer iRobot versions\n+        // may add fields.\n+        JsonReader jsonReader = new JsonReader(new StringReader(reply));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9674556c16225cbbe635a06414cbf94eda1ea4c"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTQxMjk4MQ==", "bodyText": "Done", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r511412981", "createdAt": "2020-10-24T11:42:17Z", "author": {"login": "Sonic-Amiga"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/internal/IdentProtocol.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.internal;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.nio.charset.StandardCharsets;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * iRobot discovery and identification protocol\n+ *\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Initial contribution\n+ *\n+ */\n+public class IdentProtocol {\n+\n+    private static final String UDP_PACKET_CONTENTS = \"irobotmcs\";\n+    private static final int REMOTE_UDP_PORT = 5678;\n+\n+    public static DatagramSocket sendRequest(InetAddress host) throws IOException {\n+        DatagramSocket socket = new DatagramSocket();\n+\n+        socket.setBroadcast(true);\n+        socket.setReuseAddress(true);\n+\n+        byte[] packetContents = UDP_PACKET_CONTENTS.getBytes(StandardCharsets.UTF_8);\n+        DatagramPacket packet = new DatagramPacket(packetContents, packetContents.length, host, REMOTE_UDP_PORT);\n+\n+        socket.send(packet);\n+        return socket;\n+    }\n+\n+    public static DatagramPacket receiveResponse(DatagramSocket socket) throws IOException {\n+        byte[] buffer = new byte[1024];\n+        DatagramPacket incomingPacket = new DatagramPacket(buffer, buffer.length);\n+\n+        socket.setSoTimeout(1000 /* one second */);\n+        socket.receive(incomingPacket);\n+\n+        return incomingPacket;\n+    }\n+\n+    public static IdentData decodeResponse(DatagramPacket packet) throws JsonParseException, ClassCastException {\n+        /*\n+         * packet is a JSON of the following contents (addresses are undisclosed):\n+         * @formatter:off\n+         * {\n+         *   \"ver\":\"3\",\n+         *   \"hostname\":\"Roomba-3168820480607740\",\n+         *   \"robotname\":\"Roomba\",\n+         *   \"ip\":\"XXX.XXX.XXX.XXX\",\n+         *   \"mac\":\"XX:XX:XX:XX:XX:XX\",\n+         *   \"sw\":\"v2.4.6-3\",\n+         *   \"sku\":\"R981040\",\n+         *   \"nc\":0,\n+         *   \"proto\":\"mqtt\",\n+         *   \"cap\":{\n+         *     \"pose\":1,\n+         *     \"ota\":2,\n+         *     \"multiPass\":2,\n+         *     \"carpetBoost\":1,\n+         *     \"pp\":1,\n+         *     \"binFullDetect\":1,\n+         *     \"langOta\":1,\n+         *     \"maps\":1,\n+         *     \"edge\":1,\n+         *     \"eco\":1,\n+         *     \"svcConf\":1\n+         *   }\n+         * }\n+         * @formatter:on\n+         */\n+        String reply = new String(packet.getData());\n+        // We are not consuming all the fields, so we have to create the reader explicitly\n+        // If we use fromJson(String) or fromJson(java.util.reader), it will throw\n+        // \"JSON not fully consumed\" exception, because not all the reader's content has been\n+        // used up. We want to avoid that for compatibility reasons because newer iRobot versions\n+        // may add fields.\n+        JsonReader jsonReader = new JsonReader(new StringReader(reply));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk5MTM2NA=="}, "originalCommit": {"oid": "e9674556c16225cbbe635a06414cbf94eda1ea4c"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMTAwNTM3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/internal/RawMQTT.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNjoxMjo1NFrOHnUgew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNjoxMjo1NFrOHnUgew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk5MjUwNw==", "bodyText": "See above. Encoding.", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r510992507", "createdAt": "2020-10-23T16:12:54Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/internal/RawMQTT.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.internal;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.TrustManager;\n+import javax.net.ssl.X509TrustManager;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * A \"raw MQTT\" client for sending custom \"get password\" request.\n+ * Seems pretty much reinventing a bicycle, but it looks like HiveMq\n+ * doesn't provide for sending and receiving custom packets.\n+ *\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class RawMQTT {\n+    public static final int ROOMBA_MQTT_PORT = 8883;\n+\n+    private Socket socket;\n+\n+    public static class Packet {\n+        public byte message;\n+        public byte[] payload;\n+\n+        Packet(byte msg, byte[] data) {\n+            message = msg;\n+            payload = data;\n+        }\n+\n+        public boolean isValidPasswdPacket() {\n+            return message == PasswdPacket.MESSAGE && payload.length >= PasswdPacket.HEADER_SIZE;\n+        }\n+    };\n+\n+    public static class PasswdPacket extends Packet {\n+        static final byte MESSAGE = (byte) 0xF0; // MQTT Reserved\n+        static final int MAGIC = 0x293bccef;\n+        static final byte HEADER_SIZE = 5;\n+        private ByteBuffer buffer;\n+\n+        public PasswdPacket(Packet raw) {\n+            super(raw.message, raw.payload);\n+            buffer = ByteBuffer.wrap(payload).order(ByteOrder.LITTLE_ENDIAN);\n+        }\n+\n+        public int getMagic() {\n+            return buffer.getInt(0);\n+        }\n+\n+        public byte getStatus() {\n+            return buffer.get(4);\n+        }\n+\n+        public @Nullable String getPassword() {\n+            if (getStatus() != 0) {\n+                return null;\n+            }\n+\n+            int length = payload.length - HEADER_SIZE;\n+            byte[] passwd = new byte[length];\n+\n+            buffer.position(HEADER_SIZE);\n+            buffer.get(passwd);\n+\n+            return new String(passwd);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9674556c16225cbbe635a06414cbf94eda1ea4c"}, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMTAwNzU2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/internal/RawMQTT.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNjoxMzoyOVrOHnUh4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQxMTo0NTozNVrOHnuPqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk5Mjg2NA==", "bodyText": "Can you do this or remove the comment?", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r510992864", "createdAt": "2020-10-23T16:13:29Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/internal/RawMQTT.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.internal;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.TrustManager;\n+import javax.net.ssl.X509TrustManager;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * A \"raw MQTT\" client for sending custom \"get password\" request.\n+ * Seems pretty much reinventing a bicycle, but it looks like HiveMq\n+ * doesn't provide for sending and receiving custom packets.\n+ *\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class RawMQTT {\n+    public static final int ROOMBA_MQTT_PORT = 8883;\n+\n+    private Socket socket;\n+\n+    public static class Packet {\n+        public byte message;\n+        public byte[] payload;\n+\n+        Packet(byte msg, byte[] data) {\n+            message = msg;\n+            payload = data;\n+        }\n+\n+        public boolean isValidPasswdPacket() {\n+            return message == PasswdPacket.MESSAGE && payload.length >= PasswdPacket.HEADER_SIZE;\n+        }\n+    };\n+\n+    public static class PasswdPacket extends Packet {\n+        static final byte MESSAGE = (byte) 0xF0; // MQTT Reserved\n+        static final int MAGIC = 0x293bccef;\n+        static final byte HEADER_SIZE = 5;\n+        private ByteBuffer buffer;\n+\n+        public PasswdPacket(Packet raw) {\n+            super(raw.message, raw.payload);\n+            buffer = ByteBuffer.wrap(payload).order(ByteOrder.LITTLE_ENDIAN);\n+        }\n+\n+        public int getMagic() {\n+            return buffer.getInt(0);\n+        }\n+\n+        public byte getStatus() {\n+            return buffer.get(4);\n+        }\n+\n+        public @Nullable String getPassword() {\n+            if (getStatus() != 0) {\n+                return null;\n+            }\n+\n+            int length = payload.length - HEADER_SIZE;\n+            byte[] passwd = new byte[length];\n+\n+            buffer.position(HEADER_SIZE);\n+            buffer.get(passwd);\n+\n+            return new String(passwd);\n+        }\n+    }\n+\n+    // Roomba MQTT is using SSL with custom root CA certificate.\n+    private static class MQTTTrustManager implements X509TrustManager {\n+        @Override\n+        public X509Certificate @Nullable [] getAcceptedIssuers() {\n+            return null;\n+        }\n+\n+        @Override\n+        public void checkClientTrusted(X509Certificate @Nullable [] arg0, @Nullable String arg1)\n+                throws CertificateException {\n+        }\n+\n+        @Override\n+        public void checkServerTrusted(X509Certificate @Nullable [] certs, @Nullable String authMethod)\n+                throws CertificateException {\n+            /*\n+             * TODO: Retrieve Roomba CA certificate and implement proper verification\n+             * logger.debug(\"Auth method: \" + authMethod);\n+             * for (X509Certificate cert : certs) {\n+             * logger.debug(\"Cert: \" + cert.toString());\n+             * }\n+             */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9674556c16225cbbe635a06414cbf94eda1ea4c"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTQxNDE4Nw==", "bodyText": "Removed. It would take significant time to do it. Perhaps need to reverse engineer smartphone's app built-in check", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r511414187", "createdAt": "2020-10-24T11:45:35Z", "author": {"login": "Sonic-Amiga"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/internal/RawMQTT.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.internal;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.TrustManager;\n+import javax.net.ssl.X509TrustManager;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * A \"raw MQTT\" client for sending custom \"get password\" request.\n+ * Seems pretty much reinventing a bicycle, but it looks like HiveMq\n+ * doesn't provide for sending and receiving custom packets.\n+ *\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Initial contribution\n+ *\n+ */\n+@NonNullByDefault\n+public class RawMQTT {\n+    public static final int ROOMBA_MQTT_PORT = 8883;\n+\n+    private Socket socket;\n+\n+    public static class Packet {\n+        public byte message;\n+        public byte[] payload;\n+\n+        Packet(byte msg, byte[] data) {\n+            message = msg;\n+            payload = data;\n+        }\n+\n+        public boolean isValidPasswdPacket() {\n+            return message == PasswdPacket.MESSAGE && payload.length >= PasswdPacket.HEADER_SIZE;\n+        }\n+    };\n+\n+    public static class PasswdPacket extends Packet {\n+        static final byte MESSAGE = (byte) 0xF0; // MQTT Reserved\n+        static final int MAGIC = 0x293bccef;\n+        static final byte HEADER_SIZE = 5;\n+        private ByteBuffer buffer;\n+\n+        public PasswdPacket(Packet raw) {\n+            super(raw.message, raw.payload);\n+            buffer = ByteBuffer.wrap(payload).order(ByteOrder.LITTLE_ENDIAN);\n+        }\n+\n+        public int getMagic() {\n+            return buffer.getInt(0);\n+        }\n+\n+        public byte getStatus() {\n+            return buffer.get(4);\n+        }\n+\n+        public @Nullable String getPassword() {\n+            if (getStatus() != 0) {\n+                return null;\n+            }\n+\n+            int length = payload.length - HEADER_SIZE;\n+            byte[] passwd = new byte[length];\n+\n+            buffer.position(HEADER_SIZE);\n+            buffer.get(passwd);\n+\n+            return new String(passwd);\n+        }\n+    }\n+\n+    // Roomba MQTT is using SSL with custom root CA certificate.\n+    private static class MQTTTrustManager implements X509TrustManager {\n+        @Override\n+        public X509Certificate @Nullable [] getAcceptedIssuers() {\n+            return null;\n+        }\n+\n+        @Override\n+        public void checkClientTrusted(X509Certificate @Nullable [] arg0, @Nullable String arg1)\n+                throws CertificateException {\n+        }\n+\n+        @Override\n+        public void checkServerTrusted(X509Certificate @Nullable [] certs, @Nullable String authMethod)\n+                throws CertificateException {\n+            /*\n+             * TODO: Retrieve Roomba CA certificate and implement proper verification\n+             * logger.debug(\"Auth method: \" + authMethod);\n+             * for (X509Certificate cert : certs) {\n+             * logger.debug(\"Cert: \" + cert.toString());\n+             * }\n+             */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk5Mjg2NA=="}, "originalCommit": {"oid": "e9674556c16225cbbe635a06414cbf94eda1ea4c"}, "originalPosition": 116}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMTAxNTExOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/roomba/RoombaConfiguration.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNjoxNToyOFrOHnUmWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQxMTo1Mjo1MFrOHnuYuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk5NDAwOQ==", "bodyText": "Please add the NonNullByDefault annotation.", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r510994009", "createdAt": "2020-10-23T16:15:28Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/roomba/RoombaConfiguration.java", "diffHunk": "@@ -0,0 +1,31 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.roomba;\n+\n+/**\n+ * Roomba Thing configuration\n+ *\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Initial contribution\n+ *\n+ */\n+public class RoombaConfiguration {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9674556c16225cbbe635a06414cbf94eda1ea4c"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTQxNjUwNA==", "bodyText": "The official doc says that these are not mandatory for data-only classes like config. But enjoy.", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r511416504", "createdAt": "2020-10-24T11:52:50Z", "author": {"login": "Sonic-Amiga"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/roomba/RoombaConfiguration.java", "diffHunk": "@@ -0,0 +1,31 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.roomba;\n+\n+/**\n+ * Roomba Thing configuration\n+ *\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Initial contribution\n+ *\n+ */\n+public class RoombaConfiguration {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk5NDAwOQ=="}, "originalCommit": {"oid": "e9674556c16225cbbe635a06414cbf94eda1ea4c"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMTAxNzUxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/roomba/RoombaConfiguration.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNjoxNjowOVrOHnUn1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQxMTo1MDoxMVrOHnuVkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk5NDM5MA==", "bodyText": "The Configuration class should only contain members that are part of the config.", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r510994390", "createdAt": "2020-10-23T16:16:09Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/roomba/RoombaConfiguration.java", "diffHunk": "@@ -0,0 +1,31 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.roomba;\n+\n+/**\n+ * Roomba Thing configuration\n+ *\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Initial contribution\n+ *\n+ */\n+public class RoombaConfiguration {\n+    public static String FIELD_IPADDRESS = \"ipaddress\";\n+    public static String FIELD_PASSWORD = \"password\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9674556c16225cbbe635a06414cbf94eda1ea4c"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTQxNTY5Ng==", "bodyText": "Some API calls refer to names of config fields in string form, i thought it would be very logical and convenient to have them here. But enjoy.", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r511415696", "createdAt": "2020-10-24T11:50:11Z", "author": {"login": "Sonic-Amiga"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/roomba/RoombaConfiguration.java", "diffHunk": "@@ -0,0 +1,31 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.roomba;\n+\n+/**\n+ * Roomba Thing configuration\n+ *\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Initial contribution\n+ *\n+ */\n+public class RoombaConfiguration {\n+    public static String FIELD_IPADDRESS = \"ipaddress\";\n+    public static String FIELD_PASSWORD = \"password\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk5NDM5MA=="}, "originalCommit": {"oid": "e9674556c16225cbbe635a06414cbf94eda1ea4c"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMTAyNDgwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.irobot/src/main/resources/OH-INF/binding/binding.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNjoxODoxMlrOHnUsjA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNjoxODoxMlrOHnUsjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk5NTU5Ng==", "bodyText": "Could you be a bit more verbose, so that somebody who hasn't heard about it gets a clue what this is about (vacuum robots)?", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r510995596", "createdAt": "2020-10-23T16:18:12Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.irobot/src/main/resources/OH-INF/binding/binding.xml", "diffHunk": "@@ -0,0 +1,10 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<binding:binding id=\"irobot\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:binding=\"https://openhab.org/schemas/binding/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/binding/v1.0.0 https://openhab.org/schemas/binding-1.0.0.xsd\">\n+\n+\t<name>IRobot Binding</name>\n+\t<description>This is the binding for iRobot robots.</description>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9674556c16225cbbe635a06414cbf94eda1ea4c"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMTAyNTQxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.irobot/src/main/resources/OH-INF/binding/binding.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNjoxODoyNFrOHnUs7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNjoxODoyNFrOHnUs7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk5NTY5Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t<name>IRobot Binding</name>\n          \n          \n            \n            \t<name>iRobot Binding</name>", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r510995693", "createdAt": "2020-10-23T16:18:24Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.irobot/src/main/resources/OH-INF/binding/binding.xml", "diffHunk": "@@ -0,0 +1,10 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<binding:binding id=\"irobot\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:binding=\"https://openhab.org/schemas/binding/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/binding/v1.0.0 https://openhab.org/schemas/binding-1.0.0.xsd\">\n+\n+\t<name>IRobot Binding</name>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9674556c16225cbbe635a06414cbf94eda1ea4c"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMTAyNjYwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.irobot/src/main/resources/OH-INF/thing/thing-types.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNjoxODo0MlrOHnUtsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQxMTo1NDoxMVrOHnuaaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk5NTg5MA==", "bodyText": "Can this be removed?", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r510995890", "createdAt": "2020-10-23T16:18:42Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.irobot/src/main/resources/OH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,260 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"irobot\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- Sample Thing Type -->", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9674556c16225cbbe635a06414cbf94eda1ea4c"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTQxNjkzNw==", "bodyText": "Of course :)", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r511416937", "createdAt": "2020-10-24T11:54:11Z", "author": {"login": "Sonic-Amiga"}, "path": "bundles/org.openhab.binding.irobot/src/main/resources/OH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,260 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"irobot\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- Sample Thing Type -->", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk5NTg5MA=="}, "originalCommit": {"oid": "e9674556c16225cbbe635a06414cbf94eda1ea4c"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMTAyOTE5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.irobot/src/main/resources/OH-INF/thing/thing-types.xml", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNjoxOToyMlrOHnUvPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQxNDoyMTozNlrOHnxnsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk5NjI4Nw==", "bodyText": "You could specify <context>network-address</context> to get a free validation.", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r510996287", "createdAt": "2020-10-23T16:19:22Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.irobot/src/main/resources/OH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,260 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"irobot\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- Sample Thing Type -->\n+\t<thing-type id=\"roomba\">\n+\t\t<label>Roomba</label>\n+\t\t<description>A Roomba vacuum robot</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"command\" typeId=\"command\"/>\n+\t\t\t<channel id=\"cycle\" typeId=\"cycle\"/>\n+\t\t\t<channel id=\"phase\" typeId=\"phase\"/>\n+\t\t\t<channel id=\"battery\" typeId=\"battery\"/>\n+\t\t\t<channel id=\"bin\" typeId=\"bin\"/>\n+\t\t\t<channel id=\"error\" typeId=\"error\"/>\n+\t\t\t<channel id=\"rssi\" typeId=\"rssi\"/>\n+\t\t\t<channel id=\"snr\" typeId=\"snr\"/>\n+\t\t\t<channel id=\"sched_mon\" typeId=\"sched_switch\">\n+\t\t\t\t<label>Schedule Mon</label>\n+\t\t\t\t<description>Monday schedule active</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"sched_tue\" typeId=\"sched_switch\">\n+\t\t\t\t<label>Schedule Tue</label>\n+\t\t\t\t<description>Tuesday schedule active</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"sched_wed\" typeId=\"sched_switch\">\n+\t\t\t\t<label>Schedule Wed</label>\n+\t\t\t\t<description>Wednesday schedule active</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"sched_thu\" typeId=\"sched_switch\">\n+\t\t\t\t<label>Schedule Thu</label>\n+\t\t\t\t<description>Thirsday schedule active</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"sched_fri\" typeId=\"sched_switch\">\n+\t\t\t\t<label>Schedule Fri</label>\n+\t\t\t\t<description>Friday schedule active</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"sched_sat\" typeId=\"sched_switch\">\n+\t\t\t\t<label>Schedule Sat</label>\n+\t\t\t\t<description>Saturday schedule active</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"sched_sun\" typeId=\"sched_switch\">\n+\t\t\t\t<label>Schedule Sun</label>\n+\t\t\t\t<description>Sunday schedule active</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"schedule\" typeId=\"schedule\"/>\n+\t\t\t<channel id=\"edge_clean\" typeId=\"edge_clean\"/>\n+\t\t\t<channel id=\"always_finish\" typeId=\"always_finish\"/>\n+\t\t\t<channel id=\"power_boost\" typeId=\"power_boost\"/>\n+\t\t\t<channel id=\"clean_passes\" typeId=\"clean_passes\"/>\n+\t\t</channels>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"ipaddress\" type=\"text\">\n+\t\t\t\t<label>IP Address</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9674556c16225cbbe635a06414cbf94eda1ea4c"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTQxNzMxNg==", "bodyText": "But what about arbitrary host name ? Like \"my_roomba.livingroom.local\" ? It's not forbidden to use /etc/hosts or local DNS. Or is it ?", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r511417316", "createdAt": "2020-10-24T11:55:27Z", "author": {"login": "Sonic-Amiga"}, "path": "bundles/org.openhab.binding.irobot/src/main/resources/OH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,260 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"irobot\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- Sample Thing Type -->\n+\t<thing-type id=\"roomba\">\n+\t\t<label>Roomba</label>\n+\t\t<description>A Roomba vacuum robot</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"command\" typeId=\"command\"/>\n+\t\t\t<channel id=\"cycle\" typeId=\"cycle\"/>\n+\t\t\t<channel id=\"phase\" typeId=\"phase\"/>\n+\t\t\t<channel id=\"battery\" typeId=\"battery\"/>\n+\t\t\t<channel id=\"bin\" typeId=\"bin\"/>\n+\t\t\t<channel id=\"error\" typeId=\"error\"/>\n+\t\t\t<channel id=\"rssi\" typeId=\"rssi\"/>\n+\t\t\t<channel id=\"snr\" typeId=\"snr\"/>\n+\t\t\t<channel id=\"sched_mon\" typeId=\"sched_switch\">\n+\t\t\t\t<label>Schedule Mon</label>\n+\t\t\t\t<description>Monday schedule active</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"sched_tue\" typeId=\"sched_switch\">\n+\t\t\t\t<label>Schedule Tue</label>\n+\t\t\t\t<description>Tuesday schedule active</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"sched_wed\" typeId=\"sched_switch\">\n+\t\t\t\t<label>Schedule Wed</label>\n+\t\t\t\t<description>Wednesday schedule active</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"sched_thu\" typeId=\"sched_switch\">\n+\t\t\t\t<label>Schedule Thu</label>\n+\t\t\t\t<description>Thirsday schedule active</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"sched_fri\" typeId=\"sched_switch\">\n+\t\t\t\t<label>Schedule Fri</label>\n+\t\t\t\t<description>Friday schedule active</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"sched_sat\" typeId=\"sched_switch\">\n+\t\t\t\t<label>Schedule Sat</label>\n+\t\t\t\t<description>Saturday schedule active</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"sched_sun\" typeId=\"sched_switch\">\n+\t\t\t\t<label>Schedule Sun</label>\n+\t\t\t\t<description>Sunday schedule active</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"schedule\" typeId=\"schedule\"/>\n+\t\t\t<channel id=\"edge_clean\" typeId=\"edge_clean\"/>\n+\t\t\t<channel id=\"always_finish\" typeId=\"always_finish\"/>\n+\t\t\t<channel id=\"power_boost\" typeId=\"power_boost\"/>\n+\t\t\t<channel id=\"clean_passes\" typeId=\"clean_passes\"/>\n+\t\t</channels>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"ipaddress\" type=\"text\">\n+\t\t\t\t<label>IP Address</label>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk5NjI4Nw=="}, "originalCommit": {"oid": "e9674556c16225cbbe635a06414cbf94eda1ea4c"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTQ2OTQ4OQ==", "bodyText": "I've checked what Daikin binding does, it even calls the field \"Hostname\", but still uses this context. Apparently it works with hostnames too, done", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r511469489", "createdAt": "2020-10-24T14:21:36Z", "author": {"login": "Sonic-Amiga"}, "path": "bundles/org.openhab.binding.irobot/src/main/resources/OH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,260 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"irobot\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- Sample Thing Type -->\n+\t<thing-type id=\"roomba\">\n+\t\t<label>Roomba</label>\n+\t\t<description>A Roomba vacuum robot</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"command\" typeId=\"command\"/>\n+\t\t\t<channel id=\"cycle\" typeId=\"cycle\"/>\n+\t\t\t<channel id=\"phase\" typeId=\"phase\"/>\n+\t\t\t<channel id=\"battery\" typeId=\"battery\"/>\n+\t\t\t<channel id=\"bin\" typeId=\"bin\"/>\n+\t\t\t<channel id=\"error\" typeId=\"error\"/>\n+\t\t\t<channel id=\"rssi\" typeId=\"rssi\"/>\n+\t\t\t<channel id=\"snr\" typeId=\"snr\"/>\n+\t\t\t<channel id=\"sched_mon\" typeId=\"sched_switch\">\n+\t\t\t\t<label>Schedule Mon</label>\n+\t\t\t\t<description>Monday schedule active</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"sched_tue\" typeId=\"sched_switch\">\n+\t\t\t\t<label>Schedule Tue</label>\n+\t\t\t\t<description>Tuesday schedule active</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"sched_wed\" typeId=\"sched_switch\">\n+\t\t\t\t<label>Schedule Wed</label>\n+\t\t\t\t<description>Wednesday schedule active</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"sched_thu\" typeId=\"sched_switch\">\n+\t\t\t\t<label>Schedule Thu</label>\n+\t\t\t\t<description>Thirsday schedule active</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"sched_fri\" typeId=\"sched_switch\">\n+\t\t\t\t<label>Schedule Fri</label>\n+\t\t\t\t<description>Friday schedule active</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"sched_sat\" typeId=\"sched_switch\">\n+\t\t\t\t<label>Schedule Sat</label>\n+\t\t\t\t<description>Saturday schedule active</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"sched_sun\" typeId=\"sched_switch\">\n+\t\t\t\t<label>Schedule Sun</label>\n+\t\t\t\t<description>Sunday schedule active</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"schedule\" typeId=\"schedule\"/>\n+\t\t\t<channel id=\"edge_clean\" typeId=\"edge_clean\"/>\n+\t\t\t<channel id=\"always_finish\" typeId=\"always_finish\"/>\n+\t\t\t<channel id=\"power_boost\" typeId=\"power_boost\"/>\n+\t\t\t<channel id=\"clean_passes\" typeId=\"clean_passes\"/>\n+\t\t</channels>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"ipaddress\" type=\"text\">\n+\t\t\t\t<label>IP Address</label>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk5NjI4Nw=="}, "originalCommit": {"oid": "e9674556c16225cbbe635a06414cbf94eda1ea4c"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMTAzMDc2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.irobot/src/main/resources/OH-INF/thing/thing-types.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNjoxOTo0N1rOHnUwNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNjoxOTo0N1rOHnUwNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk5NjUzNA==", "bodyText": "This doesn't have any effect and could be removed. Same for below.", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r510996534", "createdAt": "2020-10-23T16:19:47Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.irobot/src/main/resources/OH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,260 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"irobot\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- Sample Thing Type -->\n+\t<thing-type id=\"roomba\">\n+\t\t<label>Roomba</label>\n+\t\t<description>A Roomba vacuum robot</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"command\" typeId=\"command\"/>\n+\t\t\t<channel id=\"cycle\" typeId=\"cycle\"/>\n+\t\t\t<channel id=\"phase\" typeId=\"phase\"/>\n+\t\t\t<channel id=\"battery\" typeId=\"battery\"/>\n+\t\t\t<channel id=\"bin\" typeId=\"bin\"/>\n+\t\t\t<channel id=\"error\" typeId=\"error\"/>\n+\t\t\t<channel id=\"rssi\" typeId=\"rssi\"/>\n+\t\t\t<channel id=\"snr\" typeId=\"snr\"/>\n+\t\t\t<channel id=\"sched_mon\" typeId=\"sched_switch\">\n+\t\t\t\t<label>Schedule Mon</label>\n+\t\t\t\t<description>Monday schedule active</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"sched_tue\" typeId=\"sched_switch\">\n+\t\t\t\t<label>Schedule Tue</label>\n+\t\t\t\t<description>Tuesday schedule active</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"sched_wed\" typeId=\"sched_switch\">\n+\t\t\t\t<label>Schedule Wed</label>\n+\t\t\t\t<description>Wednesday schedule active</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"sched_thu\" typeId=\"sched_switch\">\n+\t\t\t\t<label>Schedule Thu</label>\n+\t\t\t\t<description>Thirsday schedule active</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"sched_fri\" typeId=\"sched_switch\">\n+\t\t\t\t<label>Schedule Fri</label>\n+\t\t\t\t<description>Friday schedule active</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"sched_sat\" typeId=\"sched_switch\">\n+\t\t\t\t<label>Schedule Sat</label>\n+\t\t\t\t<description>Saturday schedule active</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"sched_sun\" typeId=\"sched_switch\">\n+\t\t\t\t<label>Schedule Sun</label>\n+\t\t\t\t<description>Sunday schedule active</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"schedule\" typeId=\"schedule\"/>\n+\t\t\t<channel id=\"edge_clean\" typeId=\"edge_clean\"/>\n+\t\t\t<channel id=\"always_finish\" typeId=\"always_finish\"/>\n+\t\t\t<channel id=\"power_boost\" typeId=\"power_boost\"/>\n+\t\t\t<channel id=\"clean_passes\" typeId=\"clean_passes\"/>\n+\t\t</channels>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"ipaddress\" type=\"text\">\n+\t\t\t\t<label>IP Address</label>\n+\t\t\t\t<description>IP Address of your Roomba</description>\n+\t\t\t\t<default></default>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9674556c16225cbbe635a06414cbf94eda1ea4c"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMTAzMjcxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.irobot/src/main/resources/OH-INF/thing/thing-types.xml", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNjoyMDoxOVrOHnUxZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxOToxNTo0NVrOHoeqsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk5NjgzOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t<parameter name=\"password\" type=\"text\">\n          \n          \n            \n            \t\t\t<parameter name=\"password\" type=\"text\">\n          \n          \n            \n            \t\t\t<context>password</context>", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r510996838", "createdAt": "2020-10-23T16:20:19Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.irobot/src/main/resources/OH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,260 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"irobot\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- Sample Thing Type -->\n+\t<thing-type id=\"roomba\">\n+\t\t<label>Roomba</label>\n+\t\t<description>A Roomba vacuum robot</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"command\" typeId=\"command\"/>\n+\t\t\t<channel id=\"cycle\" typeId=\"cycle\"/>\n+\t\t\t<channel id=\"phase\" typeId=\"phase\"/>\n+\t\t\t<channel id=\"battery\" typeId=\"battery\"/>\n+\t\t\t<channel id=\"bin\" typeId=\"bin\"/>\n+\t\t\t<channel id=\"error\" typeId=\"error\"/>\n+\t\t\t<channel id=\"rssi\" typeId=\"rssi\"/>\n+\t\t\t<channel id=\"snr\" typeId=\"snr\"/>\n+\t\t\t<channel id=\"sched_mon\" typeId=\"sched_switch\">\n+\t\t\t\t<label>Schedule Mon</label>\n+\t\t\t\t<description>Monday schedule active</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"sched_tue\" typeId=\"sched_switch\">\n+\t\t\t\t<label>Schedule Tue</label>\n+\t\t\t\t<description>Tuesday schedule active</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"sched_wed\" typeId=\"sched_switch\">\n+\t\t\t\t<label>Schedule Wed</label>\n+\t\t\t\t<description>Wednesday schedule active</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"sched_thu\" typeId=\"sched_switch\">\n+\t\t\t\t<label>Schedule Thu</label>\n+\t\t\t\t<description>Thirsday schedule active</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"sched_fri\" typeId=\"sched_switch\">\n+\t\t\t\t<label>Schedule Fri</label>\n+\t\t\t\t<description>Friday schedule active</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"sched_sat\" typeId=\"sched_switch\">\n+\t\t\t\t<label>Schedule Sat</label>\n+\t\t\t\t<description>Saturday schedule active</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"sched_sun\" typeId=\"sched_switch\">\n+\t\t\t\t<label>Schedule Sun</label>\n+\t\t\t\t<description>Sunday schedule active</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"schedule\" typeId=\"schedule\"/>\n+\t\t\t<channel id=\"edge_clean\" typeId=\"edge_clean\"/>\n+\t\t\t<channel id=\"always_finish\" typeId=\"always_finish\"/>\n+\t\t\t<channel id=\"power_boost\" typeId=\"power_boost\"/>\n+\t\t\t<channel id=\"clean_passes\" typeId=\"clean_passes\"/>\n+\t\t</channels>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"ipaddress\" type=\"text\">\n+\t\t\t\t<label>IP Address</label>\n+\t\t\t\t<description>IP Address of your Roomba</description>\n+\t\t\t\t<default></default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"password\" type=\"text\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e9674556c16225cbbe635a06414cbf94eda1ea4c"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTQxOTE2Ng==", "bodyText": "Nope. Above i described the usage of the password. It's dictated by the robot, not by the user. There can be millions of reasons why the user would want to know it. And reading it here is the only way to go. There should not be stars / dots instead.\nFor instance, you may want to be able to quickly restore the configuration, or migrate from OH v3 to OH v4 without having to go through the process of re-identifying all of 30 robots by pressing a button on each of them.\nPersonally i use it every time when i am adding new channels during the development. In order to update the OH and get the new channels, you need to remove the Thing completely and re-add it again. Being able to Ctrl-C Ctrl-V the password is super handy.\nOther projects (python or Dorita) supply a special tool in order for the user to retrieve the password, here the tool comes built-in,", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r511419166", "createdAt": "2020-10-24T12:01:13Z", "author": {"login": "Sonic-Amiga"}, "path": "bundles/org.openhab.binding.irobot/src/main/resources/OH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,260 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"irobot\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- Sample Thing Type -->\n+\t<thing-type id=\"roomba\">\n+\t\t<label>Roomba</label>\n+\t\t<description>A Roomba vacuum robot</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"command\" typeId=\"command\"/>\n+\t\t\t<channel id=\"cycle\" typeId=\"cycle\"/>\n+\t\t\t<channel id=\"phase\" typeId=\"phase\"/>\n+\t\t\t<channel id=\"battery\" typeId=\"battery\"/>\n+\t\t\t<channel id=\"bin\" typeId=\"bin\"/>\n+\t\t\t<channel id=\"error\" typeId=\"error\"/>\n+\t\t\t<channel id=\"rssi\" typeId=\"rssi\"/>\n+\t\t\t<channel id=\"snr\" typeId=\"snr\"/>\n+\t\t\t<channel id=\"sched_mon\" typeId=\"sched_switch\">\n+\t\t\t\t<label>Schedule Mon</label>\n+\t\t\t\t<description>Monday schedule active</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"sched_tue\" typeId=\"sched_switch\">\n+\t\t\t\t<label>Schedule Tue</label>\n+\t\t\t\t<description>Tuesday schedule active</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"sched_wed\" typeId=\"sched_switch\">\n+\t\t\t\t<label>Schedule Wed</label>\n+\t\t\t\t<description>Wednesday schedule active</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"sched_thu\" typeId=\"sched_switch\">\n+\t\t\t\t<label>Schedule Thu</label>\n+\t\t\t\t<description>Thirsday schedule active</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"sched_fri\" typeId=\"sched_switch\">\n+\t\t\t\t<label>Schedule Fri</label>\n+\t\t\t\t<description>Friday schedule active</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"sched_sat\" typeId=\"sched_switch\">\n+\t\t\t\t<label>Schedule Sat</label>\n+\t\t\t\t<description>Saturday schedule active</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"sched_sun\" typeId=\"sched_switch\">\n+\t\t\t\t<label>Schedule Sun</label>\n+\t\t\t\t<description>Sunday schedule active</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"schedule\" typeId=\"schedule\"/>\n+\t\t\t<channel id=\"edge_clean\" typeId=\"edge_clean\"/>\n+\t\t\t<channel id=\"always_finish\" typeId=\"always_finish\"/>\n+\t\t\t<channel id=\"power_boost\" typeId=\"power_boost\"/>\n+\t\t\t<channel id=\"clean_passes\" typeId=\"clean_passes\"/>\n+\t\t</channels>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"ipaddress\" type=\"text\">\n+\t\t\t\t<label>IP Address</label>\n+\t\t\t\t<description>IP Address of your Roomba</description>\n+\t\t\t\t<default></default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"password\" type=\"text\">", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk5NjgzOA=="}, "originalCommit": {"oid": "e9674556c16225cbbe635a06414cbf94eda1ea4c"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjIwNzUzNg==", "bodyText": "You convinced me.", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r512207536", "createdAt": "2020-10-26T19:15:45Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.irobot/src/main/resources/OH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,260 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"irobot\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- Sample Thing Type -->\n+\t<thing-type id=\"roomba\">\n+\t\t<label>Roomba</label>\n+\t\t<description>A Roomba vacuum robot</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"command\" typeId=\"command\"/>\n+\t\t\t<channel id=\"cycle\" typeId=\"cycle\"/>\n+\t\t\t<channel id=\"phase\" typeId=\"phase\"/>\n+\t\t\t<channel id=\"battery\" typeId=\"battery\"/>\n+\t\t\t<channel id=\"bin\" typeId=\"bin\"/>\n+\t\t\t<channel id=\"error\" typeId=\"error\"/>\n+\t\t\t<channel id=\"rssi\" typeId=\"rssi\"/>\n+\t\t\t<channel id=\"snr\" typeId=\"snr\"/>\n+\t\t\t<channel id=\"sched_mon\" typeId=\"sched_switch\">\n+\t\t\t\t<label>Schedule Mon</label>\n+\t\t\t\t<description>Monday schedule active</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"sched_tue\" typeId=\"sched_switch\">\n+\t\t\t\t<label>Schedule Tue</label>\n+\t\t\t\t<description>Tuesday schedule active</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"sched_wed\" typeId=\"sched_switch\">\n+\t\t\t\t<label>Schedule Wed</label>\n+\t\t\t\t<description>Wednesday schedule active</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"sched_thu\" typeId=\"sched_switch\">\n+\t\t\t\t<label>Schedule Thu</label>\n+\t\t\t\t<description>Thirsday schedule active</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"sched_fri\" typeId=\"sched_switch\">\n+\t\t\t\t<label>Schedule Fri</label>\n+\t\t\t\t<description>Friday schedule active</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"sched_sat\" typeId=\"sched_switch\">\n+\t\t\t\t<label>Schedule Sat</label>\n+\t\t\t\t<description>Saturday schedule active</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"sched_sun\" typeId=\"sched_switch\">\n+\t\t\t\t<label>Schedule Sun</label>\n+\t\t\t\t<description>Sunday schedule active</description>\n+\t\t\t</channel>\n+\t\t\t<channel id=\"schedule\" typeId=\"schedule\"/>\n+\t\t\t<channel id=\"edge_clean\" typeId=\"edge_clean\"/>\n+\t\t\t<channel id=\"always_finish\" typeId=\"always_finish\"/>\n+\t\t\t<channel id=\"power_boost\" typeId=\"power_boost\"/>\n+\t\t\t<channel id=\"clean_passes\" typeId=\"clean_passes\"/>\n+\t\t</channels>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"ipaddress\" type=\"text\">\n+\t\t\t\t<label>IP Address</label>\n+\t\t\t\t<description>IP Address of your Roomba</description>\n+\t\t\t\t<default></default>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"password\" type=\"text\">", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk5NjgzOA=="}, "originalCommit": {"oid": "e9674556c16225cbbe635a06414cbf94eda1ea4c"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MTkxMjI5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.daikin/CONTRIBUTING.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxNToxNzozOFrOHuyHsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxODozMjoxMFrOHwp66A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODgxNzcxMw==", "bodyText": "This file shouldn't be part of the PR.", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r518817713", "createdAt": "2020-11-06T15:17:38Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.daikin/CONTRIBUTING.md", "diffHunk": "@@ -0,0 +1,174 @@\n+# Contributing to openHAB", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "12d1bc627f38ece34b5c0c2b3390787e69ad0cfd"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDc4MDUyMA==", "bodyText": "Thanks; i have no idea where it came from.", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r520780520", "createdAt": "2020-11-10T18:32:10Z", "author": {"login": "Sonic-Amiga"}, "path": "bundles/org.openhab.binding.daikin/CONTRIBUTING.md", "diffHunk": "@@ -0,0 +1,174 @@\n+# Contributing to openHAB", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODgxNzcxMw=="}, "originalCommit": {"oid": "12d1bc627f38ece34b5c0c2b3390787e69ad0cfd"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MTkzNzU3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.irobot/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxNToyMzowM1rOHuyYFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxNToyMzowM1rOHuyYFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODgyMTkwOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            not work. Add the robot manually as Roomba. and use external tools (like Dorita980) in order to retrieve the\n          \n          \n            \n            not work. Add the robot manually as Roomba and use external tools (like Dorita980) in order to retrieve the", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r518821908", "createdAt": "2020-11-06T15:23:03Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.irobot/README.md", "diffHunk": "@@ -0,0 +1,184 @@\n+# iRobot Binding\n+\n+This binding provides integration of products by iRobot company (http://www.irobot.com/). It is currently developed to support Roomba 900\n+series robotic vacuum cleaner with built-in Wi-Fi module. The binding interfaces to the robot directly without any need for a dedicated MQTT server.\n+\n+## Supported Things\n+\n+- iRobot Roomba robotic vacuum cleaner (https://www.irobot.com/roomba). The binding has been developed and tested with Roomba 930.\n+- iRobot Braava has also been reported to (partially) work. Automatic configuration and password retrieval does\n+not work. Add the robot manually as Roomba. and use external tools (like Dorita980) in order to retrieve the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "12d1bc627f38ece34b5c0c2b3390787e69ad0cfd"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MTk0MDk5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.irobot/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxNToyMzo1MlrOHuyaRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxNToyMzo1MlrOHuyaRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODgyMjQ3MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ## Known problems / caveats\n          \n          \n            \n            ## Known Problems / Caveats", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r518822471", "createdAt": "2020-11-06T15:23:52Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.irobot/README.md", "diffHunk": "@@ -0,0 +1,184 @@\n+# iRobot Binding\n+\n+This binding provides integration of products by iRobot company (http://www.irobot.com/). It is currently developed to support Roomba 900\n+series robotic vacuum cleaner with built-in Wi-Fi module. The binding interfaces to the robot directly without any need for a dedicated MQTT server.\n+\n+## Supported Things\n+\n+- iRobot Roomba robotic vacuum cleaner (https://www.irobot.com/roomba). The binding has been developed and tested with Roomba 930.\n+- iRobot Braava has also been reported to (partially) work. Automatic configuration and password retrieval does\n+not work. Add the robot manually as Roomba. and use external tools (like Dorita980) in order to retrieve the\n+password.\n+\n+## Discovery\n+\n+Roombas on the same network will be discovered automatically, however in order to connect to them a password is needed. The\n+password is a machine-generated string, which is unfortunately not exposed by the original iRobot smartphone application, but\n+it can be downloaded from the robot itself. If no password is configured, the Thing enters \"CONFIGURATION PENDING\" state.\n+Now you need to perform authorization by pressing and holding the HOME button on your robot until it plays series of tones\n+(approximately 2 seconds). The Wi-Fi indicator on the robot will flash for 30 seconds, the binding should automatically\n+receive the password and go ONLINE.\n+\n+After you've done this procedure you can write the password somewhere in case if you need to reconfigure your binding. It's not\n+known, however, whether the password is eternal or can change during factory reset.\n+\n+## Thing Configuration\n+\n+\n+| Parameter | Meaning                                |\n+|-----------|----------------------------------------|\n+| ipaddress | IP address (or hostname) of your robot |\n+| password  | Password for the robot                 |\n+\n+## Channels\n+\n+| channel       | type   | description                                        | Read-only |\n+|---------------|--------|----------------------------------------------------|-----------|\n+| command       | String | Command to execute: clean, spot, dock, pause, stop | N |\n+| cycle         | String | Current mission: none, clean, spot                 | Y |\n+| phase         | String | Current phase of the mission; see below.           | Y |\n+| battery       | Number | Battery charge in percents                         | Y |\n+| bin           | String | Bin status: ok, removed, full                      | Y |\n+| error         | String | Error code; see below                              | Y |\n+| rssi          | Number | Wi-Fi Received Signal Strength indicator in db     | Y |\n+| snr           | Number | Wi-Fi Signal to noise ratio                        | Y |\n+| sched_mon     | Switch | Scheduled clean enabled for Monday                 | N |\n+| sched_tue     | Switch | Scheduled clean enabled for Tuesday                | N |\n+| sched_wed     | Switch | Scheduled clean enabled for Wednesday              | N |\n+| sched_thu     | Switch | Scheduled clean enabled for Thursday               | N |\n+| sched_fri     | Switch | Scheduled clean enabled for Friday                 | N |\n+| sched_sat     | Switch | Scheduled clean enabled for Saturday               | N |\n+| sched_sun     | Switch | Scheduled clean enabled for Sunday                 | N |\n+| schedule      | Number | Schedule bitmask for use in scripts. 7 bits, bit #0 corresponds to Sunday | N |\n+| edge_clean    | Switch | Seek out and clean along walls and furniture legs  | N |\n+| always_finish | Switch | Whether to keep cleaning if the bin becomes full   | N |\n+| power_boost   | String | Power boost mode: \"auto\", \"performance\", \"eco\"     | N |\n+| clean_passes  | String | Number of cleaning passes: \"auto\", \"1\", \"2\"        | N |\n+\n+Known phase strings and their meanings:\n+\n+| phase     | Meaning                           |\n+|-----------|-----------------------------------|\n+| charge    | Charging                          |\n+| new       | New Mission (*)                   |\n+| run       | Running                           |\n+| resume    | Resumed (*)                       |\n+| hmMidMsn  | Going for recharge during mission |\n+| recharge  | Recharging                        |\n+| stuck     | Stuck                             |\n+| mUsrDock  | Going home (on user command)      |\n+| dock      | Docking (*)                       |\n+| dockend   | Docking - End Mission (*)         |\n+| cancelled | Cancelled (*)                     |\n+| stop      | Stopped                           |\n+| pause     | Paused (*)                        |\n+| hmPostMsn | Going home after mission          |\n+| \"\" (empty string) | None (*)                  |\n+\n+Phases, marked with asterisk (*), have not been seen being reported by Roomba 930. All the definitions\n+are taken from Roomba980-Python.\n+\n+Error codes. Data type is string in order to be able to utilize mapping to human-readable strings.\n+\n+| Code | Meaning                    |\n+|------|----------------------------|\n+| 0    | None                       |\n+| 1    | Left wheel off floor       |\n+| 2    | Main Brushes stuck         |\n+| 3    | Right wheel off floor      |\n+| 4    | Left wheel stuck           |\n+| 5    | Right wheel stuck          |\n+| 6    | Stuck near a cliff         |\n+| 7    | Left wheel error           |\n+| 8    | Bin error                  |\n+| 9    | Bumper stuck               |\n+| 10    | Right wheel error         |\n+| 11    | Bin error                 |\n+| 12    | Cliff sensor issue        |\n+| 13    | Both wheels off floor     |\n+| 14    | Bin missing               |\n+| 15    | Reboot required           |\n+| 16    | Bumped unexpectedly       |\n+| 17    | Path blocked              |\n+| 18    | Docking issue             |\n+| 19    | Undocking issue           |\n+| 20    | Docking issue             |\n+| 21    | Navigation problem        |\n+| 22    | Navigation problem        | \n+| 23    | Battery issue             |\n+| 24    | Navigation problem        |\n+| 25    | Reboot required           |\n+| 26    | Vacuum problem            |\n+| 27    | Vacuum problem            |\n+| 29    | Software update needed    |\n+| 30    | Vacuum problem            |\n+| 31    | Reboot required           |\n+| 32    | Smart map problem         |\n+| 33    | Path blocked              |\n+| 34    | Reboot required           |\n+| 35    | Unrecognized cleaning pad |\n+| 36    | Bin full                  |\n+| 37    | Tank needed refilling     |\n+| 38    | Vacuum problem            |\n+| 39    | Reboot required           |\n+| 40    | Navigation problem        |\n+| 41    | Timed out                 |\n+| 42    | Localization problem      |\n+| 43    | Navigation problem        |\n+| 44    | Pump issue                |\n+| 45    | Lid open                  |\n+| 46    | Low battery               |\n+| 47    | Reboot required           |\n+| 48    | Path blocked              |\n+| 52    | Pad required attention    |\n+| 65    | Hardware problem detected |\n+| 66    | Low memory                |\n+| 68    | Hardware problem detected |\n+| 73    | Pad type changed          |\n+| 74    | Max area reached          |\n+| 75    | Navigation problem        |\n+| 76    | Hardware problem detected |\n+\n+## Known problems / caveats", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "12d1bc627f38ece34b5c0c2b3390787e69ad0cfd"}, "originalPosition": 142}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MTk0NzA2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/discovery/IRobotDiscoveryService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxNToyNToxNlrOHuyd4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxNToyNToxNlrOHuyd4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODgyMzM5NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            @Component(service = DiscoveryService.class)\n          \n          \n            \n            @Component(service = DiscoveryService.class, configurationPid = \"discovery.irobot\")", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r518823394", "createdAt": "2020-11-06T15:25:16Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/discovery/IRobotDiscoveryService.java", "diffHunk": "@@ -0,0 +1,161 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.discovery;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.IRobotBindingConstants;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.net.NetUtil;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * Discovery service for iRobots\n+ *\n+ * @author Pavel Fedin - Initial contribution\n+ *\n+ */\n+@Component(service = DiscoveryService.class)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "12d1bc627f38ece34b5c0c2b3390787e69ad0cfd"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4MzYzODQ3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNVQxMDoxNzoxMlrOHzeb1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxNzo0NTo1OFrOH1BdKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzczODA3MA==", "bodyText": "This sould be warn. You could also throw an unchecked exception like IllegalStateException if it's strange this would happen.", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r523738070", "createdAt": "2020-11-15T10:17:12Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "diffHunk": "@@ -503,4 +529,49 @@ private void reportProperty(String property, @Nullable String value) {\n             updateProperty(property, value);\n         }\n     }\n+\n+    @Override\n+    public void connectionStateChanged(MqttConnectionState state, @Nullable Throwable error) {\n+        if (state == MqttConnectionState.CONNECTED) {\n+            MqttBrokerConnection connection = this.connection;\n+\n+            if (connection == null) {\n+                // This would be very strange, but Eclipse forces us to do the check\n+                logger.error(\"Established connection without broker pointer\");\n+                return;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4657b930609f82d8ce25bb94ccb32b9c8c9eb7a2"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM2MDQyNA==", "bodyText": "Done", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r525360424", "createdAt": "2020-11-17T17:45:58Z", "author": {"login": "Sonic-Amiga"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "diffHunk": "@@ -503,4 +529,49 @@ private void reportProperty(String property, @Nullable String value) {\n             updateProperty(property, value);\n         }\n     }\n+\n+    @Override\n+    public void connectionStateChanged(MqttConnectionState state, @Nullable Throwable error) {\n+        if (state == MqttConnectionState.CONNECTED) {\n+            MqttBrokerConnection connection = this.connection;\n+\n+            if (connection == null) {\n+                // This would be very strange, but Eclipse forces us to do the check\n+                logger.error(\"Established connection without broker pointer\");\n+                return;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzczODA3MA=="}, "originalCommit": {"oid": "4657b930609f82d8ce25bb94ccb32b9c8c9eb7a2"}, "originalPosition": 130}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4MzYzODY0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNVQxMDoxNzozNFrOHzeb7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxNzo0NjoyMFrOH1BeDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzczODA5NA==", "bodyText": "This is already logged by the framework and could be removed.", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r523738094", "createdAt": "2020-11-15T10:17:34Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "diffHunk": "@@ -503,4 +529,49 @@ private void reportProperty(String property, @Nullable String value) {\n             updateProperty(property, value);\n         }\n     }\n+\n+    @Override\n+    public void connectionStateChanged(MqttConnectionState state, @Nullable Throwable error) {\n+        if (state == MqttConnectionState.CONNECTED) {\n+            MqttBrokerConnection connection = this.connection;\n+\n+            if (connection == null) {\n+                // This would be very strange, but Eclipse forces us to do the check\n+                logger.error(\"Established connection without broker pointer\");\n+                return;\n+            }\n+\n+            logger.debug(\"Connection established\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4657b930609f82d8ce25bb94ccb32b9c8c9eb7a2"}, "originalPosition": 133}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM2MDY1NA==", "bodyText": "Forgot, sorry", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r525360654", "createdAt": "2020-11-17T17:46:20Z", "author": {"login": "Sonic-Amiga"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "diffHunk": "@@ -503,4 +529,49 @@ private void reportProperty(String property, @Nullable String value) {\n             updateProperty(property, value);\n         }\n     }\n+\n+    @Override\n+    public void connectionStateChanged(MqttConnectionState state, @Nullable Throwable error) {\n+        if (state == MqttConnectionState.CONNECTED) {\n+            MqttBrokerConnection connection = this.connection;\n+\n+            if (connection == null) {\n+                // This would be very strange, but Eclipse forces us to do the check\n+                logger.error(\"Established connection without broker pointer\");\n+                return;\n+            }\n+\n+            logger.debug(\"Connection established\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzczODA5NA=="}, "originalCommit": {"oid": "4657b930609f82d8ce25bb94ccb32b9c8c9eb7a2"}, "originalPosition": 133}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4MzYzODcxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNVQxMDoxNzo1M1rOHzeb-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxNzo0NzoyN1rOH1Bg6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzczODEwNA==", "bodyText": "Can this be removed?", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r523738104", "createdAt": "2020-11-15T10:17:53Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "diffHunk": "@@ -503,4 +529,49 @@ private void reportProperty(String property, @Nullable String value) {\n             updateProperty(property, value);\n         }\n     }\n+\n+    @Override\n+    public void connectionStateChanged(MqttConnectionState state, @Nullable Throwable error) {\n+        if (state == MqttConnectionState.CONNECTED) {\n+            MqttBrokerConnection connection = this.connection;\n+\n+            if (connection == null) {\n+                // This would be very strange, but Eclipse forces us to do the check\n+                logger.error(\"Established connection without broker pointer\");\n+                return;\n+            }\n+\n+            logger.debug(\"Connection established\");\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            // Roomba sends us two topics:\n+            // \"wifistat\" - reports singnal strength and current robot position\n+            // \"$aws/things/<BLID>/shadow/update\" - the rest of messages\n+            // Subscribe to everything since we're interested in both\n+            connection.subscribe(\"#\", this).exceptionally(e -> {\n+                logger.warn(\"MQTT subscription failed: {}\", e.getMessage());\n+                return false;\n+            }).thenAccept(v -> {\n+                if (!v) {\n+                    logger.warn(\"Subscription timeout\");\n+                } else {\n+                    logger.trace(\"Subscription done\");\n+                }\n+            });\n+\n+        } else {\n+            // channelStateByChannelUID.values().forEach(c -> c.stop());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4657b930609f82d8ce25bb94ccb32b9c8c9eb7a2"}, "originalPosition": 152}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM2MTM4Ng==", "bodyText": "Yep, overlook, thanks", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r525361386", "createdAt": "2020-11-17T17:47:27Z", "author": {"login": "Sonic-Amiga"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "diffHunk": "@@ -503,4 +529,49 @@ private void reportProperty(String property, @Nullable String value) {\n             updateProperty(property, value);\n         }\n     }\n+\n+    @Override\n+    public void connectionStateChanged(MqttConnectionState state, @Nullable Throwable error) {\n+        if (state == MqttConnectionState.CONNECTED) {\n+            MqttBrokerConnection connection = this.connection;\n+\n+            if (connection == null) {\n+                // This would be very strange, but Eclipse forces us to do the check\n+                logger.error(\"Established connection without broker pointer\");\n+                return;\n+            }\n+\n+            logger.debug(\"Connection established\");\n+            updateStatus(ThingStatus.ONLINE);\n+\n+            // Roomba sends us two topics:\n+            // \"wifistat\" - reports singnal strength and current robot position\n+            // \"$aws/things/<BLID>/shadow/update\" - the rest of messages\n+            // Subscribe to everything since we're interested in both\n+            connection.subscribe(\"#\", this).exceptionally(e -> {\n+                logger.warn(\"MQTT subscription failed: {}\", e.getMessage());\n+                return false;\n+            }).thenAccept(v -> {\n+                if (!v) {\n+                    logger.warn(\"Subscription timeout\");\n+                } else {\n+                    logger.trace(\"Subscription done\");\n+                }\n+            });\n+\n+        } else {\n+            // channelStateByChannelUID.values().forEach(c -> c.stop());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzczODEwNA=="}, "originalCommit": {"oid": "4657b930609f82d8ce25bb94ccb32b9c8c9eb7a2"}, "originalPosition": 152}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4MzY0NTc3OnYy", "diffSide": "LEFT", "path": "bundles/org.openhab.binding.irobot/src/main/feature/feature.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNVQxMDoyNTo0NFrOHzefZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QxNzo1MDowMlrOH1BtCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzczODk4Mw==", "bodyText": "You need to add <feature>openhab-transport-mqtt</feature>. This is why the build fails.", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r523738983", "createdAt": "2020-11-15T10:25:44Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.irobot/src/main/feature/feature.xml", "diffHunk": "@@ -18,7 +18,6 @@\n \n \t<feature name=\"openhab-binding-irobot\" description=\"iRobot Binding\" version=\"${project.version}\">\n \t\t<feature>openhab-runtime-base</feature>\n-\t\t<feature dependency=\"true\">openhab.tp-hivemqclient</feature>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4657b930609f82d8ce25bb94ccb32b9c8c9eb7a2"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTM2NDQ5MA==", "bodyText": "Thank you for the hint, fixed", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r525364490", "createdAt": "2020-11-17T17:50:02Z", "author": {"login": "Sonic-Amiga"}, "path": "bundles/org.openhab.binding.irobot/src/main/feature/feature.xml", "diffHunk": "@@ -18,7 +18,6 @@\n \n \t<feature name=\"openhab-binding-irobot\" description=\"iRobot Binding\" version=\"${project.version}\">\n \t\t<feature>openhab-runtime-base</feature>\n-\t\t<feature dependency=\"true\">openhab.tp-hivemqclient</feature>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzczODk4Mw=="}, "originalCommit": {"oid": "4657b930609f82d8ce25bb94ccb32b9c8c9eb7a2"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwNTE0OTA1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxOToxNTo0NlrOH2tygA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxODo1ODo1OFrOH6AYSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzEzNTM2MA==", "bodyText": "Please see all others.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * @author Pavel Fedin <pavel_fedin@mail.ru> - Rewrite for 900 series\n          \n          \n            \n             * @author Pavel Fedin - Rewrite for 900 series", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r527135360", "createdAt": "2020-11-19T19:15:46Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "diffHunk": "@@ -0,0 +1,575 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.handler;\n+\n+import static org.openhab.binding.irobot.IRobotBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Hashtable;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.internal.MQTTProtocol;\n+import org.openhab.binding.irobot.internal.RawMQTT;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.io.transport.mqtt.MqttBrokerConnection;\n+import org.openhab.core.io.transport.mqtt.MqttConnectionObserver;\n+import org.openhab.core.io.transport.mqtt.MqttConnectionState;\n+import org.openhab.core.io.transport.mqtt.MqttMessageSubscriber;\n+import org.openhab.core.io.transport.mqtt.reconnect.PeriodicReconnectStrategy;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The {@link RoombaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author hkuhn42 - Initial contribution\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Rewrite for 900 series", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38e4469938e548437db8ccdab906544545c70c9d"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU4NTY3Mg==", "bodyText": "Done", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r530585672", "createdAt": "2020-11-25T18:58:58Z", "author": {"login": "Sonic-Amiga"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "diffHunk": "@@ -0,0 +1,575 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.handler;\n+\n+import static org.openhab.binding.irobot.IRobotBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Hashtable;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.internal.MQTTProtocol;\n+import org.openhab.binding.irobot.internal.RawMQTT;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.io.transport.mqtt.MqttBrokerConnection;\n+import org.openhab.core.io.transport.mqtt.MqttConnectionObserver;\n+import org.openhab.core.io.transport.mqtt.MqttConnectionState;\n+import org.openhab.core.io.transport.mqtt.MqttMessageSubscriber;\n+import org.openhab.core.io.transport.mqtt.reconnect.PeriodicReconnectStrategy;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The {@link RoombaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author hkuhn42 - Initial contribution\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Rewrite for 900 series", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzEzNTM2MA=="}, "originalCommit": {"oid": "38e4469938e548437db8ccdab906544545c70c9d"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwNTE2Mzg1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxOToxOTo1MFrOH2t70g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxODo1OTowN1rOH6AYhA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzEzNzc0Ng==", "bodyText": "Please use camelCase.", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r527137746", "createdAt": "2020-11-19T19:19:50Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "diffHunk": "@@ -0,0 +1,575 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.handler;\n+\n+import static org.openhab.binding.irobot.IRobotBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Hashtable;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.internal.MQTTProtocol;\n+import org.openhab.binding.irobot.internal.RawMQTT;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.io.transport.mqtt.MqttBrokerConnection;\n+import org.openhab.core.io.transport.mqtt.MqttConnectionObserver;\n+import org.openhab.core.io.transport.mqtt.MqttConnectionState;\n+import org.openhab.core.io.transport.mqtt.MqttMessageSubscriber;\n+import org.openhab.core.io.transport.mqtt.reconnect.PeriodicReconnectStrategy;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The {@link RoombaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author hkuhn42 - Initial contribution\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Rewrite for 900 series\n+ */\n+@NonNullByDefault\n+public class RoombaHandler extends BaseThingHandler implements MqttConnectionObserver, MqttMessageSubscriber {\n+    private final Logger logger = LoggerFactory.getLogger(RoombaHandler.class);\n+    private final Gson gson = new Gson();\n+    private static final int RECONNECT_DELAY_SEC = 5; // In seconds\n+    private @Nullable Future<?> reconnectReq;\n+    // Dummy RoombaConfiguration object in order to shut up Eclipse warnings\n+    // The real one is set in initialize()\n+    private RoombaConfiguration config = new RoombaConfiguration();\n+    private @Nullable String blid = null;\n+    private @Nullable MqttBrokerConnection connection;\n+    private Hashtable<String, State> lastState = new Hashtable<>();\n+    private MQTTProtocol.@Nullable Schedule lastSchedule = null;\n+    private boolean autoPasses = true;\n+    private @Nullable Boolean two_passes = null;\n+    private boolean carpet_boost = true;\n+    private @Nullable Boolean vac_high = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38e4469938e548437db8ccdab906544545c70c9d"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU4NTczMg==", "bodyText": "Yep", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r530585732", "createdAt": "2020-11-25T18:59:07Z", "author": {"login": "Sonic-Amiga"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "diffHunk": "@@ -0,0 +1,575 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.handler;\n+\n+import static org.openhab.binding.irobot.IRobotBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Hashtable;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.internal.MQTTProtocol;\n+import org.openhab.binding.irobot.internal.RawMQTT;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.io.transport.mqtt.MqttBrokerConnection;\n+import org.openhab.core.io.transport.mqtt.MqttConnectionObserver;\n+import org.openhab.core.io.transport.mqtt.MqttConnectionState;\n+import org.openhab.core.io.transport.mqtt.MqttMessageSubscriber;\n+import org.openhab.core.io.transport.mqtt.reconnect.PeriodicReconnectStrategy;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The {@link RoombaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author hkuhn42 - Initial contribution\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Rewrite for 900 series\n+ */\n+@NonNullByDefault\n+public class RoombaHandler extends BaseThingHandler implements MqttConnectionObserver, MqttMessageSubscriber {\n+    private final Logger logger = LoggerFactory.getLogger(RoombaHandler.class);\n+    private final Gson gson = new Gson();\n+    private static final int RECONNECT_DELAY_SEC = 5; // In seconds\n+    private @Nullable Future<?> reconnectReq;\n+    // Dummy RoombaConfiguration object in order to shut up Eclipse warnings\n+    // The real one is set in initialize()\n+    private RoombaConfiguration config = new RoombaConfiguration();\n+    private @Nullable String blid = null;\n+    private @Nullable MqttBrokerConnection connection;\n+    private Hashtable<String, State> lastState = new Hashtable<>();\n+    private MQTTProtocol.@Nullable Schedule lastSchedule = null;\n+    private boolean autoPasses = true;\n+    private @Nullable Boolean two_passes = null;\n+    private boolean carpet_boost = true;\n+    private @Nullable Boolean vac_high = null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzEzNzc0Ng=="}, "originalCommit": {"oid": "38e4469938e548437db8ccdab906544545c70c9d"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMwNTMwMTA1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xOVQxOTo1NTowMlrOH2vOzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQxODo1OToxNlrOH6AY0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE1ODk5MA==", "bodyText": "The compiler warning can be avoided by storing the reference to a local variable and do the null check on that. Same for below.", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r527158990", "createdAt": "2020-11-19T19:55:02Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "diffHunk": "@@ -0,0 +1,575 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.handler;\n+\n+import static org.openhab.binding.irobot.IRobotBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Hashtable;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.internal.MQTTProtocol;\n+import org.openhab.binding.irobot.internal.RawMQTT;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.io.transport.mqtt.MqttBrokerConnection;\n+import org.openhab.core.io.transport.mqtt.MqttConnectionObserver;\n+import org.openhab.core.io.transport.mqtt.MqttConnectionState;\n+import org.openhab.core.io.transport.mqtt.MqttMessageSubscriber;\n+import org.openhab.core.io.transport.mqtt.reconnect.PeriodicReconnectStrategy;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The {@link RoombaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author hkuhn42 - Initial contribution\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Rewrite for 900 series\n+ */\n+@NonNullByDefault\n+public class RoombaHandler extends BaseThingHandler implements MqttConnectionObserver, MqttMessageSubscriber {\n+    private final Logger logger = LoggerFactory.getLogger(RoombaHandler.class);\n+    private final Gson gson = new Gson();\n+    private static final int RECONNECT_DELAY_SEC = 5; // In seconds\n+    private @Nullable Future<?> reconnectReq;\n+    // Dummy RoombaConfiguration object in order to shut up Eclipse warnings\n+    // The real one is set in initialize()\n+    private RoombaConfiguration config = new RoombaConfiguration();\n+    private @Nullable String blid = null;\n+    private @Nullable MqttBrokerConnection connection;\n+    private Hashtable<String, State> lastState = new Hashtable<>();\n+    private MQTTProtocol.@Nullable Schedule lastSchedule = null;\n+    private boolean autoPasses = true;\n+    private @Nullable Boolean two_passes = null;\n+    private boolean carpet_boost = true;\n+    private @Nullable Boolean vac_high = null;\n+    private boolean isPaused = false;\n+\n+    public RoombaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(RoombaConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.execute(() -> {\n+            connect();\n+        });\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        scheduler.execute(() -> {\n+            disconnect();\n+        });\n+    }\n+\n+    // lastState.get() can return null if the key is not found according\n+    // to the documentation\n+    @SuppressWarnings(\"null\")\n+    private void handleRefresh(String ch) {\n+        State value = lastState.get(ch);\n+\n+        if (value != null) {\n+            updateState(ch, value);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String ch = channelUID.getId();\n+        if (command instanceof RefreshType) {\n+            handleRefresh(ch);\n+            return;\n+        }\n+\n+        if (ch.equals(CHANNEL_COMMAND)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+\n+                if (cmd.equals(CMD_CLEAN)) {\n+                    cmd = isPaused ? \"resume\" : \"start\";\n+                }\n+\n+                sendRequest(new MQTTProtocol.CommandRequest(cmd));\n+            }\n+        } else if (ch.startsWith(CHANNEL_SCHED_SWITCH_PREFIX)) {\n+            MQTTProtocol.Schedule schedule = lastSchedule;\n+\n+            // Schedule can only be updated in a bulk, so we have to store current\n+            // schedule and modify components.\n+            if (command instanceof OnOffType && schedule != null && schedule.cycle != null) {\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    if (ch.equals(CHANNEL_SCHED_SWITCH[i])) {\n+                        MQTTProtocol.Schedule newSchedule = new MQTTProtocol.Schedule(schedule.cycle);\n+\n+                        newSchedule.enableCycle(i, command.equals(OnOffType.ON));\n+                        sendSchedule(newSchedule);\n+                        break;\n+                    }\n+                }\n+            }\n+        } else if (ch.equals(CHANNEL_SCHEDULE)) {\n+            if (command instanceof DecimalType) {\n+                int bitmask = ((DecimalType) command).intValue();\n+                JsonArray cycle = new JsonArray();\n+\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    enableCycle(cycle, i, (bitmask & (1 << i)) != 0);\n+                }\n+\n+                sendSchedule(new MQTTProtocol.Schedule(bitmask));\n+            }\n+        } else if (ch.equals(CHANNEL_EDGE_CLEAN)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.OpenOnly(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_ALWAYS_FINISH)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.BinPause(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_POWER_BOOST)) {\n+            sendDelta(new MQTTProtocol.PowerBoost(command.equals(BOOST_AUTO), command.equals(BOOST_PERFORMANCE)));\n+        } else if (ch.equals(CHANNEL_CLEAN_PASSES)) {\n+            sendDelta(new MQTTProtocol.CleanPasses(!command.equals(PASSES_AUTO), command.equals(PASSES_2)));\n+        }\n+    }\n+\n+    private void enableCycle(JsonArray cycle, int i, boolean enable) {\n+        JsonPrimitive value = new JsonPrimitive(enable ? \"start\" : \"none\");\n+        cycle.set(i, value);\n+    }\n+\n+    private void sendSchedule(MQTTProtocol.Schedule schedule) {\n+        sendDelta(new MQTTProtocol.CleanSchedule(schedule));\n+    }\n+\n+    private void sendDelta(MQTTProtocol.StateValue state) {\n+        sendRequest(new MQTTProtocol.DeltaRequest(state));\n+    }\n+\n+    private void sendRequest(MQTTProtocol.Request request) {\n+        MqttBrokerConnection conn = connection;\n+\n+        if (conn != null) {\n+            String json = gson.toJson(request);\n+            logger.trace(\"Sending {}: {}\", request.getTopic(), json);\n+            // 1 here actually corresponds to MQTT qos 0 (AT_MOST_ONCE). Only this value is accepted\n+            // by Roomba, others just cause it to reject the command and drop the connection.\n+            conn.publish(request.getTopic(), json.getBytes(), 1, false);\n+        }\n+    }\n+\n+    // In order not to mess up our connection state we need to make sure\n+    // that connect() and disconnect() are never running concurrently, so\n+    // they are synchronized\n+    private synchronized void connect() {\n+        logger.debug(\"Connecting to {}\", config.ipaddress);\n+\n+        try {\n+            InetAddress host = InetAddress.getByName(config.ipaddress);\n+            String blid = this.blid;\n+\n+            if (blid == null) {\n+                DatagramSocket identSocket = IdentProtocol.sendRequest(host);\n+                DatagramPacket identPacket = IdentProtocol.receiveResponse(identSocket);\n+                IdentProtocol.IdentData ident;\n+\n+                identSocket.close();\n+\n+                try {\n+                    ident = IdentProtocol.decodeResponse(identPacket);\n+                } catch (JsonParseException e) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Malformed IDENT response\");\n+                    return;\n+                }\n+\n+                if (ident.ver < IdentData.MIN_SUPPORTED_VERSION) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                            \"Unsupported version \" + ident.ver);\n+                    return;\n+                }\n+\n+                if (!ident.product.equals(IdentData.PRODUCT_ROOMBA)) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                            \"Not a Roomba: \" + ident.product);\n+                    return;\n+                }\n+\n+                blid = ident.blid;\n+                this.blid = blid;\n+            }\n+\n+            logger.debug(\"BLID is: {}\", blid);\n+\n+            if (config.password.isEmpty()) {\n+                RawMQTT mqtt;\n+\n+                try {\n+                    mqtt = new RawMQTT(host, 8883);\n+                } catch (KeyManagementException | NoSuchAlgorithmException e1) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e1.toString());\n+                    return; // This is internal system error, no retry\n+                }\n+\n+                mqtt.requestPassword();\n+                RawMQTT.Packet response = mqtt.readPacket();\n+                mqtt.close();\n+\n+                if (response != null && response.isValidPasswdPacket()) {\n+                    RawMQTT.PasswdPacket passwdPacket = new RawMQTT.PasswdPacket(response);\n+                    String password = passwdPacket.getPassword();\n+\n+                    if (password != null) {\n+                        config.password = password;\n+\n+                        Configuration configuration = editConfiguration();\n+\n+                        configuration.put(\"password\", password);\n+                        updateConfiguration(configuration);\n+\n+                        logger.debug(\"Password successfully retrieved\");\n+                    }\n+                }\n+            }\n+\n+            if (config.password.isEmpty()) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING,\n+                        \"Authentication on the robot is required\");\n+                scheduleReconnect();\n+                return;\n+            }\n+\n+            // BLID is used as both client ID and username. The name of BLID also came from Roomba980-python\n+            MqttBrokerConnection connection = new MqttBrokerConnection(config.ipaddress, RawMQTT.ROOMBA_MQTT_PORT, true,\n+                    blid);\n+\n+            this.connection = connection;\n+\n+            // Disable sending UNSUBSCRIBE request before disconnecting becuase Roomba doesn't like it.\n+            // It just swallows the request and never sends any response, so stop() method never completes.\n+            connection.setUnsubscribeOnStop(false);\n+            connection.setCredentials(blid, config.password);\n+            connection.setTrustManagers(RawMQTT.getTrustManagers());\n+            // 1 here actually corresponds to MQTT qos 0 (AT_MOST_ONCE). Only this value is accepted\n+            // by Roomba, others just cause it to reject the command and drop the connection.\n+            connection.setQos(1);\n+            // MQTT connection reconnects itself, so we don't have to call scheduleReconnect()\n+            // when it breaks. Just set the period in ms.\n+            connection.setReconnectStrategy(\n+                    new PeriodicReconnectStrategy(RECONNECT_DELAY_SEC * 1000, RECONNECT_DELAY_SEC * 1000));\n+            connection.start().exceptionally(e -> {\n+                connectionStateChanged(MqttConnectionState.DISCONNECTED, e);\n+                return false;\n+            }).thenAccept(v -> {\n+                if (!v) {\n+                    connectionStateChanged(MqttConnectionState.DISCONNECTED, new TimeoutException(\"Timeout\"));\n+                } else {\n+                    connectionStateChanged(MqttConnectionState.CONNECTED, null);\n+                }\n+            });\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            scheduleReconnect();\n+        }\n+    }\n+\n+    private synchronized void disconnect() {\n+        if (reconnectReq != null) {\n+            reconnectReq.cancel(false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38e4469938e548437db8ccdab906544545c70c9d"}, "originalPosition": 322}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDU4NTgwOA==", "bodyText": "ACK", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r530585808", "createdAt": "2020-11-25T18:59:16Z", "author": {"login": "Sonic-Amiga"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/handler/RoombaHandler.java", "diffHunk": "@@ -0,0 +1,575 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.handler;\n+\n+import static org.openhab.binding.irobot.IRobotBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Hashtable;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.internal.MQTTProtocol;\n+import org.openhab.binding.irobot.internal.RawMQTT;\n+import org.openhab.binding.irobot.roomba.RoombaConfiguration;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.io.transport.mqtt.MqttBrokerConnection;\n+import org.openhab.core.io.transport.mqtt.MqttConnectionObserver;\n+import org.openhab.core.io.transport.mqtt.MqttConnectionState;\n+import org.openhab.core.io.transport.mqtt.MqttMessageSubscriber;\n+import org.openhab.core.io.transport.mqtt.reconnect.PeriodicReconnectStrategy;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The {@link RoombaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author hkuhn42 - Initial contribution\n+ * @author Pavel Fedin <pavel_fedin@mail.ru> - Rewrite for 900 series\n+ */\n+@NonNullByDefault\n+public class RoombaHandler extends BaseThingHandler implements MqttConnectionObserver, MqttMessageSubscriber {\n+    private final Logger logger = LoggerFactory.getLogger(RoombaHandler.class);\n+    private final Gson gson = new Gson();\n+    private static final int RECONNECT_DELAY_SEC = 5; // In seconds\n+    private @Nullable Future<?> reconnectReq;\n+    // Dummy RoombaConfiguration object in order to shut up Eclipse warnings\n+    // The real one is set in initialize()\n+    private RoombaConfiguration config = new RoombaConfiguration();\n+    private @Nullable String blid = null;\n+    private @Nullable MqttBrokerConnection connection;\n+    private Hashtable<String, State> lastState = new Hashtable<>();\n+    private MQTTProtocol.@Nullable Schedule lastSchedule = null;\n+    private boolean autoPasses = true;\n+    private @Nullable Boolean two_passes = null;\n+    private boolean carpet_boost = true;\n+    private @Nullable Boolean vac_high = null;\n+    private boolean isPaused = false;\n+\n+    public RoombaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(RoombaConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.execute(() -> {\n+            connect();\n+        });\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        scheduler.execute(() -> {\n+            disconnect();\n+        });\n+    }\n+\n+    // lastState.get() can return null if the key is not found according\n+    // to the documentation\n+    @SuppressWarnings(\"null\")\n+    private void handleRefresh(String ch) {\n+        State value = lastState.get(ch);\n+\n+        if (value != null) {\n+            updateState(ch, value);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String ch = channelUID.getId();\n+        if (command instanceof RefreshType) {\n+            handleRefresh(ch);\n+            return;\n+        }\n+\n+        if (ch.equals(CHANNEL_COMMAND)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+\n+                if (cmd.equals(CMD_CLEAN)) {\n+                    cmd = isPaused ? \"resume\" : \"start\";\n+                }\n+\n+                sendRequest(new MQTTProtocol.CommandRequest(cmd));\n+            }\n+        } else if (ch.startsWith(CHANNEL_SCHED_SWITCH_PREFIX)) {\n+            MQTTProtocol.Schedule schedule = lastSchedule;\n+\n+            // Schedule can only be updated in a bulk, so we have to store current\n+            // schedule and modify components.\n+            if (command instanceof OnOffType && schedule != null && schedule.cycle != null) {\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    if (ch.equals(CHANNEL_SCHED_SWITCH[i])) {\n+                        MQTTProtocol.Schedule newSchedule = new MQTTProtocol.Schedule(schedule.cycle);\n+\n+                        newSchedule.enableCycle(i, command.equals(OnOffType.ON));\n+                        sendSchedule(newSchedule);\n+                        break;\n+                    }\n+                }\n+            }\n+        } else if (ch.equals(CHANNEL_SCHEDULE)) {\n+            if (command instanceof DecimalType) {\n+                int bitmask = ((DecimalType) command).intValue();\n+                JsonArray cycle = new JsonArray();\n+\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    enableCycle(cycle, i, (bitmask & (1 << i)) != 0);\n+                }\n+\n+                sendSchedule(new MQTTProtocol.Schedule(bitmask));\n+            }\n+        } else if (ch.equals(CHANNEL_EDGE_CLEAN)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.OpenOnly(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_ALWAYS_FINISH)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.BinPause(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_POWER_BOOST)) {\n+            sendDelta(new MQTTProtocol.PowerBoost(command.equals(BOOST_AUTO), command.equals(BOOST_PERFORMANCE)));\n+        } else if (ch.equals(CHANNEL_CLEAN_PASSES)) {\n+            sendDelta(new MQTTProtocol.CleanPasses(!command.equals(PASSES_AUTO), command.equals(PASSES_2)));\n+        }\n+    }\n+\n+    private void enableCycle(JsonArray cycle, int i, boolean enable) {\n+        JsonPrimitive value = new JsonPrimitive(enable ? \"start\" : \"none\");\n+        cycle.set(i, value);\n+    }\n+\n+    private void sendSchedule(MQTTProtocol.Schedule schedule) {\n+        sendDelta(new MQTTProtocol.CleanSchedule(schedule));\n+    }\n+\n+    private void sendDelta(MQTTProtocol.StateValue state) {\n+        sendRequest(new MQTTProtocol.DeltaRequest(state));\n+    }\n+\n+    private void sendRequest(MQTTProtocol.Request request) {\n+        MqttBrokerConnection conn = connection;\n+\n+        if (conn != null) {\n+            String json = gson.toJson(request);\n+            logger.trace(\"Sending {}: {}\", request.getTopic(), json);\n+            // 1 here actually corresponds to MQTT qos 0 (AT_MOST_ONCE). Only this value is accepted\n+            // by Roomba, others just cause it to reject the command and drop the connection.\n+            conn.publish(request.getTopic(), json.getBytes(), 1, false);\n+        }\n+    }\n+\n+    // In order not to mess up our connection state we need to make sure\n+    // that connect() and disconnect() are never running concurrently, so\n+    // they are synchronized\n+    private synchronized void connect() {\n+        logger.debug(\"Connecting to {}\", config.ipaddress);\n+\n+        try {\n+            InetAddress host = InetAddress.getByName(config.ipaddress);\n+            String blid = this.blid;\n+\n+            if (blid == null) {\n+                DatagramSocket identSocket = IdentProtocol.sendRequest(host);\n+                DatagramPacket identPacket = IdentProtocol.receiveResponse(identSocket);\n+                IdentProtocol.IdentData ident;\n+\n+                identSocket.close();\n+\n+                try {\n+                    ident = IdentProtocol.decodeResponse(identPacket);\n+                } catch (JsonParseException e) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Malformed IDENT response\");\n+                    return;\n+                }\n+\n+                if (ident.ver < IdentData.MIN_SUPPORTED_VERSION) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                            \"Unsupported version \" + ident.ver);\n+                    return;\n+                }\n+\n+                if (!ident.product.equals(IdentData.PRODUCT_ROOMBA)) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                            \"Not a Roomba: \" + ident.product);\n+                    return;\n+                }\n+\n+                blid = ident.blid;\n+                this.blid = blid;\n+            }\n+\n+            logger.debug(\"BLID is: {}\", blid);\n+\n+            if (config.password.isEmpty()) {\n+                RawMQTT mqtt;\n+\n+                try {\n+                    mqtt = new RawMQTT(host, 8883);\n+                } catch (KeyManagementException | NoSuchAlgorithmException e1) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e1.toString());\n+                    return; // This is internal system error, no retry\n+                }\n+\n+                mqtt.requestPassword();\n+                RawMQTT.Packet response = mqtt.readPacket();\n+                mqtt.close();\n+\n+                if (response != null && response.isValidPasswdPacket()) {\n+                    RawMQTT.PasswdPacket passwdPacket = new RawMQTT.PasswdPacket(response);\n+                    String password = passwdPacket.getPassword();\n+\n+                    if (password != null) {\n+                        config.password = password;\n+\n+                        Configuration configuration = editConfiguration();\n+\n+                        configuration.put(\"password\", password);\n+                        updateConfiguration(configuration);\n+\n+                        logger.debug(\"Password successfully retrieved\");\n+                    }\n+                }\n+            }\n+\n+            if (config.password.isEmpty()) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING,\n+                        \"Authentication on the robot is required\");\n+                scheduleReconnect();\n+                return;\n+            }\n+\n+            // BLID is used as both client ID and username. The name of BLID also came from Roomba980-python\n+            MqttBrokerConnection connection = new MqttBrokerConnection(config.ipaddress, RawMQTT.ROOMBA_MQTT_PORT, true,\n+                    blid);\n+\n+            this.connection = connection;\n+\n+            // Disable sending UNSUBSCRIBE request before disconnecting becuase Roomba doesn't like it.\n+            // It just swallows the request and never sends any response, so stop() method never completes.\n+            connection.setUnsubscribeOnStop(false);\n+            connection.setCredentials(blid, config.password);\n+            connection.setTrustManagers(RawMQTT.getTrustManagers());\n+            // 1 here actually corresponds to MQTT qos 0 (AT_MOST_ONCE). Only this value is accepted\n+            // by Roomba, others just cause it to reject the command and drop the connection.\n+            connection.setQos(1);\n+            // MQTT connection reconnects itself, so we don't have to call scheduleReconnect()\n+            // when it breaks. Just set the period in ms.\n+            connection.setReconnectStrategy(\n+                    new PeriodicReconnectStrategy(RECONNECT_DELAY_SEC * 1000, RECONNECT_DELAY_SEC * 1000));\n+            connection.start().exceptionally(e -> {\n+                connectionStateChanged(MqttConnectionState.DISCONNECTED, e);\n+                return false;\n+            }).thenAccept(v -> {\n+                if (!v) {\n+                    connectionStateChanged(MqttConnectionState.DISCONNECTED, new TimeoutException(\"Timeout\"));\n+                } else {\n+                    connectionStateChanged(MqttConnectionState.CONNECTED, null);\n+                }\n+            });\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            scheduleReconnect();\n+        }\n+    }\n+\n+    private synchronized void disconnect() {\n+        if (reconnectReq != null) {\n+            reconnectReq.cancel(false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE1ODk5MA=="}, "originalCommit": {"oid": "38e4469938e548437db8ccdab906544545c70c9d"}, "originalPosition": 322}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyOTM2OTk0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.irobot/src/main/resources/OH-INF/binding/binding.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQwNzo1MDo0NFrOH6PRPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxODoxOTozM1rOH6kogw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDgyOTYyOA==", "bodyText": "In the meanwhile this tag has been removed from all bindings. See #9113\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t<author>Pavel Fedin</author>", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r530829628", "createdAt": "2020-11-26T07:50:44Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.irobot/src/main/resources/OH-INF/binding/binding.xml", "diffHunk": "@@ -0,0 +1,10 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<binding:binding id=\"irobot\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:binding=\"https://openhab.org/schemas/binding/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/binding/v1.0.0 https://openhab.org/schemas/binding-1.0.0.xsd\">\n+\n+\t<name>iRobot Binding</name>\n+\t<description>This is the binding for iRobot vacuum robots.</description>\n+\t<author>Pavel Fedin</author>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "09c40515b9036262a8982bfaf47f70740b4e49a2"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTE3OTY1MQ==", "bodyText": "Fixed", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r531179651", "createdAt": "2020-11-26T18:19:33Z", "author": {"login": "Sonic-Amiga"}, "path": "bundles/org.openhab.binding.irobot/src/main/resources/OH-INF/binding/binding.xml", "diffHunk": "@@ -0,0 +1,10 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<binding:binding id=\"irobot\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:binding=\"https://openhab.org/schemas/binding/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/binding/v1.0.0 https://openhab.org/schemas/binding-1.0.0.xsd\">\n+\n+\t<name>iRobot Binding</name>\n+\t<description>This is the binding for iRobot vacuum robots.</description>\n+\t<author>Pavel Fedin</author>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDgyOTYyOA=="}, "originalCommit": {"oid": "09c40515b9036262a8982bfaf47f70740b4e49a2"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzMTY3NDczOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/internal/IRobotBindingConstants.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxODozODoyMFrOH6k92g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNlQxODozODoyMFrOH6k92g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMTE4NTExNA==", "bodyText": "The SAT check complains about the order of the modifiers.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public final static ThingTypeUID THING_TYPE_ROOMBA = new ThingTypeUID(BINDING_ID, \"roomba\");\n          \n          \n            \n                public static final ThingTypeUID THING_TYPE_ROOMBA = new ThingTypeUID(BINDING_ID, \"roomba\");", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r531185114", "createdAt": "2020-11-26T18:38:20Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/internal/IRobotBindingConstants.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.internal;\n+\n+import org.openhab.core.thing.ThingTypeUID;\n+\n+/**\n+ * The {@link VacuumBinding} class defines common constants, which are\n+ * used across the whole binding.\n+ *\n+ * @author hkuhn42 - Initial contribution\n+ */\n+public class IRobotBindingConstants {\n+\n+    public static final String BINDING_ID = \"irobot\";\n+\n+    // List of all Thing Type UIDs\n+    public final static ThingTypeUID THING_TYPE_ROOMBA = new ThingTypeUID(BINDING_ID, \"roomba\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4aa3023158e1986e2bd0a015c11f9c108876486e"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzODE1MDE0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/internal/discovery/IRobotDiscoveryService.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yOVQwNDo0NjoyMFrOH7gKUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yOVQwNDo0NjoyMFrOH7gKUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjE1NDk2MQ==", "bodyText": "You should close the socket when you are done with it. An easy way to do this is to define the socket variable in a try-with-resources statement.", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r532154961", "createdAt": "2020-11-29T04:46:20Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/internal/discovery/IRobotDiscoveryService.java", "diffHunk": "@@ -0,0 +1,161 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.internal.discovery;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.net.UnknownHostException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.internal.IRobotBindingConstants;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.net.NetUtil;\n+import org.openhab.core.thing.ThingUID;\n+import org.osgi.service.component.annotations.Component;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * Discovery service for iRobots\n+ *\n+ * @author Pavel Fedin - Initial contribution\n+ *\n+ */\n+@Component(service = DiscoveryService.class, configurationPid = \"discovery.irobot\")\n+@NonNullByDefault\n+public class IRobotDiscoveryService extends AbstractDiscoveryService {\n+\n+    private final Logger logger = LoggerFactory.getLogger(IRobotDiscoveryService.class);\n+    private final Runnable scanner;\n+    private @Nullable ScheduledFuture<?> backgroundFuture;\n+\n+    public IRobotDiscoveryService() {\n+        super(Collections.singleton(IRobotBindingConstants.THING_TYPE_ROOMBA), 30, true);\n+        scanner = createScanner();\n+    }\n+\n+    @Override\n+    protected void startBackgroundDiscovery() {\n+        stopBackgroundScan();\n+        backgroundFuture = scheduler.scheduleWithFixedDelay(scanner, 0, 60, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    protected void stopBackgroundDiscovery() {\n+        stopBackgroundScan();\n+        super.stopBackgroundDiscovery();\n+    }\n+\n+    private void stopBackgroundScan() {\n+        ScheduledFuture<?> scan = backgroundFuture;\n+\n+        if (scan != null) {\n+            scan.cancel(true);\n+            backgroundFuture = null;\n+        }\n+    }\n+\n+    @Override\n+    protected void startScan() {\n+        scheduler.execute(scanner);\n+    }\n+\n+    private Runnable createScanner() {\n+        return () -> {\n+            long timestampOfLastScan = getTimestampOfLastScan();\n+            for (InetAddress broadcastAddress : getBroadcastAddresses()) {\n+                logger.debug(\"Starting broadcast for {}\", broadcastAddress.toString());\n+\n+                DatagramSocket socket;\n+                try {\n+                    socket = IdentProtocol.sendRequest(broadcastAddress);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7c151658d2d58e8306a315f18c13a3b6aa15fa5f"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzODE1MTY2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/internal/handler/RoombaHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yOVQwNDo0ODo1MFrOH7gK_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMjoxMTo0MVrOH8p1mQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjE1NTEzNA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    scheduler.execute(() -> {\n          \n          \n            \n                        disconnect();\n          \n          \n            \n                    });\n          \n          \n            \n                    scheduler.execute(this::disconnect);", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r532155134", "createdAt": "2020-11-29T04:48:50Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/internal/handler/RoombaHandler.java", "diffHunk": "@@ -0,0 +1,578 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.internal.handler;\n+\n+import static org.openhab.binding.irobot.internal.IRobotBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Hashtable;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.internal.MQTTProtocol;\n+import org.openhab.binding.irobot.internal.RawMQTT;\n+import org.openhab.binding.irobot.internal.RoombaConfiguration;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.io.transport.mqtt.MqttBrokerConnection;\n+import org.openhab.core.io.transport.mqtt.MqttConnectionObserver;\n+import org.openhab.core.io.transport.mqtt.MqttConnectionState;\n+import org.openhab.core.io.transport.mqtt.MqttMessageSubscriber;\n+import org.openhab.core.io.transport.mqtt.reconnect.PeriodicReconnectStrategy;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The {@link RoombaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author hkuhn42 - Initial contribution\n+ * @author Pavel Fedin - Rewrite for 900 series\n+ */\n+@NonNullByDefault\n+public class RoombaHandler extends BaseThingHandler implements MqttConnectionObserver, MqttMessageSubscriber {\n+    private final Logger logger = LoggerFactory.getLogger(RoombaHandler.class);\n+    private final Gson gson = new Gson();\n+    private static final int RECONNECT_DELAY_SEC = 5; // In seconds\n+    private @Nullable Future<?> reconnectReq;\n+    // Dummy RoombaConfiguration object in order to shut up Eclipse warnings\n+    // The real one is set in initialize()\n+    private RoombaConfiguration config = new RoombaConfiguration();\n+    private @Nullable String blid = null;\n+    private @Nullable MqttBrokerConnection connection;\n+    private Hashtable<String, State> lastState = new Hashtable<>();\n+    private MQTTProtocol.@Nullable Schedule lastSchedule = null;\n+    private boolean autoPasses = true;\n+    private @Nullable Boolean twoPasses = null;\n+    private boolean carpetBoost = true;\n+    private @Nullable Boolean vacHigh = null;\n+    private boolean isPaused = false;\n+\n+    public RoombaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(RoombaConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.execute(() -> {\n+            connect();\n+        });\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        scheduler.execute(() -> {\n+            disconnect();\n+        });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7c151658d2d58e8306a315f18c13a3b6aa15fa5f"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM2MjA3Mw==", "bodyText": "Done", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r533362073", "createdAt": "2020-12-01T12:11:41Z", "author": {"login": "Sonic-Amiga"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/internal/handler/RoombaHandler.java", "diffHunk": "@@ -0,0 +1,578 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.internal.handler;\n+\n+import static org.openhab.binding.irobot.internal.IRobotBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Hashtable;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.internal.MQTTProtocol;\n+import org.openhab.binding.irobot.internal.RawMQTT;\n+import org.openhab.binding.irobot.internal.RoombaConfiguration;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.io.transport.mqtt.MqttBrokerConnection;\n+import org.openhab.core.io.transport.mqtt.MqttConnectionObserver;\n+import org.openhab.core.io.transport.mqtt.MqttConnectionState;\n+import org.openhab.core.io.transport.mqtt.MqttMessageSubscriber;\n+import org.openhab.core.io.transport.mqtt.reconnect.PeriodicReconnectStrategy;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The {@link RoombaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author hkuhn42 - Initial contribution\n+ * @author Pavel Fedin - Rewrite for 900 series\n+ */\n+@NonNullByDefault\n+public class RoombaHandler extends BaseThingHandler implements MqttConnectionObserver, MqttMessageSubscriber {\n+    private final Logger logger = LoggerFactory.getLogger(RoombaHandler.class);\n+    private final Gson gson = new Gson();\n+    private static final int RECONNECT_DELAY_SEC = 5; // In seconds\n+    private @Nullable Future<?> reconnectReq;\n+    // Dummy RoombaConfiguration object in order to shut up Eclipse warnings\n+    // The real one is set in initialize()\n+    private RoombaConfiguration config = new RoombaConfiguration();\n+    private @Nullable String blid = null;\n+    private @Nullable MqttBrokerConnection connection;\n+    private Hashtable<String, State> lastState = new Hashtable<>();\n+    private MQTTProtocol.@Nullable Schedule lastSchedule = null;\n+    private boolean autoPasses = true;\n+    private @Nullable Boolean twoPasses = null;\n+    private boolean carpetBoost = true;\n+    private @Nullable Boolean vacHigh = null;\n+    private boolean isPaused = false;\n+\n+    public RoombaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(RoombaConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.execute(() -> {\n+            connect();\n+        });\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        scheduler.execute(() -> {\n+            disconnect();\n+        });", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjE1NTEzNA=="}, "originalCommit": {"oid": "7c151658d2d58e8306a315f18c13a3b6aa15fa5f"}, "originalPosition": 106}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzODE1MTc5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/internal/handler/RoombaHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yOVQwNDo0OTowN1rOH7gLDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMjoxMTo1MVrOH8p1-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjE1NTE1MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    scheduler.execute(() -> {\n          \n          \n            \n                        connect();\n          \n          \n            \n                    });\n          \n          \n            \n                    scheduler.execute(this::connect);", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r532155150", "createdAt": "2020-11-29T04:49:07Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/internal/handler/RoombaHandler.java", "diffHunk": "@@ -0,0 +1,578 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.internal.handler;\n+\n+import static org.openhab.binding.irobot.internal.IRobotBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Hashtable;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.internal.MQTTProtocol;\n+import org.openhab.binding.irobot.internal.RawMQTT;\n+import org.openhab.binding.irobot.internal.RoombaConfiguration;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.io.transport.mqtt.MqttBrokerConnection;\n+import org.openhab.core.io.transport.mqtt.MqttConnectionObserver;\n+import org.openhab.core.io.transport.mqtt.MqttConnectionState;\n+import org.openhab.core.io.transport.mqtt.MqttMessageSubscriber;\n+import org.openhab.core.io.transport.mqtt.reconnect.PeriodicReconnectStrategy;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The {@link RoombaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author hkuhn42 - Initial contribution\n+ * @author Pavel Fedin - Rewrite for 900 series\n+ */\n+@NonNullByDefault\n+public class RoombaHandler extends BaseThingHandler implements MqttConnectionObserver, MqttMessageSubscriber {\n+    private final Logger logger = LoggerFactory.getLogger(RoombaHandler.class);\n+    private final Gson gson = new Gson();\n+    private static final int RECONNECT_DELAY_SEC = 5; // In seconds\n+    private @Nullable Future<?> reconnectReq;\n+    // Dummy RoombaConfiguration object in order to shut up Eclipse warnings\n+    // The real one is set in initialize()\n+    private RoombaConfiguration config = new RoombaConfiguration();\n+    private @Nullable String blid = null;\n+    private @Nullable MqttBrokerConnection connection;\n+    private Hashtable<String, State> lastState = new Hashtable<>();\n+    private MQTTProtocol.@Nullable Schedule lastSchedule = null;\n+    private boolean autoPasses = true;\n+    private @Nullable Boolean twoPasses = null;\n+    private boolean carpetBoost = true;\n+    private @Nullable Boolean vacHigh = null;\n+    private boolean isPaused = false;\n+\n+    public RoombaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(RoombaConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.execute(() -> {\n+            connect();\n+        });", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7c151658d2d58e8306a315f18c13a3b6aa15fa5f"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM2MjE3MA==", "bodyText": "Done", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r533362170", "createdAt": "2020-12-01T12:11:51Z", "author": {"login": "Sonic-Amiga"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/internal/handler/RoombaHandler.java", "diffHunk": "@@ -0,0 +1,578 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.internal.handler;\n+\n+import static org.openhab.binding.irobot.internal.IRobotBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Hashtable;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.internal.MQTTProtocol;\n+import org.openhab.binding.irobot.internal.RawMQTT;\n+import org.openhab.binding.irobot.internal.RoombaConfiguration;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.io.transport.mqtt.MqttBrokerConnection;\n+import org.openhab.core.io.transport.mqtt.MqttConnectionObserver;\n+import org.openhab.core.io.transport.mqtt.MqttConnectionState;\n+import org.openhab.core.io.transport.mqtt.MqttMessageSubscriber;\n+import org.openhab.core.io.transport.mqtt.reconnect.PeriodicReconnectStrategy;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The {@link RoombaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author hkuhn42 - Initial contribution\n+ * @author Pavel Fedin - Rewrite for 900 series\n+ */\n+@NonNullByDefault\n+public class RoombaHandler extends BaseThingHandler implements MqttConnectionObserver, MqttMessageSubscriber {\n+    private final Logger logger = LoggerFactory.getLogger(RoombaHandler.class);\n+    private final Gson gson = new Gson();\n+    private static final int RECONNECT_DELAY_SEC = 5; // In seconds\n+    private @Nullable Future<?> reconnectReq;\n+    // Dummy RoombaConfiguration object in order to shut up Eclipse warnings\n+    // The real one is set in initialize()\n+    private RoombaConfiguration config = new RoombaConfiguration();\n+    private @Nullable String blid = null;\n+    private @Nullable MqttBrokerConnection connection;\n+    private Hashtable<String, State> lastState = new Hashtable<>();\n+    private MQTTProtocol.@Nullable Schedule lastSchedule = null;\n+    private boolean autoPasses = true;\n+    private @Nullable Boolean twoPasses = null;\n+    private boolean carpetBoost = true;\n+    private @Nullable Boolean vacHigh = null;\n+    private boolean isPaused = false;\n+\n+    public RoombaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(RoombaConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.execute(() -> {\n+            connect();\n+        });", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjE1NTE1MA=="}, "originalCommit": {"oid": "7c151658d2d58e8306a315f18c13a3b6aa15fa5f"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzODE1NTU4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/internal/IdentProtocol.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yOVQwNDo1NDo0MlrOH7gMtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMTo1NDowNVrOH8pOUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjE1NTU3Mw==", "bodyText": "Please add @NonNullByDefault", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r532155573", "createdAt": "2020-11-29T04:54:42Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/internal/IdentProtocol.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.internal;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.nio.charset.StandardCharsets;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * iRobot discovery and identification protocol\n+ *\n+ * @author Pavel Fedin - Initial contribution\n+ *\n+ */\n+public class IdentProtocol {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7c151658d2d58e8306a315f18c13a3b6aa15fa5f"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM1MjAxNg==", "bodyText": "I can't because this also applies to inner IdentData class, which is deserialized from json, and is, by your own criteria, \"data only\".\nIn fact IdentData is used as a namespace, it doesn't contain any single data field and only static functions. Does @NonNullByDefault even make sense here ?", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r533352016", "createdAt": "2020-12-01T11:54:05Z", "author": {"login": "Sonic-Amiga"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/internal/IdentProtocol.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.internal;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.nio.charset.StandardCharsets;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * iRobot discovery and identification protocol\n+ *\n+ * @author Pavel Fedin - Initial contribution\n+ *\n+ */\n+public class IdentProtocol {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjE1NTU3Mw=="}, "originalCommit": {"oid": "7c151658d2d58e8306a315f18c13a3b6aa15fa5f"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzODE1NTcyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/internal/MQTTProtocol.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yOVQwNDo1NDo1MVrOH7gMxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMTo1NDoxNVrOH8pOug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjE1NTU5MA==", "bodyText": "Please add @NonNullByDefault", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r532155590", "createdAt": "2020-11-29T04:54:51Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/internal/MQTTProtocol.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.internal;\n+\n+/**\n+ * iRobot MQTT protocol messages\n+ *\n+ * @author Pavel Fedin - Initial contribution\n+ *\n+ */\n+public class MQTTProtocol {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7c151658d2d58e8306a315f18c13a3b6aa15fa5f"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM1MjEyMg==", "bodyText": "The same as above.", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r533352122", "createdAt": "2020-12-01T11:54:15Z", "author": {"login": "Sonic-Amiga"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/internal/MQTTProtocol.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.internal;\n+\n+/**\n+ * iRobot MQTT protocol messages\n+ *\n+ * @author Pavel Fedin - Initial contribution\n+ *\n+ */\n+public class MQTTProtocol {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjE1NTU5MA=="}, "originalCommit": {"oid": "7c151658d2d58e8306a315f18c13a3b6aa15fa5f"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzODE1NjQ3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/internal/MQTTProtocol.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yOVQwNDo1NTozNVrOH7gNEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMjoxMToyOVrOH8p1KA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjE1NTY2Ng==", "bodyText": "To deal with the @NonNullByDefault warnings you can do one of three things:\n\nAdd the @NonNullByDefault to the class.\nMake sure that your class name ends in DTO\nMake sure that your class is in a package or subpackage called dto.\n\nPlease do one of the three.", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r532155666", "createdAt": "2020-11-29T04:55:35Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/internal/MQTTProtocol.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.internal;\n+\n+/**\n+ * iRobot MQTT protocol messages\n+ *\n+ * @author Pavel Fedin - Initial contribution\n+ *\n+ */\n+public class MQTTProtocol {\n+    public interface Request {\n+        public String getTopic();\n+    }\n+\n+    public static class CommandRequest implements Request {\n+        public String command;\n+        public long time;\n+        public String initiator;\n+\n+        public CommandRequest(String cmd) {\n+            command = cmd;\n+            time = System.currentTimeMillis() / 1000;\n+            initiator = \"localApp\";\n+        }\n+\n+        @Override\n+        public String getTopic() {\n+            return \"cmd\";\n+        }\n+    }\n+\n+    public static class DeltaRequest implements Request {\n+        public StateValue state;\n+\n+        public DeltaRequest(StateValue state) {\n+            this.state = state;\n+        }\n+\n+        @Override\n+        public String getTopic() {\n+            return \"delta\";\n+        }\n+    }\n+\n+    public static class CleanMissionStatus {\n+        public String cycle;\n+        public String phase;\n+        public int error;\n+    }\n+\n+    public static class BinStatus {\n+        public boolean present;\n+        public boolean full;\n+    }\n+\n+    public static class SignalStrength {\n+        public int rssi;\n+        public int snr;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7c151658d2d58e8306a315f18c13a3b6aa15fa5f"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM2MTk2MA==", "bodyText": "Well, have fun with dto package", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r533361960", "createdAt": "2020-12-01T12:11:29Z", "author": {"login": "Sonic-Amiga"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/internal/MQTTProtocol.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.internal;\n+\n+/**\n+ * iRobot MQTT protocol messages\n+ *\n+ * @author Pavel Fedin - Initial contribution\n+ *\n+ */\n+public class MQTTProtocol {\n+    public interface Request {\n+        public String getTopic();\n+    }\n+\n+    public static class CommandRequest implements Request {\n+        public String command;\n+        public long time;\n+        public String initiator;\n+\n+        public CommandRequest(String cmd) {\n+            command = cmd;\n+            time = System.currentTimeMillis() / 1000;\n+            initiator = \"localApp\";\n+        }\n+\n+        @Override\n+        public String getTopic() {\n+            return \"cmd\";\n+        }\n+    }\n+\n+    public static class DeltaRequest implements Request {\n+        public StateValue state;\n+\n+        public DeltaRequest(StateValue state) {\n+            this.state = state;\n+        }\n+\n+        @Override\n+        public String getTopic() {\n+            return \"delta\";\n+        }\n+    }\n+\n+    public static class CleanMissionStatus {\n+        public String cycle;\n+        public String phase;\n+        public int error;\n+    }\n+\n+    public static class BinStatus {\n+        public boolean present;\n+        public boolean full;\n+    }\n+\n+    public static class SignalStrength {\n+        public int rssi;\n+        public int snr;\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjE1NTY2Ng=="}, "originalCommit": {"oid": "7c151658d2d58e8306a315f18c13a3b6aa15fa5f"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMzODE2MDMwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/internal/handler/RoombaHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yOVQwNTowMToxMVrOH7gOug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wMVQxMjowNTowOVrOH8pnYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjE1NjA5MA==", "bodyText": "You need some way to prevent this from getting called if the handler is disposed.", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r532156090", "createdAt": "2020-11-29T05:01:11Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/internal/handler/RoombaHandler.java", "diffHunk": "@@ -0,0 +1,578 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.internal.handler;\n+\n+import static org.openhab.binding.irobot.internal.IRobotBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Hashtable;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.internal.MQTTProtocol;\n+import org.openhab.binding.irobot.internal.RawMQTT;\n+import org.openhab.binding.irobot.internal.RoombaConfiguration;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.io.transport.mqtt.MqttBrokerConnection;\n+import org.openhab.core.io.transport.mqtt.MqttConnectionObserver;\n+import org.openhab.core.io.transport.mqtt.MqttConnectionState;\n+import org.openhab.core.io.transport.mqtt.MqttMessageSubscriber;\n+import org.openhab.core.io.transport.mqtt.reconnect.PeriodicReconnectStrategy;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The {@link RoombaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author hkuhn42 - Initial contribution\n+ * @author Pavel Fedin - Rewrite for 900 series\n+ */\n+@NonNullByDefault\n+public class RoombaHandler extends BaseThingHandler implements MqttConnectionObserver, MqttMessageSubscriber {\n+    private final Logger logger = LoggerFactory.getLogger(RoombaHandler.class);\n+    private final Gson gson = new Gson();\n+    private static final int RECONNECT_DELAY_SEC = 5; // In seconds\n+    private @Nullable Future<?> reconnectReq;\n+    // Dummy RoombaConfiguration object in order to shut up Eclipse warnings\n+    // The real one is set in initialize()\n+    private RoombaConfiguration config = new RoombaConfiguration();\n+    private @Nullable String blid = null;\n+    private @Nullable MqttBrokerConnection connection;\n+    private Hashtable<String, State> lastState = new Hashtable<>();\n+    private MQTTProtocol.@Nullable Schedule lastSchedule = null;\n+    private boolean autoPasses = true;\n+    private @Nullable Boolean twoPasses = null;\n+    private boolean carpetBoost = true;\n+    private @Nullable Boolean vacHigh = null;\n+    private boolean isPaused = false;\n+\n+    public RoombaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(RoombaConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.execute(() -> {\n+            connect();\n+        });\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        scheduler.execute(() -> {\n+            disconnect();\n+        });\n+    }\n+\n+    // lastState.get() can return null if the key is not found according\n+    // to the documentation\n+    @SuppressWarnings(\"null\")\n+    private void handleRefresh(String ch) {\n+        State value = lastState.get(ch);\n+\n+        if (value != null) {\n+            updateState(ch, value);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String ch = channelUID.getId();\n+        if (command instanceof RefreshType) {\n+            handleRefresh(ch);\n+            return;\n+        }\n+\n+        if (ch.equals(CHANNEL_COMMAND)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+\n+                if (cmd.equals(CMD_CLEAN)) {\n+                    cmd = isPaused ? \"resume\" : \"start\";\n+                }\n+\n+                sendRequest(new MQTTProtocol.CommandRequest(cmd));\n+            }\n+        } else if (ch.startsWith(CHANNEL_SCHED_SWITCH_PREFIX)) {\n+            MQTTProtocol.Schedule schedule = lastSchedule;\n+\n+            // Schedule can only be updated in a bulk, so we have to store current\n+            // schedule and modify components.\n+            if (command instanceof OnOffType && schedule != null && schedule.cycle != null) {\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    if (ch.equals(CHANNEL_SCHED_SWITCH[i])) {\n+                        MQTTProtocol.Schedule newSchedule = new MQTTProtocol.Schedule(schedule.cycle);\n+\n+                        newSchedule.enableCycle(i, command.equals(OnOffType.ON));\n+                        sendSchedule(newSchedule);\n+                        break;\n+                    }\n+                }\n+            }\n+        } else if (ch.equals(CHANNEL_SCHEDULE)) {\n+            if (command instanceof DecimalType) {\n+                int bitmask = ((DecimalType) command).intValue();\n+                JsonArray cycle = new JsonArray();\n+\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    enableCycle(cycle, i, (bitmask & (1 << i)) != 0);\n+                }\n+\n+                sendSchedule(new MQTTProtocol.Schedule(bitmask));\n+            }\n+        } else if (ch.equals(CHANNEL_EDGE_CLEAN)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.OpenOnly(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_ALWAYS_FINISH)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.BinPause(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_POWER_BOOST)) {\n+            sendDelta(new MQTTProtocol.PowerBoost(command.equals(BOOST_AUTO), command.equals(BOOST_PERFORMANCE)));\n+        } else if (ch.equals(CHANNEL_CLEAN_PASSES)) {\n+            sendDelta(new MQTTProtocol.CleanPasses(!command.equals(PASSES_AUTO), command.equals(PASSES_2)));\n+        }\n+    }\n+\n+    private void enableCycle(JsonArray cycle, int i, boolean enable) {\n+        JsonPrimitive value = new JsonPrimitive(enable ? \"start\" : \"none\");\n+        cycle.set(i, value);\n+    }\n+\n+    private void sendSchedule(MQTTProtocol.Schedule schedule) {\n+        sendDelta(new MQTTProtocol.CleanSchedule(schedule));\n+    }\n+\n+    private void sendDelta(MQTTProtocol.StateValue state) {\n+        sendRequest(new MQTTProtocol.DeltaRequest(state));\n+    }\n+\n+    private void sendRequest(MQTTProtocol.Request request) {\n+        MqttBrokerConnection conn = connection;\n+\n+        if (conn != null) {\n+            String json = gson.toJson(request);\n+            logger.trace(\"Sending {}: {}\", request.getTopic(), json);\n+            // 1 here actually corresponds to MQTT qos 0 (AT_MOST_ONCE). Only this value is accepted\n+            // by Roomba, others just cause it to reject the command and drop the connection.\n+            conn.publish(request.getTopic(), json.getBytes(), 1, false);\n+        }\n+    }\n+\n+    // In order not to mess up our connection state we need to make sure\n+    // that connect() and disconnect() are never running concurrently, so\n+    // they are synchronized\n+    private synchronized void connect() {\n+        logger.debug(\"Connecting to {}\", config.ipaddress);\n+\n+        try {\n+            InetAddress host = InetAddress.getByName(config.ipaddress);\n+            String blid = this.blid;\n+\n+            if (blid == null) {\n+                DatagramSocket identSocket = IdentProtocol.sendRequest(host);\n+                DatagramPacket identPacket = IdentProtocol.receiveResponse(identSocket);\n+                IdentProtocol.IdentData ident;\n+\n+                identSocket.close();\n+\n+                try {\n+                    ident = IdentProtocol.decodeResponse(identPacket);\n+                } catch (JsonParseException e) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Malformed IDENT response\");\n+                    return;\n+                }\n+\n+                if (ident.ver < IdentData.MIN_SUPPORTED_VERSION) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                            \"Unsupported version \" + ident.ver);\n+                    return;\n+                }\n+\n+                if (!ident.product.equals(IdentData.PRODUCT_ROOMBA)) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                            \"Not a Roomba: \" + ident.product);\n+                    return;\n+                }\n+\n+                blid = ident.blid;\n+                this.blid = blid;\n+            }\n+\n+            logger.debug(\"BLID is: {}\", blid);\n+\n+            if (config.password.isEmpty()) {\n+                RawMQTT mqtt;\n+\n+                try {\n+                    mqtt = new RawMQTT(host, 8883);\n+                } catch (KeyManagementException | NoSuchAlgorithmException e1) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e1.toString());\n+                    return; // This is internal system error, no retry\n+                }\n+\n+                mqtt.requestPassword();\n+                RawMQTT.Packet response = mqtt.readPacket();\n+                mqtt.close();\n+\n+                if (response != null && response.isValidPasswdPacket()) {\n+                    RawMQTT.PasswdPacket passwdPacket = new RawMQTT.PasswdPacket(response);\n+                    String password = passwdPacket.getPassword();\n+\n+                    if (password != null) {\n+                        config.password = password;\n+\n+                        Configuration configuration = editConfiguration();\n+\n+                        configuration.put(\"password\", password);\n+                        updateConfiguration(configuration);\n+\n+                        logger.debug(\"Password successfully retrieved\");\n+                    }\n+                }\n+            }\n+\n+            if (config.password.isEmpty()) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING,\n+                        \"Authentication on the robot is required\");\n+                scheduleReconnect();\n+                return;\n+            }\n+\n+            // BLID is used as both client ID and username. The name of BLID also came from Roomba980-python\n+            MqttBrokerConnection connection = new MqttBrokerConnection(config.ipaddress, RawMQTT.ROOMBA_MQTT_PORT, true,\n+                    blid);\n+\n+            this.connection = connection;\n+\n+            // Disable sending UNSUBSCRIBE request before disconnecting becuase Roomba doesn't like it.\n+            // It just swallows the request and never sends any response, so stop() method never completes.\n+            connection.setUnsubscribeOnStop(false);\n+            connection.setCredentials(blid, config.password);\n+            connection.setTrustManagers(RawMQTT.getTrustManagers());\n+            // 1 here actually corresponds to MQTT qos 0 (AT_MOST_ONCE). Only this value is accepted\n+            // by Roomba, others just cause it to reject the command and drop the connection.\n+            connection.setQos(1);\n+            // MQTT connection reconnects itself, so we don't have to call scheduleReconnect()\n+            // when it breaks. Just set the period in ms.\n+            connection.setReconnectStrategy(\n+                    new PeriodicReconnectStrategy(RECONNECT_DELAY_SEC * 1000, RECONNECT_DELAY_SEC * 1000));\n+            connection.start().exceptionally(e -> {\n+                connectionStateChanged(MqttConnectionState.DISCONNECTED, e);\n+                return false;\n+            }).thenAccept(v -> {\n+                if (!v) {\n+                    connectionStateChanged(MqttConnectionState.DISCONNECTED, new TimeoutException(\"Timeout\"));\n+                } else {\n+                    connectionStateChanged(MqttConnectionState.CONNECTED, null);\n+                }\n+            });\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            scheduleReconnect();\n+        }\n+    }\n+\n+    private synchronized void disconnect() {\n+        Future<?> reconnectReq = this.reconnectReq;\n+        MqttBrokerConnection connection = this.connection;\n+\n+        if (reconnectReq != null) {\n+            reconnectReq.cancel(false);\n+            this.reconnectReq = null;\n+        }\n+\n+        if (connection != null) {\n+            connection.stop();\n+            logger.trace(\"Closed connection to {}\", config.ipaddress);\n+            this.connection = null;\n+        }\n+    }\n+\n+    private void scheduleReconnect() {\n+        reconnectReq = scheduler.schedule(this::connect, RECONNECT_DELAY_SEC, TimeUnit.SECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7c151658d2d58e8306a315f18c13a3b6aa15fa5f"}, "originalPosition": 337}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzM1ODQzMg==", "bodyText": "I can add \"boolean disposed\" flag and check it inside scheduleReconnect(), if you're insisting, however it's impossible because it's only called from within connect(), and connect() and disconnect() are synchronized. So disconnect() will wait for connect() to complete, then it will cancel any reconnect request if pending.", "url": "https://github.com/openhab/openhab-addons/pull/8723#discussion_r533358432", "createdAt": "2020-12-01T12:05:09Z", "author": {"login": "Sonic-Amiga"}, "path": "bundles/org.openhab.binding.irobot/src/main/java/org/openhab/binding/irobot/internal/handler/RoombaHandler.java", "diffHunk": "@@ -0,0 +1,578 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.irobot.internal.handler;\n+\n+import static org.openhab.binding.irobot.internal.IRobotBindingConstants.*;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.net.DatagramPacket;\n+import java.net.DatagramSocket;\n+import java.net.InetAddress;\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.Hashtable;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.irobot.internal.IdentProtocol;\n+import org.openhab.binding.irobot.internal.IdentProtocol.IdentData;\n+import org.openhab.binding.irobot.internal.MQTTProtocol;\n+import org.openhab.binding.irobot.internal.RawMQTT;\n+import org.openhab.binding.irobot.internal.RoombaConfiguration;\n+import org.openhab.core.config.core.Configuration;\n+import org.openhab.core.io.transport.mqtt.MqttBrokerConnection;\n+import org.openhab.core.io.transport.mqtt.MqttConnectionObserver;\n+import org.openhab.core.io.transport.mqtt.MqttConnectionState;\n+import org.openhab.core.io.transport.mqtt.MqttMessageSubscriber;\n+import org.openhab.core.io.transport.mqtt.reconnect.PeriodicReconnectStrategy;\n+import org.openhab.core.library.types.DecimalType;\n+import org.openhab.core.library.types.OnOffType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.binding.BaseThingHandler;\n+import org.openhab.core.types.Command;\n+import org.openhab.core.types.RefreshType;\n+import org.openhab.core.types.State;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonPrimitive;\n+import com.google.gson.stream.JsonReader;\n+\n+/**\n+ * The {@link RoombaHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author hkuhn42 - Initial contribution\n+ * @author Pavel Fedin - Rewrite for 900 series\n+ */\n+@NonNullByDefault\n+public class RoombaHandler extends BaseThingHandler implements MqttConnectionObserver, MqttMessageSubscriber {\n+    private final Logger logger = LoggerFactory.getLogger(RoombaHandler.class);\n+    private final Gson gson = new Gson();\n+    private static final int RECONNECT_DELAY_SEC = 5; // In seconds\n+    private @Nullable Future<?> reconnectReq;\n+    // Dummy RoombaConfiguration object in order to shut up Eclipse warnings\n+    // The real one is set in initialize()\n+    private RoombaConfiguration config = new RoombaConfiguration();\n+    private @Nullable String blid = null;\n+    private @Nullable MqttBrokerConnection connection;\n+    private Hashtable<String, State> lastState = new Hashtable<>();\n+    private MQTTProtocol.@Nullable Schedule lastSchedule = null;\n+    private boolean autoPasses = true;\n+    private @Nullable Boolean twoPasses = null;\n+    private boolean carpetBoost = true;\n+    private @Nullable Boolean vacHigh = null;\n+    private boolean isPaused = false;\n+\n+    public RoombaHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(RoombaConfiguration.class);\n+        updateStatus(ThingStatus.UNKNOWN);\n+\n+        scheduler.execute(() -> {\n+            connect();\n+        });\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        scheduler.execute(() -> {\n+            disconnect();\n+        });\n+    }\n+\n+    // lastState.get() can return null if the key is not found according\n+    // to the documentation\n+    @SuppressWarnings(\"null\")\n+    private void handleRefresh(String ch) {\n+        State value = lastState.get(ch);\n+\n+        if (value != null) {\n+            updateState(ch, value);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        String ch = channelUID.getId();\n+        if (command instanceof RefreshType) {\n+            handleRefresh(ch);\n+            return;\n+        }\n+\n+        if (ch.equals(CHANNEL_COMMAND)) {\n+            if (command instanceof StringType) {\n+                String cmd = command.toString();\n+\n+                if (cmd.equals(CMD_CLEAN)) {\n+                    cmd = isPaused ? \"resume\" : \"start\";\n+                }\n+\n+                sendRequest(new MQTTProtocol.CommandRequest(cmd));\n+            }\n+        } else if (ch.startsWith(CHANNEL_SCHED_SWITCH_PREFIX)) {\n+            MQTTProtocol.Schedule schedule = lastSchedule;\n+\n+            // Schedule can only be updated in a bulk, so we have to store current\n+            // schedule and modify components.\n+            if (command instanceof OnOffType && schedule != null && schedule.cycle != null) {\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    if (ch.equals(CHANNEL_SCHED_SWITCH[i])) {\n+                        MQTTProtocol.Schedule newSchedule = new MQTTProtocol.Schedule(schedule.cycle);\n+\n+                        newSchedule.enableCycle(i, command.equals(OnOffType.ON));\n+                        sendSchedule(newSchedule);\n+                        break;\n+                    }\n+                }\n+            }\n+        } else if (ch.equals(CHANNEL_SCHEDULE)) {\n+            if (command instanceof DecimalType) {\n+                int bitmask = ((DecimalType) command).intValue();\n+                JsonArray cycle = new JsonArray();\n+\n+                for (int i = 0; i < CHANNEL_SCHED_SWITCH.length; i++) {\n+                    enableCycle(cycle, i, (bitmask & (1 << i)) != 0);\n+                }\n+\n+                sendSchedule(new MQTTProtocol.Schedule(bitmask));\n+            }\n+        } else if (ch.equals(CHANNEL_EDGE_CLEAN)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.OpenOnly(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_ALWAYS_FINISH)) {\n+            if (command instanceof OnOffType) {\n+                sendDelta(new MQTTProtocol.BinPause(command.equals(OnOffType.OFF)));\n+            }\n+        } else if (ch.equals(CHANNEL_POWER_BOOST)) {\n+            sendDelta(new MQTTProtocol.PowerBoost(command.equals(BOOST_AUTO), command.equals(BOOST_PERFORMANCE)));\n+        } else if (ch.equals(CHANNEL_CLEAN_PASSES)) {\n+            sendDelta(new MQTTProtocol.CleanPasses(!command.equals(PASSES_AUTO), command.equals(PASSES_2)));\n+        }\n+    }\n+\n+    private void enableCycle(JsonArray cycle, int i, boolean enable) {\n+        JsonPrimitive value = new JsonPrimitive(enable ? \"start\" : \"none\");\n+        cycle.set(i, value);\n+    }\n+\n+    private void sendSchedule(MQTTProtocol.Schedule schedule) {\n+        sendDelta(new MQTTProtocol.CleanSchedule(schedule));\n+    }\n+\n+    private void sendDelta(MQTTProtocol.StateValue state) {\n+        sendRequest(new MQTTProtocol.DeltaRequest(state));\n+    }\n+\n+    private void sendRequest(MQTTProtocol.Request request) {\n+        MqttBrokerConnection conn = connection;\n+\n+        if (conn != null) {\n+            String json = gson.toJson(request);\n+            logger.trace(\"Sending {}: {}\", request.getTopic(), json);\n+            // 1 here actually corresponds to MQTT qos 0 (AT_MOST_ONCE). Only this value is accepted\n+            // by Roomba, others just cause it to reject the command and drop the connection.\n+            conn.publish(request.getTopic(), json.getBytes(), 1, false);\n+        }\n+    }\n+\n+    // In order not to mess up our connection state we need to make sure\n+    // that connect() and disconnect() are never running concurrently, so\n+    // they are synchronized\n+    private synchronized void connect() {\n+        logger.debug(\"Connecting to {}\", config.ipaddress);\n+\n+        try {\n+            InetAddress host = InetAddress.getByName(config.ipaddress);\n+            String blid = this.blid;\n+\n+            if (blid == null) {\n+                DatagramSocket identSocket = IdentProtocol.sendRequest(host);\n+                DatagramPacket identPacket = IdentProtocol.receiveResponse(identSocket);\n+                IdentProtocol.IdentData ident;\n+\n+                identSocket.close();\n+\n+                try {\n+                    ident = IdentProtocol.decodeResponse(identPacket);\n+                } catch (JsonParseException e) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Malformed IDENT response\");\n+                    return;\n+                }\n+\n+                if (ident.ver < IdentData.MIN_SUPPORTED_VERSION) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                            \"Unsupported version \" + ident.ver);\n+                    return;\n+                }\n+\n+                if (!ident.product.equals(IdentData.PRODUCT_ROOMBA)) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                            \"Not a Roomba: \" + ident.product);\n+                    return;\n+                }\n+\n+                blid = ident.blid;\n+                this.blid = blid;\n+            }\n+\n+            logger.debug(\"BLID is: {}\", blid);\n+\n+            if (config.password.isEmpty()) {\n+                RawMQTT mqtt;\n+\n+                try {\n+                    mqtt = new RawMQTT(host, 8883);\n+                } catch (KeyManagementException | NoSuchAlgorithmException e1) {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e1.toString());\n+                    return; // This is internal system error, no retry\n+                }\n+\n+                mqtt.requestPassword();\n+                RawMQTT.Packet response = mqtt.readPacket();\n+                mqtt.close();\n+\n+                if (response != null && response.isValidPasswdPacket()) {\n+                    RawMQTT.PasswdPacket passwdPacket = new RawMQTT.PasswdPacket(response);\n+                    String password = passwdPacket.getPassword();\n+\n+                    if (password != null) {\n+                        config.password = password;\n+\n+                        Configuration configuration = editConfiguration();\n+\n+                        configuration.put(\"password\", password);\n+                        updateConfiguration(configuration);\n+\n+                        logger.debug(\"Password successfully retrieved\");\n+                    }\n+                }\n+            }\n+\n+            if (config.password.isEmpty()) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_PENDING,\n+                        \"Authentication on the robot is required\");\n+                scheduleReconnect();\n+                return;\n+            }\n+\n+            // BLID is used as both client ID and username. The name of BLID also came from Roomba980-python\n+            MqttBrokerConnection connection = new MqttBrokerConnection(config.ipaddress, RawMQTT.ROOMBA_MQTT_PORT, true,\n+                    blid);\n+\n+            this.connection = connection;\n+\n+            // Disable sending UNSUBSCRIBE request before disconnecting becuase Roomba doesn't like it.\n+            // It just swallows the request and never sends any response, so stop() method never completes.\n+            connection.setUnsubscribeOnStop(false);\n+            connection.setCredentials(blid, config.password);\n+            connection.setTrustManagers(RawMQTT.getTrustManagers());\n+            // 1 here actually corresponds to MQTT qos 0 (AT_MOST_ONCE). Only this value is accepted\n+            // by Roomba, others just cause it to reject the command and drop the connection.\n+            connection.setQos(1);\n+            // MQTT connection reconnects itself, so we don't have to call scheduleReconnect()\n+            // when it breaks. Just set the period in ms.\n+            connection.setReconnectStrategy(\n+                    new PeriodicReconnectStrategy(RECONNECT_DELAY_SEC * 1000, RECONNECT_DELAY_SEC * 1000));\n+            connection.start().exceptionally(e -> {\n+                connectionStateChanged(MqttConnectionState.DISCONNECTED, e);\n+                return false;\n+            }).thenAccept(v -> {\n+                if (!v) {\n+                    connectionStateChanged(MqttConnectionState.DISCONNECTED, new TimeoutException(\"Timeout\"));\n+                } else {\n+                    connectionStateChanged(MqttConnectionState.CONNECTED, null);\n+                }\n+            });\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, e.getMessage());\n+            scheduleReconnect();\n+        }\n+    }\n+\n+    private synchronized void disconnect() {\n+        Future<?> reconnectReq = this.reconnectReq;\n+        MqttBrokerConnection connection = this.connection;\n+\n+        if (reconnectReq != null) {\n+            reconnectReq.cancel(false);\n+            this.reconnectReq = null;\n+        }\n+\n+        if (connection != null) {\n+            connection.stop();\n+            logger.trace(\"Closed connection to {}\", config.ipaddress);\n+            this.connection = null;\n+        }\n+    }\n+\n+    private void scheduleReconnect() {\n+        reconnectReq = scheduler.schedule(this::connect, RECONNECT_DELAY_SEC, TimeUnit.SECONDS);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjE1NjA5MA=="}, "originalCommit": {"oid": "7c151658d2d58e8306a315f18c13a3b6aa15fa5f"}, "originalPosition": 337}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4258, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}