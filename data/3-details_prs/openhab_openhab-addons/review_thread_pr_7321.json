{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAwNjY2MTY0", "number": 7321, "reviewThreads": {"totalCount": 55, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxODo0MToyMFrOD-WLQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNFQxODoyNTozMlrOEFVu7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NzAxNjM1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.smhi/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxODo0MToyMFrOGYZJ7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxODo0MToyMFrOGYZJ7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODIzMTE1MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            | Frozen precipitation  | Number | Percent of precipitation in frozen form (will be set to UNDEF if there's no precipitaion)  |\n          \n          \n            \n            | Frozen precipitation  | Number | Percent of precipitation in frozen form (will be set to UNDEF if there's no precipitation)  |", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r428231150", "createdAt": "2020-05-20T18:41:20Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.smhi/README.md", "diffHunk": "@@ -0,0 +1,143 @@\n+# Smhi Binding\n+\n+This binding gets hourly and daily forecast from SMHI - the Swedish Meteorological and Hydrological Institute. It can't \n+get forecasts for other countries than Sweden.\n+## Supported Things\n+\n+The binding support only one thing-type: forecast. The thing can be configured to get hourly forecasts for up to 24 \n+hours, and daily forecasts for up to 10 days.\n+\n+\n+## Discovery\n+\n+This binding does not support automatic discovery.\n+\n+## Thing Configuration\n+\n+The forecast thing needs to be configured with the latitude and longitude for the location of the forecast. You can \n+also choose for which hours and which days you would like to get forecasts.\n+\n+| Parameter | Description | Required |\n+|-----------|-------------|----------|\n+| Latitude  | Latitude of the forecast | Yes |\n+| Longitute | Longitude of the forecast | Yes |\n+| Hourly forecasts | The hourly forecasts to display | No |\n+| Daily forecasts | The daily forecasts to display | No |\n+\n+## Channels\n+\n+The channels are the same for all forecasts: \n+\n+#### Basic channels\n+\n+| channel  | type   | description                  |\n+|----------|--------|------------------------------|\n+| Temperature  | Number | Temperature in Celsius  |\n+| Wind direction  | Number | Wind direction in degrees  |\n+| Wind Speed  | Number | Wind speed in m/s  |\n+| Wind gust speed  | Number | Wind gust speed in m/s  |\n+| Minimum precipitation  | Number | Minimum precipitation intensity in mm/h  |\n+| Maximum precipitation  | Number | Maximum precipitation intensity in mm/h  |\n+| Precipitation category*  | Number | Type of precipitation  |\n+| Air pressure  | Number | Air pressure in hPa  |\n+| Relative humidity  | Number | Relative humidity in percent  |\n+| Total cloud cover  | Number | Mean value of total cloud cover in octets (how many eights of the visible sky is covered)  |\n+| Weather condition**  | Number | Short description of the weather conditions  |\n+\n+#### Advanced channels\n+\n+| channel  | type   | description                  |\n+|----------|--------|------------------------------|\n+| Visibility  | Number | Horizontal visibility in km  |\n+| Thunder probability  | Number | Probability of thunder in percent  |\n+| Frozen precipitation  | Number | Percent of precipitation in frozen form (will be set to UNDEF if there's no precipitaion)  |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ae7bd48b32ca057a99676ae00d993b4c822ffd4"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NzA0NzMzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.smhi/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxODo1MDowM1rOGYZdbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxODo1MDowM1rOGYZdbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODIzNjE0Mw==", "bodyText": "Suggestion for better usability: Transform the value to percent for better abstraction. Same for the other octet values.", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r428236143", "createdAt": "2020-05-20T18:50:03Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.smhi/README.md", "diffHunk": "@@ -0,0 +1,143 @@\n+# Smhi Binding\n+\n+This binding gets hourly and daily forecast from SMHI - the Swedish Meteorological and Hydrological Institute. It can't \n+get forecasts for other countries than Sweden.\n+## Supported Things\n+\n+The binding support only one thing-type: forecast. The thing can be configured to get hourly forecasts for up to 24 \n+hours, and daily forecasts for up to 10 days.\n+\n+\n+## Discovery\n+\n+This binding does not support automatic discovery.\n+\n+## Thing Configuration\n+\n+The forecast thing needs to be configured with the latitude and longitude for the location of the forecast. You can \n+also choose for which hours and which days you would like to get forecasts.\n+\n+| Parameter | Description | Required |\n+|-----------|-------------|----------|\n+| Latitude  | Latitude of the forecast | Yes |\n+| Longitute | Longitude of the forecast | Yes |\n+| Hourly forecasts | The hourly forecasts to display | No |\n+| Daily forecasts | The daily forecasts to display | No |\n+\n+## Channels\n+\n+The channels are the same for all forecasts: \n+\n+#### Basic channels\n+\n+| channel  | type   | description                  |\n+|----------|--------|------------------------------|\n+| Temperature  | Number | Temperature in Celsius  |\n+| Wind direction  | Number | Wind direction in degrees  |\n+| Wind Speed  | Number | Wind speed in m/s  |\n+| Wind gust speed  | Number | Wind gust speed in m/s  |\n+| Minimum precipitation  | Number | Minimum precipitation intensity in mm/h  |\n+| Maximum precipitation  | Number | Maximum precipitation intensity in mm/h  |\n+| Precipitation category*  | Number | Type of precipitation  |\n+| Air pressure  | Number | Air pressure in hPa  |\n+| Relative humidity  | Number | Relative humidity in percent  |\n+| Total cloud cover  | Number | Mean value of total cloud cover in octets (how many eights of the visible sky is covered)  |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ae7bd48b32ca057a99676ae00d993b4c822ffd4"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NzEwNjgyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/Forecast.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxOTowNjo0OFrOGYaCdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxNTo1NDo1NlrOGY4tBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI0NTYyMw==", "bodyText": "You seem to have a more recent branch \"smhi\" in your personal repo in which this code formatting issue is fixed. Which branch do you want to get merged?", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r428245623", "createdAt": "2020-05-20T19:06:48Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/Forecast.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.smhi.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.Map;\n+\n+\n+/**\n+ * A class containing a forecast for a specific point in time.\n+ *\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+@NonNullByDefault\n+public class Forecast implements Comparable<Forecast> {\n+    protected ZonedDateTime validTime;\n+    private Map<String, @Nullable BigDecimal> parameters;\n+\n+    public Forecast(ZonedDateTime validTime, Map<String, @Nullable BigDecimal> parameters) {\n+        this.validTime = validTime;\n+        this.parameters = parameters;\n+    }\n+\n+    public ZonedDateTime getValidTime() {\n+        return validTime;\n+    }\n+\n+    public Map<String, @Nullable BigDecimal> getParameters() {\n+        return parameters;\n+    }\n+\n+    public @Nullable BigDecimal getParameter(String parameter) { return parameters.get(parameter); }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ae7bd48b32ca057a99676ae00d993b4c822ffd4"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODUwNjY0OQ==", "bodyText": "I made a separate pr-branch so I could squash all commits when making the pr, but still keep the commit history in my own branch. Perhaps there is a better way to do this? I've then continued to make some improvements in the other branch (applied spotless, which is probably what solved this). Can pull them in here as well.", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r428506649", "createdAt": "2020-05-21T08:05:24Z", "author": {"login": "pacive"}, "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/Forecast.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.smhi.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.Map;\n+\n+\n+/**\n+ * A class containing a forecast for a specific point in time.\n+ *\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+@NonNullByDefault\n+public class Forecast implements Comparable<Forecast> {\n+    protected ZonedDateTime validTime;\n+    private Map<String, @Nullable BigDecimal> parameters;\n+\n+    public Forecast(ZonedDateTime validTime, Map<String, @Nullable BigDecimal> parameters) {\n+        this.validTime = validTime;\n+        this.parameters = parameters;\n+    }\n+\n+    public ZonedDateTime getValidTime() {\n+        return validTime;\n+    }\n+\n+    public Map<String, @Nullable BigDecimal> getParameters() {\n+        return parameters;\n+    }\n+\n+    public @Nullable BigDecimal getParameter(String parameter) { return parameters.get(parameter); }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI0NTYyMw=="}, "originalCommit": {"oid": "7ae7bd48b32ca057a99676ae00d993b4c822ffd4"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODc0ODAzOQ==", "bodyText": "You should definitly push them here, that they get merged, too.", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r428748039", "createdAt": "2020-05-21T15:54:56Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/Forecast.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.smhi.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.Map;\n+\n+\n+/**\n+ * A class containing a forecast for a specific point in time.\n+ *\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+@NonNullByDefault\n+public class Forecast implements Comparable<Forecast> {\n+    protected ZonedDateTime validTime;\n+    private Map<String, @Nullable BigDecimal> parameters;\n+\n+    public Forecast(ZonedDateTime validTime, Map<String, @Nullable BigDecimal> parameters) {\n+        this.validTime = validTime;\n+        this.parameters = parameters;\n+    }\n+\n+    public ZonedDateTime getValidTime() {\n+        return validTime;\n+    }\n+\n+    public Map<String, @Nullable BigDecimal> getParameters() {\n+        return parameters;\n+    }\n+\n+    public @Nullable BigDecimal getParameter(String parameter) { return parameters.get(parameter); }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI0NTYyMw=="}, "originalCommit": {"oid": "7ae7bd48b32ca057a99676ae00d993b4c822ffd4"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NzExNDkwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/Parser.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxOTowODo1OVrOGYaHcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxNTo1NjowN1rOGY4vrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI0Njg5Nw==", "bodyText": "I think it's better practise to write the explicit classes. See Eclipse \"organize imports\".", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r428246897", "createdAt": "2020-05-20T19:08:59Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/Parser.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.smhi.internal;\n+\n+import com.google.gson.*;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ae7bd48b32ca057a99676ae00d993b4c822ffd4"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODUxMTIyNg==", "bodyText": "Intellij automatically switches to a wildcard import when there's several (more than 3 i think) imports from the same package. Can change it to be more explicit.", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r428511226", "createdAt": "2020-05-21T08:15:54Z", "author": {"login": "pacive"}, "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/Parser.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.smhi.internal;\n+\n+import com.google.gson.*;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI0Njg5Nw=="}, "originalCommit": {"oid": "7ae7bd48b32ca057a99676ae00d993b4c822ffd4"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODc0ODcxNg==", "bodyText": "Ok, read some discussions about that. I'm wondering what the other reviewers will say.", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r428748716", "createdAt": "2020-05-21T15:56:07Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/Parser.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.smhi.internal;\n+\n+import com.google.gson.*;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI0Njg5Nw=="}, "originalCommit": {"oid": "7ae7bd48b32ca057a99676ae00d993b4c822ffd4"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NzExNTMwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/Parser.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxOTowOTowNVrOGYaHtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxOTowOTowNVrOGYaHtA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI0Njk2NA==", "bodyText": "See above.", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r428246964", "createdAt": "2020-05-20T19:09:05Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/Parser.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.smhi.internal;\n+\n+import com.google.gson.*;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.*;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ae7bd48b32ca057a99676ae00d993b4c822ffd4"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NzEyNzI4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/Parser.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxOToxMjoyN1rOGYaPBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQwNjoyNToyOFrOGZMAhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI0ODgzOQ==", "bodyText": "You could have had some fun with Java streams here. Next time...", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r428248839", "createdAt": "2020-05-20T19:12:27Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/Parser.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.smhi.internal;\n+\n+import com.google.gson.*;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.*;\n+\n+/**\n+ * Class with static methods for parsing json strings returned from Smhi\n+ *\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+@NonNullByDefault\n+public class Parser {\n+\n+    private static JsonParser parser = new JsonParser();\n+\n+    /**\n+     * Parse a json string received from Smhi containing forecasts.\n+     * @param json A json string\n+     * @return A {@link TimeSeries} object\n+     */\n+    public static TimeSeries parseTimeSeries(String json) {\n+        ZonedDateTime referenceTime;\n+        List<Forecast> forecasts = new ArrayList<>();\n+        JsonObject object = parser.parse(json).getAsJsonObject();\n+\n+        referenceTime = parseApprovedTime(json);\n+        JsonArray timeSeries = object.get(\"timeSeries\").getAsJsonArray();\n+\n+        timeSeries.forEach(element -> {\n+            forecasts.add(parseForecast(element.getAsJsonObject()));\n+        });\n+\n+        forecasts.sort(Comparator.naturalOrder());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ae7bd48b32ca057a99676ae00d993b4c822ffd4"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODU0MTExNA==", "bodyText": "I definitely need to read up more on streams, but when I experimented a bit here it seems that gson JsonArray doesn't support the stream() method. Is there another way to use it with an arbitrary \u00ccterable<>(which is whatJsonArray` implements)?", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r428541114", "createdAt": "2020-05-21T09:19:13Z", "author": {"login": "pacive"}, "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/Parser.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.smhi.internal;\n+\n+import com.google.gson.*;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.*;\n+\n+/**\n+ * Class with static methods for parsing json strings returned from Smhi\n+ *\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+@NonNullByDefault\n+public class Parser {\n+\n+    private static JsonParser parser = new JsonParser();\n+\n+    /**\n+     * Parse a json string received from Smhi containing forecasts.\n+     * @param json A json string\n+     * @return A {@link TimeSeries} object\n+     */\n+    public static TimeSeries parseTimeSeries(String json) {\n+        ZonedDateTime referenceTime;\n+        List<Forecast> forecasts = new ArrayList<>();\n+        JsonObject object = parser.parse(json).getAsJsonObject();\n+\n+        referenceTime = parseApprovedTime(json);\n+        JsonArray timeSeries = object.get(\"timeSeries\").getAsJsonArray();\n+\n+        timeSeries.forEach(element -> {\n+            forecasts.add(parseForecast(element.getAsJsonObject()));\n+        });\n+\n+        forecasts.sort(Comparator.naturalOrder());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI0ODgzOQ=="}, "originalCommit": {"oid": "7ae7bd48b32ca057a99676ae00d993b4c822ffd4"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODc0OTIwNA==", "bodyText": "You can do Stream.of(timeSeries) to get a stream. Then, you may want to use map().", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r428749204", "createdAt": "2020-05-21T15:57:00Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/Parser.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.smhi.internal;\n+\n+import com.google.gson.*;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.*;\n+\n+/**\n+ * Class with static methods for parsing json strings returned from Smhi\n+ *\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+@NonNullByDefault\n+public class Parser {\n+\n+    private static JsonParser parser = new JsonParser();\n+\n+    /**\n+     * Parse a json string received from Smhi containing forecasts.\n+     * @param json A json string\n+     * @return A {@link TimeSeries} object\n+     */\n+    public static TimeSeries parseTimeSeries(String json) {\n+        ZonedDateTime referenceTime;\n+        List<Forecast> forecasts = new ArrayList<>();\n+        JsonObject object = parser.parse(json).getAsJsonObject();\n+\n+        referenceTime = parseApprovedTime(json);\n+        JsonArray timeSeries = object.get(\"timeSeries\").getAsJsonArray();\n+\n+        timeSeries.forEach(element -> {\n+            forecasts.add(parseForecast(element.getAsJsonObject()));\n+        });\n+\n+        forecasts.sort(Comparator.naturalOrder());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI0ODgzOQ=="}, "originalCommit": {"oid": "7ae7bd48b32ca057a99676ae00d993b4c822ffd4"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTA2NDMyNw==", "bodyText": "Didn't work with Stream.of() but thanks to Stack Overflow I found you need to go via StreamSupport.stream(timeSeries.spliterator(), false)", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r429064327", "createdAt": "2020-05-22T06:25:28Z", "author": {"login": "pacive"}, "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/Parser.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.smhi.internal;\n+\n+import com.google.gson.*;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.*;\n+\n+/**\n+ * Class with static methods for parsing json strings returned from Smhi\n+ *\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+@NonNullByDefault\n+public class Parser {\n+\n+    private static JsonParser parser = new JsonParser();\n+\n+    /**\n+     * Parse a json string received from Smhi containing forecasts.\n+     * @param json A json string\n+     * @return A {@link TimeSeries} object\n+     */\n+    public static TimeSeries parseTimeSeries(String json) {\n+        ZonedDateTime referenceTime;\n+        List<Forecast> forecasts = new ArrayList<>();\n+        JsonObject object = parser.parse(json).getAsJsonObject();\n+\n+        referenceTime = parseApprovedTime(json);\n+        JsonArray timeSeries = object.get(\"timeSeries\").getAsJsonArray();\n+\n+        timeSeries.forEach(element -> {\n+            forecasts.add(parseForecast(element.getAsJsonObject()));\n+        });\n+\n+        forecasts.sort(Comparator.naturalOrder());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI0ODgzOQ=="}, "originalCommit": {"oid": "7ae7bd48b32ca057a99676ae00d993b4c822ffd4"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NzEzNTQ2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiConnector.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxOToxNDo0NFrOGYaUDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxNTo1Nzo1N1rOGY4zpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI1MDEyNg==", "bodyText": "See above", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r428250126", "createdAt": "2020-05-20T19:14:44Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiConnector.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.smhi.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.time.ZonedDateTime;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+import static org.openhab.binding.smhi.internal.SmhiBindingConstants.*;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ae7bd48b32ca057a99676ae00d993b4c822ffd4"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODU0MTk5NA==", "bodyText": "This is not the same as the others since it's a static import of the binding constants. I don't need to import them individually, do I?", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r428541994", "createdAt": "2020-05-21T09:21:05Z", "author": {"login": "pacive"}, "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiConnector.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.smhi.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.time.ZonedDateTime;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+import static org.openhab.binding.smhi.internal.SmhiBindingConstants.*;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI1MDEyNg=="}, "originalCommit": {"oid": "7ae7bd48b32ca057a99676ae00d993b4c822ffd4"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODc0OTczMg==", "bodyText": "You are totally right. Please ignore my comment.", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r428749732", "createdAt": "2020-05-21T15:57:57Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiConnector.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.smhi.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.time.ZonedDateTime;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+import static org.openhab.binding.smhi.internal.SmhiBindingConstants.*;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI1MDEyNg=="}, "originalCommit": {"oid": "7ae7bd48b32ca057a99676ae00d993b4c822ffd4"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NzE1MTIxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiConnector.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxOToxOTozM1rOGYaeFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMlQxNTo1MzozN1rOGZcE5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI1MjY5Mw==", "bodyText": "Throwing an unchecked Exception from a binding is evil. You should handle the error appropriately and log it with log.warn().", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r428252693", "createdAt": "2020-05-20T19:19:33Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiConnector.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.smhi.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.time.ZonedDateTime;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+import static org.openhab.binding.smhi.internal.SmhiBindingConstants.*;\n+\n+/**\n+ * Class for handling http requests to Smhi's API and return values.\n+ *\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmhiConnector {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SmhiConnector.class);\n+\n+    private static final String ACCEPT = \"application/json\";\n+\n+    private final HttpClient httpClient;\n+\n+    public SmhiConnector(HttpClient httpClient) {\n+        this.httpClient = httpClient;\n+    }\n+\n+    /**\n+     * Get the reference time (the time when the forecast starts) of the latest published forecast\n+     * @return A {@link ZonedDateTime} with the time of the latest forecast.\n+     */\n+    public ZonedDateTime getReferenceTime() {\n+        logger.debug(\"Fetching reference time\");\n+        Request req = httpClient.newRequest(APPROVED_TIME_URL);\n+        req.accept(ACCEPT);\n+        ContentResponse resp;\n+        try {\n+            resp = req.send();\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            throw new SmhiException();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ae7bd48b32ca057a99676ae00d993b4c822ffd4"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTIwNDEzNQ==", "bodyText": "Didn't know about checked vs unchecked exceptions, thanks for enlightening me :). Would altering SmhiException to extend Exception instead of RuntimeException be better?", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r429204135", "createdAt": "2020-05-22T11:56:52Z", "author": {"login": "pacive"}, "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiConnector.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.smhi.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.time.ZonedDateTime;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+import static org.openhab.binding.smhi.internal.SmhiBindingConstants.*;\n+\n+/**\n+ * Class for handling http requests to Smhi's API and return values.\n+ *\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmhiConnector {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SmhiConnector.class);\n+\n+    private static final String ACCEPT = \"application/json\";\n+\n+    private final HttpClient httpClient;\n+\n+    public SmhiConnector(HttpClient httpClient) {\n+        this.httpClient = httpClient;\n+    }\n+\n+    /**\n+     * Get the reference time (the time when the forecast starts) of the latest published forecast\n+     * @return A {@link ZonedDateTime} with the time of the latest forecast.\n+     */\n+    public ZonedDateTime getReferenceTime() {\n+        logger.debug(\"Fetching reference time\");\n+        Request req = httpClient.newRequest(APPROVED_TIME_URL);\n+        req.accept(ACCEPT);\n+        ContentResponse resp;\n+        try {\n+            resp = req.send();\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            throw new SmhiException();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI1MjY5Mw=="}, "originalCommit": {"oid": "7ae7bd48b32ca057a99676ae00d993b4c822ffd4"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTMyNzU5MA==", "bodyText": "That would be a checked Exception, then. So, yes, this would be better!", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r429327590", "createdAt": "2020-05-22T15:53:37Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiConnector.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.smhi.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.time.ZonedDateTime;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+import static org.openhab.binding.smhi.internal.SmhiBindingConstants.*;\n+\n+/**\n+ * Class for handling http requests to Smhi's API and return values.\n+ *\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmhiConnector {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SmhiConnector.class);\n+\n+    private static final String ACCEPT = \"application/json\";\n+\n+    private final HttpClient httpClient;\n+\n+    public SmhiConnector(HttpClient httpClient) {\n+        this.httpClient = httpClient;\n+    }\n+\n+    /**\n+     * Get the reference time (the time when the forecast starts) of the latest published forecast\n+     * @return A {@link ZonedDateTime} with the time of the latest forecast.\n+     */\n+    public ZonedDateTime getReferenceTime() {\n+        logger.debug(\"Fetching reference time\");\n+        Request req = httpClient.newRequest(APPROVED_TIME_URL);\n+        req.accept(ACCEPT);\n+        ContentResponse resp;\n+        try {\n+            resp = req.send();\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            throw new SmhiException();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI1MjY5Mw=="}, "originalCommit": {"oid": "7ae7bd48b32ca057a99676ae00d993b4c822ffd4"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NzE1MzM4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiConnector.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxOToyMDowNFrOGYafWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxOToyMDowNFrOGYafWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI1MzAxNw==", "bodyText": "See above", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r428253017", "createdAt": "2020-05-20T19:20:04Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiConnector.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.smhi.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.time.ZonedDateTime;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+import static org.openhab.binding.smhi.internal.SmhiBindingConstants.*;\n+\n+/**\n+ * Class for handling http requests to Smhi's API and return values.\n+ *\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmhiConnector {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SmhiConnector.class);\n+\n+    private static final String ACCEPT = \"application/json\";\n+\n+    private final HttpClient httpClient;\n+\n+    public SmhiConnector(HttpClient httpClient) {\n+        this.httpClient = httpClient;\n+    }\n+\n+    /**\n+     * Get the reference time (the time when the forecast starts) of the latest published forecast\n+     * @return A {@link ZonedDateTime} with the time of the latest forecast.\n+     */\n+    public ZonedDateTime getReferenceTime() {\n+        logger.debug(\"Fetching reference time\");\n+        Request req = httpClient.newRequest(APPROVED_TIME_URL);\n+        req.accept(ACCEPT);\n+        ContentResponse resp;\n+        try {\n+            resp = req.send();\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            throw new SmhiException();\n+        }\n+        return Parser.parseApprovedTime(resp.getContentAsString());\n+    }\n+\n+    /**\n+     * Get a forecast for the specified WGS84 coordinates.\n+     * @param lat Latitude\n+     * @param lon Longitude\n+     * @return A {@link TimeSeries} object containing the published forecasts.\n+     */\n+    public TimeSeries getForecast(double lat, double lon) {\n+        logger.debug(\"Fetching new forecast\");\n+        String url = String.format(POINT_FORECAST_URL, lon, lat);\n+        Request req = httpClient.newRequest(url);\n+        req.accept(ACCEPT);\n+        ContentResponse resp;\n+        try {\n+            resp = req.send();\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            throw new SmhiException();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ae7bd48b32ca057a99676ae00d993b4c822ffd4"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NzE1OTIyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxOToyMTo0N1rOGYai_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxOToyMTo0N1rOGYai_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI1Mzk0OA==", "bodyText": "See above", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r428253948", "createdAt": "2020-05-20T19:21:47Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiHandler.java", "diffHunk": "@@ -0,0 +1,350 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smhi.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerCallback;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.math.BigDecimal;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.*;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ae7bd48b32ca057a99676ae00d993b4c822ffd4"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NzE1OTcxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxOToyMTo1N1rOGYajVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxMjowMDoyM1rOGYwO7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI1NDAzOA==", "bodyText": "See above", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r428254038", "createdAt": "2020-05-20T19:21:57Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiHandler.java", "diffHunk": "@@ -0,0 +1,350 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smhi.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerCallback;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.math.BigDecimal;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.*;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.openhab.binding.smhi.internal.SmhiBindingConstants.*;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ae7bd48b32ca057a99676ae00d993b4c822ffd4"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODYwOTI2MA==", "bodyText": "Also for binding constants", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r428609260", "createdAt": "2020-05-21T12:00:23Z", "author": {"login": "pacive"}, "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiHandler.java", "diffHunk": "@@ -0,0 +1,350 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smhi.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerCallback;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.math.BigDecimal;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.*;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.openhab.binding.smhi.internal.SmhiBindingConstants.*;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI1NDAzOA=="}, "originalCommit": {"oid": "7ae7bd48b32ca057a99676ae00d993b4c822ffd4"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NzE3MDExOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxOToyNToxOVrOGYaqBw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxOToyNToxOVrOGYaqBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI1NTc1MQ==", "bodyText": "This timer is not canceled when the addon is disposed. Although this is a one-shot, it's good practise to cancel it explicitly.", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r428255751", "createdAt": "2020-05-20T19:25:19Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiHandler.java", "diffHunk": "@@ -0,0 +1,350 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smhi.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerCallback;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.math.BigDecimal;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.*;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.openhab.binding.smhi.internal.SmhiBindingConstants.*;\n+\n+/**\n+ * The {@link SmhiHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmhiHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SmhiHandler.class);\n+\n+    private @NonNullByDefault({}) SmhiConfiguration config;\n+\n+    private final HttpClient httpClient;\n+    private @NonNullByDefault({}) SmhiConnector connection;\n+    private ZonedDateTime currentHour;\n+    private ZonedDateTime currentDay;\n+    private @Nullable TimeSeries cachedTimeSeries;\n+    private boolean hasLatestForecast = false;\n+    private @Nullable Future<?> forecastUpdater;\n+    private @Nullable Future<?> instantUpdate;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ae7bd48b32ca057a99676ae00d993b4c822ffd4"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NzE4OTkwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxOTozMTo0M1rOGYa2wQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxOTozMTo0M1rOGYa2wQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI1OTAwOQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * Start polling wor updated weather forecast.\n          \n          \n            \n                 * Start polling for updated weather forecast.", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r428259009", "createdAt": "2020-05-20T19:31:43Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiHandler.java", "diffHunk": "@@ -0,0 +1,350 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smhi.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerCallback;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.math.BigDecimal;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.*;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.openhab.binding.smhi.internal.SmhiBindingConstants.*;\n+\n+/**\n+ * The {@link SmhiHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmhiHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SmhiHandler.class);\n+\n+    private @NonNullByDefault({}) SmhiConfiguration config;\n+\n+    private final HttpClient httpClient;\n+    private @NonNullByDefault({}) SmhiConnector connection;\n+    private ZonedDateTime currentHour;\n+    private ZonedDateTime currentDay;\n+    private @Nullable TimeSeries cachedTimeSeries;\n+    private boolean hasLatestForecast = false;\n+    private @Nullable Future<?> forecastUpdater;\n+    private @Nullable Future<?> instantUpdate;\n+\n+    public SmhiHandler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.currentHour = calculateCurrentHour();\n+        this.currentDay = calculateCurrentDay();\n+    }\n+\n+    /**\n+     * Handles commands sent to channels. Since all values are read-only, only REFRESH commands are allowed.\n+     * Sending REFRESH to any item updates all items, since all values are returned in the response from Smhi.\n+     * Therefore there's a wait of 5 seconds before the values are fetched, in which time all other commands are\n+     * blocked, to prevent spamming Smhi's API.\n+     *\n+     * @param channelUID\n+     * @param command\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            synchronized (this) {\n+                Future<?> localRef = instantUpdate;\n+                if (localRef == null || localRef.isDone() || localRef.isCancelled()) {\n+                    instantUpdate = scheduler.schedule(this::getUpdatedForecast, 5, TimeUnit.SECONDS);\n+                } else {\n+                    logger.debug(\"Already waiting for scheduled refresh\");\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(SmhiConfiguration.class);\n+        if (config == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+            return;\n+        }\n+        connection = new SmhiConnector(httpClient);\n+\n+        //Check which channel groups are selected in the config.\n+        List<Channel> channels = new ArrayList<>();\n+        channels.addAll(createChannels());\n+        updateThing(editThing().withChannels(channels).build());\n+\n+        startPolling();\n+        updateStatus(ThingStatus.ONLINE);\n+        synchronized (this) {\n+            Future<?> localRef = instantUpdate;\n+            if (localRef == null || localRef.isDone() || localRef.isCancelled()) {\n+                instantUpdate = scheduler.schedule(this::getUpdatedForecast, 5, TimeUnit.SECONDS);\n+            } else {\n+                logger.debug(\"Already waiting for scheduled refresh\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Start polling wor updated weather forecast.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ae7bd48b32ca057a99676ae00d993b4c822ffd4"}, "originalPosition": 119}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NzIyMjgyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiHandler.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxOTo0MjoyMVrOGYbL9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxNjowNDowOFrOGY5CCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI2NDQzOQ==", "bodyText": "It's bad practise to throw unchecked Exceptions on expected errors, because the compiler do not forces you (or any other developer) to handle the error when using getForecast(). Better throw a custom exception (e.g. SmhiException, extending Exception.", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r428264439", "createdAt": "2020-05-20T19:42:21Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiHandler.java", "diffHunk": "@@ -0,0 +1,350 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smhi.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerCallback;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.math.BigDecimal;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.*;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.openhab.binding.smhi.internal.SmhiBindingConstants.*;\n+\n+/**\n+ * The {@link SmhiHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmhiHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SmhiHandler.class);\n+\n+    private @NonNullByDefault({}) SmhiConfiguration config;\n+\n+    private final HttpClient httpClient;\n+    private @NonNullByDefault({}) SmhiConnector connection;\n+    private ZonedDateTime currentHour;\n+    private ZonedDateTime currentDay;\n+    private @Nullable TimeSeries cachedTimeSeries;\n+    private boolean hasLatestForecast = false;\n+    private @Nullable Future<?> forecastUpdater;\n+    private @Nullable Future<?> instantUpdate;\n+\n+    public SmhiHandler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.currentHour = calculateCurrentHour();\n+        this.currentDay = calculateCurrentDay();\n+    }\n+\n+    /**\n+     * Handles commands sent to channels. Since all values are read-only, only REFRESH commands are allowed.\n+     * Sending REFRESH to any item updates all items, since all values are returned in the response from Smhi.\n+     * Therefore there's a wait of 5 seconds before the values are fetched, in which time all other commands are\n+     * blocked, to prevent spamming Smhi's API.\n+     *\n+     * @param channelUID\n+     * @param command\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            synchronized (this) {\n+                Future<?> localRef = instantUpdate;\n+                if (localRef == null || localRef.isDone() || localRef.isCancelled()) {\n+                    instantUpdate = scheduler.schedule(this::getUpdatedForecast, 5, TimeUnit.SECONDS);\n+                } else {\n+                    logger.debug(\"Already waiting for scheduled refresh\");\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(SmhiConfiguration.class);\n+        if (config == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+            return;\n+        }\n+        connection = new SmhiConnector(httpClient);\n+\n+        //Check which channel groups are selected in the config.\n+        List<Channel> channels = new ArrayList<>();\n+        channels.addAll(createChannels());\n+        updateThing(editThing().withChannels(channels).build());\n+\n+        startPolling();\n+        updateStatus(ThingStatus.ONLINE);\n+        synchronized (this) {\n+            Future<?> localRef = instantUpdate;\n+            if (localRef == null || localRef.isDone() || localRef.isCancelled()) {\n+                instantUpdate = scheduler.schedule(this::getUpdatedForecast, 5, TimeUnit.SECONDS);\n+            } else {\n+                logger.debug(\"Already waiting for scheduled refresh\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Start polling wor updated weather forecast.\n+     */\n+    private synchronized void startPolling() {\n+        forecastUpdater = scheduler.scheduleWithFixedDelay(this::waitForForecast, 1, 1, TimeUnit.MINUTES);\n+    }\n+\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        if (!isModifyingCurrentConfig(configurationParameters)) {\n+            return;\n+        }\n+\n+        validateConfigurationParameters(configurationParameters);\n+\n+        Configuration configuration = editConfiguration();\n+        for (Map.Entry<String, Object> configurationParameter : configurationParameters.entrySet()) {\n+            configuration.put(configurationParameter.getKey(), configurationParameter.getValue());\n+        }\n+\n+        if (isInitialized()) {\n+            updateConfiguration(configuration);\n+            config = configuration.as(SmhiConfiguration.class);\n+            updateThing(editThing().withChannels(createChannels()).build());\n+        } else {\n+            // persist new configuration and notify Thing Manager\n+            updateConfiguration(configuration);\n+            ThingHandlerCallback callback = getCallback();\n+            if (callback != null) {\n+                callback.configurationUpdated(this.getThing());\n+            } else {\n+                logger.warn(\"Handler {} tried updating its configuration although the handler was already disposed.\",\n+                        this.getClass().getSimpleName());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update channels with new forecast data.\n+     * @param timeSeries A {@link TimeSeries} object containing forecasts.\n+     */\n+    private void updateChannels(TimeSeries timeSeries) {\n+        // Loop through hourly forecasts and update those available\n+        for (int i = 0; i < 25; i++) {\n+            List<Channel> channels = thing.getChannelsOfGroup(\"hour_\" + i);\n+            if (channels.isEmpty()) {\n+                continue;\n+            }\n+            Forecast forecast = timeSeries.getForecast(i);\n+            channels.forEach(c -> {\n+                String id = c.getUID().getIdWithoutGroup();\n+                BigDecimal value = forecast.getParameter(id);\n+                if (value != null) {\n+                    // Smhi returns -9 for spp if there's no precipitation, convert to UNDEF\n+                    if (id.equals(PERCENT_FROZEN) && value.intValue() == -9) {\n+                        updateState(c.getUID(), UnDefType.UNDEF);\n+                    } else {\n+                        updateState(c.getUID(), new DecimalType(value));\n+                    }\n+                } else {\n+                    updateState(c.getUID(), UnDefType.NULL);\n+                }\n+            });\n+        }\n+        // Loop through daily forecasts and updates those available\n+        for (int i = 0; i < 10; i++) {\n+            List<Channel> channels = thing.getChannelsOfGroup(\"day_\" + i);\n+            if (channels.isEmpty()) {\n+                continue;\n+            }\n+            Forecast forecast;\n+            try {\n+                forecast = timeSeries.getForecast(currentDay, 24 * i + 12);\n+            } catch (NoSuchElementException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ae7bd48b32ca057a99676ae00d993b4c822ffd4"}, "originalPosition": 191}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODU2Nzk3OA==", "bodyText": "I thought this was the most appropriate exception to throw, since it's what's being thrown by Iterator.next() when there are no more elements (which is basically what happens here if the time is too far off). Will change to return null instead of throwing an exception and check for that instead.", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r428567978", "createdAt": "2020-05-21T10:19:50Z", "author": {"login": "pacive"}, "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiHandler.java", "diffHunk": "@@ -0,0 +1,350 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smhi.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerCallback;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.math.BigDecimal;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.*;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.openhab.binding.smhi.internal.SmhiBindingConstants.*;\n+\n+/**\n+ * The {@link SmhiHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmhiHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SmhiHandler.class);\n+\n+    private @NonNullByDefault({}) SmhiConfiguration config;\n+\n+    private final HttpClient httpClient;\n+    private @NonNullByDefault({}) SmhiConnector connection;\n+    private ZonedDateTime currentHour;\n+    private ZonedDateTime currentDay;\n+    private @Nullable TimeSeries cachedTimeSeries;\n+    private boolean hasLatestForecast = false;\n+    private @Nullable Future<?> forecastUpdater;\n+    private @Nullable Future<?> instantUpdate;\n+\n+    public SmhiHandler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.currentHour = calculateCurrentHour();\n+        this.currentDay = calculateCurrentDay();\n+    }\n+\n+    /**\n+     * Handles commands sent to channels. Since all values are read-only, only REFRESH commands are allowed.\n+     * Sending REFRESH to any item updates all items, since all values are returned in the response from Smhi.\n+     * Therefore there's a wait of 5 seconds before the values are fetched, in which time all other commands are\n+     * blocked, to prevent spamming Smhi's API.\n+     *\n+     * @param channelUID\n+     * @param command\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            synchronized (this) {\n+                Future<?> localRef = instantUpdate;\n+                if (localRef == null || localRef.isDone() || localRef.isCancelled()) {\n+                    instantUpdate = scheduler.schedule(this::getUpdatedForecast, 5, TimeUnit.SECONDS);\n+                } else {\n+                    logger.debug(\"Already waiting for scheduled refresh\");\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(SmhiConfiguration.class);\n+        if (config == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+            return;\n+        }\n+        connection = new SmhiConnector(httpClient);\n+\n+        //Check which channel groups are selected in the config.\n+        List<Channel> channels = new ArrayList<>();\n+        channels.addAll(createChannels());\n+        updateThing(editThing().withChannels(channels).build());\n+\n+        startPolling();\n+        updateStatus(ThingStatus.ONLINE);\n+        synchronized (this) {\n+            Future<?> localRef = instantUpdate;\n+            if (localRef == null || localRef.isDone() || localRef.isCancelled()) {\n+                instantUpdate = scheduler.schedule(this::getUpdatedForecast, 5, TimeUnit.SECONDS);\n+            } else {\n+                logger.debug(\"Already waiting for scheduled refresh\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Start polling wor updated weather forecast.\n+     */\n+    private synchronized void startPolling() {\n+        forecastUpdater = scheduler.scheduleWithFixedDelay(this::waitForForecast, 1, 1, TimeUnit.MINUTES);\n+    }\n+\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        if (!isModifyingCurrentConfig(configurationParameters)) {\n+            return;\n+        }\n+\n+        validateConfigurationParameters(configurationParameters);\n+\n+        Configuration configuration = editConfiguration();\n+        for (Map.Entry<String, Object> configurationParameter : configurationParameters.entrySet()) {\n+            configuration.put(configurationParameter.getKey(), configurationParameter.getValue());\n+        }\n+\n+        if (isInitialized()) {\n+            updateConfiguration(configuration);\n+            config = configuration.as(SmhiConfiguration.class);\n+            updateThing(editThing().withChannels(createChannels()).build());\n+        } else {\n+            // persist new configuration and notify Thing Manager\n+            updateConfiguration(configuration);\n+            ThingHandlerCallback callback = getCallback();\n+            if (callback != null) {\n+                callback.configurationUpdated(this.getThing());\n+            } else {\n+                logger.warn(\"Handler {} tried updating its configuration although the handler was already disposed.\",\n+                        this.getClass().getSimpleName());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update channels with new forecast data.\n+     * @param timeSeries A {@link TimeSeries} object containing forecasts.\n+     */\n+    private void updateChannels(TimeSeries timeSeries) {\n+        // Loop through hourly forecasts and update those available\n+        for (int i = 0; i < 25; i++) {\n+            List<Channel> channels = thing.getChannelsOfGroup(\"hour_\" + i);\n+            if (channels.isEmpty()) {\n+                continue;\n+            }\n+            Forecast forecast = timeSeries.getForecast(i);\n+            channels.forEach(c -> {\n+                String id = c.getUID().getIdWithoutGroup();\n+                BigDecimal value = forecast.getParameter(id);\n+                if (value != null) {\n+                    // Smhi returns -9 for spp if there's no precipitation, convert to UNDEF\n+                    if (id.equals(PERCENT_FROZEN) && value.intValue() == -9) {\n+                        updateState(c.getUID(), UnDefType.UNDEF);\n+                    } else {\n+                        updateState(c.getUID(), new DecimalType(value));\n+                    }\n+                } else {\n+                    updateState(c.getUID(), UnDefType.NULL);\n+                }\n+            });\n+        }\n+        // Loop through daily forecasts and updates those available\n+        for (int i = 0; i < 10; i++) {\n+            List<Channel> channels = thing.getChannelsOfGroup(\"day_\" + i);\n+            if (channels.isEmpty()) {\n+                continue;\n+            }\n+            Forecast forecast;\n+            try {\n+                forecast = timeSeries.getForecast(currentDay, 24 * i + 12);\n+            } catch (NoSuchElementException e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI2NDQzOQ=="}, "originalCommit": {"oid": "7ae7bd48b32ca057a99676ae00d993b4c822ffd4"}, "originalPosition": 191}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODc1MzQxNg==", "bodyText": "NoSuchElementException is an unchecked Exception, which should only raise if there is a bug in your code. Returning null is ok, IMHO. You could also return Optional<Forecast>. And if there is no Forecast available, you return Optional.empty().", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r428753416", "createdAt": "2020-05-21T16:04:08Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiHandler.java", "diffHunk": "@@ -0,0 +1,350 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smhi.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerCallback;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.math.BigDecimal;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.*;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.openhab.binding.smhi.internal.SmhiBindingConstants.*;\n+\n+/**\n+ * The {@link SmhiHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmhiHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SmhiHandler.class);\n+\n+    private @NonNullByDefault({}) SmhiConfiguration config;\n+\n+    private final HttpClient httpClient;\n+    private @NonNullByDefault({}) SmhiConnector connection;\n+    private ZonedDateTime currentHour;\n+    private ZonedDateTime currentDay;\n+    private @Nullable TimeSeries cachedTimeSeries;\n+    private boolean hasLatestForecast = false;\n+    private @Nullable Future<?> forecastUpdater;\n+    private @Nullable Future<?> instantUpdate;\n+\n+    public SmhiHandler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.currentHour = calculateCurrentHour();\n+        this.currentDay = calculateCurrentDay();\n+    }\n+\n+    /**\n+     * Handles commands sent to channels. Since all values are read-only, only REFRESH commands are allowed.\n+     * Sending REFRESH to any item updates all items, since all values are returned in the response from Smhi.\n+     * Therefore there's a wait of 5 seconds before the values are fetched, in which time all other commands are\n+     * blocked, to prevent spamming Smhi's API.\n+     *\n+     * @param channelUID\n+     * @param command\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            synchronized (this) {\n+                Future<?> localRef = instantUpdate;\n+                if (localRef == null || localRef.isDone() || localRef.isCancelled()) {\n+                    instantUpdate = scheduler.schedule(this::getUpdatedForecast, 5, TimeUnit.SECONDS);\n+                } else {\n+                    logger.debug(\"Already waiting for scheduled refresh\");\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(SmhiConfiguration.class);\n+        if (config == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+            return;\n+        }\n+        connection = new SmhiConnector(httpClient);\n+\n+        //Check which channel groups are selected in the config.\n+        List<Channel> channels = new ArrayList<>();\n+        channels.addAll(createChannels());\n+        updateThing(editThing().withChannels(channels).build());\n+\n+        startPolling();\n+        updateStatus(ThingStatus.ONLINE);\n+        synchronized (this) {\n+            Future<?> localRef = instantUpdate;\n+            if (localRef == null || localRef.isDone() || localRef.isCancelled()) {\n+                instantUpdate = scheduler.schedule(this::getUpdatedForecast, 5, TimeUnit.SECONDS);\n+            } else {\n+                logger.debug(\"Already waiting for scheduled refresh\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Start polling wor updated weather forecast.\n+     */\n+    private synchronized void startPolling() {\n+        forecastUpdater = scheduler.scheduleWithFixedDelay(this::waitForForecast, 1, 1, TimeUnit.MINUTES);\n+    }\n+\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        if (!isModifyingCurrentConfig(configurationParameters)) {\n+            return;\n+        }\n+\n+        validateConfigurationParameters(configurationParameters);\n+\n+        Configuration configuration = editConfiguration();\n+        for (Map.Entry<String, Object> configurationParameter : configurationParameters.entrySet()) {\n+            configuration.put(configurationParameter.getKey(), configurationParameter.getValue());\n+        }\n+\n+        if (isInitialized()) {\n+            updateConfiguration(configuration);\n+            config = configuration.as(SmhiConfiguration.class);\n+            updateThing(editThing().withChannels(createChannels()).build());\n+        } else {\n+            // persist new configuration and notify Thing Manager\n+            updateConfiguration(configuration);\n+            ThingHandlerCallback callback = getCallback();\n+            if (callback != null) {\n+                callback.configurationUpdated(this.getThing());\n+            } else {\n+                logger.warn(\"Handler {} tried updating its configuration although the handler was already disposed.\",\n+                        this.getClass().getSimpleName());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update channels with new forecast data.\n+     * @param timeSeries A {@link TimeSeries} object containing forecasts.\n+     */\n+    private void updateChannels(TimeSeries timeSeries) {\n+        // Loop through hourly forecasts and update those available\n+        for (int i = 0; i < 25; i++) {\n+            List<Channel> channels = thing.getChannelsOfGroup(\"hour_\" + i);\n+            if (channels.isEmpty()) {\n+                continue;\n+            }\n+            Forecast forecast = timeSeries.getForecast(i);\n+            channels.forEach(c -> {\n+                String id = c.getUID().getIdWithoutGroup();\n+                BigDecimal value = forecast.getParameter(id);\n+                if (value != null) {\n+                    // Smhi returns -9 for spp if there's no precipitation, convert to UNDEF\n+                    if (id.equals(PERCENT_FROZEN) && value.intValue() == -9) {\n+                        updateState(c.getUID(), UnDefType.UNDEF);\n+                    } else {\n+                        updateState(c.getUID(), new DecimalType(value));\n+                    }\n+                } else {\n+                    updateState(c.getUID(), UnDefType.NULL);\n+                }\n+            });\n+        }\n+        // Loop through daily forecasts and updates those available\n+        for (int i = 0; i < 10; i++) {\n+            List<Channel> channels = thing.getChannelsOfGroup(\"day_\" + i);\n+            if (channels.isEmpty()) {\n+                continue;\n+            }\n+            Forecast forecast;\n+            try {\n+                forecast = timeSeries.getForecast(currentDay, 24 * i + 12);\n+            } catch (NoSuchElementException e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI2NDQzOQ=="}, "originalCommit": {"oid": "7ae7bd48b32ca057a99676ae00d993b4c822ffd4"}, "originalPosition": 191}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NzIzODQ2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiHandler.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxOTo0NzoyMFrOGYbV6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxNjowNzowNFrOGY5IoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI2Njk4Ng==", "bodyText": "What type of exception are you catching here? If you want to catch a RuntimeException, you should catch for the exact type.", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r428266986", "createdAt": "2020-05-20T19:47:20Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiHandler.java", "diffHunk": "@@ -0,0 +1,350 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smhi.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerCallback;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.math.BigDecimal;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.*;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.openhab.binding.smhi.internal.SmhiBindingConstants.*;\n+\n+/**\n+ * The {@link SmhiHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmhiHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SmhiHandler.class);\n+\n+    private @NonNullByDefault({}) SmhiConfiguration config;\n+\n+    private final HttpClient httpClient;\n+    private @NonNullByDefault({}) SmhiConnector connection;\n+    private ZonedDateTime currentHour;\n+    private ZonedDateTime currentDay;\n+    private @Nullable TimeSeries cachedTimeSeries;\n+    private boolean hasLatestForecast = false;\n+    private @Nullable Future<?> forecastUpdater;\n+    private @Nullable Future<?> instantUpdate;\n+\n+    public SmhiHandler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.currentHour = calculateCurrentHour();\n+        this.currentDay = calculateCurrentDay();\n+    }\n+\n+    /**\n+     * Handles commands sent to channels. Since all values are read-only, only REFRESH commands are allowed.\n+     * Sending REFRESH to any item updates all items, since all values are returned in the response from Smhi.\n+     * Therefore there's a wait of 5 seconds before the values are fetched, in which time all other commands are\n+     * blocked, to prevent spamming Smhi's API.\n+     *\n+     * @param channelUID\n+     * @param command\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            synchronized (this) {\n+                Future<?> localRef = instantUpdate;\n+                if (localRef == null || localRef.isDone() || localRef.isCancelled()) {\n+                    instantUpdate = scheduler.schedule(this::getUpdatedForecast, 5, TimeUnit.SECONDS);\n+                } else {\n+                    logger.debug(\"Already waiting for scheduled refresh\");\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(SmhiConfiguration.class);\n+        if (config == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+            return;\n+        }\n+        connection = new SmhiConnector(httpClient);\n+\n+        //Check which channel groups are selected in the config.\n+        List<Channel> channels = new ArrayList<>();\n+        channels.addAll(createChannels());\n+        updateThing(editThing().withChannels(channels).build());\n+\n+        startPolling();\n+        updateStatus(ThingStatus.ONLINE);\n+        synchronized (this) {\n+            Future<?> localRef = instantUpdate;\n+            if (localRef == null || localRef.isDone() || localRef.isCancelled()) {\n+                instantUpdate = scheduler.schedule(this::getUpdatedForecast, 5, TimeUnit.SECONDS);\n+            } else {\n+                logger.debug(\"Already waiting for scheduled refresh\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Start polling wor updated weather forecast.\n+     */\n+    private synchronized void startPolling() {\n+        forecastUpdater = scheduler.scheduleWithFixedDelay(this::waitForForecast, 1, 1, TimeUnit.MINUTES);\n+    }\n+\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        if (!isModifyingCurrentConfig(configurationParameters)) {\n+            return;\n+        }\n+\n+        validateConfigurationParameters(configurationParameters);\n+\n+        Configuration configuration = editConfiguration();\n+        for (Map.Entry<String, Object> configurationParameter : configurationParameters.entrySet()) {\n+            configuration.put(configurationParameter.getKey(), configurationParameter.getValue());\n+        }\n+\n+        if (isInitialized()) {\n+            updateConfiguration(configuration);\n+            config = configuration.as(SmhiConfiguration.class);\n+            updateThing(editThing().withChannels(createChannels()).build());\n+        } else {\n+            // persist new configuration and notify Thing Manager\n+            updateConfiguration(configuration);\n+            ThingHandlerCallback callback = getCallback();\n+            if (callback != null) {\n+                callback.configurationUpdated(this.getThing());\n+            } else {\n+                logger.warn(\"Handler {} tried updating its configuration although the handler was already disposed.\",\n+                        this.getClass().getSimpleName());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update channels with new forecast data.\n+     * @param timeSeries A {@link TimeSeries} object containing forecasts.\n+     */\n+    private void updateChannels(TimeSeries timeSeries) {\n+        // Loop through hourly forecasts and update those available\n+        for (int i = 0; i < 25; i++) {\n+            List<Channel> channels = thing.getChannelsOfGroup(\"hour_\" + i);\n+            if (channels.isEmpty()) {\n+                continue;\n+            }\n+            Forecast forecast = timeSeries.getForecast(i);\n+            channels.forEach(c -> {\n+                String id = c.getUID().getIdWithoutGroup();\n+                BigDecimal value = forecast.getParameter(id);\n+                if (value != null) {\n+                    // Smhi returns -9 for spp if there's no precipitation, convert to UNDEF\n+                    if (id.equals(PERCENT_FROZEN) && value.intValue() == -9) {\n+                        updateState(c.getUID(), UnDefType.UNDEF);\n+                    } else {\n+                        updateState(c.getUID(), new DecimalType(value));\n+                    }\n+                } else {\n+                    updateState(c.getUID(), UnDefType.NULL);\n+                }\n+            });\n+        }\n+        // Loop through daily forecasts and updates those available\n+        for (int i = 0; i < 10; i++) {\n+            List<Channel> channels = thing.getChannelsOfGroup(\"day_\" + i);\n+            if (channels.isEmpty()) {\n+                continue;\n+            }\n+            Forecast forecast;\n+            try {\n+                forecast = timeSeries.getForecast(currentDay, 24 * i + 12);\n+            } catch (NoSuchElementException e) {\n+                logger.info(\"No forecast yet for {}\", currentDay.plusHours(24 * i + 12));\n+                channels.forEach(c -> {\n+                    updateState(c.getUID(), UnDefType.NULL);\n+                });\n+                continue;\n+            }\n+            channels.forEach(c -> {\n+                String id = c.getUID().getIdWithoutGroup();\n+                BigDecimal value = forecast.getParameter(id);\n+                if (value != null) {\n+                    // Smhi returns -9 for spp if there's no precipitation, convert to UNDEF\n+                    if (id.equals(PERCENT_FROZEN) && value.intValue() == -9) {\n+                        updateState(c.getUID(), UnDefType.UNDEF);\n+                    } else {\n+                        updateState(c.getUID(), new DecimalType(value));\n+                    }\n+                } else {\n+                    updateState(c.getUID(), UnDefType.NULL);\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Dispose the {@link org.eclipse.smarthome.core.thing.binding.ThingHandler}. Cancel scheduled jobs\n+     */\n+    public void dispose() {\n+        Future<?> localRef = forecastUpdater;\n+        if (localRef != null) {\n+            localRef.cancel(false);\n+        }\n+    }\n+\n+    /**\n+     * First check if the time has shifted to a new hour, then start checking if a new forecast have been\n+     * published, in that case, fetch it and update channels.\n+     */\n+    private void waitForForecast() {\n+        try {\n+            if (isItNewHour()) {\n+                currentHour = calculateCurrentHour();\n+                currentDay = calculateCurrentDay();\n+                // Update channels with cached forecasts - just shift an hour forward\n+                TimeSeries forecast = cachedTimeSeries;\n+                if (forecast != null) {\n+                    updateChannels(forecast);\n+                }\n+                hasLatestForecast = false;\n+            }\n+            if (!hasLatestForecast && isForecastUpdated()) {\n+                getUpdatedForecast();\n+            }\n+        } catch (Exception e) {\n+            logger.debug(\"Something went wrong: \", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ae7bd48b32ca057a99676ae00d993b4c822ffd4"}, "originalPosition": 245}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODU1MDk1Ng==", "bodyText": "This was to catch the exceptions thrown by getReferenceTime() and getForecast(), but thought I would make sure to not miss anything. Have caught these in other methods now though, so might be able to remove this now. Will require some testing to make sure nothing breaks.", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r428550956", "createdAt": "2020-05-21T09:41:17Z", "author": {"login": "pacive"}, "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiHandler.java", "diffHunk": "@@ -0,0 +1,350 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smhi.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerCallback;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.math.BigDecimal;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.*;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.openhab.binding.smhi.internal.SmhiBindingConstants.*;\n+\n+/**\n+ * The {@link SmhiHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmhiHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SmhiHandler.class);\n+\n+    private @NonNullByDefault({}) SmhiConfiguration config;\n+\n+    private final HttpClient httpClient;\n+    private @NonNullByDefault({}) SmhiConnector connection;\n+    private ZonedDateTime currentHour;\n+    private ZonedDateTime currentDay;\n+    private @Nullable TimeSeries cachedTimeSeries;\n+    private boolean hasLatestForecast = false;\n+    private @Nullable Future<?> forecastUpdater;\n+    private @Nullable Future<?> instantUpdate;\n+\n+    public SmhiHandler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.currentHour = calculateCurrentHour();\n+        this.currentDay = calculateCurrentDay();\n+    }\n+\n+    /**\n+     * Handles commands sent to channels. Since all values are read-only, only REFRESH commands are allowed.\n+     * Sending REFRESH to any item updates all items, since all values are returned in the response from Smhi.\n+     * Therefore there's a wait of 5 seconds before the values are fetched, in which time all other commands are\n+     * blocked, to prevent spamming Smhi's API.\n+     *\n+     * @param channelUID\n+     * @param command\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            synchronized (this) {\n+                Future<?> localRef = instantUpdate;\n+                if (localRef == null || localRef.isDone() || localRef.isCancelled()) {\n+                    instantUpdate = scheduler.schedule(this::getUpdatedForecast, 5, TimeUnit.SECONDS);\n+                } else {\n+                    logger.debug(\"Already waiting for scheduled refresh\");\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(SmhiConfiguration.class);\n+        if (config == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+            return;\n+        }\n+        connection = new SmhiConnector(httpClient);\n+\n+        //Check which channel groups are selected in the config.\n+        List<Channel> channels = new ArrayList<>();\n+        channels.addAll(createChannels());\n+        updateThing(editThing().withChannels(channels).build());\n+\n+        startPolling();\n+        updateStatus(ThingStatus.ONLINE);\n+        synchronized (this) {\n+            Future<?> localRef = instantUpdate;\n+            if (localRef == null || localRef.isDone() || localRef.isCancelled()) {\n+                instantUpdate = scheduler.schedule(this::getUpdatedForecast, 5, TimeUnit.SECONDS);\n+            } else {\n+                logger.debug(\"Already waiting for scheduled refresh\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Start polling wor updated weather forecast.\n+     */\n+    private synchronized void startPolling() {\n+        forecastUpdater = scheduler.scheduleWithFixedDelay(this::waitForForecast, 1, 1, TimeUnit.MINUTES);\n+    }\n+\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        if (!isModifyingCurrentConfig(configurationParameters)) {\n+            return;\n+        }\n+\n+        validateConfigurationParameters(configurationParameters);\n+\n+        Configuration configuration = editConfiguration();\n+        for (Map.Entry<String, Object> configurationParameter : configurationParameters.entrySet()) {\n+            configuration.put(configurationParameter.getKey(), configurationParameter.getValue());\n+        }\n+\n+        if (isInitialized()) {\n+            updateConfiguration(configuration);\n+            config = configuration.as(SmhiConfiguration.class);\n+            updateThing(editThing().withChannels(createChannels()).build());\n+        } else {\n+            // persist new configuration and notify Thing Manager\n+            updateConfiguration(configuration);\n+            ThingHandlerCallback callback = getCallback();\n+            if (callback != null) {\n+                callback.configurationUpdated(this.getThing());\n+            } else {\n+                logger.warn(\"Handler {} tried updating its configuration although the handler was already disposed.\",\n+                        this.getClass().getSimpleName());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update channels with new forecast data.\n+     * @param timeSeries A {@link TimeSeries} object containing forecasts.\n+     */\n+    private void updateChannels(TimeSeries timeSeries) {\n+        // Loop through hourly forecasts and update those available\n+        for (int i = 0; i < 25; i++) {\n+            List<Channel> channels = thing.getChannelsOfGroup(\"hour_\" + i);\n+            if (channels.isEmpty()) {\n+                continue;\n+            }\n+            Forecast forecast = timeSeries.getForecast(i);\n+            channels.forEach(c -> {\n+                String id = c.getUID().getIdWithoutGroup();\n+                BigDecimal value = forecast.getParameter(id);\n+                if (value != null) {\n+                    // Smhi returns -9 for spp if there's no precipitation, convert to UNDEF\n+                    if (id.equals(PERCENT_FROZEN) && value.intValue() == -9) {\n+                        updateState(c.getUID(), UnDefType.UNDEF);\n+                    } else {\n+                        updateState(c.getUID(), new DecimalType(value));\n+                    }\n+                } else {\n+                    updateState(c.getUID(), UnDefType.NULL);\n+                }\n+            });\n+        }\n+        // Loop through daily forecasts and updates those available\n+        for (int i = 0; i < 10; i++) {\n+            List<Channel> channels = thing.getChannelsOfGroup(\"day_\" + i);\n+            if (channels.isEmpty()) {\n+                continue;\n+            }\n+            Forecast forecast;\n+            try {\n+                forecast = timeSeries.getForecast(currentDay, 24 * i + 12);\n+            } catch (NoSuchElementException e) {\n+                logger.info(\"No forecast yet for {}\", currentDay.plusHours(24 * i + 12));\n+                channels.forEach(c -> {\n+                    updateState(c.getUID(), UnDefType.NULL);\n+                });\n+                continue;\n+            }\n+            channels.forEach(c -> {\n+                String id = c.getUID().getIdWithoutGroup();\n+                BigDecimal value = forecast.getParameter(id);\n+                if (value != null) {\n+                    // Smhi returns -9 for spp if there's no precipitation, convert to UNDEF\n+                    if (id.equals(PERCENT_FROZEN) && value.intValue() == -9) {\n+                        updateState(c.getUID(), UnDefType.UNDEF);\n+                    } else {\n+                        updateState(c.getUID(), new DecimalType(value));\n+                    }\n+                } else {\n+                    updateState(c.getUID(), UnDefType.NULL);\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Dispose the {@link org.eclipse.smarthome.core.thing.binding.ThingHandler}. Cancel scheduled jobs\n+     */\n+    public void dispose() {\n+        Future<?> localRef = forecastUpdater;\n+        if (localRef != null) {\n+            localRef.cancel(false);\n+        }\n+    }\n+\n+    /**\n+     * First check if the time has shifted to a new hour, then start checking if a new forecast have been\n+     * published, in that case, fetch it and update channels.\n+     */\n+    private void waitForForecast() {\n+        try {\n+            if (isItNewHour()) {\n+                currentHour = calculateCurrentHour();\n+                currentDay = calculateCurrentDay();\n+                // Update channels with cached forecasts - just shift an hour forward\n+                TimeSeries forecast = cachedTimeSeries;\n+                if (forecast != null) {\n+                    updateChannels(forecast);\n+                }\n+                hasLatestForecast = false;\n+            }\n+            if (!hasLatestForecast && isForecastUpdated()) {\n+                getUpdatedForecast();\n+            }\n+        } catch (Exception e) {\n+            logger.debug(\"Something went wrong: \", e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI2Njk4Ng=="}, "originalCommit": {"oid": "7ae7bd48b32ca057a99676ae00d993b4c822ffd4"}, "originalPosition": 245}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODc1NTEwNA==", "bodyText": "Here you see the disadvantage about unchecked Exceptions. If you would throw a checked Exception, the compiler would complain if you miss to catch the Exception here.", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r428755104", "createdAt": "2020-05-21T16:07:04Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiHandler.java", "diffHunk": "@@ -0,0 +1,350 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smhi.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerCallback;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.math.BigDecimal;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.*;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.openhab.binding.smhi.internal.SmhiBindingConstants.*;\n+\n+/**\n+ * The {@link SmhiHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmhiHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SmhiHandler.class);\n+\n+    private @NonNullByDefault({}) SmhiConfiguration config;\n+\n+    private final HttpClient httpClient;\n+    private @NonNullByDefault({}) SmhiConnector connection;\n+    private ZonedDateTime currentHour;\n+    private ZonedDateTime currentDay;\n+    private @Nullable TimeSeries cachedTimeSeries;\n+    private boolean hasLatestForecast = false;\n+    private @Nullable Future<?> forecastUpdater;\n+    private @Nullable Future<?> instantUpdate;\n+\n+    public SmhiHandler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.currentHour = calculateCurrentHour();\n+        this.currentDay = calculateCurrentDay();\n+    }\n+\n+    /**\n+     * Handles commands sent to channels. Since all values are read-only, only REFRESH commands are allowed.\n+     * Sending REFRESH to any item updates all items, since all values are returned in the response from Smhi.\n+     * Therefore there's a wait of 5 seconds before the values are fetched, in which time all other commands are\n+     * blocked, to prevent spamming Smhi's API.\n+     *\n+     * @param channelUID\n+     * @param command\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            synchronized (this) {\n+                Future<?> localRef = instantUpdate;\n+                if (localRef == null || localRef.isDone() || localRef.isCancelled()) {\n+                    instantUpdate = scheduler.schedule(this::getUpdatedForecast, 5, TimeUnit.SECONDS);\n+                } else {\n+                    logger.debug(\"Already waiting for scheduled refresh\");\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(SmhiConfiguration.class);\n+        if (config == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+            return;\n+        }\n+        connection = new SmhiConnector(httpClient);\n+\n+        //Check which channel groups are selected in the config.\n+        List<Channel> channels = new ArrayList<>();\n+        channels.addAll(createChannels());\n+        updateThing(editThing().withChannels(channels).build());\n+\n+        startPolling();\n+        updateStatus(ThingStatus.ONLINE);\n+        synchronized (this) {\n+            Future<?> localRef = instantUpdate;\n+            if (localRef == null || localRef.isDone() || localRef.isCancelled()) {\n+                instantUpdate = scheduler.schedule(this::getUpdatedForecast, 5, TimeUnit.SECONDS);\n+            } else {\n+                logger.debug(\"Already waiting for scheduled refresh\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Start polling wor updated weather forecast.\n+     */\n+    private synchronized void startPolling() {\n+        forecastUpdater = scheduler.scheduleWithFixedDelay(this::waitForForecast, 1, 1, TimeUnit.MINUTES);\n+    }\n+\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        if (!isModifyingCurrentConfig(configurationParameters)) {\n+            return;\n+        }\n+\n+        validateConfigurationParameters(configurationParameters);\n+\n+        Configuration configuration = editConfiguration();\n+        for (Map.Entry<String, Object> configurationParameter : configurationParameters.entrySet()) {\n+            configuration.put(configurationParameter.getKey(), configurationParameter.getValue());\n+        }\n+\n+        if (isInitialized()) {\n+            updateConfiguration(configuration);\n+            config = configuration.as(SmhiConfiguration.class);\n+            updateThing(editThing().withChannels(createChannels()).build());\n+        } else {\n+            // persist new configuration and notify Thing Manager\n+            updateConfiguration(configuration);\n+            ThingHandlerCallback callback = getCallback();\n+            if (callback != null) {\n+                callback.configurationUpdated(this.getThing());\n+            } else {\n+                logger.warn(\"Handler {} tried updating its configuration although the handler was already disposed.\",\n+                        this.getClass().getSimpleName());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update channels with new forecast data.\n+     * @param timeSeries A {@link TimeSeries} object containing forecasts.\n+     */\n+    private void updateChannels(TimeSeries timeSeries) {\n+        // Loop through hourly forecasts and update those available\n+        for (int i = 0; i < 25; i++) {\n+            List<Channel> channels = thing.getChannelsOfGroup(\"hour_\" + i);\n+            if (channels.isEmpty()) {\n+                continue;\n+            }\n+            Forecast forecast = timeSeries.getForecast(i);\n+            channels.forEach(c -> {\n+                String id = c.getUID().getIdWithoutGroup();\n+                BigDecimal value = forecast.getParameter(id);\n+                if (value != null) {\n+                    // Smhi returns -9 for spp if there's no precipitation, convert to UNDEF\n+                    if (id.equals(PERCENT_FROZEN) && value.intValue() == -9) {\n+                        updateState(c.getUID(), UnDefType.UNDEF);\n+                    } else {\n+                        updateState(c.getUID(), new DecimalType(value));\n+                    }\n+                } else {\n+                    updateState(c.getUID(), UnDefType.NULL);\n+                }\n+            });\n+        }\n+        // Loop through daily forecasts and updates those available\n+        for (int i = 0; i < 10; i++) {\n+            List<Channel> channels = thing.getChannelsOfGroup(\"day_\" + i);\n+            if (channels.isEmpty()) {\n+                continue;\n+            }\n+            Forecast forecast;\n+            try {\n+                forecast = timeSeries.getForecast(currentDay, 24 * i + 12);\n+            } catch (NoSuchElementException e) {\n+                logger.info(\"No forecast yet for {}\", currentDay.plusHours(24 * i + 12));\n+                channels.forEach(c -> {\n+                    updateState(c.getUID(), UnDefType.NULL);\n+                });\n+                continue;\n+            }\n+            channels.forEach(c -> {\n+                String id = c.getUID().getIdWithoutGroup();\n+                BigDecimal value = forecast.getParameter(id);\n+                if (value != null) {\n+                    // Smhi returns -9 for spp if there's no precipitation, convert to UNDEF\n+                    if (id.equals(PERCENT_FROZEN) && value.intValue() == -9) {\n+                        updateState(c.getUID(), UnDefType.UNDEF);\n+                    } else {\n+                        updateState(c.getUID(), new DecimalType(value));\n+                    }\n+                } else {\n+                    updateState(c.getUID(), UnDefType.NULL);\n+                }\n+            });\n+        }\n+    }\n+\n+    /**\n+     * Dispose the {@link org.eclipse.smarthome.core.thing.binding.ThingHandler}. Cancel scheduled jobs\n+     */\n+    public void dispose() {\n+        Future<?> localRef = forecastUpdater;\n+        if (localRef != null) {\n+            localRef.cancel(false);\n+        }\n+    }\n+\n+    /**\n+     * First check if the time has shifted to a new hour, then start checking if a new forecast have been\n+     * published, in that case, fetch it and update channels.\n+     */\n+    private void waitForForecast() {\n+        try {\n+            if (isItNewHour()) {\n+                currentHour = calculateCurrentHour();\n+                currentDay = calculateCurrentDay();\n+                // Update channels with cached forecasts - just shift an hour forward\n+                TimeSeries forecast = cachedTimeSeries;\n+                if (forecast != null) {\n+                    updateChannels(forecast);\n+                }\n+                hasLatestForecast = false;\n+            }\n+            if (!hasLatestForecast && isForecastUpdated()) {\n+                getUpdatedForecast();\n+            }\n+        } catch (Exception e) {\n+            logger.debug(\"Something went wrong: \", e);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI2Njk4Ng=="}, "originalCommit": {"oid": "7ae7bd48b32ca057a99676ae00d993b4c822ffd4"}, "originalPosition": 245}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NzI0Mjg0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiHandlerFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxOTo0ODo0MlrOGYbYnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxMjowMDo1NFrOGYwP3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI2NzY3Nw==", "bodyText": "See above", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r428267677", "createdAt": "2020-05-20T19:48:42Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiHandlerFactory.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smhi.internal;\n+\n+import static org.openhab.binding.smhi.internal.SmhiBindingConstants.*;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ae7bd48b32ca057a99676ae00d993b4c822ffd4"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODYwOTUwMw==", "bodyText": "Constants", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r428609503", "createdAt": "2020-05-21T12:00:54Z", "author": {"login": "pacive"}, "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiHandlerFactory.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smhi.internal;\n+\n+import static org.openhab.binding.smhi.internal.SmhiBindingConstants.*;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI2NzY3Nw=="}, "originalCommit": {"oid": "7ae7bd48b32ca057a99676ae00d993b4c822ffd4"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NzI0NDE4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/TimeSeries.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxOTo0OToxMFrOGYbZiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxOTo0OToxMFrOGYbZiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI2NzkxNQ==", "bodyText": "See above", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r428267915", "createdAt": "2020-05-20T19:49:10Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/TimeSeries.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.smhi.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+import java.time.ZonedDateTime;\n+import java.util.*;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ae7bd48b32ca057a99676ae00d993b4c822ffd4"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NzI1MzUzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.smhi/src/main/resources/ESH-INF/binding/binding.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxOTo1MjowN1rOGYbflQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxOTo1MjowN1rOGYbflQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI2OTQ2MQ==", "bodyText": "I'd write \"smhi\" out, to let the user know this binding is only useful for swedish locations.", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r428269461", "createdAt": "2020-05-20T19:52:07Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.smhi/src/main/resources/ESH-INF/binding/binding.xml", "diffHunk": "@@ -0,0 +1,10 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<binding:binding id=\"smhi\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:binding=\"https://openhab.org/schemas/binding/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/binding/v1.0.0 https://openhab.org/schemas/binding-1.0.0.xsd\">\n+\n+\t<name>Smhi Binding</name>\n+\t<description>Binding for getting weather forecasts from smhi</description>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ae7bd48b32ca057a99676ae00d993b4c822ffd4"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NzI2MjM5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.smhi/src/main/resources/ESH-INF/config/forecast-config.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxOTo1NDo1NFrOGYblWw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQwOTo0NDoxOFrOGYswMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI3MDkzOQ==", "bodyText": "Is there a reason that you state the 00: prefix? Would \"Current hour\" be sufficent?", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r428270939", "createdAt": "2020-05-20T19:54:54Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.smhi/src/main/resources/ESH-INF/config/forecast-config.xml", "diffHunk": "@@ -0,0 +1,68 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<config-description:config-descriptions\n+\t\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\t\txmlns:config-description=\"https://openhab.org/schemas/config-description/v1.0.0\"\n+\t\txsi:schemaLocation=\"https://openhab.org/schemas/config-description/v1.0.0\n+\t\thttps://openhab.org/schemas/config-description-1.0.0.xsd\">\n+\n+\t<config-description uri=\"thing-type:smhi:forecast\">\n+\t\t<parameter name=\"latitude\" type=\"decimal\" required=\"true\">\n+\t\t\t<label>Latitude</label>\n+\t\t\t<description>Latitude for the forecast</description>\n+\t\t</parameter>\n+\t\t<parameter name=\"longitude\" type=\"decimal\" required=\"true\">\n+\t\t\t<label>Longitude</label>\n+\t\t\t<description>Longitude for the forecast</description>\n+\t\t</parameter>\n+\t\t<parameter name=\"hourlyForecasts\" type=\"integer\" multiple=\"true\">\n+\t\t\t<label>Hourly forecasts</label>\n+\t\t\t<description>The hourly forecasts to display</description>\n+\t\t\t<limitToOptions>true</limitToOptions>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"0\">00: Current hour</option>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ae7bd48b32ca057a99676ae00d993b4c822ffd4"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODU1MjI0MA==", "bodyText": "That's a workaround because paperUI sorts the option alphabetically, regardless of the order the options are specified. See openhab/openhab-webui#212", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r428552240", "createdAt": "2020-05-21T09:44:18Z", "author": {"login": "pacive"}, "path": "bundles/org.openhab.binding.smhi/src/main/resources/ESH-INF/config/forecast-config.xml", "diffHunk": "@@ -0,0 +1,68 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<config-description:config-descriptions\n+\t\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\t\txmlns:config-description=\"https://openhab.org/schemas/config-description/v1.0.0\"\n+\t\txsi:schemaLocation=\"https://openhab.org/schemas/config-description/v1.0.0\n+\t\thttps://openhab.org/schemas/config-description-1.0.0.xsd\">\n+\n+\t<config-description uri=\"thing-type:smhi:forecast\">\n+\t\t<parameter name=\"latitude\" type=\"decimal\" required=\"true\">\n+\t\t\t<label>Latitude</label>\n+\t\t\t<description>Latitude for the forecast</description>\n+\t\t</parameter>\n+\t\t<parameter name=\"longitude\" type=\"decimal\" required=\"true\">\n+\t\t\t<label>Longitude</label>\n+\t\t\t<description>Longitude for the forecast</description>\n+\t\t</parameter>\n+\t\t<parameter name=\"hourlyForecasts\" type=\"integer\" multiple=\"true\">\n+\t\t\t<label>Hourly forecasts</label>\n+\t\t\t<description>The hourly forecasts to display</description>\n+\t\t\t<limitToOptions>true</limitToOptions>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"0\">00: Current hour</option>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI3MDkzOQ=="}, "originalCommit": {"oid": "7ae7bd48b32ca057a99676ae00d993b4c822ffd4"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2NzI3NTM0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.smhi/src/main/resources/ESH-INF/thing/thing-types.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxOTo1ODo1M1rOGYbtlg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxOTo1ODo1M1rOGYbtlg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI3MzA0Ng==", "bodyText": "I'd write it consistently in upper letters or camelcase.", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r428273046", "createdAt": "2020-05-20T19:58:53Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.smhi/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,157 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"smhi\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"forecast\">\n+\t\t<label>Smhi Weather forecast</label>\n+\t\t<description>Gets weather forecasts from SMHI</description>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ae7bd48b32ca057a99676ae00d993b4c822ffd4"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3ODczNTQ3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.smhi/src/main/feature/feature.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQyMDoxNzozMVrOGaJFQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQyMDoxNzozMVrOGaJFQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA2NDk2Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t<feature name=\"openhab-binding-smhi\" description=\"Smhi Binding\" version=\"${project.version}\">\n          \n          \n            \n            \t<feature name=\"openhab-binding-smhi\" description=\"SMHI Binding\" version=\"${project.version}\">", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r430064963", "createdAt": "2020-05-25T20:17:31Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.smhi/src/main/feature/feature.xml", "diffHunk": "@@ -0,0 +1,9 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<features name=\"org.openhab.binding.smhi-${project.version}\" xmlns=\"http://karaf.apache.org/xmlns/features/v1.4.0\">\n+\t<repository>mvn:org.openhab.core.features.karaf/org.openhab.core.features.karaf.openhab-core/${ohc.version}/xml/features</repository>\n+\n+\t<feature name=\"openhab-binding-smhi\" description=\"Smhi Binding\" version=\"${project.version}\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9dc268556a10edf32791015ba499006820297240"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3ODc0OTgyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiConnector.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQyMDoyNzo1MFrOGaJNSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQyMDoyNzo1MFrOGaJNSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA2NzAxOA==", "bodyText": "You should pass the exception to SmhiException to be able to produce an appropriate error message. Or log it here.", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r430067018", "createdAt": "2020-05-25T20:27:50Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiConnector.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.smhi.internal;\n+\n+import static org.openhab.binding.smhi.internal.SmhiBindingConstants.*;\n+\n+import java.time.ZonedDateTime;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for handling http requests to Smhi's API and return values.\n+ *\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmhiConnector {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SmhiConnector.class);\n+\n+    private static final String ACCEPT = \"application/json\";\n+\n+    private final HttpClient httpClient;\n+\n+    public SmhiConnector(HttpClient httpClient) {\n+        this.httpClient = httpClient;\n+    }\n+\n+    /**\n+     * Get the reference time (the time when the forecast starts) of the latest published forecast\n+     * \n+     * @return A {@link ZonedDateTime} with the time of the latest forecast.\n+     */\n+    public ZonedDateTime getReferenceTime() throws SmhiException {\n+        logger.debug(\"Fetching reference time\");\n+        Request req = httpClient.newRequest(APPROVED_TIME_URL);\n+        req.accept(ACCEPT);\n+        ContentResponse resp;\n+        try {\n+            resp = req.send();\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            throw new SmhiException();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9dc268556a10edf32791015ba499006820297240"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3ODc1MDcxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiConnector.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQyMDoyODozM1rOGaJNzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQyMDoyODozM1rOGaJNzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA2NzE1MA==", "bodyText": "See above", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r430067150", "createdAt": "2020-05-25T20:28:33Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiConnector.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.smhi.internal;\n+\n+import static org.openhab.binding.smhi.internal.SmhiBindingConstants.*;\n+\n+import java.time.ZonedDateTime;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentResponse;\n+import org.eclipse.jetty.client.api.Request;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class for handling http requests to Smhi's API and return values.\n+ *\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmhiConnector {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SmhiConnector.class);\n+\n+    private static final String ACCEPT = \"application/json\";\n+\n+    private final HttpClient httpClient;\n+\n+    public SmhiConnector(HttpClient httpClient) {\n+        this.httpClient = httpClient;\n+    }\n+\n+    /**\n+     * Get the reference time (the time when the forecast starts) of the latest published forecast\n+     * \n+     * @return A {@link ZonedDateTime} with the time of the latest forecast.\n+     */\n+    public ZonedDateTime getReferenceTime() throws SmhiException {\n+        logger.debug(\"Fetching reference time\");\n+        Request req = httpClient.newRequest(APPROVED_TIME_URL);\n+        req.accept(ACCEPT);\n+        ContentResponse resp;\n+        try {\n+            resp = req.send();\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            throw new SmhiException();\n+        }\n+        return Parser.parseApprovedTime(resp.getContentAsString());\n+    }\n+\n+    /**\n+     * Get a forecast for the specified WGS84 coordinates.\n+     * \n+     * @param lat Latitude\n+     * @param lon Longitude\n+     * @return A {@link TimeSeries} object containing the published forecasts.\n+     */\n+    public TimeSeries getForecast(double lat, double lon) throws SmhiException {\n+        logger.debug(\"Fetching new forecast\");\n+        String url = String.format(POINT_FORECAST_URL, lon, lat);\n+        Request req = httpClient.newRequest(url);\n+        req.accept(ACCEPT);\n+        ContentResponse resp;\n+        try {\n+            resp = req.send();\n+        } catch (InterruptedException | TimeoutException | ExecutionException e) {\n+            throw new SmhiException();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9dc268556a10edf32791015ba499006820297240"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3ODc2MTMzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQyMDozNjoyNlrOGaJT5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQyMDozNjoyNlrOGaJT5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA2ODcxMQ==", "bodyText": "You should make this Nullable. I have seen handleCommand() to be invoked asynchronously, before initialize() has been finished.", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r430068711", "createdAt": "2020-05-25T20:36:26Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiHandler.java", "diffHunk": "@@ -0,0 +1,381 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smhi.internal;\n+\n+import static org.openhab.binding.smhi.internal.SmhiBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelGroupUID;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerCallback;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SmhiHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmhiHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SmhiHandler.class);\n+\n+    private @NonNullByDefault({}) SmhiConfiguration config;\n+\n+    private final HttpClient httpClient;\n+    private @NonNullByDefault({}) SmhiConnector connection;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9dc268556a10edf32791015ba499006820297240"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3ODc3NzIxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.smhi/src/main/resources/ESH-INF/config/forecast-config.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQyMDo0ODo0NFrOGaJdHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQyMDo0ODo0NFrOGaJdHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA3MTA2OA==", "bodyText": "Words in labels must be capitalized: https://www.openhab.org/docs/developer/bindings/thing-xml.html#formatting-labels-and-descriptions", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r430071068", "createdAt": "2020-05-25T20:48:44Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.smhi/src/main/resources/ESH-INF/config/forecast-config.xml", "diffHunk": "@@ -0,0 +1,68 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<config-description:config-descriptions\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:config-description=\"https://openhab.org/schemas/config-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/config-description/v1.0.0\n+\t\thttps://openhab.org/schemas/config-description-1.0.0.xsd\">\n+\n+\t<config-description uri=\"thing-type:smhi:forecast\">\n+\t\t<parameter name=\"latitude\" type=\"decimal\" required=\"true\">\n+\t\t\t<label>Latitude</label>\n+\t\t\t<description>Latitude for the forecast</description>\n+\t\t</parameter>\n+\t\t<parameter name=\"longitude\" type=\"decimal\" required=\"true\">\n+\t\t\t<label>Longitude</label>\n+\t\t\t<description>Longitude for the forecast</description>\n+\t\t</parameter>\n+\t\t<parameter name=\"hourlyForecasts\" type=\"integer\" multiple=\"true\">\n+\t\t\t<label>Hourly forecasts</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9dc268556a10edf32791015ba499006820297240"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3ODc3NzY2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.smhi/src/main/resources/ESH-INF/config/forecast-config.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQyMDo0OToxMlrOGaJdaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQyMDo0OToxMlrOGaJdaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA3MTE0NQ==", "bodyText": "See above", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r430071145", "createdAt": "2020-05-25T20:49:12Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.smhi/src/main/resources/ESH-INF/config/forecast-config.xml", "diffHunk": "@@ -0,0 +1,68 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<config-description:config-descriptions\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:config-description=\"https://openhab.org/schemas/config-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/config-description/v1.0.0\n+\t\thttps://openhab.org/schemas/config-description-1.0.0.xsd\">\n+\n+\t<config-description uri=\"thing-type:smhi:forecast\">\n+\t\t<parameter name=\"latitude\" type=\"decimal\" required=\"true\">\n+\t\t\t<label>Latitude</label>\n+\t\t\t<description>Latitude for the forecast</description>\n+\t\t</parameter>\n+\t\t<parameter name=\"longitude\" type=\"decimal\" required=\"true\">\n+\t\t\t<label>Longitude</label>\n+\t\t\t<description>Longitude for the forecast</description>\n+\t\t</parameter>\n+\t\t<parameter name=\"hourlyForecasts\" type=\"integer\" multiple=\"true\">\n+\t\t\t<label>Hourly forecasts</label>\n+\t\t\t<description>The hourly forecasts to display</description>\n+\t\t\t<limitToOptions>true</limitToOptions>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"0\">00: Current hour</option>\n+\t\t\t\t<option value=\"1\">01: Next hour</option>\n+\t\t\t\t<option value=\"2\">02: 2 hours from now</option>\n+\t\t\t\t<option value=\"3\">03: 3 hours from now</option>\n+\t\t\t\t<option value=\"4\">04: 4 hours from now</option>\n+\t\t\t\t<option value=\"5\">05: 5 hours from now</option>\n+\t\t\t\t<option value=\"6\">06: 6 hours from now</option>\n+\t\t\t\t<option value=\"7\">07: 7 hours from now</option>\n+\t\t\t\t<option value=\"8\">08: 8 hours from now</option>\n+\t\t\t\t<option value=\"9\">09: 9 hours from now</option>\n+\t\t\t\t<option value=\"10\">10: 10 hours from now</option>\n+\t\t\t\t<option value=\"11\">11: 11 hours from now</option>\n+\t\t\t\t<option value=\"12\">12: 12 hours from now</option>\n+\t\t\t\t<option value=\"13\">13: 13 hours from now</option>\n+\t\t\t\t<option value=\"14\">14: 14 hours from now</option>\n+\t\t\t\t<option value=\"15\">15: 15 hours from now</option>\n+\t\t\t\t<option value=\"16\">16: 16 hours from now</option>\n+\t\t\t\t<option value=\"17\">17: 17 hours from now</option>\n+\t\t\t\t<option value=\"18\">18: 18 hours from now</option>\n+\t\t\t\t<option value=\"19\">19: 19 hours from now</option>\n+\t\t\t\t<option value=\"20\">20: 20 hours from now</option>\n+\t\t\t\t<option value=\"21\">21: 21 hours from now</option>\n+\t\t\t\t<option value=\"22\">22: 22 hours from now</option>\n+\t\t\t\t<option value=\"23\">23: 23 hours from now</option>\n+\t\t\t\t<option value=\"24\">24: 24 hours from now</option>\n+\t\t\t</options>\n+\t\t</parameter>\n+\t\t<parameter name=\"dailyForecasts\" type=\"integer\" multiple=\"true\">\n+\t\t\t<label>Daily forecasts</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9dc268556a10edf32791015ba499006820297240"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3ODc3ODcyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.smhi/src/main/resources/ESH-INF/thing/thing-types.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQyMDo0OTo1NlrOGaJeAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNVQyMDo0OTo1NlrOGaJeAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDA3MTI5Nw==", "bodyText": "See above and the other labels in this file.", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r430071297", "createdAt": "2020-05-25T20:49:56Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.smhi/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,157 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"smhi\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"forecast\">\n+\t\t<label>SMHI weather forecast</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9dc268556a10edf32791015ba499006820297240"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5MTIxOTk0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiException.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxOTo1ODoyMlrOGcEksg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yOFQxOTo1ODoyMlrOGcEksg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA4ODI0Mg==", "bodyText": "When using these constructers, getCause() will return null and throw a NPE in SmhiHandler.java:306. Since these constructors are not used, I would remove them.", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r432088242", "createdAt": "2020-05-28T19:58:22Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiException.java", "diffHunk": "@@ -0,0 +1,37 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.smhi.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmhiException extends Exception {\n+\n+    private static final long serialVersionUID = 516565331L;\n+\n+    public SmhiException() {\n+        super();\n+    }\n+\n+    public SmhiException(String message) {\n+        super(message);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04caeadd78674cdd127b76897a0e145f91cf5066"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNzM3NTM1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/Forecast.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwMDo0NDoyMVrOGhhGFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwMDo0NDoyMVrOGhhGFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc5ODQyMA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                protected ZonedDateTime validTime;\n          \n          \n            \n                private Map<String, @Nullable BigDecimal> parameters;\n          \n          \n            \n                protected final ZonedDateTime validTime;\n          \n          \n            \n                private final Map<String, @Nullable BigDecimal> parameters;", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r437798420", "createdAt": "2020-06-10T00:44:21Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/Forecast.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.smhi.internal;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * A class containing a forecast for a specific point in time.\n+ *\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+@NonNullByDefault\n+public class Forecast implements Comparable<Forecast> {\n+    protected ZonedDateTime validTime;\n+    private Map<String, @Nullable BigDecimal> parameters;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "096d8f47028e888178d56b371172a883987d73c9"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNzQwNzcyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiConfiguration.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwMTowNDoxNlrOGhhZ_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwMTowNDoxNlrOGhhZ_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgwMzUxOA==", "bodyText": "Please add @NonNullByDefault", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r437803518", "createdAt": "2020-06-10T01:04:16Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiConfiguration.java", "diffHunk": "@@ -0,0 +1,31 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smhi.internal;\n+\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link SmhiConfiguration} class contains fields mapping thing configuration parameters.\n+ *\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+public class SmhiConfiguration {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "096d8f47028e888178d56b371172a883987d73c9"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNzQwOTI4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwMTowNToxNFrOGhha4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwMTowNToxNFrOGhha4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgwMzc0Nw==", "bodyText": "A canceled future is considered done.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            if (localRef == null || localRef.isDone() || localRef.isCancelled()) {\n          \n          \n            \n                            if (localRef == null || localRef.isDone()) {", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r437803747", "createdAt": "2020-06-10T01:05:14Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiHandler.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smhi.internal;\n+\n+import static org.openhab.binding.smhi.internal.SmhiBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelGroupUID;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerCallback;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SmhiHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmhiHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SmhiHandler.class);\n+\n+    private @NonNullByDefault({}) SmhiConfiguration config;\n+\n+    private final HttpClient httpClient;\n+    private @Nullable SmhiConnector connection;\n+    private ZonedDateTime currentHour;\n+    private ZonedDateTime currentDay;\n+    private @Nullable TimeSeries cachedTimeSeries;\n+    private boolean hasLatestForecast = false;\n+    private @Nullable Future<?> forecastUpdater;\n+    private @Nullable Future<?> instantUpdate;\n+\n+    public SmhiHandler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.currentHour = calculateCurrentHour();\n+        this.currentDay = calculateCurrentDay();\n+    }\n+\n+    /**\n+     * Handles commands sent to channels. Since all values are read-only, only REFRESH commands are allowed.\n+     * Sending REFRESH to any item updates all items, since all values are returned in the response from Smhi.\n+     * Therefore there's a wait of 5 seconds before the values are fetched, in which time all other commands are\n+     * blocked, to prevent spamming Smhi's API.\n+     *\n+     * @param channelUID\n+     * @param command\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            synchronized (this) {\n+                Future<?> localRef = instantUpdate;\n+                if (localRef == null || localRef.isDone() || localRef.isCancelled()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "096d8f47028e888178d56b371172a883987d73c9"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNzQyNDg1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/TimeSeries.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwMToxNToyOFrOGhhkjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwMToxNToyOFrOGhhkjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgwNjIyMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Iterator<Forecast> iterator = forecasts.iterator();\n          \n          \n            \n            \n          \n          \n            \n                    while (iterator.hasNext()) {\n          \n          \n            \n                        Forecast forecast = iterator.next();\n          \n          \n            \n                        if (forecast.getValidTime().compareTo(startTime.plusHours(hourOffset)) >= 0) {\n          \n          \n            \n                            return forecast;\n          \n          \n            \n                        }\n          \n          \n            \n                    }\n          \n          \n            \n                    return null;\n          \n          \n            \n                    for(Forecast forecast : forecasts){\n          \n          \n            \n                        if (forecast.getValidTime().compareTo(startTime.plusHours(hourOffset)) >= 0) {\n          \n          \n            \n                            return forecast;\n          \n          \n            \n                        }\n          \n          \n            \n                    }\n          \n          \n            \n                    return null;", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r437806222", "createdAt": "2020-06-10T01:15:28Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/TimeSeries.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.smhi.internal;\n+\n+import java.time.ZonedDateTime;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Spliterator;\n+import java.util.function.Consumer;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * A collection class with utility methods to retrieve forecasts pertaining to a specified time.\n+ *\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+@NonNullByDefault\n+public class TimeSeries implements Iterable<Forecast> {\n+\n+    private ZonedDateTime referenceTime;\n+    private List<Forecast> forecasts;\n+\n+    public TimeSeries(ZonedDateTime referenceTime, List<Forecast> forecasts) {\n+        this.referenceTime = referenceTime;\n+        this.forecasts = forecasts;\n+    }\n+\n+    public ZonedDateTime getReferenceTime() {\n+        return referenceTime;\n+    }\n+\n+    /**\n+     * Retrieves the first {@link Forecast} that is equal to or after offset time (from now).\n+     *\n+     * @param hourOffset number of hours after now.\n+     * @return\n+     */\n+    public @Nullable Forecast getForecast(int hourOffset) {\n+        return getForecast(ZonedDateTime.now(), hourOffset);\n+    }\n+\n+    /**\n+     * Retrieves the first {@link Forecast} that is equal to or after the offset time (from startTime).\n+     *\n+     * @param hourOffset number of hours after now.\n+     * @return\n+     */\n+    public @Nullable Forecast getForecast(ZonedDateTime startTime, int hourOffset) {\n+        if (hourOffset < 0) {\n+            throw new IllegalArgumentException(\"Offset must be at least 0\");\n+        }\n+\n+        Iterator<Forecast> iterator = forecasts.iterator();\n+\n+        while (iterator.hasNext()) {\n+            Forecast forecast = iterator.next();\n+            if (forecast.getValidTime().compareTo(startTime.plusHours(hourOffset)) >= 0) {\n+                return forecast;\n+            }\n+        }\n+        return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "096d8f47028e888178d56b371172a883987d73c9"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNzQ1MjY0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwMTozMjoxM1rOGhh1aA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwMTozMjoxM1rOGhh1aA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgxMDUzNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            logger.info(\"No forecast yet for {}\", currentDay.plusHours(24 * i + 12));\n          \n          \n            \n                            logger.debug(\"No forecast yet for {}\", currentDay.plusHours(24 * i + 12));", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r437810536", "createdAt": "2020-06-10T01:32:13Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiHandler.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smhi.internal;\n+\n+import static org.openhab.binding.smhi.internal.SmhiBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelGroupUID;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerCallback;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SmhiHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmhiHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SmhiHandler.class);\n+\n+    private @NonNullByDefault({}) SmhiConfiguration config;\n+\n+    private final HttpClient httpClient;\n+    private @Nullable SmhiConnector connection;\n+    private ZonedDateTime currentHour;\n+    private ZonedDateTime currentDay;\n+    private @Nullable TimeSeries cachedTimeSeries;\n+    private boolean hasLatestForecast = false;\n+    private @Nullable Future<?> forecastUpdater;\n+    private @Nullable Future<?> instantUpdate;\n+\n+    public SmhiHandler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.currentHour = calculateCurrentHour();\n+        this.currentDay = calculateCurrentDay();\n+    }\n+\n+    /**\n+     * Handles commands sent to channels. Since all values are read-only, only REFRESH commands are allowed.\n+     * Sending REFRESH to any item updates all items, since all values are returned in the response from Smhi.\n+     * Therefore there's a wait of 5 seconds before the values are fetched, in which time all other commands are\n+     * blocked, to prevent spamming Smhi's API.\n+     *\n+     * @param channelUID\n+     * @param command\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            synchronized (this) {\n+                Future<?> localRef = instantUpdate;\n+                if (localRef == null || localRef.isDone() || localRef.isCancelled()) {\n+                    instantUpdate = scheduler.schedule(this::getUpdatedForecast, 5, TimeUnit.SECONDS);\n+                } else {\n+                    logger.debug(\"Already waiting for scheduled refresh\");\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(SmhiConfiguration.class);\n+        if (config == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+            return;\n+        }\n+        connection = new SmhiConnector(httpClient);\n+\n+        // Check which channel groups are selected in the config.\n+        List<Channel> channels = new ArrayList<>();\n+        channels.addAll(createChannels());\n+        updateThing(editThing().withChannels(channels).build());\n+\n+        startPolling();\n+        updateStatus(ThingStatus.ONLINE);\n+        synchronized (this) {\n+            Future<?> localRef = instantUpdate;\n+            if (localRef == null || localRef.isDone() || localRef.isCancelled()) {\n+                instantUpdate = scheduler.schedule(this::getUpdatedForecast, 5, TimeUnit.SECONDS);\n+            } else {\n+                logger.debug(\"Already waiting for scheduled refresh\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Start polling for updated weather forecast.\n+     */\n+    private synchronized void startPolling() {\n+        forecastUpdater = scheduler.scheduleWithFixedDelay(this::waitForForecast, 1, 1, TimeUnit.MINUTES);\n+    }\n+\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        if (!isModifyingCurrentConfig(configurationParameters)) {\n+            return;\n+        }\n+\n+        validateConfigurationParameters(configurationParameters);\n+\n+        Configuration configuration = editConfiguration();\n+        for (Map.Entry<String, Object> configurationParameter : configurationParameters.entrySet()) {\n+            configuration.put(configurationParameter.getKey(), configurationParameter.getValue());\n+        }\n+\n+        if (isInitialized()) {\n+            updateConfiguration(configuration);\n+            config = configuration.as(SmhiConfiguration.class);\n+            updateThing(editThing().withChannels(createChannels()).build());\n+        } else {\n+            // persist new configuration and notify Thing Manager\n+            updateConfiguration(configuration);\n+            ThingHandlerCallback callback = getCallback();\n+            if (callback != null) {\n+                callback.configurationUpdated(this.getThing());\n+            } else {\n+                logger.warn(\"Handler {} tried updating its configuration although the handler was already disposed.\",\n+                        this.getClass().getSimpleName());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update channels with new forecast data.\n+     * \n+     * @param timeSeries A {@link TimeSeries} object containing forecasts.\n+     */\n+    private void updateChannels(TimeSeries timeSeries) {\n+        // Loop through hourly forecasts and update those available\n+        for (int i = 0; i < 25; i++) {\n+            List<Channel> channels = thing.getChannelsOfGroup(\"hour_\" + i);\n+            if (channels.isEmpty()) {\n+                continue;\n+            }\n+            Forecast forecast = timeSeries.getForecast(i);\n+            if (forecast != null) {\n+                channels.forEach(c -> {\n+                    String id = c.getUID().getIdWithoutGroup();\n+                    BigDecimal value = forecast.getParameter(id);\n+                    updateChannel(c, value);\n+                });\n+            }\n+        }\n+        // Loop through daily forecasts and updates those available\n+        for (int i = 0; i < 10; i++) {\n+            List<Channel> channels = thing.getChannelsOfGroup(\"day_\" + i);\n+            if (channels.isEmpty()) {\n+                continue;\n+            }\n+            Forecast forecast = timeSeries.getForecast(currentDay, 24 * i + 12);\n+\n+            if (forecast == null) {\n+                logger.info(\"No forecast yet for {}\", currentDay.plusHours(24 * i + 12));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "096d8f47028e888178d56b371172a883987d73c9"}, "originalPosition": 194}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNzQ1ODE4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwMTozNTozMlrOGhh4sw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwMTozNTozMlrOGhh4sw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgxMTM3OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if (localRef == null || localRef.isDone() || localRef.isCancelled()) {\n          \n          \n            \n                        if (localRef == null || localRef.isDone()) {", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r437811379", "createdAt": "2020-06-10T01:35:32Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiHandler.java", "diffHunk": "@@ -0,0 +1,386 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smhi.internal;\n+\n+import static org.openhab.binding.smhi.internal.SmhiBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelGroupUID;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerCallback;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SmhiHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmhiHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SmhiHandler.class);\n+\n+    private @NonNullByDefault({}) SmhiConfiguration config;\n+\n+    private final HttpClient httpClient;\n+    private @Nullable SmhiConnector connection;\n+    private ZonedDateTime currentHour;\n+    private ZonedDateTime currentDay;\n+    private @Nullable TimeSeries cachedTimeSeries;\n+    private boolean hasLatestForecast = false;\n+    private @Nullable Future<?> forecastUpdater;\n+    private @Nullable Future<?> instantUpdate;\n+\n+    public SmhiHandler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.currentHour = calculateCurrentHour();\n+        this.currentDay = calculateCurrentDay();\n+    }\n+\n+    /**\n+     * Handles commands sent to channels. Since all values are read-only, only REFRESH commands are allowed.\n+     * Sending REFRESH to any item updates all items, since all values are returned in the response from Smhi.\n+     * Therefore there's a wait of 5 seconds before the values are fetched, in which time all other commands are\n+     * blocked, to prevent spamming Smhi's API.\n+     *\n+     * @param channelUID\n+     * @param command\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            synchronized (this) {\n+                Future<?> localRef = instantUpdate;\n+                if (localRef == null || localRef.isDone() || localRef.isCancelled()) {\n+                    instantUpdate = scheduler.schedule(this::getUpdatedForecast, 5, TimeUnit.SECONDS);\n+                } else {\n+                    logger.debug(\"Already waiting for scheduled refresh\");\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(SmhiConfiguration.class);\n+        if (config == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+            return;\n+        }\n+        connection = new SmhiConnector(httpClient);\n+\n+        // Check which channel groups are selected in the config.\n+        List<Channel> channels = new ArrayList<>();\n+        channels.addAll(createChannels());\n+        updateThing(editThing().withChannels(channels).build());\n+\n+        startPolling();\n+        updateStatus(ThingStatus.ONLINE);\n+        synchronized (this) {\n+            Future<?> localRef = instantUpdate;\n+            if (localRef == null || localRef.isDone() || localRef.isCancelled()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "096d8f47028e888178d56b371172a883987d73c9"}, "originalPosition": 119}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNzY5MjI4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.smhi/src/main/resources/ESH-INF/thing/channel-types.xml", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwNDowNjo0MVrOGhkH6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQyMjowNzo1MlrOGjSybA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg0ODA0Mg==", "bodyText": "Please apply openHab's Units of Measurement framework wherever applicable. This allows user interfaces greater flexibility when it comes to rendering data from your binding.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t<item-type>Number</item-type>\n          \n          \n            \n            \t\t<item-type>Number:Speed</item-type>", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r437848042", "createdAt": "2020-06-10T04:06:41Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.smhi/src/main/resources/ESH-INF/thing/channel-types.xml", "diffHunk": "@@ -0,0 +1,214 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"smhi\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<channel-type id=\"msl\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Air Pressure</label>\n+\t\t<description>Air pressure in hPa</description>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\t<channel-type id=\"t\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Temperature</label>\n+\t\t<description>Temperature in C</description>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\t<channel-type id=\"vis\" advanced=\"true\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Visibility</label>\n+\t\t<description>Horizontal visibility in km</description>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\t<channel-type id=\"wd\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Wind Direction</label>\n+\t\t<description>Wind direction in degrees</description>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\t<channel-type id=\"ws\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Wind Speed</label>\n+\t\t<description>Wind speed in m/s</description>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\t<channel-type id=\"r\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Relative Humidity</label>\n+\t\t<description>Relative humidity in percent</description>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\t<channel-type id=\"tstm\" advanced=\"true\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Thunder Probability</label>\n+\t\t<description>Probability of thunder in percent</description>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\t<channel-type id=\"tcc_mean\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Total Cloud Cover</label>\n+\t\t<description>Mean value of total cloud cover in octets</description>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\t<channel-type id=\"lcc_mean\" advanced=\"true\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Low Level Cloud Cover</label>\n+\t\t<description>Mean value of low level cloud cover (0-2500 m) in octets</description>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\t<channel-type id=\"mcc_mean\" advanced=\"true\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Medium Level Cloud Cover</label>\n+\t\t<description>Mean value of medium level cloud cover (2500-6000 m) in octets</description>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\t<channel-type id=\"hcc_mean\" advanced=\"true\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>High Level Cloud Cover</label>\n+\t\t<description>Mean value of high level cloud cover (> 6000 m) in octets</description>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\t<channel-type id=\"gust\">\n+\t\t<item-type>Number</item-type>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "096d8f47028e888178d56b371172a883987d73c9"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkyMjQxOA==", "bodyText": "Thanks for your comments, working on implementing UoM. Do you now what's the best practice to handle precipitation? It's commonly reported as mm/h, but in reality it should be l/m\u00b2/h. It feels kind of weird to define it as a speed measurement.", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r437922418", "createdAt": "2020-06-10T07:41:02Z", "author": {"login": "pacive"}, "path": "bundles/org.openhab.binding.smhi/src/main/resources/ESH-INF/thing/channel-types.xml", "diffHunk": "@@ -0,0 +1,214 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"smhi\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<channel-type id=\"msl\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Air Pressure</label>\n+\t\t<description>Air pressure in hPa</description>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\t<channel-type id=\"t\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Temperature</label>\n+\t\t<description>Temperature in C</description>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\t<channel-type id=\"vis\" advanced=\"true\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Visibility</label>\n+\t\t<description>Horizontal visibility in km</description>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\t<channel-type id=\"wd\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Wind Direction</label>\n+\t\t<description>Wind direction in degrees</description>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\t<channel-type id=\"ws\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Wind Speed</label>\n+\t\t<description>Wind speed in m/s</description>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\t<channel-type id=\"r\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Relative Humidity</label>\n+\t\t<description>Relative humidity in percent</description>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\t<channel-type id=\"tstm\" advanced=\"true\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Thunder Probability</label>\n+\t\t<description>Probability of thunder in percent</description>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\t<channel-type id=\"tcc_mean\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Total Cloud Cover</label>\n+\t\t<description>Mean value of total cloud cover in octets</description>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\t<channel-type id=\"lcc_mean\" advanced=\"true\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Low Level Cloud Cover</label>\n+\t\t<description>Mean value of low level cloud cover (0-2500 m) in octets</description>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\t<channel-type id=\"mcc_mean\" advanced=\"true\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Medium Level Cloud Cover</label>\n+\t\t<description>Mean value of medium level cloud cover (2500-6000 m) in octets</description>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\t<channel-type id=\"hcc_mean\" advanced=\"true\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>High Level Cloud Cover</label>\n+\t\t<description>Mean value of high level cloud cover (> 6000 m) in octets</description>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\t<channel-type id=\"gust\">\n+\t\t<item-type>Number</item-type>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg0ODA0Mg=="}, "originalCommit": {"oid": "096d8f47028e888178d56b371172a883987d73c9"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY2MTE2NA==", "bodyText": "I would just stick with mm/h since it is more commonly used", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r439661164", "createdAt": "2020-06-12T22:07:52Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.smhi/src/main/resources/ESH-INF/thing/channel-types.xml", "diffHunk": "@@ -0,0 +1,214 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"smhi\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<channel-type id=\"msl\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Air Pressure</label>\n+\t\t<description>Air pressure in hPa</description>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\t<channel-type id=\"t\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Temperature</label>\n+\t\t<description>Temperature in C</description>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\t<channel-type id=\"vis\" advanced=\"true\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Visibility</label>\n+\t\t<description>Horizontal visibility in km</description>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\t<channel-type id=\"wd\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Wind Direction</label>\n+\t\t<description>Wind direction in degrees</description>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\t<channel-type id=\"ws\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Wind Speed</label>\n+\t\t<description>Wind speed in m/s</description>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\t<channel-type id=\"r\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Relative Humidity</label>\n+\t\t<description>Relative humidity in percent</description>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\t<channel-type id=\"tstm\" advanced=\"true\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Thunder Probability</label>\n+\t\t<description>Probability of thunder in percent</description>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\t<channel-type id=\"tcc_mean\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Total Cloud Cover</label>\n+\t\t<description>Mean value of total cloud cover in octets</description>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\t<channel-type id=\"lcc_mean\" advanced=\"true\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Low Level Cloud Cover</label>\n+\t\t<description>Mean value of low level cloud cover (0-2500 m) in octets</description>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\t<channel-type id=\"mcc_mean\" advanced=\"true\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Medium Level Cloud Cover</label>\n+\t\t<description>Mean value of medium level cloud cover (2500-6000 m) in octets</description>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\t<channel-type id=\"hcc_mean\" advanced=\"true\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>High Level Cloud Cover</label>\n+\t\t<description>Mean value of high level cloud cover (> 6000 m) in octets</description>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\t<channel-type id=\"gust\">\n+\t\t<item-type>Number</item-type>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg0ODA0Mg=="}, "originalCommit": {"oid": "096d8f47028e888178d56b371172a883987d73c9"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNzY5NDY4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.smhi/src/main/resources/ESH-INF/thing/channel-types.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwNDowODoyNVrOGhkJag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwNDowODoyNVrOGhkJag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg0ODQyNg==", "bodyText": "Please use \"Number:Dimensionless\" and Percent units.", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r437848426", "createdAt": "2020-06-10T04:08:25Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.smhi/src/main/resources/ESH-INF/thing/channel-types.xml", "diffHunk": "@@ -0,0 +1,214 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"smhi\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<channel-type id=\"msl\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Air Pressure</label>\n+\t\t<description>Air pressure in hPa</description>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\t<channel-type id=\"t\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Temperature</label>\n+\t\t<description>Temperature in C</description>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\t<channel-type id=\"vis\" advanced=\"true\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Visibility</label>\n+\t\t<description>Horizontal visibility in km</description>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\t<channel-type id=\"wd\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Wind Direction</label>\n+\t\t<description>Wind direction in degrees</description>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\t<channel-type id=\"ws\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Wind Speed</label>\n+\t\t<description>Wind speed in m/s</description>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\t<channel-type id=\"r\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Relative Humidity</label>\n+\t\t<description>Relative humidity in percent</description>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\t<channel-type id=\"tstm\" advanced=\"true\">\n+\t\t<item-type>Number</item-type>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "096d8f47028e888178d56b371172a883987d73c9"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcyNzY5NDgxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.smhi/src/main/resources/ESH-INF/thing/channel-types.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwNDowODozMVrOGhkJfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMFQwNDowODozMVrOGhkJfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg0ODQ0Ng==", "bodyText": "same here", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r437848446", "createdAt": "2020-06-10T04:08:31Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.smhi/src/main/resources/ESH-INF/thing/channel-types.xml", "diffHunk": "@@ -0,0 +1,214 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"smhi\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<channel-type id=\"msl\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Air Pressure</label>\n+\t\t<description>Air pressure in hPa</description>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\t<channel-type id=\"t\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Temperature</label>\n+\t\t<description>Temperature in C</description>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\t<channel-type id=\"vis\" advanced=\"true\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Visibility</label>\n+\t\t<description>Horizontal visibility in km</description>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\t<channel-type id=\"wd\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Wind Direction</label>\n+\t\t<description>Wind direction in degrees</description>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\t<channel-type id=\"ws\">\n+\t\t<item-type>Number</item-type>\n+\t\t<label>Wind Speed</label>\n+\t\t<description>Wind speed in m/s</description>\n+\t\t<state readOnly=\"true\" />\n+\t</channel-type>\n+\t<channel-type id=\"r\">\n+\t\t<item-type>Number</item-type>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "096d8f47028e888178d56b371172a883987d73c9"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczODg5NzI5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiBindingConstants.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQyMjoxMDo1M1rOGjS1zA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QwNToxMToyOFrOGjVxuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY2MjAyOA==", "bodyText": "I think you are incorrectly trying to map the percent unit to be in the 0.0-1.0 range instead of the 0-100 range.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static final BigDecimal OCTAS_TO_PERCENT = BigDecimal.valueOf(0.08);\n          \n          \n            \n                public static final BigDecimal OCTAS_TO_PERCENT = BigDecimal.valueOf(8);", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r439662028", "createdAt": "2020-06-12T22:10:53Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiBindingConstants.java", "diffHunk": "@@ -67,4 +68,6 @@\n     public static final String APPROVED_TIME_URL = BASE_URL + \"/api/category/pmp3g/version/2/approvedtime.json\";\n     public static final String POINT_FORECAST_URL = BASE_URL\n             + \"/api/category/pmp3g/version/2/geotype/point/lon/%.6f/lat/%.6f/data.json\";\n+\n+    public static final BigDecimal OCTAS_TO_PERCENT = BigDecimal.valueOf(0.08);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d865653ef2800a9eedf242941937164aefaa069"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwODE5NQ==", "bodyText": "No, e.g. 5/8 = 0.625, 5/0.08 = 62.5. 62.5 Is the number I want, right?", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r439708195", "createdAt": "2020-06-13T04:33:22Z", "author": {"login": "pacive"}, "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiBindingConstants.java", "diffHunk": "@@ -67,4 +68,6 @@\n     public static final String APPROVED_TIME_URL = BASE_URL + \"/api/category/pmp3g/version/2/approvedtime.json\";\n     public static final String POINT_FORECAST_URL = BASE_URL\n             + \"/api/category/pmp3g/version/2/geotype/point/lon/%.6f/lat/%.6f/data.json\";\n+\n+    public static final BigDecimal OCTAS_TO_PERCENT = BigDecimal.valueOf(0.08);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY2MjAyOA=="}, "originalCommit": {"oid": "9d865653ef2800a9eedf242941937164aefaa069"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcxMDEzOQ==", "bodyText": "Now that I think about it though, it might be more clear to just multiply by 12.5 instead.", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r439710139", "createdAt": "2020-06-13T05:11:28Z", "author": {"login": "pacive"}, "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiBindingConstants.java", "diffHunk": "@@ -67,4 +68,6 @@\n     public static final String APPROVED_TIME_URL = BASE_URL + \"/api/category/pmp3g/version/2/approvedtime.json\";\n     public static final String POINT_FORECAST_URL = BASE_URL\n             + \"/api/category/pmp3g/version/2/geotype/point/lon/%.6f/lat/%.6f/data.json\";\n+\n+    public static final BigDecimal OCTAS_TO_PERCENT = BigDecimal.valueOf(0.08);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY2MjAyOA=="}, "originalCommit": {"oid": "9d865653ef2800a9eedf242941937164aefaa069"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczODkxNTE3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQyMjoyMTozMVrOGjTAlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQyMjoyMTozMVrOGjTAlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY2NDc4OQ==", "bodyText": "Please refactor this to its own method so that handleCommand and initialize can both use it.", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r439664789", "createdAt": "2020-06-12T22:21:31Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiHandler.java", "diffHunk": "@@ -0,0 +1,421 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smhi.internal;\n+\n+import static org.openhab.binding.smhi.internal.SmhiBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.MetricPrefix;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelGroupUID;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerCallback;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SmhiHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmhiHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SmhiHandler.class);\n+\n+    private @NonNullByDefault({}) SmhiConfiguration config;\n+\n+    private final HttpClient httpClient;\n+    private @Nullable SmhiConnector connection;\n+    private ZonedDateTime currentHour;\n+    private ZonedDateTime currentDay;\n+    private @Nullable TimeSeries cachedTimeSeries;\n+    private boolean hasLatestForecast = false;\n+    private @Nullable Future<?> forecastUpdater;\n+    private @Nullable Future<?> instantUpdate;\n+\n+    public SmhiHandler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.currentHour = calculateCurrentHour();\n+        this.currentDay = calculateCurrentDay();\n+    }\n+\n+    /**\n+     * Handles commands sent to channels. Since all values are read-only, only REFRESH commands are allowed.\n+     * Sending REFRESH to any item updates all items, since all values are returned in the response from Smhi.\n+     * Therefore there's a wait of 5 seconds before the values are fetched, in which time all other commands are\n+     * blocked, to prevent spamming Smhi's API.\n+     *\n+     * @param channelUID\n+     * @param command\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            synchronized (this) {\n+                Future<?> localRef = instantUpdate;\n+                if (localRef == null || localRef.isDone()) {\n+                    instantUpdate = scheduler.schedule(this::getUpdatedForecast, 5, TimeUnit.SECONDS);\n+                } else {\n+                    logger.debug(\"Already waiting for scheduled refresh\");\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(SmhiConfiguration.class);\n+        if (config == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+            return;\n+        }\n+        connection = new SmhiConnector(httpClient);\n+\n+        // Check which channel groups are selected in the config.\n+        List<Channel> channels = new ArrayList<>();\n+        channels.addAll(createChannels());\n+        updateThing(editThing().withChannels(channels).build());\n+\n+        startPolling();\n+        updateStatus(ThingStatus.ONLINE);\n+        synchronized (this) {\n+            Future<?> localRef = instantUpdate;\n+            if (localRef == null || localRef.isDone()) {\n+                instantUpdate = scheduler.schedule(this::getUpdatedForecast, 5, TimeUnit.SECONDS);\n+            } else {\n+                logger.debug(\"Already waiting for scheduled refresh\");\n+            }\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "086a20070bdf370b51d38471f065dda2cb862ded"}, "originalPosition": 129}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczODkxODQwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/Forecast.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQyMjoyMzo0MlrOGjTCsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QwNDo0NDozOVrOGjVsOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY2NTMzMA==", "bodyText": "Any reason this is protected rather than private?", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r439665330", "createdAt": "2020-06-12T22:23:42Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/Forecast.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.smhi.internal;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * A class containing a forecast for a specific point in time.\n+ *\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+@NonNullByDefault\n+public class Forecast implements Comparable<Forecast> {\n+    protected final ZonedDateTime validTime;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "086a20070bdf370b51d38471f065dda2cb862ded"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwODcyOA==", "bodyText": "I (apparently mistakenly) thought protected was to enable instances to see each other's fields (in the compareTo method), but seems I got it mixed up with Ruby's access modifiers.", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r439708728", "createdAt": "2020-06-13T04:44:39Z", "author": {"login": "pacive"}, "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/Forecast.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.smhi.internal;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * A class containing a forecast for a specific point in time.\n+ *\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+@NonNullByDefault\n+public class Forecast implements Comparable<Forecast> {\n+    protected final ZonedDateTime validTime;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY2NTMzMA=="}, "originalCommit": {"oid": "086a20070bdf370b51d38471f065dda2cb862ded"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczODkxOTc3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiConfiguration.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQyMjoyNDozNlrOGjTDdg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQyMjoyNDozNlrOGjTDdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY2NTUyNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Nullable\n          \n          \n            \n                public List<Integer> hourlyForecasts;\n          \n          \n            \n                @Nullable\n          \n          \n            \n                public List<Integer> dailyForecasts;\n          \n          \n            \n                public @Nullable List<Integer> hourlyForecasts;\n          \n          \n            \n                public @Nullable List<Integer> dailyForecasts;", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r439665526", "createdAt": "2020-06-12T22:24:36Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiConfiguration.java", "diffHunk": "@@ -0,0 +1,33 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smhi.internal;\n+\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link SmhiConfiguration} class contains fields mapping thing configuration parameters.\n+ *\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmhiConfiguration {\n+    public double latitude;\n+    public double longitude;\n+    @Nullable\n+    public List<Integer> hourlyForecasts;\n+    @Nullable\n+    public List<Integer> dailyForecasts;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "086a20070bdf370b51d38471f065dda2cb862ded"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczODkyMTY5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQyMjoyNTo0OVrOGjTElw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQyMjoyNTo0OVrOGjTElw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY2NTgxNQ==", "bodyText": "You can get around the null checking issues by just initializing your config to a default instance.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private @NonNullByDefault({}) SmhiConfiguration config;\n          \n          \n            \n                private SmhiConfiguration config = new SmhiConfiguration();", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r439665815", "createdAt": "2020-06-12T22:25:49Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiHandler.java", "diffHunk": "@@ -0,0 +1,421 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smhi.internal;\n+\n+import static org.openhab.binding.smhi.internal.SmhiBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.MetricPrefix;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelGroupUID;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerCallback;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SmhiHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmhiHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SmhiHandler.class);\n+\n+    private @NonNullByDefault({}) SmhiConfiguration config;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "086a20070bdf370b51d38471f065dda2cb862ded"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczODkyODkzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiHandler.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQyMjozMDo0NFrOGjTJEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QwODoxNToxNFrOGjWZuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY2Njk2Mg==", "bodyText": "Don't most of these channels have units now?", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r439666962", "createdAt": "2020-06-12T22:30:44Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiHandler.java", "diffHunk": "@@ -0,0 +1,421 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smhi.internal;\n+\n+import static org.openhab.binding.smhi.internal.SmhiBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.MetricPrefix;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelGroupUID;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerCallback;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SmhiHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmhiHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SmhiHandler.class);\n+\n+    private @NonNullByDefault({}) SmhiConfiguration config;\n+\n+    private final HttpClient httpClient;\n+    private @Nullable SmhiConnector connection;\n+    private ZonedDateTime currentHour;\n+    private ZonedDateTime currentDay;\n+    private @Nullable TimeSeries cachedTimeSeries;\n+    private boolean hasLatestForecast = false;\n+    private @Nullable Future<?> forecastUpdater;\n+    private @Nullable Future<?> instantUpdate;\n+\n+    public SmhiHandler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.currentHour = calculateCurrentHour();\n+        this.currentDay = calculateCurrentDay();\n+    }\n+\n+    /**\n+     * Handles commands sent to channels. Since all values are read-only, only REFRESH commands are allowed.\n+     * Sending REFRESH to any item updates all items, since all values are returned in the response from Smhi.\n+     * Therefore there's a wait of 5 seconds before the values are fetched, in which time all other commands are\n+     * blocked, to prevent spamming Smhi's API.\n+     *\n+     * @param channelUID\n+     * @param command\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            synchronized (this) {\n+                Future<?> localRef = instantUpdate;\n+                if (localRef == null || localRef.isDone()) {\n+                    instantUpdate = scheduler.schedule(this::getUpdatedForecast, 5, TimeUnit.SECONDS);\n+                } else {\n+                    logger.debug(\"Already waiting for scheduled refresh\");\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(SmhiConfiguration.class);\n+        if (config == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+            return;\n+        }\n+        connection = new SmhiConnector(httpClient);\n+\n+        // Check which channel groups are selected in the config.\n+        List<Channel> channels = new ArrayList<>();\n+        channels.addAll(createChannels());\n+        updateThing(editThing().withChannels(channels).build());\n+\n+        startPolling();\n+        updateStatus(ThingStatus.ONLINE);\n+        synchronized (this) {\n+            Future<?> localRef = instantUpdate;\n+            if (localRef == null || localRef.isDone()) {\n+                instantUpdate = scheduler.schedule(this::getUpdatedForecast, 5, TimeUnit.SECONDS);\n+            } else {\n+                logger.debug(\"Already waiting for scheduled refresh\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Start polling for updated weather forecast.\n+     */\n+    private synchronized void startPolling() {\n+        forecastUpdater = scheduler.scheduleWithFixedDelay(this::waitForForecast, 1, 1, TimeUnit.MINUTES);\n+    }\n+\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        if (!isModifyingCurrentConfig(configurationParameters)) {\n+            return;\n+        }\n+\n+        validateConfigurationParameters(configurationParameters);\n+\n+        Configuration configuration = editConfiguration();\n+        for (Map.Entry<String, Object> configurationParameter : configurationParameters.entrySet()) {\n+            configuration.put(configurationParameter.getKey(), configurationParameter.getValue());\n+        }\n+\n+        if (isInitialized()) {\n+            updateConfiguration(configuration);\n+            config = configuration.as(SmhiConfiguration.class);\n+            updateThing(editThing().withChannels(createChannels()).build());\n+        } else {\n+            // persist new configuration and notify Thing Manager\n+            updateConfiguration(configuration);\n+            ThingHandlerCallback callback = getCallback();\n+            if (callback != null) {\n+                callback.configurationUpdated(this.getThing());\n+            } else {\n+                logger.warn(\"Handler {} tried updating its configuration although the handler was already disposed.\",\n+                        this.getClass().getSimpleName());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update channels with new forecast data.\n+     * \n+     * @param timeSeries A {@link TimeSeries} object containing forecasts.\n+     */\n+    private void updateChannels(TimeSeries timeSeries) {\n+        // Loop through hourly forecasts and update those available\n+        for (int i = 0; i < 25; i++) {\n+            List<Channel> channels = thing.getChannelsOfGroup(\"hour_\" + i);\n+            if (channels.isEmpty()) {\n+                continue;\n+            }\n+            Forecast forecast = timeSeries.getForecast(i);\n+            if (forecast != null) {\n+                channels.forEach(c -> {\n+                    String id = c.getUID().getIdWithoutGroup();\n+                    BigDecimal value = forecast.getParameter(id);\n+                    updateChannel(c, value);\n+                });\n+            }\n+        }\n+        // Loop through daily forecasts and updates those available\n+        for (int i = 0; i < 10; i++) {\n+            List<Channel> channels = thing.getChannelsOfGroup(\"day_\" + i);\n+            if (channels.isEmpty()) {\n+                continue;\n+            }\n+            Forecast forecast = timeSeries.getForecast(currentDay, 24 * i + 12);\n+\n+            if (forecast == null) {\n+                logger.debug(\"No forecast yet for {}\", currentDay.plusHours(24 * i + 12));\n+                channels.forEach(c -> {\n+                    updateState(c.getUID(), UnDefType.NULL);\n+                });\n+            } else {\n+                channels.forEach(c -> {\n+                    String id = c.getUID().getIdWithoutGroup();\n+                    BigDecimal value = forecast.getParameter(id);\n+                    updateChannel(c, value);\n+                });\n+            }\n+        }\n+    }\n+\n+    private void updateChannel(Channel channel, @Nullable BigDecimal value) {\n+        String id = channel.getUID().getIdWithoutGroup();\n+        State newState = UnDefType.NULL;\n+\n+        if (value != null) {\n+            switch (id) {\n+                case PRESSURE:\n+                    newState = new QuantityType<>(value, MetricPrefix.HECTO(SIUnits.PASCAL));\n+                    break;\n+                case TEMPERATURE:\n+                    newState = new QuantityType<>(value, SIUnits.CELSIUS);\n+                    break;\n+                case VISIBILITY:\n+                    newState = new QuantityType<>(value, MetricPrefix.KILO(SIUnits.METRE));\n+                    break;\n+                case WIND_DIRECTION:\n+                    newState = new QuantityType<>(value, SmartHomeUnits.DEGREE_ANGLE);\n+                    break;\n+                case WIND_SPEED:\n+                case GUST:\n+                    newState = new QuantityType<>(value, SmartHomeUnits.METRE_PER_SECOND);\n+                    break;\n+                case RELATIVE_HUMIDITY:\n+                case THUNDER_PROBABILITY:\n+                    newState = new QuantityType<>(value, SmartHomeUnits.PERCENT);\n+                    break;\n+                case PERCENT_FROZEN:\n+                    // Smhi returns -9 for spp if there's no precipitation, convert to UNDEF\n+                    if (value.intValue() == -9) {\n+                        newState = UnDefType.UNDEF;\n+                    } else {\n+                        newState = new QuantityType<>(value, SmartHomeUnits.PERCENT);\n+                    }\n+                    break;\n+                case HIGH_CLOUD_COVER:\n+                case MEDIUM_CLOUD_COVER:\n+                case LOW_CLOUD_COVER:\n+                case TOTAL_CLOUD_COVER:\n+                    newState = new QuantityType<>(value.divide(OCTAS_TO_PERCENT), SmartHomeUnits.PERCENT);\n+                    break;\n+                case PRECIPITATION_MAX:\n+                case PRECIPITATION_MEAN:\n+                case PRECIPITATION_MEDIAN:\n+                case PRECIPITATION_MIN:\n+                    newState = new QuantityType<>(value, SmartHomeUnits.MILLIMETRE_PER_HOUR);\n+                    break;\n+                default:\n+                    newState = new DecimalType(value);\n+            }\n+        }\n+\n+        updateState(channel.getUID(), newState);\n+    }\n+\n+    /**\n+     * Dispose the {@link org.eclipse.smarthome.core.thing.binding.ThingHandler}. Cancel scheduled jobs\n+     */\n+    public void dispose() {\n+        Future<?> localRef = forecastUpdater;\n+        if (localRef != null) {\n+            localRef.cancel(false);\n+        }\n+        localRef = instantUpdate;\n+        if (localRef != null) {\n+            localRef.cancel(false);\n+        }\n+    }\n+\n+    /**\n+     * First check if the time has shifted to a new hour, then start checking if a new forecast have been\n+     * published, in that case, fetch it and update channels.\n+     */\n+    private void waitForForecast() {\n+        if (isItNewHour()) {\n+            currentHour = calculateCurrentHour();\n+            currentDay = calculateCurrentDay();\n+            // Update channels with cached forecasts - just shift an hour forward\n+            TimeSeries forecast = cachedTimeSeries;\n+            if (forecast != null) {\n+                updateChannels(forecast);\n+            }\n+            hasLatestForecast = false;\n+        }\n+        if (!hasLatestForecast && isForecastUpdated()) {\n+            getUpdatedForecast();\n+        }\n+    }\n+\n+    /**\n+     * Checks if it is a new hour.\n+     * \n+     * @return true if the current time is more than one hour after currentHour, otherwise false.\n+     */\n+    private boolean isItNewHour() {\n+        return ZonedDateTime.now().minusHours(1).isAfter(currentHour);\n+    }\n+\n+    /**\n+     * Call Smhi's endpoint to check for the time of the last forecast, to see if a new one is available.\n+     * \n+     * @return true if the time of the latest forecast is equal to or after currentHour, otherwise false\n+     */\n+    private boolean isForecastUpdated() {\n+        ZonedDateTime referenceTime;\n+        SmhiConnector apiConnection = connection;\n+        if (apiConnection != null) {\n+            try {\n+                referenceTime = apiConnection.getReferenceTime();\n+            } catch (SmhiException e) {\n+                return false;\n+            }\n+            return referenceTime.isEqual(currentHour) || referenceTime.isAfter(currentHour);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Fetches latest forecast from Smhi, update channels and check if it was published in the current hour.\n+     * If it is, set flag to indicate we have the latest forecast.\n+     */\n+    private void getUpdatedForecast() {\n+        TimeSeries forecast;\n+        ZonedDateTime referenceTime;\n+        SmhiConnector apiConnection = connection;\n+        if (apiConnection != null) {\n+            try {\n+                forecast = apiConnection.getForecast(config.latitude, config.longitude);\n+            } catch (SmhiException e) {\n+                logger.warn(\"Failed to get new forecast: {}\", e.getCause().getMessage());\n+                return;\n+            }\n+            referenceTime = forecast.getReferenceTime();\n+            updateChannels(forecast);\n+            if (referenceTime.isEqual(currentHour) || referenceTime.isAfter(currentHour)) {\n+                hasLatestForecast = true;\n+            }\n+            cachedTimeSeries = forecast;\n+        }\n+    }\n+\n+    /**\n+     * Get the current time rounded down to hour\n+     * \n+     * @return A {@link ZonedDateTime} corresponding to the last even hour\n+     */\n+    private ZonedDateTime calculateCurrentHour() {\n+        ZonedDateTime now = ZonedDateTime.now().withZoneSameInstant(ZoneOffset.UTC);\n+        int y = now.getYear();\n+        int m = now.getMonth().getValue();\n+        int d = now.getDayOfMonth();\n+        int h = now.getHour();\n+        return ZonedDateTime.of(y, m, d, h, 0, 0, 0, ZoneOffset.UTC);\n+    }\n+\n+    /**\n+     * Get the current time rounded down to day\n+     * \n+     * @return A {@link ZonedDateTime} corresponding to the last even day.\n+     */\n+    private ZonedDateTime calculateCurrentDay() {\n+        ZonedDateTime now = ZonedDateTime.now().withZoneSameInstant(ZoneOffset.UTC);\n+        int y = now.getYear();\n+        int m = now.getMonth().getValue();\n+        int d = now.getDayOfMonth();\n+        return ZonedDateTime.of(y, m, d, 0, 0, 0, 0, ZoneOffset.UTC);\n+    }\n+\n+    /**\n+     * Creates channels based on selections in thing configuration\n+     * \n+     * @return\n+     */\n+    private List<Channel> createChannels() {\n+        List<Channel> channels = new ArrayList<>();\n+\n+        // There's currently a bug in PaperUI that can cause options to be added more than one time\n+        // to the list. Convert to a sorted set to work around this.\n+        // See https://github.com/openhab/openhab-webui/issues/212\n+        Set<Integer> hours = new TreeSet<>();\n+        Set<Integer> days = new TreeSet<>();\n+        if (config.hourlyForecasts != null) {\n+            hours.addAll(config.hourlyForecasts);\n+        }\n+        if (config.dailyForecasts != null) {\n+            days.addAll(config.dailyForecasts);\n+        }\n+\n+        for (int i : hours) {\n+            ChannelGroupUID groupUID = new ChannelGroupUID(thing.getUID(), \"hour_\" + i);\n+            CHANNEL_IDS.forEach(id -> {\n+                ChannelUID channelUID = new ChannelUID(groupUID, id);\n+                Channel channel = ChannelBuilder.create(channelUID, \"Number\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "086a20070bdf370b51d38471f065dda2cb862ded"}, "originalPosition": 404}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcxMDAyOA==", "bodyText": "The units are working even though it's defined just as \"Number\". Do I have to hardcode all Item types here as well? Is there an easier way to just create a channel from a channel-type defined in xml? All info is already defined there, so seems unnecessary to define it again here, but the ChannelBuilder constructor requires this.", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r439710028", "createdAt": "2020-06-13T05:09:22Z", "author": {"login": "pacive"}, "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiHandler.java", "diffHunk": "@@ -0,0 +1,421 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smhi.internal;\n+\n+import static org.openhab.binding.smhi.internal.SmhiBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.MetricPrefix;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelGroupUID;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerCallback;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SmhiHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmhiHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SmhiHandler.class);\n+\n+    private @NonNullByDefault({}) SmhiConfiguration config;\n+\n+    private final HttpClient httpClient;\n+    private @Nullable SmhiConnector connection;\n+    private ZonedDateTime currentHour;\n+    private ZonedDateTime currentDay;\n+    private @Nullable TimeSeries cachedTimeSeries;\n+    private boolean hasLatestForecast = false;\n+    private @Nullable Future<?> forecastUpdater;\n+    private @Nullable Future<?> instantUpdate;\n+\n+    public SmhiHandler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.currentHour = calculateCurrentHour();\n+        this.currentDay = calculateCurrentDay();\n+    }\n+\n+    /**\n+     * Handles commands sent to channels. Since all values are read-only, only REFRESH commands are allowed.\n+     * Sending REFRESH to any item updates all items, since all values are returned in the response from Smhi.\n+     * Therefore there's a wait of 5 seconds before the values are fetched, in which time all other commands are\n+     * blocked, to prevent spamming Smhi's API.\n+     *\n+     * @param channelUID\n+     * @param command\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            synchronized (this) {\n+                Future<?> localRef = instantUpdate;\n+                if (localRef == null || localRef.isDone()) {\n+                    instantUpdate = scheduler.schedule(this::getUpdatedForecast, 5, TimeUnit.SECONDS);\n+                } else {\n+                    logger.debug(\"Already waiting for scheduled refresh\");\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(SmhiConfiguration.class);\n+        if (config == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+            return;\n+        }\n+        connection = new SmhiConnector(httpClient);\n+\n+        // Check which channel groups are selected in the config.\n+        List<Channel> channels = new ArrayList<>();\n+        channels.addAll(createChannels());\n+        updateThing(editThing().withChannels(channels).build());\n+\n+        startPolling();\n+        updateStatus(ThingStatus.ONLINE);\n+        synchronized (this) {\n+            Future<?> localRef = instantUpdate;\n+            if (localRef == null || localRef.isDone()) {\n+                instantUpdate = scheduler.schedule(this::getUpdatedForecast, 5, TimeUnit.SECONDS);\n+            } else {\n+                logger.debug(\"Already waiting for scheduled refresh\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Start polling for updated weather forecast.\n+     */\n+    private synchronized void startPolling() {\n+        forecastUpdater = scheduler.scheduleWithFixedDelay(this::waitForForecast, 1, 1, TimeUnit.MINUTES);\n+    }\n+\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        if (!isModifyingCurrentConfig(configurationParameters)) {\n+            return;\n+        }\n+\n+        validateConfigurationParameters(configurationParameters);\n+\n+        Configuration configuration = editConfiguration();\n+        for (Map.Entry<String, Object> configurationParameter : configurationParameters.entrySet()) {\n+            configuration.put(configurationParameter.getKey(), configurationParameter.getValue());\n+        }\n+\n+        if (isInitialized()) {\n+            updateConfiguration(configuration);\n+            config = configuration.as(SmhiConfiguration.class);\n+            updateThing(editThing().withChannels(createChannels()).build());\n+        } else {\n+            // persist new configuration and notify Thing Manager\n+            updateConfiguration(configuration);\n+            ThingHandlerCallback callback = getCallback();\n+            if (callback != null) {\n+                callback.configurationUpdated(this.getThing());\n+            } else {\n+                logger.warn(\"Handler {} tried updating its configuration although the handler was already disposed.\",\n+                        this.getClass().getSimpleName());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update channels with new forecast data.\n+     * \n+     * @param timeSeries A {@link TimeSeries} object containing forecasts.\n+     */\n+    private void updateChannels(TimeSeries timeSeries) {\n+        // Loop through hourly forecasts and update those available\n+        for (int i = 0; i < 25; i++) {\n+            List<Channel> channels = thing.getChannelsOfGroup(\"hour_\" + i);\n+            if (channels.isEmpty()) {\n+                continue;\n+            }\n+            Forecast forecast = timeSeries.getForecast(i);\n+            if (forecast != null) {\n+                channels.forEach(c -> {\n+                    String id = c.getUID().getIdWithoutGroup();\n+                    BigDecimal value = forecast.getParameter(id);\n+                    updateChannel(c, value);\n+                });\n+            }\n+        }\n+        // Loop through daily forecasts and updates those available\n+        for (int i = 0; i < 10; i++) {\n+            List<Channel> channels = thing.getChannelsOfGroup(\"day_\" + i);\n+            if (channels.isEmpty()) {\n+                continue;\n+            }\n+            Forecast forecast = timeSeries.getForecast(currentDay, 24 * i + 12);\n+\n+            if (forecast == null) {\n+                logger.debug(\"No forecast yet for {}\", currentDay.plusHours(24 * i + 12));\n+                channels.forEach(c -> {\n+                    updateState(c.getUID(), UnDefType.NULL);\n+                });\n+            } else {\n+                channels.forEach(c -> {\n+                    String id = c.getUID().getIdWithoutGroup();\n+                    BigDecimal value = forecast.getParameter(id);\n+                    updateChannel(c, value);\n+                });\n+            }\n+        }\n+    }\n+\n+    private void updateChannel(Channel channel, @Nullable BigDecimal value) {\n+        String id = channel.getUID().getIdWithoutGroup();\n+        State newState = UnDefType.NULL;\n+\n+        if (value != null) {\n+            switch (id) {\n+                case PRESSURE:\n+                    newState = new QuantityType<>(value, MetricPrefix.HECTO(SIUnits.PASCAL));\n+                    break;\n+                case TEMPERATURE:\n+                    newState = new QuantityType<>(value, SIUnits.CELSIUS);\n+                    break;\n+                case VISIBILITY:\n+                    newState = new QuantityType<>(value, MetricPrefix.KILO(SIUnits.METRE));\n+                    break;\n+                case WIND_DIRECTION:\n+                    newState = new QuantityType<>(value, SmartHomeUnits.DEGREE_ANGLE);\n+                    break;\n+                case WIND_SPEED:\n+                case GUST:\n+                    newState = new QuantityType<>(value, SmartHomeUnits.METRE_PER_SECOND);\n+                    break;\n+                case RELATIVE_HUMIDITY:\n+                case THUNDER_PROBABILITY:\n+                    newState = new QuantityType<>(value, SmartHomeUnits.PERCENT);\n+                    break;\n+                case PERCENT_FROZEN:\n+                    // Smhi returns -9 for spp if there's no precipitation, convert to UNDEF\n+                    if (value.intValue() == -9) {\n+                        newState = UnDefType.UNDEF;\n+                    } else {\n+                        newState = new QuantityType<>(value, SmartHomeUnits.PERCENT);\n+                    }\n+                    break;\n+                case HIGH_CLOUD_COVER:\n+                case MEDIUM_CLOUD_COVER:\n+                case LOW_CLOUD_COVER:\n+                case TOTAL_CLOUD_COVER:\n+                    newState = new QuantityType<>(value.divide(OCTAS_TO_PERCENT), SmartHomeUnits.PERCENT);\n+                    break;\n+                case PRECIPITATION_MAX:\n+                case PRECIPITATION_MEAN:\n+                case PRECIPITATION_MEDIAN:\n+                case PRECIPITATION_MIN:\n+                    newState = new QuantityType<>(value, SmartHomeUnits.MILLIMETRE_PER_HOUR);\n+                    break;\n+                default:\n+                    newState = new DecimalType(value);\n+            }\n+        }\n+\n+        updateState(channel.getUID(), newState);\n+    }\n+\n+    /**\n+     * Dispose the {@link org.eclipse.smarthome.core.thing.binding.ThingHandler}. Cancel scheduled jobs\n+     */\n+    public void dispose() {\n+        Future<?> localRef = forecastUpdater;\n+        if (localRef != null) {\n+            localRef.cancel(false);\n+        }\n+        localRef = instantUpdate;\n+        if (localRef != null) {\n+            localRef.cancel(false);\n+        }\n+    }\n+\n+    /**\n+     * First check if the time has shifted to a new hour, then start checking if a new forecast have been\n+     * published, in that case, fetch it and update channels.\n+     */\n+    private void waitForForecast() {\n+        if (isItNewHour()) {\n+            currentHour = calculateCurrentHour();\n+            currentDay = calculateCurrentDay();\n+            // Update channels with cached forecasts - just shift an hour forward\n+            TimeSeries forecast = cachedTimeSeries;\n+            if (forecast != null) {\n+                updateChannels(forecast);\n+            }\n+            hasLatestForecast = false;\n+        }\n+        if (!hasLatestForecast && isForecastUpdated()) {\n+            getUpdatedForecast();\n+        }\n+    }\n+\n+    /**\n+     * Checks if it is a new hour.\n+     * \n+     * @return true if the current time is more than one hour after currentHour, otherwise false.\n+     */\n+    private boolean isItNewHour() {\n+        return ZonedDateTime.now().minusHours(1).isAfter(currentHour);\n+    }\n+\n+    /**\n+     * Call Smhi's endpoint to check for the time of the last forecast, to see if a new one is available.\n+     * \n+     * @return true if the time of the latest forecast is equal to or after currentHour, otherwise false\n+     */\n+    private boolean isForecastUpdated() {\n+        ZonedDateTime referenceTime;\n+        SmhiConnector apiConnection = connection;\n+        if (apiConnection != null) {\n+            try {\n+                referenceTime = apiConnection.getReferenceTime();\n+            } catch (SmhiException e) {\n+                return false;\n+            }\n+            return referenceTime.isEqual(currentHour) || referenceTime.isAfter(currentHour);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Fetches latest forecast from Smhi, update channels and check if it was published in the current hour.\n+     * If it is, set flag to indicate we have the latest forecast.\n+     */\n+    private void getUpdatedForecast() {\n+        TimeSeries forecast;\n+        ZonedDateTime referenceTime;\n+        SmhiConnector apiConnection = connection;\n+        if (apiConnection != null) {\n+            try {\n+                forecast = apiConnection.getForecast(config.latitude, config.longitude);\n+            } catch (SmhiException e) {\n+                logger.warn(\"Failed to get new forecast: {}\", e.getCause().getMessage());\n+                return;\n+            }\n+            referenceTime = forecast.getReferenceTime();\n+            updateChannels(forecast);\n+            if (referenceTime.isEqual(currentHour) || referenceTime.isAfter(currentHour)) {\n+                hasLatestForecast = true;\n+            }\n+            cachedTimeSeries = forecast;\n+        }\n+    }\n+\n+    /**\n+     * Get the current time rounded down to hour\n+     * \n+     * @return A {@link ZonedDateTime} corresponding to the last even hour\n+     */\n+    private ZonedDateTime calculateCurrentHour() {\n+        ZonedDateTime now = ZonedDateTime.now().withZoneSameInstant(ZoneOffset.UTC);\n+        int y = now.getYear();\n+        int m = now.getMonth().getValue();\n+        int d = now.getDayOfMonth();\n+        int h = now.getHour();\n+        return ZonedDateTime.of(y, m, d, h, 0, 0, 0, ZoneOffset.UTC);\n+    }\n+\n+    /**\n+     * Get the current time rounded down to day\n+     * \n+     * @return A {@link ZonedDateTime} corresponding to the last even day.\n+     */\n+    private ZonedDateTime calculateCurrentDay() {\n+        ZonedDateTime now = ZonedDateTime.now().withZoneSameInstant(ZoneOffset.UTC);\n+        int y = now.getYear();\n+        int m = now.getMonth().getValue();\n+        int d = now.getDayOfMonth();\n+        return ZonedDateTime.of(y, m, d, 0, 0, 0, 0, ZoneOffset.UTC);\n+    }\n+\n+    /**\n+     * Creates channels based on selections in thing configuration\n+     * \n+     * @return\n+     */\n+    private List<Channel> createChannels() {\n+        List<Channel> channels = new ArrayList<>();\n+\n+        // There's currently a bug in PaperUI that can cause options to be added more than one time\n+        // to the list. Convert to a sorted set to work around this.\n+        // See https://github.com/openhab/openhab-webui/issues/212\n+        Set<Integer> hours = new TreeSet<>();\n+        Set<Integer> days = new TreeSet<>();\n+        if (config.hourlyForecasts != null) {\n+            hours.addAll(config.hourlyForecasts);\n+        }\n+        if (config.dailyForecasts != null) {\n+            days.addAll(config.dailyForecasts);\n+        }\n+\n+        for (int i : hours) {\n+            ChannelGroupUID groupUID = new ChannelGroupUID(thing.getUID(), \"hour_\" + i);\n+            CHANNEL_IDS.forEach(id -> {\n+                ChannelUID channelUID = new ChannelUID(groupUID, id);\n+                Channel channel = ChannelBuilder.create(channelUID, \"Number\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY2Njk2Mg=="}, "originalCommit": {"oid": "086a20070bdf370b51d38471f065dda2cb862ded"}, "originalPosition": 404}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcxMzE4Ng==", "bodyText": "Not sure myself. But after looking at the core code it seems like you can just set the itemType to null. If the core was coded sensibly it would look at the ChannelType's itemType in the case that the Channel's itemType was missing. I think that would be one way to avoid redefining the itemtypes if it works.", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r439713186", "createdAt": "2020-06-13T06:08:30Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiHandler.java", "diffHunk": "@@ -0,0 +1,421 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smhi.internal;\n+\n+import static org.openhab.binding.smhi.internal.SmhiBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.MetricPrefix;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelGroupUID;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerCallback;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SmhiHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmhiHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SmhiHandler.class);\n+\n+    private @NonNullByDefault({}) SmhiConfiguration config;\n+\n+    private final HttpClient httpClient;\n+    private @Nullable SmhiConnector connection;\n+    private ZonedDateTime currentHour;\n+    private ZonedDateTime currentDay;\n+    private @Nullable TimeSeries cachedTimeSeries;\n+    private boolean hasLatestForecast = false;\n+    private @Nullable Future<?> forecastUpdater;\n+    private @Nullable Future<?> instantUpdate;\n+\n+    public SmhiHandler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.currentHour = calculateCurrentHour();\n+        this.currentDay = calculateCurrentDay();\n+    }\n+\n+    /**\n+     * Handles commands sent to channels. Since all values are read-only, only REFRESH commands are allowed.\n+     * Sending REFRESH to any item updates all items, since all values are returned in the response from Smhi.\n+     * Therefore there's a wait of 5 seconds before the values are fetched, in which time all other commands are\n+     * blocked, to prevent spamming Smhi's API.\n+     *\n+     * @param channelUID\n+     * @param command\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            synchronized (this) {\n+                Future<?> localRef = instantUpdate;\n+                if (localRef == null || localRef.isDone()) {\n+                    instantUpdate = scheduler.schedule(this::getUpdatedForecast, 5, TimeUnit.SECONDS);\n+                } else {\n+                    logger.debug(\"Already waiting for scheduled refresh\");\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(SmhiConfiguration.class);\n+        if (config == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+            return;\n+        }\n+        connection = new SmhiConnector(httpClient);\n+\n+        // Check which channel groups are selected in the config.\n+        List<Channel> channels = new ArrayList<>();\n+        channels.addAll(createChannels());\n+        updateThing(editThing().withChannels(channels).build());\n+\n+        startPolling();\n+        updateStatus(ThingStatus.ONLINE);\n+        synchronized (this) {\n+            Future<?> localRef = instantUpdate;\n+            if (localRef == null || localRef.isDone()) {\n+                instantUpdate = scheduler.schedule(this::getUpdatedForecast, 5, TimeUnit.SECONDS);\n+            } else {\n+                logger.debug(\"Already waiting for scheduled refresh\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Start polling for updated weather forecast.\n+     */\n+    private synchronized void startPolling() {\n+        forecastUpdater = scheduler.scheduleWithFixedDelay(this::waitForForecast, 1, 1, TimeUnit.MINUTES);\n+    }\n+\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        if (!isModifyingCurrentConfig(configurationParameters)) {\n+            return;\n+        }\n+\n+        validateConfigurationParameters(configurationParameters);\n+\n+        Configuration configuration = editConfiguration();\n+        for (Map.Entry<String, Object> configurationParameter : configurationParameters.entrySet()) {\n+            configuration.put(configurationParameter.getKey(), configurationParameter.getValue());\n+        }\n+\n+        if (isInitialized()) {\n+            updateConfiguration(configuration);\n+            config = configuration.as(SmhiConfiguration.class);\n+            updateThing(editThing().withChannels(createChannels()).build());\n+        } else {\n+            // persist new configuration and notify Thing Manager\n+            updateConfiguration(configuration);\n+            ThingHandlerCallback callback = getCallback();\n+            if (callback != null) {\n+                callback.configurationUpdated(this.getThing());\n+            } else {\n+                logger.warn(\"Handler {} tried updating its configuration although the handler was already disposed.\",\n+                        this.getClass().getSimpleName());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update channels with new forecast data.\n+     * \n+     * @param timeSeries A {@link TimeSeries} object containing forecasts.\n+     */\n+    private void updateChannels(TimeSeries timeSeries) {\n+        // Loop through hourly forecasts and update those available\n+        for (int i = 0; i < 25; i++) {\n+            List<Channel> channels = thing.getChannelsOfGroup(\"hour_\" + i);\n+            if (channels.isEmpty()) {\n+                continue;\n+            }\n+            Forecast forecast = timeSeries.getForecast(i);\n+            if (forecast != null) {\n+                channels.forEach(c -> {\n+                    String id = c.getUID().getIdWithoutGroup();\n+                    BigDecimal value = forecast.getParameter(id);\n+                    updateChannel(c, value);\n+                });\n+            }\n+        }\n+        // Loop through daily forecasts and updates those available\n+        for (int i = 0; i < 10; i++) {\n+            List<Channel> channels = thing.getChannelsOfGroup(\"day_\" + i);\n+            if (channels.isEmpty()) {\n+                continue;\n+            }\n+            Forecast forecast = timeSeries.getForecast(currentDay, 24 * i + 12);\n+\n+            if (forecast == null) {\n+                logger.debug(\"No forecast yet for {}\", currentDay.plusHours(24 * i + 12));\n+                channels.forEach(c -> {\n+                    updateState(c.getUID(), UnDefType.NULL);\n+                });\n+            } else {\n+                channels.forEach(c -> {\n+                    String id = c.getUID().getIdWithoutGroup();\n+                    BigDecimal value = forecast.getParameter(id);\n+                    updateChannel(c, value);\n+                });\n+            }\n+        }\n+    }\n+\n+    private void updateChannel(Channel channel, @Nullable BigDecimal value) {\n+        String id = channel.getUID().getIdWithoutGroup();\n+        State newState = UnDefType.NULL;\n+\n+        if (value != null) {\n+            switch (id) {\n+                case PRESSURE:\n+                    newState = new QuantityType<>(value, MetricPrefix.HECTO(SIUnits.PASCAL));\n+                    break;\n+                case TEMPERATURE:\n+                    newState = new QuantityType<>(value, SIUnits.CELSIUS);\n+                    break;\n+                case VISIBILITY:\n+                    newState = new QuantityType<>(value, MetricPrefix.KILO(SIUnits.METRE));\n+                    break;\n+                case WIND_DIRECTION:\n+                    newState = new QuantityType<>(value, SmartHomeUnits.DEGREE_ANGLE);\n+                    break;\n+                case WIND_SPEED:\n+                case GUST:\n+                    newState = new QuantityType<>(value, SmartHomeUnits.METRE_PER_SECOND);\n+                    break;\n+                case RELATIVE_HUMIDITY:\n+                case THUNDER_PROBABILITY:\n+                    newState = new QuantityType<>(value, SmartHomeUnits.PERCENT);\n+                    break;\n+                case PERCENT_FROZEN:\n+                    // Smhi returns -9 for spp if there's no precipitation, convert to UNDEF\n+                    if (value.intValue() == -9) {\n+                        newState = UnDefType.UNDEF;\n+                    } else {\n+                        newState = new QuantityType<>(value, SmartHomeUnits.PERCENT);\n+                    }\n+                    break;\n+                case HIGH_CLOUD_COVER:\n+                case MEDIUM_CLOUD_COVER:\n+                case LOW_CLOUD_COVER:\n+                case TOTAL_CLOUD_COVER:\n+                    newState = new QuantityType<>(value.divide(OCTAS_TO_PERCENT), SmartHomeUnits.PERCENT);\n+                    break;\n+                case PRECIPITATION_MAX:\n+                case PRECIPITATION_MEAN:\n+                case PRECIPITATION_MEDIAN:\n+                case PRECIPITATION_MIN:\n+                    newState = new QuantityType<>(value, SmartHomeUnits.MILLIMETRE_PER_HOUR);\n+                    break;\n+                default:\n+                    newState = new DecimalType(value);\n+            }\n+        }\n+\n+        updateState(channel.getUID(), newState);\n+    }\n+\n+    /**\n+     * Dispose the {@link org.eclipse.smarthome.core.thing.binding.ThingHandler}. Cancel scheduled jobs\n+     */\n+    public void dispose() {\n+        Future<?> localRef = forecastUpdater;\n+        if (localRef != null) {\n+            localRef.cancel(false);\n+        }\n+        localRef = instantUpdate;\n+        if (localRef != null) {\n+            localRef.cancel(false);\n+        }\n+    }\n+\n+    /**\n+     * First check if the time has shifted to a new hour, then start checking if a new forecast have been\n+     * published, in that case, fetch it and update channels.\n+     */\n+    private void waitForForecast() {\n+        if (isItNewHour()) {\n+            currentHour = calculateCurrentHour();\n+            currentDay = calculateCurrentDay();\n+            // Update channels with cached forecasts - just shift an hour forward\n+            TimeSeries forecast = cachedTimeSeries;\n+            if (forecast != null) {\n+                updateChannels(forecast);\n+            }\n+            hasLatestForecast = false;\n+        }\n+        if (!hasLatestForecast && isForecastUpdated()) {\n+            getUpdatedForecast();\n+        }\n+    }\n+\n+    /**\n+     * Checks if it is a new hour.\n+     * \n+     * @return true if the current time is more than one hour after currentHour, otherwise false.\n+     */\n+    private boolean isItNewHour() {\n+        return ZonedDateTime.now().minusHours(1).isAfter(currentHour);\n+    }\n+\n+    /**\n+     * Call Smhi's endpoint to check for the time of the last forecast, to see if a new one is available.\n+     * \n+     * @return true if the time of the latest forecast is equal to or after currentHour, otherwise false\n+     */\n+    private boolean isForecastUpdated() {\n+        ZonedDateTime referenceTime;\n+        SmhiConnector apiConnection = connection;\n+        if (apiConnection != null) {\n+            try {\n+                referenceTime = apiConnection.getReferenceTime();\n+            } catch (SmhiException e) {\n+                return false;\n+            }\n+            return referenceTime.isEqual(currentHour) || referenceTime.isAfter(currentHour);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Fetches latest forecast from Smhi, update channels and check if it was published in the current hour.\n+     * If it is, set flag to indicate we have the latest forecast.\n+     */\n+    private void getUpdatedForecast() {\n+        TimeSeries forecast;\n+        ZonedDateTime referenceTime;\n+        SmhiConnector apiConnection = connection;\n+        if (apiConnection != null) {\n+            try {\n+                forecast = apiConnection.getForecast(config.latitude, config.longitude);\n+            } catch (SmhiException e) {\n+                logger.warn(\"Failed to get new forecast: {}\", e.getCause().getMessage());\n+                return;\n+            }\n+            referenceTime = forecast.getReferenceTime();\n+            updateChannels(forecast);\n+            if (referenceTime.isEqual(currentHour) || referenceTime.isAfter(currentHour)) {\n+                hasLatestForecast = true;\n+            }\n+            cachedTimeSeries = forecast;\n+        }\n+    }\n+\n+    /**\n+     * Get the current time rounded down to hour\n+     * \n+     * @return A {@link ZonedDateTime} corresponding to the last even hour\n+     */\n+    private ZonedDateTime calculateCurrentHour() {\n+        ZonedDateTime now = ZonedDateTime.now().withZoneSameInstant(ZoneOffset.UTC);\n+        int y = now.getYear();\n+        int m = now.getMonth().getValue();\n+        int d = now.getDayOfMonth();\n+        int h = now.getHour();\n+        return ZonedDateTime.of(y, m, d, h, 0, 0, 0, ZoneOffset.UTC);\n+    }\n+\n+    /**\n+     * Get the current time rounded down to day\n+     * \n+     * @return A {@link ZonedDateTime} corresponding to the last even day.\n+     */\n+    private ZonedDateTime calculateCurrentDay() {\n+        ZonedDateTime now = ZonedDateTime.now().withZoneSameInstant(ZoneOffset.UTC);\n+        int y = now.getYear();\n+        int m = now.getMonth().getValue();\n+        int d = now.getDayOfMonth();\n+        return ZonedDateTime.of(y, m, d, 0, 0, 0, 0, ZoneOffset.UTC);\n+    }\n+\n+    /**\n+     * Creates channels based on selections in thing configuration\n+     * \n+     * @return\n+     */\n+    private List<Channel> createChannels() {\n+        List<Channel> channels = new ArrayList<>();\n+\n+        // There's currently a bug in PaperUI that can cause options to be added more than one time\n+        // to the list. Convert to a sorted set to work around this.\n+        // See https://github.com/openhab/openhab-webui/issues/212\n+        Set<Integer> hours = new TreeSet<>();\n+        Set<Integer> days = new TreeSet<>();\n+        if (config.hourlyForecasts != null) {\n+            hours.addAll(config.hourlyForecasts);\n+        }\n+        if (config.dailyForecasts != null) {\n+            days.addAll(config.dailyForecasts);\n+        }\n+\n+        for (int i : hours) {\n+            ChannelGroupUID groupUID = new ChannelGroupUID(thing.getUID(), \"hour_\" + i);\n+            CHANNEL_IDS.forEach(id -> {\n+                ChannelUID channelUID = new ChannelUID(groupUID, id);\n+                Channel channel = ChannelBuilder.create(channelUID, \"Number\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY2Njk2Mg=="}, "originalCommit": {"oid": "086a20070bdf370b51d38471f065dda2cb862ded"}, "originalPosition": 404}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcxNjM3OQ==", "bodyText": "Thanks, will try and test it out!", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r439716379", "createdAt": "2020-06-13T07:04:58Z", "author": {"login": "pacive"}, "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiHandler.java", "diffHunk": "@@ -0,0 +1,421 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smhi.internal;\n+\n+import static org.openhab.binding.smhi.internal.SmhiBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.MetricPrefix;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelGroupUID;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerCallback;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SmhiHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmhiHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SmhiHandler.class);\n+\n+    private @NonNullByDefault({}) SmhiConfiguration config;\n+\n+    private final HttpClient httpClient;\n+    private @Nullable SmhiConnector connection;\n+    private ZonedDateTime currentHour;\n+    private ZonedDateTime currentDay;\n+    private @Nullable TimeSeries cachedTimeSeries;\n+    private boolean hasLatestForecast = false;\n+    private @Nullable Future<?> forecastUpdater;\n+    private @Nullable Future<?> instantUpdate;\n+\n+    public SmhiHandler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.currentHour = calculateCurrentHour();\n+        this.currentDay = calculateCurrentDay();\n+    }\n+\n+    /**\n+     * Handles commands sent to channels. Since all values are read-only, only REFRESH commands are allowed.\n+     * Sending REFRESH to any item updates all items, since all values are returned in the response from Smhi.\n+     * Therefore there's a wait of 5 seconds before the values are fetched, in which time all other commands are\n+     * blocked, to prevent spamming Smhi's API.\n+     *\n+     * @param channelUID\n+     * @param command\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            synchronized (this) {\n+                Future<?> localRef = instantUpdate;\n+                if (localRef == null || localRef.isDone()) {\n+                    instantUpdate = scheduler.schedule(this::getUpdatedForecast, 5, TimeUnit.SECONDS);\n+                } else {\n+                    logger.debug(\"Already waiting for scheduled refresh\");\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(SmhiConfiguration.class);\n+        if (config == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+            return;\n+        }\n+        connection = new SmhiConnector(httpClient);\n+\n+        // Check which channel groups are selected in the config.\n+        List<Channel> channels = new ArrayList<>();\n+        channels.addAll(createChannels());\n+        updateThing(editThing().withChannels(channels).build());\n+\n+        startPolling();\n+        updateStatus(ThingStatus.ONLINE);\n+        synchronized (this) {\n+            Future<?> localRef = instantUpdate;\n+            if (localRef == null || localRef.isDone()) {\n+                instantUpdate = scheduler.schedule(this::getUpdatedForecast, 5, TimeUnit.SECONDS);\n+            } else {\n+                logger.debug(\"Already waiting for scheduled refresh\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Start polling for updated weather forecast.\n+     */\n+    private synchronized void startPolling() {\n+        forecastUpdater = scheduler.scheduleWithFixedDelay(this::waitForForecast, 1, 1, TimeUnit.MINUTES);\n+    }\n+\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        if (!isModifyingCurrentConfig(configurationParameters)) {\n+            return;\n+        }\n+\n+        validateConfigurationParameters(configurationParameters);\n+\n+        Configuration configuration = editConfiguration();\n+        for (Map.Entry<String, Object> configurationParameter : configurationParameters.entrySet()) {\n+            configuration.put(configurationParameter.getKey(), configurationParameter.getValue());\n+        }\n+\n+        if (isInitialized()) {\n+            updateConfiguration(configuration);\n+            config = configuration.as(SmhiConfiguration.class);\n+            updateThing(editThing().withChannels(createChannels()).build());\n+        } else {\n+            // persist new configuration and notify Thing Manager\n+            updateConfiguration(configuration);\n+            ThingHandlerCallback callback = getCallback();\n+            if (callback != null) {\n+                callback.configurationUpdated(this.getThing());\n+            } else {\n+                logger.warn(\"Handler {} tried updating its configuration although the handler was already disposed.\",\n+                        this.getClass().getSimpleName());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update channels with new forecast data.\n+     * \n+     * @param timeSeries A {@link TimeSeries} object containing forecasts.\n+     */\n+    private void updateChannels(TimeSeries timeSeries) {\n+        // Loop through hourly forecasts and update those available\n+        for (int i = 0; i < 25; i++) {\n+            List<Channel> channels = thing.getChannelsOfGroup(\"hour_\" + i);\n+            if (channels.isEmpty()) {\n+                continue;\n+            }\n+            Forecast forecast = timeSeries.getForecast(i);\n+            if (forecast != null) {\n+                channels.forEach(c -> {\n+                    String id = c.getUID().getIdWithoutGroup();\n+                    BigDecimal value = forecast.getParameter(id);\n+                    updateChannel(c, value);\n+                });\n+            }\n+        }\n+        // Loop through daily forecasts and updates those available\n+        for (int i = 0; i < 10; i++) {\n+            List<Channel> channels = thing.getChannelsOfGroup(\"day_\" + i);\n+            if (channels.isEmpty()) {\n+                continue;\n+            }\n+            Forecast forecast = timeSeries.getForecast(currentDay, 24 * i + 12);\n+\n+            if (forecast == null) {\n+                logger.debug(\"No forecast yet for {}\", currentDay.plusHours(24 * i + 12));\n+                channels.forEach(c -> {\n+                    updateState(c.getUID(), UnDefType.NULL);\n+                });\n+            } else {\n+                channels.forEach(c -> {\n+                    String id = c.getUID().getIdWithoutGroup();\n+                    BigDecimal value = forecast.getParameter(id);\n+                    updateChannel(c, value);\n+                });\n+            }\n+        }\n+    }\n+\n+    private void updateChannel(Channel channel, @Nullable BigDecimal value) {\n+        String id = channel.getUID().getIdWithoutGroup();\n+        State newState = UnDefType.NULL;\n+\n+        if (value != null) {\n+            switch (id) {\n+                case PRESSURE:\n+                    newState = new QuantityType<>(value, MetricPrefix.HECTO(SIUnits.PASCAL));\n+                    break;\n+                case TEMPERATURE:\n+                    newState = new QuantityType<>(value, SIUnits.CELSIUS);\n+                    break;\n+                case VISIBILITY:\n+                    newState = new QuantityType<>(value, MetricPrefix.KILO(SIUnits.METRE));\n+                    break;\n+                case WIND_DIRECTION:\n+                    newState = new QuantityType<>(value, SmartHomeUnits.DEGREE_ANGLE);\n+                    break;\n+                case WIND_SPEED:\n+                case GUST:\n+                    newState = new QuantityType<>(value, SmartHomeUnits.METRE_PER_SECOND);\n+                    break;\n+                case RELATIVE_HUMIDITY:\n+                case THUNDER_PROBABILITY:\n+                    newState = new QuantityType<>(value, SmartHomeUnits.PERCENT);\n+                    break;\n+                case PERCENT_FROZEN:\n+                    // Smhi returns -9 for spp if there's no precipitation, convert to UNDEF\n+                    if (value.intValue() == -9) {\n+                        newState = UnDefType.UNDEF;\n+                    } else {\n+                        newState = new QuantityType<>(value, SmartHomeUnits.PERCENT);\n+                    }\n+                    break;\n+                case HIGH_CLOUD_COVER:\n+                case MEDIUM_CLOUD_COVER:\n+                case LOW_CLOUD_COVER:\n+                case TOTAL_CLOUD_COVER:\n+                    newState = new QuantityType<>(value.divide(OCTAS_TO_PERCENT), SmartHomeUnits.PERCENT);\n+                    break;\n+                case PRECIPITATION_MAX:\n+                case PRECIPITATION_MEAN:\n+                case PRECIPITATION_MEDIAN:\n+                case PRECIPITATION_MIN:\n+                    newState = new QuantityType<>(value, SmartHomeUnits.MILLIMETRE_PER_HOUR);\n+                    break;\n+                default:\n+                    newState = new DecimalType(value);\n+            }\n+        }\n+\n+        updateState(channel.getUID(), newState);\n+    }\n+\n+    /**\n+     * Dispose the {@link org.eclipse.smarthome.core.thing.binding.ThingHandler}. Cancel scheduled jobs\n+     */\n+    public void dispose() {\n+        Future<?> localRef = forecastUpdater;\n+        if (localRef != null) {\n+            localRef.cancel(false);\n+        }\n+        localRef = instantUpdate;\n+        if (localRef != null) {\n+            localRef.cancel(false);\n+        }\n+    }\n+\n+    /**\n+     * First check if the time has shifted to a new hour, then start checking if a new forecast have been\n+     * published, in that case, fetch it and update channels.\n+     */\n+    private void waitForForecast() {\n+        if (isItNewHour()) {\n+            currentHour = calculateCurrentHour();\n+            currentDay = calculateCurrentDay();\n+            // Update channels with cached forecasts - just shift an hour forward\n+            TimeSeries forecast = cachedTimeSeries;\n+            if (forecast != null) {\n+                updateChannels(forecast);\n+            }\n+            hasLatestForecast = false;\n+        }\n+        if (!hasLatestForecast && isForecastUpdated()) {\n+            getUpdatedForecast();\n+        }\n+    }\n+\n+    /**\n+     * Checks if it is a new hour.\n+     * \n+     * @return true if the current time is more than one hour after currentHour, otherwise false.\n+     */\n+    private boolean isItNewHour() {\n+        return ZonedDateTime.now().minusHours(1).isAfter(currentHour);\n+    }\n+\n+    /**\n+     * Call Smhi's endpoint to check for the time of the last forecast, to see if a new one is available.\n+     * \n+     * @return true if the time of the latest forecast is equal to or after currentHour, otherwise false\n+     */\n+    private boolean isForecastUpdated() {\n+        ZonedDateTime referenceTime;\n+        SmhiConnector apiConnection = connection;\n+        if (apiConnection != null) {\n+            try {\n+                referenceTime = apiConnection.getReferenceTime();\n+            } catch (SmhiException e) {\n+                return false;\n+            }\n+            return referenceTime.isEqual(currentHour) || referenceTime.isAfter(currentHour);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Fetches latest forecast from Smhi, update channels and check if it was published in the current hour.\n+     * If it is, set flag to indicate we have the latest forecast.\n+     */\n+    private void getUpdatedForecast() {\n+        TimeSeries forecast;\n+        ZonedDateTime referenceTime;\n+        SmhiConnector apiConnection = connection;\n+        if (apiConnection != null) {\n+            try {\n+                forecast = apiConnection.getForecast(config.latitude, config.longitude);\n+            } catch (SmhiException e) {\n+                logger.warn(\"Failed to get new forecast: {}\", e.getCause().getMessage());\n+                return;\n+            }\n+            referenceTime = forecast.getReferenceTime();\n+            updateChannels(forecast);\n+            if (referenceTime.isEqual(currentHour) || referenceTime.isAfter(currentHour)) {\n+                hasLatestForecast = true;\n+            }\n+            cachedTimeSeries = forecast;\n+        }\n+    }\n+\n+    /**\n+     * Get the current time rounded down to hour\n+     * \n+     * @return A {@link ZonedDateTime} corresponding to the last even hour\n+     */\n+    private ZonedDateTime calculateCurrentHour() {\n+        ZonedDateTime now = ZonedDateTime.now().withZoneSameInstant(ZoneOffset.UTC);\n+        int y = now.getYear();\n+        int m = now.getMonth().getValue();\n+        int d = now.getDayOfMonth();\n+        int h = now.getHour();\n+        return ZonedDateTime.of(y, m, d, h, 0, 0, 0, ZoneOffset.UTC);\n+    }\n+\n+    /**\n+     * Get the current time rounded down to day\n+     * \n+     * @return A {@link ZonedDateTime} corresponding to the last even day.\n+     */\n+    private ZonedDateTime calculateCurrentDay() {\n+        ZonedDateTime now = ZonedDateTime.now().withZoneSameInstant(ZoneOffset.UTC);\n+        int y = now.getYear();\n+        int m = now.getMonth().getValue();\n+        int d = now.getDayOfMonth();\n+        return ZonedDateTime.of(y, m, d, 0, 0, 0, 0, ZoneOffset.UTC);\n+    }\n+\n+    /**\n+     * Creates channels based on selections in thing configuration\n+     * \n+     * @return\n+     */\n+    private List<Channel> createChannels() {\n+        List<Channel> channels = new ArrayList<>();\n+\n+        // There's currently a bug in PaperUI that can cause options to be added more than one time\n+        // to the list. Convert to a sorted set to work around this.\n+        // See https://github.com/openhab/openhab-webui/issues/212\n+        Set<Integer> hours = new TreeSet<>();\n+        Set<Integer> days = new TreeSet<>();\n+        if (config.hourlyForecasts != null) {\n+            hours.addAll(config.hourlyForecasts);\n+        }\n+        if (config.dailyForecasts != null) {\n+            days.addAll(config.dailyForecasts);\n+        }\n+\n+        for (int i : hours) {\n+            ChannelGroupUID groupUID = new ChannelGroupUID(thing.getUID(), \"hour_\" + i);\n+            CHANNEL_IDS.forEach(id -> {\n+                ChannelUID channelUID = new ChannelUID(groupUID, id);\n+                Channel channel = ChannelBuilder.create(channelUID, \"Number\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY2Njk2Mg=="}, "originalCommit": {"oid": "086a20070bdf370b51d38471f065dda2cb862ded"}, "originalPosition": 404}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcyMDM3Nw==", "bodyText": "Didn't work. The acceptedItemType property remained null, giving no hint to the UI what item type to use. Had to do it the harder way instead.", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r439720377", "createdAt": "2020-06-13T08:15:14Z", "author": {"login": "pacive"}, "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiHandler.java", "diffHunk": "@@ -0,0 +1,421 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smhi.internal;\n+\n+import static org.openhab.binding.smhi.internal.SmhiBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.MetricPrefix;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelGroupUID;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerCallback;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SmhiHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmhiHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SmhiHandler.class);\n+\n+    private @NonNullByDefault({}) SmhiConfiguration config;\n+\n+    private final HttpClient httpClient;\n+    private @Nullable SmhiConnector connection;\n+    private ZonedDateTime currentHour;\n+    private ZonedDateTime currentDay;\n+    private @Nullable TimeSeries cachedTimeSeries;\n+    private boolean hasLatestForecast = false;\n+    private @Nullable Future<?> forecastUpdater;\n+    private @Nullable Future<?> instantUpdate;\n+\n+    public SmhiHandler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.currentHour = calculateCurrentHour();\n+        this.currentDay = calculateCurrentDay();\n+    }\n+\n+    /**\n+     * Handles commands sent to channels. Since all values are read-only, only REFRESH commands are allowed.\n+     * Sending REFRESH to any item updates all items, since all values are returned in the response from Smhi.\n+     * Therefore there's a wait of 5 seconds before the values are fetched, in which time all other commands are\n+     * blocked, to prevent spamming Smhi's API.\n+     *\n+     * @param channelUID\n+     * @param command\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            synchronized (this) {\n+                Future<?> localRef = instantUpdate;\n+                if (localRef == null || localRef.isDone()) {\n+                    instantUpdate = scheduler.schedule(this::getUpdatedForecast, 5, TimeUnit.SECONDS);\n+                } else {\n+                    logger.debug(\"Already waiting for scheduled refresh\");\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(SmhiConfiguration.class);\n+        if (config == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+            return;\n+        }\n+        connection = new SmhiConnector(httpClient);\n+\n+        // Check which channel groups are selected in the config.\n+        List<Channel> channels = new ArrayList<>();\n+        channels.addAll(createChannels());\n+        updateThing(editThing().withChannels(channels).build());\n+\n+        startPolling();\n+        updateStatus(ThingStatus.ONLINE);\n+        synchronized (this) {\n+            Future<?> localRef = instantUpdate;\n+            if (localRef == null || localRef.isDone()) {\n+                instantUpdate = scheduler.schedule(this::getUpdatedForecast, 5, TimeUnit.SECONDS);\n+            } else {\n+                logger.debug(\"Already waiting for scheduled refresh\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Start polling for updated weather forecast.\n+     */\n+    private synchronized void startPolling() {\n+        forecastUpdater = scheduler.scheduleWithFixedDelay(this::waitForForecast, 1, 1, TimeUnit.MINUTES);\n+    }\n+\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        if (!isModifyingCurrentConfig(configurationParameters)) {\n+            return;\n+        }\n+\n+        validateConfigurationParameters(configurationParameters);\n+\n+        Configuration configuration = editConfiguration();\n+        for (Map.Entry<String, Object> configurationParameter : configurationParameters.entrySet()) {\n+            configuration.put(configurationParameter.getKey(), configurationParameter.getValue());\n+        }\n+\n+        if (isInitialized()) {\n+            updateConfiguration(configuration);\n+            config = configuration.as(SmhiConfiguration.class);\n+            updateThing(editThing().withChannels(createChannels()).build());\n+        } else {\n+            // persist new configuration and notify Thing Manager\n+            updateConfiguration(configuration);\n+            ThingHandlerCallback callback = getCallback();\n+            if (callback != null) {\n+                callback.configurationUpdated(this.getThing());\n+            } else {\n+                logger.warn(\"Handler {} tried updating its configuration although the handler was already disposed.\",\n+                        this.getClass().getSimpleName());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update channels with new forecast data.\n+     * \n+     * @param timeSeries A {@link TimeSeries} object containing forecasts.\n+     */\n+    private void updateChannels(TimeSeries timeSeries) {\n+        // Loop through hourly forecasts and update those available\n+        for (int i = 0; i < 25; i++) {\n+            List<Channel> channels = thing.getChannelsOfGroup(\"hour_\" + i);\n+            if (channels.isEmpty()) {\n+                continue;\n+            }\n+            Forecast forecast = timeSeries.getForecast(i);\n+            if (forecast != null) {\n+                channels.forEach(c -> {\n+                    String id = c.getUID().getIdWithoutGroup();\n+                    BigDecimal value = forecast.getParameter(id);\n+                    updateChannel(c, value);\n+                });\n+            }\n+        }\n+        // Loop through daily forecasts and updates those available\n+        for (int i = 0; i < 10; i++) {\n+            List<Channel> channels = thing.getChannelsOfGroup(\"day_\" + i);\n+            if (channels.isEmpty()) {\n+                continue;\n+            }\n+            Forecast forecast = timeSeries.getForecast(currentDay, 24 * i + 12);\n+\n+            if (forecast == null) {\n+                logger.debug(\"No forecast yet for {}\", currentDay.plusHours(24 * i + 12));\n+                channels.forEach(c -> {\n+                    updateState(c.getUID(), UnDefType.NULL);\n+                });\n+            } else {\n+                channels.forEach(c -> {\n+                    String id = c.getUID().getIdWithoutGroup();\n+                    BigDecimal value = forecast.getParameter(id);\n+                    updateChannel(c, value);\n+                });\n+            }\n+        }\n+    }\n+\n+    private void updateChannel(Channel channel, @Nullable BigDecimal value) {\n+        String id = channel.getUID().getIdWithoutGroup();\n+        State newState = UnDefType.NULL;\n+\n+        if (value != null) {\n+            switch (id) {\n+                case PRESSURE:\n+                    newState = new QuantityType<>(value, MetricPrefix.HECTO(SIUnits.PASCAL));\n+                    break;\n+                case TEMPERATURE:\n+                    newState = new QuantityType<>(value, SIUnits.CELSIUS);\n+                    break;\n+                case VISIBILITY:\n+                    newState = new QuantityType<>(value, MetricPrefix.KILO(SIUnits.METRE));\n+                    break;\n+                case WIND_DIRECTION:\n+                    newState = new QuantityType<>(value, SmartHomeUnits.DEGREE_ANGLE);\n+                    break;\n+                case WIND_SPEED:\n+                case GUST:\n+                    newState = new QuantityType<>(value, SmartHomeUnits.METRE_PER_SECOND);\n+                    break;\n+                case RELATIVE_HUMIDITY:\n+                case THUNDER_PROBABILITY:\n+                    newState = new QuantityType<>(value, SmartHomeUnits.PERCENT);\n+                    break;\n+                case PERCENT_FROZEN:\n+                    // Smhi returns -9 for spp if there's no precipitation, convert to UNDEF\n+                    if (value.intValue() == -9) {\n+                        newState = UnDefType.UNDEF;\n+                    } else {\n+                        newState = new QuantityType<>(value, SmartHomeUnits.PERCENT);\n+                    }\n+                    break;\n+                case HIGH_CLOUD_COVER:\n+                case MEDIUM_CLOUD_COVER:\n+                case LOW_CLOUD_COVER:\n+                case TOTAL_CLOUD_COVER:\n+                    newState = new QuantityType<>(value.divide(OCTAS_TO_PERCENT), SmartHomeUnits.PERCENT);\n+                    break;\n+                case PRECIPITATION_MAX:\n+                case PRECIPITATION_MEAN:\n+                case PRECIPITATION_MEDIAN:\n+                case PRECIPITATION_MIN:\n+                    newState = new QuantityType<>(value, SmartHomeUnits.MILLIMETRE_PER_HOUR);\n+                    break;\n+                default:\n+                    newState = new DecimalType(value);\n+            }\n+        }\n+\n+        updateState(channel.getUID(), newState);\n+    }\n+\n+    /**\n+     * Dispose the {@link org.eclipse.smarthome.core.thing.binding.ThingHandler}. Cancel scheduled jobs\n+     */\n+    public void dispose() {\n+        Future<?> localRef = forecastUpdater;\n+        if (localRef != null) {\n+            localRef.cancel(false);\n+        }\n+        localRef = instantUpdate;\n+        if (localRef != null) {\n+            localRef.cancel(false);\n+        }\n+    }\n+\n+    /**\n+     * First check if the time has shifted to a new hour, then start checking if a new forecast have been\n+     * published, in that case, fetch it and update channels.\n+     */\n+    private void waitForForecast() {\n+        if (isItNewHour()) {\n+            currentHour = calculateCurrentHour();\n+            currentDay = calculateCurrentDay();\n+            // Update channels with cached forecasts - just shift an hour forward\n+            TimeSeries forecast = cachedTimeSeries;\n+            if (forecast != null) {\n+                updateChannels(forecast);\n+            }\n+            hasLatestForecast = false;\n+        }\n+        if (!hasLatestForecast && isForecastUpdated()) {\n+            getUpdatedForecast();\n+        }\n+    }\n+\n+    /**\n+     * Checks if it is a new hour.\n+     * \n+     * @return true if the current time is more than one hour after currentHour, otherwise false.\n+     */\n+    private boolean isItNewHour() {\n+        return ZonedDateTime.now().minusHours(1).isAfter(currentHour);\n+    }\n+\n+    /**\n+     * Call Smhi's endpoint to check for the time of the last forecast, to see if a new one is available.\n+     * \n+     * @return true if the time of the latest forecast is equal to or after currentHour, otherwise false\n+     */\n+    private boolean isForecastUpdated() {\n+        ZonedDateTime referenceTime;\n+        SmhiConnector apiConnection = connection;\n+        if (apiConnection != null) {\n+            try {\n+                referenceTime = apiConnection.getReferenceTime();\n+            } catch (SmhiException e) {\n+                return false;\n+            }\n+            return referenceTime.isEqual(currentHour) || referenceTime.isAfter(currentHour);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Fetches latest forecast from Smhi, update channels and check if it was published in the current hour.\n+     * If it is, set flag to indicate we have the latest forecast.\n+     */\n+    private void getUpdatedForecast() {\n+        TimeSeries forecast;\n+        ZonedDateTime referenceTime;\n+        SmhiConnector apiConnection = connection;\n+        if (apiConnection != null) {\n+            try {\n+                forecast = apiConnection.getForecast(config.latitude, config.longitude);\n+            } catch (SmhiException e) {\n+                logger.warn(\"Failed to get new forecast: {}\", e.getCause().getMessage());\n+                return;\n+            }\n+            referenceTime = forecast.getReferenceTime();\n+            updateChannels(forecast);\n+            if (referenceTime.isEqual(currentHour) || referenceTime.isAfter(currentHour)) {\n+                hasLatestForecast = true;\n+            }\n+            cachedTimeSeries = forecast;\n+        }\n+    }\n+\n+    /**\n+     * Get the current time rounded down to hour\n+     * \n+     * @return A {@link ZonedDateTime} corresponding to the last even hour\n+     */\n+    private ZonedDateTime calculateCurrentHour() {\n+        ZonedDateTime now = ZonedDateTime.now().withZoneSameInstant(ZoneOffset.UTC);\n+        int y = now.getYear();\n+        int m = now.getMonth().getValue();\n+        int d = now.getDayOfMonth();\n+        int h = now.getHour();\n+        return ZonedDateTime.of(y, m, d, h, 0, 0, 0, ZoneOffset.UTC);\n+    }\n+\n+    /**\n+     * Get the current time rounded down to day\n+     * \n+     * @return A {@link ZonedDateTime} corresponding to the last even day.\n+     */\n+    private ZonedDateTime calculateCurrentDay() {\n+        ZonedDateTime now = ZonedDateTime.now().withZoneSameInstant(ZoneOffset.UTC);\n+        int y = now.getYear();\n+        int m = now.getMonth().getValue();\n+        int d = now.getDayOfMonth();\n+        return ZonedDateTime.of(y, m, d, 0, 0, 0, 0, ZoneOffset.UTC);\n+    }\n+\n+    /**\n+     * Creates channels based on selections in thing configuration\n+     * \n+     * @return\n+     */\n+    private List<Channel> createChannels() {\n+        List<Channel> channels = new ArrayList<>();\n+\n+        // There's currently a bug in PaperUI that can cause options to be added more than one time\n+        // to the list. Convert to a sorted set to work around this.\n+        // See https://github.com/openhab/openhab-webui/issues/212\n+        Set<Integer> hours = new TreeSet<>();\n+        Set<Integer> days = new TreeSet<>();\n+        if (config.hourlyForecasts != null) {\n+            hours.addAll(config.hourlyForecasts);\n+        }\n+        if (config.dailyForecasts != null) {\n+            days.addAll(config.dailyForecasts);\n+        }\n+\n+        for (int i : hours) {\n+            ChannelGroupUID groupUID = new ChannelGroupUID(thing.getUID(), \"hour_\" + i);\n+            CHANNEL_IDS.forEach(id -> {\n+                ChannelUID channelUID = new ChannelUID(groupUID, id);\n+                Channel channel = ChannelBuilder.create(channelUID, \"Number\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY2Njk2Mg=="}, "originalCommit": {"oid": "086a20070bdf370b51d38471f065dda2cb862ded"}, "originalPosition": 404}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczODkyOTgyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQyMjozMToxNlrOGjTJmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQyMjozMToxNlrOGjTJmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY2NzA5Ng==", "bodyText": "same here", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r439667096", "createdAt": "2020-06-12T22:31:16Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiHandler.java", "diffHunk": "@@ -0,0 +1,421 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smhi.internal;\n+\n+import static org.openhab.binding.smhi.internal.SmhiBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.MetricPrefix;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelGroupUID;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerCallback;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SmhiHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmhiHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SmhiHandler.class);\n+\n+    private @NonNullByDefault({}) SmhiConfiguration config;\n+\n+    private final HttpClient httpClient;\n+    private @Nullable SmhiConnector connection;\n+    private ZonedDateTime currentHour;\n+    private ZonedDateTime currentDay;\n+    private @Nullable TimeSeries cachedTimeSeries;\n+    private boolean hasLatestForecast = false;\n+    private @Nullable Future<?> forecastUpdater;\n+    private @Nullable Future<?> instantUpdate;\n+\n+    public SmhiHandler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.currentHour = calculateCurrentHour();\n+        this.currentDay = calculateCurrentDay();\n+    }\n+\n+    /**\n+     * Handles commands sent to channels. Since all values are read-only, only REFRESH commands are allowed.\n+     * Sending REFRESH to any item updates all items, since all values are returned in the response from Smhi.\n+     * Therefore there's a wait of 5 seconds before the values are fetched, in which time all other commands are\n+     * blocked, to prevent spamming Smhi's API.\n+     *\n+     * @param channelUID\n+     * @param command\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            synchronized (this) {\n+                Future<?> localRef = instantUpdate;\n+                if (localRef == null || localRef.isDone()) {\n+                    instantUpdate = scheduler.schedule(this::getUpdatedForecast, 5, TimeUnit.SECONDS);\n+                } else {\n+                    logger.debug(\"Already waiting for scheduled refresh\");\n+                }\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(SmhiConfiguration.class);\n+        if (config == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR);\n+            return;\n+        }\n+        connection = new SmhiConnector(httpClient);\n+\n+        // Check which channel groups are selected in the config.\n+        List<Channel> channels = new ArrayList<>();\n+        channels.addAll(createChannels());\n+        updateThing(editThing().withChannels(channels).build());\n+\n+        startPolling();\n+        updateStatus(ThingStatus.ONLINE);\n+        synchronized (this) {\n+            Future<?> localRef = instantUpdate;\n+            if (localRef == null || localRef.isDone()) {\n+                instantUpdate = scheduler.schedule(this::getUpdatedForecast, 5, TimeUnit.SECONDS);\n+            } else {\n+                logger.debug(\"Already waiting for scheduled refresh\");\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Start polling for updated weather forecast.\n+     */\n+    private synchronized void startPolling() {\n+        forecastUpdater = scheduler.scheduleWithFixedDelay(this::waitForForecast, 1, 1, TimeUnit.MINUTES);\n+    }\n+\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        if (!isModifyingCurrentConfig(configurationParameters)) {\n+            return;\n+        }\n+\n+        validateConfigurationParameters(configurationParameters);\n+\n+        Configuration configuration = editConfiguration();\n+        for (Map.Entry<String, Object> configurationParameter : configurationParameters.entrySet()) {\n+            configuration.put(configurationParameter.getKey(), configurationParameter.getValue());\n+        }\n+\n+        if (isInitialized()) {\n+            updateConfiguration(configuration);\n+            config = configuration.as(SmhiConfiguration.class);\n+            updateThing(editThing().withChannels(createChannels()).build());\n+        } else {\n+            // persist new configuration and notify Thing Manager\n+            updateConfiguration(configuration);\n+            ThingHandlerCallback callback = getCallback();\n+            if (callback != null) {\n+                callback.configurationUpdated(this.getThing());\n+            } else {\n+                logger.warn(\"Handler {} tried updating its configuration although the handler was already disposed.\",\n+                        this.getClass().getSimpleName());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update channels with new forecast data.\n+     * \n+     * @param timeSeries A {@link TimeSeries} object containing forecasts.\n+     */\n+    private void updateChannels(TimeSeries timeSeries) {\n+        // Loop through hourly forecasts and update those available\n+        for (int i = 0; i < 25; i++) {\n+            List<Channel> channels = thing.getChannelsOfGroup(\"hour_\" + i);\n+            if (channels.isEmpty()) {\n+                continue;\n+            }\n+            Forecast forecast = timeSeries.getForecast(i);\n+            if (forecast != null) {\n+                channels.forEach(c -> {\n+                    String id = c.getUID().getIdWithoutGroup();\n+                    BigDecimal value = forecast.getParameter(id);\n+                    updateChannel(c, value);\n+                });\n+            }\n+        }\n+        // Loop through daily forecasts and updates those available\n+        for (int i = 0; i < 10; i++) {\n+            List<Channel> channels = thing.getChannelsOfGroup(\"day_\" + i);\n+            if (channels.isEmpty()) {\n+                continue;\n+            }\n+            Forecast forecast = timeSeries.getForecast(currentDay, 24 * i + 12);\n+\n+            if (forecast == null) {\n+                logger.debug(\"No forecast yet for {}\", currentDay.plusHours(24 * i + 12));\n+                channels.forEach(c -> {\n+                    updateState(c.getUID(), UnDefType.NULL);\n+                });\n+            } else {\n+                channels.forEach(c -> {\n+                    String id = c.getUID().getIdWithoutGroup();\n+                    BigDecimal value = forecast.getParameter(id);\n+                    updateChannel(c, value);\n+                });\n+            }\n+        }\n+    }\n+\n+    private void updateChannel(Channel channel, @Nullable BigDecimal value) {\n+        String id = channel.getUID().getIdWithoutGroup();\n+        State newState = UnDefType.NULL;\n+\n+        if (value != null) {\n+            switch (id) {\n+                case PRESSURE:\n+                    newState = new QuantityType<>(value, MetricPrefix.HECTO(SIUnits.PASCAL));\n+                    break;\n+                case TEMPERATURE:\n+                    newState = new QuantityType<>(value, SIUnits.CELSIUS);\n+                    break;\n+                case VISIBILITY:\n+                    newState = new QuantityType<>(value, MetricPrefix.KILO(SIUnits.METRE));\n+                    break;\n+                case WIND_DIRECTION:\n+                    newState = new QuantityType<>(value, SmartHomeUnits.DEGREE_ANGLE);\n+                    break;\n+                case WIND_SPEED:\n+                case GUST:\n+                    newState = new QuantityType<>(value, SmartHomeUnits.METRE_PER_SECOND);\n+                    break;\n+                case RELATIVE_HUMIDITY:\n+                case THUNDER_PROBABILITY:\n+                    newState = new QuantityType<>(value, SmartHomeUnits.PERCENT);\n+                    break;\n+                case PERCENT_FROZEN:\n+                    // Smhi returns -9 for spp if there's no precipitation, convert to UNDEF\n+                    if (value.intValue() == -9) {\n+                        newState = UnDefType.UNDEF;\n+                    } else {\n+                        newState = new QuantityType<>(value, SmartHomeUnits.PERCENT);\n+                    }\n+                    break;\n+                case HIGH_CLOUD_COVER:\n+                case MEDIUM_CLOUD_COVER:\n+                case LOW_CLOUD_COVER:\n+                case TOTAL_CLOUD_COVER:\n+                    newState = new QuantityType<>(value.divide(OCTAS_TO_PERCENT), SmartHomeUnits.PERCENT);\n+                    break;\n+                case PRECIPITATION_MAX:\n+                case PRECIPITATION_MEAN:\n+                case PRECIPITATION_MEDIAN:\n+                case PRECIPITATION_MIN:\n+                    newState = new QuantityType<>(value, SmartHomeUnits.MILLIMETRE_PER_HOUR);\n+                    break;\n+                default:\n+                    newState = new DecimalType(value);\n+            }\n+        }\n+\n+        updateState(channel.getUID(), newState);\n+    }\n+\n+    /**\n+     * Dispose the {@link org.eclipse.smarthome.core.thing.binding.ThingHandler}. Cancel scheduled jobs\n+     */\n+    public void dispose() {\n+        Future<?> localRef = forecastUpdater;\n+        if (localRef != null) {\n+            localRef.cancel(false);\n+        }\n+        localRef = instantUpdate;\n+        if (localRef != null) {\n+            localRef.cancel(false);\n+        }\n+    }\n+\n+    /**\n+     * First check if the time has shifted to a new hour, then start checking if a new forecast have been\n+     * published, in that case, fetch it and update channels.\n+     */\n+    private void waitForForecast() {\n+        if (isItNewHour()) {\n+            currentHour = calculateCurrentHour();\n+            currentDay = calculateCurrentDay();\n+            // Update channels with cached forecasts - just shift an hour forward\n+            TimeSeries forecast = cachedTimeSeries;\n+            if (forecast != null) {\n+                updateChannels(forecast);\n+            }\n+            hasLatestForecast = false;\n+        }\n+        if (!hasLatestForecast && isForecastUpdated()) {\n+            getUpdatedForecast();\n+        }\n+    }\n+\n+    /**\n+     * Checks if it is a new hour.\n+     * \n+     * @return true if the current time is more than one hour after currentHour, otherwise false.\n+     */\n+    private boolean isItNewHour() {\n+        return ZonedDateTime.now().minusHours(1).isAfter(currentHour);\n+    }\n+\n+    /**\n+     * Call Smhi's endpoint to check for the time of the last forecast, to see if a new one is available.\n+     * \n+     * @return true if the time of the latest forecast is equal to or after currentHour, otherwise false\n+     */\n+    private boolean isForecastUpdated() {\n+        ZonedDateTime referenceTime;\n+        SmhiConnector apiConnection = connection;\n+        if (apiConnection != null) {\n+            try {\n+                referenceTime = apiConnection.getReferenceTime();\n+            } catch (SmhiException e) {\n+                return false;\n+            }\n+            return referenceTime.isEqual(currentHour) || referenceTime.isAfter(currentHour);\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Fetches latest forecast from Smhi, update channels and check if it was published in the current hour.\n+     * If it is, set flag to indicate we have the latest forecast.\n+     */\n+    private void getUpdatedForecast() {\n+        TimeSeries forecast;\n+        ZonedDateTime referenceTime;\n+        SmhiConnector apiConnection = connection;\n+        if (apiConnection != null) {\n+            try {\n+                forecast = apiConnection.getForecast(config.latitude, config.longitude);\n+            } catch (SmhiException e) {\n+                logger.warn(\"Failed to get new forecast: {}\", e.getCause().getMessage());\n+                return;\n+            }\n+            referenceTime = forecast.getReferenceTime();\n+            updateChannels(forecast);\n+            if (referenceTime.isEqual(currentHour) || referenceTime.isAfter(currentHour)) {\n+                hasLatestForecast = true;\n+            }\n+            cachedTimeSeries = forecast;\n+        }\n+    }\n+\n+    /**\n+     * Get the current time rounded down to hour\n+     * \n+     * @return A {@link ZonedDateTime} corresponding to the last even hour\n+     */\n+    private ZonedDateTime calculateCurrentHour() {\n+        ZonedDateTime now = ZonedDateTime.now().withZoneSameInstant(ZoneOffset.UTC);\n+        int y = now.getYear();\n+        int m = now.getMonth().getValue();\n+        int d = now.getDayOfMonth();\n+        int h = now.getHour();\n+        return ZonedDateTime.of(y, m, d, h, 0, 0, 0, ZoneOffset.UTC);\n+    }\n+\n+    /**\n+     * Get the current time rounded down to day\n+     * \n+     * @return A {@link ZonedDateTime} corresponding to the last even day.\n+     */\n+    private ZonedDateTime calculateCurrentDay() {\n+        ZonedDateTime now = ZonedDateTime.now().withZoneSameInstant(ZoneOffset.UTC);\n+        int y = now.getYear();\n+        int m = now.getMonth().getValue();\n+        int d = now.getDayOfMonth();\n+        return ZonedDateTime.of(y, m, d, 0, 0, 0, 0, ZoneOffset.UTC);\n+    }\n+\n+    /**\n+     * Creates channels based on selections in thing configuration\n+     * \n+     * @return\n+     */\n+    private List<Channel> createChannels() {\n+        List<Channel> channels = new ArrayList<>();\n+\n+        // There's currently a bug in PaperUI that can cause options to be added more than one time\n+        // to the list. Convert to a sorted set to work around this.\n+        // See https://github.com/openhab/openhab-webui/issues/212\n+        Set<Integer> hours = new TreeSet<>();\n+        Set<Integer> days = new TreeSet<>();\n+        if (config.hourlyForecasts != null) {\n+            hours.addAll(config.hourlyForecasts);\n+        }\n+        if (config.dailyForecasts != null) {\n+            days.addAll(config.dailyForecasts);\n+        }\n+\n+        for (int i : hours) {\n+            ChannelGroupUID groupUID = new ChannelGroupUID(thing.getUID(), \"hour_\" + i);\n+            CHANNEL_IDS.forEach(id -> {\n+                ChannelUID channelUID = new ChannelUID(groupUID, id);\n+                Channel channel = ChannelBuilder.create(channelUID, \"Number\")\n+                        .withType(new ChannelTypeUID(BINDING_ID, id)).build();\n+                channels.add(channel);\n+            });\n+        }\n+\n+        for (int i : days) {\n+            ChannelGroupUID groupUID = new ChannelGroupUID(thing.getUID(), \"day_\" + i);\n+            CHANNEL_IDS.forEach(id -> {\n+                ChannelUID channelUID = new ChannelUID(groupUID, id);\n+                Channel channel = ChannelBuilder.create(channelUID, \"Number\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "086a20070bdf370b51d38471f065dda2cb862ded"}, "originalPosition": 414}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczOTYxMjEwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/PointOutOfBoundsException.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QxODo1NDo0NFrOGjY3pg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QxODo1NDo0NFrOGjY3pg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc2MDgwNg==", "bodyText": "You can omit the call to super() here since it is already implied.", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r439760806", "createdAt": "2020-06-13T18:54:44Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/PointOutOfBoundsException.java", "diffHunk": "@@ -0,0 +1,29 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.smhi.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+@NonNullByDefault\n+public class PointOutOfBoundsException extends Exception {\n+\n+    private static final long serialVersionUID = 546566512L;\n+\n+    public PointOutOfBoundsException() {\n+        super();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "44a1568fbd70b4fdf0dd0febfc9fd34e070ce3d6"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczOTYxMzcyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QxODo1NzoyNFrOGjY4bQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QxODo1NzoyNFrOGjY4bQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc2MTAwNQ==", "bodyText": "This should never be null now so it should be ok to remove the @NonNullByDefault({}) unless you had another reason to keep it.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private @NonNullByDefault({}) SmhiConfiguration config = new SmhiConfiguration();\n          \n          \n            \n                private SmhiConfiguration config = new SmhiConfiguration();", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r439761005", "createdAt": "2020-06-13T18:57:24Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiHandler.java", "diffHunk": "@@ -0,0 +1,458 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smhi.internal;\n+\n+import static org.openhab.binding.smhi.internal.SmhiBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.MetricPrefix;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.*;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerCallback;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SmhiHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmhiHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SmhiHandler.class);\n+\n+    private @NonNullByDefault({}) SmhiConfiguration config = new SmhiConfiguration();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "44a1568fbd70b4fdf0dd0febfc9fd34e070ce3d6"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0MDMzNzg0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.smhi/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNFQxODoxNDo0OVrOGjem-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNFQxODoxNDo0OVrOGjem-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1NDg0MA==", "bodyText": "The new line is on a typical place. Better put the different sentences on their own lines that is easier if the file even has to updated/reviewed later on.", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r439854840", "createdAt": "2020-06-14T18:14:49Z", "author": {"login": "martinvw"}, "path": "bundles/org.openhab.binding.smhi/README.md", "diffHunk": "@@ -0,0 +1,143 @@\n+# Smhi Binding\n+\n+This binding gets hourly and daily forecast from SMHI - the Swedish Meteorological and Hydrological Institute. It can't ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cb7c5c1bac986eaf75640cd37d7b9c9221123e40"}, "originalPosition": 3}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0MDMzODE5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.smhi/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNFQxODoxNToyN1rOGjenIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNFQxODoxNToyN1rOGjenIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1NDg4Mw==", "bodyText": "Please always put an empty line in front of titles (a single)", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r439854883", "createdAt": "2020-06-14T18:15:27Z", "author": {"login": "martinvw"}, "path": "bundles/org.openhab.binding.smhi/README.md", "diffHunk": "@@ -0,0 +1,143 @@\n+# Smhi Binding\n+\n+This binding gets hourly and daily forecast from SMHI - the Swedish Meteorological and Hydrological Institute. It can't \n+get forecasts for other countries than Sweden.\n+## Supported Things", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cb7c5c1bac986eaf75640cd37d7b9c9221123e40"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0MDMzOTE1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/Parser.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNFQxODoxNzoxNFrOGjennQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNFQxODoxNzoxNFrOGjennQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1NTAwNQ==", "bodyText": "I would always prefer longer more descriptive names, what is a parObj", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r439855005", "createdAt": "2020-06-14T18:17:14Z", "author": {"login": "martinvw"}, "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/Parser.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.smhi.internal;\n+\n+import java.math.BigDecimal;\n+import java.time.ZonedDateTime;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.StreamSupport;\n+\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * Class with static methods for parsing json strings returned from Smhi\n+ *\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+@NonNullByDefault\n+public class Parser {\n+\n+    private static JsonParser parser = new JsonParser();\n+\n+    /**\n+     * Parse a json string received from Smhi containing forecasts.\n+     *\n+     * @param json A json string\n+     * @return A {@link TimeSeries} object\n+     */\n+    public static TimeSeries parseTimeSeries(String json) {\n+        ZonedDateTime referenceTime;\n+        JsonObject object = parser.parse(json).getAsJsonObject();\n+\n+        referenceTime = parseApprovedTime(json);\n+        JsonArray timeSeries = object.get(\"timeSeries\").getAsJsonArray();\n+\n+        List<Forecast> forecasts = StreamSupport.stream(timeSeries.spliterator(), false)\n+                        .map(element -> parseForecast(element.getAsJsonObject()))\n+                        .sorted(Comparator.naturalOrder())\n+                        .collect(Collectors.toList());\n+\n+        return new TimeSeries(referenceTime, forecasts);\n+    }\n+\n+    /**\n+     * Parse a json string containing the approved time and reference time of the latest forecast\n+     *\n+     * @param json A json string\n+     * @return {@link ZonedDateTime} of the reference time\n+     */\n+    public static ZonedDateTime parseApprovedTime(String json) {\n+        JsonObject timeObj = parser.parse(json).getAsJsonObject();\n+\n+        return ZonedDateTime.parse(timeObj.get(\"referenceTime\").getAsString());\n+    }\n+\n+    /**\n+     * Parse a single forecast, i.e. a forecast for a specific time.\n+     *\n+     * @param object\n+     * @return\n+     */\n+    private static Forecast parseForecast(JsonObject object) {\n+        ZonedDateTime validTime = ZonedDateTime.parse(object.get(\"validTime\").getAsString());\n+        Map<String, @Nullable BigDecimal> parameters = new HashMap<>();\n+\n+        JsonArray par = object.get(\"parameters\").getAsJsonArray();\n+\n+        par.forEach(element -> {\n+            JsonObject parObj = element.getAsJsonObject();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cb7c5c1bac986eaf75640cd37d7b9c9221123e40"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0MDMzOTczOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/PointOutOfBoundsException.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNFQxODoxODoyMFrOGjen7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNFQxODoxODoyMFrOGjen7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1NTA4NA==", "bodyText": "This constructor would still be there if you remove this code, the same result less code.", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r439855084", "createdAt": "2020-06-14T18:18:20Z", "author": {"login": "martinvw"}, "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/PointOutOfBoundsException.java", "diffHunk": "@@ -0,0 +1,28 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.smhi.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+@NonNullByDefault\n+public class PointOutOfBoundsException extends Exception {\n+\n+    private static final long serialVersionUID = 546566512L;\n+\n+    public PointOutOfBoundsException() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cb7c5c1bac986eaf75640cd37d7b9c9221123e40"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0MDMzOTkzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiBindingConstants.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNFQxODoxODo1M1rOGjeoBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNFQxODoxODo1M1rOGjeoBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1NTExMA==", "bodyText": "It seems that the base url could include /api/category/pmp3g/version/2/", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r439855110", "createdAt": "2020-06-14T18:18:53Z", "author": {"login": "martinvw"}, "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiBindingConstants.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smhi.internal;\n+\n+import java.math.BigDecimal;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+\n+/**\n+ * The {@link SmhiBindingConstants} class defines common constants, which are\n+ * used across the whole binding.\n+ *\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmhiBindingConstants {\n+\n+    public static final String BINDING_ID = \"smhi\";\n+\n+    // List of all Thing Type UIDs\n+    public static final ThingTypeUID THING_TYPE_FORECAST = new ThingTypeUID(BINDING_ID, \"forecast\");\n+\n+    // Smhi's ids for parameters, also used as channel ids\n+    public static final String PRESSURE = \"msl\";\n+    public static final String TEMPERATURE = \"t\";\n+    public static final String VISIBILITY = \"vis\";\n+    public static final String WIND_DIRECTION = \"wd\";\n+    public static final String WIND_SPEED = \"ws\";\n+    public static final String RELATIVE_HUMIDITY = \"r\";\n+    public static final String THUNDER_PROBABILITY = \"tstm\";\n+    public static final String TOTAL_CLOUD_COVER = \"tcc_mean\";\n+    public static final String LOW_CLOUD_COVER = \"lcc_mean\";\n+    public static final String MEDIUM_CLOUD_COVER = \"mcc_mean\";\n+    public static final String HIGH_CLOUD_COVER = \"hcc_mean\";\n+    public static final String GUST = \"gust\";\n+    public static final String PRECIPITATION_MIN = \"pmin\";\n+    public static final String PRECIPITATION_MAX = \"pmax\";\n+    public static final String PRECIPITATION_MEAN = \"pmean\";\n+    public static final String PRECIPITATION_MEDIAN = \"pmedian\";\n+    public static final String PERCENT_FROZEN = \"spp\";\n+    public static final String PRECIPITATION_CATEGORY = \"pcat\";\n+    public static final String WEATHER_SYMBOL = \"wsymb2\";\n+\n+    public static final List<String> CHANNEL_IDS = Collections\n+            .unmodifiableList(Stream\n+                    .of(PRESSURE, TEMPERATURE, VISIBILITY, WIND_DIRECTION, WIND_SPEED, RELATIVE_HUMIDITY,\n+                            THUNDER_PROBABILITY, TOTAL_CLOUD_COVER, LOW_CLOUD_COVER, MEDIUM_CLOUD_COVER,\n+                            HIGH_CLOUD_COVER, GUST, PRECIPITATION_MIN, PRECIPITATION_MAX, PRECIPITATION_MEAN,\n+                            PRECIPITATION_MEDIAN, PERCENT_FROZEN, PRECIPITATION_CATEGORY, WEATHER_SYMBOL)\n+                    .collect(Collectors.toList()));\n+\n+    public static final String BASE_URL = \"https://opendata-download-metfcst.smhi.se\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cb7c5c1bac986eaf75640cd37d7b9c9221123e40"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0MDM0MTg2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiHandler.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNFQxODoyMToyMlrOGjeo-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQxMjo1NTozOFrOGkZ8bQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1NTM1Mw==", "bodyText": "This warning sounds very familiar does the framework issue the same warning?", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r439855353", "createdAt": "2020-06-14T18:21:22Z", "author": {"login": "martinvw"}, "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiHandler.java", "diffHunk": "@@ -0,0 +1,485 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smhi.internal;\n+\n+import static org.openhab.binding.smhi.internal.SmhiBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.MetricPrefix;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelGroupUID;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerCallback;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SmhiHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmhiHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SmhiHandler.class);\n+\n+    private SmhiConfiguration config = new SmhiConfiguration();\n+\n+    private final HttpClient httpClient;\n+    private @Nullable SmhiConnector connection;\n+    private ZonedDateTime currentHour;\n+    private ZonedDateTime currentDay;\n+    private @Nullable TimeSeries cachedTimeSeries;\n+    private boolean hasLatestForecast = false;\n+    private @Nullable Future<?> forecastUpdater;\n+    private @Nullable Future<?> instantUpdate;\n+\n+    public SmhiHandler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.currentHour = calculateCurrentHour();\n+        this.currentDay = calculateCurrentDay();\n+    }\n+\n+    /**\n+     * Handles commands sent to channels. Since all values are read-only, only REFRESH commands are allowed.\n+     * Sending REFRESH to any item updates all items, since all values are returned in the response from Smhi.\n+     * Therefore there's a wait of 5 seconds before the values are fetched, in which time all other commands are\n+     * blocked, to prevent spamming Smhi's API.\n+     *\n+     * @param channelUID\n+     * @param command\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateNow();\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(SmhiConfiguration.class);\n+\n+        connection = new SmhiConnector(httpClient);\n+\n+        // Check which channel groups are selected in the config.\n+        List<Channel> channels = new ArrayList<>();\n+        channels.addAll(createChannels());\n+        updateThing(editThing().withChannels(channels).build());\n+\n+        startPolling();\n+        updateNow();\n+    }\n+\n+    /**\n+     * Start polling for updated weather forecast.\n+     */\n+    private synchronized void startPolling() {\n+        logger.debug(\"Start polling\");\n+        forecastUpdater = scheduler.scheduleWithFixedDelay(this::waitForForecast, 1, 1, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Cancels all jobs.\n+     */\n+    private synchronized void cancelPolling() {\n+        logger.debug(\"Cancelling polling\");\n+        Future<?> localRef = forecastUpdater;\n+        if (localRef != null) {\n+            localRef.cancel(false);\n+        }\n+        localRef = instantUpdate;\n+        if (localRef != null) {\n+            localRef.cancel(false);\n+        }\n+    }\n+\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        if (!isModifyingCurrentConfig(configurationParameters)) {\n+            return;\n+        }\n+\n+        validateConfigurationParameters(configurationParameters);\n+\n+        Configuration configuration = editConfiguration();\n+        for (Map.Entry<String, Object> configurationParameter : configurationParameters.entrySet()) {\n+            configuration.put(configurationParameter.getKey(), configurationParameter.getValue());\n+        }\n+\n+        if (isInitialized()) {\n+            updateConfiguration(configuration);\n+            config = configuration.as(SmhiConfiguration.class);\n+            updateThing(editThing().withChannels(createChannels()).build());\n+            if (!isPollingStarted()) {\n+                startPolling();\n+            }\n+            updateNow();\n+        } else {\n+            // persist new configuration and notify Thing Manager\n+            updateConfiguration(configuration);\n+            ThingHandlerCallback callback = getCallback();\n+            if (callback != null) {\n+                callback.configurationUpdated(this.getThing());\n+            } else {\n+                logger.warn(\"Handler {} tried updating its configuration although the handler was already disposed.\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cb7c5c1bac986eaf75640cd37d7b9c9221123e40"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg2MDUxOQ==", "bodyText": "The code in the method is in part copied from BaseThingHandler, I wanted most of the same functionality but skip the dispose()/initialize() part and handle that differently. Is there a better way to achieve this?", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r439860519", "createdAt": "2020-06-14T19:31:07Z", "author": {"login": "pacive"}, "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiHandler.java", "diffHunk": "@@ -0,0 +1,485 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smhi.internal;\n+\n+import static org.openhab.binding.smhi.internal.SmhiBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.MetricPrefix;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelGroupUID;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerCallback;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SmhiHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmhiHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SmhiHandler.class);\n+\n+    private SmhiConfiguration config = new SmhiConfiguration();\n+\n+    private final HttpClient httpClient;\n+    private @Nullable SmhiConnector connection;\n+    private ZonedDateTime currentHour;\n+    private ZonedDateTime currentDay;\n+    private @Nullable TimeSeries cachedTimeSeries;\n+    private boolean hasLatestForecast = false;\n+    private @Nullable Future<?> forecastUpdater;\n+    private @Nullable Future<?> instantUpdate;\n+\n+    public SmhiHandler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.currentHour = calculateCurrentHour();\n+        this.currentDay = calculateCurrentDay();\n+    }\n+\n+    /**\n+     * Handles commands sent to channels. Since all values are read-only, only REFRESH commands are allowed.\n+     * Sending REFRESH to any item updates all items, since all values are returned in the response from Smhi.\n+     * Therefore there's a wait of 5 seconds before the values are fetched, in which time all other commands are\n+     * blocked, to prevent spamming Smhi's API.\n+     *\n+     * @param channelUID\n+     * @param command\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateNow();\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(SmhiConfiguration.class);\n+\n+        connection = new SmhiConnector(httpClient);\n+\n+        // Check which channel groups are selected in the config.\n+        List<Channel> channels = new ArrayList<>();\n+        channels.addAll(createChannels());\n+        updateThing(editThing().withChannels(channels).build());\n+\n+        startPolling();\n+        updateNow();\n+    }\n+\n+    /**\n+     * Start polling for updated weather forecast.\n+     */\n+    private synchronized void startPolling() {\n+        logger.debug(\"Start polling\");\n+        forecastUpdater = scheduler.scheduleWithFixedDelay(this::waitForForecast, 1, 1, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Cancels all jobs.\n+     */\n+    private synchronized void cancelPolling() {\n+        logger.debug(\"Cancelling polling\");\n+        Future<?> localRef = forecastUpdater;\n+        if (localRef != null) {\n+            localRef.cancel(false);\n+        }\n+        localRef = instantUpdate;\n+        if (localRef != null) {\n+            localRef.cancel(false);\n+        }\n+    }\n+\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        if (!isModifyingCurrentConfig(configurationParameters)) {\n+            return;\n+        }\n+\n+        validateConfigurationParameters(configurationParameters);\n+\n+        Configuration configuration = editConfiguration();\n+        for (Map.Entry<String, Object> configurationParameter : configurationParameters.entrySet()) {\n+            configuration.put(configurationParameter.getKey(), configurationParameter.getValue());\n+        }\n+\n+        if (isInitialized()) {\n+            updateConfiguration(configuration);\n+            config = configuration.as(SmhiConfiguration.class);\n+            updateThing(editThing().withChannels(createChannels()).build());\n+            if (!isPollingStarted()) {\n+                startPolling();\n+            }\n+            updateNow();\n+        } else {\n+            // persist new configuration and notify Thing Manager\n+            updateConfiguration(configuration);\n+            ThingHandlerCallback callback = getCallback();\n+            if (callback != null) {\n+                callback.configurationUpdated(this.getThing());\n+            } else {\n+                logger.warn(\"Handler {} tried updating its configuration although the handler was already disposed.\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1NTM1Mw=="}, "originalCommit": {"oid": "cb7c5c1bac986eaf75640cd37d7b9c9221123e40"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDc0Njg1NA==", "bodyText": "Why do you need to override the method it seems that you still perform most of the re-initialization anyway?", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r440746854", "createdAt": "2020-06-16T10:24:29Z", "author": {"login": "martinvw"}, "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiHandler.java", "diffHunk": "@@ -0,0 +1,485 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smhi.internal;\n+\n+import static org.openhab.binding.smhi.internal.SmhiBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.MetricPrefix;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelGroupUID;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerCallback;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SmhiHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmhiHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SmhiHandler.class);\n+\n+    private SmhiConfiguration config = new SmhiConfiguration();\n+\n+    private final HttpClient httpClient;\n+    private @Nullable SmhiConnector connection;\n+    private ZonedDateTime currentHour;\n+    private ZonedDateTime currentDay;\n+    private @Nullable TimeSeries cachedTimeSeries;\n+    private boolean hasLatestForecast = false;\n+    private @Nullable Future<?> forecastUpdater;\n+    private @Nullable Future<?> instantUpdate;\n+\n+    public SmhiHandler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.currentHour = calculateCurrentHour();\n+        this.currentDay = calculateCurrentDay();\n+    }\n+\n+    /**\n+     * Handles commands sent to channels. Since all values are read-only, only REFRESH commands are allowed.\n+     * Sending REFRESH to any item updates all items, since all values are returned in the response from Smhi.\n+     * Therefore there's a wait of 5 seconds before the values are fetched, in which time all other commands are\n+     * blocked, to prevent spamming Smhi's API.\n+     *\n+     * @param channelUID\n+     * @param command\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateNow();\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(SmhiConfiguration.class);\n+\n+        connection = new SmhiConnector(httpClient);\n+\n+        // Check which channel groups are selected in the config.\n+        List<Channel> channels = new ArrayList<>();\n+        channels.addAll(createChannels());\n+        updateThing(editThing().withChannels(channels).build());\n+\n+        startPolling();\n+        updateNow();\n+    }\n+\n+    /**\n+     * Start polling for updated weather forecast.\n+     */\n+    private synchronized void startPolling() {\n+        logger.debug(\"Start polling\");\n+        forecastUpdater = scheduler.scheduleWithFixedDelay(this::waitForForecast, 1, 1, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Cancels all jobs.\n+     */\n+    private synchronized void cancelPolling() {\n+        logger.debug(\"Cancelling polling\");\n+        Future<?> localRef = forecastUpdater;\n+        if (localRef != null) {\n+            localRef.cancel(false);\n+        }\n+        localRef = instantUpdate;\n+        if (localRef != null) {\n+            localRef.cancel(false);\n+        }\n+    }\n+\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        if (!isModifyingCurrentConfig(configurationParameters)) {\n+            return;\n+        }\n+\n+        validateConfigurationParameters(configurationParameters);\n+\n+        Configuration configuration = editConfiguration();\n+        for (Map.Entry<String, Object> configurationParameter : configurationParameters.entrySet()) {\n+            configuration.put(configurationParameter.getKey(), configurationParameter.getValue());\n+        }\n+\n+        if (isInitialized()) {\n+            updateConfiguration(configuration);\n+            config = configuration.as(SmhiConfiguration.class);\n+            updateThing(editThing().withChannels(createChannels()).build());\n+            if (!isPollingStarted()) {\n+                startPolling();\n+            }\n+            updateNow();\n+        } else {\n+            // persist new configuration and notify Thing Manager\n+            updateConfiguration(configuration);\n+            ThingHandlerCallback callback = getCallback();\n+            if (callback != null) {\n+                callback.configurationUpdated(this.getThing());\n+            } else {\n+                logger.warn(\"Handler {} tried updating its configuration although the handler was already disposed.\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1NTM1Mw=="}, "originalCommit": {"oid": "cb7c5c1bac986eaf75640cd37d7b9c9221123e40"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDgyNjk4OQ==", "bodyText": "You're right, i'll remove the method and just let it be handled in the default way.", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r440826989", "createdAt": "2020-06-16T12:55:38Z", "author": {"login": "pacive"}, "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiHandler.java", "diffHunk": "@@ -0,0 +1,485 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smhi.internal;\n+\n+import static org.openhab.binding.smhi.internal.SmhiBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.MetricPrefix;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelGroupUID;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerCallback;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SmhiHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmhiHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SmhiHandler.class);\n+\n+    private SmhiConfiguration config = new SmhiConfiguration();\n+\n+    private final HttpClient httpClient;\n+    private @Nullable SmhiConnector connection;\n+    private ZonedDateTime currentHour;\n+    private ZonedDateTime currentDay;\n+    private @Nullable TimeSeries cachedTimeSeries;\n+    private boolean hasLatestForecast = false;\n+    private @Nullable Future<?> forecastUpdater;\n+    private @Nullable Future<?> instantUpdate;\n+\n+    public SmhiHandler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.currentHour = calculateCurrentHour();\n+        this.currentDay = calculateCurrentDay();\n+    }\n+\n+    /**\n+     * Handles commands sent to channels. Since all values are read-only, only REFRESH commands are allowed.\n+     * Sending REFRESH to any item updates all items, since all values are returned in the response from Smhi.\n+     * Therefore there's a wait of 5 seconds before the values are fetched, in which time all other commands are\n+     * blocked, to prevent spamming Smhi's API.\n+     *\n+     * @param channelUID\n+     * @param command\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateNow();\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(SmhiConfiguration.class);\n+\n+        connection = new SmhiConnector(httpClient);\n+\n+        // Check which channel groups are selected in the config.\n+        List<Channel> channels = new ArrayList<>();\n+        channels.addAll(createChannels());\n+        updateThing(editThing().withChannels(channels).build());\n+\n+        startPolling();\n+        updateNow();\n+    }\n+\n+    /**\n+     * Start polling for updated weather forecast.\n+     */\n+    private synchronized void startPolling() {\n+        logger.debug(\"Start polling\");\n+        forecastUpdater = scheduler.scheduleWithFixedDelay(this::waitForForecast, 1, 1, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Cancels all jobs.\n+     */\n+    private synchronized void cancelPolling() {\n+        logger.debug(\"Cancelling polling\");\n+        Future<?> localRef = forecastUpdater;\n+        if (localRef != null) {\n+            localRef.cancel(false);\n+        }\n+        localRef = instantUpdate;\n+        if (localRef != null) {\n+            localRef.cancel(false);\n+        }\n+    }\n+\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        if (!isModifyingCurrentConfig(configurationParameters)) {\n+            return;\n+        }\n+\n+        validateConfigurationParameters(configurationParameters);\n+\n+        Configuration configuration = editConfiguration();\n+        for (Map.Entry<String, Object> configurationParameter : configurationParameters.entrySet()) {\n+            configuration.put(configurationParameter.getKey(), configurationParameter.getValue());\n+        }\n+\n+        if (isInitialized()) {\n+            updateConfiguration(configuration);\n+            config = configuration.as(SmhiConfiguration.class);\n+            updateThing(editThing().withChannels(createChannels()).build());\n+            if (!isPollingStarted()) {\n+                startPolling();\n+            }\n+            updateNow();\n+        } else {\n+            // persist new configuration and notify Thing Manager\n+            updateConfiguration(configuration);\n+            ThingHandlerCallback callback = getCallback();\n+            if (callback != null) {\n+                callback.configurationUpdated(this.getThing());\n+            } else {\n+                logger.warn(\"Handler {} tried updating its configuration although the handler was already disposed.\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1NTM1Mw=="}, "originalCommit": {"oid": "cb7c5c1bac986eaf75640cd37d7b9c9221123e40"}, "originalPosition": 165}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0MDM0MjQyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNFQxODoyMjoyNFrOGjepQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNFQxOTozNTo1NVrOGje-zA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1NTQyNg==", "bodyText": "How many hours are in a day, does it really include hour 0 and 24? That is 25 data points, just checking :-)", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r439855426", "createdAt": "2020-06-14T18:22:24Z", "author": {"login": "martinvw"}, "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiHandler.java", "diffHunk": "@@ -0,0 +1,485 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smhi.internal;\n+\n+import static org.openhab.binding.smhi.internal.SmhiBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.MetricPrefix;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelGroupUID;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerCallback;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SmhiHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmhiHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SmhiHandler.class);\n+\n+    private SmhiConfiguration config = new SmhiConfiguration();\n+\n+    private final HttpClient httpClient;\n+    private @Nullable SmhiConnector connection;\n+    private ZonedDateTime currentHour;\n+    private ZonedDateTime currentDay;\n+    private @Nullable TimeSeries cachedTimeSeries;\n+    private boolean hasLatestForecast = false;\n+    private @Nullable Future<?> forecastUpdater;\n+    private @Nullable Future<?> instantUpdate;\n+\n+    public SmhiHandler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.currentHour = calculateCurrentHour();\n+        this.currentDay = calculateCurrentDay();\n+    }\n+\n+    /**\n+     * Handles commands sent to channels. Since all values are read-only, only REFRESH commands are allowed.\n+     * Sending REFRESH to any item updates all items, since all values are returned in the response from Smhi.\n+     * Therefore there's a wait of 5 seconds before the values are fetched, in which time all other commands are\n+     * blocked, to prevent spamming Smhi's API.\n+     *\n+     * @param channelUID\n+     * @param command\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateNow();\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(SmhiConfiguration.class);\n+\n+        connection = new SmhiConnector(httpClient);\n+\n+        // Check which channel groups are selected in the config.\n+        List<Channel> channels = new ArrayList<>();\n+        channels.addAll(createChannels());\n+        updateThing(editThing().withChannels(channels).build());\n+\n+        startPolling();\n+        updateNow();\n+    }\n+\n+    /**\n+     * Start polling for updated weather forecast.\n+     */\n+    private synchronized void startPolling() {\n+        logger.debug(\"Start polling\");\n+        forecastUpdater = scheduler.scheduleWithFixedDelay(this::waitForForecast, 1, 1, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Cancels all jobs.\n+     */\n+    private synchronized void cancelPolling() {\n+        logger.debug(\"Cancelling polling\");\n+        Future<?> localRef = forecastUpdater;\n+        if (localRef != null) {\n+            localRef.cancel(false);\n+        }\n+        localRef = instantUpdate;\n+        if (localRef != null) {\n+            localRef.cancel(false);\n+        }\n+    }\n+\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        if (!isModifyingCurrentConfig(configurationParameters)) {\n+            return;\n+        }\n+\n+        validateConfigurationParameters(configurationParameters);\n+\n+        Configuration configuration = editConfiguration();\n+        for (Map.Entry<String, Object> configurationParameter : configurationParameters.entrySet()) {\n+            configuration.put(configurationParameter.getKey(), configurationParameter.getValue());\n+        }\n+\n+        if (isInitialized()) {\n+            updateConfiguration(configuration);\n+            config = configuration.as(SmhiConfiguration.class);\n+            updateThing(editThing().withChannels(createChannels()).build());\n+            if (!isPollingStarted()) {\n+                startPolling();\n+            }\n+            updateNow();\n+        } else {\n+            // persist new configuration and notify Thing Manager\n+            updateConfiguration(configuration);\n+            ThingHandlerCallback callback = getCallback();\n+            if (callback != null) {\n+                callback.configurationUpdated(this.getThing());\n+            } else {\n+                logger.warn(\"Handler {} tried updating its configuration although the handler was already disposed.\",\n+                        this.getClass().getSimpleName());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update channels with new forecast data.\n+     * \n+     * @param timeSeries A {@link TimeSeries} object containing forecasts.\n+     */\n+    private void updateChannels(TimeSeries timeSeries) {\n+        // Loop through hourly forecasts and update those available\n+        for (int i = 0; i < 25; i++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cb7c5c1bac986eaf75640cd37d7b9c9221123e40"}, "originalPosition": 178}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg2MDk0MA==", "bodyText": "Hour 0 is the current hour, and then you can add channels for the next hour (1) up to 24 hours from now :)", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r439860940", "createdAt": "2020-06-14T19:35:55Z", "author": {"login": "pacive"}, "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiHandler.java", "diffHunk": "@@ -0,0 +1,485 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smhi.internal;\n+\n+import static org.openhab.binding.smhi.internal.SmhiBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.MetricPrefix;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelGroupUID;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerCallback;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SmhiHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmhiHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SmhiHandler.class);\n+\n+    private SmhiConfiguration config = new SmhiConfiguration();\n+\n+    private final HttpClient httpClient;\n+    private @Nullable SmhiConnector connection;\n+    private ZonedDateTime currentHour;\n+    private ZonedDateTime currentDay;\n+    private @Nullable TimeSeries cachedTimeSeries;\n+    private boolean hasLatestForecast = false;\n+    private @Nullable Future<?> forecastUpdater;\n+    private @Nullable Future<?> instantUpdate;\n+\n+    public SmhiHandler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.currentHour = calculateCurrentHour();\n+        this.currentDay = calculateCurrentDay();\n+    }\n+\n+    /**\n+     * Handles commands sent to channels. Since all values are read-only, only REFRESH commands are allowed.\n+     * Sending REFRESH to any item updates all items, since all values are returned in the response from Smhi.\n+     * Therefore there's a wait of 5 seconds before the values are fetched, in which time all other commands are\n+     * blocked, to prevent spamming Smhi's API.\n+     *\n+     * @param channelUID\n+     * @param command\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateNow();\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(SmhiConfiguration.class);\n+\n+        connection = new SmhiConnector(httpClient);\n+\n+        // Check which channel groups are selected in the config.\n+        List<Channel> channels = new ArrayList<>();\n+        channels.addAll(createChannels());\n+        updateThing(editThing().withChannels(channels).build());\n+\n+        startPolling();\n+        updateNow();\n+    }\n+\n+    /**\n+     * Start polling for updated weather forecast.\n+     */\n+    private synchronized void startPolling() {\n+        logger.debug(\"Start polling\");\n+        forecastUpdater = scheduler.scheduleWithFixedDelay(this::waitForForecast, 1, 1, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Cancels all jobs.\n+     */\n+    private synchronized void cancelPolling() {\n+        logger.debug(\"Cancelling polling\");\n+        Future<?> localRef = forecastUpdater;\n+        if (localRef != null) {\n+            localRef.cancel(false);\n+        }\n+        localRef = instantUpdate;\n+        if (localRef != null) {\n+            localRef.cancel(false);\n+        }\n+    }\n+\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        if (!isModifyingCurrentConfig(configurationParameters)) {\n+            return;\n+        }\n+\n+        validateConfigurationParameters(configurationParameters);\n+\n+        Configuration configuration = editConfiguration();\n+        for (Map.Entry<String, Object> configurationParameter : configurationParameters.entrySet()) {\n+            configuration.put(configurationParameter.getKey(), configurationParameter.getValue());\n+        }\n+\n+        if (isInitialized()) {\n+            updateConfiguration(configuration);\n+            config = configuration.as(SmhiConfiguration.class);\n+            updateThing(editThing().withChannels(createChannels()).build());\n+            if (!isPollingStarted()) {\n+                startPolling();\n+            }\n+            updateNow();\n+        } else {\n+            // persist new configuration and notify Thing Manager\n+            updateConfiguration(configuration);\n+            ThingHandlerCallback callback = getCallback();\n+            if (callback != null) {\n+                callback.configurationUpdated(this.getThing());\n+            } else {\n+                logger.warn(\"Handler {} tried updating its configuration although the handler was already disposed.\",\n+                        this.getClass().getSimpleName());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update channels with new forecast data.\n+     * \n+     * @param timeSeries A {@link TimeSeries} object containing forecasts.\n+     */\n+    private void updateChannels(TimeSeries timeSeries) {\n+        // Loop through hourly forecasts and update those available\n+        for (int i = 0; i < 25; i++) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1NTQyNg=="}, "originalCommit": {"oid": "cb7c5c1bac986eaf75640cd37d7b9c9221123e40"}, "originalPosition": 178}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0MDM0MzI3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiHandler.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNFQxODoyNDowM1rOGjepug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxODoxMjoxOFrOGj9QxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1NTU0Ng==", "bodyText": "You are doing a small calculation in you debug statement, I don't know how often this path is executed, but people without debug logging still do the calculation each time. You could guard it with logger.isDebugEnabled()", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r439855546", "createdAt": "2020-06-14T18:24:03Z", "author": {"login": "martinvw"}, "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiHandler.java", "diffHunk": "@@ -0,0 +1,485 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smhi.internal;\n+\n+import static org.openhab.binding.smhi.internal.SmhiBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.MetricPrefix;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelGroupUID;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerCallback;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SmhiHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmhiHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SmhiHandler.class);\n+\n+    private SmhiConfiguration config = new SmhiConfiguration();\n+\n+    private final HttpClient httpClient;\n+    private @Nullable SmhiConnector connection;\n+    private ZonedDateTime currentHour;\n+    private ZonedDateTime currentDay;\n+    private @Nullable TimeSeries cachedTimeSeries;\n+    private boolean hasLatestForecast = false;\n+    private @Nullable Future<?> forecastUpdater;\n+    private @Nullable Future<?> instantUpdate;\n+\n+    public SmhiHandler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.currentHour = calculateCurrentHour();\n+        this.currentDay = calculateCurrentDay();\n+    }\n+\n+    /**\n+     * Handles commands sent to channels. Since all values are read-only, only REFRESH commands are allowed.\n+     * Sending REFRESH to any item updates all items, since all values are returned in the response from Smhi.\n+     * Therefore there's a wait of 5 seconds before the values are fetched, in which time all other commands are\n+     * blocked, to prevent spamming Smhi's API.\n+     *\n+     * @param channelUID\n+     * @param command\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateNow();\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(SmhiConfiguration.class);\n+\n+        connection = new SmhiConnector(httpClient);\n+\n+        // Check which channel groups are selected in the config.\n+        List<Channel> channels = new ArrayList<>();\n+        channels.addAll(createChannels());\n+        updateThing(editThing().withChannels(channels).build());\n+\n+        startPolling();\n+        updateNow();\n+    }\n+\n+    /**\n+     * Start polling for updated weather forecast.\n+     */\n+    private synchronized void startPolling() {\n+        logger.debug(\"Start polling\");\n+        forecastUpdater = scheduler.scheduleWithFixedDelay(this::waitForForecast, 1, 1, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Cancels all jobs.\n+     */\n+    private synchronized void cancelPolling() {\n+        logger.debug(\"Cancelling polling\");\n+        Future<?> localRef = forecastUpdater;\n+        if (localRef != null) {\n+            localRef.cancel(false);\n+        }\n+        localRef = instantUpdate;\n+        if (localRef != null) {\n+            localRef.cancel(false);\n+        }\n+    }\n+\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        if (!isModifyingCurrentConfig(configurationParameters)) {\n+            return;\n+        }\n+\n+        validateConfigurationParameters(configurationParameters);\n+\n+        Configuration configuration = editConfiguration();\n+        for (Map.Entry<String, Object> configurationParameter : configurationParameters.entrySet()) {\n+            configuration.put(configurationParameter.getKey(), configurationParameter.getValue());\n+        }\n+\n+        if (isInitialized()) {\n+            updateConfiguration(configuration);\n+            config = configuration.as(SmhiConfiguration.class);\n+            updateThing(editThing().withChannels(createChannels()).build());\n+            if (!isPollingStarted()) {\n+                startPolling();\n+            }\n+            updateNow();\n+        } else {\n+            // persist new configuration and notify Thing Manager\n+            updateConfiguration(configuration);\n+            ThingHandlerCallback callback = getCallback();\n+            if (callback != null) {\n+                callback.configurationUpdated(this.getThing());\n+            } else {\n+                logger.warn(\"Handler {} tried updating its configuration although the handler was already disposed.\",\n+                        this.getClass().getSimpleName());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update channels with new forecast data.\n+     * \n+     * @param timeSeries A {@link TimeSeries} object containing forecasts.\n+     */\n+    private void updateChannels(TimeSeries timeSeries) {\n+        // Loop through hourly forecasts and update those available\n+        for (int i = 0; i < 25; i++) {\n+            List<Channel> channels = thing.getChannelsOfGroup(\"hour_\" + i);\n+            if (channels.isEmpty()) {\n+                continue;\n+            }\n+            Forecast forecast = timeSeries.getForecast(i);\n+            if (forecast != null) {\n+                channels.forEach(c -> {\n+                    String id = c.getUID().getIdWithoutGroup();\n+                    BigDecimal value = forecast.getParameter(id);\n+                    updateChannel(c, value);\n+                });\n+            }\n+        }\n+        // Loop through daily forecasts and updates those available\n+        for (int i = 0; i < 10; i++) {\n+            List<Channel> channels = thing.getChannelsOfGroup(\"day_\" + i);\n+            if (channels.isEmpty()) {\n+                continue;\n+            }\n+            Forecast forecast = timeSeries.getForecast(currentDay, 24 * i + 12);\n+\n+            if (forecast == null) {\n+                logger.debug(\"No forecast yet for {}\", currentDay.plusHours(24 * i + 12));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cb7c5c1bac986eaf75640cd37d7b9c9221123e40"}, "originalPosition": 201}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI5MzU4OQ==", "bodyText": "Is it just the integer calculation you're concerned about or the plusHours() as well? I could do the calculation separately and use it both for timeSeries.getForecast() and the debug statement (would look better DRY-wise). Anyway, this logging statement shouldn't appear more than once an hour at most.", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r440293589", "createdAt": "2020-06-15T16:19:00Z", "author": {"login": "pacive"}, "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiHandler.java", "diffHunk": "@@ -0,0 +1,485 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smhi.internal;\n+\n+import static org.openhab.binding.smhi.internal.SmhiBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.MetricPrefix;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelGroupUID;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerCallback;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SmhiHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmhiHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SmhiHandler.class);\n+\n+    private SmhiConfiguration config = new SmhiConfiguration();\n+\n+    private final HttpClient httpClient;\n+    private @Nullable SmhiConnector connection;\n+    private ZonedDateTime currentHour;\n+    private ZonedDateTime currentDay;\n+    private @Nullable TimeSeries cachedTimeSeries;\n+    private boolean hasLatestForecast = false;\n+    private @Nullable Future<?> forecastUpdater;\n+    private @Nullable Future<?> instantUpdate;\n+\n+    public SmhiHandler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.currentHour = calculateCurrentHour();\n+        this.currentDay = calculateCurrentDay();\n+    }\n+\n+    /**\n+     * Handles commands sent to channels. Since all values are read-only, only REFRESH commands are allowed.\n+     * Sending REFRESH to any item updates all items, since all values are returned in the response from Smhi.\n+     * Therefore there's a wait of 5 seconds before the values are fetched, in which time all other commands are\n+     * blocked, to prevent spamming Smhi's API.\n+     *\n+     * @param channelUID\n+     * @param command\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateNow();\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(SmhiConfiguration.class);\n+\n+        connection = new SmhiConnector(httpClient);\n+\n+        // Check which channel groups are selected in the config.\n+        List<Channel> channels = new ArrayList<>();\n+        channels.addAll(createChannels());\n+        updateThing(editThing().withChannels(channels).build());\n+\n+        startPolling();\n+        updateNow();\n+    }\n+\n+    /**\n+     * Start polling for updated weather forecast.\n+     */\n+    private synchronized void startPolling() {\n+        logger.debug(\"Start polling\");\n+        forecastUpdater = scheduler.scheduleWithFixedDelay(this::waitForForecast, 1, 1, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Cancels all jobs.\n+     */\n+    private synchronized void cancelPolling() {\n+        logger.debug(\"Cancelling polling\");\n+        Future<?> localRef = forecastUpdater;\n+        if (localRef != null) {\n+            localRef.cancel(false);\n+        }\n+        localRef = instantUpdate;\n+        if (localRef != null) {\n+            localRef.cancel(false);\n+        }\n+    }\n+\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        if (!isModifyingCurrentConfig(configurationParameters)) {\n+            return;\n+        }\n+\n+        validateConfigurationParameters(configurationParameters);\n+\n+        Configuration configuration = editConfiguration();\n+        for (Map.Entry<String, Object> configurationParameter : configurationParameters.entrySet()) {\n+            configuration.put(configurationParameter.getKey(), configurationParameter.getValue());\n+        }\n+\n+        if (isInitialized()) {\n+            updateConfiguration(configuration);\n+            config = configuration.as(SmhiConfiguration.class);\n+            updateThing(editThing().withChannels(createChannels()).build());\n+            if (!isPollingStarted()) {\n+                startPolling();\n+            }\n+            updateNow();\n+        } else {\n+            // persist new configuration and notify Thing Manager\n+            updateConfiguration(configuration);\n+            ThingHandlerCallback callback = getCallback();\n+            if (callback != null) {\n+                callback.configurationUpdated(this.getThing());\n+            } else {\n+                logger.warn(\"Handler {} tried updating its configuration although the handler was already disposed.\",\n+                        this.getClass().getSimpleName());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update channels with new forecast data.\n+     * \n+     * @param timeSeries A {@link TimeSeries} object containing forecasts.\n+     */\n+    private void updateChannels(TimeSeries timeSeries) {\n+        // Loop through hourly forecasts and update those available\n+        for (int i = 0; i < 25; i++) {\n+            List<Channel> channels = thing.getChannelsOfGroup(\"hour_\" + i);\n+            if (channels.isEmpty()) {\n+                continue;\n+            }\n+            Forecast forecast = timeSeries.getForecast(i);\n+            if (forecast != null) {\n+                channels.forEach(c -> {\n+                    String id = c.getUID().getIdWithoutGroup();\n+                    BigDecimal value = forecast.getParameter(id);\n+                    updateChannel(c, value);\n+                });\n+            }\n+        }\n+        // Loop through daily forecasts and updates those available\n+        for (int i = 0; i < 10; i++) {\n+            List<Channel> channels = thing.getChannelsOfGroup(\"day_\" + i);\n+            if (channels.isEmpty()) {\n+                continue;\n+            }\n+            Forecast forecast = timeSeries.getForecast(currentDay, 24 * i + 12);\n+\n+            if (forecast == null) {\n+                logger.debug(\"No forecast yet for {}\", currentDay.plusHours(24 * i + 12));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1NTU0Ng=="}, "originalCommit": {"oid": "cb7c5c1bac986eaf75640cd37d7b9c9221123e40"}, "originalPosition": 201}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM1NzA2MQ==", "bodyText": "Especially the plusHours because that is kinda black box, the integer calculation should be done in a single CPU tick :-)\nGiven its frequency it's not problematic", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r440357061", "createdAt": "2020-06-15T18:12:18Z", "author": {"login": "martinvw"}, "path": "bundles/org.openhab.binding.smhi/src/main/java/org/openhab/binding/smhi/internal/SmhiHandler.java", "diffHunk": "@@ -0,0 +1,485 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.smhi.internal;\n+\n+import static org.openhab.binding.smhi.internal.SmhiBindingConstants.*;\n+\n+import java.math.BigDecimal;\n+import java.time.ZoneOffset;\n+import java.time.ZonedDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.smarthome.config.core.Configuration;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.MetricPrefix;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.Channel;\n+import org.eclipse.smarthome.core.thing.ChannelGroupUID;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerCallback;\n+import org.eclipse.smarthome.core.thing.binding.builder.ChannelBuilder;\n+import org.eclipse.smarthome.core.thing.type.ChannelTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link SmhiHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Anders Alfredsson - Initial contribution\n+ */\n+@NonNullByDefault\n+public class SmhiHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(SmhiHandler.class);\n+\n+    private SmhiConfiguration config = new SmhiConfiguration();\n+\n+    private final HttpClient httpClient;\n+    private @Nullable SmhiConnector connection;\n+    private ZonedDateTime currentHour;\n+    private ZonedDateTime currentDay;\n+    private @Nullable TimeSeries cachedTimeSeries;\n+    private boolean hasLatestForecast = false;\n+    private @Nullable Future<?> forecastUpdater;\n+    private @Nullable Future<?> instantUpdate;\n+\n+    public SmhiHandler(Thing thing, HttpClient httpClient) {\n+        super(thing);\n+        this.httpClient = httpClient;\n+        this.currentHour = calculateCurrentHour();\n+        this.currentDay = calculateCurrentDay();\n+    }\n+\n+    /**\n+     * Handles commands sent to channels. Since all values are read-only, only REFRESH commands are allowed.\n+     * Sending REFRESH to any item updates all items, since all values are returned in the response from Smhi.\n+     * Therefore there's a wait of 5 seconds before the values are fetched, in which time all other commands are\n+     * blocked, to prevent spamming Smhi's API.\n+     *\n+     * @param channelUID\n+     * @param command\n+     */\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateNow();\n+        }\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(SmhiConfiguration.class);\n+\n+        connection = new SmhiConnector(httpClient);\n+\n+        // Check which channel groups are selected in the config.\n+        List<Channel> channels = new ArrayList<>();\n+        channels.addAll(createChannels());\n+        updateThing(editThing().withChannels(channels).build());\n+\n+        startPolling();\n+        updateNow();\n+    }\n+\n+    /**\n+     * Start polling for updated weather forecast.\n+     */\n+    private synchronized void startPolling() {\n+        logger.debug(\"Start polling\");\n+        forecastUpdater = scheduler.scheduleWithFixedDelay(this::waitForForecast, 1, 1, TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Cancels all jobs.\n+     */\n+    private synchronized void cancelPolling() {\n+        logger.debug(\"Cancelling polling\");\n+        Future<?> localRef = forecastUpdater;\n+        if (localRef != null) {\n+            localRef.cancel(false);\n+        }\n+        localRef = instantUpdate;\n+        if (localRef != null) {\n+            localRef.cancel(false);\n+        }\n+    }\n+\n+    @Override\n+    public void handleConfigurationUpdate(Map<String, Object> configurationParameters) {\n+        if (!isModifyingCurrentConfig(configurationParameters)) {\n+            return;\n+        }\n+\n+        validateConfigurationParameters(configurationParameters);\n+\n+        Configuration configuration = editConfiguration();\n+        for (Map.Entry<String, Object> configurationParameter : configurationParameters.entrySet()) {\n+            configuration.put(configurationParameter.getKey(), configurationParameter.getValue());\n+        }\n+\n+        if (isInitialized()) {\n+            updateConfiguration(configuration);\n+            config = configuration.as(SmhiConfiguration.class);\n+            updateThing(editThing().withChannels(createChannels()).build());\n+            if (!isPollingStarted()) {\n+                startPolling();\n+            }\n+            updateNow();\n+        } else {\n+            // persist new configuration and notify Thing Manager\n+            updateConfiguration(configuration);\n+            ThingHandlerCallback callback = getCallback();\n+            if (callback != null) {\n+                callback.configurationUpdated(this.getThing());\n+            } else {\n+                logger.warn(\"Handler {} tried updating its configuration although the handler was already disposed.\",\n+                        this.getClass().getSimpleName());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Update channels with new forecast data.\n+     * \n+     * @param timeSeries A {@link TimeSeries} object containing forecasts.\n+     */\n+    private void updateChannels(TimeSeries timeSeries) {\n+        // Loop through hourly forecasts and update those available\n+        for (int i = 0; i < 25; i++) {\n+            List<Channel> channels = thing.getChannelsOfGroup(\"hour_\" + i);\n+            if (channels.isEmpty()) {\n+                continue;\n+            }\n+            Forecast forecast = timeSeries.getForecast(i);\n+            if (forecast != null) {\n+                channels.forEach(c -> {\n+                    String id = c.getUID().getIdWithoutGroup();\n+                    BigDecimal value = forecast.getParameter(id);\n+                    updateChannel(c, value);\n+                });\n+            }\n+        }\n+        // Loop through daily forecasts and updates those available\n+        for (int i = 0; i < 10; i++) {\n+            List<Channel> channels = thing.getChannelsOfGroup(\"day_\" + i);\n+            if (channels.isEmpty()) {\n+                continue;\n+            }\n+            Forecast forecast = timeSeries.getForecast(currentDay, 24 * i + 12);\n+\n+            if (forecast == null) {\n+                logger.debug(\"No forecast yet for {}\", currentDay.plusHours(24 * i + 12));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1NTU0Ng=="}, "originalCommit": {"oid": "cb7c5c1bac986eaf75640cd37d7b9c9221123e40"}, "originalPosition": 201}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0MDM0NDE1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.smhi/src/main/resources/ESH-INF/config/forecast-config.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNFQxODoyNTozMlrOGjeqJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNFQxODoyNTozMlrOGjeqJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1NTY1NQ==", "bodyText": "That explains a lot about my review comment \ud83d\ude09", "url": "https://github.com/openhab/openhab-addons/pull/7321#discussion_r439855655", "createdAt": "2020-06-14T18:25:32Z", "author": {"login": "martinvw"}, "path": "bundles/org.openhab.binding.smhi/src/main/resources/ESH-INF/config/forecast-config.xml", "diffHunk": "@@ -0,0 +1,68 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<config-description:config-descriptions\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:config-description=\"https://openhab.org/schemas/config-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/config-description/v1.0.0\n+\t\thttps://openhab.org/schemas/config-description-1.0.0.xsd\">\n+\n+\t<config-description uri=\"thing-type:smhi:forecast\">\n+\t\t<parameter name=\"latitude\" type=\"decimal\" required=\"true\">\n+\t\t\t<label>Latitude</label>\n+\t\t\t<description>Latitude for the forecast</description>\n+\t\t</parameter>\n+\t\t<parameter name=\"longitude\" type=\"decimal\" required=\"true\">\n+\t\t\t<label>Longitude</label>\n+\t\t\t<description>Longitude for the forecast</description>\n+\t\t</parameter>\n+\t\t<parameter name=\"hourlyForecasts\" type=\"integer\" multiple=\"true\">\n+\t\t\t<label>Hourly Forecasts</label>\n+\t\t\t<description>The hourly forecasts to display</description>\n+\t\t\t<limitToOptions>true</limitToOptions>\n+\t\t\t<options>\n+\t\t\t\t<option value=\"0\">00: Current hour</option>\n+\t\t\t\t<option value=\"1\">01: Next hour</option>\n+\t\t\t\t<option value=\"2\">02: 2 hours from now</option>\n+\t\t\t\t<option value=\"3\">03: 3 hours from now</option>\n+\t\t\t\t<option value=\"4\">04: 4 hours from now</option>\n+\t\t\t\t<option value=\"5\">05: 5 hours from now</option>\n+\t\t\t\t<option value=\"6\">06: 6 hours from now</option>\n+\t\t\t\t<option value=\"7\">07: 7 hours from now</option>\n+\t\t\t\t<option value=\"8\">08: 8 hours from now</option>\n+\t\t\t\t<option value=\"9\">09: 9 hours from now</option>\n+\t\t\t\t<option value=\"10\">10: 10 hours from now</option>\n+\t\t\t\t<option value=\"11\">11: 11 hours from now</option>\n+\t\t\t\t<option value=\"12\">12: 12 hours from now</option>\n+\t\t\t\t<option value=\"13\">13: 13 hours from now</option>\n+\t\t\t\t<option value=\"14\">14: 14 hours from now</option>\n+\t\t\t\t<option value=\"15\">15: 15 hours from now</option>\n+\t\t\t\t<option value=\"16\">16: 16 hours from now</option>\n+\t\t\t\t<option value=\"17\">17: 17 hours from now</option>\n+\t\t\t\t<option value=\"18\">18: 18 hours from now</option>\n+\t\t\t\t<option value=\"19\">19: 19 hours from now</option>\n+\t\t\t\t<option value=\"20\">20: 20 hours from now</option>\n+\t\t\t\t<option value=\"21\">21: 21 hours from now</option>\n+\t\t\t\t<option value=\"22\">22: 22 hours from now</option>\n+\t\t\t\t<option value=\"23\">23: 23 hours from now</option>\n+\t\t\t\t<option value=\"24\">24: 24 hours from now</option>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cb7c5c1bac986eaf75640cd37d7b9c9221123e40"}, "originalPosition": 46}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 572, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}