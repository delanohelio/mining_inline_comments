{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk3MzM0Njgz", "number": 8650, "reviewThreads": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwMDoxNToxMFrOEq9wbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMVQyMzoyNzoyNFrOEsbtKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNDg3NDY5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.lutron/src/main/java/org/openhab/binding/lutron/internal/discovery/LeapDeviceDiscoveryService.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwMDoxNToxMFrOHdeN5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMFQxNjozNzowNFrOHfg-rg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY2NTgyOA==", "bodyText": "I suggest that you change your discovery service into a ThingHandlerService so that you don't have to manage osgi registration of this class. It is a bit verbose to explain how to make the change but I've found another PR that shows exactly the changes that are required: https://github.com/openhab/openhab-addons/pull/6396/files", "url": "https://github.com/openhab/openhab-addons/pull/8650#discussion_r500665828", "createdAt": "2020-10-07T00:15:10Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lutron/src/main/java/org/openhab/binding/lutron/internal/discovery/LeapDeviceDiscoveryService.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.lutron.internal.discovery;\n+\n+import static org.openhab.binding.lutron.internal.LutronBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.lutron.internal.LutronHandlerFactory;\n+import org.openhab.binding.lutron.internal.handler.LeapBridgeHandler;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Area;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Device;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.OccupancyGroup;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link LeapDeviceDiscoveryService} discovers devices paired with Lutron bridges using the LEAP protocol.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LeapDeviceDiscoveryService extends AbstractDiscoveryService {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "deb48c1252ee18917f2f9e19cf0158fedb164659"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDc1NjUwOA==", "bodyText": "Yeah, I vaguely remember this change from last year. I\u2019ll take a look at it.", "url": "https://github.com/openhab/openhab-addons/pull/8650#discussion_r500756508", "createdAt": "2020-10-07T06:02:48Z", "author": {"login": "bobadair"}, "path": "bundles/org.openhab.binding.lutron/src/main/java/org/openhab/binding/lutron/internal/discovery/LeapDeviceDiscoveryService.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.lutron.internal.discovery;\n+\n+import static org.openhab.binding.lutron.internal.LutronBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.lutron.internal.LutronHandlerFactory;\n+import org.openhab.binding.lutron.internal.handler.LeapBridgeHandler;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Area;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Device;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.OccupancyGroup;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link LeapDeviceDiscoveryService} discovers devices paired with Lutron bridges using the LEAP protocol.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LeapDeviceDiscoveryService extends AbstractDiscoveryService {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY2NTgyOA=="}, "originalCommit": {"oid": "deb48c1252ee18917f2f9e19cf0158fedb164659"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjYwMTk0OA==", "bodyText": "I ran in to an interesting issue when I was playing around with this. I changed the definition of LeapDeviceDiscoveryService to the following:\npublic class LeapDeviceDiscoveryService extends AbstractDiscoveryService implements DiscoveryService, ThingHandlerService\n\nBut then I got an error indicating a conflict between AbstractDiscoveryService and the ThingHandlerService interface:\nThe inherited method AbstractDiscoveryService.deactivate() cannot hide the public abstract method in ThingHandlerService\n\nThey do seems to define deactivate() in incompatible ways:\nAbstractDiscoveryService:\n    protected void deactivate() {\n        if (backgroundDiscoveryEnabled) {\n            stopBackgroundDiscovery();\n        }\n    }\n\nThingHandlerService:\n    default void deactivate() {\n    }\n\nAnyway, I'm starting to think that changing this to a ThingHandlerService  may not be worth the effort.", "url": "https://github.com/openhab/openhab-addons/pull/8650#discussion_r502601948", "createdAt": "2020-10-09T18:24:11Z", "author": {"login": "bobadair"}, "path": "bundles/org.openhab.binding.lutron/src/main/java/org/openhab/binding/lutron/internal/discovery/LeapDeviceDiscoveryService.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.lutron.internal.discovery;\n+\n+import static org.openhab.binding.lutron.internal.LutronBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.lutron.internal.LutronHandlerFactory;\n+import org.openhab.binding.lutron.internal.handler.LeapBridgeHandler;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Area;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Device;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.OccupancyGroup;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link LeapDeviceDiscoveryService} discovers devices paired with Lutron bridges using the LEAP protocol.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LeapDeviceDiscoveryService extends AbstractDiscoveryService {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY2NTgyOA=="}, "originalCommit": {"oid": "deb48c1252ee18917f2f9e19cf0158fedb164659"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjgwODIzOA==", "bodyText": "You would need to redeclare deactivate as a public method in your LeapDeviceDiscoveryService. You can just call super.deactivate inside it. The key is to make it a public method so that it satisfies the ThingHandlerService interface method.", "url": "https://github.com/openhab/openhab-addons/pull/8650#discussion_r502808238", "createdAt": "2020-10-10T16:37:04Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lutron/src/main/java/org/openhab/binding/lutron/internal/discovery/LeapDeviceDiscoveryService.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.lutron.internal.discovery;\n+\n+import static org.openhab.binding.lutron.internal.LutronBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.lutron.internal.LutronHandlerFactory;\n+import org.openhab.binding.lutron.internal.handler.LeapBridgeHandler;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Area;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Device;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.OccupancyGroup;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link LeapDeviceDiscoveryService} discovers devices paired with Lutron bridges using the LEAP protocol.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LeapDeviceDiscoveryService extends AbstractDiscoveryService {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY2NTgyOA=="}, "originalCommit": {"oid": "deb48c1252ee18917f2f9e19cf0158fedb164659"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNDg5NDYzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.lutron/src/main/java/org/openhab/binding/lutron/internal/protocol/LIPCommand.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwMDoyNToyMlrOHdeZdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwMDoyNToyMlrOHdeZdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY2ODc5MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        throw (new IllegalArgumentException(\"Invalid command parameter\"));\n          \n          \n            \n                        throw new IllegalArgumentException(\"Invalid command parameter\");", "url": "https://github.com/openhab/openhab-addons/pull/8650#discussion_r500668791", "createdAt": "2020-10-07T00:25:22Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lutron/src/main/java/org/openhab/binding/lutron/internal/protocol/LIPCommand.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lutron.internal.protocol;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.lutron.internal.handler.LeapBridgeHandler;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapCommand;\n+import org.openhab.binding.lutron.internal.protocol.lip.LutronCommandType;\n+import org.openhab.binding.lutron.internal.protocol.lip.LutronOperation;\n+import org.openhab.binding.lutron.internal.protocol.lip.TargetType;\n+\n+/**\n+ * Generic LIP command for use inside bridge handler\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LIPCommand extends LutronCommandNew {\n+    private final Object[] parameters;\n+\n+    public LIPCommand(TargetType targetType, LutronOperation operation, LutronCommandType CommandType,\n+            @Nullable Integer integrationId, Object... parameters) {\n+        super(targetType, operation, CommandType, integrationId);\n+        this.parameters = parameters;\n+    }\n+\n+    @Override\n+    public String lipCommand() {\n+        StringBuilder builder = new StringBuilder().append(operation).append(commandType);\n+        if (integrationId != null) {\n+            builder.append(',').append(integrationId);\n+        }\n+        if (parameters != null) { // This CAN be null\n+            for (Object parameter : parameters) {\n+                builder.append(',').append(parameter);\n+            }\n+        }\n+\n+        return builder.toString();\n+    }\n+\n+    @Override\n+    public @Nullable LeapCommand leapCommand(LeapBridgeHandler bridgeHandler, @Nullable Integer leapZone) {\n+        return null;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return lipCommand();\n+    }\n+\n+    public int getNumberParameter(int position) {\n+        if (parameters.length > position && parameters[position] instanceof Number) {\n+            Number num = (Number) parameters[position];\n+            return num.intValue();\n+        } else {\n+            throw (new IllegalArgumentException(\"Invalid command parameter\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "deb48c1252ee18917f2f9e19cf0158fedb164659"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNDkwNDM5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.lutron/src/main/java/org/openhab/binding/lutron/internal/protocol/leap/LeapMessageParser.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwMDozMDozNlrOHdee_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwNTo1MzoxNFrOHdjjGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY3MDIwNg==", "bodyText": "not parsed?", "url": "https://github.com/openhab/openhab-addons/pull/8650#discussion_r500670206", "createdAt": "2020-10-07T00:30:36Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lutron/src/main/java/org/openhab/binding/lutron/internal/protocol/leap/LeapMessageParser.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lutron.internal.protocol.leap;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Area;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ButtonGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Device;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ExceptionDetail;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Header;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.OccupancyGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.OccupancyGroupStatus;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ZoneStatus;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonParser;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * Class responsible for parsing incoming LEAP messages\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LeapMessageParser {\n+    private final Logger logger = LoggerFactory.getLogger(LeapMessageParser.class);\n+\n+    private final Gson gson;\n+    private final LeapMessageParserCallbacks callback;\n+\n+    /**\n+     * LeapMessageParser Constructor\n+     *\n+     * @param callback Object implementing the LeapMessageParserCallbacks interface\n+     */\n+    public LeapMessageParser(LeapMessageParserCallbacks callback) {\n+        gson = new GsonBuilder().create();\n+        this.callback = callback;\n+    }\n+\n+    /**\n+     * Parse and process a LEAP protocol message\n+     *\n+     * @param msg String containing the LEAP message\n+     */\n+    public void handleMessage(String msg) {\n+        if (msg.trim().equals(\"\")) {\n+            return; // Ignore empty lines\n+        }\n+        logger.trace(\"Received message: {}\", msg);\n+\n+        try {\n+            JsonObject message = (JsonObject) new JsonParser().parse(msg);\n+\n+            if (!message.has(\"CommuniqueType\")) {\n+                logger.debug(\"No CommuniqueType found in message: {}\", msg);\n+                return;\n+            }\n+\n+            String communiqueType = message.get(\"CommuniqueType\").getAsString();\n+            // CommuniqueType type = CommuniqueType.valueOf(communiqueType);\n+            logger.debug(\"Received CommuniqueType: {}\", communiqueType);\n+            callback.validMessageReceived(communiqueType);\n+\n+            switch (communiqueType) {\n+                case \"CreateResponse\":\n+                    return;\n+                case \"ReadResponse\":\n+                    handleReadResponseMessage(message);\n+                    break;\n+                case \"UpdateResponse\":\n+                    break;\n+                case \"SubscribeResponse\":\n+                    // Subscribe responses can contain bodies with data\n+                    handleReadResponseMessage(message);\n+                    return;\n+                case \"UnsubscribeResponse\":\n+                    return;\n+                case \"ExceptionResponse\":\n+                    handleExceptionResponse(message);\n+                    return;\n+                default:\n+                    logger.debug(\"Unknown CommuniqueType received: {}\", communiqueType);\n+                    break;\n+            }\n+        } catch (JsonParseException e) {\n+            logger.debug(\"Error parsing message: {}\", e.getMessage());\n+            return;\n+        }\n+    }\n+\n+    /**\n+     * Method called by handleMessage() to handle all LEAP ExceptionResponse messages.\n+     *\n+     * @param message LEAP message\n+     */\n+    private void handleExceptionResponse(JsonObject message) {\n+        String detailMessage = \"\";\n+\n+        try {\n+            JsonObject header = message.get(\"Header\").getAsJsonObject();\n+            Header headerObj = gson.fromJson(header, Header.class);\n+\n+            if (MessageBodyType.ExceptionDetail.toString().equalsIgnoreCase(headerObj.messageBodyType)\n+                    && message.has(\"Body\")) {\n+                JsonObject body = message.get(\"Body\").getAsJsonObject();\n+                ExceptionDetail exceptionDetail = gson.fromJson(body, ExceptionDetail.class);\n+                if (exceptionDetail != null) {\n+                    detailMessage = exceptionDetail.message;\n+                }\n+            }\n+            logger.debug(\"Exception response received. Status: {} URL: {} Message: {}\", headerObj.statusCode,\n+                    headerObj.url, detailMessage);\n+\n+        } catch (JsonParseException | IllegalStateException e) {\n+            logger.debug(\"Exception response received. Error parsing exception message: {}\", e.getMessage());\n+            return;\n+        }\n+    }\n+\n+    /**\n+     * Method called by handleMessage() to handle all LEAP ReadResponse and SubscribeResponse messages.\n+     *\n+     * @param message LEAP message\n+     */\n+    private void handleReadResponseMessage(JsonObject message) {\n+        try {\n+            JsonObject header = message.get(\"Header\").getAsJsonObject();\n+            Header headerObj = gson.fromJson(header, Header.class);\n+\n+            // if 204/NoContent response received for buttongroup request, create empty button map\n+            if (Request.BUTTON_GROUP_URL.equals(headerObj.url)\n+                    && Header.STATUS_NO_CONTENT.equalsIgnoreCase(headerObj.statusCode)) {\n+                callback.handleEmptyButtonGroupDefinition();\n+                return;\n+            }\n+\n+            if (!header.has(\"MessageBodyType\")) {\n+                logger.trace(\"No MessageBodyType in header\");\n+                return;\n+            }\n+            String messageBodyType = header.get(\"MessageBodyType\").getAsString();\n+            logger.trace(\"MessageBodyType: {}\", messageBodyType);\n+\n+            if (!message.has(\"Body\")) {\n+                logger.debug(\"No Body found in message\");\n+                return;\n+            }\n+            JsonObject body = message.get(\"Body\").getAsJsonObject();\n+\n+            switch (messageBodyType) {\n+                case \"OnePingResponse\":\n+                    parseOnePingResponse(body);\n+                    break;\n+                case \"OneZoneStatus\":\n+                    parseOneZoneStatus(body);\n+                    break;\n+                case \"MultipleAreaDefinition\":\n+                    parseMultipleAreaDefinition(body);\n+                    break;\n+                case \"MultipleButtonGroupDefinition\":\n+                    parseMultipleButtonGroupDefinition(body);\n+                    break;\n+                case \"MultipleDeviceDefinition\":\n+                    parseMultipleDeviceDefinition(body);\n+                    break;\n+                case \"MultipleOccupancyGroupDefinition\":\n+                    parseMultipleOccupancyGroupDefinition(body);\n+                    break;\n+                case \"MultipleOccupancyGroupStatus\":\n+                    parseMultipleOccupancyGroupStatus(body);\n+                    break;\n+                case \"MultipleVirtualButtonDefinition\":\n+                    break;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "deb48c1252ee18917f2f9e19cf0158fedb164659"}, "originalPosition": 195}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDc1MzE3OA==", "bodyText": "No, I haven't added support for that yet.", "url": "https://github.com/openhab/openhab-addons/pull/8650#discussion_r500753178", "createdAt": "2020-10-07T05:53:14Z", "author": {"login": "bobadair"}, "path": "bundles/org.openhab.binding.lutron/src/main/java/org/openhab/binding/lutron/internal/protocol/leap/LeapMessageParser.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lutron.internal.protocol.leap;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Area;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ButtonGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Device;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ExceptionDetail;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Header;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.OccupancyGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.OccupancyGroupStatus;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ZoneStatus;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonParser;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * Class responsible for parsing incoming LEAP messages\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LeapMessageParser {\n+    private final Logger logger = LoggerFactory.getLogger(LeapMessageParser.class);\n+\n+    private final Gson gson;\n+    private final LeapMessageParserCallbacks callback;\n+\n+    /**\n+     * LeapMessageParser Constructor\n+     *\n+     * @param callback Object implementing the LeapMessageParserCallbacks interface\n+     */\n+    public LeapMessageParser(LeapMessageParserCallbacks callback) {\n+        gson = new GsonBuilder().create();\n+        this.callback = callback;\n+    }\n+\n+    /**\n+     * Parse and process a LEAP protocol message\n+     *\n+     * @param msg String containing the LEAP message\n+     */\n+    public void handleMessage(String msg) {\n+        if (msg.trim().equals(\"\")) {\n+            return; // Ignore empty lines\n+        }\n+        logger.trace(\"Received message: {}\", msg);\n+\n+        try {\n+            JsonObject message = (JsonObject) new JsonParser().parse(msg);\n+\n+            if (!message.has(\"CommuniqueType\")) {\n+                logger.debug(\"No CommuniqueType found in message: {}\", msg);\n+                return;\n+            }\n+\n+            String communiqueType = message.get(\"CommuniqueType\").getAsString();\n+            // CommuniqueType type = CommuniqueType.valueOf(communiqueType);\n+            logger.debug(\"Received CommuniqueType: {}\", communiqueType);\n+            callback.validMessageReceived(communiqueType);\n+\n+            switch (communiqueType) {\n+                case \"CreateResponse\":\n+                    return;\n+                case \"ReadResponse\":\n+                    handleReadResponseMessage(message);\n+                    break;\n+                case \"UpdateResponse\":\n+                    break;\n+                case \"SubscribeResponse\":\n+                    // Subscribe responses can contain bodies with data\n+                    handleReadResponseMessage(message);\n+                    return;\n+                case \"UnsubscribeResponse\":\n+                    return;\n+                case \"ExceptionResponse\":\n+                    handleExceptionResponse(message);\n+                    return;\n+                default:\n+                    logger.debug(\"Unknown CommuniqueType received: {}\", communiqueType);\n+                    break;\n+            }\n+        } catch (JsonParseException e) {\n+            logger.debug(\"Error parsing message: {}\", e.getMessage());\n+            return;\n+        }\n+    }\n+\n+    /**\n+     * Method called by handleMessage() to handle all LEAP ExceptionResponse messages.\n+     *\n+     * @param message LEAP message\n+     */\n+    private void handleExceptionResponse(JsonObject message) {\n+        String detailMessage = \"\";\n+\n+        try {\n+            JsonObject header = message.get(\"Header\").getAsJsonObject();\n+            Header headerObj = gson.fromJson(header, Header.class);\n+\n+            if (MessageBodyType.ExceptionDetail.toString().equalsIgnoreCase(headerObj.messageBodyType)\n+                    && message.has(\"Body\")) {\n+                JsonObject body = message.get(\"Body\").getAsJsonObject();\n+                ExceptionDetail exceptionDetail = gson.fromJson(body, ExceptionDetail.class);\n+                if (exceptionDetail != null) {\n+                    detailMessage = exceptionDetail.message;\n+                }\n+            }\n+            logger.debug(\"Exception response received. Status: {} URL: {} Message: {}\", headerObj.statusCode,\n+                    headerObj.url, detailMessage);\n+\n+        } catch (JsonParseException | IllegalStateException e) {\n+            logger.debug(\"Exception response received. Error parsing exception message: {}\", e.getMessage());\n+            return;\n+        }\n+    }\n+\n+    /**\n+     * Method called by handleMessage() to handle all LEAP ReadResponse and SubscribeResponse messages.\n+     *\n+     * @param message LEAP message\n+     */\n+    private void handleReadResponseMessage(JsonObject message) {\n+        try {\n+            JsonObject header = message.get(\"Header\").getAsJsonObject();\n+            Header headerObj = gson.fromJson(header, Header.class);\n+\n+            // if 204/NoContent response received for buttongroup request, create empty button map\n+            if (Request.BUTTON_GROUP_URL.equals(headerObj.url)\n+                    && Header.STATUS_NO_CONTENT.equalsIgnoreCase(headerObj.statusCode)) {\n+                callback.handleEmptyButtonGroupDefinition();\n+                return;\n+            }\n+\n+            if (!header.has(\"MessageBodyType\")) {\n+                logger.trace(\"No MessageBodyType in header\");\n+                return;\n+            }\n+            String messageBodyType = header.get(\"MessageBodyType\").getAsString();\n+            logger.trace(\"MessageBodyType: {}\", messageBodyType);\n+\n+            if (!message.has(\"Body\")) {\n+                logger.debug(\"No Body found in message\");\n+                return;\n+            }\n+            JsonObject body = message.get(\"Body\").getAsJsonObject();\n+\n+            switch (messageBodyType) {\n+                case \"OnePingResponse\":\n+                    parseOnePingResponse(body);\n+                    break;\n+                case \"OneZoneStatus\":\n+                    parseOneZoneStatus(body);\n+                    break;\n+                case \"MultipleAreaDefinition\":\n+                    parseMultipleAreaDefinition(body);\n+                    break;\n+                case \"MultipleButtonGroupDefinition\":\n+                    parseMultipleButtonGroupDefinition(body);\n+                    break;\n+                case \"MultipleDeviceDefinition\":\n+                    parseMultipleDeviceDefinition(body);\n+                    break;\n+                case \"MultipleOccupancyGroupDefinition\":\n+                    parseMultipleOccupancyGroupDefinition(body);\n+                    break;\n+                case \"MultipleOccupancyGroupStatus\":\n+                    parseMultipleOccupancyGroupStatus(body);\n+                    break;\n+                case \"MultipleVirtualButtonDefinition\":\n+                    break;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY3MDIwNg=="}, "originalCommit": {"oid": "deb48c1252ee18917f2f9e19cf0158fedb164659"}, "originalPosition": 195}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNDkwODU0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.lutron/src/main/java/org/openhab/binding/lutron/internal/protocol/lip/TargetType.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwMDozMjo1MFrOHdehcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwMDozMjo1MFrOHdehcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY3MDgzNA==", "bodyText": "Please add @NonNullByDefault", "url": "https://github.com/openhab/openhab-addons/pull/8650#discussion_r500670834", "createdAt": "2020-10-07T00:32:50Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lutron/src/main/java/org/openhab/binding/lutron/internal/protocol/lip/TargetType.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lutron.internal.protocol.lip;\n+\n+/**\n+ * Target device type enum. Used to annotate LutronCommand objects so the LEAP bridge can translate them.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+public enum TargetType {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "deb48c1252ee18917f2f9e19cf0158fedb164659"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNTA1MzU5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.lutron/src/main/java/org/openhab/binding/lutron/internal/handler/LeapBridgeHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwMTo1NjozNVrOHdf1Eg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwMTo1NjozNVrOHdf1Eg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY5MjI0Mg==", "bodyText": "Since you aren't using any of the atomic functionality of this class, you should just replace it with a volatile boolean instead.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private final AtomicBoolean deviceDataLoaded = new AtomicBoolean(false);\n          \n          \n            \n                private volatile boolean deviceDataLoaded = false;", "url": "https://github.com/openhab/openhab-addons/pull/8650#discussion_r500692242", "createdAt": "2020-10-07T01:56:35Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lutron/src/main/java/org/openhab/binding/lutron/internal/handler/LeapBridgeHandler.java", "diffHunk": "@@ -0,0 +1,763 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lutron.internal.handler;\n+\n+import static org.openhab.binding.lutron.internal.LutronBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.net.UnknownHostException;\n+import java.security.KeyManagementException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.UnrecoverableKeyException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManager;\n+import javax.net.ssl.TrustManagerFactory;\n+import javax.net.ssl.X509TrustManager;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.lutron.internal.config.LeapBridgeConfig;\n+import org.openhab.binding.lutron.internal.discovery.LeapDeviceDiscoveryService;\n+import org.openhab.binding.lutron.internal.protocol.FanSpeedType;\n+import org.openhab.binding.lutron.internal.protocol.GroupCommand;\n+import org.openhab.binding.lutron.internal.protocol.LutronCommandNew;\n+import org.openhab.binding.lutron.internal.protocol.OutputCommand;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapCommand;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapMessageParser;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapMessageParserCallbacks;\n+import org.openhab.binding.lutron.internal.protocol.leap.Request;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Area;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ButtonGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Device;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.OccupancyGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ZoneStatus;\n+import org.openhab.binding.lutron.internal.protocol.lip.LutronCommandType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Bridge handler responsible for communicating with Lutron hubs that support the LEAP protocol, such as Caseta and\n+ * RA2 Select.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LeapBridgeHandler extends LutronBridgeHandler implements LeapMessageParserCallbacks {\n+    private static final int DEFAULT_RECONNECT_MINUTES = 5;\n+    private static final int DEFAULT_HEARTBEAT_MINUTES = 5;\n+    private static final long KEEPALIVE_TIMEOUT_SECONDS = 30;\n+\n+    private static final String STATUS_INITIALIZING = \"Initializing\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(LeapBridgeHandler.class);\n+\n+    private @NonNullByDefault({}) LeapBridgeConfig config;\n+    private int reconnectInterval;\n+    private int heartbeatInterval;\n+    private int sendDelay;\n+\n+    private @NonNullByDefault({}) SSLSocketFactory sslsocketfactory;\n+    private @Nullable SSLSocket sslsocket;\n+    private @Nullable BufferedWriter writer;\n+    private @Nullable BufferedReader reader;\n+\n+    private @NonNullByDefault({}) LeapMessageParser leapMessageParser;\n+\n+    private final BlockingQueue<LeapCommand> sendQueue = new LinkedBlockingQueue<>();\n+\n+    private @Nullable Thread senderThread;\n+    private @Nullable Thread readerThread;\n+\n+    private @Nullable ScheduledFuture<?> keepAlive;\n+    private @Nullable ScheduledFuture<?> keepAliveReconnect;\n+    private @Nullable ScheduledFuture<?> connectRetryJob;\n+    private final Object keepAliveReconnectLock = new Object();\n+\n+    private final Map<Integer, Integer> zoneToDevice = new HashMap<>();\n+    private final Map<Integer, Integer> deviceToZone = new HashMap<>();\n+    private final Object zoneMapsLock = new Object();\n+\n+    private @Nullable Map<Integer, List<Integer>> deviceButtonMap;\n+    private final Object deviceButtonMapLock = new Object();\n+\n+    private final AtomicBoolean deviceDataLoaded = new AtomicBoolean(false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "deb48c1252ee18917f2f9e19cf0158fedb164659"}, "originalPosition": 125}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNTA1NDE2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.lutron/src/main/java/org/openhab/binding/lutron/internal/handler/LeapBridgeHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwMTo1Njo1MVrOHdf1Zg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwMTo1Njo1MVrOHdf1Zg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY5MjMyNg==", "bodyText": "same here\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private final AtomicBoolean buttonDataLoaded = new AtomicBoolean(false);\n          \n          \n            \n                private volatile boolean buttonDataLoaded = false;", "url": "https://github.com/openhab/openhab-addons/pull/8650#discussion_r500692326", "createdAt": "2020-10-07T01:56:51Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lutron/src/main/java/org/openhab/binding/lutron/internal/handler/LeapBridgeHandler.java", "diffHunk": "@@ -0,0 +1,763 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lutron.internal.handler;\n+\n+import static org.openhab.binding.lutron.internal.LutronBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.net.UnknownHostException;\n+import java.security.KeyManagementException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.UnrecoverableKeyException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManager;\n+import javax.net.ssl.TrustManagerFactory;\n+import javax.net.ssl.X509TrustManager;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.lutron.internal.config.LeapBridgeConfig;\n+import org.openhab.binding.lutron.internal.discovery.LeapDeviceDiscoveryService;\n+import org.openhab.binding.lutron.internal.protocol.FanSpeedType;\n+import org.openhab.binding.lutron.internal.protocol.GroupCommand;\n+import org.openhab.binding.lutron.internal.protocol.LutronCommandNew;\n+import org.openhab.binding.lutron.internal.protocol.OutputCommand;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapCommand;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapMessageParser;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapMessageParserCallbacks;\n+import org.openhab.binding.lutron.internal.protocol.leap.Request;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Area;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ButtonGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Device;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.OccupancyGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ZoneStatus;\n+import org.openhab.binding.lutron.internal.protocol.lip.LutronCommandType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Bridge handler responsible for communicating with Lutron hubs that support the LEAP protocol, such as Caseta and\n+ * RA2 Select.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LeapBridgeHandler extends LutronBridgeHandler implements LeapMessageParserCallbacks {\n+    private static final int DEFAULT_RECONNECT_MINUTES = 5;\n+    private static final int DEFAULT_HEARTBEAT_MINUTES = 5;\n+    private static final long KEEPALIVE_TIMEOUT_SECONDS = 30;\n+\n+    private static final String STATUS_INITIALIZING = \"Initializing\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(LeapBridgeHandler.class);\n+\n+    private @NonNullByDefault({}) LeapBridgeConfig config;\n+    private int reconnectInterval;\n+    private int heartbeatInterval;\n+    private int sendDelay;\n+\n+    private @NonNullByDefault({}) SSLSocketFactory sslsocketfactory;\n+    private @Nullable SSLSocket sslsocket;\n+    private @Nullable BufferedWriter writer;\n+    private @Nullable BufferedReader reader;\n+\n+    private @NonNullByDefault({}) LeapMessageParser leapMessageParser;\n+\n+    private final BlockingQueue<LeapCommand> sendQueue = new LinkedBlockingQueue<>();\n+\n+    private @Nullable Thread senderThread;\n+    private @Nullable Thread readerThread;\n+\n+    private @Nullable ScheduledFuture<?> keepAlive;\n+    private @Nullable ScheduledFuture<?> keepAliveReconnect;\n+    private @Nullable ScheduledFuture<?> connectRetryJob;\n+    private final Object keepAliveReconnectLock = new Object();\n+\n+    private final Map<Integer, Integer> zoneToDevice = new HashMap<>();\n+    private final Map<Integer, Integer> deviceToZone = new HashMap<>();\n+    private final Object zoneMapsLock = new Object();\n+\n+    private @Nullable Map<Integer, List<Integer>> deviceButtonMap;\n+    private final Object deviceButtonMapLock = new Object();\n+\n+    private final AtomicBoolean deviceDataLoaded = new AtomicBoolean(false);\n+    private final AtomicBoolean buttonDataLoaded = new AtomicBoolean(false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "deb48c1252ee18917f2f9e19cf0158fedb164659"}, "originalPosition": 126}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNTA2NzkzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.lutron/src/main/java/org/openhab/binding/lutron/internal/handler/LeapBridgeHandler.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwMjowMzowOFrOHdf8tg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQwNDo0MTowN1rOHe6-uA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY5NDE5OA==", "bodyText": "You should make another catch for a InterruptedIOException. You shouldn't attempt a reconnect if you received an interrupt.", "url": "https://github.com/openhab/openhab-addons/pull/8650#discussion_r500694198", "createdAt": "2020-10-07T02:03:08Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lutron/src/main/java/org/openhab/binding/lutron/internal/handler/LeapBridgeHandler.java", "diffHunk": "@@ -0,0 +1,763 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lutron.internal.handler;\n+\n+import static org.openhab.binding.lutron.internal.LutronBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.net.UnknownHostException;\n+import java.security.KeyManagementException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.UnrecoverableKeyException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManager;\n+import javax.net.ssl.TrustManagerFactory;\n+import javax.net.ssl.X509TrustManager;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.lutron.internal.config.LeapBridgeConfig;\n+import org.openhab.binding.lutron.internal.discovery.LeapDeviceDiscoveryService;\n+import org.openhab.binding.lutron.internal.protocol.FanSpeedType;\n+import org.openhab.binding.lutron.internal.protocol.GroupCommand;\n+import org.openhab.binding.lutron.internal.protocol.LutronCommandNew;\n+import org.openhab.binding.lutron.internal.protocol.OutputCommand;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapCommand;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapMessageParser;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapMessageParserCallbacks;\n+import org.openhab.binding.lutron.internal.protocol.leap.Request;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Area;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ButtonGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Device;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.OccupancyGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ZoneStatus;\n+import org.openhab.binding.lutron.internal.protocol.lip.LutronCommandType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Bridge handler responsible for communicating with Lutron hubs that support the LEAP protocol, such as Caseta and\n+ * RA2 Select.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LeapBridgeHandler extends LutronBridgeHandler implements LeapMessageParserCallbacks {\n+    private static final int DEFAULT_RECONNECT_MINUTES = 5;\n+    private static final int DEFAULT_HEARTBEAT_MINUTES = 5;\n+    private static final long KEEPALIVE_TIMEOUT_SECONDS = 30;\n+\n+    private static final String STATUS_INITIALIZING = \"Initializing\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(LeapBridgeHandler.class);\n+\n+    private @NonNullByDefault({}) LeapBridgeConfig config;\n+    private int reconnectInterval;\n+    private int heartbeatInterval;\n+    private int sendDelay;\n+\n+    private @NonNullByDefault({}) SSLSocketFactory sslsocketfactory;\n+    private @Nullable SSLSocket sslsocket;\n+    private @Nullable BufferedWriter writer;\n+    private @Nullable BufferedReader reader;\n+\n+    private @NonNullByDefault({}) LeapMessageParser leapMessageParser;\n+\n+    private final BlockingQueue<LeapCommand> sendQueue = new LinkedBlockingQueue<>();\n+\n+    private @Nullable Thread senderThread;\n+    private @Nullable Thread readerThread;\n+\n+    private @Nullable ScheduledFuture<?> keepAlive;\n+    private @Nullable ScheduledFuture<?> keepAliveReconnect;\n+    private @Nullable ScheduledFuture<?> connectRetryJob;\n+    private final Object keepAliveReconnectLock = new Object();\n+\n+    private final Map<Integer, Integer> zoneToDevice = new HashMap<>();\n+    private final Map<Integer, Integer> deviceToZone = new HashMap<>();\n+    private final Object zoneMapsLock = new Object();\n+\n+    private @Nullable Map<Integer, List<Integer>> deviceButtonMap;\n+    private final Object deviceButtonMapLock = new Object();\n+\n+    private final AtomicBoolean deviceDataLoaded = new AtomicBoolean(false);\n+    private final AtomicBoolean buttonDataLoaded = new AtomicBoolean(false);\n+\n+    private final Map<Integer, LutronHandler> childHandlerMap = new ConcurrentHashMap<>();\n+    private final Map<Integer, OGroupHandler> groupHandlerMap = new ConcurrentHashMap<>();\n+\n+    private @Nullable LeapDeviceDiscoveryService discoveryService;\n+\n+    public void setDiscoveryService(LeapDeviceDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    public LeapBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+        leapMessageParser = new LeapMessageParser(this);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        SSLContext sslContext;\n+\n+        childHandlerMap.clear();\n+        groupHandlerMap.clear();\n+\n+        config = getConfigAs(LeapBridgeConfig.class);\n+        String keystorePassword = (config.keystorePassword == null) ? \"\" : config.keystorePassword;\n+\n+        String ipAddress = config.ipAddress;\n+        if (ipAddress == null || ipAddress.isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"bridge address not specified\");\n+            return;\n+        }\n+\n+        reconnectInterval = (config.reconnect > 0) ? config.reconnect : DEFAULT_RECONNECT_MINUTES;\n+        heartbeatInterval = (config.heartbeat > 0) ? config.heartbeat : DEFAULT_HEARTBEAT_MINUTES;\n+        sendDelay = (config.delay < 0) ? 0 : config.delay;\n+\n+        if (config.keystore == null || keystorePassword == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Keystore/keystore password not configured\");\n+            return;\n+        } else {\n+            try (FileInputStream keystoreInputStream = new FileInputStream(config.keystore)) {\n+                logger.trace(\"Initializing keystore\");\n+                KeyStore keystore = KeyStore.getInstance(KeyStore.getDefaultType());\n+\n+                keystore.load(keystoreInputStream, keystorePassword.toCharArray());\n+\n+                logger.trace(\"Initializing SSL Context\");\n+                KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n+                kmf.init(keystore, keystorePassword.toCharArray());\n+\n+                TrustManager[] trustManagers;\n+                if (config.certValidate) {\n+                    // Use default trust manager which will attempt to validate server certificate from hub\n+                    TrustManagerFactory tmf = TrustManagerFactory\n+                            .getInstance(TrustManagerFactory.getDefaultAlgorithm());\n+                    tmf.init(keystore);\n+                    trustManagers = tmf.getTrustManagers();\n+                } else {\n+                    // Use no-op trust manager which will not verify certificates\n+                    trustManagers = defineNoOpTrustManager();\n+                }\n+\n+                sslContext = SSLContext.getInstance(\"TLS\");\n+                sslContext.init(kmf.getKeyManagers(), trustManagers, null);\n+\n+                sslsocketfactory = sslContext.getSocketFactory();\n+            } catch (FileNotFoundException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Keystore file not found\");\n+                return;\n+            } catch (CertificateException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Certificate exception\");\n+                return;\n+            } catch (UnrecoverableKeyException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"Key unrecoverable with supplied password\");\n+                return;\n+            } catch (KeyManagementException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Key management exception\");\n+                logger.debug(\"Key management exception\", e);\n+                return;\n+            } catch (KeyStoreException | NoSuchAlgorithmException | IOException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Error initializing keystore\");\n+                logger.debug(\"Error initializing keystore\", e);\n+                return;\n+            }\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Connecting\");\n+        scheduler.submit(this::connect); // start the async connect task\n+    }\n+\n+    /**\n+     * Return a no-op SSL trust manager which will not verify server or client certificates.\n+     */\n+    private TrustManager[] defineNoOpTrustManager() {\n+        return new TrustManager[] { new X509TrustManager() {\n+            @Override\n+            public void checkClientTrusted(final X509Certificate @Nullable [] chain, final @Nullable String authType) {\n+                logger.debug(\"Assuming client certificate is valid\");\n+                if (chain != null) {\n+                    for (int cert = 0; cert < chain.length; cert++) {\n+                        logger.trace(\"Subject DN: {}\", chain[cert].getSubjectDN());\n+                        logger.trace(\"Issuer DN: {}\", chain[cert].getIssuerDN());\n+                        logger.trace(\"Serial number {}:\", chain[cert].getSerialNumber());\n+                    }\n+                }\n+            }\n+\n+            @Override\n+            public void checkServerTrusted(final X509Certificate @Nullable [] chain, final @Nullable String authType) {\n+                logger.debug(\"Assuming server certificate is valid\");\n+                if (chain != null) {\n+                    for (int cert = 0; cert < chain.length; cert++) {\n+                        logger.trace(\"Subject DN: {}\", chain[cert].getSubjectDN());\n+                        logger.trace(\"Issuer DN: {}\", chain[cert].getIssuerDN());\n+                        logger.trace(\"Serial number: {}\", chain[cert].getSerialNumber());\n+                    }\n+                }\n+            }\n+\n+            @Override\n+            public X509Certificate @Nullable [] getAcceptedIssuers() {\n+                return null;\n+            }\n+        } };\n+    }\n+\n+    private synchronized void connect() {\n+        deviceDataLoaded.set(false);\n+        buttonDataLoaded.set(false);\n+\n+        try {\n+            logger.debug(\"Opening SSL connection to {}:{}\", config.ipAddress, config.port);\n+            SSLSocket sslsocket = (SSLSocket) sslsocketfactory.createSocket(config.ipAddress, config.port);\n+            sslsocket.startHandshake();\n+            writer = new BufferedWriter(new OutputStreamWriter(sslsocket.getOutputStream()));\n+            reader = new BufferedReader(new InputStreamReader(sslsocket.getInputStream()));\n+            this.sslsocket = sslsocket;\n+        } catch (UnknownHostException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Unknown host\");\n+            return;\n+        } catch (IllegalArgumentException e) {\n+            // port out of valid range\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Invalid port number\");\n+            return;\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Error opening SSL connection. Check log.\");\n+            logger.info(\"Error opening SSL connection: {}\", e.getMessage());\n+            disconnect();\n+            scheduleConnectRetry(reconnectInterval); // Possibly a temporary problem. Try again later.\n+            return;\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, STATUS_INITIALIZING);\n+\n+        Thread readerThread = new Thread(this::readerThreadJob, \"Lutron reader\");\n+        readerThread.setDaemon(true);\n+        readerThread.start();\n+        this.readerThread = readerThread;\n+\n+        Thread senderThread = new Thread(this::senderThreadJob, \"Lutron sender\");\n+        senderThread.setDaemon(true);\n+        senderThread.start();\n+        this.senderThread = senderThread;\n+\n+        sendCommand(new LeapCommand(Request.getButtonGroups()));\n+        queryDiscoveryData();\n+        sendCommand(new LeapCommand(Request.subscribeOccupancyGroupStatus()));\n+\n+        logger.debug(\"Starting keepAlive job with interval {}\", heartbeatInterval);\n+        keepAlive = scheduler.scheduleWithFixedDelay(this::sendKeepAlive, heartbeatInterval, heartbeatInterval,\n+                TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Called by connect() and discovery service to request fresh discovery data\n+     */\n+    public void queryDiscoveryData() {\n+        sendCommand(new LeapCommand(Request.getDevices()));\n+        sendCommand(new LeapCommand(Request.getAreas()));\n+        sendCommand(new LeapCommand(Request.getOccupancyGroups()));\n+    }\n+\n+    private void scheduleConnectRetry(long waitMinutes) {\n+        logger.debug(\"Scheduling connection retry in {} minutes\", waitMinutes);\n+        connectRetryJob = scheduler.schedule(this::connect, waitMinutes, TimeUnit.MINUTES);\n+    }\n+\n+    private synchronized void disconnect() {\n+        logger.debug(\"Disconnecting\");\n+\n+        Thread senderThread = this.senderThread;\n+        Thread readerThread = this.readerThread;\n+\n+        if (connectRetryJob != null) {\n+            connectRetryJob.cancel(true);\n+        }\n+        if (keepAlive != null) {\n+            keepAlive.cancel(true);\n+        }\n+\n+        // May be called from keepAliveReconnect thread, so call cancel with false\n+        reconnectTaskCancel(false);\n+\n+        if (senderThread != null && senderThread.isAlive()) {\n+            senderThread.interrupt();\n+        }\n+        if (readerThread != null && readerThread.isAlive()) {\n+            readerThread.interrupt();\n+        }\n+        if (sslsocket != null) {\n+            try {\n+                sslsocket.close();\n+            } catch (IOException e) {\n+                logger.debug(\"Error closing SSL socket: {}\", e.getMessage());\n+            }\n+            sslsocket = null;\n+        }\n+        if (reader != null) {\n+            try {\n+                reader.close();\n+            } catch (IOException e) {\n+                logger.debug(\"Error closing reader: {}\", e.getMessage());\n+            }\n+        }\n+        if (writer != null) {\n+            try {\n+                writer.close();\n+            } catch (IOException e) {\n+                logger.debug(\"Error closing writer: {}\", e.getMessage());\n+            }\n+        }\n+\n+        deviceDataLoaded.set(false);\n+        buttonDataLoaded.set(false);\n+    }\n+\n+    private synchronized void reconnect() {\n+        logger.debug(\"Attempting to reconnect to the bridge\");\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"reconnecting\");\n+        disconnect();\n+        connect();\n+    }\n+\n+    /**\n+     * Method executed by the message sender thread (senderThread)\n+     */\n+    private void senderThreadJob() {\n+        logger.debug(\"Command sender thread started\");\n+        try {\n+            while (!Thread.currentThread().isInterrupted() && writer != null) {\n+                LeapCommand command = sendQueue.take();\n+                logger.trace(\"Sending command {}\", command);\n+\n+                try {\n+                    BufferedWriter writer = this.writer;\n+                    if (writer != null) {\n+                        writer.write(command.toString() + \"\\n\");\n+                        writer.flush();\n+                    }\n+                } catch (IOException e) {\n+                    logger.warn(\"Communication error, will try to reconnect. Error: {}\", e.getMessage());\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR);\n+                    sendQueue.add(command); // Requeue command\n+                    reconnect();\n+                    break; // reconnect() will start a new thread; terminate this one\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "deb48c1252ee18917f2f9e19cf0158fedb164659"}, "originalPosition": 394}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQ0MzA1Ng==", "bodyText": "When catching InterruptedIOException, is it best to call Thread.currentThread().interrupt() or just exit?", "url": "https://github.com/openhab/openhab-addons/pull/8650#discussion_r501443056", "createdAt": "2020-10-08T04:35:41Z", "author": {"login": "bobadair"}, "path": "bundles/org.openhab.binding.lutron/src/main/java/org/openhab/binding/lutron/internal/handler/LeapBridgeHandler.java", "diffHunk": "@@ -0,0 +1,763 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lutron.internal.handler;\n+\n+import static org.openhab.binding.lutron.internal.LutronBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.net.UnknownHostException;\n+import java.security.KeyManagementException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.UnrecoverableKeyException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManager;\n+import javax.net.ssl.TrustManagerFactory;\n+import javax.net.ssl.X509TrustManager;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.lutron.internal.config.LeapBridgeConfig;\n+import org.openhab.binding.lutron.internal.discovery.LeapDeviceDiscoveryService;\n+import org.openhab.binding.lutron.internal.protocol.FanSpeedType;\n+import org.openhab.binding.lutron.internal.protocol.GroupCommand;\n+import org.openhab.binding.lutron.internal.protocol.LutronCommandNew;\n+import org.openhab.binding.lutron.internal.protocol.OutputCommand;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapCommand;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapMessageParser;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapMessageParserCallbacks;\n+import org.openhab.binding.lutron.internal.protocol.leap.Request;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Area;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ButtonGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Device;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.OccupancyGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ZoneStatus;\n+import org.openhab.binding.lutron.internal.protocol.lip.LutronCommandType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Bridge handler responsible for communicating with Lutron hubs that support the LEAP protocol, such as Caseta and\n+ * RA2 Select.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LeapBridgeHandler extends LutronBridgeHandler implements LeapMessageParserCallbacks {\n+    private static final int DEFAULT_RECONNECT_MINUTES = 5;\n+    private static final int DEFAULT_HEARTBEAT_MINUTES = 5;\n+    private static final long KEEPALIVE_TIMEOUT_SECONDS = 30;\n+\n+    private static final String STATUS_INITIALIZING = \"Initializing\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(LeapBridgeHandler.class);\n+\n+    private @NonNullByDefault({}) LeapBridgeConfig config;\n+    private int reconnectInterval;\n+    private int heartbeatInterval;\n+    private int sendDelay;\n+\n+    private @NonNullByDefault({}) SSLSocketFactory sslsocketfactory;\n+    private @Nullable SSLSocket sslsocket;\n+    private @Nullable BufferedWriter writer;\n+    private @Nullable BufferedReader reader;\n+\n+    private @NonNullByDefault({}) LeapMessageParser leapMessageParser;\n+\n+    private final BlockingQueue<LeapCommand> sendQueue = new LinkedBlockingQueue<>();\n+\n+    private @Nullable Thread senderThread;\n+    private @Nullable Thread readerThread;\n+\n+    private @Nullable ScheduledFuture<?> keepAlive;\n+    private @Nullable ScheduledFuture<?> keepAliveReconnect;\n+    private @Nullable ScheduledFuture<?> connectRetryJob;\n+    private final Object keepAliveReconnectLock = new Object();\n+\n+    private final Map<Integer, Integer> zoneToDevice = new HashMap<>();\n+    private final Map<Integer, Integer> deviceToZone = new HashMap<>();\n+    private final Object zoneMapsLock = new Object();\n+\n+    private @Nullable Map<Integer, List<Integer>> deviceButtonMap;\n+    private final Object deviceButtonMapLock = new Object();\n+\n+    private final AtomicBoolean deviceDataLoaded = new AtomicBoolean(false);\n+    private final AtomicBoolean buttonDataLoaded = new AtomicBoolean(false);\n+\n+    private final Map<Integer, LutronHandler> childHandlerMap = new ConcurrentHashMap<>();\n+    private final Map<Integer, OGroupHandler> groupHandlerMap = new ConcurrentHashMap<>();\n+\n+    private @Nullable LeapDeviceDiscoveryService discoveryService;\n+\n+    public void setDiscoveryService(LeapDeviceDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    public LeapBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+        leapMessageParser = new LeapMessageParser(this);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        SSLContext sslContext;\n+\n+        childHandlerMap.clear();\n+        groupHandlerMap.clear();\n+\n+        config = getConfigAs(LeapBridgeConfig.class);\n+        String keystorePassword = (config.keystorePassword == null) ? \"\" : config.keystorePassword;\n+\n+        String ipAddress = config.ipAddress;\n+        if (ipAddress == null || ipAddress.isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"bridge address not specified\");\n+            return;\n+        }\n+\n+        reconnectInterval = (config.reconnect > 0) ? config.reconnect : DEFAULT_RECONNECT_MINUTES;\n+        heartbeatInterval = (config.heartbeat > 0) ? config.heartbeat : DEFAULT_HEARTBEAT_MINUTES;\n+        sendDelay = (config.delay < 0) ? 0 : config.delay;\n+\n+        if (config.keystore == null || keystorePassword == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Keystore/keystore password not configured\");\n+            return;\n+        } else {\n+            try (FileInputStream keystoreInputStream = new FileInputStream(config.keystore)) {\n+                logger.trace(\"Initializing keystore\");\n+                KeyStore keystore = KeyStore.getInstance(KeyStore.getDefaultType());\n+\n+                keystore.load(keystoreInputStream, keystorePassword.toCharArray());\n+\n+                logger.trace(\"Initializing SSL Context\");\n+                KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n+                kmf.init(keystore, keystorePassword.toCharArray());\n+\n+                TrustManager[] trustManagers;\n+                if (config.certValidate) {\n+                    // Use default trust manager which will attempt to validate server certificate from hub\n+                    TrustManagerFactory tmf = TrustManagerFactory\n+                            .getInstance(TrustManagerFactory.getDefaultAlgorithm());\n+                    tmf.init(keystore);\n+                    trustManagers = tmf.getTrustManagers();\n+                } else {\n+                    // Use no-op trust manager which will not verify certificates\n+                    trustManagers = defineNoOpTrustManager();\n+                }\n+\n+                sslContext = SSLContext.getInstance(\"TLS\");\n+                sslContext.init(kmf.getKeyManagers(), trustManagers, null);\n+\n+                sslsocketfactory = sslContext.getSocketFactory();\n+            } catch (FileNotFoundException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Keystore file not found\");\n+                return;\n+            } catch (CertificateException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Certificate exception\");\n+                return;\n+            } catch (UnrecoverableKeyException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"Key unrecoverable with supplied password\");\n+                return;\n+            } catch (KeyManagementException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Key management exception\");\n+                logger.debug(\"Key management exception\", e);\n+                return;\n+            } catch (KeyStoreException | NoSuchAlgorithmException | IOException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Error initializing keystore\");\n+                logger.debug(\"Error initializing keystore\", e);\n+                return;\n+            }\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Connecting\");\n+        scheduler.submit(this::connect); // start the async connect task\n+    }\n+\n+    /**\n+     * Return a no-op SSL trust manager which will not verify server or client certificates.\n+     */\n+    private TrustManager[] defineNoOpTrustManager() {\n+        return new TrustManager[] { new X509TrustManager() {\n+            @Override\n+            public void checkClientTrusted(final X509Certificate @Nullable [] chain, final @Nullable String authType) {\n+                logger.debug(\"Assuming client certificate is valid\");\n+                if (chain != null) {\n+                    for (int cert = 0; cert < chain.length; cert++) {\n+                        logger.trace(\"Subject DN: {}\", chain[cert].getSubjectDN());\n+                        logger.trace(\"Issuer DN: {}\", chain[cert].getIssuerDN());\n+                        logger.trace(\"Serial number {}:\", chain[cert].getSerialNumber());\n+                    }\n+                }\n+            }\n+\n+            @Override\n+            public void checkServerTrusted(final X509Certificate @Nullable [] chain, final @Nullable String authType) {\n+                logger.debug(\"Assuming server certificate is valid\");\n+                if (chain != null) {\n+                    for (int cert = 0; cert < chain.length; cert++) {\n+                        logger.trace(\"Subject DN: {}\", chain[cert].getSubjectDN());\n+                        logger.trace(\"Issuer DN: {}\", chain[cert].getIssuerDN());\n+                        logger.trace(\"Serial number: {}\", chain[cert].getSerialNumber());\n+                    }\n+                }\n+            }\n+\n+            @Override\n+            public X509Certificate @Nullable [] getAcceptedIssuers() {\n+                return null;\n+            }\n+        } };\n+    }\n+\n+    private synchronized void connect() {\n+        deviceDataLoaded.set(false);\n+        buttonDataLoaded.set(false);\n+\n+        try {\n+            logger.debug(\"Opening SSL connection to {}:{}\", config.ipAddress, config.port);\n+            SSLSocket sslsocket = (SSLSocket) sslsocketfactory.createSocket(config.ipAddress, config.port);\n+            sslsocket.startHandshake();\n+            writer = new BufferedWriter(new OutputStreamWriter(sslsocket.getOutputStream()));\n+            reader = new BufferedReader(new InputStreamReader(sslsocket.getInputStream()));\n+            this.sslsocket = sslsocket;\n+        } catch (UnknownHostException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Unknown host\");\n+            return;\n+        } catch (IllegalArgumentException e) {\n+            // port out of valid range\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Invalid port number\");\n+            return;\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Error opening SSL connection. Check log.\");\n+            logger.info(\"Error opening SSL connection: {}\", e.getMessage());\n+            disconnect();\n+            scheduleConnectRetry(reconnectInterval); // Possibly a temporary problem. Try again later.\n+            return;\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, STATUS_INITIALIZING);\n+\n+        Thread readerThread = new Thread(this::readerThreadJob, \"Lutron reader\");\n+        readerThread.setDaemon(true);\n+        readerThread.start();\n+        this.readerThread = readerThread;\n+\n+        Thread senderThread = new Thread(this::senderThreadJob, \"Lutron sender\");\n+        senderThread.setDaemon(true);\n+        senderThread.start();\n+        this.senderThread = senderThread;\n+\n+        sendCommand(new LeapCommand(Request.getButtonGroups()));\n+        queryDiscoveryData();\n+        sendCommand(new LeapCommand(Request.subscribeOccupancyGroupStatus()));\n+\n+        logger.debug(\"Starting keepAlive job with interval {}\", heartbeatInterval);\n+        keepAlive = scheduler.scheduleWithFixedDelay(this::sendKeepAlive, heartbeatInterval, heartbeatInterval,\n+                TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Called by connect() and discovery service to request fresh discovery data\n+     */\n+    public void queryDiscoveryData() {\n+        sendCommand(new LeapCommand(Request.getDevices()));\n+        sendCommand(new LeapCommand(Request.getAreas()));\n+        sendCommand(new LeapCommand(Request.getOccupancyGroups()));\n+    }\n+\n+    private void scheduleConnectRetry(long waitMinutes) {\n+        logger.debug(\"Scheduling connection retry in {} minutes\", waitMinutes);\n+        connectRetryJob = scheduler.schedule(this::connect, waitMinutes, TimeUnit.MINUTES);\n+    }\n+\n+    private synchronized void disconnect() {\n+        logger.debug(\"Disconnecting\");\n+\n+        Thread senderThread = this.senderThread;\n+        Thread readerThread = this.readerThread;\n+\n+        if (connectRetryJob != null) {\n+            connectRetryJob.cancel(true);\n+        }\n+        if (keepAlive != null) {\n+            keepAlive.cancel(true);\n+        }\n+\n+        // May be called from keepAliveReconnect thread, so call cancel with false\n+        reconnectTaskCancel(false);\n+\n+        if (senderThread != null && senderThread.isAlive()) {\n+            senderThread.interrupt();\n+        }\n+        if (readerThread != null && readerThread.isAlive()) {\n+            readerThread.interrupt();\n+        }\n+        if (sslsocket != null) {\n+            try {\n+                sslsocket.close();\n+            } catch (IOException e) {\n+                logger.debug(\"Error closing SSL socket: {}\", e.getMessage());\n+            }\n+            sslsocket = null;\n+        }\n+        if (reader != null) {\n+            try {\n+                reader.close();\n+            } catch (IOException e) {\n+                logger.debug(\"Error closing reader: {}\", e.getMessage());\n+            }\n+        }\n+        if (writer != null) {\n+            try {\n+                writer.close();\n+            } catch (IOException e) {\n+                logger.debug(\"Error closing writer: {}\", e.getMessage());\n+            }\n+        }\n+\n+        deviceDataLoaded.set(false);\n+        buttonDataLoaded.set(false);\n+    }\n+\n+    private synchronized void reconnect() {\n+        logger.debug(\"Attempting to reconnect to the bridge\");\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"reconnecting\");\n+        disconnect();\n+        connect();\n+    }\n+\n+    /**\n+     * Method executed by the message sender thread (senderThread)\n+     */\n+    private void senderThreadJob() {\n+        logger.debug(\"Command sender thread started\");\n+        try {\n+            while (!Thread.currentThread().isInterrupted() && writer != null) {\n+                LeapCommand command = sendQueue.take();\n+                logger.trace(\"Sending command {}\", command);\n+\n+                try {\n+                    BufferedWriter writer = this.writer;\n+                    if (writer != null) {\n+                        writer.write(command.toString() + \"\\n\");\n+                        writer.flush();\n+                    }\n+                } catch (IOException e) {\n+                    logger.warn(\"Communication error, will try to reconnect. Error: {}\", e.getMessage());\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR);\n+                    sendQueue.add(command); // Requeue command\n+                    reconnect();\n+                    break; // reconnect() will start a new thread; terminate this one\n+                }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY5NDE5OA=="}, "originalCommit": {"oid": "deb48c1252ee18917f2f9e19cf0158fedb164659"}, "originalPosition": 394}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQ0OTg2OA==", "bodyText": "It would be best to just exit. Calling Thread.currentThread().interrupt() is only useful if you expect/know that something higher up the call stack is checking for interrupts. Which I don't think is the case here.", "url": "https://github.com/openhab/openhab-addons/pull/8650#discussion_r501449868", "createdAt": "2020-10-08T05:03:24Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lutron/src/main/java/org/openhab/binding/lutron/internal/handler/LeapBridgeHandler.java", "diffHunk": "@@ -0,0 +1,763 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lutron.internal.handler;\n+\n+import static org.openhab.binding.lutron.internal.LutronBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.net.UnknownHostException;\n+import java.security.KeyManagementException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.UnrecoverableKeyException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManager;\n+import javax.net.ssl.TrustManagerFactory;\n+import javax.net.ssl.X509TrustManager;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.lutron.internal.config.LeapBridgeConfig;\n+import org.openhab.binding.lutron.internal.discovery.LeapDeviceDiscoveryService;\n+import org.openhab.binding.lutron.internal.protocol.FanSpeedType;\n+import org.openhab.binding.lutron.internal.protocol.GroupCommand;\n+import org.openhab.binding.lutron.internal.protocol.LutronCommandNew;\n+import org.openhab.binding.lutron.internal.protocol.OutputCommand;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapCommand;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapMessageParser;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapMessageParserCallbacks;\n+import org.openhab.binding.lutron.internal.protocol.leap.Request;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Area;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ButtonGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Device;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.OccupancyGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ZoneStatus;\n+import org.openhab.binding.lutron.internal.protocol.lip.LutronCommandType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Bridge handler responsible for communicating with Lutron hubs that support the LEAP protocol, such as Caseta and\n+ * RA2 Select.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LeapBridgeHandler extends LutronBridgeHandler implements LeapMessageParserCallbacks {\n+    private static final int DEFAULT_RECONNECT_MINUTES = 5;\n+    private static final int DEFAULT_HEARTBEAT_MINUTES = 5;\n+    private static final long KEEPALIVE_TIMEOUT_SECONDS = 30;\n+\n+    private static final String STATUS_INITIALIZING = \"Initializing\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(LeapBridgeHandler.class);\n+\n+    private @NonNullByDefault({}) LeapBridgeConfig config;\n+    private int reconnectInterval;\n+    private int heartbeatInterval;\n+    private int sendDelay;\n+\n+    private @NonNullByDefault({}) SSLSocketFactory sslsocketfactory;\n+    private @Nullable SSLSocket sslsocket;\n+    private @Nullable BufferedWriter writer;\n+    private @Nullable BufferedReader reader;\n+\n+    private @NonNullByDefault({}) LeapMessageParser leapMessageParser;\n+\n+    private final BlockingQueue<LeapCommand> sendQueue = new LinkedBlockingQueue<>();\n+\n+    private @Nullable Thread senderThread;\n+    private @Nullable Thread readerThread;\n+\n+    private @Nullable ScheduledFuture<?> keepAlive;\n+    private @Nullable ScheduledFuture<?> keepAliveReconnect;\n+    private @Nullable ScheduledFuture<?> connectRetryJob;\n+    private final Object keepAliveReconnectLock = new Object();\n+\n+    private final Map<Integer, Integer> zoneToDevice = new HashMap<>();\n+    private final Map<Integer, Integer> deviceToZone = new HashMap<>();\n+    private final Object zoneMapsLock = new Object();\n+\n+    private @Nullable Map<Integer, List<Integer>> deviceButtonMap;\n+    private final Object deviceButtonMapLock = new Object();\n+\n+    private final AtomicBoolean deviceDataLoaded = new AtomicBoolean(false);\n+    private final AtomicBoolean buttonDataLoaded = new AtomicBoolean(false);\n+\n+    private final Map<Integer, LutronHandler> childHandlerMap = new ConcurrentHashMap<>();\n+    private final Map<Integer, OGroupHandler> groupHandlerMap = new ConcurrentHashMap<>();\n+\n+    private @Nullable LeapDeviceDiscoveryService discoveryService;\n+\n+    public void setDiscoveryService(LeapDeviceDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    public LeapBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+        leapMessageParser = new LeapMessageParser(this);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        SSLContext sslContext;\n+\n+        childHandlerMap.clear();\n+        groupHandlerMap.clear();\n+\n+        config = getConfigAs(LeapBridgeConfig.class);\n+        String keystorePassword = (config.keystorePassword == null) ? \"\" : config.keystorePassword;\n+\n+        String ipAddress = config.ipAddress;\n+        if (ipAddress == null || ipAddress.isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"bridge address not specified\");\n+            return;\n+        }\n+\n+        reconnectInterval = (config.reconnect > 0) ? config.reconnect : DEFAULT_RECONNECT_MINUTES;\n+        heartbeatInterval = (config.heartbeat > 0) ? config.heartbeat : DEFAULT_HEARTBEAT_MINUTES;\n+        sendDelay = (config.delay < 0) ? 0 : config.delay;\n+\n+        if (config.keystore == null || keystorePassword == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Keystore/keystore password not configured\");\n+            return;\n+        } else {\n+            try (FileInputStream keystoreInputStream = new FileInputStream(config.keystore)) {\n+                logger.trace(\"Initializing keystore\");\n+                KeyStore keystore = KeyStore.getInstance(KeyStore.getDefaultType());\n+\n+                keystore.load(keystoreInputStream, keystorePassword.toCharArray());\n+\n+                logger.trace(\"Initializing SSL Context\");\n+                KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n+                kmf.init(keystore, keystorePassword.toCharArray());\n+\n+                TrustManager[] trustManagers;\n+                if (config.certValidate) {\n+                    // Use default trust manager which will attempt to validate server certificate from hub\n+                    TrustManagerFactory tmf = TrustManagerFactory\n+                            .getInstance(TrustManagerFactory.getDefaultAlgorithm());\n+                    tmf.init(keystore);\n+                    trustManagers = tmf.getTrustManagers();\n+                } else {\n+                    // Use no-op trust manager which will not verify certificates\n+                    trustManagers = defineNoOpTrustManager();\n+                }\n+\n+                sslContext = SSLContext.getInstance(\"TLS\");\n+                sslContext.init(kmf.getKeyManagers(), trustManagers, null);\n+\n+                sslsocketfactory = sslContext.getSocketFactory();\n+            } catch (FileNotFoundException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Keystore file not found\");\n+                return;\n+            } catch (CertificateException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Certificate exception\");\n+                return;\n+            } catch (UnrecoverableKeyException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"Key unrecoverable with supplied password\");\n+                return;\n+            } catch (KeyManagementException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Key management exception\");\n+                logger.debug(\"Key management exception\", e);\n+                return;\n+            } catch (KeyStoreException | NoSuchAlgorithmException | IOException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Error initializing keystore\");\n+                logger.debug(\"Error initializing keystore\", e);\n+                return;\n+            }\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Connecting\");\n+        scheduler.submit(this::connect); // start the async connect task\n+    }\n+\n+    /**\n+     * Return a no-op SSL trust manager which will not verify server or client certificates.\n+     */\n+    private TrustManager[] defineNoOpTrustManager() {\n+        return new TrustManager[] { new X509TrustManager() {\n+            @Override\n+            public void checkClientTrusted(final X509Certificate @Nullable [] chain, final @Nullable String authType) {\n+                logger.debug(\"Assuming client certificate is valid\");\n+                if (chain != null) {\n+                    for (int cert = 0; cert < chain.length; cert++) {\n+                        logger.trace(\"Subject DN: {}\", chain[cert].getSubjectDN());\n+                        logger.trace(\"Issuer DN: {}\", chain[cert].getIssuerDN());\n+                        logger.trace(\"Serial number {}:\", chain[cert].getSerialNumber());\n+                    }\n+                }\n+            }\n+\n+            @Override\n+            public void checkServerTrusted(final X509Certificate @Nullable [] chain, final @Nullable String authType) {\n+                logger.debug(\"Assuming server certificate is valid\");\n+                if (chain != null) {\n+                    for (int cert = 0; cert < chain.length; cert++) {\n+                        logger.trace(\"Subject DN: {}\", chain[cert].getSubjectDN());\n+                        logger.trace(\"Issuer DN: {}\", chain[cert].getIssuerDN());\n+                        logger.trace(\"Serial number: {}\", chain[cert].getSerialNumber());\n+                    }\n+                }\n+            }\n+\n+            @Override\n+            public X509Certificate @Nullable [] getAcceptedIssuers() {\n+                return null;\n+            }\n+        } };\n+    }\n+\n+    private synchronized void connect() {\n+        deviceDataLoaded.set(false);\n+        buttonDataLoaded.set(false);\n+\n+        try {\n+            logger.debug(\"Opening SSL connection to {}:{}\", config.ipAddress, config.port);\n+            SSLSocket sslsocket = (SSLSocket) sslsocketfactory.createSocket(config.ipAddress, config.port);\n+            sslsocket.startHandshake();\n+            writer = new BufferedWriter(new OutputStreamWriter(sslsocket.getOutputStream()));\n+            reader = new BufferedReader(new InputStreamReader(sslsocket.getInputStream()));\n+            this.sslsocket = sslsocket;\n+        } catch (UnknownHostException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Unknown host\");\n+            return;\n+        } catch (IllegalArgumentException e) {\n+            // port out of valid range\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Invalid port number\");\n+            return;\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Error opening SSL connection. Check log.\");\n+            logger.info(\"Error opening SSL connection: {}\", e.getMessage());\n+            disconnect();\n+            scheduleConnectRetry(reconnectInterval); // Possibly a temporary problem. Try again later.\n+            return;\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, STATUS_INITIALIZING);\n+\n+        Thread readerThread = new Thread(this::readerThreadJob, \"Lutron reader\");\n+        readerThread.setDaemon(true);\n+        readerThread.start();\n+        this.readerThread = readerThread;\n+\n+        Thread senderThread = new Thread(this::senderThreadJob, \"Lutron sender\");\n+        senderThread.setDaemon(true);\n+        senderThread.start();\n+        this.senderThread = senderThread;\n+\n+        sendCommand(new LeapCommand(Request.getButtonGroups()));\n+        queryDiscoveryData();\n+        sendCommand(new LeapCommand(Request.subscribeOccupancyGroupStatus()));\n+\n+        logger.debug(\"Starting keepAlive job with interval {}\", heartbeatInterval);\n+        keepAlive = scheduler.scheduleWithFixedDelay(this::sendKeepAlive, heartbeatInterval, heartbeatInterval,\n+                TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Called by connect() and discovery service to request fresh discovery data\n+     */\n+    public void queryDiscoveryData() {\n+        sendCommand(new LeapCommand(Request.getDevices()));\n+        sendCommand(new LeapCommand(Request.getAreas()));\n+        sendCommand(new LeapCommand(Request.getOccupancyGroups()));\n+    }\n+\n+    private void scheduleConnectRetry(long waitMinutes) {\n+        logger.debug(\"Scheduling connection retry in {} minutes\", waitMinutes);\n+        connectRetryJob = scheduler.schedule(this::connect, waitMinutes, TimeUnit.MINUTES);\n+    }\n+\n+    private synchronized void disconnect() {\n+        logger.debug(\"Disconnecting\");\n+\n+        Thread senderThread = this.senderThread;\n+        Thread readerThread = this.readerThread;\n+\n+        if (connectRetryJob != null) {\n+            connectRetryJob.cancel(true);\n+        }\n+        if (keepAlive != null) {\n+            keepAlive.cancel(true);\n+        }\n+\n+        // May be called from keepAliveReconnect thread, so call cancel with false\n+        reconnectTaskCancel(false);\n+\n+        if (senderThread != null && senderThread.isAlive()) {\n+            senderThread.interrupt();\n+        }\n+        if (readerThread != null && readerThread.isAlive()) {\n+            readerThread.interrupt();\n+        }\n+        if (sslsocket != null) {\n+            try {\n+                sslsocket.close();\n+            } catch (IOException e) {\n+                logger.debug(\"Error closing SSL socket: {}\", e.getMessage());\n+            }\n+            sslsocket = null;\n+        }\n+        if (reader != null) {\n+            try {\n+                reader.close();\n+            } catch (IOException e) {\n+                logger.debug(\"Error closing reader: {}\", e.getMessage());\n+            }\n+        }\n+        if (writer != null) {\n+            try {\n+                writer.close();\n+            } catch (IOException e) {\n+                logger.debug(\"Error closing writer: {}\", e.getMessage());\n+            }\n+        }\n+\n+        deviceDataLoaded.set(false);\n+        buttonDataLoaded.set(false);\n+    }\n+\n+    private synchronized void reconnect() {\n+        logger.debug(\"Attempting to reconnect to the bridge\");\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"reconnecting\");\n+        disconnect();\n+        connect();\n+    }\n+\n+    /**\n+     * Method executed by the message sender thread (senderThread)\n+     */\n+    private void senderThreadJob() {\n+        logger.debug(\"Command sender thread started\");\n+        try {\n+            while (!Thread.currentThread().isInterrupted() && writer != null) {\n+                LeapCommand command = sendQueue.take();\n+                logger.trace(\"Sending command {}\", command);\n+\n+                try {\n+                    BufferedWriter writer = this.writer;\n+                    if (writer != null) {\n+                        writer.write(command.toString() + \"\\n\");\n+                        writer.flush();\n+                    }\n+                } catch (IOException e) {\n+                    logger.warn(\"Communication error, will try to reconnect. Error: {}\", e.getMessage());\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR);\n+                    sendQueue.add(command); // Requeue command\n+                    reconnect();\n+                    break; // reconnect() will start a new thread; terminate this one\n+                }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY5NDE5OA=="}, "originalCommit": {"oid": "deb48c1252ee18917f2f9e19cf0158fedb164659"}, "originalPosition": 394}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE4NTY1Ng==", "bodyText": "Done", "url": "https://github.com/openhab/openhab-addons/pull/8650#discussion_r502185656", "createdAt": "2020-10-09T04:41:07Z", "author": {"login": "bobadair"}, "path": "bundles/org.openhab.binding.lutron/src/main/java/org/openhab/binding/lutron/internal/handler/LeapBridgeHandler.java", "diffHunk": "@@ -0,0 +1,763 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lutron.internal.handler;\n+\n+import static org.openhab.binding.lutron.internal.LutronBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.net.UnknownHostException;\n+import java.security.KeyManagementException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.UnrecoverableKeyException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManager;\n+import javax.net.ssl.TrustManagerFactory;\n+import javax.net.ssl.X509TrustManager;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.lutron.internal.config.LeapBridgeConfig;\n+import org.openhab.binding.lutron.internal.discovery.LeapDeviceDiscoveryService;\n+import org.openhab.binding.lutron.internal.protocol.FanSpeedType;\n+import org.openhab.binding.lutron.internal.protocol.GroupCommand;\n+import org.openhab.binding.lutron.internal.protocol.LutronCommandNew;\n+import org.openhab.binding.lutron.internal.protocol.OutputCommand;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapCommand;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapMessageParser;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapMessageParserCallbacks;\n+import org.openhab.binding.lutron.internal.protocol.leap.Request;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Area;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ButtonGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Device;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.OccupancyGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ZoneStatus;\n+import org.openhab.binding.lutron.internal.protocol.lip.LutronCommandType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Bridge handler responsible for communicating with Lutron hubs that support the LEAP protocol, such as Caseta and\n+ * RA2 Select.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LeapBridgeHandler extends LutronBridgeHandler implements LeapMessageParserCallbacks {\n+    private static final int DEFAULT_RECONNECT_MINUTES = 5;\n+    private static final int DEFAULT_HEARTBEAT_MINUTES = 5;\n+    private static final long KEEPALIVE_TIMEOUT_SECONDS = 30;\n+\n+    private static final String STATUS_INITIALIZING = \"Initializing\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(LeapBridgeHandler.class);\n+\n+    private @NonNullByDefault({}) LeapBridgeConfig config;\n+    private int reconnectInterval;\n+    private int heartbeatInterval;\n+    private int sendDelay;\n+\n+    private @NonNullByDefault({}) SSLSocketFactory sslsocketfactory;\n+    private @Nullable SSLSocket sslsocket;\n+    private @Nullable BufferedWriter writer;\n+    private @Nullable BufferedReader reader;\n+\n+    private @NonNullByDefault({}) LeapMessageParser leapMessageParser;\n+\n+    private final BlockingQueue<LeapCommand> sendQueue = new LinkedBlockingQueue<>();\n+\n+    private @Nullable Thread senderThread;\n+    private @Nullable Thread readerThread;\n+\n+    private @Nullable ScheduledFuture<?> keepAlive;\n+    private @Nullable ScheduledFuture<?> keepAliveReconnect;\n+    private @Nullable ScheduledFuture<?> connectRetryJob;\n+    private final Object keepAliveReconnectLock = new Object();\n+\n+    private final Map<Integer, Integer> zoneToDevice = new HashMap<>();\n+    private final Map<Integer, Integer> deviceToZone = new HashMap<>();\n+    private final Object zoneMapsLock = new Object();\n+\n+    private @Nullable Map<Integer, List<Integer>> deviceButtonMap;\n+    private final Object deviceButtonMapLock = new Object();\n+\n+    private final AtomicBoolean deviceDataLoaded = new AtomicBoolean(false);\n+    private final AtomicBoolean buttonDataLoaded = new AtomicBoolean(false);\n+\n+    private final Map<Integer, LutronHandler> childHandlerMap = new ConcurrentHashMap<>();\n+    private final Map<Integer, OGroupHandler> groupHandlerMap = new ConcurrentHashMap<>();\n+\n+    private @Nullable LeapDeviceDiscoveryService discoveryService;\n+\n+    public void setDiscoveryService(LeapDeviceDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    public LeapBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+        leapMessageParser = new LeapMessageParser(this);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        SSLContext sslContext;\n+\n+        childHandlerMap.clear();\n+        groupHandlerMap.clear();\n+\n+        config = getConfigAs(LeapBridgeConfig.class);\n+        String keystorePassword = (config.keystorePassword == null) ? \"\" : config.keystorePassword;\n+\n+        String ipAddress = config.ipAddress;\n+        if (ipAddress == null || ipAddress.isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"bridge address not specified\");\n+            return;\n+        }\n+\n+        reconnectInterval = (config.reconnect > 0) ? config.reconnect : DEFAULT_RECONNECT_MINUTES;\n+        heartbeatInterval = (config.heartbeat > 0) ? config.heartbeat : DEFAULT_HEARTBEAT_MINUTES;\n+        sendDelay = (config.delay < 0) ? 0 : config.delay;\n+\n+        if (config.keystore == null || keystorePassword == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Keystore/keystore password not configured\");\n+            return;\n+        } else {\n+            try (FileInputStream keystoreInputStream = new FileInputStream(config.keystore)) {\n+                logger.trace(\"Initializing keystore\");\n+                KeyStore keystore = KeyStore.getInstance(KeyStore.getDefaultType());\n+\n+                keystore.load(keystoreInputStream, keystorePassword.toCharArray());\n+\n+                logger.trace(\"Initializing SSL Context\");\n+                KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n+                kmf.init(keystore, keystorePassword.toCharArray());\n+\n+                TrustManager[] trustManagers;\n+                if (config.certValidate) {\n+                    // Use default trust manager which will attempt to validate server certificate from hub\n+                    TrustManagerFactory tmf = TrustManagerFactory\n+                            .getInstance(TrustManagerFactory.getDefaultAlgorithm());\n+                    tmf.init(keystore);\n+                    trustManagers = tmf.getTrustManagers();\n+                } else {\n+                    // Use no-op trust manager which will not verify certificates\n+                    trustManagers = defineNoOpTrustManager();\n+                }\n+\n+                sslContext = SSLContext.getInstance(\"TLS\");\n+                sslContext.init(kmf.getKeyManagers(), trustManagers, null);\n+\n+                sslsocketfactory = sslContext.getSocketFactory();\n+            } catch (FileNotFoundException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Keystore file not found\");\n+                return;\n+            } catch (CertificateException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Certificate exception\");\n+                return;\n+            } catch (UnrecoverableKeyException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"Key unrecoverable with supplied password\");\n+                return;\n+            } catch (KeyManagementException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Key management exception\");\n+                logger.debug(\"Key management exception\", e);\n+                return;\n+            } catch (KeyStoreException | NoSuchAlgorithmException | IOException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Error initializing keystore\");\n+                logger.debug(\"Error initializing keystore\", e);\n+                return;\n+            }\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Connecting\");\n+        scheduler.submit(this::connect); // start the async connect task\n+    }\n+\n+    /**\n+     * Return a no-op SSL trust manager which will not verify server or client certificates.\n+     */\n+    private TrustManager[] defineNoOpTrustManager() {\n+        return new TrustManager[] { new X509TrustManager() {\n+            @Override\n+            public void checkClientTrusted(final X509Certificate @Nullable [] chain, final @Nullable String authType) {\n+                logger.debug(\"Assuming client certificate is valid\");\n+                if (chain != null) {\n+                    for (int cert = 0; cert < chain.length; cert++) {\n+                        logger.trace(\"Subject DN: {}\", chain[cert].getSubjectDN());\n+                        logger.trace(\"Issuer DN: {}\", chain[cert].getIssuerDN());\n+                        logger.trace(\"Serial number {}:\", chain[cert].getSerialNumber());\n+                    }\n+                }\n+            }\n+\n+            @Override\n+            public void checkServerTrusted(final X509Certificate @Nullable [] chain, final @Nullable String authType) {\n+                logger.debug(\"Assuming server certificate is valid\");\n+                if (chain != null) {\n+                    for (int cert = 0; cert < chain.length; cert++) {\n+                        logger.trace(\"Subject DN: {}\", chain[cert].getSubjectDN());\n+                        logger.trace(\"Issuer DN: {}\", chain[cert].getIssuerDN());\n+                        logger.trace(\"Serial number: {}\", chain[cert].getSerialNumber());\n+                    }\n+                }\n+            }\n+\n+            @Override\n+            public X509Certificate @Nullable [] getAcceptedIssuers() {\n+                return null;\n+            }\n+        } };\n+    }\n+\n+    private synchronized void connect() {\n+        deviceDataLoaded.set(false);\n+        buttonDataLoaded.set(false);\n+\n+        try {\n+            logger.debug(\"Opening SSL connection to {}:{}\", config.ipAddress, config.port);\n+            SSLSocket sslsocket = (SSLSocket) sslsocketfactory.createSocket(config.ipAddress, config.port);\n+            sslsocket.startHandshake();\n+            writer = new BufferedWriter(new OutputStreamWriter(sslsocket.getOutputStream()));\n+            reader = new BufferedReader(new InputStreamReader(sslsocket.getInputStream()));\n+            this.sslsocket = sslsocket;\n+        } catch (UnknownHostException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Unknown host\");\n+            return;\n+        } catch (IllegalArgumentException e) {\n+            // port out of valid range\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Invalid port number\");\n+            return;\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Error opening SSL connection. Check log.\");\n+            logger.info(\"Error opening SSL connection: {}\", e.getMessage());\n+            disconnect();\n+            scheduleConnectRetry(reconnectInterval); // Possibly a temporary problem. Try again later.\n+            return;\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, STATUS_INITIALIZING);\n+\n+        Thread readerThread = new Thread(this::readerThreadJob, \"Lutron reader\");\n+        readerThread.setDaemon(true);\n+        readerThread.start();\n+        this.readerThread = readerThread;\n+\n+        Thread senderThread = new Thread(this::senderThreadJob, \"Lutron sender\");\n+        senderThread.setDaemon(true);\n+        senderThread.start();\n+        this.senderThread = senderThread;\n+\n+        sendCommand(new LeapCommand(Request.getButtonGroups()));\n+        queryDiscoveryData();\n+        sendCommand(new LeapCommand(Request.subscribeOccupancyGroupStatus()));\n+\n+        logger.debug(\"Starting keepAlive job with interval {}\", heartbeatInterval);\n+        keepAlive = scheduler.scheduleWithFixedDelay(this::sendKeepAlive, heartbeatInterval, heartbeatInterval,\n+                TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Called by connect() and discovery service to request fresh discovery data\n+     */\n+    public void queryDiscoveryData() {\n+        sendCommand(new LeapCommand(Request.getDevices()));\n+        sendCommand(new LeapCommand(Request.getAreas()));\n+        sendCommand(new LeapCommand(Request.getOccupancyGroups()));\n+    }\n+\n+    private void scheduleConnectRetry(long waitMinutes) {\n+        logger.debug(\"Scheduling connection retry in {} minutes\", waitMinutes);\n+        connectRetryJob = scheduler.schedule(this::connect, waitMinutes, TimeUnit.MINUTES);\n+    }\n+\n+    private synchronized void disconnect() {\n+        logger.debug(\"Disconnecting\");\n+\n+        Thread senderThread = this.senderThread;\n+        Thread readerThread = this.readerThread;\n+\n+        if (connectRetryJob != null) {\n+            connectRetryJob.cancel(true);\n+        }\n+        if (keepAlive != null) {\n+            keepAlive.cancel(true);\n+        }\n+\n+        // May be called from keepAliveReconnect thread, so call cancel with false\n+        reconnectTaskCancel(false);\n+\n+        if (senderThread != null && senderThread.isAlive()) {\n+            senderThread.interrupt();\n+        }\n+        if (readerThread != null && readerThread.isAlive()) {\n+            readerThread.interrupt();\n+        }\n+        if (sslsocket != null) {\n+            try {\n+                sslsocket.close();\n+            } catch (IOException e) {\n+                logger.debug(\"Error closing SSL socket: {}\", e.getMessage());\n+            }\n+            sslsocket = null;\n+        }\n+        if (reader != null) {\n+            try {\n+                reader.close();\n+            } catch (IOException e) {\n+                logger.debug(\"Error closing reader: {}\", e.getMessage());\n+            }\n+        }\n+        if (writer != null) {\n+            try {\n+                writer.close();\n+            } catch (IOException e) {\n+                logger.debug(\"Error closing writer: {}\", e.getMessage());\n+            }\n+        }\n+\n+        deviceDataLoaded.set(false);\n+        buttonDataLoaded.set(false);\n+    }\n+\n+    private synchronized void reconnect() {\n+        logger.debug(\"Attempting to reconnect to the bridge\");\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"reconnecting\");\n+        disconnect();\n+        connect();\n+    }\n+\n+    /**\n+     * Method executed by the message sender thread (senderThread)\n+     */\n+    private void senderThreadJob() {\n+        logger.debug(\"Command sender thread started\");\n+        try {\n+            while (!Thread.currentThread().isInterrupted() && writer != null) {\n+                LeapCommand command = sendQueue.take();\n+                logger.trace(\"Sending command {}\", command);\n+\n+                try {\n+                    BufferedWriter writer = this.writer;\n+                    if (writer != null) {\n+                        writer.write(command.toString() + \"\\n\");\n+                        writer.flush();\n+                    }\n+                } catch (IOException e) {\n+                    logger.warn(\"Communication error, will try to reconnect. Error: {}\", e.getMessage());\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR);\n+                    sendQueue.add(command); // Requeue command\n+                    reconnect();\n+                    break; // reconnect() will start a new thread; terminate this one\n+                }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY5NDE5OA=="}, "originalCommit": {"oid": "deb48c1252ee18917f2f9e19cf0158fedb164659"}, "originalPosition": 394}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNTA3ODczOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.lutron/src/main/java/org/openhab/binding/lutron/internal/handler/LeapBridgeHandler.java", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwMjowODowN1rOHdgCZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQwNDo1MzowMFrOHe7JNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY5NTY1Mw==", "bodyText": "In order to avoid the null checker warnings cache this.sslsocket to a local variable and perform your logic on that local variable instead.", "url": "https://github.com/openhab/openhab-addons/pull/8650#discussion_r500695653", "createdAt": "2020-10-07T02:08:07Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lutron/src/main/java/org/openhab/binding/lutron/internal/handler/LeapBridgeHandler.java", "diffHunk": "@@ -0,0 +1,763 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lutron.internal.handler;\n+\n+import static org.openhab.binding.lutron.internal.LutronBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.net.UnknownHostException;\n+import java.security.KeyManagementException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.UnrecoverableKeyException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManager;\n+import javax.net.ssl.TrustManagerFactory;\n+import javax.net.ssl.X509TrustManager;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.lutron.internal.config.LeapBridgeConfig;\n+import org.openhab.binding.lutron.internal.discovery.LeapDeviceDiscoveryService;\n+import org.openhab.binding.lutron.internal.protocol.FanSpeedType;\n+import org.openhab.binding.lutron.internal.protocol.GroupCommand;\n+import org.openhab.binding.lutron.internal.protocol.LutronCommandNew;\n+import org.openhab.binding.lutron.internal.protocol.OutputCommand;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapCommand;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapMessageParser;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapMessageParserCallbacks;\n+import org.openhab.binding.lutron.internal.protocol.leap.Request;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Area;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ButtonGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Device;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.OccupancyGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ZoneStatus;\n+import org.openhab.binding.lutron.internal.protocol.lip.LutronCommandType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Bridge handler responsible for communicating with Lutron hubs that support the LEAP protocol, such as Caseta and\n+ * RA2 Select.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LeapBridgeHandler extends LutronBridgeHandler implements LeapMessageParserCallbacks {\n+    private static final int DEFAULT_RECONNECT_MINUTES = 5;\n+    private static final int DEFAULT_HEARTBEAT_MINUTES = 5;\n+    private static final long KEEPALIVE_TIMEOUT_SECONDS = 30;\n+\n+    private static final String STATUS_INITIALIZING = \"Initializing\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(LeapBridgeHandler.class);\n+\n+    private @NonNullByDefault({}) LeapBridgeConfig config;\n+    private int reconnectInterval;\n+    private int heartbeatInterval;\n+    private int sendDelay;\n+\n+    private @NonNullByDefault({}) SSLSocketFactory sslsocketfactory;\n+    private @Nullable SSLSocket sslsocket;\n+    private @Nullable BufferedWriter writer;\n+    private @Nullable BufferedReader reader;\n+\n+    private @NonNullByDefault({}) LeapMessageParser leapMessageParser;\n+\n+    private final BlockingQueue<LeapCommand> sendQueue = new LinkedBlockingQueue<>();\n+\n+    private @Nullable Thread senderThread;\n+    private @Nullable Thread readerThread;\n+\n+    private @Nullable ScheduledFuture<?> keepAlive;\n+    private @Nullable ScheduledFuture<?> keepAliveReconnect;\n+    private @Nullable ScheduledFuture<?> connectRetryJob;\n+    private final Object keepAliveReconnectLock = new Object();\n+\n+    private final Map<Integer, Integer> zoneToDevice = new HashMap<>();\n+    private final Map<Integer, Integer> deviceToZone = new HashMap<>();\n+    private final Object zoneMapsLock = new Object();\n+\n+    private @Nullable Map<Integer, List<Integer>> deviceButtonMap;\n+    private final Object deviceButtonMapLock = new Object();\n+\n+    private final AtomicBoolean deviceDataLoaded = new AtomicBoolean(false);\n+    private final AtomicBoolean buttonDataLoaded = new AtomicBoolean(false);\n+\n+    private final Map<Integer, LutronHandler> childHandlerMap = new ConcurrentHashMap<>();\n+    private final Map<Integer, OGroupHandler> groupHandlerMap = new ConcurrentHashMap<>();\n+\n+    private @Nullable LeapDeviceDiscoveryService discoveryService;\n+\n+    public void setDiscoveryService(LeapDeviceDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    public LeapBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+        leapMessageParser = new LeapMessageParser(this);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        SSLContext sslContext;\n+\n+        childHandlerMap.clear();\n+        groupHandlerMap.clear();\n+\n+        config = getConfigAs(LeapBridgeConfig.class);\n+        String keystorePassword = (config.keystorePassword == null) ? \"\" : config.keystorePassword;\n+\n+        String ipAddress = config.ipAddress;\n+        if (ipAddress == null || ipAddress.isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"bridge address not specified\");\n+            return;\n+        }\n+\n+        reconnectInterval = (config.reconnect > 0) ? config.reconnect : DEFAULT_RECONNECT_MINUTES;\n+        heartbeatInterval = (config.heartbeat > 0) ? config.heartbeat : DEFAULT_HEARTBEAT_MINUTES;\n+        sendDelay = (config.delay < 0) ? 0 : config.delay;\n+\n+        if (config.keystore == null || keystorePassword == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Keystore/keystore password not configured\");\n+            return;\n+        } else {\n+            try (FileInputStream keystoreInputStream = new FileInputStream(config.keystore)) {\n+                logger.trace(\"Initializing keystore\");\n+                KeyStore keystore = KeyStore.getInstance(KeyStore.getDefaultType());\n+\n+                keystore.load(keystoreInputStream, keystorePassword.toCharArray());\n+\n+                logger.trace(\"Initializing SSL Context\");\n+                KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n+                kmf.init(keystore, keystorePassword.toCharArray());\n+\n+                TrustManager[] trustManagers;\n+                if (config.certValidate) {\n+                    // Use default trust manager which will attempt to validate server certificate from hub\n+                    TrustManagerFactory tmf = TrustManagerFactory\n+                            .getInstance(TrustManagerFactory.getDefaultAlgorithm());\n+                    tmf.init(keystore);\n+                    trustManagers = tmf.getTrustManagers();\n+                } else {\n+                    // Use no-op trust manager which will not verify certificates\n+                    trustManagers = defineNoOpTrustManager();\n+                }\n+\n+                sslContext = SSLContext.getInstance(\"TLS\");\n+                sslContext.init(kmf.getKeyManagers(), trustManagers, null);\n+\n+                sslsocketfactory = sslContext.getSocketFactory();\n+            } catch (FileNotFoundException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Keystore file not found\");\n+                return;\n+            } catch (CertificateException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Certificate exception\");\n+                return;\n+            } catch (UnrecoverableKeyException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"Key unrecoverable with supplied password\");\n+                return;\n+            } catch (KeyManagementException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Key management exception\");\n+                logger.debug(\"Key management exception\", e);\n+                return;\n+            } catch (KeyStoreException | NoSuchAlgorithmException | IOException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Error initializing keystore\");\n+                logger.debug(\"Error initializing keystore\", e);\n+                return;\n+            }\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Connecting\");\n+        scheduler.submit(this::connect); // start the async connect task\n+    }\n+\n+    /**\n+     * Return a no-op SSL trust manager which will not verify server or client certificates.\n+     */\n+    private TrustManager[] defineNoOpTrustManager() {\n+        return new TrustManager[] { new X509TrustManager() {\n+            @Override\n+            public void checkClientTrusted(final X509Certificate @Nullable [] chain, final @Nullable String authType) {\n+                logger.debug(\"Assuming client certificate is valid\");\n+                if (chain != null) {\n+                    for (int cert = 0; cert < chain.length; cert++) {\n+                        logger.trace(\"Subject DN: {}\", chain[cert].getSubjectDN());\n+                        logger.trace(\"Issuer DN: {}\", chain[cert].getIssuerDN());\n+                        logger.trace(\"Serial number {}:\", chain[cert].getSerialNumber());\n+                    }\n+                }\n+            }\n+\n+            @Override\n+            public void checkServerTrusted(final X509Certificate @Nullable [] chain, final @Nullable String authType) {\n+                logger.debug(\"Assuming server certificate is valid\");\n+                if (chain != null) {\n+                    for (int cert = 0; cert < chain.length; cert++) {\n+                        logger.trace(\"Subject DN: {}\", chain[cert].getSubjectDN());\n+                        logger.trace(\"Issuer DN: {}\", chain[cert].getIssuerDN());\n+                        logger.trace(\"Serial number: {}\", chain[cert].getSerialNumber());\n+                    }\n+                }\n+            }\n+\n+            @Override\n+            public X509Certificate @Nullable [] getAcceptedIssuers() {\n+                return null;\n+            }\n+        } };\n+    }\n+\n+    private synchronized void connect() {\n+        deviceDataLoaded.set(false);\n+        buttonDataLoaded.set(false);\n+\n+        try {\n+            logger.debug(\"Opening SSL connection to {}:{}\", config.ipAddress, config.port);\n+            SSLSocket sslsocket = (SSLSocket) sslsocketfactory.createSocket(config.ipAddress, config.port);\n+            sslsocket.startHandshake();\n+            writer = new BufferedWriter(new OutputStreamWriter(sslsocket.getOutputStream()));\n+            reader = new BufferedReader(new InputStreamReader(sslsocket.getInputStream()));\n+            this.sslsocket = sslsocket;\n+        } catch (UnknownHostException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Unknown host\");\n+            return;\n+        } catch (IllegalArgumentException e) {\n+            // port out of valid range\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Invalid port number\");\n+            return;\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Error opening SSL connection. Check log.\");\n+            logger.info(\"Error opening SSL connection: {}\", e.getMessage());\n+            disconnect();\n+            scheduleConnectRetry(reconnectInterval); // Possibly a temporary problem. Try again later.\n+            return;\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, STATUS_INITIALIZING);\n+\n+        Thread readerThread = new Thread(this::readerThreadJob, \"Lutron reader\");\n+        readerThread.setDaemon(true);\n+        readerThread.start();\n+        this.readerThread = readerThread;\n+\n+        Thread senderThread = new Thread(this::senderThreadJob, \"Lutron sender\");\n+        senderThread.setDaemon(true);\n+        senderThread.start();\n+        this.senderThread = senderThread;\n+\n+        sendCommand(new LeapCommand(Request.getButtonGroups()));\n+        queryDiscoveryData();\n+        sendCommand(new LeapCommand(Request.subscribeOccupancyGroupStatus()));\n+\n+        logger.debug(\"Starting keepAlive job with interval {}\", heartbeatInterval);\n+        keepAlive = scheduler.scheduleWithFixedDelay(this::sendKeepAlive, heartbeatInterval, heartbeatInterval,\n+                TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Called by connect() and discovery service to request fresh discovery data\n+     */\n+    public void queryDiscoveryData() {\n+        sendCommand(new LeapCommand(Request.getDevices()));\n+        sendCommand(new LeapCommand(Request.getAreas()));\n+        sendCommand(new LeapCommand(Request.getOccupancyGroups()));\n+    }\n+\n+    private void scheduleConnectRetry(long waitMinutes) {\n+        logger.debug(\"Scheduling connection retry in {} minutes\", waitMinutes);\n+        connectRetryJob = scheduler.schedule(this::connect, waitMinutes, TimeUnit.MINUTES);\n+    }\n+\n+    private synchronized void disconnect() {\n+        logger.debug(\"Disconnecting\");\n+\n+        Thread senderThread = this.senderThread;\n+        Thread readerThread = this.readerThread;\n+\n+        if (connectRetryJob != null) {\n+            connectRetryJob.cancel(true);\n+        }\n+        if (keepAlive != null) {\n+            keepAlive.cancel(true);\n+        }\n+\n+        // May be called from keepAliveReconnect thread, so call cancel with false\n+        reconnectTaskCancel(false);\n+\n+        if (senderThread != null && senderThread.isAlive()) {\n+            senderThread.interrupt();\n+        }\n+        if (readerThread != null && readerThread.isAlive()) {\n+            readerThread.interrupt();\n+        }\n+        if (sslsocket != null) {\n+            try {\n+                sslsocket.close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "deb48c1252ee18917f2f9e19cf0158fedb164659"}, "originalPosition": 340}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTE4MjI3NA==", "bodyText": "None of these four null checker warnings were showing up in Eclipse.", "url": "https://github.com/openhab/openhab-addons/pull/8650#discussion_r501182274", "createdAt": "2020-10-07T17:20:47Z", "author": {"login": "bobadair"}, "path": "bundles/org.openhab.binding.lutron/src/main/java/org/openhab/binding/lutron/internal/handler/LeapBridgeHandler.java", "diffHunk": "@@ -0,0 +1,763 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lutron.internal.handler;\n+\n+import static org.openhab.binding.lutron.internal.LutronBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.net.UnknownHostException;\n+import java.security.KeyManagementException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.UnrecoverableKeyException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManager;\n+import javax.net.ssl.TrustManagerFactory;\n+import javax.net.ssl.X509TrustManager;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.lutron.internal.config.LeapBridgeConfig;\n+import org.openhab.binding.lutron.internal.discovery.LeapDeviceDiscoveryService;\n+import org.openhab.binding.lutron.internal.protocol.FanSpeedType;\n+import org.openhab.binding.lutron.internal.protocol.GroupCommand;\n+import org.openhab.binding.lutron.internal.protocol.LutronCommandNew;\n+import org.openhab.binding.lutron.internal.protocol.OutputCommand;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapCommand;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapMessageParser;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapMessageParserCallbacks;\n+import org.openhab.binding.lutron.internal.protocol.leap.Request;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Area;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ButtonGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Device;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.OccupancyGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ZoneStatus;\n+import org.openhab.binding.lutron.internal.protocol.lip.LutronCommandType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Bridge handler responsible for communicating with Lutron hubs that support the LEAP protocol, such as Caseta and\n+ * RA2 Select.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LeapBridgeHandler extends LutronBridgeHandler implements LeapMessageParserCallbacks {\n+    private static final int DEFAULT_RECONNECT_MINUTES = 5;\n+    private static final int DEFAULT_HEARTBEAT_MINUTES = 5;\n+    private static final long KEEPALIVE_TIMEOUT_SECONDS = 30;\n+\n+    private static final String STATUS_INITIALIZING = \"Initializing\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(LeapBridgeHandler.class);\n+\n+    private @NonNullByDefault({}) LeapBridgeConfig config;\n+    private int reconnectInterval;\n+    private int heartbeatInterval;\n+    private int sendDelay;\n+\n+    private @NonNullByDefault({}) SSLSocketFactory sslsocketfactory;\n+    private @Nullable SSLSocket sslsocket;\n+    private @Nullable BufferedWriter writer;\n+    private @Nullable BufferedReader reader;\n+\n+    private @NonNullByDefault({}) LeapMessageParser leapMessageParser;\n+\n+    private final BlockingQueue<LeapCommand> sendQueue = new LinkedBlockingQueue<>();\n+\n+    private @Nullable Thread senderThread;\n+    private @Nullable Thread readerThread;\n+\n+    private @Nullable ScheduledFuture<?> keepAlive;\n+    private @Nullable ScheduledFuture<?> keepAliveReconnect;\n+    private @Nullable ScheduledFuture<?> connectRetryJob;\n+    private final Object keepAliveReconnectLock = new Object();\n+\n+    private final Map<Integer, Integer> zoneToDevice = new HashMap<>();\n+    private final Map<Integer, Integer> deviceToZone = new HashMap<>();\n+    private final Object zoneMapsLock = new Object();\n+\n+    private @Nullable Map<Integer, List<Integer>> deviceButtonMap;\n+    private final Object deviceButtonMapLock = new Object();\n+\n+    private final AtomicBoolean deviceDataLoaded = new AtomicBoolean(false);\n+    private final AtomicBoolean buttonDataLoaded = new AtomicBoolean(false);\n+\n+    private final Map<Integer, LutronHandler> childHandlerMap = new ConcurrentHashMap<>();\n+    private final Map<Integer, OGroupHandler> groupHandlerMap = new ConcurrentHashMap<>();\n+\n+    private @Nullable LeapDeviceDiscoveryService discoveryService;\n+\n+    public void setDiscoveryService(LeapDeviceDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    public LeapBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+        leapMessageParser = new LeapMessageParser(this);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        SSLContext sslContext;\n+\n+        childHandlerMap.clear();\n+        groupHandlerMap.clear();\n+\n+        config = getConfigAs(LeapBridgeConfig.class);\n+        String keystorePassword = (config.keystorePassword == null) ? \"\" : config.keystorePassword;\n+\n+        String ipAddress = config.ipAddress;\n+        if (ipAddress == null || ipAddress.isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"bridge address not specified\");\n+            return;\n+        }\n+\n+        reconnectInterval = (config.reconnect > 0) ? config.reconnect : DEFAULT_RECONNECT_MINUTES;\n+        heartbeatInterval = (config.heartbeat > 0) ? config.heartbeat : DEFAULT_HEARTBEAT_MINUTES;\n+        sendDelay = (config.delay < 0) ? 0 : config.delay;\n+\n+        if (config.keystore == null || keystorePassword == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Keystore/keystore password not configured\");\n+            return;\n+        } else {\n+            try (FileInputStream keystoreInputStream = new FileInputStream(config.keystore)) {\n+                logger.trace(\"Initializing keystore\");\n+                KeyStore keystore = KeyStore.getInstance(KeyStore.getDefaultType());\n+\n+                keystore.load(keystoreInputStream, keystorePassword.toCharArray());\n+\n+                logger.trace(\"Initializing SSL Context\");\n+                KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n+                kmf.init(keystore, keystorePassword.toCharArray());\n+\n+                TrustManager[] trustManagers;\n+                if (config.certValidate) {\n+                    // Use default trust manager which will attempt to validate server certificate from hub\n+                    TrustManagerFactory tmf = TrustManagerFactory\n+                            .getInstance(TrustManagerFactory.getDefaultAlgorithm());\n+                    tmf.init(keystore);\n+                    trustManagers = tmf.getTrustManagers();\n+                } else {\n+                    // Use no-op trust manager which will not verify certificates\n+                    trustManagers = defineNoOpTrustManager();\n+                }\n+\n+                sslContext = SSLContext.getInstance(\"TLS\");\n+                sslContext.init(kmf.getKeyManagers(), trustManagers, null);\n+\n+                sslsocketfactory = sslContext.getSocketFactory();\n+            } catch (FileNotFoundException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Keystore file not found\");\n+                return;\n+            } catch (CertificateException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Certificate exception\");\n+                return;\n+            } catch (UnrecoverableKeyException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"Key unrecoverable with supplied password\");\n+                return;\n+            } catch (KeyManagementException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Key management exception\");\n+                logger.debug(\"Key management exception\", e);\n+                return;\n+            } catch (KeyStoreException | NoSuchAlgorithmException | IOException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Error initializing keystore\");\n+                logger.debug(\"Error initializing keystore\", e);\n+                return;\n+            }\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Connecting\");\n+        scheduler.submit(this::connect); // start the async connect task\n+    }\n+\n+    /**\n+     * Return a no-op SSL trust manager which will not verify server or client certificates.\n+     */\n+    private TrustManager[] defineNoOpTrustManager() {\n+        return new TrustManager[] { new X509TrustManager() {\n+            @Override\n+            public void checkClientTrusted(final X509Certificate @Nullable [] chain, final @Nullable String authType) {\n+                logger.debug(\"Assuming client certificate is valid\");\n+                if (chain != null) {\n+                    for (int cert = 0; cert < chain.length; cert++) {\n+                        logger.trace(\"Subject DN: {}\", chain[cert].getSubjectDN());\n+                        logger.trace(\"Issuer DN: {}\", chain[cert].getIssuerDN());\n+                        logger.trace(\"Serial number {}:\", chain[cert].getSerialNumber());\n+                    }\n+                }\n+            }\n+\n+            @Override\n+            public void checkServerTrusted(final X509Certificate @Nullable [] chain, final @Nullable String authType) {\n+                logger.debug(\"Assuming server certificate is valid\");\n+                if (chain != null) {\n+                    for (int cert = 0; cert < chain.length; cert++) {\n+                        logger.trace(\"Subject DN: {}\", chain[cert].getSubjectDN());\n+                        logger.trace(\"Issuer DN: {}\", chain[cert].getIssuerDN());\n+                        logger.trace(\"Serial number: {}\", chain[cert].getSerialNumber());\n+                    }\n+                }\n+            }\n+\n+            @Override\n+            public X509Certificate @Nullable [] getAcceptedIssuers() {\n+                return null;\n+            }\n+        } };\n+    }\n+\n+    private synchronized void connect() {\n+        deviceDataLoaded.set(false);\n+        buttonDataLoaded.set(false);\n+\n+        try {\n+            logger.debug(\"Opening SSL connection to {}:{}\", config.ipAddress, config.port);\n+            SSLSocket sslsocket = (SSLSocket) sslsocketfactory.createSocket(config.ipAddress, config.port);\n+            sslsocket.startHandshake();\n+            writer = new BufferedWriter(new OutputStreamWriter(sslsocket.getOutputStream()));\n+            reader = new BufferedReader(new InputStreamReader(sslsocket.getInputStream()));\n+            this.sslsocket = sslsocket;\n+        } catch (UnknownHostException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Unknown host\");\n+            return;\n+        } catch (IllegalArgumentException e) {\n+            // port out of valid range\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Invalid port number\");\n+            return;\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Error opening SSL connection. Check log.\");\n+            logger.info(\"Error opening SSL connection: {}\", e.getMessage());\n+            disconnect();\n+            scheduleConnectRetry(reconnectInterval); // Possibly a temporary problem. Try again later.\n+            return;\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, STATUS_INITIALIZING);\n+\n+        Thread readerThread = new Thread(this::readerThreadJob, \"Lutron reader\");\n+        readerThread.setDaemon(true);\n+        readerThread.start();\n+        this.readerThread = readerThread;\n+\n+        Thread senderThread = new Thread(this::senderThreadJob, \"Lutron sender\");\n+        senderThread.setDaemon(true);\n+        senderThread.start();\n+        this.senderThread = senderThread;\n+\n+        sendCommand(new LeapCommand(Request.getButtonGroups()));\n+        queryDiscoveryData();\n+        sendCommand(new LeapCommand(Request.subscribeOccupancyGroupStatus()));\n+\n+        logger.debug(\"Starting keepAlive job with interval {}\", heartbeatInterval);\n+        keepAlive = scheduler.scheduleWithFixedDelay(this::sendKeepAlive, heartbeatInterval, heartbeatInterval,\n+                TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Called by connect() and discovery service to request fresh discovery data\n+     */\n+    public void queryDiscoveryData() {\n+        sendCommand(new LeapCommand(Request.getDevices()));\n+        sendCommand(new LeapCommand(Request.getAreas()));\n+        sendCommand(new LeapCommand(Request.getOccupancyGroups()));\n+    }\n+\n+    private void scheduleConnectRetry(long waitMinutes) {\n+        logger.debug(\"Scheduling connection retry in {} minutes\", waitMinutes);\n+        connectRetryJob = scheduler.schedule(this::connect, waitMinutes, TimeUnit.MINUTES);\n+    }\n+\n+    private synchronized void disconnect() {\n+        logger.debug(\"Disconnecting\");\n+\n+        Thread senderThread = this.senderThread;\n+        Thread readerThread = this.readerThread;\n+\n+        if (connectRetryJob != null) {\n+            connectRetryJob.cancel(true);\n+        }\n+        if (keepAlive != null) {\n+            keepAlive.cancel(true);\n+        }\n+\n+        // May be called from keepAliveReconnect thread, so call cancel with false\n+        reconnectTaskCancel(false);\n+\n+        if (senderThread != null && senderThread.isAlive()) {\n+            senderThread.interrupt();\n+        }\n+        if (readerThread != null && readerThread.isAlive()) {\n+            readerThread.interrupt();\n+        }\n+        if (sslsocket != null) {\n+            try {\n+                sslsocket.close();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY5NTY1Mw=="}, "originalCommit": {"oid": "deb48c1252ee18917f2f9e19cf0158fedb164659"}, "originalPosition": 340}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTM1MDkyOQ==", "bodyText": "They might not show up in Eclipse but they do show up in the build console:\n[WARNING] /home/travis/build/openhab/openhab-addons/bundles/org.openhab.binding.lutron/src/main/java/org/openhab/binding/lutron/internal/handler/LeapBridgeHandler.java:[588,13] Potential null pointer access: this expression has a '@Nullable' type\n[WARNING] /home/travis/build/openhab/openhab-addons/bundles/org.openhab.binding.lutron/src/main/java/org/openhab/binding/lutron/internal/handler/LeapBridgeHandler.java:[595,13] Potential null pointer access: this expression has a '@Nullable' type\n[WARNING] /home/travis/build/openhab/openhab-addons/bundles/org.openhab.binding.lutron/src/main/java/org/openhab/binding/lutron/internal/handler/LeapBridgeHandler.java:[602,13] Potential null pointer access: this expression has a '@Nullable' type\n[WARNING] /home/travis/build/openhab/openhab-addons/bundles/org.openhab.binding.lutron/src/main/java/org/openhab/binding/lutron/internal/handler/LeapBridgeHandler.java:[659,44] Potential null pointer access: this expression has a '@Nullable' type\n[WARNING] /home/travis/build/openhab/openhab-addons/bundles/org.openhab.binding.lutron/src/main/java/org/openhab/binding/lutron/internal/handler/LeapBridgeHandler.java:[660,21] Redundant null check: The variable buttonList cannot be null at this location", "url": "https://github.com/openhab/openhab-addons/pull/8650#discussion_r501350929", "createdAt": "2020-10-07T22:41:56Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lutron/src/main/java/org/openhab/binding/lutron/internal/handler/LeapBridgeHandler.java", "diffHunk": "@@ -0,0 +1,763 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lutron.internal.handler;\n+\n+import static org.openhab.binding.lutron.internal.LutronBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.net.UnknownHostException;\n+import java.security.KeyManagementException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.UnrecoverableKeyException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManager;\n+import javax.net.ssl.TrustManagerFactory;\n+import javax.net.ssl.X509TrustManager;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.lutron.internal.config.LeapBridgeConfig;\n+import org.openhab.binding.lutron.internal.discovery.LeapDeviceDiscoveryService;\n+import org.openhab.binding.lutron.internal.protocol.FanSpeedType;\n+import org.openhab.binding.lutron.internal.protocol.GroupCommand;\n+import org.openhab.binding.lutron.internal.protocol.LutronCommandNew;\n+import org.openhab.binding.lutron.internal.protocol.OutputCommand;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapCommand;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapMessageParser;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapMessageParserCallbacks;\n+import org.openhab.binding.lutron.internal.protocol.leap.Request;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Area;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ButtonGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Device;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.OccupancyGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ZoneStatus;\n+import org.openhab.binding.lutron.internal.protocol.lip.LutronCommandType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Bridge handler responsible for communicating with Lutron hubs that support the LEAP protocol, such as Caseta and\n+ * RA2 Select.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LeapBridgeHandler extends LutronBridgeHandler implements LeapMessageParserCallbacks {\n+    private static final int DEFAULT_RECONNECT_MINUTES = 5;\n+    private static final int DEFAULT_HEARTBEAT_MINUTES = 5;\n+    private static final long KEEPALIVE_TIMEOUT_SECONDS = 30;\n+\n+    private static final String STATUS_INITIALIZING = \"Initializing\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(LeapBridgeHandler.class);\n+\n+    private @NonNullByDefault({}) LeapBridgeConfig config;\n+    private int reconnectInterval;\n+    private int heartbeatInterval;\n+    private int sendDelay;\n+\n+    private @NonNullByDefault({}) SSLSocketFactory sslsocketfactory;\n+    private @Nullable SSLSocket sslsocket;\n+    private @Nullable BufferedWriter writer;\n+    private @Nullable BufferedReader reader;\n+\n+    private @NonNullByDefault({}) LeapMessageParser leapMessageParser;\n+\n+    private final BlockingQueue<LeapCommand> sendQueue = new LinkedBlockingQueue<>();\n+\n+    private @Nullable Thread senderThread;\n+    private @Nullable Thread readerThread;\n+\n+    private @Nullable ScheduledFuture<?> keepAlive;\n+    private @Nullable ScheduledFuture<?> keepAliveReconnect;\n+    private @Nullable ScheduledFuture<?> connectRetryJob;\n+    private final Object keepAliveReconnectLock = new Object();\n+\n+    private final Map<Integer, Integer> zoneToDevice = new HashMap<>();\n+    private final Map<Integer, Integer> deviceToZone = new HashMap<>();\n+    private final Object zoneMapsLock = new Object();\n+\n+    private @Nullable Map<Integer, List<Integer>> deviceButtonMap;\n+    private final Object deviceButtonMapLock = new Object();\n+\n+    private final AtomicBoolean deviceDataLoaded = new AtomicBoolean(false);\n+    private final AtomicBoolean buttonDataLoaded = new AtomicBoolean(false);\n+\n+    private final Map<Integer, LutronHandler> childHandlerMap = new ConcurrentHashMap<>();\n+    private final Map<Integer, OGroupHandler> groupHandlerMap = new ConcurrentHashMap<>();\n+\n+    private @Nullable LeapDeviceDiscoveryService discoveryService;\n+\n+    public void setDiscoveryService(LeapDeviceDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    public LeapBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+        leapMessageParser = new LeapMessageParser(this);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        SSLContext sslContext;\n+\n+        childHandlerMap.clear();\n+        groupHandlerMap.clear();\n+\n+        config = getConfigAs(LeapBridgeConfig.class);\n+        String keystorePassword = (config.keystorePassword == null) ? \"\" : config.keystorePassword;\n+\n+        String ipAddress = config.ipAddress;\n+        if (ipAddress == null || ipAddress.isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"bridge address not specified\");\n+            return;\n+        }\n+\n+        reconnectInterval = (config.reconnect > 0) ? config.reconnect : DEFAULT_RECONNECT_MINUTES;\n+        heartbeatInterval = (config.heartbeat > 0) ? config.heartbeat : DEFAULT_HEARTBEAT_MINUTES;\n+        sendDelay = (config.delay < 0) ? 0 : config.delay;\n+\n+        if (config.keystore == null || keystorePassword == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Keystore/keystore password not configured\");\n+            return;\n+        } else {\n+            try (FileInputStream keystoreInputStream = new FileInputStream(config.keystore)) {\n+                logger.trace(\"Initializing keystore\");\n+                KeyStore keystore = KeyStore.getInstance(KeyStore.getDefaultType());\n+\n+                keystore.load(keystoreInputStream, keystorePassword.toCharArray());\n+\n+                logger.trace(\"Initializing SSL Context\");\n+                KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n+                kmf.init(keystore, keystorePassword.toCharArray());\n+\n+                TrustManager[] trustManagers;\n+                if (config.certValidate) {\n+                    // Use default trust manager which will attempt to validate server certificate from hub\n+                    TrustManagerFactory tmf = TrustManagerFactory\n+                            .getInstance(TrustManagerFactory.getDefaultAlgorithm());\n+                    tmf.init(keystore);\n+                    trustManagers = tmf.getTrustManagers();\n+                } else {\n+                    // Use no-op trust manager which will not verify certificates\n+                    trustManagers = defineNoOpTrustManager();\n+                }\n+\n+                sslContext = SSLContext.getInstance(\"TLS\");\n+                sslContext.init(kmf.getKeyManagers(), trustManagers, null);\n+\n+                sslsocketfactory = sslContext.getSocketFactory();\n+            } catch (FileNotFoundException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Keystore file not found\");\n+                return;\n+            } catch (CertificateException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Certificate exception\");\n+                return;\n+            } catch (UnrecoverableKeyException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"Key unrecoverable with supplied password\");\n+                return;\n+            } catch (KeyManagementException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Key management exception\");\n+                logger.debug(\"Key management exception\", e);\n+                return;\n+            } catch (KeyStoreException | NoSuchAlgorithmException | IOException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Error initializing keystore\");\n+                logger.debug(\"Error initializing keystore\", e);\n+                return;\n+            }\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Connecting\");\n+        scheduler.submit(this::connect); // start the async connect task\n+    }\n+\n+    /**\n+     * Return a no-op SSL trust manager which will not verify server or client certificates.\n+     */\n+    private TrustManager[] defineNoOpTrustManager() {\n+        return new TrustManager[] { new X509TrustManager() {\n+            @Override\n+            public void checkClientTrusted(final X509Certificate @Nullable [] chain, final @Nullable String authType) {\n+                logger.debug(\"Assuming client certificate is valid\");\n+                if (chain != null) {\n+                    for (int cert = 0; cert < chain.length; cert++) {\n+                        logger.trace(\"Subject DN: {}\", chain[cert].getSubjectDN());\n+                        logger.trace(\"Issuer DN: {}\", chain[cert].getIssuerDN());\n+                        logger.trace(\"Serial number {}:\", chain[cert].getSerialNumber());\n+                    }\n+                }\n+            }\n+\n+            @Override\n+            public void checkServerTrusted(final X509Certificate @Nullable [] chain, final @Nullable String authType) {\n+                logger.debug(\"Assuming server certificate is valid\");\n+                if (chain != null) {\n+                    for (int cert = 0; cert < chain.length; cert++) {\n+                        logger.trace(\"Subject DN: {}\", chain[cert].getSubjectDN());\n+                        logger.trace(\"Issuer DN: {}\", chain[cert].getIssuerDN());\n+                        logger.trace(\"Serial number: {}\", chain[cert].getSerialNumber());\n+                    }\n+                }\n+            }\n+\n+            @Override\n+            public X509Certificate @Nullable [] getAcceptedIssuers() {\n+                return null;\n+            }\n+        } };\n+    }\n+\n+    private synchronized void connect() {\n+        deviceDataLoaded.set(false);\n+        buttonDataLoaded.set(false);\n+\n+        try {\n+            logger.debug(\"Opening SSL connection to {}:{}\", config.ipAddress, config.port);\n+            SSLSocket sslsocket = (SSLSocket) sslsocketfactory.createSocket(config.ipAddress, config.port);\n+            sslsocket.startHandshake();\n+            writer = new BufferedWriter(new OutputStreamWriter(sslsocket.getOutputStream()));\n+            reader = new BufferedReader(new InputStreamReader(sslsocket.getInputStream()));\n+            this.sslsocket = sslsocket;\n+        } catch (UnknownHostException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Unknown host\");\n+            return;\n+        } catch (IllegalArgumentException e) {\n+            // port out of valid range\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Invalid port number\");\n+            return;\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Error opening SSL connection. Check log.\");\n+            logger.info(\"Error opening SSL connection: {}\", e.getMessage());\n+            disconnect();\n+            scheduleConnectRetry(reconnectInterval); // Possibly a temporary problem. Try again later.\n+            return;\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, STATUS_INITIALIZING);\n+\n+        Thread readerThread = new Thread(this::readerThreadJob, \"Lutron reader\");\n+        readerThread.setDaemon(true);\n+        readerThread.start();\n+        this.readerThread = readerThread;\n+\n+        Thread senderThread = new Thread(this::senderThreadJob, \"Lutron sender\");\n+        senderThread.setDaemon(true);\n+        senderThread.start();\n+        this.senderThread = senderThread;\n+\n+        sendCommand(new LeapCommand(Request.getButtonGroups()));\n+        queryDiscoveryData();\n+        sendCommand(new LeapCommand(Request.subscribeOccupancyGroupStatus()));\n+\n+        logger.debug(\"Starting keepAlive job with interval {}\", heartbeatInterval);\n+        keepAlive = scheduler.scheduleWithFixedDelay(this::sendKeepAlive, heartbeatInterval, heartbeatInterval,\n+                TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Called by connect() and discovery service to request fresh discovery data\n+     */\n+    public void queryDiscoveryData() {\n+        sendCommand(new LeapCommand(Request.getDevices()));\n+        sendCommand(new LeapCommand(Request.getAreas()));\n+        sendCommand(new LeapCommand(Request.getOccupancyGroups()));\n+    }\n+\n+    private void scheduleConnectRetry(long waitMinutes) {\n+        logger.debug(\"Scheduling connection retry in {} minutes\", waitMinutes);\n+        connectRetryJob = scheduler.schedule(this::connect, waitMinutes, TimeUnit.MINUTES);\n+    }\n+\n+    private synchronized void disconnect() {\n+        logger.debug(\"Disconnecting\");\n+\n+        Thread senderThread = this.senderThread;\n+        Thread readerThread = this.readerThread;\n+\n+        if (connectRetryJob != null) {\n+            connectRetryJob.cancel(true);\n+        }\n+        if (keepAlive != null) {\n+            keepAlive.cancel(true);\n+        }\n+\n+        // May be called from keepAliveReconnect thread, so call cancel with false\n+        reconnectTaskCancel(false);\n+\n+        if (senderThread != null && senderThread.isAlive()) {\n+            senderThread.interrupt();\n+        }\n+        if (readerThread != null && readerThread.isAlive()) {\n+            readerThread.interrupt();\n+        }\n+        if (sslsocket != null) {\n+            try {\n+                sslsocket.close();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY5NTY1Mw=="}, "originalCommit": {"oid": "deb48c1252ee18917f2f9e19cf0158fedb164659"}, "originalPosition": 340}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQxMTQyMg==", "bodyText": "Yes, I'm just wondering why they don't show up in Eclipse as well. Should we open a an issue on it? And if so, where?", "url": "https://github.com/openhab/openhab-addons/pull/8650#discussion_r501411422", "createdAt": "2020-10-08T02:23:19Z", "author": {"login": "bobadair"}, "path": "bundles/org.openhab.binding.lutron/src/main/java/org/openhab/binding/lutron/internal/handler/LeapBridgeHandler.java", "diffHunk": "@@ -0,0 +1,763 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lutron.internal.handler;\n+\n+import static org.openhab.binding.lutron.internal.LutronBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.net.UnknownHostException;\n+import java.security.KeyManagementException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.UnrecoverableKeyException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManager;\n+import javax.net.ssl.TrustManagerFactory;\n+import javax.net.ssl.X509TrustManager;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.lutron.internal.config.LeapBridgeConfig;\n+import org.openhab.binding.lutron.internal.discovery.LeapDeviceDiscoveryService;\n+import org.openhab.binding.lutron.internal.protocol.FanSpeedType;\n+import org.openhab.binding.lutron.internal.protocol.GroupCommand;\n+import org.openhab.binding.lutron.internal.protocol.LutronCommandNew;\n+import org.openhab.binding.lutron.internal.protocol.OutputCommand;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapCommand;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapMessageParser;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapMessageParserCallbacks;\n+import org.openhab.binding.lutron.internal.protocol.leap.Request;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Area;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ButtonGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Device;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.OccupancyGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ZoneStatus;\n+import org.openhab.binding.lutron.internal.protocol.lip.LutronCommandType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Bridge handler responsible for communicating with Lutron hubs that support the LEAP protocol, such as Caseta and\n+ * RA2 Select.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LeapBridgeHandler extends LutronBridgeHandler implements LeapMessageParserCallbacks {\n+    private static final int DEFAULT_RECONNECT_MINUTES = 5;\n+    private static final int DEFAULT_HEARTBEAT_MINUTES = 5;\n+    private static final long KEEPALIVE_TIMEOUT_SECONDS = 30;\n+\n+    private static final String STATUS_INITIALIZING = \"Initializing\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(LeapBridgeHandler.class);\n+\n+    private @NonNullByDefault({}) LeapBridgeConfig config;\n+    private int reconnectInterval;\n+    private int heartbeatInterval;\n+    private int sendDelay;\n+\n+    private @NonNullByDefault({}) SSLSocketFactory sslsocketfactory;\n+    private @Nullable SSLSocket sslsocket;\n+    private @Nullable BufferedWriter writer;\n+    private @Nullable BufferedReader reader;\n+\n+    private @NonNullByDefault({}) LeapMessageParser leapMessageParser;\n+\n+    private final BlockingQueue<LeapCommand> sendQueue = new LinkedBlockingQueue<>();\n+\n+    private @Nullable Thread senderThread;\n+    private @Nullable Thread readerThread;\n+\n+    private @Nullable ScheduledFuture<?> keepAlive;\n+    private @Nullable ScheduledFuture<?> keepAliveReconnect;\n+    private @Nullable ScheduledFuture<?> connectRetryJob;\n+    private final Object keepAliveReconnectLock = new Object();\n+\n+    private final Map<Integer, Integer> zoneToDevice = new HashMap<>();\n+    private final Map<Integer, Integer> deviceToZone = new HashMap<>();\n+    private final Object zoneMapsLock = new Object();\n+\n+    private @Nullable Map<Integer, List<Integer>> deviceButtonMap;\n+    private final Object deviceButtonMapLock = new Object();\n+\n+    private final AtomicBoolean deviceDataLoaded = new AtomicBoolean(false);\n+    private final AtomicBoolean buttonDataLoaded = new AtomicBoolean(false);\n+\n+    private final Map<Integer, LutronHandler> childHandlerMap = new ConcurrentHashMap<>();\n+    private final Map<Integer, OGroupHandler> groupHandlerMap = new ConcurrentHashMap<>();\n+\n+    private @Nullable LeapDeviceDiscoveryService discoveryService;\n+\n+    public void setDiscoveryService(LeapDeviceDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    public LeapBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+        leapMessageParser = new LeapMessageParser(this);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        SSLContext sslContext;\n+\n+        childHandlerMap.clear();\n+        groupHandlerMap.clear();\n+\n+        config = getConfigAs(LeapBridgeConfig.class);\n+        String keystorePassword = (config.keystorePassword == null) ? \"\" : config.keystorePassword;\n+\n+        String ipAddress = config.ipAddress;\n+        if (ipAddress == null || ipAddress.isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"bridge address not specified\");\n+            return;\n+        }\n+\n+        reconnectInterval = (config.reconnect > 0) ? config.reconnect : DEFAULT_RECONNECT_MINUTES;\n+        heartbeatInterval = (config.heartbeat > 0) ? config.heartbeat : DEFAULT_HEARTBEAT_MINUTES;\n+        sendDelay = (config.delay < 0) ? 0 : config.delay;\n+\n+        if (config.keystore == null || keystorePassword == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Keystore/keystore password not configured\");\n+            return;\n+        } else {\n+            try (FileInputStream keystoreInputStream = new FileInputStream(config.keystore)) {\n+                logger.trace(\"Initializing keystore\");\n+                KeyStore keystore = KeyStore.getInstance(KeyStore.getDefaultType());\n+\n+                keystore.load(keystoreInputStream, keystorePassword.toCharArray());\n+\n+                logger.trace(\"Initializing SSL Context\");\n+                KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n+                kmf.init(keystore, keystorePassword.toCharArray());\n+\n+                TrustManager[] trustManagers;\n+                if (config.certValidate) {\n+                    // Use default trust manager which will attempt to validate server certificate from hub\n+                    TrustManagerFactory tmf = TrustManagerFactory\n+                            .getInstance(TrustManagerFactory.getDefaultAlgorithm());\n+                    tmf.init(keystore);\n+                    trustManagers = tmf.getTrustManagers();\n+                } else {\n+                    // Use no-op trust manager which will not verify certificates\n+                    trustManagers = defineNoOpTrustManager();\n+                }\n+\n+                sslContext = SSLContext.getInstance(\"TLS\");\n+                sslContext.init(kmf.getKeyManagers(), trustManagers, null);\n+\n+                sslsocketfactory = sslContext.getSocketFactory();\n+            } catch (FileNotFoundException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Keystore file not found\");\n+                return;\n+            } catch (CertificateException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Certificate exception\");\n+                return;\n+            } catch (UnrecoverableKeyException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"Key unrecoverable with supplied password\");\n+                return;\n+            } catch (KeyManagementException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Key management exception\");\n+                logger.debug(\"Key management exception\", e);\n+                return;\n+            } catch (KeyStoreException | NoSuchAlgorithmException | IOException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Error initializing keystore\");\n+                logger.debug(\"Error initializing keystore\", e);\n+                return;\n+            }\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Connecting\");\n+        scheduler.submit(this::connect); // start the async connect task\n+    }\n+\n+    /**\n+     * Return a no-op SSL trust manager which will not verify server or client certificates.\n+     */\n+    private TrustManager[] defineNoOpTrustManager() {\n+        return new TrustManager[] { new X509TrustManager() {\n+            @Override\n+            public void checkClientTrusted(final X509Certificate @Nullable [] chain, final @Nullable String authType) {\n+                logger.debug(\"Assuming client certificate is valid\");\n+                if (chain != null) {\n+                    for (int cert = 0; cert < chain.length; cert++) {\n+                        logger.trace(\"Subject DN: {}\", chain[cert].getSubjectDN());\n+                        logger.trace(\"Issuer DN: {}\", chain[cert].getIssuerDN());\n+                        logger.trace(\"Serial number {}:\", chain[cert].getSerialNumber());\n+                    }\n+                }\n+            }\n+\n+            @Override\n+            public void checkServerTrusted(final X509Certificate @Nullable [] chain, final @Nullable String authType) {\n+                logger.debug(\"Assuming server certificate is valid\");\n+                if (chain != null) {\n+                    for (int cert = 0; cert < chain.length; cert++) {\n+                        logger.trace(\"Subject DN: {}\", chain[cert].getSubjectDN());\n+                        logger.trace(\"Issuer DN: {}\", chain[cert].getIssuerDN());\n+                        logger.trace(\"Serial number: {}\", chain[cert].getSerialNumber());\n+                    }\n+                }\n+            }\n+\n+            @Override\n+            public X509Certificate @Nullable [] getAcceptedIssuers() {\n+                return null;\n+            }\n+        } };\n+    }\n+\n+    private synchronized void connect() {\n+        deviceDataLoaded.set(false);\n+        buttonDataLoaded.set(false);\n+\n+        try {\n+            logger.debug(\"Opening SSL connection to {}:{}\", config.ipAddress, config.port);\n+            SSLSocket sslsocket = (SSLSocket) sslsocketfactory.createSocket(config.ipAddress, config.port);\n+            sslsocket.startHandshake();\n+            writer = new BufferedWriter(new OutputStreamWriter(sslsocket.getOutputStream()));\n+            reader = new BufferedReader(new InputStreamReader(sslsocket.getInputStream()));\n+            this.sslsocket = sslsocket;\n+        } catch (UnknownHostException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Unknown host\");\n+            return;\n+        } catch (IllegalArgumentException e) {\n+            // port out of valid range\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Invalid port number\");\n+            return;\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Error opening SSL connection. Check log.\");\n+            logger.info(\"Error opening SSL connection: {}\", e.getMessage());\n+            disconnect();\n+            scheduleConnectRetry(reconnectInterval); // Possibly a temporary problem. Try again later.\n+            return;\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, STATUS_INITIALIZING);\n+\n+        Thread readerThread = new Thread(this::readerThreadJob, \"Lutron reader\");\n+        readerThread.setDaemon(true);\n+        readerThread.start();\n+        this.readerThread = readerThread;\n+\n+        Thread senderThread = new Thread(this::senderThreadJob, \"Lutron sender\");\n+        senderThread.setDaemon(true);\n+        senderThread.start();\n+        this.senderThread = senderThread;\n+\n+        sendCommand(new LeapCommand(Request.getButtonGroups()));\n+        queryDiscoveryData();\n+        sendCommand(new LeapCommand(Request.subscribeOccupancyGroupStatus()));\n+\n+        logger.debug(\"Starting keepAlive job with interval {}\", heartbeatInterval);\n+        keepAlive = scheduler.scheduleWithFixedDelay(this::sendKeepAlive, heartbeatInterval, heartbeatInterval,\n+                TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Called by connect() and discovery service to request fresh discovery data\n+     */\n+    public void queryDiscoveryData() {\n+        sendCommand(new LeapCommand(Request.getDevices()));\n+        sendCommand(new LeapCommand(Request.getAreas()));\n+        sendCommand(new LeapCommand(Request.getOccupancyGroups()));\n+    }\n+\n+    private void scheduleConnectRetry(long waitMinutes) {\n+        logger.debug(\"Scheduling connection retry in {} minutes\", waitMinutes);\n+        connectRetryJob = scheduler.schedule(this::connect, waitMinutes, TimeUnit.MINUTES);\n+    }\n+\n+    private synchronized void disconnect() {\n+        logger.debug(\"Disconnecting\");\n+\n+        Thread senderThread = this.senderThread;\n+        Thread readerThread = this.readerThread;\n+\n+        if (connectRetryJob != null) {\n+            connectRetryJob.cancel(true);\n+        }\n+        if (keepAlive != null) {\n+            keepAlive.cancel(true);\n+        }\n+\n+        // May be called from keepAliveReconnect thread, so call cancel with false\n+        reconnectTaskCancel(false);\n+\n+        if (senderThread != null && senderThread.isAlive()) {\n+            senderThread.interrupt();\n+        }\n+        if (readerThread != null && readerThread.isAlive()) {\n+            readerThread.interrupt();\n+        }\n+        if (sslsocket != null) {\n+            try {\n+                sslsocket.close();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY5NTY1Mw=="}, "originalCommit": {"oid": "deb48c1252ee18917f2f9e19cf0158fedb164659"}, "originalPosition": 340}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQ1MTE5Nw==", "bodyText": "I'm not really sure.", "url": "https://github.com/openhab/openhab-addons/pull/8650#discussion_r501451197", "createdAt": "2020-10-08T05:08:23Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lutron/src/main/java/org/openhab/binding/lutron/internal/handler/LeapBridgeHandler.java", "diffHunk": "@@ -0,0 +1,763 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lutron.internal.handler;\n+\n+import static org.openhab.binding.lutron.internal.LutronBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.net.UnknownHostException;\n+import java.security.KeyManagementException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.UnrecoverableKeyException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManager;\n+import javax.net.ssl.TrustManagerFactory;\n+import javax.net.ssl.X509TrustManager;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.lutron.internal.config.LeapBridgeConfig;\n+import org.openhab.binding.lutron.internal.discovery.LeapDeviceDiscoveryService;\n+import org.openhab.binding.lutron.internal.protocol.FanSpeedType;\n+import org.openhab.binding.lutron.internal.protocol.GroupCommand;\n+import org.openhab.binding.lutron.internal.protocol.LutronCommandNew;\n+import org.openhab.binding.lutron.internal.protocol.OutputCommand;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapCommand;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapMessageParser;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapMessageParserCallbacks;\n+import org.openhab.binding.lutron.internal.protocol.leap.Request;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Area;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ButtonGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Device;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.OccupancyGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ZoneStatus;\n+import org.openhab.binding.lutron.internal.protocol.lip.LutronCommandType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Bridge handler responsible for communicating with Lutron hubs that support the LEAP protocol, such as Caseta and\n+ * RA2 Select.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LeapBridgeHandler extends LutronBridgeHandler implements LeapMessageParserCallbacks {\n+    private static final int DEFAULT_RECONNECT_MINUTES = 5;\n+    private static final int DEFAULT_HEARTBEAT_MINUTES = 5;\n+    private static final long KEEPALIVE_TIMEOUT_SECONDS = 30;\n+\n+    private static final String STATUS_INITIALIZING = \"Initializing\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(LeapBridgeHandler.class);\n+\n+    private @NonNullByDefault({}) LeapBridgeConfig config;\n+    private int reconnectInterval;\n+    private int heartbeatInterval;\n+    private int sendDelay;\n+\n+    private @NonNullByDefault({}) SSLSocketFactory sslsocketfactory;\n+    private @Nullable SSLSocket sslsocket;\n+    private @Nullable BufferedWriter writer;\n+    private @Nullable BufferedReader reader;\n+\n+    private @NonNullByDefault({}) LeapMessageParser leapMessageParser;\n+\n+    private final BlockingQueue<LeapCommand> sendQueue = new LinkedBlockingQueue<>();\n+\n+    private @Nullable Thread senderThread;\n+    private @Nullable Thread readerThread;\n+\n+    private @Nullable ScheduledFuture<?> keepAlive;\n+    private @Nullable ScheduledFuture<?> keepAliveReconnect;\n+    private @Nullable ScheduledFuture<?> connectRetryJob;\n+    private final Object keepAliveReconnectLock = new Object();\n+\n+    private final Map<Integer, Integer> zoneToDevice = new HashMap<>();\n+    private final Map<Integer, Integer> deviceToZone = new HashMap<>();\n+    private final Object zoneMapsLock = new Object();\n+\n+    private @Nullable Map<Integer, List<Integer>> deviceButtonMap;\n+    private final Object deviceButtonMapLock = new Object();\n+\n+    private final AtomicBoolean deviceDataLoaded = new AtomicBoolean(false);\n+    private final AtomicBoolean buttonDataLoaded = new AtomicBoolean(false);\n+\n+    private final Map<Integer, LutronHandler> childHandlerMap = new ConcurrentHashMap<>();\n+    private final Map<Integer, OGroupHandler> groupHandlerMap = new ConcurrentHashMap<>();\n+\n+    private @Nullable LeapDeviceDiscoveryService discoveryService;\n+\n+    public void setDiscoveryService(LeapDeviceDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    public LeapBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+        leapMessageParser = new LeapMessageParser(this);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        SSLContext sslContext;\n+\n+        childHandlerMap.clear();\n+        groupHandlerMap.clear();\n+\n+        config = getConfigAs(LeapBridgeConfig.class);\n+        String keystorePassword = (config.keystorePassword == null) ? \"\" : config.keystorePassword;\n+\n+        String ipAddress = config.ipAddress;\n+        if (ipAddress == null || ipAddress.isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"bridge address not specified\");\n+            return;\n+        }\n+\n+        reconnectInterval = (config.reconnect > 0) ? config.reconnect : DEFAULT_RECONNECT_MINUTES;\n+        heartbeatInterval = (config.heartbeat > 0) ? config.heartbeat : DEFAULT_HEARTBEAT_MINUTES;\n+        sendDelay = (config.delay < 0) ? 0 : config.delay;\n+\n+        if (config.keystore == null || keystorePassword == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Keystore/keystore password not configured\");\n+            return;\n+        } else {\n+            try (FileInputStream keystoreInputStream = new FileInputStream(config.keystore)) {\n+                logger.trace(\"Initializing keystore\");\n+                KeyStore keystore = KeyStore.getInstance(KeyStore.getDefaultType());\n+\n+                keystore.load(keystoreInputStream, keystorePassword.toCharArray());\n+\n+                logger.trace(\"Initializing SSL Context\");\n+                KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n+                kmf.init(keystore, keystorePassword.toCharArray());\n+\n+                TrustManager[] trustManagers;\n+                if (config.certValidate) {\n+                    // Use default trust manager which will attempt to validate server certificate from hub\n+                    TrustManagerFactory tmf = TrustManagerFactory\n+                            .getInstance(TrustManagerFactory.getDefaultAlgorithm());\n+                    tmf.init(keystore);\n+                    trustManagers = tmf.getTrustManagers();\n+                } else {\n+                    // Use no-op trust manager which will not verify certificates\n+                    trustManagers = defineNoOpTrustManager();\n+                }\n+\n+                sslContext = SSLContext.getInstance(\"TLS\");\n+                sslContext.init(kmf.getKeyManagers(), trustManagers, null);\n+\n+                sslsocketfactory = sslContext.getSocketFactory();\n+            } catch (FileNotFoundException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Keystore file not found\");\n+                return;\n+            } catch (CertificateException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Certificate exception\");\n+                return;\n+            } catch (UnrecoverableKeyException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"Key unrecoverable with supplied password\");\n+                return;\n+            } catch (KeyManagementException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Key management exception\");\n+                logger.debug(\"Key management exception\", e);\n+                return;\n+            } catch (KeyStoreException | NoSuchAlgorithmException | IOException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Error initializing keystore\");\n+                logger.debug(\"Error initializing keystore\", e);\n+                return;\n+            }\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Connecting\");\n+        scheduler.submit(this::connect); // start the async connect task\n+    }\n+\n+    /**\n+     * Return a no-op SSL trust manager which will not verify server or client certificates.\n+     */\n+    private TrustManager[] defineNoOpTrustManager() {\n+        return new TrustManager[] { new X509TrustManager() {\n+            @Override\n+            public void checkClientTrusted(final X509Certificate @Nullable [] chain, final @Nullable String authType) {\n+                logger.debug(\"Assuming client certificate is valid\");\n+                if (chain != null) {\n+                    for (int cert = 0; cert < chain.length; cert++) {\n+                        logger.trace(\"Subject DN: {}\", chain[cert].getSubjectDN());\n+                        logger.trace(\"Issuer DN: {}\", chain[cert].getIssuerDN());\n+                        logger.trace(\"Serial number {}:\", chain[cert].getSerialNumber());\n+                    }\n+                }\n+            }\n+\n+            @Override\n+            public void checkServerTrusted(final X509Certificate @Nullable [] chain, final @Nullable String authType) {\n+                logger.debug(\"Assuming server certificate is valid\");\n+                if (chain != null) {\n+                    for (int cert = 0; cert < chain.length; cert++) {\n+                        logger.trace(\"Subject DN: {}\", chain[cert].getSubjectDN());\n+                        logger.trace(\"Issuer DN: {}\", chain[cert].getIssuerDN());\n+                        logger.trace(\"Serial number: {}\", chain[cert].getSerialNumber());\n+                    }\n+                }\n+            }\n+\n+            @Override\n+            public X509Certificate @Nullable [] getAcceptedIssuers() {\n+                return null;\n+            }\n+        } };\n+    }\n+\n+    private synchronized void connect() {\n+        deviceDataLoaded.set(false);\n+        buttonDataLoaded.set(false);\n+\n+        try {\n+            logger.debug(\"Opening SSL connection to {}:{}\", config.ipAddress, config.port);\n+            SSLSocket sslsocket = (SSLSocket) sslsocketfactory.createSocket(config.ipAddress, config.port);\n+            sslsocket.startHandshake();\n+            writer = new BufferedWriter(new OutputStreamWriter(sslsocket.getOutputStream()));\n+            reader = new BufferedReader(new InputStreamReader(sslsocket.getInputStream()));\n+            this.sslsocket = sslsocket;\n+        } catch (UnknownHostException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Unknown host\");\n+            return;\n+        } catch (IllegalArgumentException e) {\n+            // port out of valid range\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Invalid port number\");\n+            return;\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Error opening SSL connection. Check log.\");\n+            logger.info(\"Error opening SSL connection: {}\", e.getMessage());\n+            disconnect();\n+            scheduleConnectRetry(reconnectInterval); // Possibly a temporary problem. Try again later.\n+            return;\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, STATUS_INITIALIZING);\n+\n+        Thread readerThread = new Thread(this::readerThreadJob, \"Lutron reader\");\n+        readerThread.setDaemon(true);\n+        readerThread.start();\n+        this.readerThread = readerThread;\n+\n+        Thread senderThread = new Thread(this::senderThreadJob, \"Lutron sender\");\n+        senderThread.setDaemon(true);\n+        senderThread.start();\n+        this.senderThread = senderThread;\n+\n+        sendCommand(new LeapCommand(Request.getButtonGroups()));\n+        queryDiscoveryData();\n+        sendCommand(new LeapCommand(Request.subscribeOccupancyGroupStatus()));\n+\n+        logger.debug(\"Starting keepAlive job with interval {}\", heartbeatInterval);\n+        keepAlive = scheduler.scheduleWithFixedDelay(this::sendKeepAlive, heartbeatInterval, heartbeatInterval,\n+                TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Called by connect() and discovery service to request fresh discovery data\n+     */\n+    public void queryDiscoveryData() {\n+        sendCommand(new LeapCommand(Request.getDevices()));\n+        sendCommand(new LeapCommand(Request.getAreas()));\n+        sendCommand(new LeapCommand(Request.getOccupancyGroups()));\n+    }\n+\n+    private void scheduleConnectRetry(long waitMinutes) {\n+        logger.debug(\"Scheduling connection retry in {} minutes\", waitMinutes);\n+        connectRetryJob = scheduler.schedule(this::connect, waitMinutes, TimeUnit.MINUTES);\n+    }\n+\n+    private synchronized void disconnect() {\n+        logger.debug(\"Disconnecting\");\n+\n+        Thread senderThread = this.senderThread;\n+        Thread readerThread = this.readerThread;\n+\n+        if (connectRetryJob != null) {\n+            connectRetryJob.cancel(true);\n+        }\n+        if (keepAlive != null) {\n+            keepAlive.cancel(true);\n+        }\n+\n+        // May be called from keepAliveReconnect thread, so call cancel with false\n+        reconnectTaskCancel(false);\n+\n+        if (senderThread != null && senderThread.isAlive()) {\n+            senderThread.interrupt();\n+        }\n+        if (readerThread != null && readerThread.isAlive()) {\n+            readerThread.interrupt();\n+        }\n+        if (sslsocket != null) {\n+            try {\n+                sslsocket.close();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY5NTY1Mw=="}, "originalCommit": {"oid": "deb48c1252ee18917f2f9e19cf0158fedb164659"}, "originalPosition": 340}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjE4ODM0Mg==", "bodyText": "These are all fixed.", "url": "https://github.com/openhab/openhab-addons/pull/8650#discussion_r502188342", "createdAt": "2020-10-09T04:53:00Z", "author": {"login": "bobadair"}, "path": "bundles/org.openhab.binding.lutron/src/main/java/org/openhab/binding/lutron/internal/handler/LeapBridgeHandler.java", "diffHunk": "@@ -0,0 +1,763 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lutron.internal.handler;\n+\n+import static org.openhab.binding.lutron.internal.LutronBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.net.UnknownHostException;\n+import java.security.KeyManagementException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.UnrecoverableKeyException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManager;\n+import javax.net.ssl.TrustManagerFactory;\n+import javax.net.ssl.X509TrustManager;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.lutron.internal.config.LeapBridgeConfig;\n+import org.openhab.binding.lutron.internal.discovery.LeapDeviceDiscoveryService;\n+import org.openhab.binding.lutron.internal.protocol.FanSpeedType;\n+import org.openhab.binding.lutron.internal.protocol.GroupCommand;\n+import org.openhab.binding.lutron.internal.protocol.LutronCommandNew;\n+import org.openhab.binding.lutron.internal.protocol.OutputCommand;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapCommand;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapMessageParser;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapMessageParserCallbacks;\n+import org.openhab.binding.lutron.internal.protocol.leap.Request;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Area;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ButtonGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Device;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.OccupancyGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ZoneStatus;\n+import org.openhab.binding.lutron.internal.protocol.lip.LutronCommandType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Bridge handler responsible for communicating with Lutron hubs that support the LEAP protocol, such as Caseta and\n+ * RA2 Select.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LeapBridgeHandler extends LutronBridgeHandler implements LeapMessageParserCallbacks {\n+    private static final int DEFAULT_RECONNECT_MINUTES = 5;\n+    private static final int DEFAULT_HEARTBEAT_MINUTES = 5;\n+    private static final long KEEPALIVE_TIMEOUT_SECONDS = 30;\n+\n+    private static final String STATUS_INITIALIZING = \"Initializing\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(LeapBridgeHandler.class);\n+\n+    private @NonNullByDefault({}) LeapBridgeConfig config;\n+    private int reconnectInterval;\n+    private int heartbeatInterval;\n+    private int sendDelay;\n+\n+    private @NonNullByDefault({}) SSLSocketFactory sslsocketfactory;\n+    private @Nullable SSLSocket sslsocket;\n+    private @Nullable BufferedWriter writer;\n+    private @Nullable BufferedReader reader;\n+\n+    private @NonNullByDefault({}) LeapMessageParser leapMessageParser;\n+\n+    private final BlockingQueue<LeapCommand> sendQueue = new LinkedBlockingQueue<>();\n+\n+    private @Nullable Thread senderThread;\n+    private @Nullable Thread readerThread;\n+\n+    private @Nullable ScheduledFuture<?> keepAlive;\n+    private @Nullable ScheduledFuture<?> keepAliveReconnect;\n+    private @Nullable ScheduledFuture<?> connectRetryJob;\n+    private final Object keepAliveReconnectLock = new Object();\n+\n+    private final Map<Integer, Integer> zoneToDevice = new HashMap<>();\n+    private final Map<Integer, Integer> deviceToZone = new HashMap<>();\n+    private final Object zoneMapsLock = new Object();\n+\n+    private @Nullable Map<Integer, List<Integer>> deviceButtonMap;\n+    private final Object deviceButtonMapLock = new Object();\n+\n+    private final AtomicBoolean deviceDataLoaded = new AtomicBoolean(false);\n+    private final AtomicBoolean buttonDataLoaded = new AtomicBoolean(false);\n+\n+    private final Map<Integer, LutronHandler> childHandlerMap = new ConcurrentHashMap<>();\n+    private final Map<Integer, OGroupHandler> groupHandlerMap = new ConcurrentHashMap<>();\n+\n+    private @Nullable LeapDeviceDiscoveryService discoveryService;\n+\n+    public void setDiscoveryService(LeapDeviceDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    public LeapBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+        leapMessageParser = new LeapMessageParser(this);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        SSLContext sslContext;\n+\n+        childHandlerMap.clear();\n+        groupHandlerMap.clear();\n+\n+        config = getConfigAs(LeapBridgeConfig.class);\n+        String keystorePassword = (config.keystorePassword == null) ? \"\" : config.keystorePassword;\n+\n+        String ipAddress = config.ipAddress;\n+        if (ipAddress == null || ipAddress.isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"bridge address not specified\");\n+            return;\n+        }\n+\n+        reconnectInterval = (config.reconnect > 0) ? config.reconnect : DEFAULT_RECONNECT_MINUTES;\n+        heartbeatInterval = (config.heartbeat > 0) ? config.heartbeat : DEFAULT_HEARTBEAT_MINUTES;\n+        sendDelay = (config.delay < 0) ? 0 : config.delay;\n+\n+        if (config.keystore == null || keystorePassword == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Keystore/keystore password not configured\");\n+            return;\n+        } else {\n+            try (FileInputStream keystoreInputStream = new FileInputStream(config.keystore)) {\n+                logger.trace(\"Initializing keystore\");\n+                KeyStore keystore = KeyStore.getInstance(KeyStore.getDefaultType());\n+\n+                keystore.load(keystoreInputStream, keystorePassword.toCharArray());\n+\n+                logger.trace(\"Initializing SSL Context\");\n+                KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n+                kmf.init(keystore, keystorePassword.toCharArray());\n+\n+                TrustManager[] trustManagers;\n+                if (config.certValidate) {\n+                    // Use default trust manager which will attempt to validate server certificate from hub\n+                    TrustManagerFactory tmf = TrustManagerFactory\n+                            .getInstance(TrustManagerFactory.getDefaultAlgorithm());\n+                    tmf.init(keystore);\n+                    trustManagers = tmf.getTrustManagers();\n+                } else {\n+                    // Use no-op trust manager which will not verify certificates\n+                    trustManagers = defineNoOpTrustManager();\n+                }\n+\n+                sslContext = SSLContext.getInstance(\"TLS\");\n+                sslContext.init(kmf.getKeyManagers(), trustManagers, null);\n+\n+                sslsocketfactory = sslContext.getSocketFactory();\n+            } catch (FileNotFoundException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Keystore file not found\");\n+                return;\n+            } catch (CertificateException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Certificate exception\");\n+                return;\n+            } catch (UnrecoverableKeyException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"Key unrecoverable with supplied password\");\n+                return;\n+            } catch (KeyManagementException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Key management exception\");\n+                logger.debug(\"Key management exception\", e);\n+                return;\n+            } catch (KeyStoreException | NoSuchAlgorithmException | IOException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Error initializing keystore\");\n+                logger.debug(\"Error initializing keystore\", e);\n+                return;\n+            }\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Connecting\");\n+        scheduler.submit(this::connect); // start the async connect task\n+    }\n+\n+    /**\n+     * Return a no-op SSL trust manager which will not verify server or client certificates.\n+     */\n+    private TrustManager[] defineNoOpTrustManager() {\n+        return new TrustManager[] { new X509TrustManager() {\n+            @Override\n+            public void checkClientTrusted(final X509Certificate @Nullable [] chain, final @Nullable String authType) {\n+                logger.debug(\"Assuming client certificate is valid\");\n+                if (chain != null) {\n+                    for (int cert = 0; cert < chain.length; cert++) {\n+                        logger.trace(\"Subject DN: {}\", chain[cert].getSubjectDN());\n+                        logger.trace(\"Issuer DN: {}\", chain[cert].getIssuerDN());\n+                        logger.trace(\"Serial number {}:\", chain[cert].getSerialNumber());\n+                    }\n+                }\n+            }\n+\n+            @Override\n+            public void checkServerTrusted(final X509Certificate @Nullable [] chain, final @Nullable String authType) {\n+                logger.debug(\"Assuming server certificate is valid\");\n+                if (chain != null) {\n+                    for (int cert = 0; cert < chain.length; cert++) {\n+                        logger.trace(\"Subject DN: {}\", chain[cert].getSubjectDN());\n+                        logger.trace(\"Issuer DN: {}\", chain[cert].getIssuerDN());\n+                        logger.trace(\"Serial number: {}\", chain[cert].getSerialNumber());\n+                    }\n+                }\n+            }\n+\n+            @Override\n+            public X509Certificate @Nullable [] getAcceptedIssuers() {\n+                return null;\n+            }\n+        } };\n+    }\n+\n+    private synchronized void connect() {\n+        deviceDataLoaded.set(false);\n+        buttonDataLoaded.set(false);\n+\n+        try {\n+            logger.debug(\"Opening SSL connection to {}:{}\", config.ipAddress, config.port);\n+            SSLSocket sslsocket = (SSLSocket) sslsocketfactory.createSocket(config.ipAddress, config.port);\n+            sslsocket.startHandshake();\n+            writer = new BufferedWriter(new OutputStreamWriter(sslsocket.getOutputStream()));\n+            reader = new BufferedReader(new InputStreamReader(sslsocket.getInputStream()));\n+            this.sslsocket = sslsocket;\n+        } catch (UnknownHostException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Unknown host\");\n+            return;\n+        } catch (IllegalArgumentException e) {\n+            // port out of valid range\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Invalid port number\");\n+            return;\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Error opening SSL connection. Check log.\");\n+            logger.info(\"Error opening SSL connection: {}\", e.getMessage());\n+            disconnect();\n+            scheduleConnectRetry(reconnectInterval); // Possibly a temporary problem. Try again later.\n+            return;\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, STATUS_INITIALIZING);\n+\n+        Thread readerThread = new Thread(this::readerThreadJob, \"Lutron reader\");\n+        readerThread.setDaemon(true);\n+        readerThread.start();\n+        this.readerThread = readerThread;\n+\n+        Thread senderThread = new Thread(this::senderThreadJob, \"Lutron sender\");\n+        senderThread.setDaemon(true);\n+        senderThread.start();\n+        this.senderThread = senderThread;\n+\n+        sendCommand(new LeapCommand(Request.getButtonGroups()));\n+        queryDiscoveryData();\n+        sendCommand(new LeapCommand(Request.subscribeOccupancyGroupStatus()));\n+\n+        logger.debug(\"Starting keepAlive job with interval {}\", heartbeatInterval);\n+        keepAlive = scheduler.scheduleWithFixedDelay(this::sendKeepAlive, heartbeatInterval, heartbeatInterval,\n+                TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Called by connect() and discovery service to request fresh discovery data\n+     */\n+    public void queryDiscoveryData() {\n+        sendCommand(new LeapCommand(Request.getDevices()));\n+        sendCommand(new LeapCommand(Request.getAreas()));\n+        sendCommand(new LeapCommand(Request.getOccupancyGroups()));\n+    }\n+\n+    private void scheduleConnectRetry(long waitMinutes) {\n+        logger.debug(\"Scheduling connection retry in {} minutes\", waitMinutes);\n+        connectRetryJob = scheduler.schedule(this::connect, waitMinutes, TimeUnit.MINUTES);\n+    }\n+\n+    private synchronized void disconnect() {\n+        logger.debug(\"Disconnecting\");\n+\n+        Thread senderThread = this.senderThread;\n+        Thread readerThread = this.readerThread;\n+\n+        if (connectRetryJob != null) {\n+            connectRetryJob.cancel(true);\n+        }\n+        if (keepAlive != null) {\n+            keepAlive.cancel(true);\n+        }\n+\n+        // May be called from keepAliveReconnect thread, so call cancel with false\n+        reconnectTaskCancel(false);\n+\n+        if (senderThread != null && senderThread.isAlive()) {\n+            senderThread.interrupt();\n+        }\n+        if (readerThread != null && readerThread.isAlive()) {\n+            readerThread.interrupt();\n+        }\n+        if (sslsocket != null) {\n+            try {\n+                sslsocket.close();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY5NTY1Mw=="}, "originalCommit": {"oid": "deb48c1252ee18917f2f9e19cf0158fedb164659"}, "originalPosition": 340}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNTA3OTAyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.lutron/src/main/java/org/openhab/binding/lutron/internal/handler/LeapBridgeHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwMjowODoxOFrOHdgClg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwMjowODoxOFrOHdgClg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY5NTcwMg==", "bodyText": "same here", "url": "https://github.com/openhab/openhab-addons/pull/8650#discussion_r500695702", "createdAt": "2020-10-07T02:08:18Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lutron/src/main/java/org/openhab/binding/lutron/internal/handler/LeapBridgeHandler.java", "diffHunk": "@@ -0,0 +1,763 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lutron.internal.handler;\n+\n+import static org.openhab.binding.lutron.internal.LutronBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.net.UnknownHostException;\n+import java.security.KeyManagementException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.UnrecoverableKeyException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManager;\n+import javax.net.ssl.TrustManagerFactory;\n+import javax.net.ssl.X509TrustManager;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.lutron.internal.config.LeapBridgeConfig;\n+import org.openhab.binding.lutron.internal.discovery.LeapDeviceDiscoveryService;\n+import org.openhab.binding.lutron.internal.protocol.FanSpeedType;\n+import org.openhab.binding.lutron.internal.protocol.GroupCommand;\n+import org.openhab.binding.lutron.internal.protocol.LutronCommandNew;\n+import org.openhab.binding.lutron.internal.protocol.OutputCommand;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapCommand;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapMessageParser;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapMessageParserCallbacks;\n+import org.openhab.binding.lutron.internal.protocol.leap.Request;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Area;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ButtonGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Device;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.OccupancyGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ZoneStatus;\n+import org.openhab.binding.lutron.internal.protocol.lip.LutronCommandType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Bridge handler responsible for communicating with Lutron hubs that support the LEAP protocol, such as Caseta and\n+ * RA2 Select.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LeapBridgeHandler extends LutronBridgeHandler implements LeapMessageParserCallbacks {\n+    private static final int DEFAULT_RECONNECT_MINUTES = 5;\n+    private static final int DEFAULT_HEARTBEAT_MINUTES = 5;\n+    private static final long KEEPALIVE_TIMEOUT_SECONDS = 30;\n+\n+    private static final String STATUS_INITIALIZING = \"Initializing\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(LeapBridgeHandler.class);\n+\n+    private @NonNullByDefault({}) LeapBridgeConfig config;\n+    private int reconnectInterval;\n+    private int heartbeatInterval;\n+    private int sendDelay;\n+\n+    private @NonNullByDefault({}) SSLSocketFactory sslsocketfactory;\n+    private @Nullable SSLSocket sslsocket;\n+    private @Nullable BufferedWriter writer;\n+    private @Nullable BufferedReader reader;\n+\n+    private @NonNullByDefault({}) LeapMessageParser leapMessageParser;\n+\n+    private final BlockingQueue<LeapCommand> sendQueue = new LinkedBlockingQueue<>();\n+\n+    private @Nullable Thread senderThread;\n+    private @Nullable Thread readerThread;\n+\n+    private @Nullable ScheduledFuture<?> keepAlive;\n+    private @Nullable ScheduledFuture<?> keepAliveReconnect;\n+    private @Nullable ScheduledFuture<?> connectRetryJob;\n+    private final Object keepAliveReconnectLock = new Object();\n+\n+    private final Map<Integer, Integer> zoneToDevice = new HashMap<>();\n+    private final Map<Integer, Integer> deviceToZone = new HashMap<>();\n+    private final Object zoneMapsLock = new Object();\n+\n+    private @Nullable Map<Integer, List<Integer>> deviceButtonMap;\n+    private final Object deviceButtonMapLock = new Object();\n+\n+    private final AtomicBoolean deviceDataLoaded = new AtomicBoolean(false);\n+    private final AtomicBoolean buttonDataLoaded = new AtomicBoolean(false);\n+\n+    private final Map<Integer, LutronHandler> childHandlerMap = new ConcurrentHashMap<>();\n+    private final Map<Integer, OGroupHandler> groupHandlerMap = new ConcurrentHashMap<>();\n+\n+    private @Nullable LeapDeviceDiscoveryService discoveryService;\n+\n+    public void setDiscoveryService(LeapDeviceDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    public LeapBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+        leapMessageParser = new LeapMessageParser(this);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        SSLContext sslContext;\n+\n+        childHandlerMap.clear();\n+        groupHandlerMap.clear();\n+\n+        config = getConfigAs(LeapBridgeConfig.class);\n+        String keystorePassword = (config.keystorePassword == null) ? \"\" : config.keystorePassword;\n+\n+        String ipAddress = config.ipAddress;\n+        if (ipAddress == null || ipAddress.isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"bridge address not specified\");\n+            return;\n+        }\n+\n+        reconnectInterval = (config.reconnect > 0) ? config.reconnect : DEFAULT_RECONNECT_MINUTES;\n+        heartbeatInterval = (config.heartbeat > 0) ? config.heartbeat : DEFAULT_HEARTBEAT_MINUTES;\n+        sendDelay = (config.delay < 0) ? 0 : config.delay;\n+\n+        if (config.keystore == null || keystorePassword == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Keystore/keystore password not configured\");\n+            return;\n+        } else {\n+            try (FileInputStream keystoreInputStream = new FileInputStream(config.keystore)) {\n+                logger.trace(\"Initializing keystore\");\n+                KeyStore keystore = KeyStore.getInstance(KeyStore.getDefaultType());\n+\n+                keystore.load(keystoreInputStream, keystorePassword.toCharArray());\n+\n+                logger.trace(\"Initializing SSL Context\");\n+                KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n+                kmf.init(keystore, keystorePassword.toCharArray());\n+\n+                TrustManager[] trustManagers;\n+                if (config.certValidate) {\n+                    // Use default trust manager which will attempt to validate server certificate from hub\n+                    TrustManagerFactory tmf = TrustManagerFactory\n+                            .getInstance(TrustManagerFactory.getDefaultAlgorithm());\n+                    tmf.init(keystore);\n+                    trustManagers = tmf.getTrustManagers();\n+                } else {\n+                    // Use no-op trust manager which will not verify certificates\n+                    trustManagers = defineNoOpTrustManager();\n+                }\n+\n+                sslContext = SSLContext.getInstance(\"TLS\");\n+                sslContext.init(kmf.getKeyManagers(), trustManagers, null);\n+\n+                sslsocketfactory = sslContext.getSocketFactory();\n+            } catch (FileNotFoundException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Keystore file not found\");\n+                return;\n+            } catch (CertificateException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Certificate exception\");\n+                return;\n+            } catch (UnrecoverableKeyException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"Key unrecoverable with supplied password\");\n+                return;\n+            } catch (KeyManagementException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Key management exception\");\n+                logger.debug(\"Key management exception\", e);\n+                return;\n+            } catch (KeyStoreException | NoSuchAlgorithmException | IOException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Error initializing keystore\");\n+                logger.debug(\"Error initializing keystore\", e);\n+                return;\n+            }\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Connecting\");\n+        scheduler.submit(this::connect); // start the async connect task\n+    }\n+\n+    /**\n+     * Return a no-op SSL trust manager which will not verify server or client certificates.\n+     */\n+    private TrustManager[] defineNoOpTrustManager() {\n+        return new TrustManager[] { new X509TrustManager() {\n+            @Override\n+            public void checkClientTrusted(final X509Certificate @Nullable [] chain, final @Nullable String authType) {\n+                logger.debug(\"Assuming client certificate is valid\");\n+                if (chain != null) {\n+                    for (int cert = 0; cert < chain.length; cert++) {\n+                        logger.trace(\"Subject DN: {}\", chain[cert].getSubjectDN());\n+                        logger.trace(\"Issuer DN: {}\", chain[cert].getIssuerDN());\n+                        logger.trace(\"Serial number {}:\", chain[cert].getSerialNumber());\n+                    }\n+                }\n+            }\n+\n+            @Override\n+            public void checkServerTrusted(final X509Certificate @Nullable [] chain, final @Nullable String authType) {\n+                logger.debug(\"Assuming server certificate is valid\");\n+                if (chain != null) {\n+                    for (int cert = 0; cert < chain.length; cert++) {\n+                        logger.trace(\"Subject DN: {}\", chain[cert].getSubjectDN());\n+                        logger.trace(\"Issuer DN: {}\", chain[cert].getIssuerDN());\n+                        logger.trace(\"Serial number: {}\", chain[cert].getSerialNumber());\n+                    }\n+                }\n+            }\n+\n+            @Override\n+            public X509Certificate @Nullable [] getAcceptedIssuers() {\n+                return null;\n+            }\n+        } };\n+    }\n+\n+    private synchronized void connect() {\n+        deviceDataLoaded.set(false);\n+        buttonDataLoaded.set(false);\n+\n+        try {\n+            logger.debug(\"Opening SSL connection to {}:{}\", config.ipAddress, config.port);\n+            SSLSocket sslsocket = (SSLSocket) sslsocketfactory.createSocket(config.ipAddress, config.port);\n+            sslsocket.startHandshake();\n+            writer = new BufferedWriter(new OutputStreamWriter(sslsocket.getOutputStream()));\n+            reader = new BufferedReader(new InputStreamReader(sslsocket.getInputStream()));\n+            this.sslsocket = sslsocket;\n+        } catch (UnknownHostException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Unknown host\");\n+            return;\n+        } catch (IllegalArgumentException e) {\n+            // port out of valid range\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Invalid port number\");\n+            return;\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Error opening SSL connection. Check log.\");\n+            logger.info(\"Error opening SSL connection: {}\", e.getMessage());\n+            disconnect();\n+            scheduleConnectRetry(reconnectInterval); // Possibly a temporary problem. Try again later.\n+            return;\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, STATUS_INITIALIZING);\n+\n+        Thread readerThread = new Thread(this::readerThreadJob, \"Lutron reader\");\n+        readerThread.setDaemon(true);\n+        readerThread.start();\n+        this.readerThread = readerThread;\n+\n+        Thread senderThread = new Thread(this::senderThreadJob, \"Lutron sender\");\n+        senderThread.setDaemon(true);\n+        senderThread.start();\n+        this.senderThread = senderThread;\n+\n+        sendCommand(new LeapCommand(Request.getButtonGroups()));\n+        queryDiscoveryData();\n+        sendCommand(new LeapCommand(Request.subscribeOccupancyGroupStatus()));\n+\n+        logger.debug(\"Starting keepAlive job with interval {}\", heartbeatInterval);\n+        keepAlive = scheduler.scheduleWithFixedDelay(this::sendKeepAlive, heartbeatInterval, heartbeatInterval,\n+                TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Called by connect() and discovery service to request fresh discovery data\n+     */\n+    public void queryDiscoveryData() {\n+        sendCommand(new LeapCommand(Request.getDevices()));\n+        sendCommand(new LeapCommand(Request.getAreas()));\n+        sendCommand(new LeapCommand(Request.getOccupancyGroups()));\n+    }\n+\n+    private void scheduleConnectRetry(long waitMinutes) {\n+        logger.debug(\"Scheduling connection retry in {} minutes\", waitMinutes);\n+        connectRetryJob = scheduler.schedule(this::connect, waitMinutes, TimeUnit.MINUTES);\n+    }\n+\n+    private synchronized void disconnect() {\n+        logger.debug(\"Disconnecting\");\n+\n+        Thread senderThread = this.senderThread;\n+        Thread readerThread = this.readerThread;\n+\n+        if (connectRetryJob != null) {\n+            connectRetryJob.cancel(true);\n+        }\n+        if (keepAlive != null) {\n+            keepAlive.cancel(true);\n+        }\n+\n+        // May be called from keepAliveReconnect thread, so call cancel with false\n+        reconnectTaskCancel(false);\n+\n+        if (senderThread != null && senderThread.isAlive()) {\n+            senderThread.interrupt();\n+        }\n+        if (readerThread != null && readerThread.isAlive()) {\n+            readerThread.interrupt();\n+        }\n+        if (sslsocket != null) {\n+            try {\n+                sslsocket.close();\n+            } catch (IOException e) {\n+                logger.debug(\"Error closing SSL socket: {}\", e.getMessage());\n+            }\n+            sslsocket = null;\n+        }\n+        if (reader != null) {\n+            try {\n+                reader.close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "deb48c1252ee18917f2f9e19cf0158fedb164659"}, "originalPosition": 348}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNTA3OTIxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.lutron/src/main/java/org/openhab/binding/lutron/internal/handler/LeapBridgeHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwMjowODoyNFrOHdgCug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwMjowODoyNFrOHdgCug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY5NTczOA==", "bodyText": "and here", "url": "https://github.com/openhab/openhab-addons/pull/8650#discussion_r500695738", "createdAt": "2020-10-07T02:08:24Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lutron/src/main/java/org/openhab/binding/lutron/internal/handler/LeapBridgeHandler.java", "diffHunk": "@@ -0,0 +1,763 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lutron.internal.handler;\n+\n+import static org.openhab.binding.lutron.internal.LutronBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.net.UnknownHostException;\n+import java.security.KeyManagementException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.UnrecoverableKeyException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManager;\n+import javax.net.ssl.TrustManagerFactory;\n+import javax.net.ssl.X509TrustManager;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.lutron.internal.config.LeapBridgeConfig;\n+import org.openhab.binding.lutron.internal.discovery.LeapDeviceDiscoveryService;\n+import org.openhab.binding.lutron.internal.protocol.FanSpeedType;\n+import org.openhab.binding.lutron.internal.protocol.GroupCommand;\n+import org.openhab.binding.lutron.internal.protocol.LutronCommandNew;\n+import org.openhab.binding.lutron.internal.protocol.OutputCommand;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapCommand;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapMessageParser;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapMessageParserCallbacks;\n+import org.openhab.binding.lutron.internal.protocol.leap.Request;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Area;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ButtonGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Device;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.OccupancyGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ZoneStatus;\n+import org.openhab.binding.lutron.internal.protocol.lip.LutronCommandType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Bridge handler responsible for communicating with Lutron hubs that support the LEAP protocol, such as Caseta and\n+ * RA2 Select.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LeapBridgeHandler extends LutronBridgeHandler implements LeapMessageParserCallbacks {\n+    private static final int DEFAULT_RECONNECT_MINUTES = 5;\n+    private static final int DEFAULT_HEARTBEAT_MINUTES = 5;\n+    private static final long KEEPALIVE_TIMEOUT_SECONDS = 30;\n+\n+    private static final String STATUS_INITIALIZING = \"Initializing\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(LeapBridgeHandler.class);\n+\n+    private @NonNullByDefault({}) LeapBridgeConfig config;\n+    private int reconnectInterval;\n+    private int heartbeatInterval;\n+    private int sendDelay;\n+\n+    private @NonNullByDefault({}) SSLSocketFactory sslsocketfactory;\n+    private @Nullable SSLSocket sslsocket;\n+    private @Nullable BufferedWriter writer;\n+    private @Nullable BufferedReader reader;\n+\n+    private @NonNullByDefault({}) LeapMessageParser leapMessageParser;\n+\n+    private final BlockingQueue<LeapCommand> sendQueue = new LinkedBlockingQueue<>();\n+\n+    private @Nullable Thread senderThread;\n+    private @Nullable Thread readerThread;\n+\n+    private @Nullable ScheduledFuture<?> keepAlive;\n+    private @Nullable ScheduledFuture<?> keepAliveReconnect;\n+    private @Nullable ScheduledFuture<?> connectRetryJob;\n+    private final Object keepAliveReconnectLock = new Object();\n+\n+    private final Map<Integer, Integer> zoneToDevice = new HashMap<>();\n+    private final Map<Integer, Integer> deviceToZone = new HashMap<>();\n+    private final Object zoneMapsLock = new Object();\n+\n+    private @Nullable Map<Integer, List<Integer>> deviceButtonMap;\n+    private final Object deviceButtonMapLock = new Object();\n+\n+    private final AtomicBoolean deviceDataLoaded = new AtomicBoolean(false);\n+    private final AtomicBoolean buttonDataLoaded = new AtomicBoolean(false);\n+\n+    private final Map<Integer, LutronHandler> childHandlerMap = new ConcurrentHashMap<>();\n+    private final Map<Integer, OGroupHandler> groupHandlerMap = new ConcurrentHashMap<>();\n+\n+    private @Nullable LeapDeviceDiscoveryService discoveryService;\n+\n+    public void setDiscoveryService(LeapDeviceDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    public LeapBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+        leapMessageParser = new LeapMessageParser(this);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        SSLContext sslContext;\n+\n+        childHandlerMap.clear();\n+        groupHandlerMap.clear();\n+\n+        config = getConfigAs(LeapBridgeConfig.class);\n+        String keystorePassword = (config.keystorePassword == null) ? \"\" : config.keystorePassword;\n+\n+        String ipAddress = config.ipAddress;\n+        if (ipAddress == null || ipAddress.isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"bridge address not specified\");\n+            return;\n+        }\n+\n+        reconnectInterval = (config.reconnect > 0) ? config.reconnect : DEFAULT_RECONNECT_MINUTES;\n+        heartbeatInterval = (config.heartbeat > 0) ? config.heartbeat : DEFAULT_HEARTBEAT_MINUTES;\n+        sendDelay = (config.delay < 0) ? 0 : config.delay;\n+\n+        if (config.keystore == null || keystorePassword == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Keystore/keystore password not configured\");\n+            return;\n+        } else {\n+            try (FileInputStream keystoreInputStream = new FileInputStream(config.keystore)) {\n+                logger.trace(\"Initializing keystore\");\n+                KeyStore keystore = KeyStore.getInstance(KeyStore.getDefaultType());\n+\n+                keystore.load(keystoreInputStream, keystorePassword.toCharArray());\n+\n+                logger.trace(\"Initializing SSL Context\");\n+                KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n+                kmf.init(keystore, keystorePassword.toCharArray());\n+\n+                TrustManager[] trustManagers;\n+                if (config.certValidate) {\n+                    // Use default trust manager which will attempt to validate server certificate from hub\n+                    TrustManagerFactory tmf = TrustManagerFactory\n+                            .getInstance(TrustManagerFactory.getDefaultAlgorithm());\n+                    tmf.init(keystore);\n+                    trustManagers = tmf.getTrustManagers();\n+                } else {\n+                    // Use no-op trust manager which will not verify certificates\n+                    trustManagers = defineNoOpTrustManager();\n+                }\n+\n+                sslContext = SSLContext.getInstance(\"TLS\");\n+                sslContext.init(kmf.getKeyManagers(), trustManagers, null);\n+\n+                sslsocketfactory = sslContext.getSocketFactory();\n+            } catch (FileNotFoundException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Keystore file not found\");\n+                return;\n+            } catch (CertificateException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Certificate exception\");\n+                return;\n+            } catch (UnrecoverableKeyException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"Key unrecoverable with supplied password\");\n+                return;\n+            } catch (KeyManagementException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Key management exception\");\n+                logger.debug(\"Key management exception\", e);\n+                return;\n+            } catch (KeyStoreException | NoSuchAlgorithmException | IOException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Error initializing keystore\");\n+                logger.debug(\"Error initializing keystore\", e);\n+                return;\n+            }\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Connecting\");\n+        scheduler.submit(this::connect); // start the async connect task\n+    }\n+\n+    /**\n+     * Return a no-op SSL trust manager which will not verify server or client certificates.\n+     */\n+    private TrustManager[] defineNoOpTrustManager() {\n+        return new TrustManager[] { new X509TrustManager() {\n+            @Override\n+            public void checkClientTrusted(final X509Certificate @Nullable [] chain, final @Nullable String authType) {\n+                logger.debug(\"Assuming client certificate is valid\");\n+                if (chain != null) {\n+                    for (int cert = 0; cert < chain.length; cert++) {\n+                        logger.trace(\"Subject DN: {}\", chain[cert].getSubjectDN());\n+                        logger.trace(\"Issuer DN: {}\", chain[cert].getIssuerDN());\n+                        logger.trace(\"Serial number {}:\", chain[cert].getSerialNumber());\n+                    }\n+                }\n+            }\n+\n+            @Override\n+            public void checkServerTrusted(final X509Certificate @Nullable [] chain, final @Nullable String authType) {\n+                logger.debug(\"Assuming server certificate is valid\");\n+                if (chain != null) {\n+                    for (int cert = 0; cert < chain.length; cert++) {\n+                        logger.trace(\"Subject DN: {}\", chain[cert].getSubjectDN());\n+                        logger.trace(\"Issuer DN: {}\", chain[cert].getIssuerDN());\n+                        logger.trace(\"Serial number: {}\", chain[cert].getSerialNumber());\n+                    }\n+                }\n+            }\n+\n+            @Override\n+            public X509Certificate @Nullable [] getAcceptedIssuers() {\n+                return null;\n+            }\n+        } };\n+    }\n+\n+    private synchronized void connect() {\n+        deviceDataLoaded.set(false);\n+        buttonDataLoaded.set(false);\n+\n+        try {\n+            logger.debug(\"Opening SSL connection to {}:{}\", config.ipAddress, config.port);\n+            SSLSocket sslsocket = (SSLSocket) sslsocketfactory.createSocket(config.ipAddress, config.port);\n+            sslsocket.startHandshake();\n+            writer = new BufferedWriter(new OutputStreamWriter(sslsocket.getOutputStream()));\n+            reader = new BufferedReader(new InputStreamReader(sslsocket.getInputStream()));\n+            this.sslsocket = sslsocket;\n+        } catch (UnknownHostException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Unknown host\");\n+            return;\n+        } catch (IllegalArgumentException e) {\n+            // port out of valid range\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Invalid port number\");\n+            return;\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Error opening SSL connection. Check log.\");\n+            logger.info(\"Error opening SSL connection: {}\", e.getMessage());\n+            disconnect();\n+            scheduleConnectRetry(reconnectInterval); // Possibly a temporary problem. Try again later.\n+            return;\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, STATUS_INITIALIZING);\n+\n+        Thread readerThread = new Thread(this::readerThreadJob, \"Lutron reader\");\n+        readerThread.setDaemon(true);\n+        readerThread.start();\n+        this.readerThread = readerThread;\n+\n+        Thread senderThread = new Thread(this::senderThreadJob, \"Lutron sender\");\n+        senderThread.setDaemon(true);\n+        senderThread.start();\n+        this.senderThread = senderThread;\n+\n+        sendCommand(new LeapCommand(Request.getButtonGroups()));\n+        queryDiscoveryData();\n+        sendCommand(new LeapCommand(Request.subscribeOccupancyGroupStatus()));\n+\n+        logger.debug(\"Starting keepAlive job with interval {}\", heartbeatInterval);\n+        keepAlive = scheduler.scheduleWithFixedDelay(this::sendKeepAlive, heartbeatInterval, heartbeatInterval,\n+                TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Called by connect() and discovery service to request fresh discovery data\n+     */\n+    public void queryDiscoveryData() {\n+        sendCommand(new LeapCommand(Request.getDevices()));\n+        sendCommand(new LeapCommand(Request.getAreas()));\n+        sendCommand(new LeapCommand(Request.getOccupancyGroups()));\n+    }\n+\n+    private void scheduleConnectRetry(long waitMinutes) {\n+        logger.debug(\"Scheduling connection retry in {} minutes\", waitMinutes);\n+        connectRetryJob = scheduler.schedule(this::connect, waitMinutes, TimeUnit.MINUTES);\n+    }\n+\n+    private synchronized void disconnect() {\n+        logger.debug(\"Disconnecting\");\n+\n+        Thread senderThread = this.senderThread;\n+        Thread readerThread = this.readerThread;\n+\n+        if (connectRetryJob != null) {\n+            connectRetryJob.cancel(true);\n+        }\n+        if (keepAlive != null) {\n+            keepAlive.cancel(true);\n+        }\n+\n+        // May be called from keepAliveReconnect thread, so call cancel with false\n+        reconnectTaskCancel(false);\n+\n+        if (senderThread != null && senderThread.isAlive()) {\n+            senderThread.interrupt();\n+        }\n+        if (readerThread != null && readerThread.isAlive()) {\n+            readerThread.interrupt();\n+        }\n+        if (sslsocket != null) {\n+            try {\n+                sslsocket.close();\n+            } catch (IOException e) {\n+                logger.debug(\"Error closing SSL socket: {}\", e.getMessage());\n+            }\n+            sslsocket = null;\n+        }\n+        if (reader != null) {\n+            try {\n+                reader.close();\n+            } catch (IOException e) {\n+                logger.debug(\"Error closing reader: {}\", e.getMessage());\n+            }\n+        }\n+        if (writer != null) {\n+            try {\n+                writer.close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "deb48c1252ee18917f2f9e19cf0158fedb164659"}, "originalPosition": 355}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNTA4MDU1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.lutron/src/main/java/org/openhab/binding/lutron/internal/handler/LeapBridgeHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwMjowOTowNFrOHdgDag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwMjowOTowNFrOHdgDag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY5NTkxNA==", "bodyText": "cache these in a local variable as well.", "url": "https://github.com/openhab/openhab-addons/pull/8650#discussion_r500695914", "createdAt": "2020-10-07T02:09:04Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lutron/src/main/java/org/openhab/binding/lutron/internal/handler/LeapBridgeHandler.java", "diffHunk": "@@ -0,0 +1,763 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lutron.internal.handler;\n+\n+import static org.openhab.binding.lutron.internal.LutronBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.net.UnknownHostException;\n+import java.security.KeyManagementException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.UnrecoverableKeyException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManager;\n+import javax.net.ssl.TrustManagerFactory;\n+import javax.net.ssl.X509TrustManager;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.lutron.internal.config.LeapBridgeConfig;\n+import org.openhab.binding.lutron.internal.discovery.LeapDeviceDiscoveryService;\n+import org.openhab.binding.lutron.internal.protocol.FanSpeedType;\n+import org.openhab.binding.lutron.internal.protocol.GroupCommand;\n+import org.openhab.binding.lutron.internal.protocol.LutronCommandNew;\n+import org.openhab.binding.lutron.internal.protocol.OutputCommand;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapCommand;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapMessageParser;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapMessageParserCallbacks;\n+import org.openhab.binding.lutron.internal.protocol.leap.Request;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Area;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ButtonGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Device;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.OccupancyGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ZoneStatus;\n+import org.openhab.binding.lutron.internal.protocol.lip.LutronCommandType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Bridge handler responsible for communicating with Lutron hubs that support the LEAP protocol, such as Caseta and\n+ * RA2 Select.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LeapBridgeHandler extends LutronBridgeHandler implements LeapMessageParserCallbacks {\n+    private static final int DEFAULT_RECONNECT_MINUTES = 5;\n+    private static final int DEFAULT_HEARTBEAT_MINUTES = 5;\n+    private static final long KEEPALIVE_TIMEOUT_SECONDS = 30;\n+\n+    private static final String STATUS_INITIALIZING = \"Initializing\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(LeapBridgeHandler.class);\n+\n+    private @NonNullByDefault({}) LeapBridgeConfig config;\n+    private int reconnectInterval;\n+    private int heartbeatInterval;\n+    private int sendDelay;\n+\n+    private @NonNullByDefault({}) SSLSocketFactory sslsocketfactory;\n+    private @Nullable SSLSocket sslsocket;\n+    private @Nullable BufferedWriter writer;\n+    private @Nullable BufferedReader reader;\n+\n+    private @NonNullByDefault({}) LeapMessageParser leapMessageParser;\n+\n+    private final BlockingQueue<LeapCommand> sendQueue = new LinkedBlockingQueue<>();\n+\n+    private @Nullable Thread senderThread;\n+    private @Nullable Thread readerThread;\n+\n+    private @Nullable ScheduledFuture<?> keepAlive;\n+    private @Nullable ScheduledFuture<?> keepAliveReconnect;\n+    private @Nullable ScheduledFuture<?> connectRetryJob;\n+    private final Object keepAliveReconnectLock = new Object();\n+\n+    private final Map<Integer, Integer> zoneToDevice = new HashMap<>();\n+    private final Map<Integer, Integer> deviceToZone = new HashMap<>();\n+    private final Object zoneMapsLock = new Object();\n+\n+    private @Nullable Map<Integer, List<Integer>> deviceButtonMap;\n+    private final Object deviceButtonMapLock = new Object();\n+\n+    private final AtomicBoolean deviceDataLoaded = new AtomicBoolean(false);\n+    private final AtomicBoolean buttonDataLoaded = new AtomicBoolean(false);\n+\n+    private final Map<Integer, LutronHandler> childHandlerMap = new ConcurrentHashMap<>();\n+    private final Map<Integer, OGroupHandler> groupHandlerMap = new ConcurrentHashMap<>();\n+\n+    private @Nullable LeapDeviceDiscoveryService discoveryService;\n+\n+    public void setDiscoveryService(LeapDeviceDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    public LeapBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+        leapMessageParser = new LeapMessageParser(this);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        SSLContext sslContext;\n+\n+        childHandlerMap.clear();\n+        groupHandlerMap.clear();\n+\n+        config = getConfigAs(LeapBridgeConfig.class);\n+        String keystorePassword = (config.keystorePassword == null) ? \"\" : config.keystorePassword;\n+\n+        String ipAddress = config.ipAddress;\n+        if (ipAddress == null || ipAddress.isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"bridge address not specified\");\n+            return;\n+        }\n+\n+        reconnectInterval = (config.reconnect > 0) ? config.reconnect : DEFAULT_RECONNECT_MINUTES;\n+        heartbeatInterval = (config.heartbeat > 0) ? config.heartbeat : DEFAULT_HEARTBEAT_MINUTES;\n+        sendDelay = (config.delay < 0) ? 0 : config.delay;\n+\n+        if (config.keystore == null || keystorePassword == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Keystore/keystore password not configured\");\n+            return;\n+        } else {\n+            try (FileInputStream keystoreInputStream = new FileInputStream(config.keystore)) {\n+                logger.trace(\"Initializing keystore\");\n+                KeyStore keystore = KeyStore.getInstance(KeyStore.getDefaultType());\n+\n+                keystore.load(keystoreInputStream, keystorePassword.toCharArray());\n+\n+                logger.trace(\"Initializing SSL Context\");\n+                KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n+                kmf.init(keystore, keystorePassword.toCharArray());\n+\n+                TrustManager[] trustManagers;\n+                if (config.certValidate) {\n+                    // Use default trust manager which will attempt to validate server certificate from hub\n+                    TrustManagerFactory tmf = TrustManagerFactory\n+                            .getInstance(TrustManagerFactory.getDefaultAlgorithm());\n+                    tmf.init(keystore);\n+                    trustManagers = tmf.getTrustManagers();\n+                } else {\n+                    // Use no-op trust manager which will not verify certificates\n+                    trustManagers = defineNoOpTrustManager();\n+                }\n+\n+                sslContext = SSLContext.getInstance(\"TLS\");\n+                sslContext.init(kmf.getKeyManagers(), trustManagers, null);\n+\n+                sslsocketfactory = sslContext.getSocketFactory();\n+            } catch (FileNotFoundException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Keystore file not found\");\n+                return;\n+            } catch (CertificateException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Certificate exception\");\n+                return;\n+            } catch (UnrecoverableKeyException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"Key unrecoverable with supplied password\");\n+                return;\n+            } catch (KeyManagementException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Key management exception\");\n+                logger.debug(\"Key management exception\", e);\n+                return;\n+            } catch (KeyStoreException | NoSuchAlgorithmException | IOException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Error initializing keystore\");\n+                logger.debug(\"Error initializing keystore\", e);\n+                return;\n+            }\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Connecting\");\n+        scheduler.submit(this::connect); // start the async connect task\n+    }\n+\n+    /**\n+     * Return a no-op SSL trust manager which will not verify server or client certificates.\n+     */\n+    private TrustManager[] defineNoOpTrustManager() {\n+        return new TrustManager[] { new X509TrustManager() {\n+            @Override\n+            public void checkClientTrusted(final X509Certificate @Nullable [] chain, final @Nullable String authType) {\n+                logger.debug(\"Assuming client certificate is valid\");\n+                if (chain != null) {\n+                    for (int cert = 0; cert < chain.length; cert++) {\n+                        logger.trace(\"Subject DN: {}\", chain[cert].getSubjectDN());\n+                        logger.trace(\"Issuer DN: {}\", chain[cert].getIssuerDN());\n+                        logger.trace(\"Serial number {}:\", chain[cert].getSerialNumber());\n+                    }\n+                }\n+            }\n+\n+            @Override\n+            public void checkServerTrusted(final X509Certificate @Nullable [] chain, final @Nullable String authType) {\n+                logger.debug(\"Assuming server certificate is valid\");\n+                if (chain != null) {\n+                    for (int cert = 0; cert < chain.length; cert++) {\n+                        logger.trace(\"Subject DN: {}\", chain[cert].getSubjectDN());\n+                        logger.trace(\"Issuer DN: {}\", chain[cert].getIssuerDN());\n+                        logger.trace(\"Serial number: {}\", chain[cert].getSerialNumber());\n+                    }\n+                }\n+            }\n+\n+            @Override\n+            public X509Certificate @Nullable [] getAcceptedIssuers() {\n+                return null;\n+            }\n+        } };\n+    }\n+\n+    private synchronized void connect() {\n+        deviceDataLoaded.set(false);\n+        buttonDataLoaded.set(false);\n+\n+        try {\n+            logger.debug(\"Opening SSL connection to {}:{}\", config.ipAddress, config.port);\n+            SSLSocket sslsocket = (SSLSocket) sslsocketfactory.createSocket(config.ipAddress, config.port);\n+            sslsocket.startHandshake();\n+            writer = new BufferedWriter(new OutputStreamWriter(sslsocket.getOutputStream()));\n+            reader = new BufferedReader(new InputStreamReader(sslsocket.getInputStream()));\n+            this.sslsocket = sslsocket;\n+        } catch (UnknownHostException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Unknown host\");\n+            return;\n+        } catch (IllegalArgumentException e) {\n+            // port out of valid range\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Invalid port number\");\n+            return;\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Error opening SSL connection. Check log.\");\n+            logger.info(\"Error opening SSL connection: {}\", e.getMessage());\n+            disconnect();\n+            scheduleConnectRetry(reconnectInterval); // Possibly a temporary problem. Try again later.\n+            return;\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, STATUS_INITIALIZING);\n+\n+        Thread readerThread = new Thread(this::readerThreadJob, \"Lutron reader\");\n+        readerThread.setDaemon(true);\n+        readerThread.start();\n+        this.readerThread = readerThread;\n+\n+        Thread senderThread = new Thread(this::senderThreadJob, \"Lutron sender\");\n+        senderThread.setDaemon(true);\n+        senderThread.start();\n+        this.senderThread = senderThread;\n+\n+        sendCommand(new LeapCommand(Request.getButtonGroups()));\n+        queryDiscoveryData();\n+        sendCommand(new LeapCommand(Request.subscribeOccupancyGroupStatus()));\n+\n+        logger.debug(\"Starting keepAlive job with interval {}\", heartbeatInterval);\n+        keepAlive = scheduler.scheduleWithFixedDelay(this::sendKeepAlive, heartbeatInterval, heartbeatInterval,\n+                TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Called by connect() and discovery service to request fresh discovery data\n+     */\n+    public void queryDiscoveryData() {\n+        sendCommand(new LeapCommand(Request.getDevices()));\n+        sendCommand(new LeapCommand(Request.getAreas()));\n+        sendCommand(new LeapCommand(Request.getOccupancyGroups()));\n+    }\n+\n+    private void scheduleConnectRetry(long waitMinutes) {\n+        logger.debug(\"Scheduling connection retry in {} minutes\", waitMinutes);\n+        connectRetryJob = scheduler.schedule(this::connect, waitMinutes, TimeUnit.MINUTES);\n+    }\n+\n+    private synchronized void disconnect() {\n+        logger.debug(\"Disconnecting\");\n+\n+        Thread senderThread = this.senderThread;\n+        Thread readerThread = this.readerThread;\n+\n+        if (connectRetryJob != null) {\n+            connectRetryJob.cancel(true);\n+        }\n+        if (keepAlive != null) {\n+            keepAlive.cancel(true);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "deb48c1252ee18917f2f9e19cf0158fedb164659"}, "originalPosition": 327}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNTA5OTgxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.lutron/src/main/java/org/openhab/binding/lutron/internal/handler/LeapBridgeHandler.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwMjoxNzo0N1rOHdgN-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQyMzowNToyNFrOHfaxSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY5ODYxOQ==", "bodyText": "Since this is asynchronous, if this handler is disposed immediately after getting initialized there is a chance it could get disposed before the connection finishes which would result in an illegal state.\nThe only slow operation you are performing as part of connect is the creation of the SSLSocket. Perhaps you could focus on just making that asynchronous instead.\nAnother option would be to cancel the future handle interrupt within your connect method.", "url": "https://github.com/openhab/openhab-addons/pull/8650#discussion_r500698619", "createdAt": "2020-10-07T02:17:47Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lutron/src/main/java/org/openhab/binding/lutron/internal/handler/LeapBridgeHandler.java", "diffHunk": "@@ -0,0 +1,763 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lutron.internal.handler;\n+\n+import static org.openhab.binding.lutron.internal.LutronBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.net.UnknownHostException;\n+import java.security.KeyManagementException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.UnrecoverableKeyException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManager;\n+import javax.net.ssl.TrustManagerFactory;\n+import javax.net.ssl.X509TrustManager;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.lutron.internal.config.LeapBridgeConfig;\n+import org.openhab.binding.lutron.internal.discovery.LeapDeviceDiscoveryService;\n+import org.openhab.binding.lutron.internal.protocol.FanSpeedType;\n+import org.openhab.binding.lutron.internal.protocol.GroupCommand;\n+import org.openhab.binding.lutron.internal.protocol.LutronCommandNew;\n+import org.openhab.binding.lutron.internal.protocol.OutputCommand;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapCommand;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapMessageParser;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapMessageParserCallbacks;\n+import org.openhab.binding.lutron.internal.protocol.leap.Request;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Area;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ButtonGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Device;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.OccupancyGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ZoneStatus;\n+import org.openhab.binding.lutron.internal.protocol.lip.LutronCommandType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Bridge handler responsible for communicating with Lutron hubs that support the LEAP protocol, such as Caseta and\n+ * RA2 Select.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LeapBridgeHandler extends LutronBridgeHandler implements LeapMessageParserCallbacks {\n+    private static final int DEFAULT_RECONNECT_MINUTES = 5;\n+    private static final int DEFAULT_HEARTBEAT_MINUTES = 5;\n+    private static final long KEEPALIVE_TIMEOUT_SECONDS = 30;\n+\n+    private static final String STATUS_INITIALIZING = \"Initializing\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(LeapBridgeHandler.class);\n+\n+    private @NonNullByDefault({}) LeapBridgeConfig config;\n+    private int reconnectInterval;\n+    private int heartbeatInterval;\n+    private int sendDelay;\n+\n+    private @NonNullByDefault({}) SSLSocketFactory sslsocketfactory;\n+    private @Nullable SSLSocket sslsocket;\n+    private @Nullable BufferedWriter writer;\n+    private @Nullable BufferedReader reader;\n+\n+    private @NonNullByDefault({}) LeapMessageParser leapMessageParser;\n+\n+    private final BlockingQueue<LeapCommand> sendQueue = new LinkedBlockingQueue<>();\n+\n+    private @Nullable Thread senderThread;\n+    private @Nullable Thread readerThread;\n+\n+    private @Nullable ScheduledFuture<?> keepAlive;\n+    private @Nullable ScheduledFuture<?> keepAliveReconnect;\n+    private @Nullable ScheduledFuture<?> connectRetryJob;\n+    private final Object keepAliveReconnectLock = new Object();\n+\n+    private final Map<Integer, Integer> zoneToDevice = new HashMap<>();\n+    private final Map<Integer, Integer> deviceToZone = new HashMap<>();\n+    private final Object zoneMapsLock = new Object();\n+\n+    private @Nullable Map<Integer, List<Integer>> deviceButtonMap;\n+    private final Object deviceButtonMapLock = new Object();\n+\n+    private final AtomicBoolean deviceDataLoaded = new AtomicBoolean(false);\n+    private final AtomicBoolean buttonDataLoaded = new AtomicBoolean(false);\n+\n+    private final Map<Integer, LutronHandler> childHandlerMap = new ConcurrentHashMap<>();\n+    private final Map<Integer, OGroupHandler> groupHandlerMap = new ConcurrentHashMap<>();\n+\n+    private @Nullable LeapDeviceDiscoveryService discoveryService;\n+\n+    public void setDiscoveryService(LeapDeviceDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    public LeapBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+        leapMessageParser = new LeapMessageParser(this);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        SSLContext sslContext;\n+\n+        childHandlerMap.clear();\n+        groupHandlerMap.clear();\n+\n+        config = getConfigAs(LeapBridgeConfig.class);\n+        String keystorePassword = (config.keystorePassword == null) ? \"\" : config.keystorePassword;\n+\n+        String ipAddress = config.ipAddress;\n+        if (ipAddress == null || ipAddress.isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"bridge address not specified\");\n+            return;\n+        }\n+\n+        reconnectInterval = (config.reconnect > 0) ? config.reconnect : DEFAULT_RECONNECT_MINUTES;\n+        heartbeatInterval = (config.heartbeat > 0) ? config.heartbeat : DEFAULT_HEARTBEAT_MINUTES;\n+        sendDelay = (config.delay < 0) ? 0 : config.delay;\n+\n+        if (config.keystore == null || keystorePassword == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Keystore/keystore password not configured\");\n+            return;\n+        } else {\n+            try (FileInputStream keystoreInputStream = new FileInputStream(config.keystore)) {\n+                logger.trace(\"Initializing keystore\");\n+                KeyStore keystore = KeyStore.getInstance(KeyStore.getDefaultType());\n+\n+                keystore.load(keystoreInputStream, keystorePassword.toCharArray());\n+\n+                logger.trace(\"Initializing SSL Context\");\n+                KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n+                kmf.init(keystore, keystorePassword.toCharArray());\n+\n+                TrustManager[] trustManagers;\n+                if (config.certValidate) {\n+                    // Use default trust manager which will attempt to validate server certificate from hub\n+                    TrustManagerFactory tmf = TrustManagerFactory\n+                            .getInstance(TrustManagerFactory.getDefaultAlgorithm());\n+                    tmf.init(keystore);\n+                    trustManagers = tmf.getTrustManagers();\n+                } else {\n+                    // Use no-op trust manager which will not verify certificates\n+                    trustManagers = defineNoOpTrustManager();\n+                }\n+\n+                sslContext = SSLContext.getInstance(\"TLS\");\n+                sslContext.init(kmf.getKeyManagers(), trustManagers, null);\n+\n+                sslsocketfactory = sslContext.getSocketFactory();\n+            } catch (FileNotFoundException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Keystore file not found\");\n+                return;\n+            } catch (CertificateException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Certificate exception\");\n+                return;\n+            } catch (UnrecoverableKeyException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"Key unrecoverable with supplied password\");\n+                return;\n+            } catch (KeyManagementException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Key management exception\");\n+                logger.debug(\"Key management exception\", e);\n+                return;\n+            } catch (KeyStoreException | NoSuchAlgorithmException | IOException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Error initializing keystore\");\n+                logger.debug(\"Error initializing keystore\", e);\n+                return;\n+            }\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Connecting\");\n+        scheduler.submit(this::connect); // start the async connect task", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "deb48c1252ee18917f2f9e19cf0158fedb164659"}, "originalPosition": 215}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMwMDU1NA==", "bodyText": "Since this is asynchronous, if this handler is disposed immediately after getting initialized there is a chance it could get disposed before the connection finishes which would result in an illegal state.\n\nThat\u2019s a good point. I think most bindings that open some sort of network connection use pretty much the same pattern, though. If there is a real possibility of dispose() being called before the async part of initialization is done, maybe the framework should be modified to keep that from happening, or some recommendation should be made in the docs about how best to deal with it?\n\nThe only slow operation you are performing as part of connect is the creation of the SSLSocket. Perhaps you could focus on just making that asynchronous instead.\n\nWell, connect() doesn\u2019t do much before creating the the SSL socket and starting the handshake, so I don\u2019t think that would help too much. Even after opening the connection, it just starts a couple of threads and queues a few commands for sending.\n\nAnother option would be to cancel the future handle interrupt within your connect method.\n\nI\u2019m not sure what you mean by this. I could save the Future returned by submit and attempt to call cancel on it in dispose(). But are createSocket() and startHandshake() even interruptible? And I assume dispose() would need to wait for connect() to exit before continuing to clean up, but I\u2019m not sure what the best way to do that is.", "url": "https://github.com/openhab/openhab-addons/pull/8650#discussion_r501300554", "createdAt": "2020-10-07T20:48:08Z", "author": {"login": "bobadair"}, "path": "bundles/org.openhab.binding.lutron/src/main/java/org/openhab/binding/lutron/internal/handler/LeapBridgeHandler.java", "diffHunk": "@@ -0,0 +1,763 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lutron.internal.handler;\n+\n+import static org.openhab.binding.lutron.internal.LutronBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.net.UnknownHostException;\n+import java.security.KeyManagementException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.UnrecoverableKeyException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManager;\n+import javax.net.ssl.TrustManagerFactory;\n+import javax.net.ssl.X509TrustManager;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.lutron.internal.config.LeapBridgeConfig;\n+import org.openhab.binding.lutron.internal.discovery.LeapDeviceDiscoveryService;\n+import org.openhab.binding.lutron.internal.protocol.FanSpeedType;\n+import org.openhab.binding.lutron.internal.protocol.GroupCommand;\n+import org.openhab.binding.lutron.internal.protocol.LutronCommandNew;\n+import org.openhab.binding.lutron.internal.protocol.OutputCommand;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapCommand;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapMessageParser;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapMessageParserCallbacks;\n+import org.openhab.binding.lutron.internal.protocol.leap.Request;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Area;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ButtonGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Device;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.OccupancyGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ZoneStatus;\n+import org.openhab.binding.lutron.internal.protocol.lip.LutronCommandType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Bridge handler responsible for communicating with Lutron hubs that support the LEAP protocol, such as Caseta and\n+ * RA2 Select.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LeapBridgeHandler extends LutronBridgeHandler implements LeapMessageParserCallbacks {\n+    private static final int DEFAULT_RECONNECT_MINUTES = 5;\n+    private static final int DEFAULT_HEARTBEAT_MINUTES = 5;\n+    private static final long KEEPALIVE_TIMEOUT_SECONDS = 30;\n+\n+    private static final String STATUS_INITIALIZING = \"Initializing\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(LeapBridgeHandler.class);\n+\n+    private @NonNullByDefault({}) LeapBridgeConfig config;\n+    private int reconnectInterval;\n+    private int heartbeatInterval;\n+    private int sendDelay;\n+\n+    private @NonNullByDefault({}) SSLSocketFactory sslsocketfactory;\n+    private @Nullable SSLSocket sslsocket;\n+    private @Nullable BufferedWriter writer;\n+    private @Nullable BufferedReader reader;\n+\n+    private @NonNullByDefault({}) LeapMessageParser leapMessageParser;\n+\n+    private final BlockingQueue<LeapCommand> sendQueue = new LinkedBlockingQueue<>();\n+\n+    private @Nullable Thread senderThread;\n+    private @Nullable Thread readerThread;\n+\n+    private @Nullable ScheduledFuture<?> keepAlive;\n+    private @Nullable ScheduledFuture<?> keepAliveReconnect;\n+    private @Nullable ScheduledFuture<?> connectRetryJob;\n+    private final Object keepAliveReconnectLock = new Object();\n+\n+    private final Map<Integer, Integer> zoneToDevice = new HashMap<>();\n+    private final Map<Integer, Integer> deviceToZone = new HashMap<>();\n+    private final Object zoneMapsLock = new Object();\n+\n+    private @Nullable Map<Integer, List<Integer>> deviceButtonMap;\n+    private final Object deviceButtonMapLock = new Object();\n+\n+    private final AtomicBoolean deviceDataLoaded = new AtomicBoolean(false);\n+    private final AtomicBoolean buttonDataLoaded = new AtomicBoolean(false);\n+\n+    private final Map<Integer, LutronHandler> childHandlerMap = new ConcurrentHashMap<>();\n+    private final Map<Integer, OGroupHandler> groupHandlerMap = new ConcurrentHashMap<>();\n+\n+    private @Nullable LeapDeviceDiscoveryService discoveryService;\n+\n+    public void setDiscoveryService(LeapDeviceDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    public LeapBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+        leapMessageParser = new LeapMessageParser(this);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        SSLContext sslContext;\n+\n+        childHandlerMap.clear();\n+        groupHandlerMap.clear();\n+\n+        config = getConfigAs(LeapBridgeConfig.class);\n+        String keystorePassword = (config.keystorePassword == null) ? \"\" : config.keystorePassword;\n+\n+        String ipAddress = config.ipAddress;\n+        if (ipAddress == null || ipAddress.isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"bridge address not specified\");\n+            return;\n+        }\n+\n+        reconnectInterval = (config.reconnect > 0) ? config.reconnect : DEFAULT_RECONNECT_MINUTES;\n+        heartbeatInterval = (config.heartbeat > 0) ? config.heartbeat : DEFAULT_HEARTBEAT_MINUTES;\n+        sendDelay = (config.delay < 0) ? 0 : config.delay;\n+\n+        if (config.keystore == null || keystorePassword == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Keystore/keystore password not configured\");\n+            return;\n+        } else {\n+            try (FileInputStream keystoreInputStream = new FileInputStream(config.keystore)) {\n+                logger.trace(\"Initializing keystore\");\n+                KeyStore keystore = KeyStore.getInstance(KeyStore.getDefaultType());\n+\n+                keystore.load(keystoreInputStream, keystorePassword.toCharArray());\n+\n+                logger.trace(\"Initializing SSL Context\");\n+                KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n+                kmf.init(keystore, keystorePassword.toCharArray());\n+\n+                TrustManager[] trustManagers;\n+                if (config.certValidate) {\n+                    // Use default trust manager which will attempt to validate server certificate from hub\n+                    TrustManagerFactory tmf = TrustManagerFactory\n+                            .getInstance(TrustManagerFactory.getDefaultAlgorithm());\n+                    tmf.init(keystore);\n+                    trustManagers = tmf.getTrustManagers();\n+                } else {\n+                    // Use no-op trust manager which will not verify certificates\n+                    trustManagers = defineNoOpTrustManager();\n+                }\n+\n+                sslContext = SSLContext.getInstance(\"TLS\");\n+                sslContext.init(kmf.getKeyManagers(), trustManagers, null);\n+\n+                sslsocketfactory = sslContext.getSocketFactory();\n+            } catch (FileNotFoundException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Keystore file not found\");\n+                return;\n+            } catch (CertificateException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Certificate exception\");\n+                return;\n+            } catch (UnrecoverableKeyException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"Key unrecoverable with supplied password\");\n+                return;\n+            } catch (KeyManagementException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Key management exception\");\n+                logger.debug(\"Key management exception\", e);\n+                return;\n+            } catch (KeyStoreException | NoSuchAlgorithmException | IOException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Error initializing keystore\");\n+                logger.debug(\"Error initializing keystore\", e);\n+                return;\n+            }\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Connecting\");\n+        scheduler.submit(this::connect); // start the async connect task", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY5ODYxOQ=="}, "originalCommit": {"oid": "deb48c1252ee18917f2f9e19cf0158fedb164659"}, "originalPosition": 215}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQ1MjMyNg==", "bodyText": "But are createSocket() and startHandshake() even interruptible? And I assume dispose() would need to wait for connect() to exit before continuing to clean up, but I\u2019m not sure what the best way to do that is.\n\nYou don't necessarily have to interrupt them so much as make sure that any results are silently discarded. You might have to do some synchronous blocks on your asynchronous stuff to make sure that a dispose() followed by an initialize() wouldn't cause some sort of collision on resource access (if it is even possible for such a collision).", "url": "https://github.com/openhab/openhab-addons/pull/8650#discussion_r501452326", "createdAt": "2020-10-08T05:12:49Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lutron/src/main/java/org/openhab/binding/lutron/internal/handler/LeapBridgeHandler.java", "diffHunk": "@@ -0,0 +1,763 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lutron.internal.handler;\n+\n+import static org.openhab.binding.lutron.internal.LutronBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.net.UnknownHostException;\n+import java.security.KeyManagementException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.UnrecoverableKeyException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManager;\n+import javax.net.ssl.TrustManagerFactory;\n+import javax.net.ssl.X509TrustManager;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.lutron.internal.config.LeapBridgeConfig;\n+import org.openhab.binding.lutron.internal.discovery.LeapDeviceDiscoveryService;\n+import org.openhab.binding.lutron.internal.protocol.FanSpeedType;\n+import org.openhab.binding.lutron.internal.protocol.GroupCommand;\n+import org.openhab.binding.lutron.internal.protocol.LutronCommandNew;\n+import org.openhab.binding.lutron.internal.protocol.OutputCommand;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapCommand;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapMessageParser;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapMessageParserCallbacks;\n+import org.openhab.binding.lutron.internal.protocol.leap.Request;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Area;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ButtonGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Device;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.OccupancyGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ZoneStatus;\n+import org.openhab.binding.lutron.internal.protocol.lip.LutronCommandType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Bridge handler responsible for communicating with Lutron hubs that support the LEAP protocol, such as Caseta and\n+ * RA2 Select.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LeapBridgeHandler extends LutronBridgeHandler implements LeapMessageParserCallbacks {\n+    private static final int DEFAULT_RECONNECT_MINUTES = 5;\n+    private static final int DEFAULT_HEARTBEAT_MINUTES = 5;\n+    private static final long KEEPALIVE_TIMEOUT_SECONDS = 30;\n+\n+    private static final String STATUS_INITIALIZING = \"Initializing\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(LeapBridgeHandler.class);\n+\n+    private @NonNullByDefault({}) LeapBridgeConfig config;\n+    private int reconnectInterval;\n+    private int heartbeatInterval;\n+    private int sendDelay;\n+\n+    private @NonNullByDefault({}) SSLSocketFactory sslsocketfactory;\n+    private @Nullable SSLSocket sslsocket;\n+    private @Nullable BufferedWriter writer;\n+    private @Nullable BufferedReader reader;\n+\n+    private @NonNullByDefault({}) LeapMessageParser leapMessageParser;\n+\n+    private final BlockingQueue<LeapCommand> sendQueue = new LinkedBlockingQueue<>();\n+\n+    private @Nullable Thread senderThread;\n+    private @Nullable Thread readerThread;\n+\n+    private @Nullable ScheduledFuture<?> keepAlive;\n+    private @Nullable ScheduledFuture<?> keepAliveReconnect;\n+    private @Nullable ScheduledFuture<?> connectRetryJob;\n+    private final Object keepAliveReconnectLock = new Object();\n+\n+    private final Map<Integer, Integer> zoneToDevice = new HashMap<>();\n+    private final Map<Integer, Integer> deviceToZone = new HashMap<>();\n+    private final Object zoneMapsLock = new Object();\n+\n+    private @Nullable Map<Integer, List<Integer>> deviceButtonMap;\n+    private final Object deviceButtonMapLock = new Object();\n+\n+    private final AtomicBoolean deviceDataLoaded = new AtomicBoolean(false);\n+    private final AtomicBoolean buttonDataLoaded = new AtomicBoolean(false);\n+\n+    private final Map<Integer, LutronHandler> childHandlerMap = new ConcurrentHashMap<>();\n+    private final Map<Integer, OGroupHandler> groupHandlerMap = new ConcurrentHashMap<>();\n+\n+    private @Nullable LeapDeviceDiscoveryService discoveryService;\n+\n+    public void setDiscoveryService(LeapDeviceDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    public LeapBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+        leapMessageParser = new LeapMessageParser(this);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        SSLContext sslContext;\n+\n+        childHandlerMap.clear();\n+        groupHandlerMap.clear();\n+\n+        config = getConfigAs(LeapBridgeConfig.class);\n+        String keystorePassword = (config.keystorePassword == null) ? \"\" : config.keystorePassword;\n+\n+        String ipAddress = config.ipAddress;\n+        if (ipAddress == null || ipAddress.isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"bridge address not specified\");\n+            return;\n+        }\n+\n+        reconnectInterval = (config.reconnect > 0) ? config.reconnect : DEFAULT_RECONNECT_MINUTES;\n+        heartbeatInterval = (config.heartbeat > 0) ? config.heartbeat : DEFAULT_HEARTBEAT_MINUTES;\n+        sendDelay = (config.delay < 0) ? 0 : config.delay;\n+\n+        if (config.keystore == null || keystorePassword == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Keystore/keystore password not configured\");\n+            return;\n+        } else {\n+            try (FileInputStream keystoreInputStream = new FileInputStream(config.keystore)) {\n+                logger.trace(\"Initializing keystore\");\n+                KeyStore keystore = KeyStore.getInstance(KeyStore.getDefaultType());\n+\n+                keystore.load(keystoreInputStream, keystorePassword.toCharArray());\n+\n+                logger.trace(\"Initializing SSL Context\");\n+                KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n+                kmf.init(keystore, keystorePassword.toCharArray());\n+\n+                TrustManager[] trustManagers;\n+                if (config.certValidate) {\n+                    // Use default trust manager which will attempt to validate server certificate from hub\n+                    TrustManagerFactory tmf = TrustManagerFactory\n+                            .getInstance(TrustManagerFactory.getDefaultAlgorithm());\n+                    tmf.init(keystore);\n+                    trustManagers = tmf.getTrustManagers();\n+                } else {\n+                    // Use no-op trust manager which will not verify certificates\n+                    trustManagers = defineNoOpTrustManager();\n+                }\n+\n+                sslContext = SSLContext.getInstance(\"TLS\");\n+                sslContext.init(kmf.getKeyManagers(), trustManagers, null);\n+\n+                sslsocketfactory = sslContext.getSocketFactory();\n+            } catch (FileNotFoundException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Keystore file not found\");\n+                return;\n+            } catch (CertificateException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Certificate exception\");\n+                return;\n+            } catch (UnrecoverableKeyException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"Key unrecoverable with supplied password\");\n+                return;\n+            } catch (KeyManagementException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Key management exception\");\n+                logger.debug(\"Key management exception\", e);\n+                return;\n+            } catch (KeyStoreException | NoSuchAlgorithmException | IOException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Error initializing keystore\");\n+                logger.debug(\"Error initializing keystore\", e);\n+                return;\n+            }\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Connecting\");\n+        scheduler.submit(this::connect); // start the async connect task", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY5ODYxOQ=="}, "originalCommit": {"oid": "deb48c1252ee18917f2f9e19cf0158fedb164659"}, "originalPosition": 215}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjcwNjUwNQ==", "bodyText": "I just pushed a commit that should take care of this.", "url": "https://github.com/openhab/openhab-addons/pull/8650#discussion_r502706505", "createdAt": "2020-10-09T23:05:24Z", "author": {"login": "bobadair"}, "path": "bundles/org.openhab.binding.lutron/src/main/java/org/openhab/binding/lutron/internal/handler/LeapBridgeHandler.java", "diffHunk": "@@ -0,0 +1,763 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lutron.internal.handler;\n+\n+import static org.openhab.binding.lutron.internal.LutronBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.net.UnknownHostException;\n+import java.security.KeyManagementException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.UnrecoverableKeyException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManager;\n+import javax.net.ssl.TrustManagerFactory;\n+import javax.net.ssl.X509TrustManager;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.lutron.internal.config.LeapBridgeConfig;\n+import org.openhab.binding.lutron.internal.discovery.LeapDeviceDiscoveryService;\n+import org.openhab.binding.lutron.internal.protocol.FanSpeedType;\n+import org.openhab.binding.lutron.internal.protocol.GroupCommand;\n+import org.openhab.binding.lutron.internal.protocol.LutronCommandNew;\n+import org.openhab.binding.lutron.internal.protocol.OutputCommand;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapCommand;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapMessageParser;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapMessageParserCallbacks;\n+import org.openhab.binding.lutron.internal.protocol.leap.Request;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Area;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ButtonGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Device;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.OccupancyGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ZoneStatus;\n+import org.openhab.binding.lutron.internal.protocol.lip.LutronCommandType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Bridge handler responsible for communicating with Lutron hubs that support the LEAP protocol, such as Caseta and\n+ * RA2 Select.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LeapBridgeHandler extends LutronBridgeHandler implements LeapMessageParserCallbacks {\n+    private static final int DEFAULT_RECONNECT_MINUTES = 5;\n+    private static final int DEFAULT_HEARTBEAT_MINUTES = 5;\n+    private static final long KEEPALIVE_TIMEOUT_SECONDS = 30;\n+\n+    private static final String STATUS_INITIALIZING = \"Initializing\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(LeapBridgeHandler.class);\n+\n+    private @NonNullByDefault({}) LeapBridgeConfig config;\n+    private int reconnectInterval;\n+    private int heartbeatInterval;\n+    private int sendDelay;\n+\n+    private @NonNullByDefault({}) SSLSocketFactory sslsocketfactory;\n+    private @Nullable SSLSocket sslsocket;\n+    private @Nullable BufferedWriter writer;\n+    private @Nullable BufferedReader reader;\n+\n+    private @NonNullByDefault({}) LeapMessageParser leapMessageParser;\n+\n+    private final BlockingQueue<LeapCommand> sendQueue = new LinkedBlockingQueue<>();\n+\n+    private @Nullable Thread senderThread;\n+    private @Nullable Thread readerThread;\n+\n+    private @Nullable ScheduledFuture<?> keepAlive;\n+    private @Nullable ScheduledFuture<?> keepAliveReconnect;\n+    private @Nullable ScheduledFuture<?> connectRetryJob;\n+    private final Object keepAliveReconnectLock = new Object();\n+\n+    private final Map<Integer, Integer> zoneToDevice = new HashMap<>();\n+    private final Map<Integer, Integer> deviceToZone = new HashMap<>();\n+    private final Object zoneMapsLock = new Object();\n+\n+    private @Nullable Map<Integer, List<Integer>> deviceButtonMap;\n+    private final Object deviceButtonMapLock = new Object();\n+\n+    private final AtomicBoolean deviceDataLoaded = new AtomicBoolean(false);\n+    private final AtomicBoolean buttonDataLoaded = new AtomicBoolean(false);\n+\n+    private final Map<Integer, LutronHandler> childHandlerMap = new ConcurrentHashMap<>();\n+    private final Map<Integer, OGroupHandler> groupHandlerMap = new ConcurrentHashMap<>();\n+\n+    private @Nullable LeapDeviceDiscoveryService discoveryService;\n+\n+    public void setDiscoveryService(LeapDeviceDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    public LeapBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+        leapMessageParser = new LeapMessageParser(this);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        SSLContext sslContext;\n+\n+        childHandlerMap.clear();\n+        groupHandlerMap.clear();\n+\n+        config = getConfigAs(LeapBridgeConfig.class);\n+        String keystorePassword = (config.keystorePassword == null) ? \"\" : config.keystorePassword;\n+\n+        String ipAddress = config.ipAddress;\n+        if (ipAddress == null || ipAddress.isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"bridge address not specified\");\n+            return;\n+        }\n+\n+        reconnectInterval = (config.reconnect > 0) ? config.reconnect : DEFAULT_RECONNECT_MINUTES;\n+        heartbeatInterval = (config.heartbeat > 0) ? config.heartbeat : DEFAULT_HEARTBEAT_MINUTES;\n+        sendDelay = (config.delay < 0) ? 0 : config.delay;\n+\n+        if (config.keystore == null || keystorePassword == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Keystore/keystore password not configured\");\n+            return;\n+        } else {\n+            try (FileInputStream keystoreInputStream = new FileInputStream(config.keystore)) {\n+                logger.trace(\"Initializing keystore\");\n+                KeyStore keystore = KeyStore.getInstance(KeyStore.getDefaultType());\n+\n+                keystore.load(keystoreInputStream, keystorePassword.toCharArray());\n+\n+                logger.trace(\"Initializing SSL Context\");\n+                KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n+                kmf.init(keystore, keystorePassword.toCharArray());\n+\n+                TrustManager[] trustManagers;\n+                if (config.certValidate) {\n+                    // Use default trust manager which will attempt to validate server certificate from hub\n+                    TrustManagerFactory tmf = TrustManagerFactory\n+                            .getInstance(TrustManagerFactory.getDefaultAlgorithm());\n+                    tmf.init(keystore);\n+                    trustManagers = tmf.getTrustManagers();\n+                } else {\n+                    // Use no-op trust manager which will not verify certificates\n+                    trustManagers = defineNoOpTrustManager();\n+                }\n+\n+                sslContext = SSLContext.getInstance(\"TLS\");\n+                sslContext.init(kmf.getKeyManagers(), trustManagers, null);\n+\n+                sslsocketfactory = sslContext.getSocketFactory();\n+            } catch (FileNotFoundException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Keystore file not found\");\n+                return;\n+            } catch (CertificateException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Certificate exception\");\n+                return;\n+            } catch (UnrecoverableKeyException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"Key unrecoverable with supplied password\");\n+                return;\n+            } catch (KeyManagementException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Key management exception\");\n+                logger.debug(\"Key management exception\", e);\n+                return;\n+            } catch (KeyStoreException | NoSuchAlgorithmException | IOException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Error initializing keystore\");\n+                logger.debug(\"Error initializing keystore\", e);\n+                return;\n+            }\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Connecting\");\n+        scheduler.submit(this::connect); // start the async connect task", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY5ODYxOQ=="}, "originalCommit": {"oid": "deb48c1252ee18917f2f9e19cf0158fedb164659"}, "originalPosition": 215}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNTExOTk4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.lutron/src/main/java/org/openhab/binding/lutron/internal/handler/LeapBridgeHandler.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwMjoyNzowMFrOHdgY_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxODoyNTo1MVrOHfUcbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDcwMTQzOA==", "bodyText": "disconnect is called as part of dispose so it would probably be a really good idea to cancel all tasks with interrupts.", "url": "https://github.com/openhab/openhab-addons/pull/8650#discussion_r500701438", "createdAt": "2020-10-07T02:27:00Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lutron/src/main/java/org/openhab/binding/lutron/internal/handler/LeapBridgeHandler.java", "diffHunk": "@@ -0,0 +1,763 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lutron.internal.handler;\n+\n+import static org.openhab.binding.lutron.internal.LutronBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.net.UnknownHostException;\n+import java.security.KeyManagementException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.UnrecoverableKeyException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManager;\n+import javax.net.ssl.TrustManagerFactory;\n+import javax.net.ssl.X509TrustManager;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.lutron.internal.config.LeapBridgeConfig;\n+import org.openhab.binding.lutron.internal.discovery.LeapDeviceDiscoveryService;\n+import org.openhab.binding.lutron.internal.protocol.FanSpeedType;\n+import org.openhab.binding.lutron.internal.protocol.GroupCommand;\n+import org.openhab.binding.lutron.internal.protocol.LutronCommandNew;\n+import org.openhab.binding.lutron.internal.protocol.OutputCommand;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapCommand;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapMessageParser;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapMessageParserCallbacks;\n+import org.openhab.binding.lutron.internal.protocol.leap.Request;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Area;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ButtonGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Device;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.OccupancyGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ZoneStatus;\n+import org.openhab.binding.lutron.internal.protocol.lip.LutronCommandType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Bridge handler responsible for communicating with Lutron hubs that support the LEAP protocol, such as Caseta and\n+ * RA2 Select.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LeapBridgeHandler extends LutronBridgeHandler implements LeapMessageParserCallbacks {\n+    private static final int DEFAULT_RECONNECT_MINUTES = 5;\n+    private static final int DEFAULT_HEARTBEAT_MINUTES = 5;\n+    private static final long KEEPALIVE_TIMEOUT_SECONDS = 30;\n+\n+    private static final String STATUS_INITIALIZING = \"Initializing\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(LeapBridgeHandler.class);\n+\n+    private @NonNullByDefault({}) LeapBridgeConfig config;\n+    private int reconnectInterval;\n+    private int heartbeatInterval;\n+    private int sendDelay;\n+\n+    private @NonNullByDefault({}) SSLSocketFactory sslsocketfactory;\n+    private @Nullable SSLSocket sslsocket;\n+    private @Nullable BufferedWriter writer;\n+    private @Nullable BufferedReader reader;\n+\n+    private @NonNullByDefault({}) LeapMessageParser leapMessageParser;\n+\n+    private final BlockingQueue<LeapCommand> sendQueue = new LinkedBlockingQueue<>();\n+\n+    private @Nullable Thread senderThread;\n+    private @Nullable Thread readerThread;\n+\n+    private @Nullable ScheduledFuture<?> keepAlive;\n+    private @Nullable ScheduledFuture<?> keepAliveReconnect;\n+    private @Nullable ScheduledFuture<?> connectRetryJob;\n+    private final Object keepAliveReconnectLock = new Object();\n+\n+    private final Map<Integer, Integer> zoneToDevice = new HashMap<>();\n+    private final Map<Integer, Integer> deviceToZone = new HashMap<>();\n+    private final Object zoneMapsLock = new Object();\n+\n+    private @Nullable Map<Integer, List<Integer>> deviceButtonMap;\n+    private final Object deviceButtonMapLock = new Object();\n+\n+    private final AtomicBoolean deviceDataLoaded = new AtomicBoolean(false);\n+    private final AtomicBoolean buttonDataLoaded = new AtomicBoolean(false);\n+\n+    private final Map<Integer, LutronHandler> childHandlerMap = new ConcurrentHashMap<>();\n+    private final Map<Integer, OGroupHandler> groupHandlerMap = new ConcurrentHashMap<>();\n+\n+    private @Nullable LeapDeviceDiscoveryService discoveryService;\n+\n+    public void setDiscoveryService(LeapDeviceDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    public LeapBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+        leapMessageParser = new LeapMessageParser(this);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        SSLContext sslContext;\n+\n+        childHandlerMap.clear();\n+        groupHandlerMap.clear();\n+\n+        config = getConfigAs(LeapBridgeConfig.class);\n+        String keystorePassword = (config.keystorePassword == null) ? \"\" : config.keystorePassword;\n+\n+        String ipAddress = config.ipAddress;\n+        if (ipAddress == null || ipAddress.isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"bridge address not specified\");\n+            return;\n+        }\n+\n+        reconnectInterval = (config.reconnect > 0) ? config.reconnect : DEFAULT_RECONNECT_MINUTES;\n+        heartbeatInterval = (config.heartbeat > 0) ? config.heartbeat : DEFAULT_HEARTBEAT_MINUTES;\n+        sendDelay = (config.delay < 0) ? 0 : config.delay;\n+\n+        if (config.keystore == null || keystorePassword == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Keystore/keystore password not configured\");\n+            return;\n+        } else {\n+            try (FileInputStream keystoreInputStream = new FileInputStream(config.keystore)) {\n+                logger.trace(\"Initializing keystore\");\n+                KeyStore keystore = KeyStore.getInstance(KeyStore.getDefaultType());\n+\n+                keystore.load(keystoreInputStream, keystorePassword.toCharArray());\n+\n+                logger.trace(\"Initializing SSL Context\");\n+                KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n+                kmf.init(keystore, keystorePassword.toCharArray());\n+\n+                TrustManager[] trustManagers;\n+                if (config.certValidate) {\n+                    // Use default trust manager which will attempt to validate server certificate from hub\n+                    TrustManagerFactory tmf = TrustManagerFactory\n+                            .getInstance(TrustManagerFactory.getDefaultAlgorithm());\n+                    tmf.init(keystore);\n+                    trustManagers = tmf.getTrustManagers();\n+                } else {\n+                    // Use no-op trust manager which will not verify certificates\n+                    trustManagers = defineNoOpTrustManager();\n+                }\n+\n+                sslContext = SSLContext.getInstance(\"TLS\");\n+                sslContext.init(kmf.getKeyManagers(), trustManagers, null);\n+\n+                sslsocketfactory = sslContext.getSocketFactory();\n+            } catch (FileNotFoundException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Keystore file not found\");\n+                return;\n+            } catch (CertificateException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Certificate exception\");\n+                return;\n+            } catch (UnrecoverableKeyException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"Key unrecoverable with supplied password\");\n+                return;\n+            } catch (KeyManagementException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Key management exception\");\n+                logger.debug(\"Key management exception\", e);\n+                return;\n+            } catch (KeyStoreException | NoSuchAlgorithmException | IOException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Error initializing keystore\");\n+                logger.debug(\"Error initializing keystore\", e);\n+                return;\n+            }\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Connecting\");\n+        scheduler.submit(this::connect); // start the async connect task\n+    }\n+\n+    /**\n+     * Return a no-op SSL trust manager which will not verify server or client certificates.\n+     */\n+    private TrustManager[] defineNoOpTrustManager() {\n+        return new TrustManager[] { new X509TrustManager() {\n+            @Override\n+            public void checkClientTrusted(final X509Certificate @Nullable [] chain, final @Nullable String authType) {\n+                logger.debug(\"Assuming client certificate is valid\");\n+                if (chain != null) {\n+                    for (int cert = 0; cert < chain.length; cert++) {\n+                        logger.trace(\"Subject DN: {}\", chain[cert].getSubjectDN());\n+                        logger.trace(\"Issuer DN: {}\", chain[cert].getIssuerDN());\n+                        logger.trace(\"Serial number {}:\", chain[cert].getSerialNumber());\n+                    }\n+                }\n+            }\n+\n+            @Override\n+            public void checkServerTrusted(final X509Certificate @Nullable [] chain, final @Nullable String authType) {\n+                logger.debug(\"Assuming server certificate is valid\");\n+                if (chain != null) {\n+                    for (int cert = 0; cert < chain.length; cert++) {\n+                        logger.trace(\"Subject DN: {}\", chain[cert].getSubjectDN());\n+                        logger.trace(\"Issuer DN: {}\", chain[cert].getIssuerDN());\n+                        logger.trace(\"Serial number: {}\", chain[cert].getSerialNumber());\n+                    }\n+                }\n+            }\n+\n+            @Override\n+            public X509Certificate @Nullable [] getAcceptedIssuers() {\n+                return null;\n+            }\n+        } };\n+    }\n+\n+    private synchronized void connect() {\n+        deviceDataLoaded.set(false);\n+        buttonDataLoaded.set(false);\n+\n+        try {\n+            logger.debug(\"Opening SSL connection to {}:{}\", config.ipAddress, config.port);\n+            SSLSocket sslsocket = (SSLSocket) sslsocketfactory.createSocket(config.ipAddress, config.port);\n+            sslsocket.startHandshake();\n+            writer = new BufferedWriter(new OutputStreamWriter(sslsocket.getOutputStream()));\n+            reader = new BufferedReader(new InputStreamReader(sslsocket.getInputStream()));\n+            this.sslsocket = sslsocket;\n+        } catch (UnknownHostException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Unknown host\");\n+            return;\n+        } catch (IllegalArgumentException e) {\n+            // port out of valid range\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Invalid port number\");\n+            return;\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Error opening SSL connection. Check log.\");\n+            logger.info(\"Error opening SSL connection: {}\", e.getMessage());\n+            disconnect();\n+            scheduleConnectRetry(reconnectInterval); // Possibly a temporary problem. Try again later.\n+            return;\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, STATUS_INITIALIZING);\n+\n+        Thread readerThread = new Thread(this::readerThreadJob, \"Lutron reader\");\n+        readerThread.setDaemon(true);\n+        readerThread.start();\n+        this.readerThread = readerThread;\n+\n+        Thread senderThread = new Thread(this::senderThreadJob, \"Lutron sender\");\n+        senderThread.setDaemon(true);\n+        senderThread.start();\n+        this.senderThread = senderThread;\n+\n+        sendCommand(new LeapCommand(Request.getButtonGroups()));\n+        queryDiscoveryData();\n+        sendCommand(new LeapCommand(Request.subscribeOccupancyGroupStatus()));\n+\n+        logger.debug(\"Starting keepAlive job with interval {}\", heartbeatInterval);\n+        keepAlive = scheduler.scheduleWithFixedDelay(this::sendKeepAlive, heartbeatInterval, heartbeatInterval,\n+                TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Called by connect() and discovery service to request fresh discovery data\n+     */\n+    public void queryDiscoveryData() {\n+        sendCommand(new LeapCommand(Request.getDevices()));\n+        sendCommand(new LeapCommand(Request.getAreas()));\n+        sendCommand(new LeapCommand(Request.getOccupancyGroups()));\n+    }\n+\n+    private void scheduleConnectRetry(long waitMinutes) {\n+        logger.debug(\"Scheduling connection retry in {} minutes\", waitMinutes);\n+        connectRetryJob = scheduler.schedule(this::connect, waitMinutes, TimeUnit.MINUTES);\n+    }\n+\n+    private synchronized void disconnect() {\n+        logger.debug(\"Disconnecting\");\n+\n+        Thread senderThread = this.senderThread;\n+        Thread readerThread = this.readerThread;\n+\n+        if (connectRetryJob != null) {\n+            connectRetryJob.cancel(true);\n+        }\n+        if (keepAlive != null) {\n+            keepAlive.cancel(true);\n+        }\n+\n+        // May be called from keepAliveReconnect thread, so call cancel with false\n+        reconnectTaskCancel(false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "deb48c1252ee18917f2f9e19cf0158fedb164659"}, "originalPosition": 330}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQxMzI5NA==", "bodyText": "Yes. I can't just call cancel with interrupt on the reconnect job all of the time, though. The reconnect job calls disconnect(), so it would shoot itself. I'll have to add a boolean parameter to disconnect() that gets set when called from dispose().", "url": "https://github.com/openhab/openhab-addons/pull/8650#discussion_r501413294", "createdAt": "2020-10-08T02:31:48Z", "author": {"login": "bobadair"}, "path": "bundles/org.openhab.binding.lutron/src/main/java/org/openhab/binding/lutron/internal/handler/LeapBridgeHandler.java", "diffHunk": "@@ -0,0 +1,763 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lutron.internal.handler;\n+\n+import static org.openhab.binding.lutron.internal.LutronBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.net.UnknownHostException;\n+import java.security.KeyManagementException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.UnrecoverableKeyException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManager;\n+import javax.net.ssl.TrustManagerFactory;\n+import javax.net.ssl.X509TrustManager;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.lutron.internal.config.LeapBridgeConfig;\n+import org.openhab.binding.lutron.internal.discovery.LeapDeviceDiscoveryService;\n+import org.openhab.binding.lutron.internal.protocol.FanSpeedType;\n+import org.openhab.binding.lutron.internal.protocol.GroupCommand;\n+import org.openhab.binding.lutron.internal.protocol.LutronCommandNew;\n+import org.openhab.binding.lutron.internal.protocol.OutputCommand;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapCommand;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapMessageParser;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapMessageParserCallbacks;\n+import org.openhab.binding.lutron.internal.protocol.leap.Request;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Area;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ButtonGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Device;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.OccupancyGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ZoneStatus;\n+import org.openhab.binding.lutron.internal.protocol.lip.LutronCommandType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Bridge handler responsible for communicating with Lutron hubs that support the LEAP protocol, such as Caseta and\n+ * RA2 Select.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LeapBridgeHandler extends LutronBridgeHandler implements LeapMessageParserCallbacks {\n+    private static final int DEFAULT_RECONNECT_MINUTES = 5;\n+    private static final int DEFAULT_HEARTBEAT_MINUTES = 5;\n+    private static final long KEEPALIVE_TIMEOUT_SECONDS = 30;\n+\n+    private static final String STATUS_INITIALIZING = \"Initializing\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(LeapBridgeHandler.class);\n+\n+    private @NonNullByDefault({}) LeapBridgeConfig config;\n+    private int reconnectInterval;\n+    private int heartbeatInterval;\n+    private int sendDelay;\n+\n+    private @NonNullByDefault({}) SSLSocketFactory sslsocketfactory;\n+    private @Nullable SSLSocket sslsocket;\n+    private @Nullable BufferedWriter writer;\n+    private @Nullable BufferedReader reader;\n+\n+    private @NonNullByDefault({}) LeapMessageParser leapMessageParser;\n+\n+    private final BlockingQueue<LeapCommand> sendQueue = new LinkedBlockingQueue<>();\n+\n+    private @Nullable Thread senderThread;\n+    private @Nullable Thread readerThread;\n+\n+    private @Nullable ScheduledFuture<?> keepAlive;\n+    private @Nullable ScheduledFuture<?> keepAliveReconnect;\n+    private @Nullable ScheduledFuture<?> connectRetryJob;\n+    private final Object keepAliveReconnectLock = new Object();\n+\n+    private final Map<Integer, Integer> zoneToDevice = new HashMap<>();\n+    private final Map<Integer, Integer> deviceToZone = new HashMap<>();\n+    private final Object zoneMapsLock = new Object();\n+\n+    private @Nullable Map<Integer, List<Integer>> deviceButtonMap;\n+    private final Object deviceButtonMapLock = new Object();\n+\n+    private final AtomicBoolean deviceDataLoaded = new AtomicBoolean(false);\n+    private final AtomicBoolean buttonDataLoaded = new AtomicBoolean(false);\n+\n+    private final Map<Integer, LutronHandler> childHandlerMap = new ConcurrentHashMap<>();\n+    private final Map<Integer, OGroupHandler> groupHandlerMap = new ConcurrentHashMap<>();\n+\n+    private @Nullable LeapDeviceDiscoveryService discoveryService;\n+\n+    public void setDiscoveryService(LeapDeviceDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    public LeapBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+        leapMessageParser = new LeapMessageParser(this);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        SSLContext sslContext;\n+\n+        childHandlerMap.clear();\n+        groupHandlerMap.clear();\n+\n+        config = getConfigAs(LeapBridgeConfig.class);\n+        String keystorePassword = (config.keystorePassword == null) ? \"\" : config.keystorePassword;\n+\n+        String ipAddress = config.ipAddress;\n+        if (ipAddress == null || ipAddress.isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"bridge address not specified\");\n+            return;\n+        }\n+\n+        reconnectInterval = (config.reconnect > 0) ? config.reconnect : DEFAULT_RECONNECT_MINUTES;\n+        heartbeatInterval = (config.heartbeat > 0) ? config.heartbeat : DEFAULT_HEARTBEAT_MINUTES;\n+        sendDelay = (config.delay < 0) ? 0 : config.delay;\n+\n+        if (config.keystore == null || keystorePassword == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Keystore/keystore password not configured\");\n+            return;\n+        } else {\n+            try (FileInputStream keystoreInputStream = new FileInputStream(config.keystore)) {\n+                logger.trace(\"Initializing keystore\");\n+                KeyStore keystore = KeyStore.getInstance(KeyStore.getDefaultType());\n+\n+                keystore.load(keystoreInputStream, keystorePassword.toCharArray());\n+\n+                logger.trace(\"Initializing SSL Context\");\n+                KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n+                kmf.init(keystore, keystorePassword.toCharArray());\n+\n+                TrustManager[] trustManagers;\n+                if (config.certValidate) {\n+                    // Use default trust manager which will attempt to validate server certificate from hub\n+                    TrustManagerFactory tmf = TrustManagerFactory\n+                            .getInstance(TrustManagerFactory.getDefaultAlgorithm());\n+                    tmf.init(keystore);\n+                    trustManagers = tmf.getTrustManagers();\n+                } else {\n+                    // Use no-op trust manager which will not verify certificates\n+                    trustManagers = defineNoOpTrustManager();\n+                }\n+\n+                sslContext = SSLContext.getInstance(\"TLS\");\n+                sslContext.init(kmf.getKeyManagers(), trustManagers, null);\n+\n+                sslsocketfactory = sslContext.getSocketFactory();\n+            } catch (FileNotFoundException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Keystore file not found\");\n+                return;\n+            } catch (CertificateException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Certificate exception\");\n+                return;\n+            } catch (UnrecoverableKeyException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"Key unrecoverable with supplied password\");\n+                return;\n+            } catch (KeyManagementException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Key management exception\");\n+                logger.debug(\"Key management exception\", e);\n+                return;\n+            } catch (KeyStoreException | NoSuchAlgorithmException | IOException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Error initializing keystore\");\n+                logger.debug(\"Error initializing keystore\", e);\n+                return;\n+            }\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Connecting\");\n+        scheduler.submit(this::connect); // start the async connect task\n+    }\n+\n+    /**\n+     * Return a no-op SSL trust manager which will not verify server or client certificates.\n+     */\n+    private TrustManager[] defineNoOpTrustManager() {\n+        return new TrustManager[] { new X509TrustManager() {\n+            @Override\n+            public void checkClientTrusted(final X509Certificate @Nullable [] chain, final @Nullable String authType) {\n+                logger.debug(\"Assuming client certificate is valid\");\n+                if (chain != null) {\n+                    for (int cert = 0; cert < chain.length; cert++) {\n+                        logger.trace(\"Subject DN: {}\", chain[cert].getSubjectDN());\n+                        logger.trace(\"Issuer DN: {}\", chain[cert].getIssuerDN());\n+                        logger.trace(\"Serial number {}:\", chain[cert].getSerialNumber());\n+                    }\n+                }\n+            }\n+\n+            @Override\n+            public void checkServerTrusted(final X509Certificate @Nullable [] chain, final @Nullable String authType) {\n+                logger.debug(\"Assuming server certificate is valid\");\n+                if (chain != null) {\n+                    for (int cert = 0; cert < chain.length; cert++) {\n+                        logger.trace(\"Subject DN: {}\", chain[cert].getSubjectDN());\n+                        logger.trace(\"Issuer DN: {}\", chain[cert].getIssuerDN());\n+                        logger.trace(\"Serial number: {}\", chain[cert].getSerialNumber());\n+                    }\n+                }\n+            }\n+\n+            @Override\n+            public X509Certificate @Nullable [] getAcceptedIssuers() {\n+                return null;\n+            }\n+        } };\n+    }\n+\n+    private synchronized void connect() {\n+        deviceDataLoaded.set(false);\n+        buttonDataLoaded.set(false);\n+\n+        try {\n+            logger.debug(\"Opening SSL connection to {}:{}\", config.ipAddress, config.port);\n+            SSLSocket sslsocket = (SSLSocket) sslsocketfactory.createSocket(config.ipAddress, config.port);\n+            sslsocket.startHandshake();\n+            writer = new BufferedWriter(new OutputStreamWriter(sslsocket.getOutputStream()));\n+            reader = new BufferedReader(new InputStreamReader(sslsocket.getInputStream()));\n+            this.sslsocket = sslsocket;\n+        } catch (UnknownHostException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Unknown host\");\n+            return;\n+        } catch (IllegalArgumentException e) {\n+            // port out of valid range\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Invalid port number\");\n+            return;\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Error opening SSL connection. Check log.\");\n+            logger.info(\"Error opening SSL connection: {}\", e.getMessage());\n+            disconnect();\n+            scheduleConnectRetry(reconnectInterval); // Possibly a temporary problem. Try again later.\n+            return;\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, STATUS_INITIALIZING);\n+\n+        Thread readerThread = new Thread(this::readerThreadJob, \"Lutron reader\");\n+        readerThread.setDaemon(true);\n+        readerThread.start();\n+        this.readerThread = readerThread;\n+\n+        Thread senderThread = new Thread(this::senderThreadJob, \"Lutron sender\");\n+        senderThread.setDaemon(true);\n+        senderThread.start();\n+        this.senderThread = senderThread;\n+\n+        sendCommand(new LeapCommand(Request.getButtonGroups()));\n+        queryDiscoveryData();\n+        sendCommand(new LeapCommand(Request.subscribeOccupancyGroupStatus()));\n+\n+        logger.debug(\"Starting keepAlive job with interval {}\", heartbeatInterval);\n+        keepAlive = scheduler.scheduleWithFixedDelay(this::sendKeepAlive, heartbeatInterval, heartbeatInterval,\n+                TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Called by connect() and discovery service to request fresh discovery data\n+     */\n+    public void queryDiscoveryData() {\n+        sendCommand(new LeapCommand(Request.getDevices()));\n+        sendCommand(new LeapCommand(Request.getAreas()));\n+        sendCommand(new LeapCommand(Request.getOccupancyGroups()));\n+    }\n+\n+    private void scheduleConnectRetry(long waitMinutes) {\n+        logger.debug(\"Scheduling connection retry in {} minutes\", waitMinutes);\n+        connectRetryJob = scheduler.schedule(this::connect, waitMinutes, TimeUnit.MINUTES);\n+    }\n+\n+    private synchronized void disconnect() {\n+        logger.debug(\"Disconnecting\");\n+\n+        Thread senderThread = this.senderThread;\n+        Thread readerThread = this.readerThread;\n+\n+        if (connectRetryJob != null) {\n+            connectRetryJob.cancel(true);\n+        }\n+        if (keepAlive != null) {\n+            keepAlive.cancel(true);\n+        }\n+\n+        // May be called from keepAliveReconnect thread, so call cancel with false\n+        reconnectTaskCancel(false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDcwMTQzOA=="}, "originalCommit": {"oid": "deb48c1252ee18917f2f9e19cf0158fedb164659"}, "originalPosition": 330}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQ1MjU3OA==", "bodyText": "Well interrupts are optional, you just need to make sure that the asynchronous task results are silently discarded.", "url": "https://github.com/openhab/openhab-addons/pull/8650#discussion_r501452578", "createdAt": "2020-10-08T05:13:52Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lutron/src/main/java/org/openhab/binding/lutron/internal/handler/LeapBridgeHandler.java", "diffHunk": "@@ -0,0 +1,763 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lutron.internal.handler;\n+\n+import static org.openhab.binding.lutron.internal.LutronBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.net.UnknownHostException;\n+import java.security.KeyManagementException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.UnrecoverableKeyException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManager;\n+import javax.net.ssl.TrustManagerFactory;\n+import javax.net.ssl.X509TrustManager;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.lutron.internal.config.LeapBridgeConfig;\n+import org.openhab.binding.lutron.internal.discovery.LeapDeviceDiscoveryService;\n+import org.openhab.binding.lutron.internal.protocol.FanSpeedType;\n+import org.openhab.binding.lutron.internal.protocol.GroupCommand;\n+import org.openhab.binding.lutron.internal.protocol.LutronCommandNew;\n+import org.openhab.binding.lutron.internal.protocol.OutputCommand;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapCommand;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapMessageParser;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapMessageParserCallbacks;\n+import org.openhab.binding.lutron.internal.protocol.leap.Request;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Area;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ButtonGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Device;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.OccupancyGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ZoneStatus;\n+import org.openhab.binding.lutron.internal.protocol.lip.LutronCommandType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Bridge handler responsible for communicating with Lutron hubs that support the LEAP protocol, such as Caseta and\n+ * RA2 Select.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LeapBridgeHandler extends LutronBridgeHandler implements LeapMessageParserCallbacks {\n+    private static final int DEFAULT_RECONNECT_MINUTES = 5;\n+    private static final int DEFAULT_HEARTBEAT_MINUTES = 5;\n+    private static final long KEEPALIVE_TIMEOUT_SECONDS = 30;\n+\n+    private static final String STATUS_INITIALIZING = \"Initializing\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(LeapBridgeHandler.class);\n+\n+    private @NonNullByDefault({}) LeapBridgeConfig config;\n+    private int reconnectInterval;\n+    private int heartbeatInterval;\n+    private int sendDelay;\n+\n+    private @NonNullByDefault({}) SSLSocketFactory sslsocketfactory;\n+    private @Nullable SSLSocket sslsocket;\n+    private @Nullable BufferedWriter writer;\n+    private @Nullable BufferedReader reader;\n+\n+    private @NonNullByDefault({}) LeapMessageParser leapMessageParser;\n+\n+    private final BlockingQueue<LeapCommand> sendQueue = new LinkedBlockingQueue<>();\n+\n+    private @Nullable Thread senderThread;\n+    private @Nullable Thread readerThread;\n+\n+    private @Nullable ScheduledFuture<?> keepAlive;\n+    private @Nullable ScheduledFuture<?> keepAliveReconnect;\n+    private @Nullable ScheduledFuture<?> connectRetryJob;\n+    private final Object keepAliveReconnectLock = new Object();\n+\n+    private final Map<Integer, Integer> zoneToDevice = new HashMap<>();\n+    private final Map<Integer, Integer> deviceToZone = new HashMap<>();\n+    private final Object zoneMapsLock = new Object();\n+\n+    private @Nullable Map<Integer, List<Integer>> deviceButtonMap;\n+    private final Object deviceButtonMapLock = new Object();\n+\n+    private final AtomicBoolean deviceDataLoaded = new AtomicBoolean(false);\n+    private final AtomicBoolean buttonDataLoaded = new AtomicBoolean(false);\n+\n+    private final Map<Integer, LutronHandler> childHandlerMap = new ConcurrentHashMap<>();\n+    private final Map<Integer, OGroupHandler> groupHandlerMap = new ConcurrentHashMap<>();\n+\n+    private @Nullable LeapDeviceDiscoveryService discoveryService;\n+\n+    public void setDiscoveryService(LeapDeviceDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    public LeapBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+        leapMessageParser = new LeapMessageParser(this);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        SSLContext sslContext;\n+\n+        childHandlerMap.clear();\n+        groupHandlerMap.clear();\n+\n+        config = getConfigAs(LeapBridgeConfig.class);\n+        String keystorePassword = (config.keystorePassword == null) ? \"\" : config.keystorePassword;\n+\n+        String ipAddress = config.ipAddress;\n+        if (ipAddress == null || ipAddress.isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"bridge address not specified\");\n+            return;\n+        }\n+\n+        reconnectInterval = (config.reconnect > 0) ? config.reconnect : DEFAULT_RECONNECT_MINUTES;\n+        heartbeatInterval = (config.heartbeat > 0) ? config.heartbeat : DEFAULT_HEARTBEAT_MINUTES;\n+        sendDelay = (config.delay < 0) ? 0 : config.delay;\n+\n+        if (config.keystore == null || keystorePassword == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Keystore/keystore password not configured\");\n+            return;\n+        } else {\n+            try (FileInputStream keystoreInputStream = new FileInputStream(config.keystore)) {\n+                logger.trace(\"Initializing keystore\");\n+                KeyStore keystore = KeyStore.getInstance(KeyStore.getDefaultType());\n+\n+                keystore.load(keystoreInputStream, keystorePassword.toCharArray());\n+\n+                logger.trace(\"Initializing SSL Context\");\n+                KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n+                kmf.init(keystore, keystorePassword.toCharArray());\n+\n+                TrustManager[] trustManagers;\n+                if (config.certValidate) {\n+                    // Use default trust manager which will attempt to validate server certificate from hub\n+                    TrustManagerFactory tmf = TrustManagerFactory\n+                            .getInstance(TrustManagerFactory.getDefaultAlgorithm());\n+                    tmf.init(keystore);\n+                    trustManagers = tmf.getTrustManagers();\n+                } else {\n+                    // Use no-op trust manager which will not verify certificates\n+                    trustManagers = defineNoOpTrustManager();\n+                }\n+\n+                sslContext = SSLContext.getInstance(\"TLS\");\n+                sslContext.init(kmf.getKeyManagers(), trustManagers, null);\n+\n+                sslsocketfactory = sslContext.getSocketFactory();\n+            } catch (FileNotFoundException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Keystore file not found\");\n+                return;\n+            } catch (CertificateException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Certificate exception\");\n+                return;\n+            } catch (UnrecoverableKeyException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"Key unrecoverable with supplied password\");\n+                return;\n+            } catch (KeyManagementException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Key management exception\");\n+                logger.debug(\"Key management exception\", e);\n+                return;\n+            } catch (KeyStoreException | NoSuchAlgorithmException | IOException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Error initializing keystore\");\n+                logger.debug(\"Error initializing keystore\", e);\n+                return;\n+            }\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Connecting\");\n+        scheduler.submit(this::connect); // start the async connect task\n+    }\n+\n+    /**\n+     * Return a no-op SSL trust manager which will not verify server or client certificates.\n+     */\n+    private TrustManager[] defineNoOpTrustManager() {\n+        return new TrustManager[] { new X509TrustManager() {\n+            @Override\n+            public void checkClientTrusted(final X509Certificate @Nullable [] chain, final @Nullable String authType) {\n+                logger.debug(\"Assuming client certificate is valid\");\n+                if (chain != null) {\n+                    for (int cert = 0; cert < chain.length; cert++) {\n+                        logger.trace(\"Subject DN: {}\", chain[cert].getSubjectDN());\n+                        logger.trace(\"Issuer DN: {}\", chain[cert].getIssuerDN());\n+                        logger.trace(\"Serial number {}:\", chain[cert].getSerialNumber());\n+                    }\n+                }\n+            }\n+\n+            @Override\n+            public void checkServerTrusted(final X509Certificate @Nullable [] chain, final @Nullable String authType) {\n+                logger.debug(\"Assuming server certificate is valid\");\n+                if (chain != null) {\n+                    for (int cert = 0; cert < chain.length; cert++) {\n+                        logger.trace(\"Subject DN: {}\", chain[cert].getSubjectDN());\n+                        logger.trace(\"Issuer DN: {}\", chain[cert].getIssuerDN());\n+                        logger.trace(\"Serial number: {}\", chain[cert].getSerialNumber());\n+                    }\n+                }\n+            }\n+\n+            @Override\n+            public X509Certificate @Nullable [] getAcceptedIssuers() {\n+                return null;\n+            }\n+        } };\n+    }\n+\n+    private synchronized void connect() {\n+        deviceDataLoaded.set(false);\n+        buttonDataLoaded.set(false);\n+\n+        try {\n+            logger.debug(\"Opening SSL connection to {}:{}\", config.ipAddress, config.port);\n+            SSLSocket sslsocket = (SSLSocket) sslsocketfactory.createSocket(config.ipAddress, config.port);\n+            sslsocket.startHandshake();\n+            writer = new BufferedWriter(new OutputStreamWriter(sslsocket.getOutputStream()));\n+            reader = new BufferedReader(new InputStreamReader(sslsocket.getInputStream()));\n+            this.sslsocket = sslsocket;\n+        } catch (UnknownHostException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Unknown host\");\n+            return;\n+        } catch (IllegalArgumentException e) {\n+            // port out of valid range\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Invalid port number\");\n+            return;\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Error opening SSL connection. Check log.\");\n+            logger.info(\"Error opening SSL connection: {}\", e.getMessage());\n+            disconnect();\n+            scheduleConnectRetry(reconnectInterval); // Possibly a temporary problem. Try again later.\n+            return;\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, STATUS_INITIALIZING);\n+\n+        Thread readerThread = new Thread(this::readerThreadJob, \"Lutron reader\");\n+        readerThread.setDaemon(true);\n+        readerThread.start();\n+        this.readerThread = readerThread;\n+\n+        Thread senderThread = new Thread(this::senderThreadJob, \"Lutron sender\");\n+        senderThread.setDaemon(true);\n+        senderThread.start();\n+        this.senderThread = senderThread;\n+\n+        sendCommand(new LeapCommand(Request.getButtonGroups()));\n+        queryDiscoveryData();\n+        sendCommand(new LeapCommand(Request.subscribeOccupancyGroupStatus()));\n+\n+        logger.debug(\"Starting keepAlive job with interval {}\", heartbeatInterval);\n+        keepAlive = scheduler.scheduleWithFixedDelay(this::sendKeepAlive, heartbeatInterval, heartbeatInterval,\n+                TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Called by connect() and discovery service to request fresh discovery data\n+     */\n+    public void queryDiscoveryData() {\n+        sendCommand(new LeapCommand(Request.getDevices()));\n+        sendCommand(new LeapCommand(Request.getAreas()));\n+        sendCommand(new LeapCommand(Request.getOccupancyGroups()));\n+    }\n+\n+    private void scheduleConnectRetry(long waitMinutes) {\n+        logger.debug(\"Scheduling connection retry in {} minutes\", waitMinutes);\n+        connectRetryJob = scheduler.schedule(this::connect, waitMinutes, TimeUnit.MINUTES);\n+    }\n+\n+    private synchronized void disconnect() {\n+        logger.debug(\"Disconnecting\");\n+\n+        Thread senderThread = this.senderThread;\n+        Thread readerThread = this.readerThread;\n+\n+        if (connectRetryJob != null) {\n+            connectRetryJob.cancel(true);\n+        }\n+        if (keepAlive != null) {\n+            keepAlive.cancel(true);\n+        }\n+\n+        // May be called from keepAliveReconnect thread, so call cancel with false\n+        reconnectTaskCancel(false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDcwMTQzOA=="}, "originalCommit": {"oid": "deb48c1252ee18917f2f9e19cf0158fedb164659"}, "originalPosition": 330}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjYwMjg2MA==", "bodyText": "I've changed this to use reconnectTaskCancel(true) when called from dispose().", "url": "https://github.com/openhab/openhab-addons/pull/8650#discussion_r502602860", "createdAt": "2020-10-09T18:25:51Z", "author": {"login": "bobadair"}, "path": "bundles/org.openhab.binding.lutron/src/main/java/org/openhab/binding/lutron/internal/handler/LeapBridgeHandler.java", "diffHunk": "@@ -0,0 +1,763 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lutron.internal.handler;\n+\n+import static org.openhab.binding.lutron.internal.LutronBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.net.UnknownHostException;\n+import java.security.KeyManagementException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.UnrecoverableKeyException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManager;\n+import javax.net.ssl.TrustManagerFactory;\n+import javax.net.ssl.X509TrustManager;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.lutron.internal.config.LeapBridgeConfig;\n+import org.openhab.binding.lutron.internal.discovery.LeapDeviceDiscoveryService;\n+import org.openhab.binding.lutron.internal.protocol.FanSpeedType;\n+import org.openhab.binding.lutron.internal.protocol.GroupCommand;\n+import org.openhab.binding.lutron.internal.protocol.LutronCommandNew;\n+import org.openhab.binding.lutron.internal.protocol.OutputCommand;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapCommand;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapMessageParser;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapMessageParserCallbacks;\n+import org.openhab.binding.lutron.internal.protocol.leap.Request;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Area;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ButtonGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Device;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.OccupancyGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ZoneStatus;\n+import org.openhab.binding.lutron.internal.protocol.lip.LutronCommandType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Bridge handler responsible for communicating with Lutron hubs that support the LEAP protocol, such as Caseta and\n+ * RA2 Select.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LeapBridgeHandler extends LutronBridgeHandler implements LeapMessageParserCallbacks {\n+    private static final int DEFAULT_RECONNECT_MINUTES = 5;\n+    private static final int DEFAULT_HEARTBEAT_MINUTES = 5;\n+    private static final long KEEPALIVE_TIMEOUT_SECONDS = 30;\n+\n+    private static final String STATUS_INITIALIZING = \"Initializing\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(LeapBridgeHandler.class);\n+\n+    private @NonNullByDefault({}) LeapBridgeConfig config;\n+    private int reconnectInterval;\n+    private int heartbeatInterval;\n+    private int sendDelay;\n+\n+    private @NonNullByDefault({}) SSLSocketFactory sslsocketfactory;\n+    private @Nullable SSLSocket sslsocket;\n+    private @Nullable BufferedWriter writer;\n+    private @Nullable BufferedReader reader;\n+\n+    private @NonNullByDefault({}) LeapMessageParser leapMessageParser;\n+\n+    private final BlockingQueue<LeapCommand> sendQueue = new LinkedBlockingQueue<>();\n+\n+    private @Nullable Thread senderThread;\n+    private @Nullable Thread readerThread;\n+\n+    private @Nullable ScheduledFuture<?> keepAlive;\n+    private @Nullable ScheduledFuture<?> keepAliveReconnect;\n+    private @Nullable ScheduledFuture<?> connectRetryJob;\n+    private final Object keepAliveReconnectLock = new Object();\n+\n+    private final Map<Integer, Integer> zoneToDevice = new HashMap<>();\n+    private final Map<Integer, Integer> deviceToZone = new HashMap<>();\n+    private final Object zoneMapsLock = new Object();\n+\n+    private @Nullable Map<Integer, List<Integer>> deviceButtonMap;\n+    private final Object deviceButtonMapLock = new Object();\n+\n+    private final AtomicBoolean deviceDataLoaded = new AtomicBoolean(false);\n+    private final AtomicBoolean buttonDataLoaded = new AtomicBoolean(false);\n+\n+    private final Map<Integer, LutronHandler> childHandlerMap = new ConcurrentHashMap<>();\n+    private final Map<Integer, OGroupHandler> groupHandlerMap = new ConcurrentHashMap<>();\n+\n+    private @Nullable LeapDeviceDiscoveryService discoveryService;\n+\n+    public void setDiscoveryService(LeapDeviceDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    public LeapBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+        leapMessageParser = new LeapMessageParser(this);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        SSLContext sslContext;\n+\n+        childHandlerMap.clear();\n+        groupHandlerMap.clear();\n+\n+        config = getConfigAs(LeapBridgeConfig.class);\n+        String keystorePassword = (config.keystorePassword == null) ? \"\" : config.keystorePassword;\n+\n+        String ipAddress = config.ipAddress;\n+        if (ipAddress == null || ipAddress.isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"bridge address not specified\");\n+            return;\n+        }\n+\n+        reconnectInterval = (config.reconnect > 0) ? config.reconnect : DEFAULT_RECONNECT_MINUTES;\n+        heartbeatInterval = (config.heartbeat > 0) ? config.heartbeat : DEFAULT_HEARTBEAT_MINUTES;\n+        sendDelay = (config.delay < 0) ? 0 : config.delay;\n+\n+        if (config.keystore == null || keystorePassword == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Keystore/keystore password not configured\");\n+            return;\n+        } else {\n+            try (FileInputStream keystoreInputStream = new FileInputStream(config.keystore)) {\n+                logger.trace(\"Initializing keystore\");\n+                KeyStore keystore = KeyStore.getInstance(KeyStore.getDefaultType());\n+\n+                keystore.load(keystoreInputStream, keystorePassword.toCharArray());\n+\n+                logger.trace(\"Initializing SSL Context\");\n+                KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n+                kmf.init(keystore, keystorePassword.toCharArray());\n+\n+                TrustManager[] trustManagers;\n+                if (config.certValidate) {\n+                    // Use default trust manager which will attempt to validate server certificate from hub\n+                    TrustManagerFactory tmf = TrustManagerFactory\n+                            .getInstance(TrustManagerFactory.getDefaultAlgorithm());\n+                    tmf.init(keystore);\n+                    trustManagers = tmf.getTrustManagers();\n+                } else {\n+                    // Use no-op trust manager which will not verify certificates\n+                    trustManagers = defineNoOpTrustManager();\n+                }\n+\n+                sslContext = SSLContext.getInstance(\"TLS\");\n+                sslContext.init(kmf.getKeyManagers(), trustManagers, null);\n+\n+                sslsocketfactory = sslContext.getSocketFactory();\n+            } catch (FileNotFoundException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Keystore file not found\");\n+                return;\n+            } catch (CertificateException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Certificate exception\");\n+                return;\n+            } catch (UnrecoverableKeyException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"Key unrecoverable with supplied password\");\n+                return;\n+            } catch (KeyManagementException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Key management exception\");\n+                logger.debug(\"Key management exception\", e);\n+                return;\n+            } catch (KeyStoreException | NoSuchAlgorithmException | IOException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Error initializing keystore\");\n+                logger.debug(\"Error initializing keystore\", e);\n+                return;\n+            }\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Connecting\");\n+        scheduler.submit(this::connect); // start the async connect task\n+    }\n+\n+    /**\n+     * Return a no-op SSL trust manager which will not verify server or client certificates.\n+     */\n+    private TrustManager[] defineNoOpTrustManager() {\n+        return new TrustManager[] { new X509TrustManager() {\n+            @Override\n+            public void checkClientTrusted(final X509Certificate @Nullable [] chain, final @Nullable String authType) {\n+                logger.debug(\"Assuming client certificate is valid\");\n+                if (chain != null) {\n+                    for (int cert = 0; cert < chain.length; cert++) {\n+                        logger.trace(\"Subject DN: {}\", chain[cert].getSubjectDN());\n+                        logger.trace(\"Issuer DN: {}\", chain[cert].getIssuerDN());\n+                        logger.trace(\"Serial number {}:\", chain[cert].getSerialNumber());\n+                    }\n+                }\n+            }\n+\n+            @Override\n+            public void checkServerTrusted(final X509Certificate @Nullable [] chain, final @Nullable String authType) {\n+                logger.debug(\"Assuming server certificate is valid\");\n+                if (chain != null) {\n+                    for (int cert = 0; cert < chain.length; cert++) {\n+                        logger.trace(\"Subject DN: {}\", chain[cert].getSubjectDN());\n+                        logger.trace(\"Issuer DN: {}\", chain[cert].getIssuerDN());\n+                        logger.trace(\"Serial number: {}\", chain[cert].getSerialNumber());\n+                    }\n+                }\n+            }\n+\n+            @Override\n+            public X509Certificate @Nullable [] getAcceptedIssuers() {\n+                return null;\n+            }\n+        } };\n+    }\n+\n+    private synchronized void connect() {\n+        deviceDataLoaded.set(false);\n+        buttonDataLoaded.set(false);\n+\n+        try {\n+            logger.debug(\"Opening SSL connection to {}:{}\", config.ipAddress, config.port);\n+            SSLSocket sslsocket = (SSLSocket) sslsocketfactory.createSocket(config.ipAddress, config.port);\n+            sslsocket.startHandshake();\n+            writer = new BufferedWriter(new OutputStreamWriter(sslsocket.getOutputStream()));\n+            reader = new BufferedReader(new InputStreamReader(sslsocket.getInputStream()));\n+            this.sslsocket = sslsocket;\n+        } catch (UnknownHostException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Unknown host\");\n+            return;\n+        } catch (IllegalArgumentException e) {\n+            // port out of valid range\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Invalid port number\");\n+            return;\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Error opening SSL connection. Check log.\");\n+            logger.info(\"Error opening SSL connection: {}\", e.getMessage());\n+            disconnect();\n+            scheduleConnectRetry(reconnectInterval); // Possibly a temporary problem. Try again later.\n+            return;\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, STATUS_INITIALIZING);\n+\n+        Thread readerThread = new Thread(this::readerThreadJob, \"Lutron reader\");\n+        readerThread.setDaemon(true);\n+        readerThread.start();\n+        this.readerThread = readerThread;\n+\n+        Thread senderThread = new Thread(this::senderThreadJob, \"Lutron sender\");\n+        senderThread.setDaemon(true);\n+        senderThread.start();\n+        this.senderThread = senderThread;\n+\n+        sendCommand(new LeapCommand(Request.getButtonGroups()));\n+        queryDiscoveryData();\n+        sendCommand(new LeapCommand(Request.subscribeOccupancyGroupStatus()));\n+\n+        logger.debug(\"Starting keepAlive job with interval {}\", heartbeatInterval);\n+        keepAlive = scheduler.scheduleWithFixedDelay(this::sendKeepAlive, heartbeatInterval, heartbeatInterval,\n+                TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Called by connect() and discovery service to request fresh discovery data\n+     */\n+    public void queryDiscoveryData() {\n+        sendCommand(new LeapCommand(Request.getDevices()));\n+        sendCommand(new LeapCommand(Request.getAreas()));\n+        sendCommand(new LeapCommand(Request.getOccupancyGroups()));\n+    }\n+\n+    private void scheduleConnectRetry(long waitMinutes) {\n+        logger.debug(\"Scheduling connection retry in {} minutes\", waitMinutes);\n+        connectRetryJob = scheduler.schedule(this::connect, waitMinutes, TimeUnit.MINUTES);\n+    }\n+\n+    private synchronized void disconnect() {\n+        logger.debug(\"Disconnecting\");\n+\n+        Thread senderThread = this.senderThread;\n+        Thread readerThread = this.readerThread;\n+\n+        if (connectRetryJob != null) {\n+            connectRetryJob.cancel(true);\n+        }\n+        if (keepAlive != null) {\n+            keepAlive.cancel(true);\n+        }\n+\n+        // May be called from keepAliveReconnect thread, so call cancel with false\n+        reconnectTaskCancel(false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDcwMTQzOA=="}, "originalCommit": {"oid": "deb48c1252ee18917f2f9e19cf0158fedb164659"}, "originalPosition": 330}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNTEyMTY4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.lutron/src/main/java/org/openhab/binding/lutron/internal/handler/LeapBridgeHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwMjoyODoxNVrOHdgaFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwMjoyODoxNVrOHdgaFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDcwMTcxNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            if (chain != null) {\n          \n          \n            \n                            if (chain != null && logger.isTraceEnabled()) {", "url": "https://github.com/openhab/openhab-addons/pull/8650#discussion_r500701716", "createdAt": "2020-10-07T02:28:15Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lutron/src/main/java/org/openhab/binding/lutron/internal/handler/LeapBridgeHandler.java", "diffHunk": "@@ -0,0 +1,763 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lutron.internal.handler;\n+\n+import static org.openhab.binding.lutron.internal.LutronBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.net.UnknownHostException;\n+import java.security.KeyManagementException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.UnrecoverableKeyException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManager;\n+import javax.net.ssl.TrustManagerFactory;\n+import javax.net.ssl.X509TrustManager;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.lutron.internal.config.LeapBridgeConfig;\n+import org.openhab.binding.lutron.internal.discovery.LeapDeviceDiscoveryService;\n+import org.openhab.binding.lutron.internal.protocol.FanSpeedType;\n+import org.openhab.binding.lutron.internal.protocol.GroupCommand;\n+import org.openhab.binding.lutron.internal.protocol.LutronCommandNew;\n+import org.openhab.binding.lutron.internal.protocol.OutputCommand;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapCommand;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapMessageParser;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapMessageParserCallbacks;\n+import org.openhab.binding.lutron.internal.protocol.leap.Request;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Area;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ButtonGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Device;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.OccupancyGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ZoneStatus;\n+import org.openhab.binding.lutron.internal.protocol.lip.LutronCommandType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Bridge handler responsible for communicating with Lutron hubs that support the LEAP protocol, such as Caseta and\n+ * RA2 Select.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LeapBridgeHandler extends LutronBridgeHandler implements LeapMessageParserCallbacks {\n+    private static final int DEFAULT_RECONNECT_MINUTES = 5;\n+    private static final int DEFAULT_HEARTBEAT_MINUTES = 5;\n+    private static final long KEEPALIVE_TIMEOUT_SECONDS = 30;\n+\n+    private static final String STATUS_INITIALIZING = \"Initializing\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(LeapBridgeHandler.class);\n+\n+    private @NonNullByDefault({}) LeapBridgeConfig config;\n+    private int reconnectInterval;\n+    private int heartbeatInterval;\n+    private int sendDelay;\n+\n+    private @NonNullByDefault({}) SSLSocketFactory sslsocketfactory;\n+    private @Nullable SSLSocket sslsocket;\n+    private @Nullable BufferedWriter writer;\n+    private @Nullable BufferedReader reader;\n+\n+    private @NonNullByDefault({}) LeapMessageParser leapMessageParser;\n+\n+    private final BlockingQueue<LeapCommand> sendQueue = new LinkedBlockingQueue<>();\n+\n+    private @Nullable Thread senderThread;\n+    private @Nullable Thread readerThread;\n+\n+    private @Nullable ScheduledFuture<?> keepAlive;\n+    private @Nullable ScheduledFuture<?> keepAliveReconnect;\n+    private @Nullable ScheduledFuture<?> connectRetryJob;\n+    private final Object keepAliveReconnectLock = new Object();\n+\n+    private final Map<Integer, Integer> zoneToDevice = new HashMap<>();\n+    private final Map<Integer, Integer> deviceToZone = new HashMap<>();\n+    private final Object zoneMapsLock = new Object();\n+\n+    private @Nullable Map<Integer, List<Integer>> deviceButtonMap;\n+    private final Object deviceButtonMapLock = new Object();\n+\n+    private final AtomicBoolean deviceDataLoaded = new AtomicBoolean(false);\n+    private final AtomicBoolean buttonDataLoaded = new AtomicBoolean(false);\n+\n+    private final Map<Integer, LutronHandler> childHandlerMap = new ConcurrentHashMap<>();\n+    private final Map<Integer, OGroupHandler> groupHandlerMap = new ConcurrentHashMap<>();\n+\n+    private @Nullable LeapDeviceDiscoveryService discoveryService;\n+\n+    public void setDiscoveryService(LeapDeviceDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    public LeapBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+        leapMessageParser = new LeapMessageParser(this);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        SSLContext sslContext;\n+\n+        childHandlerMap.clear();\n+        groupHandlerMap.clear();\n+\n+        config = getConfigAs(LeapBridgeConfig.class);\n+        String keystorePassword = (config.keystorePassword == null) ? \"\" : config.keystorePassword;\n+\n+        String ipAddress = config.ipAddress;\n+        if (ipAddress == null || ipAddress.isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"bridge address not specified\");\n+            return;\n+        }\n+\n+        reconnectInterval = (config.reconnect > 0) ? config.reconnect : DEFAULT_RECONNECT_MINUTES;\n+        heartbeatInterval = (config.heartbeat > 0) ? config.heartbeat : DEFAULT_HEARTBEAT_MINUTES;\n+        sendDelay = (config.delay < 0) ? 0 : config.delay;\n+\n+        if (config.keystore == null || keystorePassword == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Keystore/keystore password not configured\");\n+            return;\n+        } else {\n+            try (FileInputStream keystoreInputStream = new FileInputStream(config.keystore)) {\n+                logger.trace(\"Initializing keystore\");\n+                KeyStore keystore = KeyStore.getInstance(KeyStore.getDefaultType());\n+\n+                keystore.load(keystoreInputStream, keystorePassword.toCharArray());\n+\n+                logger.trace(\"Initializing SSL Context\");\n+                KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n+                kmf.init(keystore, keystorePassword.toCharArray());\n+\n+                TrustManager[] trustManagers;\n+                if (config.certValidate) {\n+                    // Use default trust manager which will attempt to validate server certificate from hub\n+                    TrustManagerFactory tmf = TrustManagerFactory\n+                            .getInstance(TrustManagerFactory.getDefaultAlgorithm());\n+                    tmf.init(keystore);\n+                    trustManagers = tmf.getTrustManagers();\n+                } else {\n+                    // Use no-op trust manager which will not verify certificates\n+                    trustManagers = defineNoOpTrustManager();\n+                }\n+\n+                sslContext = SSLContext.getInstance(\"TLS\");\n+                sslContext.init(kmf.getKeyManagers(), trustManagers, null);\n+\n+                sslsocketfactory = sslContext.getSocketFactory();\n+            } catch (FileNotFoundException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Keystore file not found\");\n+                return;\n+            } catch (CertificateException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Certificate exception\");\n+                return;\n+            } catch (UnrecoverableKeyException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"Key unrecoverable with supplied password\");\n+                return;\n+            } catch (KeyManagementException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Key management exception\");\n+                logger.debug(\"Key management exception\", e);\n+                return;\n+            } catch (KeyStoreException | NoSuchAlgorithmException | IOException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Error initializing keystore\");\n+                logger.debug(\"Error initializing keystore\", e);\n+                return;\n+            }\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Connecting\");\n+        scheduler.submit(this::connect); // start the async connect task\n+    }\n+\n+    /**\n+     * Return a no-op SSL trust manager which will not verify server or client certificates.\n+     */\n+    private TrustManager[] defineNoOpTrustManager() {\n+        return new TrustManager[] { new X509TrustManager() {\n+            @Override\n+            public void checkClientTrusted(final X509Certificate @Nullable [] chain, final @Nullable String authType) {\n+                logger.debug(\"Assuming client certificate is valid\");\n+                if (chain != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "deb48c1252ee18917f2f9e19cf0158fedb164659"}, "originalPosition": 226}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNTEyMjE2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.lutron/src/main/java/org/openhab/binding/lutron/internal/handler/LeapBridgeHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwMjoyODozMFrOHdgaVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwMjoyODozMFrOHdgaVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDcwMTc4MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            if (chain != null) {\n          \n          \n            \n                            if (chain != null && logger.isTraceEnabled()) {", "url": "https://github.com/openhab/openhab-addons/pull/8650#discussion_r500701780", "createdAt": "2020-10-07T02:28:30Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lutron/src/main/java/org/openhab/binding/lutron/internal/handler/LeapBridgeHandler.java", "diffHunk": "@@ -0,0 +1,763 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lutron.internal.handler;\n+\n+import static org.openhab.binding.lutron.internal.LutronBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.net.UnknownHostException;\n+import java.security.KeyManagementException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.UnrecoverableKeyException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManager;\n+import javax.net.ssl.TrustManagerFactory;\n+import javax.net.ssl.X509TrustManager;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.lutron.internal.config.LeapBridgeConfig;\n+import org.openhab.binding.lutron.internal.discovery.LeapDeviceDiscoveryService;\n+import org.openhab.binding.lutron.internal.protocol.FanSpeedType;\n+import org.openhab.binding.lutron.internal.protocol.GroupCommand;\n+import org.openhab.binding.lutron.internal.protocol.LutronCommandNew;\n+import org.openhab.binding.lutron.internal.protocol.OutputCommand;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapCommand;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapMessageParser;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapMessageParserCallbacks;\n+import org.openhab.binding.lutron.internal.protocol.leap.Request;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Area;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ButtonGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Device;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.OccupancyGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ZoneStatus;\n+import org.openhab.binding.lutron.internal.protocol.lip.LutronCommandType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Bridge handler responsible for communicating with Lutron hubs that support the LEAP protocol, such as Caseta and\n+ * RA2 Select.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LeapBridgeHandler extends LutronBridgeHandler implements LeapMessageParserCallbacks {\n+    private static final int DEFAULT_RECONNECT_MINUTES = 5;\n+    private static final int DEFAULT_HEARTBEAT_MINUTES = 5;\n+    private static final long KEEPALIVE_TIMEOUT_SECONDS = 30;\n+\n+    private static final String STATUS_INITIALIZING = \"Initializing\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(LeapBridgeHandler.class);\n+\n+    private @NonNullByDefault({}) LeapBridgeConfig config;\n+    private int reconnectInterval;\n+    private int heartbeatInterval;\n+    private int sendDelay;\n+\n+    private @NonNullByDefault({}) SSLSocketFactory sslsocketfactory;\n+    private @Nullable SSLSocket sslsocket;\n+    private @Nullable BufferedWriter writer;\n+    private @Nullable BufferedReader reader;\n+\n+    private @NonNullByDefault({}) LeapMessageParser leapMessageParser;\n+\n+    private final BlockingQueue<LeapCommand> sendQueue = new LinkedBlockingQueue<>();\n+\n+    private @Nullable Thread senderThread;\n+    private @Nullable Thread readerThread;\n+\n+    private @Nullable ScheduledFuture<?> keepAlive;\n+    private @Nullable ScheduledFuture<?> keepAliveReconnect;\n+    private @Nullable ScheduledFuture<?> connectRetryJob;\n+    private final Object keepAliveReconnectLock = new Object();\n+\n+    private final Map<Integer, Integer> zoneToDevice = new HashMap<>();\n+    private final Map<Integer, Integer> deviceToZone = new HashMap<>();\n+    private final Object zoneMapsLock = new Object();\n+\n+    private @Nullable Map<Integer, List<Integer>> deviceButtonMap;\n+    private final Object deviceButtonMapLock = new Object();\n+\n+    private final AtomicBoolean deviceDataLoaded = new AtomicBoolean(false);\n+    private final AtomicBoolean buttonDataLoaded = new AtomicBoolean(false);\n+\n+    private final Map<Integer, LutronHandler> childHandlerMap = new ConcurrentHashMap<>();\n+    private final Map<Integer, OGroupHandler> groupHandlerMap = new ConcurrentHashMap<>();\n+\n+    private @Nullable LeapDeviceDiscoveryService discoveryService;\n+\n+    public void setDiscoveryService(LeapDeviceDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    public LeapBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+        leapMessageParser = new LeapMessageParser(this);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        SSLContext sslContext;\n+\n+        childHandlerMap.clear();\n+        groupHandlerMap.clear();\n+\n+        config = getConfigAs(LeapBridgeConfig.class);\n+        String keystorePassword = (config.keystorePassword == null) ? \"\" : config.keystorePassword;\n+\n+        String ipAddress = config.ipAddress;\n+        if (ipAddress == null || ipAddress.isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"bridge address not specified\");\n+            return;\n+        }\n+\n+        reconnectInterval = (config.reconnect > 0) ? config.reconnect : DEFAULT_RECONNECT_MINUTES;\n+        heartbeatInterval = (config.heartbeat > 0) ? config.heartbeat : DEFAULT_HEARTBEAT_MINUTES;\n+        sendDelay = (config.delay < 0) ? 0 : config.delay;\n+\n+        if (config.keystore == null || keystorePassword == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Keystore/keystore password not configured\");\n+            return;\n+        } else {\n+            try (FileInputStream keystoreInputStream = new FileInputStream(config.keystore)) {\n+                logger.trace(\"Initializing keystore\");\n+                KeyStore keystore = KeyStore.getInstance(KeyStore.getDefaultType());\n+\n+                keystore.load(keystoreInputStream, keystorePassword.toCharArray());\n+\n+                logger.trace(\"Initializing SSL Context\");\n+                KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n+                kmf.init(keystore, keystorePassword.toCharArray());\n+\n+                TrustManager[] trustManagers;\n+                if (config.certValidate) {\n+                    // Use default trust manager which will attempt to validate server certificate from hub\n+                    TrustManagerFactory tmf = TrustManagerFactory\n+                            .getInstance(TrustManagerFactory.getDefaultAlgorithm());\n+                    tmf.init(keystore);\n+                    trustManagers = tmf.getTrustManagers();\n+                } else {\n+                    // Use no-op trust manager which will not verify certificates\n+                    trustManagers = defineNoOpTrustManager();\n+                }\n+\n+                sslContext = SSLContext.getInstance(\"TLS\");\n+                sslContext.init(kmf.getKeyManagers(), trustManagers, null);\n+\n+                sslsocketfactory = sslContext.getSocketFactory();\n+            } catch (FileNotFoundException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Keystore file not found\");\n+                return;\n+            } catch (CertificateException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Certificate exception\");\n+                return;\n+            } catch (UnrecoverableKeyException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"Key unrecoverable with supplied password\");\n+                return;\n+            } catch (KeyManagementException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Key management exception\");\n+                logger.debug(\"Key management exception\", e);\n+                return;\n+            } catch (KeyStoreException | NoSuchAlgorithmException | IOException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Error initializing keystore\");\n+                logger.debug(\"Error initializing keystore\", e);\n+                return;\n+            }\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Connecting\");\n+        scheduler.submit(this::connect); // start the async connect task\n+    }\n+\n+    /**\n+     * Return a no-op SSL trust manager which will not verify server or client certificates.\n+     */\n+    private TrustManager[] defineNoOpTrustManager() {\n+        return new TrustManager[] { new X509TrustManager() {\n+            @Override\n+            public void checkClientTrusted(final X509Certificate @Nullable [] chain, final @Nullable String authType) {\n+                logger.debug(\"Assuming client certificate is valid\");\n+                if (chain != null) {\n+                    for (int cert = 0; cert < chain.length; cert++) {\n+                        logger.trace(\"Subject DN: {}\", chain[cert].getSubjectDN());\n+                        logger.trace(\"Issuer DN: {}\", chain[cert].getIssuerDN());\n+                        logger.trace(\"Serial number {}:\", chain[cert].getSerialNumber());\n+                    }\n+                }\n+            }\n+\n+            @Override\n+            public void checkServerTrusted(final X509Certificate @Nullable [] chain, final @Nullable String authType) {\n+                logger.debug(\"Assuming server certificate is valid\");\n+                if (chain != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "deb48c1252ee18917f2f9e19cf0158fedb164659"}, "originalPosition": 238}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1MDIzMTQ4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.lutron/src/main/java/org/openhab/binding/lutron/internal/handler/PicoKeypadHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMVQyMjo0NTozMVrOHfrOfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQyMTo1NzowNFrOHgOi2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk3NjEyNg==", "bodyText": "the main branch is running on java 11, so perhaps you could get rid of this ugly stuff now?", "url": "https://github.com/openhab/openhab-addons/pull/8650#discussion_r502976126", "createdAt": "2020-10-11T22:45:31Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lutron/src/main/java/org/openhab/binding/lutron/internal/handler/PicoKeypadHandler.java", "diffHunk": "@@ -35,24 +37,69 @@ public PicoKeypadHandler(Thing thing) {\n         kp = new KeypadConfigPico();\n     }\n \n+    @SuppressWarnings(\"serial\")\n     @Override\n     protected void configureComponents(@Nullable String model) {\n         String mod = model == null ? \"Generic\" : model;\n         logger.debug(\"Configuring components for keypad model {}\", mod);\n \n         switch (mod) {\n             case \"2B\":\n+                buttonList = kp.getComponents(mod, ComponentType.BUTTON);\n+                leapButtonMap = new HashMap<Integer, Integer>() {\n+                    {\n+                        put(2, 1);\n+                        put(4, 2);\n+                    }\n+                }; // Note: we can get rid of this ugly stuff with java 9 and above", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40d4fc56591c84fbeb9ce05ce90473724e53bf3a"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU1NDc3OQ==", "bodyText": "Good catch. I was originally targeting this for 2.5.x with its Java 8 requirement.", "url": "https://github.com/openhab/openhab-addons/pull/8650#discussion_r503554779", "createdAt": "2020-10-12T21:57:04Z", "author": {"login": "bobadair"}, "path": "bundles/org.openhab.binding.lutron/src/main/java/org/openhab/binding/lutron/internal/handler/PicoKeypadHandler.java", "diffHunk": "@@ -35,24 +37,69 @@ public PicoKeypadHandler(Thing thing) {\n         kp = new KeypadConfigPico();\n     }\n \n+    @SuppressWarnings(\"serial\")\n     @Override\n     protected void configureComponents(@Nullable String model) {\n         String mod = model == null ? \"Generic\" : model;\n         logger.debug(\"Configuring components for keypad model {}\", mod);\n \n         switch (mod) {\n             case \"2B\":\n+                buttonList = kp.getComponents(mod, ComponentType.BUTTON);\n+                leapButtonMap = new HashMap<Integer, Integer>() {\n+                    {\n+                        put(2, 1);\n+                        put(4, 2);\n+                    }\n+                }; // Note: we can get rid of this ugly stuff with java 9 and above", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk3NjEyNg=="}, "originalCommit": {"oid": "40d4fc56591c84fbeb9ce05ce90473724e53bf3a"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1MDI2NzMwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.lutron/src/main/java/org/openhab/binding/lutron/internal/handler/LeapBridgeHandler.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMVQyMzoyNzoyNFrOHfrgJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQyMjo1NjoyN1rOHieRvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4MDY0Nw==", "bodyText": "The spawning of asynchronous tasks inside of other asynchronous tasks can be a real source of problems if you are trying to dispose the handler while it is getting initialized. I suggest wrapping the Thread fields in a CompletableFuture so that you have a way to prevent starting them in the event that dispose it called before your asynchronous task initialized them.\nCompletableFuture<Thread> readThreadFuture;\n\npublic void initialize() {\n  readThreadFuture = new CompletableFuture<>();\n  readThreadFuture.thenAccept(Thread::start);\n\n  Thread readerThread = new Thread(this::readerThreadJob, \"Lutron reader\");\n  readerThread.setDaemon(true);\n\n  executor.submit(() -> {\n    ...\n    readThreadFuture.complete(readerThread);\n  });\n}\n\npublic void dispose(){\n  //if this completes the future the asynchronous 'complete()' will be ignored\n  if(!readThreadFuture.cancel(false)){\n     //failure to cancel means that the future completed first, so lets interrupt the thread then   \n     readThreadFuture.thenAccept(thread -> thread.interrupt());\n  }\n}\n\nIn addition could you initialize your keepAliveJob inside of the initialize() method instead of doing it asynchronously? You could just make the keepAliveJob skip if the socket isn't ready yet.", "url": "https://github.com/openhab/openhab-addons/pull/8650#discussion_r502980647", "createdAt": "2020-10-11T23:27:24Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lutron/src/main/java/org/openhab/binding/lutron/internal/handler/LeapBridgeHandler.java", "diffHunk": "@@ -0,0 +1,802 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lutron.internal.handler;\n+\n+import static org.openhab.binding.lutron.internal.LutronBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.InterruptedIOException;\n+import java.io.OutputStreamWriter;\n+import java.net.UnknownHostException;\n+import java.security.KeyManagementException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.UnrecoverableKeyException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManager;\n+import javax.net.ssl.TrustManagerFactory;\n+import javax.net.ssl.X509TrustManager;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.lutron.internal.config.LeapBridgeConfig;\n+import org.openhab.binding.lutron.internal.discovery.LeapDeviceDiscoveryService;\n+import org.openhab.binding.lutron.internal.protocol.FanSpeedType;\n+import org.openhab.binding.lutron.internal.protocol.GroupCommand;\n+import org.openhab.binding.lutron.internal.protocol.LutronCommandNew;\n+import org.openhab.binding.lutron.internal.protocol.OutputCommand;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapCommand;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapMessageParser;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapMessageParserCallbacks;\n+import org.openhab.binding.lutron.internal.protocol.leap.Request;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Area;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ButtonGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Device;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.OccupancyGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ZoneStatus;\n+import org.openhab.binding.lutron.internal.protocol.lip.LutronCommandType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Bridge handler responsible for communicating with Lutron hubs that support the LEAP protocol, such as Caseta and\n+ * RA2 Select.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LeapBridgeHandler extends LutronBridgeHandler implements LeapMessageParserCallbacks {\n+    private static final int DEFAULT_RECONNECT_MINUTES = 5;\n+    private static final int DEFAULT_HEARTBEAT_MINUTES = 5;\n+    private static final long KEEPALIVE_TIMEOUT_SECONDS = 30;\n+\n+    private static final String STATUS_INITIALIZING = \"Initializing\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(LeapBridgeHandler.class);\n+\n+    private @NonNullByDefault({}) LeapBridgeConfig config;\n+    private int reconnectInterval;\n+    private int heartbeatInterval;\n+    private int sendDelay;\n+\n+    private @NonNullByDefault({}) SSLSocketFactory sslsocketfactory;\n+    private @Nullable SSLSocket sslsocket;\n+    private @Nullable BufferedWriter writer;\n+    private @Nullable BufferedReader reader;\n+\n+    private @NonNullByDefault({}) LeapMessageParser leapMessageParser;\n+\n+    private final BlockingQueue<LeapCommand> sendQueue = new LinkedBlockingQueue<>();\n+\n+    private @Nullable Future<?> asyncInitializeTask;\n+\n+    private @Nullable Thread senderThread;\n+    private @Nullable Thread readerThread;\n+\n+    private @Nullable ScheduledFuture<?> keepAliveJob;\n+    private @Nullable ScheduledFuture<?> keepAliveReconnectJob;\n+    private @Nullable ScheduledFuture<?> connectRetryJob;\n+    private final Object keepAliveReconnectLock = new Object();\n+\n+    private final Map<Integer, Integer> zoneToDevice = new HashMap<>();\n+    private final Map<Integer, Integer> deviceToZone = new HashMap<>();\n+    private final Object zoneMapsLock = new Object();\n+\n+    private @Nullable Map<Integer, List<Integer>> deviceButtonMap;\n+    private final Object deviceButtonMapLock = new Object();\n+\n+    private volatile boolean deviceDataLoaded = false;\n+    private volatile boolean buttonDataLoaded = false;\n+\n+    private final Map<Integer, LutronHandler> childHandlerMap = new ConcurrentHashMap<>();\n+    private final Map<Integer, OGroupHandler> groupHandlerMap = new ConcurrentHashMap<>();\n+\n+    private @Nullable LeapDeviceDiscoveryService discoveryService;\n+\n+    public void setDiscoveryService(LeapDeviceDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    public LeapBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+        leapMessageParser = new LeapMessageParser(this);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(LeapDeviceDiscoveryService.class);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        SSLContext sslContext;\n+\n+        childHandlerMap.clear();\n+        groupHandlerMap.clear();\n+\n+        config = getConfigAs(LeapBridgeConfig.class);\n+        String keystorePassword = (config.keystorePassword == null) ? \"\" : config.keystorePassword;\n+\n+        String ipAddress = config.ipAddress;\n+        if (ipAddress == null || ipAddress.isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"bridge address not specified\");\n+            return;\n+        }\n+\n+        reconnectInterval = (config.reconnect > 0) ? config.reconnect : DEFAULT_RECONNECT_MINUTES;\n+        heartbeatInterval = (config.heartbeat > 0) ? config.heartbeat : DEFAULT_HEARTBEAT_MINUTES;\n+        sendDelay = (config.delay < 0) ? 0 : config.delay;\n+\n+        if (config.keystore == null || keystorePassword == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Keystore/keystore password not configured\");\n+            return;\n+        } else {\n+            try (FileInputStream keystoreInputStream = new FileInputStream(config.keystore)) {\n+                logger.trace(\"Initializing keystore\");\n+                KeyStore keystore = KeyStore.getInstance(KeyStore.getDefaultType());\n+\n+                keystore.load(keystoreInputStream, keystorePassword.toCharArray());\n+\n+                logger.trace(\"Initializing SSL Context\");\n+                KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n+                kmf.init(keystore, keystorePassword.toCharArray());\n+\n+                TrustManager[] trustManagers;\n+                if (config.certValidate) {\n+                    // Use default trust manager which will attempt to validate server certificate from hub\n+                    TrustManagerFactory tmf = TrustManagerFactory\n+                            .getInstance(TrustManagerFactory.getDefaultAlgorithm());\n+                    tmf.init(keystore);\n+                    trustManagers = tmf.getTrustManagers();\n+                } else {\n+                    // Use no-op trust manager which will not verify certificates\n+                    trustManagers = defineNoOpTrustManager();\n+                }\n+\n+                sslContext = SSLContext.getInstance(\"TLS\");\n+                sslContext.init(kmf.getKeyManagers(), trustManagers, null);\n+\n+                sslsocketfactory = sslContext.getSocketFactory();\n+            } catch (FileNotFoundException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Keystore file not found\");\n+                return;\n+            } catch (CertificateException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Certificate exception\");\n+                return;\n+            } catch (UnrecoverableKeyException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"Key unrecoverable with supplied password\");\n+                return;\n+            } catch (KeyManagementException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Key management exception\");\n+                logger.debug(\"Key management exception\", e);\n+                return;\n+            } catch (KeyStoreException | NoSuchAlgorithmException | IOException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Error initializing keystore\");\n+                logger.debug(\"Error initializing keystore\", e);\n+                return;\n+            }\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Connecting\");\n+        asyncInitializeTask = scheduler.submit(this::connect); // start the async connect task\n+    }\n+\n+    /**\n+     * Return a no-op SSL trust manager which will not verify server or client certificates.\n+     */\n+    private TrustManager[] defineNoOpTrustManager() {\n+        return new TrustManager[] { new X509TrustManager() {\n+            @Override\n+            public void checkClientTrusted(final X509Certificate @Nullable [] chain, final @Nullable String authType) {\n+                logger.debug(\"Assuming client certificate is valid\");\n+                if (chain != null && logger.isTraceEnabled()) {\n+                    for (int cert = 0; cert < chain.length; cert++) {\n+                        logger.trace(\"Subject DN: {}\", chain[cert].getSubjectDN());\n+                        logger.trace(\"Issuer DN: {}\", chain[cert].getIssuerDN());\n+                        logger.trace(\"Serial number {}:\", chain[cert].getSerialNumber());\n+                    }\n+                }\n+            }\n+\n+            @Override\n+            public void checkServerTrusted(final X509Certificate @Nullable [] chain, final @Nullable String authType) {\n+                logger.debug(\"Assuming server certificate is valid\");\n+                if (chain != null && logger.isTraceEnabled()) {\n+                    for (int cert = 0; cert < chain.length; cert++) {\n+                        logger.trace(\"Subject DN: {}\", chain[cert].getSubjectDN());\n+                        logger.trace(\"Issuer DN: {}\", chain[cert].getIssuerDN());\n+                        logger.trace(\"Serial number: {}\", chain[cert].getSerialNumber());\n+                    }\n+                }\n+            }\n+\n+            @Override\n+            public X509Certificate @Nullable [] getAcceptedIssuers() {\n+                return null;\n+            }\n+        } };\n+    }\n+\n+    private synchronized void connect() {\n+        deviceDataLoaded = false;\n+        buttonDataLoaded = false;\n+\n+        try {\n+            logger.debug(\"Opening SSL connection to {}:{}\", config.ipAddress, config.port);\n+            SSLSocket sslsocket = (SSLSocket) sslsocketfactory.createSocket(config.ipAddress, config.port);\n+            sslsocket.startHandshake();\n+            writer = new BufferedWriter(new OutputStreamWriter(sslsocket.getOutputStream()));\n+            reader = new BufferedReader(new InputStreamReader(sslsocket.getInputStream()));\n+            this.sslsocket = sslsocket;\n+        } catch (UnknownHostException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Unknown host\");\n+            return;\n+        } catch (IllegalArgumentException e) {\n+            // port out of valid range\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Invalid port number\");\n+            return;\n+        } catch (InterruptedIOException e) {\n+            Thread.currentThread().interrupt();\n+            logger.debug(\"Interrupted while establishing connection\");\n+            return;\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Error opening SSL connection. Check log.\");\n+            logger.info(\"Error opening SSL connection: {}\", e.getMessage());\n+            disconnect(false);\n+            scheduleConnectRetry(reconnectInterval); // Possibly a temporary problem. Try again later.\n+            return;\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, STATUS_INITIALIZING);\n+\n+        Thread readerThread = new Thread(this::readerThreadJob, \"Lutron reader\");\n+        readerThread.setDaemon(true);\n+        readerThread.start();\n+        this.readerThread = readerThread;\n+\n+        Thread senderThread = new Thread(this::senderThreadJob, \"Lutron sender\");\n+        senderThread.setDaemon(true);\n+        senderThread.start();\n+        this.senderThread = senderThread;\n+\n+        sendCommand(new LeapCommand(Request.getButtonGroups()));\n+        queryDiscoveryData();\n+        sendCommand(new LeapCommand(Request.subscribeOccupancyGroupStatus()));\n+\n+        logger.debug(\"Starting keepalive job with interval {}\", heartbeatInterval);\n+        keepAliveJob = scheduler.scheduleWithFixedDelay(this::sendKeepAlive, heartbeatInterval, heartbeatInterval,\n+                TimeUnit.MINUTES);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40d4fc56591c84fbeb9ce05ce90473724e53bf3a"}, "originalPosition": 314}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDMyMjI3Mg==", "bodyText": "Sorry, I've been kind of tied up lately. I looked through that code again, though, and I don't really see any potential problems. Both connect() and disconnect() are synchronized. The dispose() routine calls cancel(true) on the Future running connect(), if it is still running, and then calls disconnect(). So disconnect() will wait for connect() to exit, and then clean up anything it did, including canceling connectRetryJob, keepAliveJob, and keepAliveReconnectJob, and interrupting senderThread and readerThread. It also closes the SSL socket, which would cause senderThread and readerThread to exit regardless. I should check to see if any of those should be declared as volatile to eliminate any potential inter-thread visibility problems, but other that than I don't really see any potential issues with dispose() whenever it's called. Very similar code is being used in this binding's ipbridge and in the alarm decoder binding's ipbridge.", "url": "https://github.com/openhab/openhab-addons/pull/8650#discussion_r504322272", "createdAt": "2020-10-13T23:52:43Z", "author": {"login": "bobadair"}, "path": "bundles/org.openhab.binding.lutron/src/main/java/org/openhab/binding/lutron/internal/handler/LeapBridgeHandler.java", "diffHunk": "@@ -0,0 +1,802 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lutron.internal.handler;\n+\n+import static org.openhab.binding.lutron.internal.LutronBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.InterruptedIOException;\n+import java.io.OutputStreamWriter;\n+import java.net.UnknownHostException;\n+import java.security.KeyManagementException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.UnrecoverableKeyException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManager;\n+import javax.net.ssl.TrustManagerFactory;\n+import javax.net.ssl.X509TrustManager;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.lutron.internal.config.LeapBridgeConfig;\n+import org.openhab.binding.lutron.internal.discovery.LeapDeviceDiscoveryService;\n+import org.openhab.binding.lutron.internal.protocol.FanSpeedType;\n+import org.openhab.binding.lutron.internal.protocol.GroupCommand;\n+import org.openhab.binding.lutron.internal.protocol.LutronCommandNew;\n+import org.openhab.binding.lutron.internal.protocol.OutputCommand;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapCommand;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapMessageParser;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapMessageParserCallbacks;\n+import org.openhab.binding.lutron.internal.protocol.leap.Request;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Area;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ButtonGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Device;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.OccupancyGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ZoneStatus;\n+import org.openhab.binding.lutron.internal.protocol.lip.LutronCommandType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Bridge handler responsible for communicating with Lutron hubs that support the LEAP protocol, such as Caseta and\n+ * RA2 Select.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LeapBridgeHandler extends LutronBridgeHandler implements LeapMessageParserCallbacks {\n+    private static final int DEFAULT_RECONNECT_MINUTES = 5;\n+    private static final int DEFAULT_HEARTBEAT_MINUTES = 5;\n+    private static final long KEEPALIVE_TIMEOUT_SECONDS = 30;\n+\n+    private static final String STATUS_INITIALIZING = \"Initializing\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(LeapBridgeHandler.class);\n+\n+    private @NonNullByDefault({}) LeapBridgeConfig config;\n+    private int reconnectInterval;\n+    private int heartbeatInterval;\n+    private int sendDelay;\n+\n+    private @NonNullByDefault({}) SSLSocketFactory sslsocketfactory;\n+    private @Nullable SSLSocket sslsocket;\n+    private @Nullable BufferedWriter writer;\n+    private @Nullable BufferedReader reader;\n+\n+    private @NonNullByDefault({}) LeapMessageParser leapMessageParser;\n+\n+    private final BlockingQueue<LeapCommand> sendQueue = new LinkedBlockingQueue<>();\n+\n+    private @Nullable Future<?> asyncInitializeTask;\n+\n+    private @Nullable Thread senderThread;\n+    private @Nullable Thread readerThread;\n+\n+    private @Nullable ScheduledFuture<?> keepAliveJob;\n+    private @Nullable ScheduledFuture<?> keepAliveReconnectJob;\n+    private @Nullable ScheduledFuture<?> connectRetryJob;\n+    private final Object keepAliveReconnectLock = new Object();\n+\n+    private final Map<Integer, Integer> zoneToDevice = new HashMap<>();\n+    private final Map<Integer, Integer> deviceToZone = new HashMap<>();\n+    private final Object zoneMapsLock = new Object();\n+\n+    private @Nullable Map<Integer, List<Integer>> deviceButtonMap;\n+    private final Object deviceButtonMapLock = new Object();\n+\n+    private volatile boolean deviceDataLoaded = false;\n+    private volatile boolean buttonDataLoaded = false;\n+\n+    private final Map<Integer, LutronHandler> childHandlerMap = new ConcurrentHashMap<>();\n+    private final Map<Integer, OGroupHandler> groupHandlerMap = new ConcurrentHashMap<>();\n+\n+    private @Nullable LeapDeviceDiscoveryService discoveryService;\n+\n+    public void setDiscoveryService(LeapDeviceDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    public LeapBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+        leapMessageParser = new LeapMessageParser(this);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(LeapDeviceDiscoveryService.class);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        SSLContext sslContext;\n+\n+        childHandlerMap.clear();\n+        groupHandlerMap.clear();\n+\n+        config = getConfigAs(LeapBridgeConfig.class);\n+        String keystorePassword = (config.keystorePassword == null) ? \"\" : config.keystorePassword;\n+\n+        String ipAddress = config.ipAddress;\n+        if (ipAddress == null || ipAddress.isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"bridge address not specified\");\n+            return;\n+        }\n+\n+        reconnectInterval = (config.reconnect > 0) ? config.reconnect : DEFAULT_RECONNECT_MINUTES;\n+        heartbeatInterval = (config.heartbeat > 0) ? config.heartbeat : DEFAULT_HEARTBEAT_MINUTES;\n+        sendDelay = (config.delay < 0) ? 0 : config.delay;\n+\n+        if (config.keystore == null || keystorePassword == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Keystore/keystore password not configured\");\n+            return;\n+        } else {\n+            try (FileInputStream keystoreInputStream = new FileInputStream(config.keystore)) {\n+                logger.trace(\"Initializing keystore\");\n+                KeyStore keystore = KeyStore.getInstance(KeyStore.getDefaultType());\n+\n+                keystore.load(keystoreInputStream, keystorePassword.toCharArray());\n+\n+                logger.trace(\"Initializing SSL Context\");\n+                KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n+                kmf.init(keystore, keystorePassword.toCharArray());\n+\n+                TrustManager[] trustManagers;\n+                if (config.certValidate) {\n+                    // Use default trust manager which will attempt to validate server certificate from hub\n+                    TrustManagerFactory tmf = TrustManagerFactory\n+                            .getInstance(TrustManagerFactory.getDefaultAlgorithm());\n+                    tmf.init(keystore);\n+                    trustManagers = tmf.getTrustManagers();\n+                } else {\n+                    // Use no-op trust manager which will not verify certificates\n+                    trustManagers = defineNoOpTrustManager();\n+                }\n+\n+                sslContext = SSLContext.getInstance(\"TLS\");\n+                sslContext.init(kmf.getKeyManagers(), trustManagers, null);\n+\n+                sslsocketfactory = sslContext.getSocketFactory();\n+            } catch (FileNotFoundException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Keystore file not found\");\n+                return;\n+            } catch (CertificateException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Certificate exception\");\n+                return;\n+            } catch (UnrecoverableKeyException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"Key unrecoverable with supplied password\");\n+                return;\n+            } catch (KeyManagementException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Key management exception\");\n+                logger.debug(\"Key management exception\", e);\n+                return;\n+            } catch (KeyStoreException | NoSuchAlgorithmException | IOException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Error initializing keystore\");\n+                logger.debug(\"Error initializing keystore\", e);\n+                return;\n+            }\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Connecting\");\n+        asyncInitializeTask = scheduler.submit(this::connect); // start the async connect task\n+    }\n+\n+    /**\n+     * Return a no-op SSL trust manager which will not verify server or client certificates.\n+     */\n+    private TrustManager[] defineNoOpTrustManager() {\n+        return new TrustManager[] { new X509TrustManager() {\n+            @Override\n+            public void checkClientTrusted(final X509Certificate @Nullable [] chain, final @Nullable String authType) {\n+                logger.debug(\"Assuming client certificate is valid\");\n+                if (chain != null && logger.isTraceEnabled()) {\n+                    for (int cert = 0; cert < chain.length; cert++) {\n+                        logger.trace(\"Subject DN: {}\", chain[cert].getSubjectDN());\n+                        logger.trace(\"Issuer DN: {}\", chain[cert].getIssuerDN());\n+                        logger.trace(\"Serial number {}:\", chain[cert].getSerialNumber());\n+                    }\n+                }\n+            }\n+\n+            @Override\n+            public void checkServerTrusted(final X509Certificate @Nullable [] chain, final @Nullable String authType) {\n+                logger.debug(\"Assuming server certificate is valid\");\n+                if (chain != null && logger.isTraceEnabled()) {\n+                    for (int cert = 0; cert < chain.length; cert++) {\n+                        logger.trace(\"Subject DN: {}\", chain[cert].getSubjectDN());\n+                        logger.trace(\"Issuer DN: {}\", chain[cert].getIssuerDN());\n+                        logger.trace(\"Serial number: {}\", chain[cert].getSerialNumber());\n+                    }\n+                }\n+            }\n+\n+            @Override\n+            public X509Certificate @Nullable [] getAcceptedIssuers() {\n+                return null;\n+            }\n+        } };\n+    }\n+\n+    private synchronized void connect() {\n+        deviceDataLoaded = false;\n+        buttonDataLoaded = false;\n+\n+        try {\n+            logger.debug(\"Opening SSL connection to {}:{}\", config.ipAddress, config.port);\n+            SSLSocket sslsocket = (SSLSocket) sslsocketfactory.createSocket(config.ipAddress, config.port);\n+            sslsocket.startHandshake();\n+            writer = new BufferedWriter(new OutputStreamWriter(sslsocket.getOutputStream()));\n+            reader = new BufferedReader(new InputStreamReader(sslsocket.getInputStream()));\n+            this.sslsocket = sslsocket;\n+        } catch (UnknownHostException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Unknown host\");\n+            return;\n+        } catch (IllegalArgumentException e) {\n+            // port out of valid range\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Invalid port number\");\n+            return;\n+        } catch (InterruptedIOException e) {\n+            Thread.currentThread().interrupt();\n+            logger.debug(\"Interrupted while establishing connection\");\n+            return;\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Error opening SSL connection. Check log.\");\n+            logger.info(\"Error opening SSL connection: {}\", e.getMessage());\n+            disconnect(false);\n+            scheduleConnectRetry(reconnectInterval); // Possibly a temporary problem. Try again later.\n+            return;\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, STATUS_INITIALIZING);\n+\n+        Thread readerThread = new Thread(this::readerThreadJob, \"Lutron reader\");\n+        readerThread.setDaemon(true);\n+        readerThread.start();\n+        this.readerThread = readerThread;\n+\n+        Thread senderThread = new Thread(this::senderThreadJob, \"Lutron sender\");\n+        senderThread.setDaemon(true);\n+        senderThread.start();\n+        this.senderThread = senderThread;\n+\n+        sendCommand(new LeapCommand(Request.getButtonGroups()));\n+        queryDiscoveryData();\n+        sendCommand(new LeapCommand(Request.subscribeOccupancyGroupStatus()));\n+\n+        logger.debug(\"Starting keepalive job with interval {}\", heartbeatInterval);\n+        keepAliveJob = scheduler.scheduleWithFixedDelay(this::sendKeepAlive, heartbeatInterval, heartbeatInterval,\n+                TimeUnit.MINUTES);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4MDY0Nw=="}, "originalCommit": {"oid": "40d4fc56591c84fbeb9ce05ce90473724e53bf3a"}, "originalPosition": 314}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTkwOTY5NQ==", "bodyText": "huh, I don't know why I didn't notice that connect and disconnect are synchronized. Yes that would prevent any problems so you can disregard my prior suggestion.", "url": "https://github.com/openhab/openhab-addons/pull/8650#discussion_r505909695", "createdAt": "2020-10-15T22:56:27Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lutron/src/main/java/org/openhab/binding/lutron/internal/handler/LeapBridgeHandler.java", "diffHunk": "@@ -0,0 +1,802 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lutron.internal.handler;\n+\n+import static org.openhab.binding.lutron.internal.LutronBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.InterruptedIOException;\n+import java.io.OutputStreamWriter;\n+import java.net.UnknownHostException;\n+import java.security.KeyManagementException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.UnrecoverableKeyException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManager;\n+import javax.net.ssl.TrustManagerFactory;\n+import javax.net.ssl.X509TrustManager;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.lutron.internal.config.LeapBridgeConfig;\n+import org.openhab.binding.lutron.internal.discovery.LeapDeviceDiscoveryService;\n+import org.openhab.binding.lutron.internal.protocol.FanSpeedType;\n+import org.openhab.binding.lutron.internal.protocol.GroupCommand;\n+import org.openhab.binding.lutron.internal.protocol.LutronCommandNew;\n+import org.openhab.binding.lutron.internal.protocol.OutputCommand;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapCommand;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapMessageParser;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapMessageParserCallbacks;\n+import org.openhab.binding.lutron.internal.protocol.leap.Request;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Area;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ButtonGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Device;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.OccupancyGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ZoneStatus;\n+import org.openhab.binding.lutron.internal.protocol.lip.LutronCommandType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Bridge handler responsible for communicating with Lutron hubs that support the LEAP protocol, such as Caseta and\n+ * RA2 Select.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LeapBridgeHandler extends LutronBridgeHandler implements LeapMessageParserCallbacks {\n+    private static final int DEFAULT_RECONNECT_MINUTES = 5;\n+    private static final int DEFAULT_HEARTBEAT_MINUTES = 5;\n+    private static final long KEEPALIVE_TIMEOUT_SECONDS = 30;\n+\n+    private static final String STATUS_INITIALIZING = \"Initializing\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(LeapBridgeHandler.class);\n+\n+    private @NonNullByDefault({}) LeapBridgeConfig config;\n+    private int reconnectInterval;\n+    private int heartbeatInterval;\n+    private int sendDelay;\n+\n+    private @NonNullByDefault({}) SSLSocketFactory sslsocketfactory;\n+    private @Nullable SSLSocket sslsocket;\n+    private @Nullable BufferedWriter writer;\n+    private @Nullable BufferedReader reader;\n+\n+    private @NonNullByDefault({}) LeapMessageParser leapMessageParser;\n+\n+    private final BlockingQueue<LeapCommand> sendQueue = new LinkedBlockingQueue<>();\n+\n+    private @Nullable Future<?> asyncInitializeTask;\n+\n+    private @Nullable Thread senderThread;\n+    private @Nullable Thread readerThread;\n+\n+    private @Nullable ScheduledFuture<?> keepAliveJob;\n+    private @Nullable ScheduledFuture<?> keepAliveReconnectJob;\n+    private @Nullable ScheduledFuture<?> connectRetryJob;\n+    private final Object keepAliveReconnectLock = new Object();\n+\n+    private final Map<Integer, Integer> zoneToDevice = new HashMap<>();\n+    private final Map<Integer, Integer> deviceToZone = new HashMap<>();\n+    private final Object zoneMapsLock = new Object();\n+\n+    private @Nullable Map<Integer, List<Integer>> deviceButtonMap;\n+    private final Object deviceButtonMapLock = new Object();\n+\n+    private volatile boolean deviceDataLoaded = false;\n+    private volatile boolean buttonDataLoaded = false;\n+\n+    private final Map<Integer, LutronHandler> childHandlerMap = new ConcurrentHashMap<>();\n+    private final Map<Integer, OGroupHandler> groupHandlerMap = new ConcurrentHashMap<>();\n+\n+    private @Nullable LeapDeviceDiscoveryService discoveryService;\n+\n+    public void setDiscoveryService(LeapDeviceDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    public LeapBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+        leapMessageParser = new LeapMessageParser(this);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(LeapDeviceDiscoveryService.class);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        SSLContext sslContext;\n+\n+        childHandlerMap.clear();\n+        groupHandlerMap.clear();\n+\n+        config = getConfigAs(LeapBridgeConfig.class);\n+        String keystorePassword = (config.keystorePassword == null) ? \"\" : config.keystorePassword;\n+\n+        String ipAddress = config.ipAddress;\n+        if (ipAddress == null || ipAddress.isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"bridge address not specified\");\n+            return;\n+        }\n+\n+        reconnectInterval = (config.reconnect > 0) ? config.reconnect : DEFAULT_RECONNECT_MINUTES;\n+        heartbeatInterval = (config.heartbeat > 0) ? config.heartbeat : DEFAULT_HEARTBEAT_MINUTES;\n+        sendDelay = (config.delay < 0) ? 0 : config.delay;\n+\n+        if (config.keystore == null || keystorePassword == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Keystore/keystore password not configured\");\n+            return;\n+        } else {\n+            try (FileInputStream keystoreInputStream = new FileInputStream(config.keystore)) {\n+                logger.trace(\"Initializing keystore\");\n+                KeyStore keystore = KeyStore.getInstance(KeyStore.getDefaultType());\n+\n+                keystore.load(keystoreInputStream, keystorePassword.toCharArray());\n+\n+                logger.trace(\"Initializing SSL Context\");\n+                KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n+                kmf.init(keystore, keystorePassword.toCharArray());\n+\n+                TrustManager[] trustManagers;\n+                if (config.certValidate) {\n+                    // Use default trust manager which will attempt to validate server certificate from hub\n+                    TrustManagerFactory tmf = TrustManagerFactory\n+                            .getInstance(TrustManagerFactory.getDefaultAlgorithm());\n+                    tmf.init(keystore);\n+                    trustManagers = tmf.getTrustManagers();\n+                } else {\n+                    // Use no-op trust manager which will not verify certificates\n+                    trustManagers = defineNoOpTrustManager();\n+                }\n+\n+                sslContext = SSLContext.getInstance(\"TLS\");\n+                sslContext.init(kmf.getKeyManagers(), trustManagers, null);\n+\n+                sslsocketfactory = sslContext.getSocketFactory();\n+            } catch (FileNotFoundException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Keystore file not found\");\n+                return;\n+            } catch (CertificateException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Certificate exception\");\n+                return;\n+            } catch (UnrecoverableKeyException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"Key unrecoverable with supplied password\");\n+                return;\n+            } catch (KeyManagementException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Key management exception\");\n+                logger.debug(\"Key management exception\", e);\n+                return;\n+            } catch (KeyStoreException | NoSuchAlgorithmException | IOException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Error initializing keystore\");\n+                logger.debug(\"Error initializing keystore\", e);\n+                return;\n+            }\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Connecting\");\n+        asyncInitializeTask = scheduler.submit(this::connect); // start the async connect task\n+    }\n+\n+    /**\n+     * Return a no-op SSL trust manager which will not verify server or client certificates.\n+     */\n+    private TrustManager[] defineNoOpTrustManager() {\n+        return new TrustManager[] { new X509TrustManager() {\n+            @Override\n+            public void checkClientTrusted(final X509Certificate @Nullable [] chain, final @Nullable String authType) {\n+                logger.debug(\"Assuming client certificate is valid\");\n+                if (chain != null && logger.isTraceEnabled()) {\n+                    for (int cert = 0; cert < chain.length; cert++) {\n+                        logger.trace(\"Subject DN: {}\", chain[cert].getSubjectDN());\n+                        logger.trace(\"Issuer DN: {}\", chain[cert].getIssuerDN());\n+                        logger.trace(\"Serial number {}:\", chain[cert].getSerialNumber());\n+                    }\n+                }\n+            }\n+\n+            @Override\n+            public void checkServerTrusted(final X509Certificate @Nullable [] chain, final @Nullable String authType) {\n+                logger.debug(\"Assuming server certificate is valid\");\n+                if (chain != null && logger.isTraceEnabled()) {\n+                    for (int cert = 0; cert < chain.length; cert++) {\n+                        logger.trace(\"Subject DN: {}\", chain[cert].getSubjectDN());\n+                        logger.trace(\"Issuer DN: {}\", chain[cert].getIssuerDN());\n+                        logger.trace(\"Serial number: {}\", chain[cert].getSerialNumber());\n+                    }\n+                }\n+            }\n+\n+            @Override\n+            public X509Certificate @Nullable [] getAcceptedIssuers() {\n+                return null;\n+            }\n+        } };\n+    }\n+\n+    private synchronized void connect() {\n+        deviceDataLoaded = false;\n+        buttonDataLoaded = false;\n+\n+        try {\n+            logger.debug(\"Opening SSL connection to {}:{}\", config.ipAddress, config.port);\n+            SSLSocket sslsocket = (SSLSocket) sslsocketfactory.createSocket(config.ipAddress, config.port);\n+            sslsocket.startHandshake();\n+            writer = new BufferedWriter(new OutputStreamWriter(sslsocket.getOutputStream()));\n+            reader = new BufferedReader(new InputStreamReader(sslsocket.getInputStream()));\n+            this.sslsocket = sslsocket;\n+        } catch (UnknownHostException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Unknown host\");\n+            return;\n+        } catch (IllegalArgumentException e) {\n+            // port out of valid range\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Invalid port number\");\n+            return;\n+        } catch (InterruptedIOException e) {\n+            Thread.currentThread().interrupt();\n+            logger.debug(\"Interrupted while establishing connection\");\n+            return;\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Error opening SSL connection. Check log.\");\n+            logger.info(\"Error opening SSL connection: {}\", e.getMessage());\n+            disconnect(false);\n+            scheduleConnectRetry(reconnectInterval); // Possibly a temporary problem. Try again later.\n+            return;\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, STATUS_INITIALIZING);\n+\n+        Thread readerThread = new Thread(this::readerThreadJob, \"Lutron reader\");\n+        readerThread.setDaemon(true);\n+        readerThread.start();\n+        this.readerThread = readerThread;\n+\n+        Thread senderThread = new Thread(this::senderThreadJob, \"Lutron sender\");\n+        senderThread.setDaemon(true);\n+        senderThread.start();\n+        this.senderThread = senderThread;\n+\n+        sendCommand(new LeapCommand(Request.getButtonGroups()));\n+        queryDiscoveryData();\n+        sendCommand(new LeapCommand(Request.subscribeOccupancyGroupStatus()));\n+\n+        logger.debug(\"Starting keepalive job with interval {}\", heartbeatInterval);\n+        keepAliveJob = scheduler.scheduleWithFixedDelay(this::sendKeepAlive, heartbeatInterval, heartbeatInterval,\n+                TimeUnit.MINUTES);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4MDY0Nw=="}, "originalCommit": {"oid": "40d4fc56591c84fbeb9ce05ce90473724e53bf3a"}, "originalPosition": 314}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4202, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}