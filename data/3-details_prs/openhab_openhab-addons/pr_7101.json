{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg0MTcwMDY3", "number": 7101, "title": "[linky] Linky binding", "bodyText": "Replaces PR #6926\nSigned-off-by: Ga\u00ebl L'hopital gael@lhopital.org", "createdAt": "2020-03-05T09:47:49Z", "url": "https://github.com/openhab/openhab-addons/pull/7101", "merged": true, "mergeCommit": {"oid": "bf318b5d21841f90b506f81eef9bd3a413b20fb0"}, "closed": true, "closedAt": "2020-04-16T20:02:09Z", "author": {"login": "clinique"}, "timelineItems": {"totalCount": 23, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcKoWqigH2gAyMzg0MTcwMDY3OjZmYWZiOWVmMWE3N2JhMGUwMWM1NzcwMjNmMWM5ZjhmOTEyZWE1OWE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcYSVJLgFqTM5NDk1Nzg2Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "6fafb9ef1a77ba0e01c577023f1c9f8f912ea59a", "author": {"user": {"login": "clinique", "name": "Ga\u00ebl L'hopital"}}, "url": "https://github.com/openhab/openhab-addons/commit/6fafb9ef1a77ba0e01c577023f1c9f8f912ea59a", "committedDate": "2020-03-05T09:46:17Z", "message": "Clean new PR for Linky binding\n\nSigned-off-by: Ga\u00ebl L'hopital <gael@lhopital.org>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "730a3c0cc8bf606279e8660930db27874e2b79c4", "author": {"user": {"login": "clinique", "name": "Ga\u00ebl L'hopital"}}, "url": "https://github.com/openhab/openhab-addons/commit/730a3c0cc8bf606279e8660930db27874e2b79c4", "committedDate": "2020-03-05T09:49:13Z", "message": "Missing bom file\n\nSigned-off-by: Ga\u00ebl L'hopital <gael@lhopital.org>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5NTA3MjE1", "url": "https://github.com/openhab/openhab-addons/pull/7101#pullrequestreview-369507215", "createdAt": "2020-03-05T11:53:27Z", "commit": {"oid": "730a3c0cc8bf606279e8660930db27874e2b79c4"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMTo1MzoyN1rOFyQsLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNVQxMTo1ODo1OFrOFyQ17w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI0NjU3NA==", "bodyText": "Could you please add @NonNullByDefault to this class (sorry, I forgot to do it).", "url": "https://github.com/openhab/openhab-addons/pull/7101#discussion_r388246574", "createdAt": "2020-03-05T11:53:27Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.linky/src/main/java/org/openhab/binding/linky/internal/console/LinkyCommandExtension.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.linky.internal.console;\n+\n+import java.time.LocalDate;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingRegistry;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.io.console.Console;\n+import org.eclipse.smarthome.io.console.extensions.AbstractConsoleCommandExtension;\n+import org.eclipse.smarthome.io.console.extensions.ConsoleCommandExtension;\n+import org.openhab.binding.linky.internal.handler.LinkyHandler;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link LinkyCommandExtension} is responsible for handling console commands\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ */\n+@Component(service = ConsoleCommandExtension.class)\n+public class LinkyCommandExtension extends AbstractConsoleCommandExtension {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "730a3c0cc8bf606279e8660930db27874e2b79c4"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI0NjkxOA==", "bodyText": "This could be replaced by a Reference parameter in the constructor.", "url": "https://github.com/openhab/openhab-addons/pull/7101#discussion_r388246918", "createdAt": "2020-03-05T11:54:14Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.linky/src/main/java/org/openhab/binding/linky/internal/console/LinkyCommandExtension.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.linky.internal.console;\n+\n+import java.time.LocalDate;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingRegistry;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.io.console.Console;\n+import org.eclipse.smarthome.io.console.extensions.AbstractConsoleCommandExtension;\n+import org.eclipse.smarthome.io.console.extensions.ConsoleCommandExtension;\n+import org.openhab.binding.linky.internal.handler.LinkyHandler;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link LinkyCommandExtension} is responsible for handling console commands\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ */\n+@Component(service = ConsoleCommandExtension.class)\n+public class LinkyCommandExtension extends AbstractConsoleCommandExtension {\n+\n+    private static final String REPORT = \"report\";\n+\n+    private ThingRegistry thingRegistry;\n+\n+    public LinkyCommandExtension() {\n+        super(\"linky\", \"Interact with the Linky binding.\");\n+    }\n+\n+    @Override\n+    public void execute(String[] args, Console console) {\n+        if (args.length >= 2) {\n+            LinkyHandler handler = null;\n+            try {\n+                ThingUID thingUID = new ThingUID(args[0]);\n+                Thing thing = thingRegistry.get(thingUID);\n+                if ((thing != null) && (thing.getHandler() != null) && (thing.getHandler() instanceof LinkyHandler)) {\n+                    handler = (LinkyHandler) thing.getHandler();\n+                }\n+            } catch (Exception e) {\n+                handler = null;\n+            }\n+            if (handler == null) {\n+                console.println(\"Bad thing id '\" + args[0] + \"'\");\n+                printUsage(console);\n+            } else {\n+                switch (args[1]) {\n+                    case REPORT:\n+                        LocalDate now = LocalDate.now();\n+                        LocalDate start = now.minusDays(7);\n+                        LocalDate end = now.minusDays(1);\n+                        String separator = \" \";\n+                        if (args.length >= 3) {\n+                            try {\n+                                start = LocalDate.parse(args[2], DateTimeFormatter.ISO_LOCAL_DATE);\n+                            } catch (DateTimeParseException e) {\n+                                console.println(\"Invalid format for start day '\" + args[2]\n+                                        + \"'; expected format is YYYY-MM-DD\");\n+                                printUsage(console);\n+                                break;\n+                            }\n+                        }\n+                        if (args.length >= 4) {\n+                            try {\n+                                end = LocalDate.parse(args[3], DateTimeFormatter.ISO_LOCAL_DATE);\n+                            } catch (DateTimeParseException e) {\n+                                console.println(\n+                                        \"Invalid format for end day '\" + args[3] + \"'; expected format is YYYY-MM-DD\");\n+                                printUsage(console);\n+                                break;\n+                            }\n+                        }\n+                        if (!start.isBefore(now)) {\n+                            console.println(\"Start day must be in the past\");\n+                            printUsage(console);\n+                            break;\n+                        }\n+                        if (start.isAfter(end)) {\n+                            console.println(\"Start day must be earlier than end day\");\n+                            printUsage(console);\n+                            break;\n+                        }\n+                        if (end.isAfter(now.minusDays(1))) {\n+                            end = now.minusDays(1);\n+                        }\n+                        if (args.length >= 5) {\n+                            separator = args[4];\n+                        }\n+                        for (String line : handler.reportValues(start, end, separator).split(\"\\n\")) {\n+                            console.println(line);\n+                        }\n+                        break;\n+                    default:\n+                        console.println(\"Unknown Linky sub command '\" + args[1] + \"'\");\n+                        printUsage(console);\n+                        break;\n+                }\n+            }\n+        } else {\n+            printUsage(console);\n+        }\n+    }\n+\n+    @Override\n+    public List<String> getUsages() {\n+        return Arrays.asList(\n+                new String[] { buildCommandUsage(\"<thingUID> \" + REPORT + \" <start day> <end day> [<separator>]\",\n+                        \"report daily consumptions between two dates\") });\n+    }\n+\n+    @Reference", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "730a3c0cc8bf606279e8660930db27874e2b79c4"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODI0OTA3MQ==", "bodyText": "In other bindings, you find ComponentContext as parameter of activate and deactivate methods but not as parameter of the constructor.\nIs this parameter really necessary here ?", "url": "https://github.com/openhab/openhab-addons/pull/7101#discussion_r388249071", "createdAt": "2020-03-05T11:58:58Z", "author": {"login": "lolodomo"}, "path": "bundles/org.openhab.binding.linky/src/main/java/org/openhab/binding/linky/internal/LinkyHandlerFactory.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.linky.internal;\n+\n+import static org.openhab.binding.linky.internal.LinkyBindingConstants.THING_TYPE_LINKY;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.i18n.LocaleProvider;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.openhab.binding.linky.internal.handler.LinkyHandler;\n+import org.osgi.service.component.ComponentContext;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link LinkyHandlerFactory} is responsible for creating things handlers.\n+ *\n+ * @author Ga\u00ebl L'hopital - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(service = ThingHandlerFactory.class, configurationPid = \"binding.linky\")\n+public class LinkyHandlerFactory extends BaseThingHandlerFactory {\n+\n+    private final LocaleProvider localeProvider;\n+\n+    @Activate\n+    public LinkyHandlerFactory(final @Reference LocaleProvider localeProvider, ComponentContext componentContext) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "730a3c0cc8bf606279e8660930db27874e2b79c4"}, "originalPosition": 43}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ca24f3c60dbe4244f0ac1c2a64db4810d0d75582", "author": {"user": {"login": "clinique", "name": "Ga\u00ebl L'hopital"}}, "url": "https://github.com/openhab/openhab-addons/commit/ca24f3c60dbe4244f0ac1c2a64db4810d0d75582", "committedDate": "2020-03-05T13:35:55Z", "message": "Code review corrections\n\nSigned-off-by: Ga\u00ebl L'hopital <gael@lhopital.org>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4380fdb26e67dc341c0567a290f79267d46dfe34", "author": {"user": {"login": "clinique", "name": "Ga\u00ebl L'hopital"}}, "url": "https://github.com/openhab/openhab-addons/commit/4380fdb26e67dc341c0567a290f79267d46dfe34", "committedDate": "2020-03-06T08:18:45Z", "message": "Debugging\n\nSigned-off-by: Ga\u00ebl L'hopital <gael@lhopital.org>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwMTc1ODY2", "url": "https://github.com/openhab/openhab-addons/pull/7101#pullrequestreview-370175866", "createdAt": "2020-03-06T09:13:44Z", "commit": {"oid": "4380fdb26e67dc341c0567a290f79267d46dfe34"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcxNTg4NDkx", "url": "https://github.com/openhab/openhab-addons/pull/7101#pullrequestreview-371588491", "createdAt": "2020-03-09T23:15:20Z", "commit": {"oid": "4380fdb26e67dc341c0567a290f79267d46dfe34"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQyMzoxNToyMFrOFz8cRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QyMzozMzozNlrOF2WADA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxMTk3NQ==", "bodyText": "Please make these final", "url": "https://github.com/openhab/openhab-addons/pull/7101#discussion_r390011975", "createdAt": "2020-03-09T23:15:20Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.linky/src/main/java/org/openhab/binding/linky/internal/handler/LinkyHandler.java", "diffHunk": "@@ -0,0 +1,387 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.linky.internal.handler;\n+\n+import static org.openhab.binding.linky.internal.LinkyBindingConstants.*;\n+import static org.openhab.binding.linky.internal.model.LinkyTimeScale.*;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.temporal.ChronoUnit;\n+import java.time.temporal.WeekFields;\n+import java.util.Base64;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.i18n.LocaleProvider;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.linky.internal.ExpiringDayCache;\n+import org.openhab.binding.linky.internal.LinkyConfiguration;\n+import org.openhab.binding.linky.internal.model.LinkyConsumptionData;\n+import org.openhab.binding.linky.internal.model.LinkyTimeScale;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+import okhttp3.FormBody;\n+import okhttp3.FormBody.Builder;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.Response;\n+\n+/**\n+ * The {@link LinkyHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ga\u00ebl L'hopital - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class LinkyHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(LinkyHandler.class);\n+\n+    private static final String LOGIN_BASE_URI = \"https://espace-client-connexion.enedis.fr/auth/UI/Login\";\n+    private static final String API_BASE_URI = \"https://espace-client-particuliers.enedis.fr/group/espace-particuliers/suivi-de-consommation\";\n+    private static final DateTimeFormatter API_DATE_FORMAT = DateTimeFormatter.ofPattern(\"dd/MM/yyyy\");\n+    private static final Builder LOGIN_BODY_BUILDER = new FormBody.Builder().add(\"encoded\", \"true\")\n+            .add(\"gx_charset\", \"UTF-8\").add(\"SunQueryParamsString\",\n+                    Base64.getEncoder().encodeToString(\"realm=particuliers\".getBytes(StandardCharsets.UTF_8)));\n+\n+    private static final int REFRESH_FIRST_HOUR_OF_DAY = 5;\n+    private static final int REFRESH_INTERVAL_IN_MIN = 360;\n+\n+    private final OkHttpClient client = new OkHttpClient.Builder().followRedirects(false)\n+            .cookieJar(new LinkyCookieJar()).build();\n+    private final Gson gson = new Gson();\n+\n+    private @NonNullByDefault({}) ScheduledFuture<?> refreshJob;\n+    private final WeekFields weekFields;\n+\n+    private ExpiringDayCache<LinkyConsumptionData> cachedDaylyData;\n+    private ExpiringDayCache<LinkyConsumptionData> cachedMonthlyData;\n+    private ExpiringDayCache<LinkyConsumptionData> cachedYearlyData;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4380fdb26e67dc341c0567a290f79267d46dfe34"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxMjUyNA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    scheduler.schedule(this::login, 0, TimeUnit.SECONDS);\n          \n          \n            \n                    scheduler.execute(this::login);", "url": "https://github.com/openhab/openhab-addons/pull/7101#discussion_r390012524", "createdAt": "2020-03-09T23:16:58Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.linky/src/main/java/org/openhab/binding/linky/internal/handler/LinkyHandler.java", "diffHunk": "@@ -0,0 +1,387 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.linky.internal.handler;\n+\n+import static org.openhab.binding.linky.internal.LinkyBindingConstants.*;\n+import static org.openhab.binding.linky.internal.model.LinkyTimeScale.*;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.temporal.ChronoUnit;\n+import java.time.temporal.WeekFields;\n+import java.util.Base64;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.i18n.LocaleProvider;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.linky.internal.ExpiringDayCache;\n+import org.openhab.binding.linky.internal.LinkyConfiguration;\n+import org.openhab.binding.linky.internal.model.LinkyConsumptionData;\n+import org.openhab.binding.linky.internal.model.LinkyTimeScale;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+import okhttp3.FormBody;\n+import okhttp3.FormBody.Builder;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.Response;\n+\n+/**\n+ * The {@link LinkyHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ga\u00ebl L'hopital - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class LinkyHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(LinkyHandler.class);\n+\n+    private static final String LOGIN_BASE_URI = \"https://espace-client-connexion.enedis.fr/auth/UI/Login\";\n+    private static final String API_BASE_URI = \"https://espace-client-particuliers.enedis.fr/group/espace-particuliers/suivi-de-consommation\";\n+    private static final DateTimeFormatter API_DATE_FORMAT = DateTimeFormatter.ofPattern(\"dd/MM/yyyy\");\n+    private static final Builder LOGIN_BODY_BUILDER = new FormBody.Builder().add(\"encoded\", \"true\")\n+            .add(\"gx_charset\", \"UTF-8\").add(\"SunQueryParamsString\",\n+                    Base64.getEncoder().encodeToString(\"realm=particuliers\".getBytes(StandardCharsets.UTF_8)));\n+\n+    private static final int REFRESH_FIRST_HOUR_OF_DAY = 5;\n+    private static final int REFRESH_INTERVAL_IN_MIN = 360;\n+\n+    private final OkHttpClient client = new OkHttpClient.Builder().followRedirects(false)\n+            .cookieJar(new LinkyCookieJar()).build();\n+    private final Gson gson = new Gson();\n+\n+    private @NonNullByDefault({}) ScheduledFuture<?> refreshJob;\n+    private final WeekFields weekFields;\n+\n+    private ExpiringDayCache<LinkyConsumptionData> cachedDaylyData;\n+    private ExpiringDayCache<LinkyConsumptionData> cachedMonthlyData;\n+    private ExpiringDayCache<LinkyConsumptionData> cachedYearlyData;\n+\n+    public LinkyHandler(Thing thing, LocaleProvider localeProvider) {\n+        super(thing);\n+        this.weekFields = WeekFields.of(localeProvider.getLocale());\n+        this.cachedDaylyData = new ExpiringDayCache<LinkyConsumptionData>(\"daily cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(DAILY, today.minusDays(13), today, true);\n+                });\n+        this.cachedMonthlyData = new ExpiringDayCache<LinkyConsumptionData>(\"monthly cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(MONTHLY, today.withDayOfMonth(1).minusMonths(1), today, true);\n+                });\n+        this.cachedYearlyData = new ExpiringDayCache<LinkyConsumptionData>(\"yearly cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(YEARLY, LocalDate.of(today.getYear() - 1, 1, 1), today, true);\n+                });\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing Linky handler.\");\n+\n+        scheduler.schedule(this::login, 0, TimeUnit.SECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4380fdb26e67dc341c0567a290f79267d46dfe34"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyNzA3OQ==", "bodyText": "What exception are you expecting here?", "url": "https://github.com/openhab/openhab-addons/pull/7101#discussion_r392527079", "createdAt": "2020-03-13T23:29:20Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.linky/src/main/java/org/openhab/binding/linky/internal/console/LinkyCommandExtension.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.linky.internal.console;\n+\n+import java.time.LocalDate;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingRegistry;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.io.console.Console;\n+import org.eclipse.smarthome.io.console.extensions.AbstractConsoleCommandExtension;\n+import org.eclipse.smarthome.io.console.extensions.ConsoleCommandExtension;\n+import org.openhab.binding.linky.internal.handler.LinkyHandler;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link LinkyCommandExtension} is responsible for handling console commands\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+@Component(service = ConsoleCommandExtension.class)\n+public class LinkyCommandExtension extends AbstractConsoleCommandExtension {\n+\n+    private static final String REPORT = \"report\";\n+\n+    private final ThingRegistry thingRegistry;\n+\n+    @Activate\n+    public LinkyCommandExtension(final @Reference ThingRegistry thingRegistry) {\n+        super(\"linky\", \"Interact with the Linky binding.\");\n+        this.thingRegistry = thingRegistry;\n+    }\n+\n+    @Override\n+    public void execute(String[] args, Console console) {\n+        if (args.length >= 2) {\n+            LinkyHandler handler = null;\n+            try {\n+                ThingUID thingUID = new ThingUID(args[0]);\n+                Thing thing = thingRegistry.get(thingUID);\n+                if ((thing != null) && (thing.getHandler() != null) && (thing.getHandler() instanceof LinkyHandler)) {\n+                    handler = (LinkyHandler) thing.getHandler();\n+                }\n+            } catch (Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4380fdb26e67dc341c0567a290f79267d46dfe34"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjUyNzg4NA==", "bodyText": "please call updateStatus(ThingStatus.UNKNOWN); just in case something goes horribly wrong with the login that the Thing will be in a valid state.", "url": "https://github.com/openhab/openhab-addons/pull/7101#discussion_r392527884", "createdAt": "2020-03-13T23:33:36Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.linky/src/main/java/org/openhab/binding/linky/internal/handler/LinkyHandler.java", "diffHunk": "@@ -0,0 +1,387 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.linky.internal.handler;\n+\n+import static org.openhab.binding.linky.internal.LinkyBindingConstants.*;\n+import static org.openhab.binding.linky.internal.model.LinkyTimeScale.*;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.temporal.ChronoUnit;\n+import java.time.temporal.WeekFields;\n+import java.util.Base64;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.i18n.LocaleProvider;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.linky.internal.ExpiringDayCache;\n+import org.openhab.binding.linky.internal.LinkyConfiguration;\n+import org.openhab.binding.linky.internal.model.LinkyConsumptionData;\n+import org.openhab.binding.linky.internal.model.LinkyTimeScale;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+import okhttp3.FormBody;\n+import okhttp3.FormBody.Builder;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.Response;\n+\n+/**\n+ * The {@link LinkyHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ga\u00ebl L'hopital - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class LinkyHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(LinkyHandler.class);\n+\n+    private static final String LOGIN_BASE_URI = \"https://espace-client-connexion.enedis.fr/auth/UI/Login\";\n+    private static final String API_BASE_URI = \"https://espace-client-particuliers.enedis.fr/group/espace-particuliers/suivi-de-consommation\";\n+    private static final DateTimeFormatter API_DATE_FORMAT = DateTimeFormatter.ofPattern(\"dd/MM/yyyy\");\n+    private static final Builder LOGIN_BODY_BUILDER = new FormBody.Builder().add(\"encoded\", \"true\")\n+            .add(\"gx_charset\", \"UTF-8\").add(\"SunQueryParamsString\",\n+                    Base64.getEncoder().encodeToString(\"realm=particuliers\".getBytes(StandardCharsets.UTF_8)));\n+\n+    private static final int REFRESH_FIRST_HOUR_OF_DAY = 5;\n+    private static final int REFRESH_INTERVAL_IN_MIN = 360;\n+\n+    private final OkHttpClient client = new OkHttpClient.Builder().followRedirects(false)\n+            .cookieJar(new LinkyCookieJar()).build();\n+    private final Gson gson = new Gson();\n+\n+    private @NonNullByDefault({}) ScheduledFuture<?> refreshJob;\n+    private final WeekFields weekFields;\n+\n+    private ExpiringDayCache<LinkyConsumptionData> cachedDaylyData;\n+    private ExpiringDayCache<LinkyConsumptionData> cachedMonthlyData;\n+    private ExpiringDayCache<LinkyConsumptionData> cachedYearlyData;\n+\n+    public LinkyHandler(Thing thing, LocaleProvider localeProvider) {\n+        super(thing);\n+        this.weekFields = WeekFields.of(localeProvider.getLocale());\n+        this.cachedDaylyData = new ExpiringDayCache<LinkyConsumptionData>(\"daily cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(DAILY, today.minusDays(13), today, true);\n+                });\n+        this.cachedMonthlyData = new ExpiringDayCache<LinkyConsumptionData>(\"monthly cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(MONTHLY, today.withDayOfMonth(1).minusMonths(1), today, true);\n+                });\n+        this.cachedYearlyData = new ExpiringDayCache<LinkyConsumptionData>(\"yearly cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(YEARLY, LocalDate.of(today.getYear() - 1, 1, 1), today, true);\n+                });\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing Linky handler.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4380fdb26e67dc341c0567a290f79267d46dfe34"}, "originalPosition": 112}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "43039363b2e2795c326571cf80a034f1c0a90a5a", "author": {"user": {"login": "clinique", "name": "Ga\u00ebl L'hopital"}}, "url": "https://github.com/openhab/openhab-addons/commit/43039363b2e2795c326571cf80a034f1c0a90a5a", "committedDate": "2020-03-14T10:42:28Z", "message": "Corrections after code review\n\nSigned-off-by: clinique <gael@lhopital.org>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc0ODI1NjYy", "url": "https://github.com/openhab/openhab-addons/pull/7101#pullrequestreview-374825662", "createdAt": "2020-03-15T19:15:22Z", "commit": {"oid": "43039363b2e2795c326571cf80a034f1c0a90a5a"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNVQxOToxNToyMlrOF2gtrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQwNToyNDo1NlrOF5H_Hg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjcwMzQwNw==", "bodyText": "Are more commands expected here in the future? If not, this switch statement should be changed to an if statement.", "url": "https://github.com/openhab/openhab-addons/pull/7101#discussion_r392703407", "createdAt": "2020-03-15T19:15:22Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.linky/src/main/java/org/openhab/binding/linky/internal/console/LinkyCommandExtension.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.linky.internal.console;\n+\n+import java.time.LocalDate;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingRegistry;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.io.console.Console;\n+import org.eclipse.smarthome.io.console.extensions.AbstractConsoleCommandExtension;\n+import org.eclipse.smarthome.io.console.extensions.ConsoleCommandExtension;\n+import org.openhab.binding.linky.internal.handler.LinkyHandler;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link LinkyCommandExtension} is responsible for handling console commands\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+@Component(service = ConsoleCommandExtension.class)\n+public class LinkyCommandExtension extends AbstractConsoleCommandExtension {\n+\n+    private static final String REPORT = \"report\";\n+\n+    private final ThingRegistry thingRegistry;\n+\n+    @Activate\n+    public LinkyCommandExtension(final @Reference ThingRegistry thingRegistry) {\n+        super(\"linky\", \"Interact with the Linky binding.\");\n+        this.thingRegistry = thingRegistry;\n+    }\n+\n+    @Override\n+    public void execute(String[] args, Console console) {\n+        if (args.length >= 2) {\n+            LinkyHandler handler = null;\n+            try {\n+                ThingUID thingUID = new ThingUID(args[0]);\n+                Thing thing = thingRegistry.get(thingUID);\n+                if ((thing != null) && (thing.getHandler() != null) && (thing.getHandler() instanceof LinkyHandler)) {\n+                    handler = (LinkyHandler) thing.getHandler();\n+                }\n+            } catch (IllegalArgumentException e) {\n+                handler = null;\n+            }\n+            if (handler == null) {\n+                console.println(\"Bad thing id '\" + args[0] + \"'\");\n+                printUsage(console);\n+            } else {\n+                switch (args[1]) {\n+                    case REPORT:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43039363b2e2795c326571cf80a034f1c0a90a5a"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ0MjgzOA==", "bodyText": "Any reason you can't use the jetty httpclient?", "url": "https://github.com/openhab/openhab-addons/pull/7101#discussion_r395442838", "createdAt": "2020-03-20T05:18:26Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.linky/pom.xml", "diffHunk": "@@ -0,0 +1,34 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+\n+  <modelVersion>4.0.0</modelVersion>\n+\n+  <parent>\n+    <groupId>org.openhab.addons.bundles</groupId>\n+    <artifactId>org.openhab.addons.reactor.bundles</artifactId>\n+    <version>2.5.3-SNAPSHOT</version>\n+  </parent>\n+\n+  <artifactId>org.openhab.binding.linky</artifactId>\n+\n+  <name>openHAB Add-ons :: Bundles :: Linky Binding</name>\n+  \n+   <properties>\n+    <bnd.importpackage>!android.*,!com.android.org.*,!dalvik.*,!javax.annotation.meta.*,!org.apache.harmony.*,!org.conscrypt.*,!sun.*</bnd.importpackage>\n+  </properties>\n+\n+  <dependencies>\n+    <dependency>\n+      <groupId>com.squareup.okhttp3</groupId>\n+      <artifactId>okhttp</artifactId>\n+      <version>3.12.3</version>\n+      <scope>compile</scope>\n+    </dependency>\n+    <dependency>\n+      <groupId>com.squareup.okio</groupId>\n+      <artifactId>okio</artifactId>\n+      <version>1.15.0</version>\n+      <scope>compile</scope>\n+    </dependency>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43039363b2e2795c326571cf80a034f1c0a90a5a"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ0MzE1OA==", "bodyText": "How about this then?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    scheduler.schedule(this::login, 0, TimeUnit.SECONDS);\n          \n          \n            \n                    scheduler.submit(this::login);", "url": "https://github.com/openhab/openhab-addons/pull/7101#discussion_r395443158", "createdAt": "2020-03-20T05:20:26Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.linky/src/main/java/org/openhab/binding/linky/internal/handler/LinkyHandler.java", "diffHunk": "@@ -0,0 +1,387 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.linky.internal.handler;\n+\n+import static org.openhab.binding.linky.internal.LinkyBindingConstants.*;\n+import static org.openhab.binding.linky.internal.model.LinkyTimeScale.*;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.temporal.ChronoUnit;\n+import java.time.temporal.WeekFields;\n+import java.util.Base64;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.i18n.LocaleProvider;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.linky.internal.ExpiringDayCache;\n+import org.openhab.binding.linky.internal.LinkyConfiguration;\n+import org.openhab.binding.linky.internal.model.LinkyConsumptionData;\n+import org.openhab.binding.linky.internal.model.LinkyTimeScale;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+import okhttp3.FormBody;\n+import okhttp3.FormBody.Builder;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.Response;\n+\n+/**\n+ * The {@link LinkyHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ga\u00ebl L'hopital - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class LinkyHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(LinkyHandler.class);\n+\n+    private static final String LOGIN_BASE_URI = \"https://espace-client-connexion.enedis.fr/auth/UI/Login\";\n+    private static final String API_BASE_URI = \"https://espace-client-particuliers.enedis.fr/group/espace-particuliers/suivi-de-consommation\";\n+    private static final DateTimeFormatter API_DATE_FORMAT = DateTimeFormatter.ofPattern(\"dd/MM/yyyy\");\n+    private static final Builder LOGIN_BODY_BUILDER = new FormBody.Builder().add(\"encoded\", \"true\")\n+            .add(\"gx_charset\", \"UTF-8\").add(\"SunQueryParamsString\",\n+                    Base64.getEncoder().encodeToString(\"realm=particuliers\".getBytes(StandardCharsets.UTF_8)));\n+\n+    private static final int REFRESH_FIRST_HOUR_OF_DAY = 5;\n+    private static final int REFRESH_INTERVAL_IN_MIN = 360;\n+\n+    private final OkHttpClient client = new OkHttpClient.Builder().followRedirects(false)\n+            .cookieJar(new LinkyCookieJar()).build();\n+    private final Gson gson = new Gson();\n+\n+    private @NonNullByDefault({}) ScheduledFuture<?> refreshJob;\n+    private final WeekFields weekFields;\n+\n+    private ExpiringDayCache<LinkyConsumptionData> cachedDaylyData;\n+    private ExpiringDayCache<LinkyConsumptionData> cachedMonthlyData;\n+    private ExpiringDayCache<LinkyConsumptionData> cachedYearlyData;\n+\n+    public LinkyHandler(Thing thing, LocaleProvider localeProvider) {\n+        super(thing);\n+        this.weekFields = WeekFields.of(localeProvider.getLocale());\n+        this.cachedDaylyData = new ExpiringDayCache<LinkyConsumptionData>(\"daily cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(DAILY, today.minusDays(13), today, true);\n+                });\n+        this.cachedMonthlyData = new ExpiringDayCache<LinkyConsumptionData>(\"monthly cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(MONTHLY, today.withDayOfMonth(1).minusMonths(1), today, true);\n+                });\n+        this.cachedYearlyData = new ExpiringDayCache<LinkyConsumptionData>(\"yearly cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(YEARLY, LocalDate.of(today.getYear() - 1, 1, 1), today, true);\n+                });\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing Linky handler.\");\n+\n+        scheduler.schedule(this::login, 0, TimeUnit.SECONDS);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxMjUyNA=="}, "originalCommit": {"oid": "4380fdb26e67dc341c0567a290f79267d46dfe34"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ0MzQ5MQ==", "bodyText": "I think this is more understandable at a glance.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        lastMonth = result.getData().get(jump++).valeur;\n          \n          \n            \n                        thisMonth = result.getData().get(jump).valeur;\n          \n          \n            \n                        lastMonth = result.getData().get(jump).valeur;\n          \n          \n            \n                        thisMonth = result.getData().get(jump+1).valeur;", "url": "https://github.com/openhab/openhab-addons/pull/7101#discussion_r395443491", "createdAt": "2020-03-20T05:22:09Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.linky/src/main/java/org/openhab/binding/linky/internal/handler/LinkyHandler.java", "diffHunk": "@@ -0,0 +1,387 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.linky.internal.handler;\n+\n+import static org.openhab.binding.linky.internal.LinkyBindingConstants.*;\n+import static org.openhab.binding.linky.internal.model.LinkyTimeScale.*;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.temporal.ChronoUnit;\n+import java.time.temporal.WeekFields;\n+import java.util.Base64;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.i18n.LocaleProvider;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.linky.internal.ExpiringDayCache;\n+import org.openhab.binding.linky.internal.LinkyConfiguration;\n+import org.openhab.binding.linky.internal.model.LinkyConsumptionData;\n+import org.openhab.binding.linky.internal.model.LinkyTimeScale;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+import okhttp3.FormBody;\n+import okhttp3.FormBody.Builder;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.Response;\n+\n+/**\n+ * The {@link LinkyHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ga\u00ebl L'hopital - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class LinkyHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(LinkyHandler.class);\n+\n+    private static final String LOGIN_BASE_URI = \"https://espace-client-connexion.enedis.fr/auth/UI/Login\";\n+    private static final String API_BASE_URI = \"https://espace-client-particuliers.enedis.fr/group/espace-particuliers/suivi-de-consommation\";\n+    private static final DateTimeFormatter API_DATE_FORMAT = DateTimeFormatter.ofPattern(\"dd/MM/yyyy\");\n+    private static final Builder LOGIN_BODY_BUILDER = new FormBody.Builder().add(\"encoded\", \"true\")\n+            .add(\"gx_charset\", \"UTF-8\").add(\"SunQueryParamsString\",\n+                    Base64.getEncoder().encodeToString(\"realm=particuliers\".getBytes(StandardCharsets.UTF_8)));\n+\n+    private static final int REFRESH_FIRST_HOUR_OF_DAY = 5;\n+    private static final int REFRESH_INTERVAL_IN_MIN = 360;\n+\n+    private final OkHttpClient client = new OkHttpClient.Builder().followRedirects(false)\n+            .cookieJar(new LinkyCookieJar()).build();\n+    private final Gson gson = new Gson();\n+\n+    private @NonNullByDefault({}) ScheduledFuture<?> refreshJob;\n+    private final WeekFields weekFields;\n+\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedDaylyData;\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedMonthlyData;\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedYearlyData;\n+\n+    public LinkyHandler(Thing thing, LocaleProvider localeProvider) {\n+        super(thing);\n+        this.weekFields = WeekFields.of(localeProvider.getLocale());\n+        this.cachedDaylyData = new ExpiringDayCache<LinkyConsumptionData>(\"daily cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(DAILY, today.minusDays(13), today, true);\n+                });\n+        this.cachedMonthlyData = new ExpiringDayCache<LinkyConsumptionData>(\"monthly cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(MONTHLY, today.withDayOfMonth(1).minusMonths(1), today, true);\n+                });\n+        this.cachedYearlyData = new ExpiringDayCache<LinkyConsumptionData>(\"yearly cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(YEARLY, LocalDate.of(today.getYear() - 1, 1, 1), today, true);\n+                });\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing Linky handler.\");\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.schedule(this::login, 0, TimeUnit.SECONDS);\n+\n+        final LocalDateTime now = LocalDateTime.now();\n+        final LocalDateTime nextDayFirstTimeUpdate = now.plusDays(1).withHour(REFRESH_FIRST_HOUR_OF_DAY)\n+                .truncatedTo(ChronoUnit.HOURS);\n+        refreshJob = scheduler.scheduleWithFixedDelay(this::updateData,\n+                ChronoUnit.MINUTES.between(now, nextDayFirstTimeUpdate) % REFRESH_INTERVAL_IN_MIN + 1,\n+                REFRESH_INTERVAL_IN_MIN, TimeUnit.MINUTES);\n+    }\n+\n+    private synchronized boolean login() {\n+        logger.debug(\"login\");\n+\n+        LinkyConfiguration config = getConfigAs(LinkyConfiguration.class);\n+        try {\n+            Request requestLogin = new Request.Builder().url(LOGIN_BASE_URI)\n+                    .post(LOGIN_BODY_BUILDER.add(\"IDToken1\", config.username).add(\"IDToken2\", config.password).build())\n+                    .build();\n+            Response response = client.newCall(requestLogin).execute();\n+            if (response.isRedirect()) {\n+                logger.debug(\"Response status {} {} redirects to {}\", response.code(), response.message(),\n+                        response.header(\"Location\"));\n+            } else {\n+                logger.debug(\"Response status {} {}\", response.code(), response.message());\n+            }\n+            response.close();\n+\n+            // Do a first call to get data; this first call will fail with code 302\n+            getConsumptionData(DAILY, LocalDate.now(), LocalDate.now(), false);\n+            updateStatus(ThingStatus.ONLINE);\n+            return true;\n+        } catch (IOException e) {\n+            logger.debug(\"Exception while trying to login: {}\", e.getMessage(), e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+            return false;\n+        }\n+    }\n+\n+    /**\n+     * Request new data and updates channels\n+     */\n+    private void updateData() {\n+        updateDailyData();\n+        updateMonthlyData();\n+        updateYearlyData();\n+    }\n+\n+    /**\n+     * Request new dayly/weekly data and updates channels\n+     */\n+    private synchronized void updateDailyData() {\n+        if (!isLinked(YESTERDAY) && !isLinked(LAST_WEEK) && !isLinked(THIS_WEEK)) {\n+            return;\n+        }\n+\n+        double lastWeek = -1;\n+        double thisWeek = -1;\n+        double yesterday = -1;\n+        LinkyConsumptionData result = cachedDaylyData.getValue();\n+        if (result != null && result.success()) {\n+            LocalDate rangeStart = LocalDate.now().minusDays(13);\n+            int jump = result.getDecalage();\n+            while (rangeStart.getDayOfWeek() != weekFields.getFirstDayOfWeek()) {\n+                rangeStart = rangeStart.plusDays(1);\n+                jump++;\n+            }\n+\n+            int lastWeekNumber = rangeStart.get(weekFields.weekOfWeekBasedYear());\n+\n+            lastWeek = 0;\n+            thisWeek = 0;\n+            yesterday = -1;\n+            while (jump < result.getData().size()) {\n+                double consumption = result.getData().get(jump).valeur;\n+                if (consumption > 0) {\n+                    if (rangeStart.get(weekFields.weekOfWeekBasedYear()) == lastWeekNumber) {\n+                        lastWeek += consumption;\n+                        logger.trace(\"Consumption at index {} added to last week: {}\", jump, consumption);\n+                    } else {\n+                        thisWeek += consumption;\n+                        logger.trace(\"Consumption at index {} added to current week: {}\", jump, consumption);\n+                    }\n+                    yesterday = consumption;\n+                }\n+                jump++;\n+                rangeStart = rangeStart.plusDays(1);\n+            }\n+        } else {\n+            cachedDaylyData.invalidateValue();\n+        }\n+        updateKwhChannel(YESTERDAY, yesterday);\n+        updateKwhChannel(THIS_WEEK, thisWeek);\n+        updateKwhChannel(LAST_WEEK, lastWeek);\n+    }\n+\n+    /**\n+     * Request new monthly data and updates channels\n+     */\n+    private synchronized void updateMonthlyData() {\n+        if (!isLinked(LAST_MONTH) && !isLinked(THIS_MONTH)) {\n+            return;\n+        }\n+\n+        double lastMonth = -1;\n+        double thisMonth = -1;\n+        LinkyConsumptionData result = cachedMonthlyData.getValue();\n+        if (result != null && result.success()) {\n+            int jump = result.getDecalage();\n+            lastMonth = result.getData().get(jump++).valeur;\n+            thisMonth = result.getData().get(jump).valeur;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43039363b2e2795c326571cf80a034f1c0a90a5a"}, "originalPosition": 223}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ0MzY1Nw==", "bodyText": "Please use StringBuilder instead of string concatenation to build up this value.", "url": "https://github.com/openhab/openhab-addons/pull/7101#discussion_r395443657", "createdAt": "2020-03-20T05:23:03Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.linky/src/main/java/org/openhab/binding/linky/internal/handler/LinkyHandler.java", "diffHunk": "@@ -0,0 +1,387 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.linky.internal.handler;\n+\n+import static org.openhab.binding.linky.internal.LinkyBindingConstants.*;\n+import static org.openhab.binding.linky.internal.model.LinkyTimeScale.*;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.temporal.ChronoUnit;\n+import java.time.temporal.WeekFields;\n+import java.util.Base64;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.i18n.LocaleProvider;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.linky.internal.ExpiringDayCache;\n+import org.openhab.binding.linky.internal.LinkyConfiguration;\n+import org.openhab.binding.linky.internal.model.LinkyConsumptionData;\n+import org.openhab.binding.linky.internal.model.LinkyTimeScale;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+import okhttp3.FormBody;\n+import okhttp3.FormBody.Builder;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.Response;\n+\n+/**\n+ * The {@link LinkyHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ga\u00ebl L'hopital - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class LinkyHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(LinkyHandler.class);\n+\n+    private static final String LOGIN_BASE_URI = \"https://espace-client-connexion.enedis.fr/auth/UI/Login\";\n+    private static final String API_BASE_URI = \"https://espace-client-particuliers.enedis.fr/group/espace-particuliers/suivi-de-consommation\";\n+    private static final DateTimeFormatter API_DATE_FORMAT = DateTimeFormatter.ofPattern(\"dd/MM/yyyy\");\n+    private static final Builder LOGIN_BODY_BUILDER = new FormBody.Builder().add(\"encoded\", \"true\")\n+            .add(\"gx_charset\", \"UTF-8\").add(\"SunQueryParamsString\",\n+                    Base64.getEncoder().encodeToString(\"realm=particuliers\".getBytes(StandardCharsets.UTF_8)));\n+\n+    private static final int REFRESH_FIRST_HOUR_OF_DAY = 5;\n+    private static final int REFRESH_INTERVAL_IN_MIN = 360;\n+\n+    private final OkHttpClient client = new OkHttpClient.Builder().followRedirects(false)\n+            .cookieJar(new LinkyCookieJar()).build();\n+    private final Gson gson = new Gson();\n+\n+    private @NonNullByDefault({}) ScheduledFuture<?> refreshJob;\n+    private final WeekFields weekFields;\n+\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedDaylyData;\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedMonthlyData;\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedYearlyData;\n+\n+    public LinkyHandler(Thing thing, LocaleProvider localeProvider) {\n+        super(thing);\n+        this.weekFields = WeekFields.of(localeProvider.getLocale());\n+        this.cachedDaylyData = new ExpiringDayCache<LinkyConsumptionData>(\"daily cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(DAILY, today.minusDays(13), today, true);\n+                });\n+        this.cachedMonthlyData = new ExpiringDayCache<LinkyConsumptionData>(\"monthly cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(MONTHLY, today.withDayOfMonth(1).minusMonths(1), today, true);\n+                });\n+        this.cachedYearlyData = new ExpiringDayCache<LinkyConsumptionData>(\"yearly cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(YEARLY, LocalDate.of(today.getYear() - 1, 1, 1), today, true);\n+                });\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing Linky handler.\");\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.schedule(this::login, 0, TimeUnit.SECONDS);\n+\n+        final LocalDateTime now = LocalDateTime.now();\n+        final LocalDateTime nextDayFirstTimeUpdate = now.plusDays(1).withHour(REFRESH_FIRST_HOUR_OF_DAY)\n+                .truncatedTo(ChronoUnit.HOURS);\n+        refreshJob = scheduler.scheduleWithFixedDelay(this::updateData,\n+                ChronoUnit.MINUTES.between(now, nextDayFirstTimeUpdate) % REFRESH_INTERVAL_IN_MIN + 1,\n+                REFRESH_INTERVAL_IN_MIN, TimeUnit.MINUTES);\n+    }\n+\n+    private synchronized boolean login() {\n+        logger.debug(\"login\");\n+\n+        LinkyConfiguration config = getConfigAs(LinkyConfiguration.class);\n+        try {\n+            Request requestLogin = new Request.Builder().url(LOGIN_BASE_URI)\n+                    .post(LOGIN_BODY_BUILDER.add(\"IDToken1\", config.username).add(\"IDToken2\", config.password).build())\n+                    .build();\n+            Response response = client.newCall(requestLogin).execute();\n+            if (response.isRedirect()) {\n+                logger.debug(\"Response status {} {} redirects to {}\", response.code(), response.message(),\n+                        response.header(\"Location\"));\n+            } else {\n+                logger.debug(\"Response status {} {}\", response.code(), response.message());\n+            }\n+            response.close();\n+\n+            // Do a first call to get data; this first call will fail with code 302\n+            getConsumptionData(DAILY, LocalDate.now(), LocalDate.now(), false);\n+            updateStatus(ThingStatus.ONLINE);\n+            return true;\n+        } catch (IOException e) {\n+            logger.debug(\"Exception while trying to login: {}\", e.getMessage(), e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+            return false;\n+        }\n+    }\n+\n+    /**\n+     * Request new data and updates channels\n+     */\n+    private void updateData() {\n+        updateDailyData();\n+        updateMonthlyData();\n+        updateYearlyData();\n+    }\n+\n+    /**\n+     * Request new dayly/weekly data and updates channels\n+     */\n+    private synchronized void updateDailyData() {\n+        if (!isLinked(YESTERDAY) && !isLinked(LAST_WEEK) && !isLinked(THIS_WEEK)) {\n+            return;\n+        }\n+\n+        double lastWeek = -1;\n+        double thisWeek = -1;\n+        double yesterday = -1;\n+        LinkyConsumptionData result = cachedDaylyData.getValue();\n+        if (result != null && result.success()) {\n+            LocalDate rangeStart = LocalDate.now().minusDays(13);\n+            int jump = result.getDecalage();\n+            while (rangeStart.getDayOfWeek() != weekFields.getFirstDayOfWeek()) {\n+                rangeStart = rangeStart.plusDays(1);\n+                jump++;\n+            }\n+\n+            int lastWeekNumber = rangeStart.get(weekFields.weekOfWeekBasedYear());\n+\n+            lastWeek = 0;\n+            thisWeek = 0;\n+            yesterday = -1;\n+            while (jump < result.getData().size()) {\n+                double consumption = result.getData().get(jump).valeur;\n+                if (consumption > 0) {\n+                    if (rangeStart.get(weekFields.weekOfWeekBasedYear()) == lastWeekNumber) {\n+                        lastWeek += consumption;\n+                        logger.trace(\"Consumption at index {} added to last week: {}\", jump, consumption);\n+                    } else {\n+                        thisWeek += consumption;\n+                        logger.trace(\"Consumption at index {} added to current week: {}\", jump, consumption);\n+                    }\n+                    yesterday = consumption;\n+                }\n+                jump++;\n+                rangeStart = rangeStart.plusDays(1);\n+            }\n+        } else {\n+            cachedDaylyData.invalidateValue();\n+        }\n+        updateKwhChannel(YESTERDAY, yesterday);\n+        updateKwhChannel(THIS_WEEK, thisWeek);\n+        updateKwhChannel(LAST_WEEK, lastWeek);\n+    }\n+\n+    /**\n+     * Request new monthly data and updates channels\n+     */\n+    private synchronized void updateMonthlyData() {\n+        if (!isLinked(LAST_MONTH) && !isLinked(THIS_MONTH)) {\n+            return;\n+        }\n+\n+        double lastMonth = -1;\n+        double thisMonth = -1;\n+        LinkyConsumptionData result = cachedMonthlyData.getValue();\n+        if (result != null && result.success()) {\n+            int jump = result.getDecalage();\n+            lastMonth = result.getData().get(jump++).valeur;\n+            thisMonth = result.getData().get(jump).valeur;\n+            if (thisMonth < 0) {\n+                thisMonth = 0;\n+            }\n+        } else {\n+            cachedMonthlyData.invalidateValue();\n+        }\n+        updateKwhChannel(LAST_MONTH, lastMonth);\n+        updateKwhChannel(THIS_MONTH, thisMonth);\n+    }\n+\n+    /**\n+     * Request new yearly data and updates channels\n+     */\n+    private synchronized void updateYearlyData() {\n+        if (!isLinked(LAST_YEAR) && !isLinked(THIS_YEAR)) {\n+            return;\n+        }\n+\n+        double thisYear = -1;\n+        double lastYear = -1;\n+        LinkyConsumptionData result = cachedYearlyData.getValue();\n+        if (result != null && result.success()) {\n+            int elementQuantity = result.getData().size();\n+            thisYear = elementQuantity > 0 ? result.getData().get(elementQuantity - 1).valeur : -1;\n+            lastYear = elementQuantity > 1 ? result.getData().get(elementQuantity - 2).valeur : -1;\n+        } else {\n+            cachedYearlyData.invalidateValue();\n+        }\n+        updateKwhChannel(LAST_YEAR, lastYear);\n+        updateKwhChannel(THIS_YEAR, thisYear);\n+    }\n+\n+    private void updateKwhChannel(String channelId, double consumption) {\n+        logger.debug(\"Update channel {} with {}\", channelId, consumption);\n+        updateState(channelId,\n+                consumption != -1 ? new QuantityType<>(consumption, SmartHomeUnits.KILOWATT_HOUR) : UnDefType.UNDEF);\n+    }\n+\n+    /**\n+     * Produce a report of all daily values between two dates\n+     *\n+     * @param startDay the start day of the report\n+     * @param endDay the end day of the report\n+     * @param separator the separator to be used betwwen the date and the value\n+     *\n+     * @return the report as a string\n+     */\n+    public String reportValues(LocalDate startDay, LocalDate endDay, @Nullable String separator) {\n+        String dump = \"\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43039363b2e2795c326571cf80a034f1c0a90a5a"}, "originalPosition": 272}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTQ0Mzk5OA==", "bodyText": "Surely there is a way to implement this without recursion right?", "url": "https://github.com/openhab/openhab-addons/pull/7101#discussion_r395443998", "createdAt": "2020-03-20T05:24:56Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.linky/src/main/java/org/openhab/binding/linky/internal/handler/LinkyHandler.java", "diffHunk": "@@ -0,0 +1,387 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.linky.internal.handler;\n+\n+import static org.openhab.binding.linky.internal.LinkyBindingConstants.*;\n+import static org.openhab.binding.linky.internal.model.LinkyTimeScale.*;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.temporal.ChronoUnit;\n+import java.time.temporal.WeekFields;\n+import java.util.Base64;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.i18n.LocaleProvider;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.linky.internal.ExpiringDayCache;\n+import org.openhab.binding.linky.internal.LinkyConfiguration;\n+import org.openhab.binding.linky.internal.model.LinkyConsumptionData;\n+import org.openhab.binding.linky.internal.model.LinkyTimeScale;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+import okhttp3.FormBody;\n+import okhttp3.FormBody.Builder;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.Response;\n+\n+/**\n+ * The {@link LinkyHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ga\u00ebl L'hopital - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class LinkyHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(LinkyHandler.class);\n+\n+    private static final String LOGIN_BASE_URI = \"https://espace-client-connexion.enedis.fr/auth/UI/Login\";\n+    private static final String API_BASE_URI = \"https://espace-client-particuliers.enedis.fr/group/espace-particuliers/suivi-de-consommation\";\n+    private static final DateTimeFormatter API_DATE_FORMAT = DateTimeFormatter.ofPattern(\"dd/MM/yyyy\");\n+    private static final Builder LOGIN_BODY_BUILDER = new FormBody.Builder().add(\"encoded\", \"true\")\n+            .add(\"gx_charset\", \"UTF-8\").add(\"SunQueryParamsString\",\n+                    Base64.getEncoder().encodeToString(\"realm=particuliers\".getBytes(StandardCharsets.UTF_8)));\n+\n+    private static final int REFRESH_FIRST_HOUR_OF_DAY = 5;\n+    private static final int REFRESH_INTERVAL_IN_MIN = 360;\n+\n+    private final OkHttpClient client = new OkHttpClient.Builder().followRedirects(false)\n+            .cookieJar(new LinkyCookieJar()).build();\n+    private final Gson gson = new Gson();\n+\n+    private @NonNullByDefault({}) ScheduledFuture<?> refreshJob;\n+    private final WeekFields weekFields;\n+\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedDaylyData;\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedMonthlyData;\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedYearlyData;\n+\n+    public LinkyHandler(Thing thing, LocaleProvider localeProvider) {\n+        super(thing);\n+        this.weekFields = WeekFields.of(localeProvider.getLocale());\n+        this.cachedDaylyData = new ExpiringDayCache<LinkyConsumptionData>(\"daily cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(DAILY, today.minusDays(13), today, true);\n+                });\n+        this.cachedMonthlyData = new ExpiringDayCache<LinkyConsumptionData>(\"monthly cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(MONTHLY, today.withDayOfMonth(1).minusMonths(1), today, true);\n+                });\n+        this.cachedYearlyData = new ExpiringDayCache<LinkyConsumptionData>(\"yearly cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(YEARLY, LocalDate.of(today.getYear() - 1, 1, 1), today, true);\n+                });\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing Linky handler.\");\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.schedule(this::login, 0, TimeUnit.SECONDS);\n+\n+        final LocalDateTime now = LocalDateTime.now();\n+        final LocalDateTime nextDayFirstTimeUpdate = now.plusDays(1).withHour(REFRESH_FIRST_HOUR_OF_DAY)\n+                .truncatedTo(ChronoUnit.HOURS);\n+        refreshJob = scheduler.scheduleWithFixedDelay(this::updateData,\n+                ChronoUnit.MINUTES.between(now, nextDayFirstTimeUpdate) % REFRESH_INTERVAL_IN_MIN + 1,\n+                REFRESH_INTERVAL_IN_MIN, TimeUnit.MINUTES);\n+    }\n+\n+    private synchronized boolean login() {\n+        logger.debug(\"login\");\n+\n+        LinkyConfiguration config = getConfigAs(LinkyConfiguration.class);\n+        try {\n+            Request requestLogin = new Request.Builder().url(LOGIN_BASE_URI)\n+                    .post(LOGIN_BODY_BUILDER.add(\"IDToken1\", config.username).add(\"IDToken2\", config.password).build())\n+                    .build();\n+            Response response = client.newCall(requestLogin).execute();\n+            if (response.isRedirect()) {\n+                logger.debug(\"Response status {} {} redirects to {}\", response.code(), response.message(),\n+                        response.header(\"Location\"));\n+            } else {\n+                logger.debug(\"Response status {} {}\", response.code(), response.message());\n+            }\n+            response.close();\n+\n+            // Do a first call to get data; this first call will fail with code 302\n+            getConsumptionData(DAILY, LocalDate.now(), LocalDate.now(), false);\n+            updateStatus(ThingStatus.ONLINE);\n+            return true;\n+        } catch (IOException e) {\n+            logger.debug(\"Exception while trying to login: {}\", e.getMessage(), e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+            return false;\n+        }\n+    }\n+\n+    /**\n+     * Request new data and updates channels\n+     */\n+    private void updateData() {\n+        updateDailyData();\n+        updateMonthlyData();\n+        updateYearlyData();\n+    }\n+\n+    /**\n+     * Request new dayly/weekly data and updates channels\n+     */\n+    private synchronized void updateDailyData() {\n+        if (!isLinked(YESTERDAY) && !isLinked(LAST_WEEK) && !isLinked(THIS_WEEK)) {\n+            return;\n+        }\n+\n+        double lastWeek = -1;\n+        double thisWeek = -1;\n+        double yesterday = -1;\n+        LinkyConsumptionData result = cachedDaylyData.getValue();\n+        if (result != null && result.success()) {\n+            LocalDate rangeStart = LocalDate.now().minusDays(13);\n+            int jump = result.getDecalage();\n+            while (rangeStart.getDayOfWeek() != weekFields.getFirstDayOfWeek()) {\n+                rangeStart = rangeStart.plusDays(1);\n+                jump++;\n+            }\n+\n+            int lastWeekNumber = rangeStart.get(weekFields.weekOfWeekBasedYear());\n+\n+            lastWeek = 0;\n+            thisWeek = 0;\n+            yesterday = -1;\n+            while (jump < result.getData().size()) {\n+                double consumption = result.getData().get(jump).valeur;\n+                if (consumption > 0) {\n+                    if (rangeStart.get(weekFields.weekOfWeekBasedYear()) == lastWeekNumber) {\n+                        lastWeek += consumption;\n+                        logger.trace(\"Consumption at index {} added to last week: {}\", jump, consumption);\n+                    } else {\n+                        thisWeek += consumption;\n+                        logger.trace(\"Consumption at index {} added to current week: {}\", jump, consumption);\n+                    }\n+                    yesterday = consumption;\n+                }\n+                jump++;\n+                rangeStart = rangeStart.plusDays(1);\n+            }\n+        } else {\n+            cachedDaylyData.invalidateValue();\n+        }\n+        updateKwhChannel(YESTERDAY, yesterday);\n+        updateKwhChannel(THIS_WEEK, thisWeek);\n+        updateKwhChannel(LAST_WEEK, lastWeek);\n+    }\n+\n+    /**\n+     * Request new monthly data and updates channels\n+     */\n+    private synchronized void updateMonthlyData() {\n+        if (!isLinked(LAST_MONTH) && !isLinked(THIS_MONTH)) {\n+            return;\n+        }\n+\n+        double lastMonth = -1;\n+        double thisMonth = -1;\n+        LinkyConsumptionData result = cachedMonthlyData.getValue();\n+        if (result != null && result.success()) {\n+            int jump = result.getDecalage();\n+            lastMonth = result.getData().get(jump++).valeur;\n+            thisMonth = result.getData().get(jump).valeur;\n+            if (thisMonth < 0) {\n+                thisMonth = 0;\n+            }\n+        } else {\n+            cachedMonthlyData.invalidateValue();\n+        }\n+        updateKwhChannel(LAST_MONTH, lastMonth);\n+        updateKwhChannel(THIS_MONTH, thisMonth);\n+    }\n+\n+    /**\n+     * Request new yearly data and updates channels\n+     */\n+    private synchronized void updateYearlyData() {\n+        if (!isLinked(LAST_YEAR) && !isLinked(THIS_YEAR)) {\n+            return;\n+        }\n+\n+        double thisYear = -1;\n+        double lastYear = -1;\n+        LinkyConsumptionData result = cachedYearlyData.getValue();\n+        if (result != null && result.success()) {\n+            int elementQuantity = result.getData().size();\n+            thisYear = elementQuantity > 0 ? result.getData().get(elementQuantity - 1).valeur : -1;\n+            lastYear = elementQuantity > 1 ? result.getData().get(elementQuantity - 2).valeur : -1;\n+        } else {\n+            cachedYearlyData.invalidateValue();\n+        }\n+        updateKwhChannel(LAST_YEAR, lastYear);\n+        updateKwhChannel(THIS_YEAR, thisYear);\n+    }\n+\n+    private void updateKwhChannel(String channelId, double consumption) {\n+        logger.debug(\"Update channel {} with {}\", channelId, consumption);\n+        updateState(channelId,\n+                consumption != -1 ? new QuantityType<>(consumption, SmartHomeUnits.KILOWATT_HOUR) : UnDefType.UNDEF);\n+    }\n+\n+    /**\n+     * Produce a report of all daily values between two dates\n+     *\n+     * @param startDay the start day of the report\n+     * @param endDay the end day of the report\n+     * @param separator the separator to be used betwwen the date and the value\n+     *\n+     * @return the report as a string\n+     */\n+    public String reportValues(LocalDate startDay, LocalDate endDay, @Nullable String separator) {\n+        String dump = \"\";\n+        if (startDay.getYear() == endDay.getYear() && startDay.getMonthValue() == endDay.getMonthValue()) {\n+            // All values in the same month\n+            LinkyConsumptionData result = getConsumptionData(DAILY, startDay, endDay, true);\n+            if (result != null && result.success()) {\n+                LocalDate currentDay = startDay;\n+                int jump = result.getDecalage();\n+                while (jump < result.getData().size() && !currentDay.isAfter(endDay)) {\n+                    double consumption = result.getData().get(jump).valeur;\n+                    dump += currentDay.format(DateTimeFormatter.ISO_LOCAL_DATE) + separator;\n+                    if (consumption >= 0) {\n+                        dump += String.valueOf(consumption);\n+                    }\n+                    dump += \"\\n\";\n+                    jump++;\n+                    currentDay = currentDay.plusDays(1);\n+                }\n+            } else {\n+                LocalDate currentDay = startDay;\n+                while (!currentDay.isAfter(endDay)) {\n+                    dump += currentDay.format(DateTimeFormatter.ISO_LOCAL_DATE) + separator + \"\\n\";\n+                    currentDay = currentDay.plusDays(1);\n+                }\n+            }\n+        } else {\n+            // Concatenate the report produced for each month between the two dates\n+            LocalDate first = startDay;\n+            do {\n+                LocalDate last = first.withDayOfMonth(first.lengthOfMonth());\n+                if (last.isAfter(endDay)) {\n+                    last = endDay;\n+                }\n+                dump += reportValues(first, last, separator);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43039363b2e2795c326571cf80a034f1c0a90a5a"}, "originalPosition": 304}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "00bed837d677a440e07ef1e33ff891b470a852bb", "author": {"user": {"login": "clinique", "name": "Ga\u00ebl L'hopital"}}, "url": "https://github.com/openhab/openhab-addons/commit/00bed837d677a440e07ef1e33ff891b470a852bb", "committedDate": "2020-03-20T07:25:49Z", "message": "Code review corrections\n\nSigned-off-by: clinique <gael@lhopital.org>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4ODI2OTUz", "url": "https://github.com/openhab/openhab-addons/pull/7101#pullrequestreview-378826953", "createdAt": "2020-03-20T21:39:32Z", "commit": {"oid": "00bed837d677a440e07ef1e33ff891b470a852bb"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQyMTozOTozMlrOF5j7Zg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQyMTo1NTowM1rOF5kPPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTkwMTc5OA==", "bodyText": "You need to add license information for the okhttp and okio dependencies.", "url": "https://github.com/openhab/openhab-addons/pull/7101#discussion_r395901798", "createdAt": "2020-03-20T21:39:32Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.linky/NOTICE", "diffHunk": "@@ -0,0 +1,13 @@\n+This content is produced and maintained by the openHAB project.\n+\n+* Project home: https://www.openhab.org\n+\n+== Declared Project Licenses\n+\n+This program and the accompanying materials are made available under the terms\n+of the Eclipse Public License 2.0 which is available at\n+https://www.eclipse.org/legal/epl-2.0/.\n+\n+== Source Code\n+\n+https://github.com/openhab/openhab-addons", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00bed837d677a440e07ef1e33ff891b470a852bb"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTkwNjg3Ng==", "bodyText": "Instead of -1, use Double.NaN to represent the the absence of data. This makes the code look safer as well as using an already existing definition for bad data.", "url": "https://github.com/openhab/openhab-addons/pull/7101#discussion_r395906876", "createdAt": "2020-03-20T21:55:03Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.linky/src/main/java/org/openhab/binding/linky/internal/handler/LinkyHandler.java", "diffHunk": "@@ -0,0 +1,387 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.linky.internal.handler;\n+\n+import static org.openhab.binding.linky.internal.LinkyBindingConstants.*;\n+import static org.openhab.binding.linky.internal.model.LinkyTimeScale.*;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.temporal.ChronoUnit;\n+import java.time.temporal.WeekFields;\n+import java.util.Base64;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.i18n.LocaleProvider;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.linky.internal.ExpiringDayCache;\n+import org.openhab.binding.linky.internal.LinkyConfiguration;\n+import org.openhab.binding.linky.internal.model.LinkyConsumptionData;\n+import org.openhab.binding.linky.internal.model.LinkyTimeScale;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+import okhttp3.FormBody;\n+import okhttp3.FormBody.Builder;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.Response;\n+\n+/**\n+ * The {@link LinkyHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ga\u00ebl L'hopital - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class LinkyHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(LinkyHandler.class);\n+\n+    private static final String LOGIN_BASE_URI = \"https://espace-client-connexion.enedis.fr/auth/UI/Login\";\n+    private static final String API_BASE_URI = \"https://espace-client-particuliers.enedis.fr/group/espace-particuliers/suivi-de-consommation\";\n+    private static final DateTimeFormatter API_DATE_FORMAT = DateTimeFormatter.ofPattern(\"dd/MM/yyyy\");\n+    private static final Builder LOGIN_BODY_BUILDER = new FormBody.Builder().add(\"encoded\", \"true\")\n+            .add(\"gx_charset\", \"UTF-8\").add(\"SunQueryParamsString\",\n+                    Base64.getEncoder().encodeToString(\"realm=particuliers\".getBytes(StandardCharsets.UTF_8)));\n+\n+    private static final int REFRESH_FIRST_HOUR_OF_DAY = 5;\n+    private static final int REFRESH_INTERVAL_IN_MIN = 360;\n+\n+    private final OkHttpClient client = new OkHttpClient.Builder().followRedirects(false)\n+            .cookieJar(new LinkyCookieJar()).build();\n+    private final Gson gson = new Gson();\n+\n+    private @NonNullByDefault({}) ScheduledFuture<?> refreshJob;\n+    private final WeekFields weekFields;\n+\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedDaylyData;\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedMonthlyData;\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedYearlyData;\n+\n+    public LinkyHandler(Thing thing, LocaleProvider localeProvider) {\n+        super(thing);\n+        this.weekFields = WeekFields.of(localeProvider.getLocale());\n+        this.cachedDaylyData = new ExpiringDayCache<LinkyConsumptionData>(\"daily cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(DAILY, today.minusDays(13), today, true);\n+                });\n+        this.cachedMonthlyData = new ExpiringDayCache<LinkyConsumptionData>(\"monthly cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(MONTHLY, today.withDayOfMonth(1).minusMonths(1), today, true);\n+                });\n+        this.cachedYearlyData = new ExpiringDayCache<LinkyConsumptionData>(\"yearly cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(YEARLY, LocalDate.of(today.getYear() - 1, 1, 1), today, true);\n+                });\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing Linky handler.\");\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.submit(this::login);\n+\n+        final LocalDateTime now = LocalDateTime.now();\n+        final LocalDateTime nextDayFirstTimeUpdate = now.plusDays(1).withHour(REFRESH_FIRST_HOUR_OF_DAY)\n+                .truncatedTo(ChronoUnit.HOURS);\n+        refreshJob = scheduler.scheduleWithFixedDelay(this::updateData,\n+                ChronoUnit.MINUTES.between(now, nextDayFirstTimeUpdate) % REFRESH_INTERVAL_IN_MIN + 1,\n+                REFRESH_INTERVAL_IN_MIN, TimeUnit.MINUTES);\n+    }\n+\n+    private synchronized boolean login() {\n+        logger.debug(\"login\");\n+\n+        LinkyConfiguration config = getConfigAs(LinkyConfiguration.class);\n+        try {\n+            Request requestLogin = new Request.Builder().url(LOGIN_BASE_URI)\n+                    .post(LOGIN_BODY_BUILDER.add(\"IDToken1\", config.username).add(\"IDToken2\", config.password).build())\n+                    .build();\n+            Response response = client.newCall(requestLogin).execute();\n+            if (response.isRedirect()) {\n+                logger.debug(\"Response status {} {} redirects to {}\", response.code(), response.message(),\n+                        response.header(\"Location\"));\n+            } else {\n+                logger.debug(\"Response status {} {}\", response.code(), response.message());\n+            }\n+            response.close();\n+\n+            // Do a first call to get data; this first call will fail with code 302\n+            getConsumptionData(DAILY, LocalDate.now(), LocalDate.now(), false);\n+            updateStatus(ThingStatus.ONLINE);\n+            return true;\n+        } catch (IOException e) {\n+            logger.debug(\"Exception while trying to login: {}\", e.getMessage(), e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+            return false;\n+        }\n+    }\n+\n+    /**\n+     * Request new data and updates channels\n+     */\n+    private void updateData() {\n+        updateDailyData();\n+        updateMonthlyData();\n+        updateYearlyData();\n+    }\n+\n+    /**\n+     * Request new dayly/weekly data and updates channels\n+     */\n+    private synchronized void updateDailyData() {\n+        if (!isLinked(YESTERDAY) && !isLinked(LAST_WEEK) && !isLinked(THIS_WEEK)) {\n+            return;\n+        }\n+\n+        double lastWeek = -1;\n+        double thisWeek = -1;\n+        double yesterday = -1;\n+        LinkyConsumptionData result = cachedDaylyData.getValue();\n+        if (result != null && result.success()) {\n+            LocalDate rangeStart = LocalDate.now().minusDays(13);\n+            int jump = result.getDecalage();\n+            while (rangeStart.getDayOfWeek() != weekFields.getFirstDayOfWeek()) {\n+                rangeStart = rangeStart.plusDays(1);\n+                jump++;\n+            }\n+\n+            int lastWeekNumber = rangeStart.get(weekFields.weekOfWeekBasedYear());\n+\n+            lastWeek = 0;\n+            thisWeek = 0;\n+            yesterday = -1;\n+            while (jump < result.getData().size()) {\n+                double consumption = result.getData().get(jump).valeur;\n+                if (consumption > 0) {\n+                    if (rangeStart.get(weekFields.weekOfWeekBasedYear()) == lastWeekNumber) {\n+                        lastWeek += consumption;\n+                        logger.trace(\"Consumption at index {} added to last week: {}\", jump, consumption);\n+                    } else {\n+                        thisWeek += consumption;\n+                        logger.trace(\"Consumption at index {} added to current week: {}\", jump, consumption);\n+                    }\n+                    yesterday = consumption;\n+                }\n+                jump++;\n+                rangeStart = rangeStart.plusDays(1);\n+            }\n+        } else {\n+            cachedDaylyData.invalidateValue();\n+        }\n+        updateKwhChannel(YESTERDAY, yesterday);\n+        updateKwhChannel(THIS_WEEK, thisWeek);\n+        updateKwhChannel(LAST_WEEK, lastWeek);\n+    }\n+\n+    /**\n+     * Request new monthly data and updates channels\n+     */\n+    private synchronized void updateMonthlyData() {\n+        if (!isLinked(LAST_MONTH) && !isLinked(THIS_MONTH)) {\n+            return;\n+        }\n+\n+        double lastMonth = -1;\n+        double thisMonth = -1;\n+        LinkyConsumptionData result = cachedMonthlyData.getValue();\n+        if (result != null && result.success()) {\n+            int jump = result.getDecalage();\n+            lastMonth = result.getData().get(jump).valeur;\n+            thisMonth = result.getData().get(jump + 1).valeur;\n+            if (thisMonth < 0) {\n+                thisMonth = 0;\n+            }\n+        } else {\n+            cachedMonthlyData.invalidateValue();\n+        }\n+        updateKwhChannel(LAST_MONTH, lastMonth);\n+        updateKwhChannel(THIS_MONTH, thisMonth);\n+    }\n+\n+    /**\n+     * Request new yearly data and updates channels\n+     */\n+    private synchronized void updateYearlyData() {\n+        if (!isLinked(LAST_YEAR) && !isLinked(THIS_YEAR)) {\n+            return;\n+        }\n+\n+        double thisYear = -1;\n+        double lastYear = -1;\n+        LinkyConsumptionData result = cachedYearlyData.getValue();\n+        if (result != null && result.success()) {\n+            int elementQuantity = result.getData().size();\n+            thisYear = elementQuantity > 0 ? result.getData().get(elementQuantity - 1).valeur : -1;\n+            lastYear = elementQuantity > 1 ? result.getData().get(elementQuantity - 2).valeur : -1;\n+        } else {\n+            cachedYearlyData.invalidateValue();\n+        }\n+        updateKwhChannel(LAST_YEAR, lastYear);\n+        updateKwhChannel(THIS_YEAR, thisYear);\n+    }\n+\n+    private void updateKwhChannel(String channelId, double consumption) {\n+        logger.debug(\"Update channel {} with {}\", channelId, consumption);\n+        updateState(channelId,\n+                consumption != -1 ? new QuantityType<>(consumption, SmartHomeUnits.KILOWATT_HOUR) : UnDefType.UNDEF);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00bed837d677a440e07ef1e33ff891b470a852bb"}, "originalPosition": 259}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c9d3e3703c0b91732f52dee340cc0b8bc9ed5157", "author": {"user": {"login": "clinique", "name": "Ga\u00ebl L'hopital"}}, "url": "https://github.com/openhab/openhab-addons/commit/c9d3e3703c0b91732f52dee340cc0b8bc9ed5157", "committedDate": "2020-03-21T07:42:56Z", "message": "Switch to Double.NaN and license headers\n\nSigned-off-by: clinique <gael@lhopital.org>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5MTU1OTgz", "url": "https://github.com/openhab/openhab-addons/pull/7101#pullrequestreview-379155983", "createdAt": "2020-03-23T06:21:17Z", "commit": {"oid": "c9d3e3703c0b91732f52dee340cc0b8bc9ed5157"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QwNjoyMToxN1rOF54F6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QwNjo0MzozNVrOF54dCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjIzMjE2OQ==", "bodyText": "Minor correction.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    updateState(channelId, consumption != Double.NaN ? new QuantityType<>(consumption, SmartHomeUnits.KILOWATT_HOUR)\n          \n          \n            \n                    updateState(channelId, !Double.isNaN(consumption) ? new QuantityType<>(consumption, SmartHomeUnits.KILOWATT_HOUR)", "url": "https://github.com/openhab/openhab-addons/pull/7101#discussion_r396232169", "createdAt": "2020-03-23T06:21:17Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.linky/src/main/java/org/openhab/binding/linky/internal/handler/LinkyHandler.java", "diffHunk": "@@ -0,0 +1,387 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.linky.internal.handler;\n+\n+import static org.openhab.binding.linky.internal.LinkyBindingConstants.*;\n+import static org.openhab.binding.linky.internal.model.LinkyTimeScale.*;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.temporal.ChronoUnit;\n+import java.time.temporal.WeekFields;\n+import java.util.Base64;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.i18n.LocaleProvider;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.linky.internal.ExpiringDayCache;\n+import org.openhab.binding.linky.internal.LinkyConfiguration;\n+import org.openhab.binding.linky.internal.model.LinkyConsumptionData;\n+import org.openhab.binding.linky.internal.model.LinkyTimeScale;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+import okhttp3.FormBody;\n+import okhttp3.FormBody.Builder;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.Response;\n+\n+/**\n+ * The {@link LinkyHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ga\u00ebl L'hopital - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class LinkyHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(LinkyHandler.class);\n+\n+    private static final String LOGIN_BASE_URI = \"https://espace-client-connexion.enedis.fr/auth/UI/Login\";\n+    private static final String API_BASE_URI = \"https://espace-client-particuliers.enedis.fr/group/espace-particuliers/suivi-de-consommation\";\n+    private static final DateTimeFormatter API_DATE_FORMAT = DateTimeFormatter.ofPattern(\"dd/MM/yyyy\");\n+    private static final Builder LOGIN_BODY_BUILDER = new FormBody.Builder().add(\"encoded\", \"true\")\n+            .add(\"gx_charset\", \"UTF-8\").add(\"SunQueryParamsString\",\n+                    Base64.getEncoder().encodeToString(\"realm=particuliers\".getBytes(StandardCharsets.UTF_8)));\n+\n+    private static final int REFRESH_FIRST_HOUR_OF_DAY = 5;\n+    private static final int REFRESH_INTERVAL_IN_MIN = 360;\n+\n+    private final OkHttpClient client = new OkHttpClient.Builder().followRedirects(false)\n+            .cookieJar(new LinkyCookieJar()).build();\n+    private final Gson gson = new Gson();\n+\n+    private @NonNullByDefault({}) ScheduledFuture<?> refreshJob;\n+    private final WeekFields weekFields;\n+\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedDaylyData;\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedMonthlyData;\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedYearlyData;\n+\n+    public LinkyHandler(Thing thing, LocaleProvider localeProvider) {\n+        super(thing);\n+        this.weekFields = WeekFields.of(localeProvider.getLocale());\n+        this.cachedDaylyData = new ExpiringDayCache<LinkyConsumptionData>(\"daily cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(DAILY, today.minusDays(13), today, true);\n+                });\n+        this.cachedMonthlyData = new ExpiringDayCache<LinkyConsumptionData>(\"monthly cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(MONTHLY, today.withDayOfMonth(1).minusMonths(1), today, true);\n+                });\n+        this.cachedYearlyData = new ExpiringDayCache<LinkyConsumptionData>(\"yearly cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(YEARLY, LocalDate.of(today.getYear() - 1, 1, 1), today, true);\n+                });\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing Linky handler.\");\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.submit(this::login);\n+\n+        final LocalDateTime now = LocalDateTime.now();\n+        final LocalDateTime nextDayFirstTimeUpdate = now.plusDays(1).withHour(REFRESH_FIRST_HOUR_OF_DAY)\n+                .truncatedTo(ChronoUnit.HOURS);\n+        refreshJob = scheduler.scheduleWithFixedDelay(this::updateData,\n+                ChronoUnit.MINUTES.between(now, nextDayFirstTimeUpdate) % REFRESH_INTERVAL_IN_MIN + 1,\n+                REFRESH_INTERVAL_IN_MIN, TimeUnit.MINUTES);\n+    }\n+\n+    private synchronized boolean login() {\n+        logger.debug(\"login\");\n+\n+        LinkyConfiguration config = getConfigAs(LinkyConfiguration.class);\n+        try {\n+            Request requestLogin = new Request.Builder().url(LOGIN_BASE_URI)\n+                    .post(LOGIN_BODY_BUILDER.add(\"IDToken1\", config.username).add(\"IDToken2\", config.password).build())\n+                    .build();\n+            Response response = client.newCall(requestLogin).execute();\n+            if (response.isRedirect()) {\n+                logger.debug(\"Response status {} {} redirects to {}\", response.code(), response.message(),\n+                        response.header(\"Location\"));\n+            } else {\n+                logger.debug(\"Response status {} {}\", response.code(), response.message());\n+            }\n+            response.close();\n+\n+            // Do a first call to get data; this first call will fail with code 302\n+            getConsumptionData(DAILY, LocalDate.now(), LocalDate.now(), false);\n+            updateStatus(ThingStatus.ONLINE);\n+            return true;\n+        } catch (IOException e) {\n+            logger.debug(\"Exception while trying to login: {}\", e.getMessage(), e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+            return false;\n+        }\n+    }\n+\n+    /**\n+     * Request new data and updates channels\n+     */\n+    private void updateData() {\n+        updateDailyData();\n+        updateMonthlyData();\n+        updateYearlyData();\n+    }\n+\n+    /**\n+     * Request new dayly/weekly data and updates channels\n+     */\n+    private synchronized void updateDailyData() {\n+        if (!isLinked(YESTERDAY) && !isLinked(LAST_WEEK) && !isLinked(THIS_WEEK)) {\n+            return;\n+        }\n+\n+        Double lastWeek = Double.NaN;\n+        Double thisWeek = Double.NaN;\n+        Double yesterday = Double.NaN;\n+        LinkyConsumptionData result = cachedDaylyData.getValue();\n+        if (result != null && result.success()) {\n+            LocalDate rangeStart = LocalDate.now().minusDays(13);\n+            int jump = result.getDecalage();\n+            while (rangeStart.getDayOfWeek() != weekFields.getFirstDayOfWeek()) {\n+                rangeStart = rangeStart.plusDays(1);\n+                jump++;\n+            }\n+\n+            int lastWeekNumber = rangeStart.get(weekFields.weekOfWeekBasedYear());\n+\n+            lastWeek = 0.0;\n+            thisWeek = 0.0;\n+            yesterday = Double.NaN;\n+            while (jump < result.getData().size()) {\n+                double consumption = result.getData().get(jump).valeur;\n+                if (consumption > 0) {\n+                    if (rangeStart.get(weekFields.weekOfWeekBasedYear()) == lastWeekNumber) {\n+                        lastWeek += consumption;\n+                        logger.trace(\"Consumption at index {} added to last week: {}\", jump, consumption);\n+                    } else {\n+                        thisWeek += consumption;\n+                        logger.trace(\"Consumption at index {} added to current week: {}\", jump, consumption);\n+                    }\n+                    yesterday = consumption;\n+                }\n+                jump++;\n+                rangeStart = rangeStart.plusDays(1);\n+            }\n+        } else {\n+            cachedDaylyData.invalidateValue();\n+        }\n+        updateKwhChannel(YESTERDAY, yesterday);\n+        updateKwhChannel(THIS_WEEK, thisWeek);\n+        updateKwhChannel(LAST_WEEK, lastWeek);\n+    }\n+\n+    /**\n+     * Request new monthly data and updates channels\n+     */\n+    private synchronized void updateMonthlyData() {\n+        if (!isLinked(LAST_MONTH) && !isLinked(THIS_MONTH)) {\n+            return;\n+        }\n+\n+        Double lastMonth = Double.NaN;\n+        Double thisMonth = Double.NaN;\n+        LinkyConsumptionData result = cachedMonthlyData.getValue();\n+        if (result != null && result.success()) {\n+            int jump = result.getDecalage();\n+            lastMonth = result.getData().get(jump).valeur;\n+            thisMonth = result.getData().get(jump + 1).valeur;\n+            if (thisMonth < 0) {\n+                thisMonth = 0.0;\n+            }\n+        } else {\n+            cachedMonthlyData.invalidateValue();\n+        }\n+        updateKwhChannel(LAST_MONTH, lastMonth);\n+        updateKwhChannel(THIS_MONTH, thisMonth);\n+    }\n+\n+    /**\n+     * Request new yearly data and updates channels\n+     */\n+    private synchronized void updateYearlyData() {\n+        if (!isLinked(LAST_YEAR) && !isLinked(THIS_YEAR)) {\n+            return;\n+        }\n+\n+        Double thisYear = Double.NaN;\n+        Double lastYear = Double.NaN;\n+        LinkyConsumptionData result = cachedYearlyData.getValue();\n+        if (result != null && result.success()) {\n+            int elementQuantity = result.getData().size();\n+            thisYear = elementQuantity > 0 ? result.getData().get(elementQuantity - 1).valeur : Double.NaN;\n+            lastYear = elementQuantity > 1 ? result.getData().get(elementQuantity - 2).valeur : Double.NaN;\n+        } else {\n+            cachedYearlyData.invalidateValue();\n+        }\n+        updateKwhChannel(LAST_YEAR, lastYear);\n+        updateKwhChannel(THIS_YEAR, thisYear);\n+    }\n+\n+    private void updateKwhChannel(String channelId, Double consumption) {\n+        logger.debug(\"Update channel {} with {}\", channelId, consumption);\n+        updateState(channelId, consumption != Double.NaN ? new QuantityType<>(consumption, SmartHomeUnits.KILOWATT_HOUR)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c9d3e3703c0b91732f52dee340cc0b8bc9ed5157"}, "originalPosition": 258}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjIzMjYyNQ==", "bodyText": "Should this also update the ThingStatus?", "url": "https://github.com/openhab/openhab-addons/pull/7101#discussion_r396232625", "createdAt": "2020-03-23T06:22:57Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.linky/src/main/java/org/openhab/binding/linky/internal/handler/LinkyHandler.java", "diffHunk": "@@ -0,0 +1,387 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.linky.internal.handler;\n+\n+import static org.openhab.binding.linky.internal.LinkyBindingConstants.*;\n+import static org.openhab.binding.linky.internal.model.LinkyTimeScale.*;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.temporal.ChronoUnit;\n+import java.time.temporal.WeekFields;\n+import java.util.Base64;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.i18n.LocaleProvider;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.linky.internal.ExpiringDayCache;\n+import org.openhab.binding.linky.internal.LinkyConfiguration;\n+import org.openhab.binding.linky.internal.model.LinkyConsumptionData;\n+import org.openhab.binding.linky.internal.model.LinkyTimeScale;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+import okhttp3.FormBody;\n+import okhttp3.FormBody.Builder;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.Response;\n+\n+/**\n+ * The {@link LinkyHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ga\u00ebl L'hopital - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class LinkyHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(LinkyHandler.class);\n+\n+    private static final String LOGIN_BASE_URI = \"https://espace-client-connexion.enedis.fr/auth/UI/Login\";\n+    private static final String API_BASE_URI = \"https://espace-client-particuliers.enedis.fr/group/espace-particuliers/suivi-de-consommation\";\n+    private static final DateTimeFormatter API_DATE_FORMAT = DateTimeFormatter.ofPattern(\"dd/MM/yyyy\");\n+    private static final Builder LOGIN_BODY_BUILDER = new FormBody.Builder().add(\"encoded\", \"true\")\n+            .add(\"gx_charset\", \"UTF-8\").add(\"SunQueryParamsString\",\n+                    Base64.getEncoder().encodeToString(\"realm=particuliers\".getBytes(StandardCharsets.UTF_8)));\n+\n+    private static final int REFRESH_FIRST_HOUR_OF_DAY = 5;\n+    private static final int REFRESH_INTERVAL_IN_MIN = 360;\n+\n+    private final OkHttpClient client = new OkHttpClient.Builder().followRedirects(false)\n+            .cookieJar(new LinkyCookieJar()).build();\n+    private final Gson gson = new Gson();\n+\n+    private @NonNullByDefault({}) ScheduledFuture<?> refreshJob;\n+    private final WeekFields weekFields;\n+\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedDaylyData;\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedMonthlyData;\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedYearlyData;\n+\n+    public LinkyHandler(Thing thing, LocaleProvider localeProvider) {\n+        super(thing);\n+        this.weekFields = WeekFields.of(localeProvider.getLocale());\n+        this.cachedDaylyData = new ExpiringDayCache<LinkyConsumptionData>(\"daily cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(DAILY, today.minusDays(13), today, true);\n+                });\n+        this.cachedMonthlyData = new ExpiringDayCache<LinkyConsumptionData>(\"monthly cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(MONTHLY, today.withDayOfMonth(1).minusMonths(1), today, true);\n+                });\n+        this.cachedYearlyData = new ExpiringDayCache<LinkyConsumptionData>(\"yearly cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(YEARLY, LocalDate.of(today.getYear() - 1, 1, 1), today, true);\n+                });\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing Linky handler.\");\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.submit(this::login);\n+\n+        final LocalDateTime now = LocalDateTime.now();\n+        final LocalDateTime nextDayFirstTimeUpdate = now.plusDays(1).withHour(REFRESH_FIRST_HOUR_OF_DAY)\n+                .truncatedTo(ChronoUnit.HOURS);\n+        refreshJob = scheduler.scheduleWithFixedDelay(this::updateData,\n+                ChronoUnit.MINUTES.between(now, nextDayFirstTimeUpdate) % REFRESH_INTERVAL_IN_MIN + 1,\n+                REFRESH_INTERVAL_IN_MIN, TimeUnit.MINUTES);\n+    }\n+\n+    private synchronized boolean login() {\n+        logger.debug(\"login\");\n+\n+        LinkyConfiguration config = getConfigAs(LinkyConfiguration.class);\n+        try {\n+            Request requestLogin = new Request.Builder().url(LOGIN_BASE_URI)\n+                    .post(LOGIN_BODY_BUILDER.add(\"IDToken1\", config.username).add(\"IDToken2\", config.password).build())\n+                    .build();\n+            Response response = client.newCall(requestLogin).execute();\n+            if (response.isRedirect()) {\n+                logger.debug(\"Response status {} {} redirects to {}\", response.code(), response.message(),\n+                        response.header(\"Location\"));\n+            } else {\n+                logger.debug(\"Response status {} {}\", response.code(), response.message());\n+            }\n+            response.close();\n+\n+            // Do a first call to get data; this first call will fail with code 302\n+            getConsumptionData(DAILY, LocalDate.now(), LocalDate.now(), false);\n+            updateStatus(ThingStatus.ONLINE);\n+            return true;\n+        } catch (IOException e) {\n+            logger.debug(\"Exception while trying to login: {}\", e.getMessage(), e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+            return false;\n+        }\n+    }\n+\n+    /**\n+     * Request new data and updates channels\n+     */\n+    private void updateData() {\n+        updateDailyData();\n+        updateMonthlyData();\n+        updateYearlyData();\n+    }\n+\n+    /**\n+     * Request new dayly/weekly data and updates channels\n+     */\n+    private synchronized void updateDailyData() {\n+        if (!isLinked(YESTERDAY) && !isLinked(LAST_WEEK) && !isLinked(THIS_WEEK)) {\n+            return;\n+        }\n+\n+        Double lastWeek = Double.NaN;\n+        Double thisWeek = Double.NaN;\n+        Double yesterday = Double.NaN;\n+        LinkyConsumptionData result = cachedDaylyData.getValue();\n+        if (result != null && result.success()) {\n+            LocalDate rangeStart = LocalDate.now().minusDays(13);\n+            int jump = result.getDecalage();\n+            while (rangeStart.getDayOfWeek() != weekFields.getFirstDayOfWeek()) {\n+                rangeStart = rangeStart.plusDays(1);\n+                jump++;\n+            }\n+\n+            int lastWeekNumber = rangeStart.get(weekFields.weekOfWeekBasedYear());\n+\n+            lastWeek = 0.0;\n+            thisWeek = 0.0;\n+            yesterday = Double.NaN;\n+            while (jump < result.getData().size()) {\n+                double consumption = result.getData().get(jump).valeur;\n+                if (consumption > 0) {\n+                    if (rangeStart.get(weekFields.weekOfWeekBasedYear()) == lastWeekNumber) {\n+                        lastWeek += consumption;\n+                        logger.trace(\"Consumption at index {} added to last week: {}\", jump, consumption);\n+                    } else {\n+                        thisWeek += consumption;\n+                        logger.trace(\"Consumption at index {} added to current week: {}\", jump, consumption);\n+                    }\n+                    yesterday = consumption;\n+                }\n+                jump++;\n+                rangeStart = rangeStart.plusDays(1);\n+            }\n+        } else {\n+            cachedDaylyData.invalidateValue();\n+        }\n+        updateKwhChannel(YESTERDAY, yesterday);\n+        updateKwhChannel(THIS_WEEK, thisWeek);\n+        updateKwhChannel(LAST_WEEK, lastWeek);\n+    }\n+\n+    /**\n+     * Request new monthly data and updates channels\n+     */\n+    private synchronized void updateMonthlyData() {\n+        if (!isLinked(LAST_MONTH) && !isLinked(THIS_MONTH)) {\n+            return;\n+        }\n+\n+        Double lastMonth = Double.NaN;\n+        Double thisMonth = Double.NaN;\n+        LinkyConsumptionData result = cachedMonthlyData.getValue();\n+        if (result != null && result.success()) {\n+            int jump = result.getDecalage();\n+            lastMonth = result.getData().get(jump).valeur;\n+            thisMonth = result.getData().get(jump + 1).valeur;\n+            if (thisMonth < 0) {\n+                thisMonth = 0.0;\n+            }\n+        } else {\n+            cachedMonthlyData.invalidateValue();\n+        }\n+        updateKwhChannel(LAST_MONTH, lastMonth);\n+        updateKwhChannel(THIS_MONTH, thisMonth);\n+    }\n+\n+    /**\n+     * Request new yearly data and updates channels\n+     */\n+    private synchronized void updateYearlyData() {\n+        if (!isLinked(LAST_YEAR) && !isLinked(THIS_YEAR)) {\n+            return;\n+        }\n+\n+        Double thisYear = Double.NaN;\n+        Double lastYear = Double.NaN;\n+        LinkyConsumptionData result = cachedYearlyData.getValue();\n+        if (result != null && result.success()) {\n+            int elementQuantity = result.getData().size();\n+            thisYear = elementQuantity > 0 ? result.getData().get(elementQuantity - 1).valeur : Double.NaN;\n+            lastYear = elementQuantity > 1 ? result.getData().get(elementQuantity - 2).valeur : Double.NaN;\n+        } else {\n+            cachedYearlyData.invalidateValue();\n+        }\n+        updateKwhChannel(LAST_YEAR, lastYear);\n+        updateKwhChannel(THIS_YEAR, thisYear);\n+    }\n+\n+    private void updateKwhChannel(String channelId, Double consumption) {\n+        logger.debug(\"Update channel {} with {}\", channelId, consumption);\n+        updateState(channelId, consumption != Double.NaN ? new QuantityType<>(consumption, SmartHomeUnits.KILOWATT_HOUR)\n+                : UnDefType.UNDEF);\n+    }\n+\n+    /**\n+     * Produce a report of all daily values between two dates\n+     *\n+     * @param startDay the start day of the report\n+     * @param endDay the end day of the report\n+     * @param separator the separator to be used betwwen the date and the value\n+     *\n+     * @return the report as a string\n+     */\n+    public String reportValues(LocalDate startDay, LocalDate endDay, @Nullable String separator) {\n+        StringBuilder dump = new StringBuilder();\n+        if (startDay.getYear() == endDay.getYear() && startDay.getMonthValue() == endDay.getMonthValue()) {\n+            // All values in the same month\n+            LinkyConsumptionData result = getConsumptionData(DAILY, startDay, endDay, true);\n+            if (result != null && result.success()) {\n+                LocalDate currentDay = startDay;\n+                int jump = result.getDecalage();\n+                while (jump < result.getData().size() && !currentDay.isAfter(endDay)) {\n+                    double consumption = result.getData().get(jump).valeur;\n+                    dump.append(currentDay.format(DateTimeFormatter.ISO_LOCAL_DATE) + separator);\n+                    if (consumption >= 0) {\n+                        dump.append(String.valueOf(consumption));\n+                    }\n+                    dump.append(\"\\n\");\n+                    jump++;\n+                    currentDay = currentDay.plusDays(1);\n+                }\n+            } else {\n+                LocalDate currentDay = startDay;\n+                while (!currentDay.isAfter(endDay)) {\n+                    dump.append(currentDay.format(DateTimeFormatter.ISO_LOCAL_DATE) + separator + \"\\n\");\n+                    currentDay = currentDay.plusDays(1);\n+                }\n+            }\n+        } else {\n+            // Concatenate the report produced for each month between the two dates\n+            LocalDate first = startDay;\n+            do {\n+                LocalDate last = first.withDayOfMonth(first.lengthOfMonth());\n+                if (last.isAfter(endDay)) {\n+                    last = endDay;\n+                }\n+                dump.append(reportValues(first, last, separator));\n+                first = last.plusDays(1);\n+            } while (!first.isAfter(endDay));\n+        }\n+        return dump.toString();\n+    }\n+\n+    private @Nullable LinkyConsumptionData getConsumptionData(LinkyTimeScale timeScale, LocalDate from, LocalDate to,\n+            boolean reLog) {\n+        logger.debug(\"getConsumptionData {}\", timeScale);\n+\n+        LinkyConsumptionData result = null;\n+        boolean tryRelog = false;\n+\n+        FormBody formBody = new FormBody.Builder().add(\"p_p_id\", \"lincspartdisplaycdc_WAR_lincspartcdcportlet\")\n+                .add(\"p_p_lifecycle\", \"2\").add(\"p_p_resource_id\", timeScale.getId())\n+                .add(\"_lincspartdisplaycdc_WAR_lincspartcdcportlet_dateDebut\", from.format(API_DATE_FORMAT))\n+                .add(\"_lincspartdisplaycdc_WAR_lincspartcdcportlet_dateFin\", to.format(API_DATE_FORMAT)).build();\n+\n+        Request requestData = new Request.Builder().url(API_BASE_URI).post(formBody).build();\n+        try (Response response = client.newCall(requestData).execute()) {\n+            if (response.isRedirect()) {\n+                String location = response.header(\"Location\");\n+                logger.debug(\"Response status {} {} redirects to {}\", response.code(), response.message(), location);\n+                if (reLog && location != null && location.startsWith(LOGIN_BASE_URI)) {\n+                    tryRelog = true;\n+                }\n+            } else {\n+                String body = (response.body() != null) ? response.body().string() : null;\n+                logger.debug(\"Response status {} {} : {}\", response.code(), response.message(), body);\n+                if (body != null && !body.isEmpty()) {\n+                    result = gson.fromJson(body, LinkyConsumptionData.class);\n+                }\n+            }\n+            response.close();\n+        } catch (IOException e) {\n+            logger.debug(\"Exception calling API : {} - {}\", e.getClass().getCanonicalName(), e.getMessage());\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, e.getMessage());\n+        } catch (JsonSyntaxException e) {\n+            logger.debug(\"Exception while converting JSON response : {}\", e.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c9d3e3703c0b91732f52dee340cc0b8bc9ed5157"}, "originalPosition": 343}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjIzNDM4NA==", "bodyText": "Since Response implements Closable please wrap this in a try-with-resources.", "url": "https://github.com/openhab/openhab-addons/pull/7101#discussion_r396234384", "createdAt": "2020-03-23T06:29:53Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.linky/src/main/java/org/openhab/binding/linky/internal/handler/LinkyHandler.java", "diffHunk": "@@ -0,0 +1,387 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.linky.internal.handler;\n+\n+import static org.openhab.binding.linky.internal.LinkyBindingConstants.*;\n+import static org.openhab.binding.linky.internal.model.LinkyTimeScale.*;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.temporal.ChronoUnit;\n+import java.time.temporal.WeekFields;\n+import java.util.Base64;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.i18n.LocaleProvider;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.linky.internal.ExpiringDayCache;\n+import org.openhab.binding.linky.internal.LinkyConfiguration;\n+import org.openhab.binding.linky.internal.model.LinkyConsumptionData;\n+import org.openhab.binding.linky.internal.model.LinkyTimeScale;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+import okhttp3.FormBody;\n+import okhttp3.FormBody.Builder;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.Response;\n+\n+/**\n+ * The {@link LinkyHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ga\u00ebl L'hopital - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class LinkyHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(LinkyHandler.class);\n+\n+    private static final String LOGIN_BASE_URI = \"https://espace-client-connexion.enedis.fr/auth/UI/Login\";\n+    private static final String API_BASE_URI = \"https://espace-client-particuliers.enedis.fr/group/espace-particuliers/suivi-de-consommation\";\n+    private static final DateTimeFormatter API_DATE_FORMAT = DateTimeFormatter.ofPattern(\"dd/MM/yyyy\");\n+    private static final Builder LOGIN_BODY_BUILDER = new FormBody.Builder().add(\"encoded\", \"true\")\n+            .add(\"gx_charset\", \"UTF-8\").add(\"SunQueryParamsString\",\n+                    Base64.getEncoder().encodeToString(\"realm=particuliers\".getBytes(StandardCharsets.UTF_8)));\n+\n+    private static final int REFRESH_FIRST_HOUR_OF_DAY = 5;\n+    private static final int REFRESH_INTERVAL_IN_MIN = 360;\n+\n+    private final OkHttpClient client = new OkHttpClient.Builder().followRedirects(false)\n+            .cookieJar(new LinkyCookieJar()).build();\n+    private final Gson gson = new Gson();\n+\n+    private @NonNullByDefault({}) ScheduledFuture<?> refreshJob;\n+    private final WeekFields weekFields;\n+\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedDaylyData;\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedMonthlyData;\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedYearlyData;\n+\n+    public LinkyHandler(Thing thing, LocaleProvider localeProvider) {\n+        super(thing);\n+        this.weekFields = WeekFields.of(localeProvider.getLocale());\n+        this.cachedDaylyData = new ExpiringDayCache<LinkyConsumptionData>(\"daily cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(DAILY, today.minusDays(13), today, true);\n+                });\n+        this.cachedMonthlyData = new ExpiringDayCache<LinkyConsumptionData>(\"monthly cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(MONTHLY, today.withDayOfMonth(1).minusMonths(1), today, true);\n+                });\n+        this.cachedYearlyData = new ExpiringDayCache<LinkyConsumptionData>(\"yearly cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(YEARLY, LocalDate.of(today.getYear() - 1, 1, 1), today, true);\n+                });\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing Linky handler.\");\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.submit(this::login);\n+\n+        final LocalDateTime now = LocalDateTime.now();\n+        final LocalDateTime nextDayFirstTimeUpdate = now.plusDays(1).withHour(REFRESH_FIRST_HOUR_OF_DAY)\n+                .truncatedTo(ChronoUnit.HOURS);\n+        refreshJob = scheduler.scheduleWithFixedDelay(this::updateData,\n+                ChronoUnit.MINUTES.between(now, nextDayFirstTimeUpdate) % REFRESH_INTERVAL_IN_MIN + 1,\n+                REFRESH_INTERVAL_IN_MIN, TimeUnit.MINUTES);\n+    }\n+\n+    private synchronized boolean login() {\n+        logger.debug(\"login\");\n+\n+        LinkyConfiguration config = getConfigAs(LinkyConfiguration.class);\n+        try {\n+            Request requestLogin = new Request.Builder().url(LOGIN_BASE_URI)\n+                    .post(LOGIN_BODY_BUILDER.add(\"IDToken1\", config.username).add(\"IDToken2\", config.password).build())\n+                    .build();\n+            Response response = client.newCall(requestLogin).execute();\n+            if (response.isRedirect()) {\n+                logger.debug(\"Response status {} {} redirects to {}\", response.code(), response.message(),\n+                        response.header(\"Location\"));\n+            } else {\n+                logger.debug(\"Response status {} {}\", response.code(), response.message());\n+            }\n+            response.close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c9d3e3703c0b91732f52dee340cc0b8bc9ed5157"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjIzODA5MA==", "bodyText": "From what I can tell, the only caller of this method splits apart the returned string into each line. Why can't this method just return a List<String>? Seems kinda strange to add in a bunch of newline characters only for callers of the method to immediately remove them.\nIt would be more efficient to pass in the List as a parameter so it can be used on recursive calls.\nWDYT?", "url": "https://github.com/openhab/openhab-addons/pull/7101#discussion_r396238090", "createdAt": "2020-03-23T06:43:35Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.linky/src/main/java/org/openhab/binding/linky/internal/handler/LinkyHandler.java", "diffHunk": "@@ -0,0 +1,387 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.linky.internal.handler;\n+\n+import static org.openhab.binding.linky.internal.LinkyBindingConstants.*;\n+import static org.openhab.binding.linky.internal.model.LinkyTimeScale.*;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.temporal.ChronoUnit;\n+import java.time.temporal.WeekFields;\n+import java.util.Base64;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.i18n.LocaleProvider;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.linky.internal.ExpiringDayCache;\n+import org.openhab.binding.linky.internal.LinkyConfiguration;\n+import org.openhab.binding.linky.internal.model.LinkyConsumptionData;\n+import org.openhab.binding.linky.internal.model.LinkyTimeScale;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+import okhttp3.FormBody;\n+import okhttp3.FormBody.Builder;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.Response;\n+\n+/**\n+ * The {@link LinkyHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ga\u00ebl L'hopital - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class LinkyHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(LinkyHandler.class);\n+\n+    private static final String LOGIN_BASE_URI = \"https://espace-client-connexion.enedis.fr/auth/UI/Login\";\n+    private static final String API_BASE_URI = \"https://espace-client-particuliers.enedis.fr/group/espace-particuliers/suivi-de-consommation\";\n+    private static final DateTimeFormatter API_DATE_FORMAT = DateTimeFormatter.ofPattern(\"dd/MM/yyyy\");\n+    private static final Builder LOGIN_BODY_BUILDER = new FormBody.Builder().add(\"encoded\", \"true\")\n+            .add(\"gx_charset\", \"UTF-8\").add(\"SunQueryParamsString\",\n+                    Base64.getEncoder().encodeToString(\"realm=particuliers\".getBytes(StandardCharsets.UTF_8)));\n+\n+    private static final int REFRESH_FIRST_HOUR_OF_DAY = 5;\n+    private static final int REFRESH_INTERVAL_IN_MIN = 360;\n+\n+    private final OkHttpClient client = new OkHttpClient.Builder().followRedirects(false)\n+            .cookieJar(new LinkyCookieJar()).build();\n+    private final Gson gson = new Gson();\n+\n+    private @NonNullByDefault({}) ScheduledFuture<?> refreshJob;\n+    private final WeekFields weekFields;\n+\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedDaylyData;\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedMonthlyData;\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedYearlyData;\n+\n+    public LinkyHandler(Thing thing, LocaleProvider localeProvider) {\n+        super(thing);\n+        this.weekFields = WeekFields.of(localeProvider.getLocale());\n+        this.cachedDaylyData = new ExpiringDayCache<LinkyConsumptionData>(\"daily cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(DAILY, today.minusDays(13), today, true);\n+                });\n+        this.cachedMonthlyData = new ExpiringDayCache<LinkyConsumptionData>(\"monthly cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(MONTHLY, today.withDayOfMonth(1).minusMonths(1), today, true);\n+                });\n+        this.cachedYearlyData = new ExpiringDayCache<LinkyConsumptionData>(\"yearly cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(YEARLY, LocalDate.of(today.getYear() - 1, 1, 1), today, true);\n+                });\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing Linky handler.\");\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.submit(this::login);\n+\n+        final LocalDateTime now = LocalDateTime.now();\n+        final LocalDateTime nextDayFirstTimeUpdate = now.plusDays(1).withHour(REFRESH_FIRST_HOUR_OF_DAY)\n+                .truncatedTo(ChronoUnit.HOURS);\n+        refreshJob = scheduler.scheduleWithFixedDelay(this::updateData,\n+                ChronoUnit.MINUTES.between(now, nextDayFirstTimeUpdate) % REFRESH_INTERVAL_IN_MIN + 1,\n+                REFRESH_INTERVAL_IN_MIN, TimeUnit.MINUTES);\n+    }\n+\n+    private synchronized boolean login() {\n+        logger.debug(\"login\");\n+\n+        LinkyConfiguration config = getConfigAs(LinkyConfiguration.class);\n+        try {\n+            Request requestLogin = new Request.Builder().url(LOGIN_BASE_URI)\n+                    .post(LOGIN_BODY_BUILDER.add(\"IDToken1\", config.username).add(\"IDToken2\", config.password).build())\n+                    .build();\n+            Response response = client.newCall(requestLogin).execute();\n+            if (response.isRedirect()) {\n+                logger.debug(\"Response status {} {} redirects to {}\", response.code(), response.message(),\n+                        response.header(\"Location\"));\n+            } else {\n+                logger.debug(\"Response status {} {}\", response.code(), response.message());\n+            }\n+            response.close();\n+\n+            // Do a first call to get data; this first call will fail with code 302\n+            getConsumptionData(DAILY, LocalDate.now(), LocalDate.now(), false);\n+            updateStatus(ThingStatus.ONLINE);\n+            return true;\n+        } catch (IOException e) {\n+            logger.debug(\"Exception while trying to login: {}\", e.getMessage(), e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+            return false;\n+        }\n+    }\n+\n+    /**\n+     * Request new data and updates channels\n+     */\n+    private void updateData() {\n+        updateDailyData();\n+        updateMonthlyData();\n+        updateYearlyData();\n+    }\n+\n+    /**\n+     * Request new dayly/weekly data and updates channels\n+     */\n+    private synchronized void updateDailyData() {\n+        if (!isLinked(YESTERDAY) && !isLinked(LAST_WEEK) && !isLinked(THIS_WEEK)) {\n+            return;\n+        }\n+\n+        Double lastWeek = Double.NaN;\n+        Double thisWeek = Double.NaN;\n+        Double yesterday = Double.NaN;\n+        LinkyConsumptionData result = cachedDaylyData.getValue();\n+        if (result != null && result.success()) {\n+            LocalDate rangeStart = LocalDate.now().minusDays(13);\n+            int jump = result.getDecalage();\n+            while (rangeStart.getDayOfWeek() != weekFields.getFirstDayOfWeek()) {\n+                rangeStart = rangeStart.plusDays(1);\n+                jump++;\n+            }\n+\n+            int lastWeekNumber = rangeStart.get(weekFields.weekOfWeekBasedYear());\n+\n+            lastWeek = 0.0;\n+            thisWeek = 0.0;\n+            yesterday = Double.NaN;\n+            while (jump < result.getData().size()) {\n+                double consumption = result.getData().get(jump).valeur;\n+                if (consumption > 0) {\n+                    if (rangeStart.get(weekFields.weekOfWeekBasedYear()) == lastWeekNumber) {\n+                        lastWeek += consumption;\n+                        logger.trace(\"Consumption at index {} added to last week: {}\", jump, consumption);\n+                    } else {\n+                        thisWeek += consumption;\n+                        logger.trace(\"Consumption at index {} added to current week: {}\", jump, consumption);\n+                    }\n+                    yesterday = consumption;\n+                }\n+                jump++;\n+                rangeStart = rangeStart.plusDays(1);\n+            }\n+        } else {\n+            cachedDaylyData.invalidateValue();\n+        }\n+        updateKwhChannel(YESTERDAY, yesterday);\n+        updateKwhChannel(THIS_WEEK, thisWeek);\n+        updateKwhChannel(LAST_WEEK, lastWeek);\n+    }\n+\n+    /**\n+     * Request new monthly data and updates channels\n+     */\n+    private synchronized void updateMonthlyData() {\n+        if (!isLinked(LAST_MONTH) && !isLinked(THIS_MONTH)) {\n+            return;\n+        }\n+\n+        Double lastMonth = Double.NaN;\n+        Double thisMonth = Double.NaN;\n+        LinkyConsumptionData result = cachedMonthlyData.getValue();\n+        if (result != null && result.success()) {\n+            int jump = result.getDecalage();\n+            lastMonth = result.getData().get(jump).valeur;\n+            thisMonth = result.getData().get(jump + 1).valeur;\n+            if (thisMonth < 0) {\n+                thisMonth = 0.0;\n+            }\n+        } else {\n+            cachedMonthlyData.invalidateValue();\n+        }\n+        updateKwhChannel(LAST_MONTH, lastMonth);\n+        updateKwhChannel(THIS_MONTH, thisMonth);\n+    }\n+\n+    /**\n+     * Request new yearly data and updates channels\n+     */\n+    private synchronized void updateYearlyData() {\n+        if (!isLinked(LAST_YEAR) && !isLinked(THIS_YEAR)) {\n+            return;\n+        }\n+\n+        Double thisYear = Double.NaN;\n+        Double lastYear = Double.NaN;\n+        LinkyConsumptionData result = cachedYearlyData.getValue();\n+        if (result != null && result.success()) {\n+            int elementQuantity = result.getData().size();\n+            thisYear = elementQuantity > 0 ? result.getData().get(elementQuantity - 1).valeur : Double.NaN;\n+            lastYear = elementQuantity > 1 ? result.getData().get(elementQuantity - 2).valeur : Double.NaN;\n+        } else {\n+            cachedYearlyData.invalidateValue();\n+        }\n+        updateKwhChannel(LAST_YEAR, lastYear);\n+        updateKwhChannel(THIS_YEAR, thisYear);\n+    }\n+\n+    private void updateKwhChannel(String channelId, Double consumption) {\n+        logger.debug(\"Update channel {} with {}\", channelId, consumption);\n+        updateState(channelId, consumption != Double.NaN ? new QuantityType<>(consumption, SmartHomeUnits.KILOWATT_HOUR)\n+                : UnDefType.UNDEF);\n+    }\n+\n+    /**\n+     * Produce a report of all daily values between two dates\n+     *\n+     * @param startDay the start day of the report\n+     * @param endDay the end day of the report\n+     * @param separator the separator to be used betwwen the date and the value\n+     *\n+     * @return the report as a string\n+     */\n+    public String reportValues(LocalDate startDay, LocalDate endDay, @Nullable String separator) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c9d3e3703c0b91732f52dee340cc0b8bc9ed5157"}, "originalPosition": 271}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2f9ef7e5bfe5d91b0edf7eafa97d17a325709a72", "author": {"user": {"login": "clinique", "name": "Ga\u00ebl L'hopital"}}, "url": "https://github.com/openhab/openhab-addons/commit/2f9ef7e5bfe5d91b0edf7eafa97d17a325709a72", "committedDate": "2020-03-23T07:29:14Z", "message": "Code review corrections\n\nSigned-off-by: clinique <gael@lhopital.org>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5NTY5Mzg2", "url": "https://github.com/openhab/openhab-addons/pull/7101#pullrequestreview-379569386", "createdAt": "2020-03-23T15:56:28Z", "commit": {"oid": "2f9ef7e5bfe5d91b0edf7eafa97d17a325709a72"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxNTo1NjoyOVrOF6MF-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yM1QxNTo1ODo1MFrOF6MNdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU1OTg2NQ==", "bodyText": "Just for fun.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            handler.reportValues(start, end, separator).forEach(line -> console.println(line));\n          \n          \n            \n                            handler.reportValues(start, end, separator).forEach(console::println);", "url": "https://github.com/openhab/openhab-addons/pull/7101#discussion_r396559865", "createdAt": "2020-03-23T15:56:29Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.linky/src/main/java/org/openhab/binding/linky/internal/console/LinkyCommandExtension.java", "diffHunk": "@@ -101,9 +101,7 @@ public void execute(String[] args, Console console) {\n                 if (args.length >= 5) {\n                     separator = args[4];\n                 }\n-                for (String line : handler.reportValues(start, end, separator).split(\"\\n\")) {\n-                    console.println(line);\n-                }\n+                handler.reportValues(start, end, separator).forEach(line -> console.println(line));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f9ef7e5bfe5d91b0edf7eafa97d17a325709a72"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU2MDU1Mw==", "bodyText": "This can be omitted since try-with-resources handles this for you.", "url": "https://github.com/openhab/openhab-addons/pull/7101#discussion_r396560553", "createdAt": "2020-03-23T15:57:20Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.linky/src/main/java/org/openhab/binding/linky/internal/handler/LinkyHandler.java", "diffHunk": "@@ -0,0 +1,390 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.linky.internal.handler;\n+\n+import static org.openhab.binding.linky.internal.LinkyBindingConstants.*;\n+import static org.openhab.binding.linky.internal.model.LinkyTimeScale.*;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.temporal.ChronoUnit;\n+import java.time.temporal.WeekFields;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.i18n.LocaleProvider;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.linky.internal.ExpiringDayCache;\n+import org.openhab.binding.linky.internal.LinkyConfiguration;\n+import org.openhab.binding.linky.internal.model.LinkyConsumptionData;\n+import org.openhab.binding.linky.internal.model.LinkyTimeScale;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+import okhttp3.FormBody;\n+import okhttp3.FormBody.Builder;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.Response;\n+\n+/**\n+ * The {@link LinkyHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ga\u00ebl L'hopital - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class LinkyHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(LinkyHandler.class);\n+\n+    private static final String LOGIN_BASE_URI = \"https://espace-client-connexion.enedis.fr/auth/UI/Login\";\n+    private static final String API_BASE_URI = \"https://espace-client-particuliers.enedis.fr/group/espace-particuliers/suivi-de-consommation\";\n+    private static final DateTimeFormatter API_DATE_FORMAT = DateTimeFormatter.ofPattern(\"dd/MM/yyyy\");\n+    private static final Builder LOGIN_BODY_BUILDER = new FormBody.Builder().add(\"encoded\", \"true\")\n+            .add(\"gx_charset\", \"UTF-8\").add(\"SunQueryParamsString\",\n+                    Base64.getEncoder().encodeToString(\"realm=particuliers\".getBytes(StandardCharsets.UTF_8)));\n+\n+    private static final int REFRESH_FIRST_HOUR_OF_DAY = 5;\n+    private static final int REFRESH_INTERVAL_IN_MIN = 360;\n+\n+    private final OkHttpClient client = new OkHttpClient.Builder().followRedirects(false)\n+            .cookieJar(new LinkyCookieJar()).build();\n+    private final Gson gson = new Gson();\n+\n+    private @NonNullByDefault({}) ScheduledFuture<?> refreshJob;\n+    private final WeekFields weekFields;\n+\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedDaylyData;\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedMonthlyData;\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedYearlyData;\n+\n+    public LinkyHandler(Thing thing, LocaleProvider localeProvider) {\n+        super(thing);\n+        this.weekFields = WeekFields.of(localeProvider.getLocale());\n+        this.cachedDaylyData = new ExpiringDayCache<LinkyConsumptionData>(\"daily cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(DAILY, today.minusDays(13), today, true);\n+                });\n+        this.cachedMonthlyData = new ExpiringDayCache<LinkyConsumptionData>(\"monthly cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(MONTHLY, today.withDayOfMonth(1).minusMonths(1), today, true);\n+                });\n+        this.cachedYearlyData = new ExpiringDayCache<LinkyConsumptionData>(\"yearly cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(YEARLY, LocalDate.of(today.getYear() - 1, 1, 1), today, true);\n+                });\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing Linky handler.\");\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.submit(this::login);\n+\n+        final LocalDateTime now = LocalDateTime.now();\n+        final LocalDateTime nextDayFirstTimeUpdate = now.plusDays(1).withHour(REFRESH_FIRST_HOUR_OF_DAY)\n+                .truncatedTo(ChronoUnit.HOURS);\n+        refreshJob = scheduler.scheduleWithFixedDelay(this::updateData,\n+                ChronoUnit.MINUTES.between(now, nextDayFirstTimeUpdate) % REFRESH_INTERVAL_IN_MIN + 1,\n+                REFRESH_INTERVAL_IN_MIN, TimeUnit.MINUTES);\n+    }\n+\n+    private synchronized boolean login() {\n+        logger.debug(\"login\");\n+\n+        LinkyConfiguration config = getConfigAs(LinkyConfiguration.class);\n+        Request requestLogin = new Request.Builder().url(LOGIN_BASE_URI)\n+                .post(LOGIN_BODY_BUILDER.add(\"IDToken1\", config.username).add(\"IDToken2\", config.password).build())\n+                .build();\n+        try (Response response = client.newCall(requestLogin).execute()) {\n+            if (response.isRedirect()) {\n+                logger.debug(\"Response status {} {} redirects to {}\", response.code(), response.message(),\n+                        response.header(\"Location\"));\n+            } else {\n+                logger.debug(\"Response status {} {}\", response.code(), response.message());\n+            }\n+            response.close();\n+\n+            // Do a first call to get data; this first call will fail with code 302\n+            getConsumptionData(DAILY, LocalDate.now(), LocalDate.now(), false);\n+            updateStatus(ThingStatus.ONLINE);\n+            return true;\n+        } catch (IOException e) {\n+            logger.debug(\"Exception while trying to login: {}\", e.getMessage(), e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+            return false;\n+        }\n+    }\n+\n+    /**\n+     * Request new data and updates channels\n+     */\n+    private void updateData() {\n+        updateDailyData();\n+        updateMonthlyData();\n+        updateYearlyData();\n+    }\n+\n+    /**\n+     * Request new dayly/weekly data and updates channels\n+     */\n+    private synchronized void updateDailyData() {\n+        if (!isLinked(YESTERDAY) && !isLinked(LAST_WEEK) && !isLinked(THIS_WEEK)) {\n+            return;\n+        }\n+\n+        Double lastWeek = Double.NaN;\n+        Double thisWeek = Double.NaN;\n+        Double yesterday = Double.NaN;\n+        LinkyConsumptionData result = cachedDaylyData.getValue();\n+        if (result != null && result.success()) {\n+            LocalDate rangeStart = LocalDate.now().minusDays(13);\n+            int jump = result.getDecalage();\n+            while (rangeStart.getDayOfWeek() != weekFields.getFirstDayOfWeek()) {\n+                rangeStart = rangeStart.plusDays(1);\n+                jump++;\n+            }\n+\n+            int lastWeekNumber = rangeStart.get(weekFields.weekOfWeekBasedYear());\n+\n+            lastWeek = 0.0;\n+            thisWeek = 0.0;\n+            yesterday = Double.NaN;\n+            while (jump < result.getData().size()) {\n+                double consumption = result.getData().get(jump).valeur;\n+                if (consumption > 0) {\n+                    if (rangeStart.get(weekFields.weekOfWeekBasedYear()) == lastWeekNumber) {\n+                        lastWeek += consumption;\n+                        logger.trace(\"Consumption at index {} added to last week: {}\", jump, consumption);\n+                    } else {\n+                        thisWeek += consumption;\n+                        logger.trace(\"Consumption at index {} added to current week: {}\", jump, consumption);\n+                    }\n+                    yesterday = consumption;\n+                }\n+                jump++;\n+                rangeStart = rangeStart.plusDays(1);\n+            }\n+        } else {\n+            cachedDaylyData.invalidateValue();\n+        }\n+        updateKwhChannel(YESTERDAY, yesterday);\n+        updateKwhChannel(THIS_WEEK, thisWeek);\n+        updateKwhChannel(LAST_WEEK, lastWeek);\n+    }\n+\n+    /**\n+     * Request new monthly data and updates channels\n+     */\n+    private synchronized void updateMonthlyData() {\n+        if (!isLinked(LAST_MONTH) && !isLinked(THIS_MONTH)) {\n+            return;\n+        }\n+\n+        Double lastMonth = Double.NaN;\n+        Double thisMonth = Double.NaN;\n+        LinkyConsumptionData result = cachedMonthlyData.getValue();\n+        if (result != null && result.success()) {\n+            int jump = result.getDecalage();\n+            lastMonth = result.getData().get(jump).valeur;\n+            thisMonth = result.getData().get(jump + 1).valeur;\n+            if (thisMonth < 0) {\n+                thisMonth = 0.0;\n+            }\n+        } else {\n+            cachedMonthlyData.invalidateValue();\n+        }\n+        updateKwhChannel(LAST_MONTH, lastMonth);\n+        updateKwhChannel(THIS_MONTH, thisMonth);\n+    }\n+\n+    /**\n+     * Request new yearly data and updates channels\n+     */\n+    private synchronized void updateYearlyData() {\n+        if (!isLinked(LAST_YEAR) && !isLinked(THIS_YEAR)) {\n+            return;\n+        }\n+\n+        Double thisYear = Double.NaN;\n+        Double lastYear = Double.NaN;\n+        LinkyConsumptionData result = cachedYearlyData.getValue();\n+        if (result != null && result.success()) {\n+            int elementQuantity = result.getData().size();\n+            thisYear = elementQuantity > 0 ? result.getData().get(elementQuantity - 1).valeur : Double.NaN;\n+            lastYear = elementQuantity > 1 ? result.getData().get(elementQuantity - 2).valeur : Double.NaN;\n+        } else {\n+            cachedYearlyData.invalidateValue();\n+        }\n+        updateKwhChannel(LAST_YEAR, lastYear);\n+        updateKwhChannel(THIS_YEAR, thisYear);\n+    }\n+\n+    private void updateKwhChannel(String channelId, Double consumption) {\n+        logger.debug(\"Update channel {} with {}\", channelId, consumption);\n+        updateState(channelId,\n+                !Double.isNaN(consumption) ? new QuantityType<>(consumption, SmartHomeUnits.KILOWATT_HOUR)\n+                        : UnDefType.UNDEF);\n+    }\n+\n+    /**\n+     * Produce a report of all daily values between two dates\n+     *\n+     * @param startDay the start day of the report\n+     * @param endDay the end day of the report\n+     * @param separator the separator to be used betwwen the date and the value\n+     *\n+     * @return the report as a string\n+     */\n+    public List<String> reportValues(LocalDate startDay, LocalDate endDay, @Nullable String separator) {\n+        List<String> report = new ArrayList<>();\n+        if (startDay.getYear() == endDay.getYear() && startDay.getMonthValue() == endDay.getMonthValue()) {\n+            // All values in the same month\n+            LinkyConsumptionData result = getConsumptionData(DAILY, startDay, endDay, true);\n+            if (result != null && result.success()) {\n+                LocalDate currentDay = startDay;\n+                int jump = result.getDecalage();\n+                while (jump < result.getData().size() && !currentDay.isAfter(endDay)) {\n+                    double consumption = result.getData().get(jump).valeur;\n+                    String line = currentDay.format(DateTimeFormatter.ISO_LOCAL_DATE) + separator;\n+                    if (consumption >= 0) {\n+                        line += String.valueOf(consumption);\n+                    }\n+                    report.add(line);\n+                    jump++;\n+                    currentDay = currentDay.plusDays(1);\n+                }\n+            } else {\n+                LocalDate currentDay = startDay;\n+                while (!currentDay.isAfter(endDay)) {\n+                    report.add(currentDay.format(DateTimeFormatter.ISO_LOCAL_DATE) + separator);\n+                    currentDay = currentDay.plusDays(1);\n+                }\n+            }\n+        } else {\n+            // Concatenate the report produced for each month between the two dates\n+            LocalDate first = startDay;\n+            do {\n+                LocalDate last = first.withDayOfMonth(first.lengthOfMonth());\n+                if (last.isAfter(endDay)) {\n+                    last = endDay;\n+                }\n+                report.addAll(reportValues(first, last, separator));\n+                first = last.plusDays(1);\n+            } while (!first.isAfter(endDay));\n+        }\n+        return report;\n+    }\n+\n+    private @Nullable LinkyConsumptionData getConsumptionData(LinkyTimeScale timeScale, LocalDate from, LocalDate to,\n+            boolean reLog) {\n+        logger.debug(\"getConsumptionData {}\", timeScale);\n+\n+        LinkyConsumptionData result = null;\n+        boolean tryRelog = false;\n+\n+        FormBody formBody = new FormBody.Builder().add(\"p_p_id\", \"lincspartdisplaycdc_WAR_lincspartcdcportlet\")\n+                .add(\"p_p_lifecycle\", \"2\").add(\"p_p_resource_id\", timeScale.getId())\n+                .add(\"_lincspartdisplaycdc_WAR_lincspartcdcportlet_dateDebut\", from.format(API_DATE_FORMAT))\n+                .add(\"_lincspartdisplaycdc_WAR_lincspartcdcportlet_dateFin\", to.format(API_DATE_FORMAT)).build();\n+\n+        Request requestData = new Request.Builder().url(API_BASE_URI).post(formBody).build();\n+        try (Response response = client.newCall(requestData).execute()) {\n+            if (response.isRedirect()) {\n+                String location = response.header(\"Location\");\n+                logger.debug(\"Response status {} {} redirects to {}\", response.code(), response.message(), location);\n+                if (reLog && location != null && location.startsWith(LOGIN_BASE_URI)) {\n+                    tryRelog = true;\n+                }\n+            } else {\n+                String body = (response.body() != null) ? response.body().string() : null;\n+                logger.debug(\"Response status {} {} : {}\", response.code(), response.message(), body);\n+                if (body != null && !body.isEmpty()) {\n+                    result = gson.fromJson(body, LinkyConsumptionData.class);\n+                }\n+            }\n+            response.close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f9ef7e5bfe5d91b0edf7eafa97d17a325709a72"}, "originalPosition": 340}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjU2MTc4Mw==", "bodyText": "This can be omitted since try-with-resources handles this for you.", "url": "https://github.com/openhab/openhab-addons/pull/7101#discussion_r396561783", "createdAt": "2020-03-23T15:58:50Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.linky/src/main/java/org/openhab/binding/linky/internal/handler/LinkyHandler.java", "diffHunk": "@@ -0,0 +1,390 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.linky.internal.handler;\n+\n+import static org.openhab.binding.linky.internal.LinkyBindingConstants.*;\n+import static org.openhab.binding.linky.internal.model.LinkyTimeScale.*;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.temporal.ChronoUnit;\n+import java.time.temporal.WeekFields;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.i18n.LocaleProvider;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.linky.internal.ExpiringDayCache;\n+import org.openhab.binding.linky.internal.LinkyConfiguration;\n+import org.openhab.binding.linky.internal.model.LinkyConsumptionData;\n+import org.openhab.binding.linky.internal.model.LinkyTimeScale;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+import okhttp3.FormBody;\n+import okhttp3.FormBody.Builder;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.Response;\n+\n+/**\n+ * The {@link LinkyHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ga\u00ebl L'hopital - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class LinkyHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(LinkyHandler.class);\n+\n+    private static final String LOGIN_BASE_URI = \"https://espace-client-connexion.enedis.fr/auth/UI/Login\";\n+    private static final String API_BASE_URI = \"https://espace-client-particuliers.enedis.fr/group/espace-particuliers/suivi-de-consommation\";\n+    private static final DateTimeFormatter API_DATE_FORMAT = DateTimeFormatter.ofPattern(\"dd/MM/yyyy\");\n+    private static final Builder LOGIN_BODY_BUILDER = new FormBody.Builder().add(\"encoded\", \"true\")\n+            .add(\"gx_charset\", \"UTF-8\").add(\"SunQueryParamsString\",\n+                    Base64.getEncoder().encodeToString(\"realm=particuliers\".getBytes(StandardCharsets.UTF_8)));\n+\n+    private static final int REFRESH_FIRST_HOUR_OF_DAY = 5;\n+    private static final int REFRESH_INTERVAL_IN_MIN = 360;\n+\n+    private final OkHttpClient client = new OkHttpClient.Builder().followRedirects(false)\n+            .cookieJar(new LinkyCookieJar()).build();\n+    private final Gson gson = new Gson();\n+\n+    private @NonNullByDefault({}) ScheduledFuture<?> refreshJob;\n+    private final WeekFields weekFields;\n+\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedDaylyData;\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedMonthlyData;\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedYearlyData;\n+\n+    public LinkyHandler(Thing thing, LocaleProvider localeProvider) {\n+        super(thing);\n+        this.weekFields = WeekFields.of(localeProvider.getLocale());\n+        this.cachedDaylyData = new ExpiringDayCache<LinkyConsumptionData>(\"daily cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(DAILY, today.minusDays(13), today, true);\n+                });\n+        this.cachedMonthlyData = new ExpiringDayCache<LinkyConsumptionData>(\"monthly cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(MONTHLY, today.withDayOfMonth(1).minusMonths(1), today, true);\n+                });\n+        this.cachedYearlyData = new ExpiringDayCache<LinkyConsumptionData>(\"yearly cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(YEARLY, LocalDate.of(today.getYear() - 1, 1, 1), today, true);\n+                });\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing Linky handler.\");\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.submit(this::login);\n+\n+        final LocalDateTime now = LocalDateTime.now();\n+        final LocalDateTime nextDayFirstTimeUpdate = now.plusDays(1).withHour(REFRESH_FIRST_HOUR_OF_DAY)\n+                .truncatedTo(ChronoUnit.HOURS);\n+        refreshJob = scheduler.scheduleWithFixedDelay(this::updateData,\n+                ChronoUnit.MINUTES.between(now, nextDayFirstTimeUpdate) % REFRESH_INTERVAL_IN_MIN + 1,\n+                REFRESH_INTERVAL_IN_MIN, TimeUnit.MINUTES);\n+    }\n+\n+    private synchronized boolean login() {\n+        logger.debug(\"login\");\n+\n+        LinkyConfiguration config = getConfigAs(LinkyConfiguration.class);\n+        Request requestLogin = new Request.Builder().url(LOGIN_BASE_URI)\n+                .post(LOGIN_BODY_BUILDER.add(\"IDToken1\", config.username).add(\"IDToken2\", config.password).build())\n+                .build();\n+        try (Response response = client.newCall(requestLogin).execute()) {\n+            if (response.isRedirect()) {\n+                logger.debug(\"Response status {} {} redirects to {}\", response.code(), response.message(),\n+                        response.header(\"Location\"));\n+            } else {\n+                logger.debug(\"Response status {} {}\", response.code(), response.message());\n+            }\n+            response.close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2f9ef7e5bfe5d91b0edf7eafa97d17a325709a72"}, "originalPosition": 140}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7f08a6e8e99fa7892536494fc0301067ea00d7f0", "author": {"user": {"login": "clinique", "name": "Ga\u00ebl L'hopital"}}, "url": "https://github.com/openhab/openhab-addons/commit/7f08a6e8e99fa7892536494fc0301067ea00d7f0", "committedDate": "2020-03-27T08:32:24Z", "message": "Code review final corrections\n\nSigned-off-by: clinique <gael@lhopital.org>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "50d9992342e2a7d8a8a038ad8f3d5da8f55b346c", "author": {"user": {"login": "clinique", "name": "Ga\u00ebl L'hopital"}}, "url": "https://github.com/openhab/openhab-addons/commit/50d9992342e2a7d8a8a038ad8f3d5da8f55b346c", "committedDate": "2020-03-27T12:26:55Z", "message": "Forgot one\n\nSigned-off-by: clinique <gael@lhopital.org>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyOTQ1Nzg5", "url": "https://github.com/openhab/openhab-addons/pull/7101#pullrequestreview-382945789", "createdAt": "2020-03-27T15:09:42Z", "commit": {"oid": "50d9992342e2a7d8a8a038ad8f3d5da8f55b346c"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxNTowOTo0M1rOF81dgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QxNToxNTozMlrOF81trQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTMzNDc4NQ==", "bodyText": "Perhaps you should have an else statement here that prints usage as well?", "url": "https://github.com/openhab/openhab-addons/pull/7101#discussion_r399334785", "createdAt": "2020-03-27T15:09:43Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.linky/src/main/java/org/openhab/binding/linky/internal/console/LinkyCommandExtension.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.linky.internal.console;\n+\n+import java.time.LocalDate;\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeParseException;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingRegistry;\n+import org.eclipse.smarthome.core.thing.ThingUID;\n+import org.eclipse.smarthome.io.console.Console;\n+import org.eclipse.smarthome.io.console.extensions.AbstractConsoleCommandExtension;\n+import org.eclipse.smarthome.io.console.extensions.ConsoleCommandExtension;\n+import org.openhab.binding.linky.internal.handler.LinkyHandler;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link LinkyCommandExtension} is responsible for handling console commands\n+ *\n+ * @author Laurent Garnier - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+@Component(service = ConsoleCommandExtension.class)\n+public class LinkyCommandExtension extends AbstractConsoleCommandExtension {\n+\n+    private static final String REPORT = \"report\";\n+\n+    private final ThingRegistry thingRegistry;\n+\n+    @Activate\n+    public LinkyCommandExtension(final @Reference ThingRegistry thingRegistry) {\n+        super(\"linky\", \"Interact with the Linky binding.\");\n+        this.thingRegistry = thingRegistry;\n+    }\n+\n+    @Override\n+    public void execute(String[] args, Console console) {\n+        if (args.length >= 2) {\n+            LinkyHandler handler = null;\n+            try {\n+                ThingUID thingUID = new ThingUID(args[0]);\n+                Thing thing = thingRegistry.get(thingUID);\n+                if ((thing != null) && (thing.getHandler() != null) && (thing.getHandler() instanceof LinkyHandler)) {\n+                    handler = (LinkyHandler) thing.getHandler();\n+                }\n+            } catch (IllegalArgumentException e) {\n+                handler = null;\n+            }\n+            if (handler == null) {\n+                console.println(\"Bad thing id '\" + args[0] + \"'\");\n+                printUsage(console);\n+            } else if (args[1] == REPORT) {\n+                LocalDate now = LocalDate.now();\n+                LocalDate start = now.minusDays(7);\n+                LocalDate end = now.minusDays(1);\n+                String separator = \" \";\n+                if (args.length >= 3) {\n+                    try {\n+                        start = LocalDate.parse(args[2], DateTimeFormatter.ISO_LOCAL_DATE);\n+                    } catch (DateTimeParseException e) {\n+                        console.println(\n+                                \"Invalid format for start day '\" + args[2] + \"'; expected format is YYYY-MM-DD\");\n+                        printUsage(console);\n+                        return;\n+                    }\n+                }\n+                if (args.length >= 4) {\n+                    try {\n+                        end = LocalDate.parse(args[3], DateTimeFormatter.ISO_LOCAL_DATE);\n+                    } catch (DateTimeParseException e) {\n+                        console.println(\"Invalid format for end day '\" + args[3] + \"'; expected format is YYYY-MM-DD\");\n+                        printUsage(console);\n+                        return;\n+                    }\n+                }\n+                if (!start.isBefore(now) || start.isAfter(end)) {\n+                    console.println(\"Start day must be in the past and before the end day\");\n+                    printUsage(console);\n+                    return;\n+                }\n+                if (end.isAfter(now.minusDays(1))) {\n+                    end = now.minusDays(1);\n+                }\n+                if (args.length >= 5) {\n+                    separator = args[4];\n+                }\n+                handler.reportValues(start, end, separator).forEach(console::println);\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50d9992342e2a7d8a8a038ad8f3d5da8f55b346c"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTMzNzQwOQ==", "bodyText": "Most builder designs return the same object, so I don't think you should use a builder as a static field and instead should construct it each time. Does LOGIN_BODY_BUILDER return a new builder instance each time you mutate it? If not then LOGIN_BODY_BUILDER should instead be a static method, named appropriately of course.", "url": "https://github.com/openhab/openhab-addons/pull/7101#discussion_r399337409", "createdAt": "2020-03-27T15:13:29Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.linky/src/main/java/org/openhab/binding/linky/internal/handler/LinkyHandler.java", "diffHunk": "@@ -0,0 +1,387 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.linky.internal.handler;\n+\n+import static org.openhab.binding.linky.internal.LinkyBindingConstants.*;\n+import static org.openhab.binding.linky.internal.model.LinkyTimeScale.*;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.temporal.ChronoUnit;\n+import java.time.temporal.WeekFields;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.i18n.LocaleProvider;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.linky.internal.ExpiringDayCache;\n+import org.openhab.binding.linky.internal.LinkyConfiguration;\n+import org.openhab.binding.linky.internal.model.LinkyConsumptionData;\n+import org.openhab.binding.linky.internal.model.LinkyTimeScale;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+import okhttp3.FormBody;\n+import okhttp3.FormBody.Builder;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.Response;\n+\n+/**\n+ * The {@link LinkyHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ga\u00ebl L'hopital - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class LinkyHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(LinkyHandler.class);\n+\n+    private static final String LOGIN_BASE_URI = \"https://espace-client-connexion.enedis.fr/auth/UI/Login\";\n+    private static final String API_BASE_URI = \"https://espace-client-particuliers.enedis.fr/group/espace-particuliers/suivi-de-consommation\";\n+    private static final DateTimeFormatter API_DATE_FORMAT = DateTimeFormatter.ofPattern(\"dd/MM/yyyy\");\n+    private static final Builder LOGIN_BODY_BUILDER = new FormBody.Builder().add(\"encoded\", \"true\")\n+            .add(\"gx_charset\", \"UTF-8\").add(\"SunQueryParamsString\",\n+                    Base64.getEncoder().encodeToString(\"realm=particuliers\".getBytes(StandardCharsets.UTF_8)));\n+\n+    private static final int REFRESH_FIRST_HOUR_OF_DAY = 5;\n+    private static final int REFRESH_INTERVAL_IN_MIN = 360;\n+\n+    private final OkHttpClient client = new OkHttpClient.Builder().followRedirects(false)\n+            .cookieJar(new LinkyCookieJar()).build();\n+    private final Gson gson = new Gson();\n+\n+    private @NonNullByDefault({}) ScheduledFuture<?> refreshJob;\n+    private final WeekFields weekFields;\n+\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedDaylyData;\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedMonthlyData;\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedYearlyData;\n+\n+    public LinkyHandler(Thing thing, LocaleProvider localeProvider) {\n+        super(thing);\n+        this.weekFields = WeekFields.of(localeProvider.getLocale());\n+        this.cachedDaylyData = new ExpiringDayCache<LinkyConsumptionData>(\"daily cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(DAILY, today.minusDays(13), today, true);\n+                });\n+        this.cachedMonthlyData = new ExpiringDayCache<LinkyConsumptionData>(\"monthly cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(MONTHLY, today.withDayOfMonth(1).minusMonths(1), today, true);\n+                });\n+        this.cachedYearlyData = new ExpiringDayCache<LinkyConsumptionData>(\"yearly cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(YEARLY, LocalDate.of(today.getYear() - 1, 1, 1), today, true);\n+                });\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing Linky handler.\");\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.submit(this::login);\n+\n+        final LocalDateTime now = LocalDateTime.now();\n+        final LocalDateTime nextDayFirstTimeUpdate = now.plusDays(1).withHour(REFRESH_FIRST_HOUR_OF_DAY)\n+                .truncatedTo(ChronoUnit.HOURS);\n+        refreshJob = scheduler.scheduleWithFixedDelay(this::updateData,\n+                ChronoUnit.MINUTES.between(now, nextDayFirstTimeUpdate) % REFRESH_INTERVAL_IN_MIN + 1,\n+                REFRESH_INTERVAL_IN_MIN, TimeUnit.MINUTES);\n+    }\n+\n+    private synchronized boolean login() {\n+        logger.debug(\"login\");\n+\n+        LinkyConfiguration config = getConfigAs(LinkyConfiguration.class);\n+        Request requestLogin = new Request.Builder().url(LOGIN_BASE_URI)\n+                .post(LOGIN_BODY_BUILDER.add(\"IDToken1\", config.username).add(\"IDToken2\", config.password).build())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50d9992342e2a7d8a8a038ad8f3d5da8f55b346c"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTMzODE4Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private void updateKwhChannel(String channelId, Double consumption) {\n          \n          \n            \n                private void updateKwhChannel(String channelId, double consumption) {", "url": "https://github.com/openhab/openhab-addons/pull/7101#discussion_r399338187", "createdAt": "2020-03-27T15:14:31Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.linky/src/main/java/org/openhab/binding/linky/internal/handler/LinkyHandler.java", "diffHunk": "@@ -0,0 +1,387 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.linky.internal.handler;\n+\n+import static org.openhab.binding.linky.internal.LinkyBindingConstants.*;\n+import static org.openhab.binding.linky.internal.model.LinkyTimeScale.*;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.temporal.ChronoUnit;\n+import java.time.temporal.WeekFields;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.i18n.LocaleProvider;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.linky.internal.ExpiringDayCache;\n+import org.openhab.binding.linky.internal.LinkyConfiguration;\n+import org.openhab.binding.linky.internal.model.LinkyConsumptionData;\n+import org.openhab.binding.linky.internal.model.LinkyTimeScale;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+import okhttp3.FormBody;\n+import okhttp3.FormBody.Builder;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.Response;\n+\n+/**\n+ * The {@link LinkyHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ga\u00ebl L'hopital - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class LinkyHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(LinkyHandler.class);\n+\n+    private static final String LOGIN_BASE_URI = \"https://espace-client-connexion.enedis.fr/auth/UI/Login\";\n+    private static final String API_BASE_URI = \"https://espace-client-particuliers.enedis.fr/group/espace-particuliers/suivi-de-consommation\";\n+    private static final DateTimeFormatter API_DATE_FORMAT = DateTimeFormatter.ofPattern(\"dd/MM/yyyy\");\n+    private static final Builder LOGIN_BODY_BUILDER = new FormBody.Builder().add(\"encoded\", \"true\")\n+            .add(\"gx_charset\", \"UTF-8\").add(\"SunQueryParamsString\",\n+                    Base64.getEncoder().encodeToString(\"realm=particuliers\".getBytes(StandardCharsets.UTF_8)));\n+\n+    private static final int REFRESH_FIRST_HOUR_OF_DAY = 5;\n+    private static final int REFRESH_INTERVAL_IN_MIN = 360;\n+\n+    private final OkHttpClient client = new OkHttpClient.Builder().followRedirects(false)\n+            .cookieJar(new LinkyCookieJar()).build();\n+    private final Gson gson = new Gson();\n+\n+    private @NonNullByDefault({}) ScheduledFuture<?> refreshJob;\n+    private final WeekFields weekFields;\n+\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedDaylyData;\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedMonthlyData;\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedYearlyData;\n+\n+    public LinkyHandler(Thing thing, LocaleProvider localeProvider) {\n+        super(thing);\n+        this.weekFields = WeekFields.of(localeProvider.getLocale());\n+        this.cachedDaylyData = new ExpiringDayCache<LinkyConsumptionData>(\"daily cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(DAILY, today.minusDays(13), today, true);\n+                });\n+        this.cachedMonthlyData = new ExpiringDayCache<LinkyConsumptionData>(\"monthly cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(MONTHLY, today.withDayOfMonth(1).minusMonths(1), today, true);\n+                });\n+        this.cachedYearlyData = new ExpiringDayCache<LinkyConsumptionData>(\"yearly cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(YEARLY, LocalDate.of(today.getYear() - 1, 1, 1), today, true);\n+                });\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing Linky handler.\");\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.submit(this::login);\n+\n+        final LocalDateTime now = LocalDateTime.now();\n+        final LocalDateTime nextDayFirstTimeUpdate = now.plusDays(1).withHour(REFRESH_FIRST_HOUR_OF_DAY)\n+                .truncatedTo(ChronoUnit.HOURS);\n+        refreshJob = scheduler.scheduleWithFixedDelay(this::updateData,\n+                ChronoUnit.MINUTES.between(now, nextDayFirstTimeUpdate) % REFRESH_INTERVAL_IN_MIN + 1,\n+                REFRESH_INTERVAL_IN_MIN, TimeUnit.MINUTES);\n+    }\n+\n+    private synchronized boolean login() {\n+        logger.debug(\"login\");\n+\n+        LinkyConfiguration config = getConfigAs(LinkyConfiguration.class);\n+        Request requestLogin = new Request.Builder().url(LOGIN_BASE_URI)\n+                .post(LOGIN_BODY_BUILDER.add(\"IDToken1\", config.username).add(\"IDToken2\", config.password).build())\n+                .build();\n+        try (Response response = client.newCall(requestLogin).execute()) {\n+            if (response.isRedirect()) {\n+                logger.debug(\"Response status {} {} redirects to {}\", response.code(), response.message(),\n+                        response.header(\"Location\"));\n+            } else {\n+                logger.debug(\"Response status {} {}\", response.code(), response.message());\n+            }\n+            // Do a first call to get data; this first call will fail with code 302\n+            getConsumptionData(DAILY, LocalDate.now(), LocalDate.now(), false);\n+            updateStatus(ThingStatus.ONLINE);\n+            return true;\n+        } catch (IOException e) {\n+            logger.debug(\"Exception while trying to login: {}\", e.getMessage(), e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+            return false;\n+        }\n+    }\n+\n+    /**\n+     * Request new data and updates channels\n+     */\n+    private void updateData() {\n+        updateDailyData();\n+        updateMonthlyData();\n+        updateYearlyData();\n+    }\n+\n+    /**\n+     * Request new dayly/weekly data and updates channels\n+     */\n+    private synchronized void updateDailyData() {\n+        if (!isLinked(YESTERDAY) && !isLinked(LAST_WEEK) && !isLinked(THIS_WEEK)) {\n+            return;\n+        }\n+\n+        Double lastWeek = Double.NaN;\n+        Double thisWeek = Double.NaN;\n+        Double yesterday = Double.NaN;\n+        LinkyConsumptionData result = cachedDaylyData.getValue();\n+        if (result != null && result.success()) {\n+            LocalDate rangeStart = LocalDate.now().minusDays(13);\n+            int jump = result.getDecalage();\n+            while (rangeStart.getDayOfWeek() != weekFields.getFirstDayOfWeek()) {\n+                rangeStart = rangeStart.plusDays(1);\n+                jump++;\n+            }\n+\n+            int lastWeekNumber = rangeStart.get(weekFields.weekOfWeekBasedYear());\n+\n+            lastWeek = 0.0;\n+            thisWeek = 0.0;\n+            yesterday = Double.NaN;\n+            while (jump < result.getData().size()) {\n+                double consumption = result.getData().get(jump).valeur;\n+                if (consumption > 0) {\n+                    if (rangeStart.get(weekFields.weekOfWeekBasedYear()) == lastWeekNumber) {\n+                        lastWeek += consumption;\n+                        logger.trace(\"Consumption at index {} added to last week: {}\", jump, consumption);\n+                    } else {\n+                        thisWeek += consumption;\n+                        logger.trace(\"Consumption at index {} added to current week: {}\", jump, consumption);\n+                    }\n+                    yesterday = consumption;\n+                }\n+                jump++;\n+                rangeStart = rangeStart.plusDays(1);\n+            }\n+        } else {\n+            cachedDaylyData.invalidateValue();\n+        }\n+        updateKwhChannel(YESTERDAY, yesterday);\n+        updateKwhChannel(THIS_WEEK, thisWeek);\n+        updateKwhChannel(LAST_WEEK, lastWeek);\n+    }\n+\n+    /**\n+     * Request new monthly data and updates channels\n+     */\n+    private synchronized void updateMonthlyData() {\n+        if (!isLinked(LAST_MONTH) && !isLinked(THIS_MONTH)) {\n+            return;\n+        }\n+\n+        Double lastMonth = Double.NaN;\n+        Double thisMonth = Double.NaN;\n+        LinkyConsumptionData result = cachedMonthlyData.getValue();\n+        if (result != null && result.success()) {\n+            int jump = result.getDecalage();\n+            lastMonth = result.getData().get(jump).valeur;\n+            thisMonth = result.getData().get(jump + 1).valeur;\n+            if (thisMonth < 0) {\n+                thisMonth = 0.0;\n+            }\n+        } else {\n+            cachedMonthlyData.invalidateValue();\n+        }\n+        updateKwhChannel(LAST_MONTH, lastMonth);\n+        updateKwhChannel(THIS_MONTH, thisMonth);\n+    }\n+\n+    /**\n+     * Request new yearly data and updates channels\n+     */\n+    private synchronized void updateYearlyData() {\n+        if (!isLinked(LAST_YEAR) && !isLinked(THIS_YEAR)) {\n+            return;\n+        }\n+\n+        Double thisYear = Double.NaN;\n+        Double lastYear = Double.NaN;\n+        LinkyConsumptionData result = cachedYearlyData.getValue();\n+        if (result != null && result.success()) {\n+            int elementQuantity = result.getData().size();\n+            thisYear = elementQuantity > 0 ? result.getData().get(elementQuantity - 1).valeur : Double.NaN;\n+            lastYear = elementQuantity > 1 ? result.getData().get(elementQuantity - 2).valeur : Double.NaN;\n+        } else {\n+            cachedYearlyData.invalidateValue();\n+        }\n+        updateKwhChannel(LAST_YEAR, lastYear);\n+        updateKwhChannel(THIS_YEAR, thisYear);\n+    }\n+\n+    private void updateKwhChannel(String channelId, Double consumption) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50d9992342e2a7d8a8a038ad8f3d5da8f55b346c"}, "originalPosition": 255}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTMzODM4OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Double thisYear = Double.NaN;\n          \n          \n            \n                    Double lastYear = Double.NaN;\n          \n          \n            \n                    double thisYear = Double.NaN;\n          \n          \n            \n                    double lastYear = Double.NaN;", "url": "https://github.com/openhab/openhab-addons/pull/7101#discussion_r399338388", "createdAt": "2020-03-27T15:14:48Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.linky/src/main/java/org/openhab/binding/linky/internal/handler/LinkyHandler.java", "diffHunk": "@@ -0,0 +1,387 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.linky.internal.handler;\n+\n+import static org.openhab.binding.linky.internal.LinkyBindingConstants.*;\n+import static org.openhab.binding.linky.internal.model.LinkyTimeScale.*;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.temporal.ChronoUnit;\n+import java.time.temporal.WeekFields;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.i18n.LocaleProvider;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.linky.internal.ExpiringDayCache;\n+import org.openhab.binding.linky.internal.LinkyConfiguration;\n+import org.openhab.binding.linky.internal.model.LinkyConsumptionData;\n+import org.openhab.binding.linky.internal.model.LinkyTimeScale;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+import okhttp3.FormBody;\n+import okhttp3.FormBody.Builder;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.Response;\n+\n+/**\n+ * The {@link LinkyHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ga\u00ebl L'hopital - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class LinkyHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(LinkyHandler.class);\n+\n+    private static final String LOGIN_BASE_URI = \"https://espace-client-connexion.enedis.fr/auth/UI/Login\";\n+    private static final String API_BASE_URI = \"https://espace-client-particuliers.enedis.fr/group/espace-particuliers/suivi-de-consommation\";\n+    private static final DateTimeFormatter API_DATE_FORMAT = DateTimeFormatter.ofPattern(\"dd/MM/yyyy\");\n+    private static final Builder LOGIN_BODY_BUILDER = new FormBody.Builder().add(\"encoded\", \"true\")\n+            .add(\"gx_charset\", \"UTF-8\").add(\"SunQueryParamsString\",\n+                    Base64.getEncoder().encodeToString(\"realm=particuliers\".getBytes(StandardCharsets.UTF_8)));\n+\n+    private static final int REFRESH_FIRST_HOUR_OF_DAY = 5;\n+    private static final int REFRESH_INTERVAL_IN_MIN = 360;\n+\n+    private final OkHttpClient client = new OkHttpClient.Builder().followRedirects(false)\n+            .cookieJar(new LinkyCookieJar()).build();\n+    private final Gson gson = new Gson();\n+\n+    private @NonNullByDefault({}) ScheduledFuture<?> refreshJob;\n+    private final WeekFields weekFields;\n+\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedDaylyData;\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedMonthlyData;\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedYearlyData;\n+\n+    public LinkyHandler(Thing thing, LocaleProvider localeProvider) {\n+        super(thing);\n+        this.weekFields = WeekFields.of(localeProvider.getLocale());\n+        this.cachedDaylyData = new ExpiringDayCache<LinkyConsumptionData>(\"daily cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(DAILY, today.minusDays(13), today, true);\n+                });\n+        this.cachedMonthlyData = new ExpiringDayCache<LinkyConsumptionData>(\"monthly cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(MONTHLY, today.withDayOfMonth(1).minusMonths(1), today, true);\n+                });\n+        this.cachedYearlyData = new ExpiringDayCache<LinkyConsumptionData>(\"yearly cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(YEARLY, LocalDate.of(today.getYear() - 1, 1, 1), today, true);\n+                });\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing Linky handler.\");\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.submit(this::login);\n+\n+        final LocalDateTime now = LocalDateTime.now();\n+        final LocalDateTime nextDayFirstTimeUpdate = now.plusDays(1).withHour(REFRESH_FIRST_HOUR_OF_DAY)\n+                .truncatedTo(ChronoUnit.HOURS);\n+        refreshJob = scheduler.scheduleWithFixedDelay(this::updateData,\n+                ChronoUnit.MINUTES.between(now, nextDayFirstTimeUpdate) % REFRESH_INTERVAL_IN_MIN + 1,\n+                REFRESH_INTERVAL_IN_MIN, TimeUnit.MINUTES);\n+    }\n+\n+    private synchronized boolean login() {\n+        logger.debug(\"login\");\n+\n+        LinkyConfiguration config = getConfigAs(LinkyConfiguration.class);\n+        Request requestLogin = new Request.Builder().url(LOGIN_BASE_URI)\n+                .post(LOGIN_BODY_BUILDER.add(\"IDToken1\", config.username).add(\"IDToken2\", config.password).build())\n+                .build();\n+        try (Response response = client.newCall(requestLogin).execute()) {\n+            if (response.isRedirect()) {\n+                logger.debug(\"Response status {} {} redirects to {}\", response.code(), response.message(),\n+                        response.header(\"Location\"));\n+            } else {\n+                logger.debug(\"Response status {} {}\", response.code(), response.message());\n+            }\n+            // Do a first call to get data; this first call will fail with code 302\n+            getConsumptionData(DAILY, LocalDate.now(), LocalDate.now(), false);\n+            updateStatus(ThingStatus.ONLINE);\n+            return true;\n+        } catch (IOException e) {\n+            logger.debug(\"Exception while trying to login: {}\", e.getMessage(), e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+            return false;\n+        }\n+    }\n+\n+    /**\n+     * Request new data and updates channels\n+     */\n+    private void updateData() {\n+        updateDailyData();\n+        updateMonthlyData();\n+        updateYearlyData();\n+    }\n+\n+    /**\n+     * Request new dayly/weekly data and updates channels\n+     */\n+    private synchronized void updateDailyData() {\n+        if (!isLinked(YESTERDAY) && !isLinked(LAST_WEEK) && !isLinked(THIS_WEEK)) {\n+            return;\n+        }\n+\n+        Double lastWeek = Double.NaN;\n+        Double thisWeek = Double.NaN;\n+        Double yesterday = Double.NaN;\n+        LinkyConsumptionData result = cachedDaylyData.getValue();\n+        if (result != null && result.success()) {\n+            LocalDate rangeStart = LocalDate.now().minusDays(13);\n+            int jump = result.getDecalage();\n+            while (rangeStart.getDayOfWeek() != weekFields.getFirstDayOfWeek()) {\n+                rangeStart = rangeStart.plusDays(1);\n+                jump++;\n+            }\n+\n+            int lastWeekNumber = rangeStart.get(weekFields.weekOfWeekBasedYear());\n+\n+            lastWeek = 0.0;\n+            thisWeek = 0.0;\n+            yesterday = Double.NaN;\n+            while (jump < result.getData().size()) {\n+                double consumption = result.getData().get(jump).valeur;\n+                if (consumption > 0) {\n+                    if (rangeStart.get(weekFields.weekOfWeekBasedYear()) == lastWeekNumber) {\n+                        lastWeek += consumption;\n+                        logger.trace(\"Consumption at index {} added to last week: {}\", jump, consumption);\n+                    } else {\n+                        thisWeek += consumption;\n+                        logger.trace(\"Consumption at index {} added to current week: {}\", jump, consumption);\n+                    }\n+                    yesterday = consumption;\n+                }\n+                jump++;\n+                rangeStart = rangeStart.plusDays(1);\n+            }\n+        } else {\n+            cachedDaylyData.invalidateValue();\n+        }\n+        updateKwhChannel(YESTERDAY, yesterday);\n+        updateKwhChannel(THIS_WEEK, thisWeek);\n+        updateKwhChannel(LAST_WEEK, lastWeek);\n+    }\n+\n+    /**\n+     * Request new monthly data and updates channels\n+     */\n+    private synchronized void updateMonthlyData() {\n+        if (!isLinked(LAST_MONTH) && !isLinked(THIS_MONTH)) {\n+            return;\n+        }\n+\n+        Double lastMonth = Double.NaN;\n+        Double thisMonth = Double.NaN;\n+        LinkyConsumptionData result = cachedMonthlyData.getValue();\n+        if (result != null && result.success()) {\n+            int jump = result.getDecalage();\n+            lastMonth = result.getData().get(jump).valeur;\n+            thisMonth = result.getData().get(jump + 1).valeur;\n+            if (thisMonth < 0) {\n+                thisMonth = 0.0;\n+            }\n+        } else {\n+            cachedMonthlyData.invalidateValue();\n+        }\n+        updateKwhChannel(LAST_MONTH, lastMonth);\n+        updateKwhChannel(THIS_MONTH, thisMonth);\n+    }\n+\n+    /**\n+     * Request new yearly data and updates channels\n+     */\n+    private synchronized void updateYearlyData() {\n+        if (!isLinked(LAST_YEAR) && !isLinked(THIS_YEAR)) {\n+            return;\n+        }\n+\n+        Double thisYear = Double.NaN;\n+        Double lastYear = Double.NaN;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50d9992342e2a7d8a8a038ad8f3d5da8f55b346c"}, "originalPosition": 242}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTMzODY2Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Double lastMonth = Double.NaN;\n          \n          \n            \n                    Double thisMonth = Double.NaN;\n          \n          \n            \n                    double lastMonth = Double.NaN;\n          \n          \n            \n                    double thisMonth = Double.NaN;", "url": "https://github.com/openhab/openhab-addons/pull/7101#discussion_r399338662", "createdAt": "2020-03-27T15:15:12Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.linky/src/main/java/org/openhab/binding/linky/internal/handler/LinkyHandler.java", "diffHunk": "@@ -0,0 +1,387 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.linky.internal.handler;\n+\n+import static org.openhab.binding.linky.internal.LinkyBindingConstants.*;\n+import static org.openhab.binding.linky.internal.model.LinkyTimeScale.*;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.temporal.ChronoUnit;\n+import java.time.temporal.WeekFields;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.i18n.LocaleProvider;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.linky.internal.ExpiringDayCache;\n+import org.openhab.binding.linky.internal.LinkyConfiguration;\n+import org.openhab.binding.linky.internal.model.LinkyConsumptionData;\n+import org.openhab.binding.linky.internal.model.LinkyTimeScale;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+import okhttp3.FormBody;\n+import okhttp3.FormBody.Builder;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.Response;\n+\n+/**\n+ * The {@link LinkyHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ga\u00ebl L'hopital - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class LinkyHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(LinkyHandler.class);\n+\n+    private static final String LOGIN_BASE_URI = \"https://espace-client-connexion.enedis.fr/auth/UI/Login\";\n+    private static final String API_BASE_URI = \"https://espace-client-particuliers.enedis.fr/group/espace-particuliers/suivi-de-consommation\";\n+    private static final DateTimeFormatter API_DATE_FORMAT = DateTimeFormatter.ofPattern(\"dd/MM/yyyy\");\n+    private static final Builder LOGIN_BODY_BUILDER = new FormBody.Builder().add(\"encoded\", \"true\")\n+            .add(\"gx_charset\", \"UTF-8\").add(\"SunQueryParamsString\",\n+                    Base64.getEncoder().encodeToString(\"realm=particuliers\".getBytes(StandardCharsets.UTF_8)));\n+\n+    private static final int REFRESH_FIRST_HOUR_OF_DAY = 5;\n+    private static final int REFRESH_INTERVAL_IN_MIN = 360;\n+\n+    private final OkHttpClient client = new OkHttpClient.Builder().followRedirects(false)\n+            .cookieJar(new LinkyCookieJar()).build();\n+    private final Gson gson = new Gson();\n+\n+    private @NonNullByDefault({}) ScheduledFuture<?> refreshJob;\n+    private final WeekFields weekFields;\n+\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedDaylyData;\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedMonthlyData;\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedYearlyData;\n+\n+    public LinkyHandler(Thing thing, LocaleProvider localeProvider) {\n+        super(thing);\n+        this.weekFields = WeekFields.of(localeProvider.getLocale());\n+        this.cachedDaylyData = new ExpiringDayCache<LinkyConsumptionData>(\"daily cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(DAILY, today.minusDays(13), today, true);\n+                });\n+        this.cachedMonthlyData = new ExpiringDayCache<LinkyConsumptionData>(\"monthly cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(MONTHLY, today.withDayOfMonth(1).minusMonths(1), today, true);\n+                });\n+        this.cachedYearlyData = new ExpiringDayCache<LinkyConsumptionData>(\"yearly cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(YEARLY, LocalDate.of(today.getYear() - 1, 1, 1), today, true);\n+                });\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing Linky handler.\");\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.submit(this::login);\n+\n+        final LocalDateTime now = LocalDateTime.now();\n+        final LocalDateTime nextDayFirstTimeUpdate = now.plusDays(1).withHour(REFRESH_FIRST_HOUR_OF_DAY)\n+                .truncatedTo(ChronoUnit.HOURS);\n+        refreshJob = scheduler.scheduleWithFixedDelay(this::updateData,\n+                ChronoUnit.MINUTES.between(now, nextDayFirstTimeUpdate) % REFRESH_INTERVAL_IN_MIN + 1,\n+                REFRESH_INTERVAL_IN_MIN, TimeUnit.MINUTES);\n+    }\n+\n+    private synchronized boolean login() {\n+        logger.debug(\"login\");\n+\n+        LinkyConfiguration config = getConfigAs(LinkyConfiguration.class);\n+        Request requestLogin = new Request.Builder().url(LOGIN_BASE_URI)\n+                .post(LOGIN_BODY_BUILDER.add(\"IDToken1\", config.username).add(\"IDToken2\", config.password).build())\n+                .build();\n+        try (Response response = client.newCall(requestLogin).execute()) {\n+            if (response.isRedirect()) {\n+                logger.debug(\"Response status {} {} redirects to {}\", response.code(), response.message(),\n+                        response.header(\"Location\"));\n+            } else {\n+                logger.debug(\"Response status {} {}\", response.code(), response.message());\n+            }\n+            // Do a first call to get data; this first call will fail with code 302\n+            getConsumptionData(DAILY, LocalDate.now(), LocalDate.now(), false);\n+            updateStatus(ThingStatus.ONLINE);\n+            return true;\n+        } catch (IOException e) {\n+            logger.debug(\"Exception while trying to login: {}\", e.getMessage(), e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+            return false;\n+        }\n+    }\n+\n+    /**\n+     * Request new data and updates channels\n+     */\n+    private void updateData() {\n+        updateDailyData();\n+        updateMonthlyData();\n+        updateYearlyData();\n+    }\n+\n+    /**\n+     * Request new dayly/weekly data and updates channels\n+     */\n+    private synchronized void updateDailyData() {\n+        if (!isLinked(YESTERDAY) && !isLinked(LAST_WEEK) && !isLinked(THIS_WEEK)) {\n+            return;\n+        }\n+\n+        Double lastWeek = Double.NaN;\n+        Double thisWeek = Double.NaN;\n+        Double yesterday = Double.NaN;\n+        LinkyConsumptionData result = cachedDaylyData.getValue();\n+        if (result != null && result.success()) {\n+            LocalDate rangeStart = LocalDate.now().minusDays(13);\n+            int jump = result.getDecalage();\n+            while (rangeStart.getDayOfWeek() != weekFields.getFirstDayOfWeek()) {\n+                rangeStart = rangeStart.plusDays(1);\n+                jump++;\n+            }\n+\n+            int lastWeekNumber = rangeStart.get(weekFields.weekOfWeekBasedYear());\n+\n+            lastWeek = 0.0;\n+            thisWeek = 0.0;\n+            yesterday = Double.NaN;\n+            while (jump < result.getData().size()) {\n+                double consumption = result.getData().get(jump).valeur;\n+                if (consumption > 0) {\n+                    if (rangeStart.get(weekFields.weekOfWeekBasedYear()) == lastWeekNumber) {\n+                        lastWeek += consumption;\n+                        logger.trace(\"Consumption at index {} added to last week: {}\", jump, consumption);\n+                    } else {\n+                        thisWeek += consumption;\n+                        logger.trace(\"Consumption at index {} added to current week: {}\", jump, consumption);\n+                    }\n+                    yesterday = consumption;\n+                }\n+                jump++;\n+                rangeStart = rangeStart.plusDays(1);\n+            }\n+        } else {\n+            cachedDaylyData.invalidateValue();\n+        }\n+        updateKwhChannel(YESTERDAY, yesterday);\n+        updateKwhChannel(THIS_WEEK, thisWeek);\n+        updateKwhChannel(LAST_WEEK, lastWeek);\n+    }\n+\n+    /**\n+     * Request new monthly data and updates channels\n+     */\n+    private synchronized void updateMonthlyData() {\n+        if (!isLinked(LAST_MONTH) && !isLinked(THIS_MONTH)) {\n+            return;\n+        }\n+\n+        Double lastMonth = Double.NaN;\n+        Double thisMonth = Double.NaN;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50d9992342e2a7d8a8a038ad8f3d5da8f55b346c"}, "originalPosition": 217}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTMzODkyNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Double lastWeek = Double.NaN;\n          \n          \n            \n                    Double thisWeek = Double.NaN;\n          \n          \n            \n                    Double yesterday = Double.NaN;\n          \n          \n            \n                    double lastWeek = Double.NaN;\n          \n          \n            \n                    double thisWeek = Double.NaN;\n          \n          \n            \n                    double yesterday = Double.NaN;", "url": "https://github.com/openhab/openhab-addons/pull/7101#discussion_r399338925", "createdAt": "2020-03-27T15:15:32Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.linky/src/main/java/org/openhab/binding/linky/internal/handler/LinkyHandler.java", "diffHunk": "@@ -0,0 +1,387 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.linky.internal.handler;\n+\n+import static org.openhab.binding.linky.internal.LinkyBindingConstants.*;\n+import static org.openhab.binding.linky.internal.model.LinkyTimeScale.*;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.time.LocalDate;\n+import java.time.LocalDateTime;\n+import java.time.format.DateTimeFormatter;\n+import java.time.temporal.ChronoUnit;\n+import java.time.temporal.WeekFields;\n+import java.util.ArrayList;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.i18n.LocaleProvider;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.linky.internal.ExpiringDayCache;\n+import org.openhab.binding.linky.internal.LinkyConfiguration;\n+import org.openhab.binding.linky.internal.model.LinkyConsumptionData;\n+import org.openhab.binding.linky.internal.model.LinkyTimeScale;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.JsonSyntaxException;\n+\n+import okhttp3.FormBody;\n+import okhttp3.FormBody.Builder;\n+import okhttp3.OkHttpClient;\n+import okhttp3.Request;\n+import okhttp3.Response;\n+\n+/**\n+ * The {@link LinkyHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Ga\u00ebl L'hopital - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+public class LinkyHandler extends BaseThingHandler {\n+    private final Logger logger = LoggerFactory.getLogger(LinkyHandler.class);\n+\n+    private static final String LOGIN_BASE_URI = \"https://espace-client-connexion.enedis.fr/auth/UI/Login\";\n+    private static final String API_BASE_URI = \"https://espace-client-particuliers.enedis.fr/group/espace-particuliers/suivi-de-consommation\";\n+    private static final DateTimeFormatter API_DATE_FORMAT = DateTimeFormatter.ofPattern(\"dd/MM/yyyy\");\n+    private static final Builder LOGIN_BODY_BUILDER = new FormBody.Builder().add(\"encoded\", \"true\")\n+            .add(\"gx_charset\", \"UTF-8\").add(\"SunQueryParamsString\",\n+                    Base64.getEncoder().encodeToString(\"realm=particuliers\".getBytes(StandardCharsets.UTF_8)));\n+\n+    private static final int REFRESH_FIRST_HOUR_OF_DAY = 5;\n+    private static final int REFRESH_INTERVAL_IN_MIN = 360;\n+\n+    private final OkHttpClient client = new OkHttpClient.Builder().followRedirects(false)\n+            .cookieJar(new LinkyCookieJar()).build();\n+    private final Gson gson = new Gson();\n+\n+    private @NonNullByDefault({}) ScheduledFuture<?> refreshJob;\n+    private final WeekFields weekFields;\n+\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedDaylyData;\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedMonthlyData;\n+    private final ExpiringDayCache<LinkyConsumptionData> cachedYearlyData;\n+\n+    public LinkyHandler(Thing thing, LocaleProvider localeProvider) {\n+        super(thing);\n+        this.weekFields = WeekFields.of(localeProvider.getLocale());\n+        this.cachedDaylyData = new ExpiringDayCache<LinkyConsumptionData>(\"daily cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(DAILY, today.minusDays(13), today, true);\n+                });\n+        this.cachedMonthlyData = new ExpiringDayCache<LinkyConsumptionData>(\"monthly cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(MONTHLY, today.withDayOfMonth(1).minusMonths(1), today, true);\n+                });\n+        this.cachedYearlyData = new ExpiringDayCache<LinkyConsumptionData>(\"yearly cache\", REFRESH_FIRST_HOUR_OF_DAY,\n+                () -> {\n+                    final LocalDate today = LocalDate.now();\n+                    return getConsumptionData(YEARLY, LocalDate.of(today.getYear() - 1, 1, 1), today, true);\n+                });\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Initializing Linky handler.\");\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.submit(this::login);\n+\n+        final LocalDateTime now = LocalDateTime.now();\n+        final LocalDateTime nextDayFirstTimeUpdate = now.plusDays(1).withHour(REFRESH_FIRST_HOUR_OF_DAY)\n+                .truncatedTo(ChronoUnit.HOURS);\n+        refreshJob = scheduler.scheduleWithFixedDelay(this::updateData,\n+                ChronoUnit.MINUTES.between(now, nextDayFirstTimeUpdate) % REFRESH_INTERVAL_IN_MIN + 1,\n+                REFRESH_INTERVAL_IN_MIN, TimeUnit.MINUTES);\n+    }\n+\n+    private synchronized boolean login() {\n+        logger.debug(\"login\");\n+\n+        LinkyConfiguration config = getConfigAs(LinkyConfiguration.class);\n+        Request requestLogin = new Request.Builder().url(LOGIN_BASE_URI)\n+                .post(LOGIN_BODY_BUILDER.add(\"IDToken1\", config.username).add(\"IDToken2\", config.password).build())\n+                .build();\n+        try (Response response = client.newCall(requestLogin).execute()) {\n+            if (response.isRedirect()) {\n+                logger.debug(\"Response status {} {} redirects to {}\", response.code(), response.message(),\n+                        response.header(\"Location\"));\n+            } else {\n+                logger.debug(\"Response status {} {}\", response.code(), response.message());\n+            }\n+            // Do a first call to get data; this first call will fail with code 302\n+            getConsumptionData(DAILY, LocalDate.now(), LocalDate.now(), false);\n+            updateStatus(ThingStatus.ONLINE);\n+            return true;\n+        } catch (IOException e) {\n+            logger.debug(\"Exception while trying to login: {}\", e.getMessage(), e);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, e.getMessage());\n+            return false;\n+        }\n+    }\n+\n+    /**\n+     * Request new data and updates channels\n+     */\n+    private void updateData() {\n+        updateDailyData();\n+        updateMonthlyData();\n+        updateYearlyData();\n+    }\n+\n+    /**\n+     * Request new dayly/weekly data and updates channels\n+     */\n+    private synchronized void updateDailyData() {\n+        if (!isLinked(YESTERDAY) && !isLinked(LAST_WEEK) && !isLinked(THIS_WEEK)) {\n+            return;\n+        }\n+\n+        Double lastWeek = Double.NaN;\n+        Double thisWeek = Double.NaN;\n+        Double yesterday = Double.NaN;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "50d9992342e2a7d8a8a038ad8f3d5da8f55b346c"}, "originalPosition": 170}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "07971052ac2179e43fbdf8e45d9123bf508e6dbf", "author": {"user": {"login": "clinique", "name": "Ga\u00ebl L'hopital"}}, "url": "https://github.com/openhab/openhab-addons/commit/07971052ac2179e43fbdf8e45d9123bf508e6dbf", "committedDate": "2020-03-29T17:52:37Z", "message": "Code rerereview :) cocococorrections\nThis PR is dedicated to Julie, 16 yo young girl, passed away with the COVID-19\n\nSigned-off-by: clinique <gael@lhopital.org>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgzNDQxNDY5", "url": "https://github.com/openhab/openhab-addons/pull/7101#pullrequestreview-383441469", "createdAt": "2020-03-29T18:37:52Z", "commit": {"oid": "07971052ac2179e43fbdf8e45d9123bf508e6dbf"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dae11993577ba5608602eb8b6ca35be88cdf626d", "author": {"user": {"login": "clinique", "name": "Ga\u00ebl L'hopital"}}, "url": "https://github.com/openhab/openhab-addons/commit/dae11993577ba5608602eb8b6ca35be88cdf626d", "committedDate": "2020-04-05T17:32:12Z", "message": "Correction of console extension\n\nSigned-off-by: clinique <gael@lhopital.org>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg4NjU0OTQx", "url": "https://github.com/openhab/openhab-addons/pull/7101#pullrequestreview-388654941", "createdAt": "2020-04-06T22:12:18Z", "commit": {"oid": "dae11993577ba5608602eb8b6ca35be88cdf626d"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk0OTU3ODYy", "url": "https://github.com/openhab/openhab-addons/pull/7101#pullrequestreview-394957862", "createdAt": "2020-04-16T20:01:39Z", "commit": {"oid": "dae11993577ba5608602eb8b6ca35be88cdf626d"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1089, "cost": 1, "resetAt": "2021-10-28T19:08:13Z"}}}