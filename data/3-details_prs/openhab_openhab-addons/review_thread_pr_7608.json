{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE2MzI0OTUy", "number": 7608, "reviewThreads": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxODozMTo1OFrOD97CPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QyMjozODoxN1rOD_KNRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MjU2OTU5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.deconz/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxODozMTo1OFrOGXtbXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxODozMTo1OFrOGXtbXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUxNDcxNw==", "bodyText": "Think this typo is not wanted?", "url": "https://github.com/openhab/openhab-addons/pull/7608#discussion_r427514717", "createdAt": "2020-05-19T18:31:58Z", "author": {"login": "DerOetzi"}, "path": "bundles/org.openhab.binding.deconz/README.md", "diffHunk": "@@ -2,32 +2,41 @@\n \n The Zigbee binding currently does not support the Dresden Elektronik Raspbee and Conbee Zigbee dongles.\n The manufacturer provides a companion app called deCONZ together with the mentioned hardware.\n-deCONZ offers a documented real-time channel that this binding makes use of to bring support for all paired Zigbee sensors and switches.\n-\n-deCONZ also acts as a HUE bridge.\n-This binding is meant to be used together with the HUE binding which makes the lights and plugs available.\n+deCONZ offers a documented real-time channel that this binding makes use of to bring support for all paired Zigbee devices.\n \n ## Supported Things\n \n There is one bridge (`deconz`) that manages the connection to the deCONZ software instance.\n-These things are supported:\n+These sensors are supported:\n \n | Device type                       | Resource Type                     | Thing type           |\n |-----------------------------------|-----------------------------------|----------------------|\n-| Presence Sensor                   | ZHAPresence, CLIPPrensence        | `presencesensor`     |\n+| Presence Sensor                   | ZHAPresence, CLIPPresence         | `presencesensor`     |\n | Power Sensor                      | ZHAPower, CLIPPower               | `powersensor`        |\n | Consumption Sensor                | ZHAConsumption                    | `consumptionsensor`  |\n | Switch                            | ZHASwitch                         | `switch`             |\n | Light Sensor                      | ZHALightLevel                     | `lightsensor`        |\n | Temperature Sensor                | ZHATemperature                    | `temperaturesensor`  |\n | Humidity Sensor                   | ZHAHumidity                       | `humiditysensor`     |\n | Pressure Sensor                   | ZHAPressure                       | `pressuresensor`     |\n-| Open/Close Sensor                 | ZHAOpenClose                      | `openclosesensor`    |\n+| Open/Close Sensor                 | ZHAOpenClose                      | `oenclosesensor`    |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d7caaa37b0ac85d6c9a8d76ab8267e7f7658063"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MjYxMjM3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.deconz/src/main/java/org/openhab/binding/deconz/internal/types/LightTypeDeserializer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxODo0MzozOFrOGXt2EQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxODo0MzozOFrOGXt2EQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUyMTU1Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    LightType lightType = LightType.UNKNOWN;\n          \n          \n            \n                    if (s != null) {\n          \n          \n            \n                        lightType = LightType.fromString(s);\n          \n          \n            \n                    }\n          \n          \n            \n                    return lightType;\n          \n          \n            \n                    return s != null ? LightType.fromString(s) : LightType.UNKNOWN;", "url": "https://github.com/openhab/openhab-addons/pull/7608#discussion_r427521553", "createdAt": "2020-05-19T18:43:38Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.deconz/src/main/java/org/openhab/binding/deconz/internal/types/LightTypeDeserializer.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.deconz.internal.types;\n+\n+import java.lang.reflect.Type;\n+\n+import com.google.gson.JsonDeserializationContext;\n+import com.google.gson.JsonDeserializer;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonParseException;\n+\n+/**\n+ * Custom deserializer for {@link LightType}\n+ *\n+ * @author Jan N. Klug - Initial contribution\n+ */\n+public class LightTypeDeserializer implements JsonDeserializer<LightType> {\n+    @Override\n+    public LightType deserialize(JsonElement json, Type typeOfT, JsonDeserializationContext context)\n+            throws JsonParseException {\n+        String s = json.getAsString();\n+\n+        LightType lightType = LightType.UNKNOWN;\n+        if (s != null) {\n+            lightType = LightType.fromString(s);\n+        }\n+        return lightType;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d7caaa37b0ac85d6c9a8d76ab8267e7f7658063"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MjY0MDkzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.deconz/src/main/java/org/openhab/binding/deconz/internal/BindingConstants.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxODo1MToxM1rOGXuIRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxODo1MToxM1rOGXuIRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUyNjIxMg==", "bodyText": "What if there is an empty string in urlParts?", "url": "https://github.com/openhab/openhab-addons/pull/7608#discussion_r427526212", "createdAt": "2020-05-19T18:51:13Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.deconz/src/main/java/org/openhab/binding/deconz/internal/BindingConstants.java", "diffHunk": "@@ -81,23 +105,15 @@\n \n     public static final String UNIQUE_ID = \"uid\";\n \n-    public static String url(String host, int port, @Nullable String apikey, @Nullable String endpointType,\n-            @Nullable String endpointID) {\n+    public static String buildUrl(String host, int port, String... urlParts) {\n         StringBuilder url = new StringBuilder();\n         url.append(\"http://\");\n         url.append(host).append(\":\").append(port);\n         url.append(\"/api/\");\n-        if (apikey != null) {\n-            url.append(apikey);\n-        }\n-        if (endpointType != null) {\n-            url.append(\"/\");\n-            url.append(endpointType);\n-            url.append(\"/\");\n-        }\n-        if (endpointID != null) {\n-            url.append(endpointID);\n+        if (urlParts.length > 0) {\n+            url.append(Stream.of(urlParts).collect(Collectors.joining(\"/\")));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d7caaa37b0ac85d6c9a8d76ab8267e7f7658063"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MjY2NTY3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.deconz/src/main/java/org/openhab/binding/deconz/internal/handler/LightThingHandler.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQxODo1Nzo0N1rOGXuXaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxNzozNjowM1rOGYWopg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUzMDA4OQ==", "bodyText": "one of these methods should be called unscaleColorTemperature. Also, these methods should be static.", "url": "https://github.com/openhab/openhab-addons/pull/7608#discussion_r427530089", "createdAt": "2020-05-19T18:57:47Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.deconz/src/main/java/org/openhab/binding/deconz/internal/handler/LightThingHandler.java", "diffHunk": "@@ -0,0 +1,314 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.deconz.internal.handler;\n+\n+import static org.openhab.binding.deconz.internal.BindingConstants.*;\n+\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.HSBType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.StopMoveType;\n+import org.eclipse.smarthome.core.library.types.UpDownType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.deconz.internal.dto.DeconzBaseMessage;\n+import org.openhab.binding.deconz.internal.dto.LightMessage;\n+import org.openhab.binding.deconz.internal.dto.LightState;\n+import org.openhab.binding.deconz.internal.netutils.AsyncHttpClient;\n+import org.openhab.binding.deconz.internal.netutils.WebSocketConnection;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * This light thing doesn't establish any connections, that is done by the bridge Thing.\n+ *\n+ * It waits for the bridge to come online, grab the websocket connection and bridge configuration\n+ * and registers to the websocket connection as a listener.\n+ *\n+ * A REST API call is made to get the initial light/rollershutter state.\n+ *\n+ * Every light and rollershutter is supported by this Thing, because a unified state is kept\n+ * in {@link #lightState}. Every field that got received by the REST API for this specific\n+ * sensor is published to the framework.\n+ *\n+ * @author Jan N. Klug - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LightThingHandler extends DeconzBaseThingHandler<LightMessage> {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPE_UIDS = Stream\n+            .of(THING_TYPE_COLOR_TEMPERATURE_LIGHT, THING_TYPE_DIMMABLE_LIGHT, THING_TYPE_COLOR_LIGHT,\n+                    THING_TYPE_EXTENDED_COLOR_LIGHT, THING_TYPE_ONOFF_LIGHT, THING_TYPE_WINDOW_COVERING)\n+            .collect(Collectors.toSet());\n+\n+    private static final double HUE_FACTOR = 65535 / 360.0;\n+    private static final double BRIGHTNESS_FACTOR = 2.54;\n+\n+    private final Logger logger = LoggerFactory.getLogger(LightThingHandler.class);\n+\n+    /**\n+     * The light state. Contains all possible fields for all supported lights\n+     */\n+    private LightState lightState = new LightState();\n+\n+    public LightThingHandler(Thing thing, Gson gson) {\n+        super(thing, gson);\n+    }\n+\n+    @Override\n+    protected void registerListener() {\n+        WebSocketConnection conn = connection;\n+        if (conn != null) {\n+            conn.registerLightListener(config.id, this);\n+        }\n+    }\n+\n+    @Override\n+    protected void unregisterListener() {\n+        WebSocketConnection conn = connection;\n+        if (conn != null) {\n+            conn.unregisterLightListener(config.id);\n+        }\n+    }\n+\n+    @Override\n+    protected void requestState() {\n+        requestState(\"lights\");\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannels(lightState);\n+            return;\n+        }\n+\n+        LightState newLightState = new LightState();\n+        Boolean currentOn = lightState.on;\n+        Integer currentBri = lightState.bri;\n+\n+        switch (channelUID.getId()) {\n+            case CHANNEL_SWITCH:\n+                if (command instanceof OnOffType) {\n+                    newLightState.on = (command == OnOffType.ON);\n+                } else {\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_BRIGHTNESS:\n+            case CHANNEL_COLOR:\n+                if (command instanceof OnOffType) {\n+                    newLightState.on = (command == OnOffType.ON);\n+                } else if (command instanceof HSBType) {\n+                    HSBType hsbCommand = (HSBType) command;\n+\n+                    if (\"xy\".equals(lightState.colormode)) {\n+                        PercentType[] xy = hsbCommand.toXY();\n+                        if (xy.length < 2) {\n+                            logger.warn(\"Failed to convert {} to xy-values\", command);\n+                        }\n+                        newLightState.xy = new Double[] { xy[0].doubleValue() / 100.0, xy[1].doubleValue() / 100.0 };\n+                    } else {\n+                        // default is colormode \"hs\" (used when colormode \"hs\" is set or colormode is unknown)\n+                        newLightState.bri = fromPercentType(hsbCommand.getBrightness());\n+                        newLightState.hue = (int) (hsbCommand.getHue().doubleValue() * HUE_FACTOR);\n+                        newLightState.sat = fromPercentType(hsbCommand.getSaturation());\n+                        break;\n+                    }\n+                } else if (command instanceof PercentType) {\n+                    newLightState.bri = fromPercentType((PercentType) command);\n+                } else if (command instanceof DecimalType) {\n+                    newLightState.bri = ((DecimalType) command).intValue();\n+                } else {\n+                    return;\n+                }\n+\n+                // send on/off state together with brightness if not already set or unknown\n+                Integer newBri = newLightState.bri;\n+                if ((newBri != null) && ((currentOn == null) || ((newBri > 0) != currentOn))) {\n+                    newLightState.on = (newBri > 0);\n+                }\n+\n+                // fix sending bri=0 when light is already off\n+                if (newBri != null && newBri == 0 && currentOn != null && !currentOn) {\n+                    return;\n+                }\n+\n+                Double transitiontime = config.transitiontime;\n+                if (transitiontime != null) {\n+                    // value is in 1/10 seconds\n+                    newLightState.transitiontime = (int) Math.round(10 * transitiontime);\n+                }\n+                break;\n+            case CHANNEL_COLOR_TEMPERATURE:\n+                if (command instanceof DecimalType) {\n+                    newLightState.colormode = \"ct\";\n+                    newLightState.ct = scaleColorTemperature(((DecimalType) command).doubleValue());\n+                } else {\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_POSITION:\n+                if (command instanceof UpDownType) {\n+                    newLightState.on = (command == UpDownType.DOWN);\n+                } else if (command == StopMoveType.STOP) {\n+                    if (currentOn != null && currentOn && currentBri != null && currentBri <= 254) {\n+                        // going down or currently stop (254 because of rounding error)\n+                        newLightState.on = true;\n+                    } else if (currentOn != null && !currentOn && currentBri != null && currentBri > 0) {\n+                        // going up or currently stopped\n+                        newLightState.on = false;\n+                    }\n+                } else if (command instanceof PercentType) {\n+                    newLightState.bri = fromPercentType((PercentType) command);\n+                } else {\n+                    return;\n+                }\n+                break;\n+            default:\n+                // no supported command\n+                return;\n+        }\n+\n+        AsyncHttpClient asyncHttpClient = http;\n+        if (asyncHttpClient == null) {\n+            return;\n+        }\n+        String url = buildUrl(bridgeConfig.host, bridgeConfig.httpPort, bridgeConfig.apikey, \"lights\", config.id,\n+                \"state\");\n+\n+        String json = gson.toJson(newLightState);\n+        logger.trace(\"Sending {} to light {} via {}\", json, config.id, url);\n+\n+        asyncHttpClient.put(url, json, bridgeConfig.timeout)\n+                .thenAccept(v -> logger.trace(\"Result code={}, body={}\", v.getResponseCode(), v.getBody()))\n+                .exceptionally(e -> {\n+                    logger.debug(\"Sending command {} to channel {} failed:\", command, channelUID, e);\n+                    return null;\n+                });\n+    }\n+\n+    @Override\n+    protected @Nullable LightMessage parseStateResponse(AsyncHttpClient.Result r) {\n+        if (r.getResponseCode() == 403) {\n+            return null;\n+        } else if (r.getResponseCode() == 200) {\n+            return gson.fromJson(r.getBody(), LightMessage.class);\n+        } else {\n+            throw new IllegalStateException(\"Unknown status code \" + r.getResponseCode() + \" for full state request\");\n+        }\n+    }\n+\n+    @Override\n+    protected void processStateResponse(@Nullable LightMessage stateResponse) {\n+        if (stateResponse == null) {\n+            return;\n+        }\n+        messageReceived(config.id, stateResponse);\n+\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    private void valueUpdated(String channelId, LightState newState) {\n+        Integer bri = newState.bri;\n+        Boolean on = newState.on;\n+\n+        switch (channelId) {\n+            case CHANNEL_SWITCH:\n+                if (on != null) {\n+                    updateState(channelId, OnOffType.from(on));\n+                }\n+                break;\n+            case CHANNEL_COLOR:\n+                Double @Nullable [] xy = newState.xy;\n+                Integer hue = newState.hue;\n+                Integer sat = newState.sat;\n+                if (hue != null && sat != null && bri != null) {\n+                    updateState(channelId,\n+                            new HSBType(new DecimalType(hue / HUE_FACTOR), toPercentType(sat), toPercentType(bri)));\n+                } else if (xy != null && xy.length == 2) {\n+                    updateState(channelId, HSBType.fromXY(xy[0].floatValue(), xy[1].floatValue()));\n+                }\n+                break;\n+            case CHANNEL_BRIGHTNESS:\n+                if (bri != null && on != null && on) {\n+                    updateState(channelId, toPercentType(bri));\n+                } else {\n+                    updateState(channelId, OnOffType.OFF);\n+                }\n+                break;\n+            case CHANNEL_COLOR_TEMPERATURE:\n+                Integer ct = newState.ct;\n+                if (ct != null) {\n+                    updateState(channelId, new DecimalType(scaleColorTemperature(ct)));\n+                }\n+                break;\n+            case CHANNEL_POSITION:\n+                if (bri != null) {\n+                    updateState(channelId, toPercentType(bri));\n+                }\n+            default:\n+        }\n+    }\n+\n+    private int scaleColorTemperature(double ct) {\n+        return (int) (ct / 100.0 * (500 - 153) + 153);\n+    }\n+\n+    private double scaleColorTemperature(int ct) {\n+        return 100.0 * (ct - 153) / (500 - 153);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d7caaa37b0ac85d6c9a8d76ab8267e7f7658063"}, "originalPosition": 282}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzk0OTc5MA==", "bodyText": "I adjusted the name but I would prefer to keep them non-static. Otherwise one could argue that toPercentType and fromPercentType should also be static. This would lead to a static logger and I think that is undesirable. Since they are only used within the handler, there is no need to make them static anyway.", "url": "https://github.com/openhab/openhab-addons/pull/7608#discussion_r427949790", "createdAt": "2020-05-20T11:55:51Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.deconz/src/main/java/org/openhab/binding/deconz/internal/handler/LightThingHandler.java", "diffHunk": "@@ -0,0 +1,314 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.deconz.internal.handler;\n+\n+import static org.openhab.binding.deconz.internal.BindingConstants.*;\n+\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.HSBType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.StopMoveType;\n+import org.eclipse.smarthome.core.library.types.UpDownType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.deconz.internal.dto.DeconzBaseMessage;\n+import org.openhab.binding.deconz.internal.dto.LightMessage;\n+import org.openhab.binding.deconz.internal.dto.LightState;\n+import org.openhab.binding.deconz.internal.netutils.AsyncHttpClient;\n+import org.openhab.binding.deconz.internal.netutils.WebSocketConnection;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * This light thing doesn't establish any connections, that is done by the bridge Thing.\n+ *\n+ * It waits for the bridge to come online, grab the websocket connection and bridge configuration\n+ * and registers to the websocket connection as a listener.\n+ *\n+ * A REST API call is made to get the initial light/rollershutter state.\n+ *\n+ * Every light and rollershutter is supported by this Thing, because a unified state is kept\n+ * in {@link #lightState}. Every field that got received by the REST API for this specific\n+ * sensor is published to the framework.\n+ *\n+ * @author Jan N. Klug - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LightThingHandler extends DeconzBaseThingHandler<LightMessage> {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPE_UIDS = Stream\n+            .of(THING_TYPE_COLOR_TEMPERATURE_LIGHT, THING_TYPE_DIMMABLE_LIGHT, THING_TYPE_COLOR_LIGHT,\n+                    THING_TYPE_EXTENDED_COLOR_LIGHT, THING_TYPE_ONOFF_LIGHT, THING_TYPE_WINDOW_COVERING)\n+            .collect(Collectors.toSet());\n+\n+    private static final double HUE_FACTOR = 65535 / 360.0;\n+    private static final double BRIGHTNESS_FACTOR = 2.54;\n+\n+    private final Logger logger = LoggerFactory.getLogger(LightThingHandler.class);\n+\n+    /**\n+     * The light state. Contains all possible fields for all supported lights\n+     */\n+    private LightState lightState = new LightState();\n+\n+    public LightThingHandler(Thing thing, Gson gson) {\n+        super(thing, gson);\n+    }\n+\n+    @Override\n+    protected void registerListener() {\n+        WebSocketConnection conn = connection;\n+        if (conn != null) {\n+            conn.registerLightListener(config.id, this);\n+        }\n+    }\n+\n+    @Override\n+    protected void unregisterListener() {\n+        WebSocketConnection conn = connection;\n+        if (conn != null) {\n+            conn.unregisterLightListener(config.id);\n+        }\n+    }\n+\n+    @Override\n+    protected void requestState() {\n+        requestState(\"lights\");\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannels(lightState);\n+            return;\n+        }\n+\n+        LightState newLightState = new LightState();\n+        Boolean currentOn = lightState.on;\n+        Integer currentBri = lightState.bri;\n+\n+        switch (channelUID.getId()) {\n+            case CHANNEL_SWITCH:\n+                if (command instanceof OnOffType) {\n+                    newLightState.on = (command == OnOffType.ON);\n+                } else {\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_BRIGHTNESS:\n+            case CHANNEL_COLOR:\n+                if (command instanceof OnOffType) {\n+                    newLightState.on = (command == OnOffType.ON);\n+                } else if (command instanceof HSBType) {\n+                    HSBType hsbCommand = (HSBType) command;\n+\n+                    if (\"xy\".equals(lightState.colormode)) {\n+                        PercentType[] xy = hsbCommand.toXY();\n+                        if (xy.length < 2) {\n+                            logger.warn(\"Failed to convert {} to xy-values\", command);\n+                        }\n+                        newLightState.xy = new Double[] { xy[0].doubleValue() / 100.0, xy[1].doubleValue() / 100.0 };\n+                    } else {\n+                        // default is colormode \"hs\" (used when colormode \"hs\" is set or colormode is unknown)\n+                        newLightState.bri = fromPercentType(hsbCommand.getBrightness());\n+                        newLightState.hue = (int) (hsbCommand.getHue().doubleValue() * HUE_FACTOR);\n+                        newLightState.sat = fromPercentType(hsbCommand.getSaturation());\n+                        break;\n+                    }\n+                } else if (command instanceof PercentType) {\n+                    newLightState.bri = fromPercentType((PercentType) command);\n+                } else if (command instanceof DecimalType) {\n+                    newLightState.bri = ((DecimalType) command).intValue();\n+                } else {\n+                    return;\n+                }\n+\n+                // send on/off state together with brightness if not already set or unknown\n+                Integer newBri = newLightState.bri;\n+                if ((newBri != null) && ((currentOn == null) || ((newBri > 0) != currentOn))) {\n+                    newLightState.on = (newBri > 0);\n+                }\n+\n+                // fix sending bri=0 when light is already off\n+                if (newBri != null && newBri == 0 && currentOn != null && !currentOn) {\n+                    return;\n+                }\n+\n+                Double transitiontime = config.transitiontime;\n+                if (transitiontime != null) {\n+                    // value is in 1/10 seconds\n+                    newLightState.transitiontime = (int) Math.round(10 * transitiontime);\n+                }\n+                break;\n+            case CHANNEL_COLOR_TEMPERATURE:\n+                if (command instanceof DecimalType) {\n+                    newLightState.colormode = \"ct\";\n+                    newLightState.ct = scaleColorTemperature(((DecimalType) command).doubleValue());\n+                } else {\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_POSITION:\n+                if (command instanceof UpDownType) {\n+                    newLightState.on = (command == UpDownType.DOWN);\n+                } else if (command == StopMoveType.STOP) {\n+                    if (currentOn != null && currentOn && currentBri != null && currentBri <= 254) {\n+                        // going down or currently stop (254 because of rounding error)\n+                        newLightState.on = true;\n+                    } else if (currentOn != null && !currentOn && currentBri != null && currentBri > 0) {\n+                        // going up or currently stopped\n+                        newLightState.on = false;\n+                    }\n+                } else if (command instanceof PercentType) {\n+                    newLightState.bri = fromPercentType((PercentType) command);\n+                } else {\n+                    return;\n+                }\n+                break;\n+            default:\n+                // no supported command\n+                return;\n+        }\n+\n+        AsyncHttpClient asyncHttpClient = http;\n+        if (asyncHttpClient == null) {\n+            return;\n+        }\n+        String url = buildUrl(bridgeConfig.host, bridgeConfig.httpPort, bridgeConfig.apikey, \"lights\", config.id,\n+                \"state\");\n+\n+        String json = gson.toJson(newLightState);\n+        logger.trace(\"Sending {} to light {} via {}\", json, config.id, url);\n+\n+        asyncHttpClient.put(url, json, bridgeConfig.timeout)\n+                .thenAccept(v -> logger.trace(\"Result code={}, body={}\", v.getResponseCode(), v.getBody()))\n+                .exceptionally(e -> {\n+                    logger.debug(\"Sending command {} to channel {} failed:\", command, channelUID, e);\n+                    return null;\n+                });\n+    }\n+\n+    @Override\n+    protected @Nullable LightMessage parseStateResponse(AsyncHttpClient.Result r) {\n+        if (r.getResponseCode() == 403) {\n+            return null;\n+        } else if (r.getResponseCode() == 200) {\n+            return gson.fromJson(r.getBody(), LightMessage.class);\n+        } else {\n+            throw new IllegalStateException(\"Unknown status code \" + r.getResponseCode() + \" for full state request\");\n+        }\n+    }\n+\n+    @Override\n+    protected void processStateResponse(@Nullable LightMessage stateResponse) {\n+        if (stateResponse == null) {\n+            return;\n+        }\n+        messageReceived(config.id, stateResponse);\n+\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    private void valueUpdated(String channelId, LightState newState) {\n+        Integer bri = newState.bri;\n+        Boolean on = newState.on;\n+\n+        switch (channelId) {\n+            case CHANNEL_SWITCH:\n+                if (on != null) {\n+                    updateState(channelId, OnOffType.from(on));\n+                }\n+                break;\n+            case CHANNEL_COLOR:\n+                Double @Nullable [] xy = newState.xy;\n+                Integer hue = newState.hue;\n+                Integer sat = newState.sat;\n+                if (hue != null && sat != null && bri != null) {\n+                    updateState(channelId,\n+                            new HSBType(new DecimalType(hue / HUE_FACTOR), toPercentType(sat), toPercentType(bri)));\n+                } else if (xy != null && xy.length == 2) {\n+                    updateState(channelId, HSBType.fromXY(xy[0].floatValue(), xy[1].floatValue()));\n+                }\n+                break;\n+            case CHANNEL_BRIGHTNESS:\n+                if (bri != null && on != null && on) {\n+                    updateState(channelId, toPercentType(bri));\n+                } else {\n+                    updateState(channelId, OnOffType.OFF);\n+                }\n+                break;\n+            case CHANNEL_COLOR_TEMPERATURE:\n+                Integer ct = newState.ct;\n+                if (ct != null) {\n+                    updateState(channelId, new DecimalType(scaleColorTemperature(ct)));\n+                }\n+                break;\n+            case CHANNEL_POSITION:\n+                if (bri != null) {\n+                    updateState(channelId, toPercentType(bri));\n+                }\n+            default:\n+        }\n+    }\n+\n+    private int scaleColorTemperature(double ct) {\n+        return (int) (ct / 100.0 * (500 - 153) + 153);\n+    }\n+\n+    private double scaleColorTemperature(int ct) {\n+        return 100.0 * (ct - 153) / (500 - 153);\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUzMDA4OQ=="}, "originalCommit": {"oid": "4d7caaa37b0ac85d6c9a8d76ab8267e7f7658063"}, "originalPosition": 282}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODE4OTg2Mg==", "bodyText": "fine by me", "url": "https://github.com/openhab/openhab-addons/pull/7608#discussion_r428189862", "createdAt": "2020-05-20T17:36:03Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.deconz/src/main/java/org/openhab/binding/deconz/internal/handler/LightThingHandler.java", "diffHunk": "@@ -0,0 +1,314 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.deconz.internal.handler;\n+\n+import static org.openhab.binding.deconz.internal.BindingConstants.*;\n+\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.HSBType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.StopMoveType;\n+import org.eclipse.smarthome.core.library.types.UpDownType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.deconz.internal.dto.DeconzBaseMessage;\n+import org.openhab.binding.deconz.internal.dto.LightMessage;\n+import org.openhab.binding.deconz.internal.dto.LightState;\n+import org.openhab.binding.deconz.internal.netutils.AsyncHttpClient;\n+import org.openhab.binding.deconz.internal.netutils.WebSocketConnection;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * This light thing doesn't establish any connections, that is done by the bridge Thing.\n+ *\n+ * It waits for the bridge to come online, grab the websocket connection and bridge configuration\n+ * and registers to the websocket connection as a listener.\n+ *\n+ * A REST API call is made to get the initial light/rollershutter state.\n+ *\n+ * Every light and rollershutter is supported by this Thing, because a unified state is kept\n+ * in {@link #lightState}. Every field that got received by the REST API for this specific\n+ * sensor is published to the framework.\n+ *\n+ * @author Jan N. Klug - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LightThingHandler extends DeconzBaseThingHandler<LightMessage> {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPE_UIDS = Stream\n+            .of(THING_TYPE_COLOR_TEMPERATURE_LIGHT, THING_TYPE_DIMMABLE_LIGHT, THING_TYPE_COLOR_LIGHT,\n+                    THING_TYPE_EXTENDED_COLOR_LIGHT, THING_TYPE_ONOFF_LIGHT, THING_TYPE_WINDOW_COVERING)\n+            .collect(Collectors.toSet());\n+\n+    private static final double HUE_FACTOR = 65535 / 360.0;\n+    private static final double BRIGHTNESS_FACTOR = 2.54;\n+\n+    private final Logger logger = LoggerFactory.getLogger(LightThingHandler.class);\n+\n+    /**\n+     * The light state. Contains all possible fields for all supported lights\n+     */\n+    private LightState lightState = new LightState();\n+\n+    public LightThingHandler(Thing thing, Gson gson) {\n+        super(thing, gson);\n+    }\n+\n+    @Override\n+    protected void registerListener() {\n+        WebSocketConnection conn = connection;\n+        if (conn != null) {\n+            conn.registerLightListener(config.id, this);\n+        }\n+    }\n+\n+    @Override\n+    protected void unregisterListener() {\n+        WebSocketConnection conn = connection;\n+        if (conn != null) {\n+            conn.unregisterLightListener(config.id);\n+        }\n+    }\n+\n+    @Override\n+    protected void requestState() {\n+        requestState(\"lights\");\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannels(lightState);\n+            return;\n+        }\n+\n+        LightState newLightState = new LightState();\n+        Boolean currentOn = lightState.on;\n+        Integer currentBri = lightState.bri;\n+\n+        switch (channelUID.getId()) {\n+            case CHANNEL_SWITCH:\n+                if (command instanceof OnOffType) {\n+                    newLightState.on = (command == OnOffType.ON);\n+                } else {\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_BRIGHTNESS:\n+            case CHANNEL_COLOR:\n+                if (command instanceof OnOffType) {\n+                    newLightState.on = (command == OnOffType.ON);\n+                } else if (command instanceof HSBType) {\n+                    HSBType hsbCommand = (HSBType) command;\n+\n+                    if (\"xy\".equals(lightState.colormode)) {\n+                        PercentType[] xy = hsbCommand.toXY();\n+                        if (xy.length < 2) {\n+                            logger.warn(\"Failed to convert {} to xy-values\", command);\n+                        }\n+                        newLightState.xy = new Double[] { xy[0].doubleValue() / 100.0, xy[1].doubleValue() / 100.0 };\n+                    } else {\n+                        // default is colormode \"hs\" (used when colormode \"hs\" is set or colormode is unknown)\n+                        newLightState.bri = fromPercentType(hsbCommand.getBrightness());\n+                        newLightState.hue = (int) (hsbCommand.getHue().doubleValue() * HUE_FACTOR);\n+                        newLightState.sat = fromPercentType(hsbCommand.getSaturation());\n+                        break;\n+                    }\n+                } else if (command instanceof PercentType) {\n+                    newLightState.bri = fromPercentType((PercentType) command);\n+                } else if (command instanceof DecimalType) {\n+                    newLightState.bri = ((DecimalType) command).intValue();\n+                } else {\n+                    return;\n+                }\n+\n+                // send on/off state together with brightness if not already set or unknown\n+                Integer newBri = newLightState.bri;\n+                if ((newBri != null) && ((currentOn == null) || ((newBri > 0) != currentOn))) {\n+                    newLightState.on = (newBri > 0);\n+                }\n+\n+                // fix sending bri=0 when light is already off\n+                if (newBri != null && newBri == 0 && currentOn != null && !currentOn) {\n+                    return;\n+                }\n+\n+                Double transitiontime = config.transitiontime;\n+                if (transitiontime != null) {\n+                    // value is in 1/10 seconds\n+                    newLightState.transitiontime = (int) Math.round(10 * transitiontime);\n+                }\n+                break;\n+            case CHANNEL_COLOR_TEMPERATURE:\n+                if (command instanceof DecimalType) {\n+                    newLightState.colormode = \"ct\";\n+                    newLightState.ct = scaleColorTemperature(((DecimalType) command).doubleValue());\n+                } else {\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_POSITION:\n+                if (command instanceof UpDownType) {\n+                    newLightState.on = (command == UpDownType.DOWN);\n+                } else if (command == StopMoveType.STOP) {\n+                    if (currentOn != null && currentOn && currentBri != null && currentBri <= 254) {\n+                        // going down or currently stop (254 because of rounding error)\n+                        newLightState.on = true;\n+                    } else if (currentOn != null && !currentOn && currentBri != null && currentBri > 0) {\n+                        // going up or currently stopped\n+                        newLightState.on = false;\n+                    }\n+                } else if (command instanceof PercentType) {\n+                    newLightState.bri = fromPercentType((PercentType) command);\n+                } else {\n+                    return;\n+                }\n+                break;\n+            default:\n+                // no supported command\n+                return;\n+        }\n+\n+        AsyncHttpClient asyncHttpClient = http;\n+        if (asyncHttpClient == null) {\n+            return;\n+        }\n+        String url = buildUrl(bridgeConfig.host, bridgeConfig.httpPort, bridgeConfig.apikey, \"lights\", config.id,\n+                \"state\");\n+\n+        String json = gson.toJson(newLightState);\n+        logger.trace(\"Sending {} to light {} via {}\", json, config.id, url);\n+\n+        asyncHttpClient.put(url, json, bridgeConfig.timeout)\n+                .thenAccept(v -> logger.trace(\"Result code={}, body={}\", v.getResponseCode(), v.getBody()))\n+                .exceptionally(e -> {\n+                    logger.debug(\"Sending command {} to channel {} failed:\", command, channelUID, e);\n+                    return null;\n+                });\n+    }\n+\n+    @Override\n+    protected @Nullable LightMessage parseStateResponse(AsyncHttpClient.Result r) {\n+        if (r.getResponseCode() == 403) {\n+            return null;\n+        } else if (r.getResponseCode() == 200) {\n+            return gson.fromJson(r.getBody(), LightMessage.class);\n+        } else {\n+            throw new IllegalStateException(\"Unknown status code \" + r.getResponseCode() + \" for full state request\");\n+        }\n+    }\n+\n+    @Override\n+    protected void processStateResponse(@Nullable LightMessage stateResponse) {\n+        if (stateResponse == null) {\n+            return;\n+        }\n+        messageReceived(config.id, stateResponse);\n+\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    private void valueUpdated(String channelId, LightState newState) {\n+        Integer bri = newState.bri;\n+        Boolean on = newState.on;\n+\n+        switch (channelId) {\n+            case CHANNEL_SWITCH:\n+                if (on != null) {\n+                    updateState(channelId, OnOffType.from(on));\n+                }\n+                break;\n+            case CHANNEL_COLOR:\n+                Double @Nullable [] xy = newState.xy;\n+                Integer hue = newState.hue;\n+                Integer sat = newState.sat;\n+                if (hue != null && sat != null && bri != null) {\n+                    updateState(channelId,\n+                            new HSBType(new DecimalType(hue / HUE_FACTOR), toPercentType(sat), toPercentType(bri)));\n+                } else if (xy != null && xy.length == 2) {\n+                    updateState(channelId, HSBType.fromXY(xy[0].floatValue(), xy[1].floatValue()));\n+                }\n+                break;\n+            case CHANNEL_BRIGHTNESS:\n+                if (bri != null && on != null && on) {\n+                    updateState(channelId, toPercentType(bri));\n+                } else {\n+                    updateState(channelId, OnOffType.OFF);\n+                }\n+                break;\n+            case CHANNEL_COLOR_TEMPERATURE:\n+                Integer ct = newState.ct;\n+                if (ct != null) {\n+                    updateState(channelId, new DecimalType(scaleColorTemperature(ct)));\n+                }\n+                break;\n+            case CHANNEL_POSITION:\n+                if (bri != null) {\n+                    updateState(channelId, toPercentType(bri));\n+                }\n+            default:\n+        }\n+    }\n+\n+    private int scaleColorTemperature(double ct) {\n+        return (int) (ct / 100.0 * (500 - 153) + 153);\n+    }\n+\n+    private double scaleColorTemperature(int ct) {\n+        return 100.0 * (ct - 153) / (500 - 153);\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzUzMDA4OQ=="}, "originalCommit": {"oid": "4d7caaa37b0ac85d6c9a8d76ab8267e7f7658063"}, "originalPosition": 282}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MzA1OTMyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.deconz/src/main/java/org/openhab/binding/deconz/internal/handler/LightThingHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQyMDo1NDo1M1rOGXyRFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQyMDo1NDo1M1rOGXyRFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU5NDAwNg==", "bodyText": "I think in this case you have to set newLightState.bri as well, because you use it below to figure out whether to send on off command as well.", "url": "https://github.com/openhab/openhab-addons/pull/7608#discussion_r427594006", "createdAt": "2020-05-19T20:54:53Z", "author": {"login": "DerOetzi"}, "path": "bundles/org.openhab.binding.deconz/src/main/java/org/openhab/binding/deconz/internal/handler/LightThingHandler.java", "diffHunk": "@@ -0,0 +1,314 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.deconz.internal.handler;\n+\n+import static org.openhab.binding.deconz.internal.BindingConstants.*;\n+\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.HSBType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.StopMoveType;\n+import org.eclipse.smarthome.core.library.types.UpDownType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.deconz.internal.dto.DeconzBaseMessage;\n+import org.openhab.binding.deconz.internal.dto.LightMessage;\n+import org.openhab.binding.deconz.internal.dto.LightState;\n+import org.openhab.binding.deconz.internal.netutils.AsyncHttpClient;\n+import org.openhab.binding.deconz.internal.netutils.WebSocketConnection;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * This light thing doesn't establish any connections, that is done by the bridge Thing.\n+ *\n+ * It waits for the bridge to come online, grab the websocket connection and bridge configuration\n+ * and registers to the websocket connection as a listener.\n+ *\n+ * A REST API call is made to get the initial light/rollershutter state.\n+ *\n+ * Every light and rollershutter is supported by this Thing, because a unified state is kept\n+ * in {@link #lightState}. Every field that got received by the REST API for this specific\n+ * sensor is published to the framework.\n+ *\n+ * @author Jan N. Klug - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LightThingHandler extends DeconzBaseThingHandler<LightMessage> {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPE_UIDS = Stream\n+            .of(THING_TYPE_COLOR_TEMPERATURE_LIGHT, THING_TYPE_DIMMABLE_LIGHT, THING_TYPE_COLOR_LIGHT,\n+                    THING_TYPE_EXTENDED_COLOR_LIGHT, THING_TYPE_ONOFF_LIGHT, THING_TYPE_WINDOW_COVERING)\n+            .collect(Collectors.toSet());\n+\n+    private static final double HUE_FACTOR = 65535 / 360.0;\n+    private static final double BRIGHTNESS_FACTOR = 2.54;\n+\n+    private final Logger logger = LoggerFactory.getLogger(LightThingHandler.class);\n+\n+    /**\n+     * The light state. Contains all possible fields for all supported lights\n+     */\n+    private LightState lightState = new LightState();\n+\n+    public LightThingHandler(Thing thing, Gson gson) {\n+        super(thing, gson);\n+    }\n+\n+    @Override\n+    protected void registerListener() {\n+        WebSocketConnection conn = connection;\n+        if (conn != null) {\n+            conn.registerLightListener(config.id, this);\n+        }\n+    }\n+\n+    @Override\n+    protected void unregisterListener() {\n+        WebSocketConnection conn = connection;\n+        if (conn != null) {\n+            conn.unregisterLightListener(config.id);\n+        }\n+    }\n+\n+    @Override\n+    protected void requestState() {\n+        requestState(\"lights\");\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannels(lightState);\n+            return;\n+        }\n+\n+        LightState newLightState = new LightState();\n+        Boolean currentOn = lightState.on;\n+        Integer currentBri = lightState.bri;\n+\n+        switch (channelUID.getId()) {\n+            case CHANNEL_SWITCH:\n+                if (command instanceof OnOffType) {\n+                    newLightState.on = (command == OnOffType.ON);\n+                } else {\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_BRIGHTNESS:\n+            case CHANNEL_COLOR:\n+                if (command instanceof OnOffType) {\n+                    newLightState.on = (command == OnOffType.ON);\n+                } else if (command instanceof HSBType) {\n+                    HSBType hsbCommand = (HSBType) command;\n+\n+                    if (\"xy\".equals(lightState.colormode)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d7caaa37b0ac85d6c9a8d76ab8267e7f7658063"}, "originalPosition": 127}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2MzA2NDUzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.deconz/src/main/java/org/openhab/binding/deconz/internal/handler/LightThingHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xOVQyMDo1NjoyOFrOGXyUcw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNFQxOTowNzo1N1rOGZwuHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU5NDg2Nw==", "bodyText": "Is not set in every needed context, see comment above", "url": "https://github.com/openhab/openhab-addons/pull/7608#discussion_r427594867", "createdAt": "2020-05-19T20:56:28Z", "author": {"login": "DerOetzi"}, "path": "bundles/org.openhab.binding.deconz/src/main/java/org/openhab/binding/deconz/internal/handler/LightThingHandler.java", "diffHunk": "@@ -0,0 +1,314 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.deconz.internal.handler;\n+\n+import static org.openhab.binding.deconz.internal.BindingConstants.*;\n+\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.HSBType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.StopMoveType;\n+import org.eclipse.smarthome.core.library.types.UpDownType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.deconz.internal.dto.DeconzBaseMessage;\n+import org.openhab.binding.deconz.internal.dto.LightMessage;\n+import org.openhab.binding.deconz.internal.dto.LightState;\n+import org.openhab.binding.deconz.internal.netutils.AsyncHttpClient;\n+import org.openhab.binding.deconz.internal.netutils.WebSocketConnection;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * This light thing doesn't establish any connections, that is done by the bridge Thing.\n+ *\n+ * It waits for the bridge to come online, grab the websocket connection and bridge configuration\n+ * and registers to the websocket connection as a listener.\n+ *\n+ * A REST API call is made to get the initial light/rollershutter state.\n+ *\n+ * Every light and rollershutter is supported by this Thing, because a unified state is kept\n+ * in {@link #lightState}. Every field that got received by the REST API for this specific\n+ * sensor is published to the framework.\n+ *\n+ * @author Jan N. Klug - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LightThingHandler extends DeconzBaseThingHandler<LightMessage> {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPE_UIDS = Stream\n+            .of(THING_TYPE_COLOR_TEMPERATURE_LIGHT, THING_TYPE_DIMMABLE_LIGHT, THING_TYPE_COLOR_LIGHT,\n+                    THING_TYPE_EXTENDED_COLOR_LIGHT, THING_TYPE_ONOFF_LIGHT, THING_TYPE_WINDOW_COVERING)\n+            .collect(Collectors.toSet());\n+\n+    private static final double HUE_FACTOR = 65535 / 360.0;\n+    private static final double BRIGHTNESS_FACTOR = 2.54;\n+\n+    private final Logger logger = LoggerFactory.getLogger(LightThingHandler.class);\n+\n+    /**\n+     * The light state. Contains all possible fields for all supported lights\n+     */\n+    private LightState lightState = new LightState();\n+\n+    public LightThingHandler(Thing thing, Gson gson) {\n+        super(thing, gson);\n+    }\n+\n+    @Override\n+    protected void registerListener() {\n+        WebSocketConnection conn = connection;\n+        if (conn != null) {\n+            conn.registerLightListener(config.id, this);\n+        }\n+    }\n+\n+    @Override\n+    protected void unregisterListener() {\n+        WebSocketConnection conn = connection;\n+        if (conn != null) {\n+            conn.unregisterLightListener(config.id);\n+        }\n+    }\n+\n+    @Override\n+    protected void requestState() {\n+        requestState(\"lights\");\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannels(lightState);\n+            return;\n+        }\n+\n+        LightState newLightState = new LightState();\n+        Boolean currentOn = lightState.on;\n+        Integer currentBri = lightState.bri;\n+\n+        switch (channelUID.getId()) {\n+            case CHANNEL_SWITCH:\n+                if (command instanceof OnOffType) {\n+                    newLightState.on = (command == OnOffType.ON);\n+                } else {\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_BRIGHTNESS:\n+            case CHANNEL_COLOR:\n+                if (command instanceof OnOffType) {\n+                    newLightState.on = (command == OnOffType.ON);\n+                } else if (command instanceof HSBType) {\n+                    HSBType hsbCommand = (HSBType) command;\n+\n+                    if (\"xy\".equals(lightState.colormode)) {\n+                        PercentType[] xy = hsbCommand.toXY();\n+                        if (xy.length < 2) {\n+                            logger.warn(\"Failed to convert {} to xy-values\", command);\n+                        }\n+                        newLightState.xy = new Double[] { xy[0].doubleValue() / 100.0, xy[1].doubleValue() / 100.0 };\n+                    } else {\n+                        // default is colormode \"hs\" (used when colormode \"hs\" is set or colormode is unknown)\n+                        newLightState.bri = fromPercentType(hsbCommand.getBrightness());\n+                        newLightState.hue = (int) (hsbCommand.getHue().doubleValue() * HUE_FACTOR);\n+                        newLightState.sat = fromPercentType(hsbCommand.getSaturation());\n+                        break;\n+                    }\n+                } else if (command instanceof PercentType) {\n+                    newLightState.bri = fromPercentType((PercentType) command);\n+                } else if (command instanceof DecimalType) {\n+                    newLightState.bri = ((DecimalType) command).intValue();\n+                } else {\n+                    return;\n+                }\n+\n+                // send on/off state together with brightness if not already set or unknown\n+                Integer newBri = newLightState.bri;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4d7caaa37b0ac85d6c9a8d76ab8267e7f7658063"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTY2NTgyMQ==", "bodyText": "Hi,\nstill have problems with version -3 and extendedcolorlight:\n21:02:46.081 [INFO ] [smarthome.event.ItemCommandEvent     ] - Item 'colorHSBVitrineWohnzimmer' received command 17,100,100\n21:02:46.118 [TRACE] [nz.internal.handler.LightThingHandler] - Sending {\"bri\":254,\"xy\":[0.6034406,0.35905895]} to light 21 via http://deconz:80/api/57867F89A9/lights/21/state\n21:02:46.156 [TRACE] [nz.internal.handler.LightThingHandler] - Result code=200, body=[{\"error\":{\"address\":\"/lights/21\",\"description\":\"parameter, /lights/21/bri, is not modifiable. Device is set to off.\",\"type\":201}},{\"error\":{\"address\":\"/lights/21\",\"description\":\"parameter, /lights/21/xy, is not modifiable. Device is set to off.\",\"type\":201}}]", "url": "https://github.com/openhab/openhab-addons/pull/7608#discussion_r429665821", "createdAt": "2020-05-24T19:07:57Z", "author": {"login": "DerOetzi"}, "path": "bundles/org.openhab.binding.deconz/src/main/java/org/openhab/binding/deconz/internal/handler/LightThingHandler.java", "diffHunk": "@@ -0,0 +1,314 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.deconz.internal.handler;\n+\n+import static org.openhab.binding.deconz.internal.BindingConstants.*;\n+\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.HSBType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.StopMoveType;\n+import org.eclipse.smarthome.core.library.types.UpDownType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.deconz.internal.dto.DeconzBaseMessage;\n+import org.openhab.binding.deconz.internal.dto.LightMessage;\n+import org.openhab.binding.deconz.internal.dto.LightState;\n+import org.openhab.binding.deconz.internal.netutils.AsyncHttpClient;\n+import org.openhab.binding.deconz.internal.netutils.WebSocketConnection;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * This light thing doesn't establish any connections, that is done by the bridge Thing.\n+ *\n+ * It waits for the bridge to come online, grab the websocket connection and bridge configuration\n+ * and registers to the websocket connection as a listener.\n+ *\n+ * A REST API call is made to get the initial light/rollershutter state.\n+ *\n+ * Every light and rollershutter is supported by this Thing, because a unified state is kept\n+ * in {@link #lightState}. Every field that got received by the REST API for this specific\n+ * sensor is published to the framework.\n+ *\n+ * @author Jan N. Klug - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LightThingHandler extends DeconzBaseThingHandler<LightMessage> {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPE_UIDS = Stream\n+            .of(THING_TYPE_COLOR_TEMPERATURE_LIGHT, THING_TYPE_DIMMABLE_LIGHT, THING_TYPE_COLOR_LIGHT,\n+                    THING_TYPE_EXTENDED_COLOR_LIGHT, THING_TYPE_ONOFF_LIGHT, THING_TYPE_WINDOW_COVERING)\n+            .collect(Collectors.toSet());\n+\n+    private static final double HUE_FACTOR = 65535 / 360.0;\n+    private static final double BRIGHTNESS_FACTOR = 2.54;\n+\n+    private final Logger logger = LoggerFactory.getLogger(LightThingHandler.class);\n+\n+    /**\n+     * The light state. Contains all possible fields for all supported lights\n+     */\n+    private LightState lightState = new LightState();\n+\n+    public LightThingHandler(Thing thing, Gson gson) {\n+        super(thing, gson);\n+    }\n+\n+    @Override\n+    protected void registerListener() {\n+        WebSocketConnection conn = connection;\n+        if (conn != null) {\n+            conn.registerLightListener(config.id, this);\n+        }\n+    }\n+\n+    @Override\n+    protected void unregisterListener() {\n+        WebSocketConnection conn = connection;\n+        if (conn != null) {\n+            conn.unregisterLightListener(config.id);\n+        }\n+    }\n+\n+    @Override\n+    protected void requestState() {\n+        requestState(\"lights\");\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            updateChannels(lightState);\n+            return;\n+        }\n+\n+        LightState newLightState = new LightState();\n+        Boolean currentOn = lightState.on;\n+        Integer currentBri = lightState.bri;\n+\n+        switch (channelUID.getId()) {\n+            case CHANNEL_SWITCH:\n+                if (command instanceof OnOffType) {\n+                    newLightState.on = (command == OnOffType.ON);\n+                } else {\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_BRIGHTNESS:\n+            case CHANNEL_COLOR:\n+                if (command instanceof OnOffType) {\n+                    newLightState.on = (command == OnOffType.ON);\n+                } else if (command instanceof HSBType) {\n+                    HSBType hsbCommand = (HSBType) command;\n+\n+                    if (\"xy\".equals(lightState.colormode)) {\n+                        PercentType[] xy = hsbCommand.toXY();\n+                        if (xy.length < 2) {\n+                            logger.warn(\"Failed to convert {} to xy-values\", command);\n+                        }\n+                        newLightState.xy = new Double[] { xy[0].doubleValue() / 100.0, xy[1].doubleValue() / 100.0 };\n+                    } else {\n+                        // default is colormode \"hs\" (used when colormode \"hs\" is set or colormode is unknown)\n+                        newLightState.bri = fromPercentType(hsbCommand.getBrightness());\n+                        newLightState.hue = (int) (hsbCommand.getHue().doubleValue() * HUE_FACTOR);\n+                        newLightState.sat = fromPercentType(hsbCommand.getSaturation());\n+                        break;\n+                    }\n+                } else if (command instanceof PercentType) {\n+                    newLightState.bri = fromPercentType((PercentType) command);\n+                } else if (command instanceof DecimalType) {\n+                    newLightState.bri = ((DecimalType) command).intValue();\n+                } else {\n+                    return;\n+                }\n+\n+                // send on/off state together with brightness if not already set or unknown\n+                Integer newBri = newLightState.bri;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU5NDg2Nw=="}, "originalCommit": {"oid": "4d7caaa37b0ac85d6c9a8d76ab8267e7f7658063"}, "originalPosition": 149}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MDk2NDgyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.deconz/src/main/resources/ESH-INF/config/config.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxOTozMzowNlrOGZAB7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQyMDowMTowMFrOGZA5Xw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg2ODA3Nw==", "bodyText": "As far as I understood the REST API documentation the transition time is only used if \"effect\" is activated. So it is only needed if also a channel for \"effect\" exists.", "url": "https://github.com/openhab/openhab-addons/pull/7608#discussion_r428868077", "createdAt": "2020-05-21T19:33:06Z", "author": {"login": "MHerbst"}, "path": "bundles/org.openhab.binding.deconz/src/main/resources/ESH-INF/config/config.xml", "diffHunk": "@@ -36,8 +36,20 @@\n \n \t<config-description uri=\"thing-type:deconz:sensor\">\n \t\t<parameter name=\"id\" type=\"text\" required=\"true\">\n-\t\t\t<label>Sensor ID</label>\n-\t\t\t<description>The deCONZ bridge assigns an integer number ID to each sensor.</description>\n+\t\t\t<label>Device ID</label>\n+\t\t\t<description>The deCONZ bridge assigns an integer number ID to each device.</description>\n+\t\t</parameter>\n+\t</config-description>\n+\n+\n+\t<config-description uri=\"thing-type:deconz:light\">\n+\t\t<parameter name=\"id\" type=\"text\" required=\"true\">\n+\t\t\t<label>Device ID</label>\n+\t\t\t<description>The deCONZ bridge assigns an integer number ID to each device.</description>\n+\t\t</parameter>\n+\t\t<parameter name=\"transitiontime\" type=\"decimal\" required=\"false\" min=\"0\" unit=\"s\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8b3031cd8d18ce22e04d0799f3d108142d13e52d"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg4MjI3MQ==", "bodyText": "I tried it with a dimmable IKEA bulb and it takes 20s to turn it on if I send 200 together with the brightness, so no matter what the documentation says, it works", "url": "https://github.com/openhab/openhab-addons/pull/7608#discussion_r428882271", "createdAt": "2020-05-21T20:01:00Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.deconz/src/main/resources/ESH-INF/config/config.xml", "diffHunk": "@@ -36,8 +36,20 @@\n \n \t<config-description uri=\"thing-type:deconz:sensor\">\n \t\t<parameter name=\"id\" type=\"text\" required=\"true\">\n-\t\t\t<label>Sensor ID</label>\n-\t\t\t<description>The deCONZ bridge assigns an integer number ID to each sensor.</description>\n+\t\t\t<label>Device ID</label>\n+\t\t\t<description>The deCONZ bridge assigns an integer number ID to each device.</description>\n+\t\t</parameter>\n+\t</config-description>\n+\n+\n+\t<config-description uri=\"thing-type:deconz:light\">\n+\t\t<parameter name=\"id\" type=\"text\" required=\"true\">\n+\t\t\t<label>Device ID</label>\n+\t\t\t<description>The deCONZ bridge assigns an integer number ID to each device.</description>\n+\t\t</parameter>\n+\t\t<parameter name=\"transitiontime\" type=\"decimal\" required=\"false\" min=\"0\" unit=\"s\">", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg2ODA3Nw=="}, "originalCommit": {"oid": "8b3031cd8d18ce22e04d0799f3d108142d13e52d"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NTUzNDA1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.deconz/src/main/java/org/openhab/binding/deconz/internal/BindingConstants.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QyMjoyMDozMVrOGZrpCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNFQwODoxNDo1NlrOGZtY8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU4MjYwMw==", "bodyText": "Why is this method in the BindingConstants class? Can you move it to a utility class instead?", "url": "https://github.com/openhab/openhab-addons/pull/7608#discussion_r429582603", "createdAt": "2020-05-23T22:20:31Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.deconz/src/main/java/org/openhab/binding/deconz/internal/BindingConstants.java", "diffHunk": "@@ -81,23 +105,15 @@\n \n     public static final String UNIQUE_ID = \"uid\";\n \n-    public static String url(String host, int port, @Nullable String apikey, @Nullable String endpointType,\n-            @Nullable String endpointID) {\n+    public static String buildUrl(String host, int port, String... urlParts) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f130544d486fa530126f78f42e682e25a11e678"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTYxMTI1MQ==", "bodyText": "Moved. I  just kept it where it was.", "url": "https://github.com/openhab/openhab-addons/pull/7608#discussion_r429611251", "createdAt": "2020-05-24T08:14:56Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.deconz/src/main/java/org/openhab/binding/deconz/internal/BindingConstants.java", "diffHunk": "@@ -81,23 +105,15 @@\n \n     public static final String UNIQUE_ID = \"uid\";\n \n-    public static String url(String host, int port, @Nullable String apikey, @Nullable String endpointType,\n-            @Nullable String endpointID) {\n+    public static String buildUrl(String host, int port, String... urlParts) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU4MjYwMw=="}, "originalCommit": {"oid": "1f130544d486fa530126f78f42e682e25a11e678"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NTUzNjMwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.deconz/src/main/java/org/openhab/binding/deconz/internal/dto/LightState.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QyMjoyNjoxMFrOGZrqPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QyMjoyNjoxMFrOGZrqPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU4MjkxMQ==", "bodyText": "Any reason you couldn't make the array primitive? public double @Nullable[] xy; should be valid.", "url": "https://github.com/openhab/openhab-addons/pull/7608#discussion_r429582911", "createdAt": "2020-05-23T22:26:10Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.deconz/src/main/java/org/openhab/binding/deconz/internal/dto/LightState.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.deconz.internal.dto;\n+\n+import java.util.Arrays;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link LightState} is send by the websocket connection as well as the Rest API.\n+ * It is part of a {@link LightMessage}.\n+ *\n+ * This should be in sync with the supported lights from\n+ * https://github.com/dresden-elektronik/deconz-rest-plugin/wiki/Supported-Devices.\n+ *\n+ * @author Jan N. Klug - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LightState {\n+    public @Nullable Boolean reachable;\n+    public @Nullable Boolean on;\n+    public @Nullable Integer bri;\n+\n+    public @Nullable String alert;\n+    public @Nullable String colormode;\n+    public @Nullable String effect;\n+\n+    // depending on the type of light\n+    public @Nullable Integer hue;\n+    public @Nullable Integer sat;\n+    public @Nullable Integer ct;\n+    public Double @Nullable [] xy;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f130544d486fa530126f78f42e682e25a11e678"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NTU0MDY2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.deconz/src/main/java/org/openhab/binding/deconz/internal/handler/LightThingHandler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QyMjozNzoxN1rOGZrsiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNFQwODoxNToyOVrOGZtZJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU4MzQ5Nw==", "bodyText": "brightness is both a PercentType and an OnOffType?", "url": "https://github.com/openhab/openhab-addons/pull/7608#discussion_r429583497", "createdAt": "2020-05-23T22:37:17Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.deconz/src/main/java/org/openhab/binding/deconz/internal/handler/LightThingHandler.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.deconz.internal.handler;\n+\n+import static org.openhab.binding.deconz.internal.BindingConstants.*;\n+\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.HSBType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.StopMoveType;\n+import org.eclipse.smarthome.core.library.types.UpDownType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.deconz.internal.dto.DeconzBaseMessage;\n+import org.openhab.binding.deconz.internal.dto.LightMessage;\n+import org.openhab.binding.deconz.internal.dto.LightState;\n+import org.openhab.binding.deconz.internal.netutils.AsyncHttpClient;\n+import org.openhab.binding.deconz.internal.netutils.WebSocketConnection;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * This light thing doesn't establish any connections, that is done by the bridge Thing.\n+ *\n+ * It waits for the bridge to come online, grab the websocket connection and bridge configuration\n+ * and registers to the websocket connection as a listener.\n+ *\n+ * A REST API call is made to get the initial light/rollershutter state.\n+ *\n+ * Every light and rollershutter is supported by this Thing, because a unified state is kept\n+ * in {@link #lightStateCache}. Every field that got received by the REST API for this specific\n+ * sensor is published to the framework.\n+ *\n+ * @author Jan N. Klug - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LightThingHandler extends DeconzBaseThingHandler<LightMessage> {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPE_UIDS = Stream\n+            .of(THING_TYPE_COLOR_TEMPERATURE_LIGHT, THING_TYPE_DIMMABLE_LIGHT, THING_TYPE_COLOR_LIGHT,\n+                    THING_TYPE_EXTENDED_COLOR_LIGHT, THING_TYPE_ONOFF_LIGHT, THING_TYPE_WINDOW_COVERING)\n+            .collect(Collectors.toSet());\n+\n+    private static final double HUE_FACTOR = 65535 / 360.0;\n+    private static final double BRIGHTNESS_FACTOR = 2.54;\n+    private static final long SKIP_UPDATE_TIMESPAN = 500; // in ms\n+\n+    private final Logger logger = LoggerFactory.getLogger(LightThingHandler.class);\n+\n+    private long lastCommandTimestamp = 0;\n+\n+    /**\n+     * The light state. Contains all possible fields for all supported lights\n+     */\n+    private LightState lightStateCache = new LightState();\n+    private LightState lastCommand = new LightState();\n+\n+    public LightThingHandler(Thing thing, Gson gson) {\n+        super(thing, gson);\n+    }\n+\n+    @Override\n+    protected void registerListener() {\n+        WebSocketConnection conn = connection;\n+        if (conn != null) {\n+            conn.registerLightListener(config.id, this);\n+        }\n+    }\n+\n+    @Override\n+    protected void unregisterListener() {\n+        WebSocketConnection conn = connection;\n+        if (conn != null) {\n+            conn.unregisterLightListener(config.id);\n+        }\n+    }\n+\n+    @Override\n+    protected void requestState() {\n+        requestState(\"lights\");\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            valueUpdated(channelUID.getId(), lightStateCache);\n+            return;\n+        }\n+\n+        LightState newLightState = new LightState();\n+        Boolean currentOn = lightStateCache.on;\n+        Integer currentBri = lightStateCache.bri;\n+\n+        switch (channelUID.getId()) {\n+            case CHANNEL_SWITCH:\n+                if (command instanceof OnOffType) {\n+                    newLightState.on = (command == OnOffType.ON);\n+                } else {\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_BRIGHTNESS:\n+            case CHANNEL_COLOR:\n+                if (command instanceof OnOffType) {\n+                    newLightState.on = (command == OnOffType.ON);\n+                } else if (command instanceof HSBType) {\n+                    HSBType hsbCommand = (HSBType) command;\n+\n+                    if (\"xy\".equals(lightStateCache.colormode)) {\n+                        PercentType[] xy = hsbCommand.toXY();\n+                        if (xy.length < 2) {\n+                            logger.warn(\"Failed to convert {} to xy-values\", command);\n+                        }\n+                        newLightState.xy = new Double[] { xy[0].doubleValue() / 100.0, xy[1].doubleValue() / 100.0 };\n+                        newLightState.bri = fromPercentType(hsbCommand.getBrightness());\n+                    } else {\n+                        // default is colormode \"hs\" (used when colormode \"hs\" is set or colormode is unknown)\n+                        newLightState.bri = fromPercentType(hsbCommand.getBrightness());\n+                        newLightState.hue = (int) (hsbCommand.getHue().doubleValue() * HUE_FACTOR);\n+                        newLightState.sat = fromPercentType(hsbCommand.getSaturation());\n+                    }\n+                } else if (command instanceof PercentType) {\n+                    newLightState.bri = fromPercentType((PercentType) command);\n+                } else if (command instanceof DecimalType) {\n+                    newLightState.bri = ((DecimalType) command).intValue();\n+                } else {\n+                    return;\n+                }\n+\n+                // send on/off state together with brightness if not already set or unknown\n+                Integer newBri = newLightState.bri;\n+                if ((newBri != null) && ((currentOn == null) || ((newBri > 0) != currentOn))) {\n+                    newLightState.on = (newBri > 0);\n+                }\n+\n+                // fix sending bri=0 when light is already off\n+                if (newBri != null && newBri == 0 && currentOn != null && !currentOn) {\n+                    return;\n+                }\n+\n+                Double transitiontime = config.transitiontime;\n+                if (transitiontime != null) {\n+                    // value is in 1/10 seconds\n+                    newLightState.transitiontime = (int) Math.round(10 * transitiontime);\n+                }\n+                break;\n+            case CHANNEL_COLOR_TEMPERATURE:\n+                if (command instanceof DecimalType) {\n+                    newLightState.colormode = \"ct\";\n+                    newLightState.ct = unscaleColorTemperature(((DecimalType) command).doubleValue());\n+                } else {\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_POSITION:\n+                if (command instanceof UpDownType) {\n+                    newLightState.on = (command == UpDownType.DOWN);\n+                } else if (command == StopMoveType.STOP) {\n+                    if (currentOn != null && currentOn && currentBri != null && currentBri <= 254) {\n+                        // going down or currently stop (254 because of rounding error)\n+                        newLightState.on = true;\n+                    } else if (currentOn != null && !currentOn && currentBri != null && currentBri > 0) {\n+                        // going up or currently stopped\n+                        newLightState.on = false;\n+                    }\n+                } else if (command instanceof PercentType) {\n+                    newLightState.bri = fromPercentType((PercentType) command);\n+                } else {\n+                    return;\n+                }\n+                break;\n+            default:\n+                // no supported command\n+                return;\n+        }\n+\n+        AsyncHttpClient asyncHttpClient = http;\n+        if (asyncHttpClient == null) {\n+            return;\n+        }\n+        String url = buildUrl(bridgeConfig.host, bridgeConfig.httpPort, bridgeConfig.apikey, \"lights\", config.id,\n+                \"state\");\n+\n+        String json = gson.toJson(newLightState);\n+        logger.trace(\"Sending {} to light {} via {}\", json, config.id, url);\n+\n+        asyncHttpClient.put(url, json, bridgeConfig.timeout).thenAccept(v -> {\n+            lastCommandTimestamp = System.currentTimeMillis();\n+            lastCommand = newLightState;\n+            logger.trace(\"Result code={}, body={}\", v.getResponseCode(), v.getBody());\n+        }).exceptionally(e -> {\n+            logger.debug(\"Sending command {} to channel {} failed:\", command, channelUID, e);\n+            return null;\n+        });\n+    }\n+\n+    @Override\n+    protected @Nullable LightMessage parseStateResponse(AsyncHttpClient.Result r) {\n+        if (r.getResponseCode() == 403) {\n+            return null;\n+        } else if (r.getResponseCode() == 200) {\n+            return gson.fromJson(r.getBody(), LightMessage.class);\n+        } else {\n+            throw new IllegalStateException(\"Unknown status code \" + r.getResponseCode() + \" for full state request\");\n+        }\n+    }\n+\n+    @Override\n+    protected void processStateResponse(@Nullable LightMessage stateResponse) {\n+        if (stateResponse == null) {\n+            return;\n+        }\n+        messageReceived(config.id, stateResponse);\n+\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    private void valueUpdated(String channelId, LightState newState) {\n+        Integer bri = newState.bri;\n+        Boolean on = newState.on;\n+\n+        switch (channelId) {\n+            case CHANNEL_SWITCH:\n+                if (on != null) {\n+                    updateState(channelId, OnOffType.from(on));\n+                }\n+                break;\n+            case CHANNEL_COLOR:\n+                Double @Nullable [] xy = newState.xy;\n+                Integer hue = newState.hue;\n+                Integer sat = newState.sat;\n+                if (hue != null && sat != null && bri != null) {\n+                    updateState(channelId,\n+                            new HSBType(new DecimalType(hue / HUE_FACTOR), toPercentType(sat), toPercentType(bri)));\n+                } else if (xy != null && xy.length == 2) {\n+                    updateState(channelId, HSBType.fromXY(xy[0].floatValue(), xy[1].floatValue()));\n+                }\n+                break;\n+            case CHANNEL_BRIGHTNESS:\n+                if (bri != null && on != null && on) {\n+                    updateState(channelId, toPercentType(bri));\n+                } else {\n+                    updateState(channelId, OnOffType.OFF);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f130544d486fa530126f78f42e682e25a11e678"}, "originalPosition": 265}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTYxMTMwMw==", "bodyText": "Both commands are valid, it's a Dimmer.", "url": "https://github.com/openhab/openhab-addons/pull/7608#discussion_r429611303", "createdAt": "2020-05-24T08:15:29Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.deconz/src/main/java/org/openhab/binding/deconz/internal/handler/LightThingHandler.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.deconz.internal.handler;\n+\n+import static org.openhab.binding.deconz.internal.BindingConstants.*;\n+\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.HSBType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.StopMoveType;\n+import org.eclipse.smarthome.core.library.types.UpDownType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.deconz.internal.dto.DeconzBaseMessage;\n+import org.openhab.binding.deconz.internal.dto.LightMessage;\n+import org.openhab.binding.deconz.internal.dto.LightState;\n+import org.openhab.binding.deconz.internal.netutils.AsyncHttpClient;\n+import org.openhab.binding.deconz.internal.netutils.WebSocketConnection;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * This light thing doesn't establish any connections, that is done by the bridge Thing.\n+ *\n+ * It waits for the bridge to come online, grab the websocket connection and bridge configuration\n+ * and registers to the websocket connection as a listener.\n+ *\n+ * A REST API call is made to get the initial light/rollershutter state.\n+ *\n+ * Every light and rollershutter is supported by this Thing, because a unified state is kept\n+ * in {@link #lightStateCache}. Every field that got received by the REST API for this specific\n+ * sensor is published to the framework.\n+ *\n+ * @author Jan N. Klug - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LightThingHandler extends DeconzBaseThingHandler<LightMessage> {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPE_UIDS = Stream\n+            .of(THING_TYPE_COLOR_TEMPERATURE_LIGHT, THING_TYPE_DIMMABLE_LIGHT, THING_TYPE_COLOR_LIGHT,\n+                    THING_TYPE_EXTENDED_COLOR_LIGHT, THING_TYPE_ONOFF_LIGHT, THING_TYPE_WINDOW_COVERING)\n+            .collect(Collectors.toSet());\n+\n+    private static final double HUE_FACTOR = 65535 / 360.0;\n+    private static final double BRIGHTNESS_FACTOR = 2.54;\n+    private static final long SKIP_UPDATE_TIMESPAN = 500; // in ms\n+\n+    private final Logger logger = LoggerFactory.getLogger(LightThingHandler.class);\n+\n+    private long lastCommandTimestamp = 0;\n+\n+    /**\n+     * The light state. Contains all possible fields for all supported lights\n+     */\n+    private LightState lightStateCache = new LightState();\n+    private LightState lastCommand = new LightState();\n+\n+    public LightThingHandler(Thing thing, Gson gson) {\n+        super(thing, gson);\n+    }\n+\n+    @Override\n+    protected void registerListener() {\n+        WebSocketConnection conn = connection;\n+        if (conn != null) {\n+            conn.registerLightListener(config.id, this);\n+        }\n+    }\n+\n+    @Override\n+    protected void unregisterListener() {\n+        WebSocketConnection conn = connection;\n+        if (conn != null) {\n+            conn.unregisterLightListener(config.id);\n+        }\n+    }\n+\n+    @Override\n+    protected void requestState() {\n+        requestState(\"lights\");\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            valueUpdated(channelUID.getId(), lightStateCache);\n+            return;\n+        }\n+\n+        LightState newLightState = new LightState();\n+        Boolean currentOn = lightStateCache.on;\n+        Integer currentBri = lightStateCache.bri;\n+\n+        switch (channelUID.getId()) {\n+            case CHANNEL_SWITCH:\n+                if (command instanceof OnOffType) {\n+                    newLightState.on = (command == OnOffType.ON);\n+                } else {\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_BRIGHTNESS:\n+            case CHANNEL_COLOR:\n+                if (command instanceof OnOffType) {\n+                    newLightState.on = (command == OnOffType.ON);\n+                } else if (command instanceof HSBType) {\n+                    HSBType hsbCommand = (HSBType) command;\n+\n+                    if (\"xy\".equals(lightStateCache.colormode)) {\n+                        PercentType[] xy = hsbCommand.toXY();\n+                        if (xy.length < 2) {\n+                            logger.warn(\"Failed to convert {} to xy-values\", command);\n+                        }\n+                        newLightState.xy = new Double[] { xy[0].doubleValue() / 100.0, xy[1].doubleValue() / 100.0 };\n+                        newLightState.bri = fromPercentType(hsbCommand.getBrightness());\n+                    } else {\n+                        // default is colormode \"hs\" (used when colormode \"hs\" is set or colormode is unknown)\n+                        newLightState.bri = fromPercentType(hsbCommand.getBrightness());\n+                        newLightState.hue = (int) (hsbCommand.getHue().doubleValue() * HUE_FACTOR);\n+                        newLightState.sat = fromPercentType(hsbCommand.getSaturation());\n+                    }\n+                } else if (command instanceof PercentType) {\n+                    newLightState.bri = fromPercentType((PercentType) command);\n+                } else if (command instanceof DecimalType) {\n+                    newLightState.bri = ((DecimalType) command).intValue();\n+                } else {\n+                    return;\n+                }\n+\n+                // send on/off state together with brightness if not already set or unknown\n+                Integer newBri = newLightState.bri;\n+                if ((newBri != null) && ((currentOn == null) || ((newBri > 0) != currentOn))) {\n+                    newLightState.on = (newBri > 0);\n+                }\n+\n+                // fix sending bri=0 when light is already off\n+                if (newBri != null && newBri == 0 && currentOn != null && !currentOn) {\n+                    return;\n+                }\n+\n+                Double transitiontime = config.transitiontime;\n+                if (transitiontime != null) {\n+                    // value is in 1/10 seconds\n+                    newLightState.transitiontime = (int) Math.round(10 * transitiontime);\n+                }\n+                break;\n+            case CHANNEL_COLOR_TEMPERATURE:\n+                if (command instanceof DecimalType) {\n+                    newLightState.colormode = \"ct\";\n+                    newLightState.ct = unscaleColorTemperature(((DecimalType) command).doubleValue());\n+                } else {\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_POSITION:\n+                if (command instanceof UpDownType) {\n+                    newLightState.on = (command == UpDownType.DOWN);\n+                } else if (command == StopMoveType.STOP) {\n+                    if (currentOn != null && currentOn && currentBri != null && currentBri <= 254) {\n+                        // going down or currently stop (254 because of rounding error)\n+                        newLightState.on = true;\n+                    } else if (currentOn != null && !currentOn && currentBri != null && currentBri > 0) {\n+                        // going up or currently stopped\n+                        newLightState.on = false;\n+                    }\n+                } else if (command instanceof PercentType) {\n+                    newLightState.bri = fromPercentType((PercentType) command);\n+                } else {\n+                    return;\n+                }\n+                break;\n+            default:\n+                // no supported command\n+                return;\n+        }\n+\n+        AsyncHttpClient asyncHttpClient = http;\n+        if (asyncHttpClient == null) {\n+            return;\n+        }\n+        String url = buildUrl(bridgeConfig.host, bridgeConfig.httpPort, bridgeConfig.apikey, \"lights\", config.id,\n+                \"state\");\n+\n+        String json = gson.toJson(newLightState);\n+        logger.trace(\"Sending {} to light {} via {}\", json, config.id, url);\n+\n+        asyncHttpClient.put(url, json, bridgeConfig.timeout).thenAccept(v -> {\n+            lastCommandTimestamp = System.currentTimeMillis();\n+            lastCommand = newLightState;\n+            logger.trace(\"Result code={}, body={}\", v.getResponseCode(), v.getBody());\n+        }).exceptionally(e -> {\n+            logger.debug(\"Sending command {} to channel {} failed:\", command, channelUID, e);\n+            return null;\n+        });\n+    }\n+\n+    @Override\n+    protected @Nullable LightMessage parseStateResponse(AsyncHttpClient.Result r) {\n+        if (r.getResponseCode() == 403) {\n+            return null;\n+        } else if (r.getResponseCode() == 200) {\n+            return gson.fromJson(r.getBody(), LightMessage.class);\n+        } else {\n+            throw new IllegalStateException(\"Unknown status code \" + r.getResponseCode() + \" for full state request\");\n+        }\n+    }\n+\n+    @Override\n+    protected void processStateResponse(@Nullable LightMessage stateResponse) {\n+        if (stateResponse == null) {\n+            return;\n+        }\n+        messageReceived(config.id, stateResponse);\n+\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    private void valueUpdated(String channelId, LightState newState) {\n+        Integer bri = newState.bri;\n+        Boolean on = newState.on;\n+\n+        switch (channelId) {\n+            case CHANNEL_SWITCH:\n+                if (on != null) {\n+                    updateState(channelId, OnOffType.from(on));\n+                }\n+                break;\n+            case CHANNEL_COLOR:\n+                Double @Nullable [] xy = newState.xy;\n+                Integer hue = newState.hue;\n+                Integer sat = newState.sat;\n+                if (hue != null && sat != null && bri != null) {\n+                    updateState(channelId,\n+                            new HSBType(new DecimalType(hue / HUE_FACTOR), toPercentType(sat), toPercentType(bri)));\n+                } else if (xy != null && xy.length == 2) {\n+                    updateState(channelId, HSBType.fromXY(xy[0].floatValue(), xy[1].floatValue()));\n+                }\n+                break;\n+            case CHANNEL_BRIGHTNESS:\n+                if (bri != null && on != null && on) {\n+                    updateState(channelId, toPercentType(bri));\n+                } else {\n+                    updateState(channelId, OnOffType.OFF);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU4MzQ5Nw=="}, "originalCommit": {"oid": "1f130544d486fa530126f78f42e682e25a11e678"}, "originalPosition": 265}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3NTU0MTE2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.deconz/src/main/java/org/openhab/binding/deconz/internal/handler/LightThingHandler.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yM1QyMjozODoxN1rOGZrsww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yNFQwODoxNjoxN1rOGZtZZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU4MzU1NQ==", "bodyText": "This is the same as brightness?", "url": "https://github.com/openhab/openhab-addons/pull/7608#discussion_r429583555", "createdAt": "2020-05-23T22:38:17Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.deconz/src/main/java/org/openhab/binding/deconz/internal/handler/LightThingHandler.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.deconz.internal.handler;\n+\n+import static org.openhab.binding.deconz.internal.BindingConstants.*;\n+\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.HSBType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.StopMoveType;\n+import org.eclipse.smarthome.core.library.types.UpDownType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.deconz.internal.dto.DeconzBaseMessage;\n+import org.openhab.binding.deconz.internal.dto.LightMessage;\n+import org.openhab.binding.deconz.internal.dto.LightState;\n+import org.openhab.binding.deconz.internal.netutils.AsyncHttpClient;\n+import org.openhab.binding.deconz.internal.netutils.WebSocketConnection;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * This light thing doesn't establish any connections, that is done by the bridge Thing.\n+ *\n+ * It waits for the bridge to come online, grab the websocket connection and bridge configuration\n+ * and registers to the websocket connection as a listener.\n+ *\n+ * A REST API call is made to get the initial light/rollershutter state.\n+ *\n+ * Every light and rollershutter is supported by this Thing, because a unified state is kept\n+ * in {@link #lightStateCache}. Every field that got received by the REST API for this specific\n+ * sensor is published to the framework.\n+ *\n+ * @author Jan N. Klug - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LightThingHandler extends DeconzBaseThingHandler<LightMessage> {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPE_UIDS = Stream\n+            .of(THING_TYPE_COLOR_TEMPERATURE_LIGHT, THING_TYPE_DIMMABLE_LIGHT, THING_TYPE_COLOR_LIGHT,\n+                    THING_TYPE_EXTENDED_COLOR_LIGHT, THING_TYPE_ONOFF_LIGHT, THING_TYPE_WINDOW_COVERING)\n+            .collect(Collectors.toSet());\n+\n+    private static final double HUE_FACTOR = 65535 / 360.0;\n+    private static final double BRIGHTNESS_FACTOR = 2.54;\n+    private static final long SKIP_UPDATE_TIMESPAN = 500; // in ms\n+\n+    private final Logger logger = LoggerFactory.getLogger(LightThingHandler.class);\n+\n+    private long lastCommandTimestamp = 0;\n+\n+    /**\n+     * The light state. Contains all possible fields for all supported lights\n+     */\n+    private LightState lightStateCache = new LightState();\n+    private LightState lastCommand = new LightState();\n+\n+    public LightThingHandler(Thing thing, Gson gson) {\n+        super(thing, gson);\n+    }\n+\n+    @Override\n+    protected void registerListener() {\n+        WebSocketConnection conn = connection;\n+        if (conn != null) {\n+            conn.registerLightListener(config.id, this);\n+        }\n+    }\n+\n+    @Override\n+    protected void unregisterListener() {\n+        WebSocketConnection conn = connection;\n+        if (conn != null) {\n+            conn.unregisterLightListener(config.id);\n+        }\n+    }\n+\n+    @Override\n+    protected void requestState() {\n+        requestState(\"lights\");\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            valueUpdated(channelUID.getId(), lightStateCache);\n+            return;\n+        }\n+\n+        LightState newLightState = new LightState();\n+        Boolean currentOn = lightStateCache.on;\n+        Integer currentBri = lightStateCache.bri;\n+\n+        switch (channelUID.getId()) {\n+            case CHANNEL_SWITCH:\n+                if (command instanceof OnOffType) {\n+                    newLightState.on = (command == OnOffType.ON);\n+                } else {\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_BRIGHTNESS:\n+            case CHANNEL_COLOR:\n+                if (command instanceof OnOffType) {\n+                    newLightState.on = (command == OnOffType.ON);\n+                } else if (command instanceof HSBType) {\n+                    HSBType hsbCommand = (HSBType) command;\n+\n+                    if (\"xy\".equals(lightStateCache.colormode)) {\n+                        PercentType[] xy = hsbCommand.toXY();\n+                        if (xy.length < 2) {\n+                            logger.warn(\"Failed to convert {} to xy-values\", command);\n+                        }\n+                        newLightState.xy = new Double[] { xy[0].doubleValue() / 100.0, xy[1].doubleValue() / 100.0 };\n+                        newLightState.bri = fromPercentType(hsbCommand.getBrightness());\n+                    } else {\n+                        // default is colormode \"hs\" (used when colormode \"hs\" is set or colormode is unknown)\n+                        newLightState.bri = fromPercentType(hsbCommand.getBrightness());\n+                        newLightState.hue = (int) (hsbCommand.getHue().doubleValue() * HUE_FACTOR);\n+                        newLightState.sat = fromPercentType(hsbCommand.getSaturation());\n+                    }\n+                } else if (command instanceof PercentType) {\n+                    newLightState.bri = fromPercentType((PercentType) command);\n+                } else if (command instanceof DecimalType) {\n+                    newLightState.bri = ((DecimalType) command).intValue();\n+                } else {\n+                    return;\n+                }\n+\n+                // send on/off state together with brightness if not already set or unknown\n+                Integer newBri = newLightState.bri;\n+                if ((newBri != null) && ((currentOn == null) || ((newBri > 0) != currentOn))) {\n+                    newLightState.on = (newBri > 0);\n+                }\n+\n+                // fix sending bri=0 when light is already off\n+                if (newBri != null && newBri == 0 && currentOn != null && !currentOn) {\n+                    return;\n+                }\n+\n+                Double transitiontime = config.transitiontime;\n+                if (transitiontime != null) {\n+                    // value is in 1/10 seconds\n+                    newLightState.transitiontime = (int) Math.round(10 * transitiontime);\n+                }\n+                break;\n+            case CHANNEL_COLOR_TEMPERATURE:\n+                if (command instanceof DecimalType) {\n+                    newLightState.colormode = \"ct\";\n+                    newLightState.ct = unscaleColorTemperature(((DecimalType) command).doubleValue());\n+                } else {\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_POSITION:\n+                if (command instanceof UpDownType) {\n+                    newLightState.on = (command == UpDownType.DOWN);\n+                } else if (command == StopMoveType.STOP) {\n+                    if (currentOn != null && currentOn && currentBri != null && currentBri <= 254) {\n+                        // going down or currently stop (254 because of rounding error)\n+                        newLightState.on = true;\n+                    } else if (currentOn != null && !currentOn && currentBri != null && currentBri > 0) {\n+                        // going up or currently stopped\n+                        newLightState.on = false;\n+                    }\n+                } else if (command instanceof PercentType) {\n+                    newLightState.bri = fromPercentType((PercentType) command);\n+                } else {\n+                    return;\n+                }\n+                break;\n+            default:\n+                // no supported command\n+                return;\n+        }\n+\n+        AsyncHttpClient asyncHttpClient = http;\n+        if (asyncHttpClient == null) {\n+            return;\n+        }\n+        String url = buildUrl(bridgeConfig.host, bridgeConfig.httpPort, bridgeConfig.apikey, \"lights\", config.id,\n+                \"state\");\n+\n+        String json = gson.toJson(newLightState);\n+        logger.trace(\"Sending {} to light {} via {}\", json, config.id, url);\n+\n+        asyncHttpClient.put(url, json, bridgeConfig.timeout).thenAccept(v -> {\n+            lastCommandTimestamp = System.currentTimeMillis();\n+            lastCommand = newLightState;\n+            logger.trace(\"Result code={}, body={}\", v.getResponseCode(), v.getBody());\n+        }).exceptionally(e -> {\n+            logger.debug(\"Sending command {} to channel {} failed:\", command, channelUID, e);\n+            return null;\n+        });\n+    }\n+\n+    @Override\n+    protected @Nullable LightMessage parseStateResponse(AsyncHttpClient.Result r) {\n+        if (r.getResponseCode() == 403) {\n+            return null;\n+        } else if (r.getResponseCode() == 200) {\n+            return gson.fromJson(r.getBody(), LightMessage.class);\n+        } else {\n+            throw new IllegalStateException(\"Unknown status code \" + r.getResponseCode() + \" for full state request\");\n+        }\n+    }\n+\n+    @Override\n+    protected void processStateResponse(@Nullable LightMessage stateResponse) {\n+        if (stateResponse == null) {\n+            return;\n+        }\n+        messageReceived(config.id, stateResponse);\n+\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    private void valueUpdated(String channelId, LightState newState) {\n+        Integer bri = newState.bri;\n+        Boolean on = newState.on;\n+\n+        switch (channelId) {\n+            case CHANNEL_SWITCH:\n+                if (on != null) {\n+                    updateState(channelId, OnOffType.from(on));\n+                }\n+                break;\n+            case CHANNEL_COLOR:\n+                Double @Nullable [] xy = newState.xy;\n+                Integer hue = newState.hue;\n+                Integer sat = newState.sat;\n+                if (hue != null && sat != null && bri != null) {\n+                    updateState(channelId,\n+                            new HSBType(new DecimalType(hue / HUE_FACTOR), toPercentType(sat), toPercentType(bri)));\n+                } else if (xy != null && xy.length == 2) {\n+                    updateState(channelId, HSBType.fromXY(xy[0].floatValue(), xy[1].floatValue()));\n+                }\n+                break;\n+            case CHANNEL_BRIGHTNESS:\n+                if (bri != null && on != null && on) {\n+                    updateState(channelId, toPercentType(bri));\n+                } else {\n+                    updateState(channelId, OnOffType.OFF);\n+                }\n+                break;\n+            case CHANNEL_COLOR_TEMPERATURE:\n+                Integer ct = newState.ct;\n+                if (ct != null) {\n+                    updateState(channelId, new DecimalType(scaleColorTemperature(ct)));\n+                }\n+                break;\n+            case CHANNEL_POSITION:\n+                if (bri != null) {\n+                    updateState(channelId, toPercentType(bri));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f130544d486fa530126f78f42e682e25a11e678"}, "originalPosition": 276}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTYxMTM2Nw==", "bodyText": "Yes. Blinds are modelled as lights in the deconz REST API and the position is set and reported as brightness.", "url": "https://github.com/openhab/openhab-addons/pull/7608#discussion_r429611367", "createdAt": "2020-05-24T08:16:17Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.deconz/src/main/java/org/openhab/binding/deconz/internal/handler/LightThingHandler.java", "diffHunk": "@@ -0,0 +1,322 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.deconz.internal.handler;\n+\n+import static org.openhab.binding.deconz.internal.BindingConstants.*;\n+\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.HSBType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.PercentType;\n+import org.eclipse.smarthome.core.library.types.StopMoveType;\n+import org.eclipse.smarthome.core.library.types.UpDownType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.deconz.internal.dto.DeconzBaseMessage;\n+import org.openhab.binding.deconz.internal.dto.LightMessage;\n+import org.openhab.binding.deconz.internal.dto.LightState;\n+import org.openhab.binding.deconz.internal.netutils.AsyncHttpClient;\n+import org.openhab.binding.deconz.internal.netutils.WebSocketConnection;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+\n+/**\n+ * This light thing doesn't establish any connections, that is done by the bridge Thing.\n+ *\n+ * It waits for the bridge to come online, grab the websocket connection and bridge configuration\n+ * and registers to the websocket connection as a listener.\n+ *\n+ * A REST API call is made to get the initial light/rollershutter state.\n+ *\n+ * Every light and rollershutter is supported by this Thing, because a unified state is kept\n+ * in {@link #lightStateCache}. Every field that got received by the REST API for this specific\n+ * sensor is published to the framework.\n+ *\n+ * @author Jan N. Klug - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LightThingHandler extends DeconzBaseThingHandler<LightMessage> {\n+    public static final Set<ThingTypeUID> SUPPORTED_THING_TYPE_UIDS = Stream\n+            .of(THING_TYPE_COLOR_TEMPERATURE_LIGHT, THING_TYPE_DIMMABLE_LIGHT, THING_TYPE_COLOR_LIGHT,\n+                    THING_TYPE_EXTENDED_COLOR_LIGHT, THING_TYPE_ONOFF_LIGHT, THING_TYPE_WINDOW_COVERING)\n+            .collect(Collectors.toSet());\n+\n+    private static final double HUE_FACTOR = 65535 / 360.0;\n+    private static final double BRIGHTNESS_FACTOR = 2.54;\n+    private static final long SKIP_UPDATE_TIMESPAN = 500; // in ms\n+\n+    private final Logger logger = LoggerFactory.getLogger(LightThingHandler.class);\n+\n+    private long lastCommandTimestamp = 0;\n+\n+    /**\n+     * The light state. Contains all possible fields for all supported lights\n+     */\n+    private LightState lightStateCache = new LightState();\n+    private LightState lastCommand = new LightState();\n+\n+    public LightThingHandler(Thing thing, Gson gson) {\n+        super(thing, gson);\n+    }\n+\n+    @Override\n+    protected void registerListener() {\n+        WebSocketConnection conn = connection;\n+        if (conn != null) {\n+            conn.registerLightListener(config.id, this);\n+        }\n+    }\n+\n+    @Override\n+    protected void unregisterListener() {\n+        WebSocketConnection conn = connection;\n+        if (conn != null) {\n+            conn.unregisterLightListener(config.id);\n+        }\n+    }\n+\n+    @Override\n+    protected void requestState() {\n+        requestState(\"lights\");\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            valueUpdated(channelUID.getId(), lightStateCache);\n+            return;\n+        }\n+\n+        LightState newLightState = new LightState();\n+        Boolean currentOn = lightStateCache.on;\n+        Integer currentBri = lightStateCache.bri;\n+\n+        switch (channelUID.getId()) {\n+            case CHANNEL_SWITCH:\n+                if (command instanceof OnOffType) {\n+                    newLightState.on = (command == OnOffType.ON);\n+                } else {\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_BRIGHTNESS:\n+            case CHANNEL_COLOR:\n+                if (command instanceof OnOffType) {\n+                    newLightState.on = (command == OnOffType.ON);\n+                } else if (command instanceof HSBType) {\n+                    HSBType hsbCommand = (HSBType) command;\n+\n+                    if (\"xy\".equals(lightStateCache.colormode)) {\n+                        PercentType[] xy = hsbCommand.toXY();\n+                        if (xy.length < 2) {\n+                            logger.warn(\"Failed to convert {} to xy-values\", command);\n+                        }\n+                        newLightState.xy = new Double[] { xy[0].doubleValue() / 100.0, xy[1].doubleValue() / 100.0 };\n+                        newLightState.bri = fromPercentType(hsbCommand.getBrightness());\n+                    } else {\n+                        // default is colormode \"hs\" (used when colormode \"hs\" is set or colormode is unknown)\n+                        newLightState.bri = fromPercentType(hsbCommand.getBrightness());\n+                        newLightState.hue = (int) (hsbCommand.getHue().doubleValue() * HUE_FACTOR);\n+                        newLightState.sat = fromPercentType(hsbCommand.getSaturation());\n+                    }\n+                } else if (command instanceof PercentType) {\n+                    newLightState.bri = fromPercentType((PercentType) command);\n+                } else if (command instanceof DecimalType) {\n+                    newLightState.bri = ((DecimalType) command).intValue();\n+                } else {\n+                    return;\n+                }\n+\n+                // send on/off state together with brightness if not already set or unknown\n+                Integer newBri = newLightState.bri;\n+                if ((newBri != null) && ((currentOn == null) || ((newBri > 0) != currentOn))) {\n+                    newLightState.on = (newBri > 0);\n+                }\n+\n+                // fix sending bri=0 when light is already off\n+                if (newBri != null && newBri == 0 && currentOn != null && !currentOn) {\n+                    return;\n+                }\n+\n+                Double transitiontime = config.transitiontime;\n+                if (transitiontime != null) {\n+                    // value is in 1/10 seconds\n+                    newLightState.transitiontime = (int) Math.round(10 * transitiontime);\n+                }\n+                break;\n+            case CHANNEL_COLOR_TEMPERATURE:\n+                if (command instanceof DecimalType) {\n+                    newLightState.colormode = \"ct\";\n+                    newLightState.ct = unscaleColorTemperature(((DecimalType) command).doubleValue());\n+                } else {\n+                    return;\n+                }\n+                break;\n+            case CHANNEL_POSITION:\n+                if (command instanceof UpDownType) {\n+                    newLightState.on = (command == UpDownType.DOWN);\n+                } else if (command == StopMoveType.STOP) {\n+                    if (currentOn != null && currentOn && currentBri != null && currentBri <= 254) {\n+                        // going down or currently stop (254 because of rounding error)\n+                        newLightState.on = true;\n+                    } else if (currentOn != null && !currentOn && currentBri != null && currentBri > 0) {\n+                        // going up or currently stopped\n+                        newLightState.on = false;\n+                    }\n+                } else if (command instanceof PercentType) {\n+                    newLightState.bri = fromPercentType((PercentType) command);\n+                } else {\n+                    return;\n+                }\n+                break;\n+            default:\n+                // no supported command\n+                return;\n+        }\n+\n+        AsyncHttpClient asyncHttpClient = http;\n+        if (asyncHttpClient == null) {\n+            return;\n+        }\n+        String url = buildUrl(bridgeConfig.host, bridgeConfig.httpPort, bridgeConfig.apikey, \"lights\", config.id,\n+                \"state\");\n+\n+        String json = gson.toJson(newLightState);\n+        logger.trace(\"Sending {} to light {} via {}\", json, config.id, url);\n+\n+        asyncHttpClient.put(url, json, bridgeConfig.timeout).thenAccept(v -> {\n+            lastCommandTimestamp = System.currentTimeMillis();\n+            lastCommand = newLightState;\n+            logger.trace(\"Result code={}, body={}\", v.getResponseCode(), v.getBody());\n+        }).exceptionally(e -> {\n+            logger.debug(\"Sending command {} to channel {} failed:\", command, channelUID, e);\n+            return null;\n+        });\n+    }\n+\n+    @Override\n+    protected @Nullable LightMessage parseStateResponse(AsyncHttpClient.Result r) {\n+        if (r.getResponseCode() == 403) {\n+            return null;\n+        } else if (r.getResponseCode() == 200) {\n+            return gson.fromJson(r.getBody(), LightMessage.class);\n+        } else {\n+            throw new IllegalStateException(\"Unknown status code \" + r.getResponseCode() + \" for full state request\");\n+        }\n+    }\n+\n+    @Override\n+    protected void processStateResponse(@Nullable LightMessage stateResponse) {\n+        if (stateResponse == null) {\n+            return;\n+        }\n+        messageReceived(config.id, stateResponse);\n+\n+        updateStatus(ThingStatus.ONLINE);\n+    }\n+\n+    private void valueUpdated(String channelId, LightState newState) {\n+        Integer bri = newState.bri;\n+        Boolean on = newState.on;\n+\n+        switch (channelId) {\n+            case CHANNEL_SWITCH:\n+                if (on != null) {\n+                    updateState(channelId, OnOffType.from(on));\n+                }\n+                break;\n+            case CHANNEL_COLOR:\n+                Double @Nullable [] xy = newState.xy;\n+                Integer hue = newState.hue;\n+                Integer sat = newState.sat;\n+                if (hue != null && sat != null && bri != null) {\n+                    updateState(channelId,\n+                            new HSBType(new DecimalType(hue / HUE_FACTOR), toPercentType(sat), toPercentType(bri)));\n+                } else if (xy != null && xy.length == 2) {\n+                    updateState(channelId, HSBType.fromXY(xy[0].floatValue(), xy[1].floatValue()));\n+                }\n+                break;\n+            case CHANNEL_BRIGHTNESS:\n+                if (bri != null && on != null && on) {\n+                    updateState(channelId, toPercentType(bri));\n+                } else {\n+                    updateState(channelId, OnOffType.OFF);\n+                }\n+                break;\n+            case CHANNEL_COLOR_TEMPERATURE:\n+                Integer ct = newState.ct;\n+                if (ct != null) {\n+                    updateState(channelId, new DecimalType(scaleColorTemperature(ct)));\n+                }\n+                break;\n+            case CHANNEL_POSITION:\n+                if (bri != null) {\n+                    updateState(channelId, toPercentType(bri));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTU4MzU1NQ=="}, "originalCommit": {"oid": "1f130544d486fa530126f78f42e682e25a11e678"}, "originalPosition": 276}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 216, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}