{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM4MzIwMzU3", "number": 9347, "reviewThreads": {"totalCount": 20, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yNVQxNDo0Mzo1MVrOFJKSyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNFQwNzowMjozOVrOFWh7vw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ1MTUwMTU0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.myq/pom.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yNVQxNDo0Mzo1MVrOILdAyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yNVQxNDo0Mzo1MVrOILdAyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODg4MDU4NA==", "bodyText": "To make the binding compile, you need to rebase your branch and set the version to the upcoming openHAB version: 3.1.0-SNAPSHOT.\nHere are the commands for rebasing your branch:\nIf not already done, add the upstream openHAB addon repo as a remote to your local repo and fetch it:\ngit remote add upstream https://github.com/openhab/openhab-addons.git\ngit fetch upstream\n\nThen, you can rebase your PR's branch onto main:\ngit rebase upstream/main\n\nFinally force-push the rebased branch to this PR's branch:\ngit push origin [your branch name of this PR] --force-with-lease", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r548880584", "createdAt": "2020-12-25T14:43:51Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.myq/pom.xml", "diffHunk": "@@ -0,0 +1,17 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+\n+  <modelVersion>4.0.0</modelVersion>\n+\n+  <parent>\n+    <groupId>org.openhab.addons.bundles</groupId>\n+    <artifactId>org.openhab.addons.reactor.bundles</artifactId>\n+    <version>3.0.0-SNAPSHOT</version>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60c6511faa1e1fcbd41f73e9e8958a14616a024b"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4MDEwMDA0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.myq/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMDoxNTozOFrOIPU0vQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMDoxNTozOFrOIPU0vQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk0MDczMw==", "bodyText": "Same for below.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            ThingTypeUID:`account`\n          \n          \n            \n            ThingTypeUID: `account`", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r552940733", "createdAt": "2021-01-06T20:15:38Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.myq/README.md", "diffHunk": "@@ -0,0 +1,71 @@\n+# MyQ Binding\n+\n+This binding integrates with the [The Chamberlain Group MyQ](https://www.myq.com) cloud service. It allows monitoring and control over [MyQ](https://www.myq.com) enabled garage doors manufactured by LiftMaster, Chamberlain and Craftsman.\n+\n+## Supported Things\n+\n+### Account\n+\n+This represents the MyQ cloud account and uses the same credentials needed when using the MyQ mobile application.\n+\n+ThingTypeUID:`account`", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b5c229bfaec596e8fe209df3946faf55db8b6b9d"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4MDEwMDU3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.myq/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMDoxNTo0OVrOIPU1BQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMDoxNTo0OVrOIPU1BQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk0MDgwNQ==", "bodyText": "Same for below.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            This represents a garage door associated with an account.  Multiple garage doors are supported.\n          \n          \n            \n            This represents a garage door associated with an account. Multiple garage doors are supported.", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r552940805", "createdAt": "2021-01-06T20:15:49Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.myq/README.md", "diffHunk": "@@ -0,0 +1,71 @@\n+# MyQ Binding\n+\n+This binding integrates with the [The Chamberlain Group MyQ](https://www.myq.com) cloud service. It allows monitoring and control over [MyQ](https://www.myq.com) enabled garage doors manufactured by LiftMaster, Chamberlain and Craftsman.\n+\n+## Supported Things\n+\n+### Account\n+\n+This represents the MyQ cloud account and uses the same credentials needed when using the MyQ mobile application.\n+\n+ThingTypeUID:`account`\n+\n+### Garage Door\n+\n+This represents a garage door associated with an account.  Multiple garage doors are supported.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b5c229bfaec596e8fe209df3946faf55db8b6b9d"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4MDEwNTUxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.myq/README.md", "isResolved": true, "comments": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMDoxNzozM1rOIPU37w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xN1QxODo1MDo0N1rOIVUO7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk0MTU1MQ==", "bodyText": "Is there any reason why these are two separate channels? What's the difference to the switch channel?", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r552941551", "createdAt": "2021-01-06T20:17:33Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.myq/README.md", "diffHunk": "@@ -0,0 +1,71 @@\n+# MyQ Binding\n+\n+This binding integrates with the [The Chamberlain Group MyQ](https://www.myq.com) cloud service. It allows monitoring and control over [MyQ](https://www.myq.com) enabled garage doors manufactured by LiftMaster, Chamberlain and Craftsman.\n+\n+## Supported Things\n+\n+### Account\n+\n+This represents the MyQ cloud account and uses the same credentials needed when using the MyQ mobile application.\n+\n+ThingTypeUID:`account`\n+\n+### Garage Door\n+\n+This represents a garage door associated with an account.  Multiple garage doors are supported.\n+\n+ThingTypeUID:`garagedoor`\n+\n+### Lamp\n+\n+This represents a lamp associated with an account.  Multiple lamps are supported.\n+\n+ThingTypeUID:`lamp`\n+\n+## Discovery\n+\n+Once an account has been added, garage doors and lamps will automatically be discovered and added to the inbox.\n+\n+## Channels\n+\n+| Channel       | Item Type     | Thing Type       | Description              |\n+|---------------|---------------|------------------|--------------------------|\n+| status        | String        | garagedoor, lamp | Status of the device     |\n+| switch        | Switch        | garagedoor, lamp | ON (open), OFF (close)   |\n+| contact       | Contact       | garagedoor       | Open, Closed             |\n+| rollershutter | Rollershutter | garagedoor       | UP (open), DOWN (closed) |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b5c229bfaec596e8fe209df3946faf55db8b6b9d"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzU5OTgzMQ==", "bodyText": "Some users prefer this to be a switch, similar to how locks are represented, others consider the door more like a rollershutter.  I tried to support both use cases.", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r553599831", "createdAt": "2021-01-07T21:29:43Z", "author": {"login": "digitaldan"}, "path": "bundles/org.openhab.binding.myq/README.md", "diffHunk": "@@ -0,0 +1,71 @@\n+# MyQ Binding\n+\n+This binding integrates with the [The Chamberlain Group MyQ](https://www.myq.com) cloud service. It allows monitoring and control over [MyQ](https://www.myq.com) enabled garage doors manufactured by LiftMaster, Chamberlain and Craftsman.\n+\n+## Supported Things\n+\n+### Account\n+\n+This represents the MyQ cloud account and uses the same credentials needed when using the MyQ mobile application.\n+\n+ThingTypeUID:`account`\n+\n+### Garage Door\n+\n+This represents a garage door associated with an account.  Multiple garage doors are supported.\n+\n+ThingTypeUID:`garagedoor`\n+\n+### Lamp\n+\n+This represents a lamp associated with an account.  Multiple lamps are supported.\n+\n+ThingTypeUID:`lamp`\n+\n+## Discovery\n+\n+Once an account has been added, garage doors and lamps will automatically be discovered and added to the inbox.\n+\n+## Channels\n+\n+| Channel       | Item Type     | Thing Type       | Description              |\n+|---------------|---------------|------------------|--------------------------|\n+| status        | String        | garagedoor, lamp | Status of the device     |\n+| switch        | Switch        | garagedoor, lamp | ON (open), OFF (close)   |\n+| contact       | Contact       | garagedoor       | Open, Closed             |\n+| rollershutter | Rollershutter | garagedoor       | UP (open), DOWN (closed) |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk0MTU1MQ=="}, "originalCommit": {"oid": "b5c229bfaec596e8fe209df3946faf55db8b6b9d"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDQ3NzM3Mg==", "bodyText": "There should be only 1 channel. Contact conceptually is readonly. Rollesshutter seems the most logically,but should accept percentage and move/stop. So that should be handled. See also https://www.openhab.org/docs/configuration/items.html#type", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r554477372", "createdAt": "2021-01-09T21:53:36Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.myq/README.md", "diffHunk": "@@ -0,0 +1,71 @@\n+# MyQ Binding\n+\n+This binding integrates with the [The Chamberlain Group MyQ](https://www.myq.com) cloud service. It allows monitoring and control over [MyQ](https://www.myq.com) enabled garage doors manufactured by LiftMaster, Chamberlain and Craftsman.\n+\n+## Supported Things\n+\n+### Account\n+\n+This represents the MyQ cloud account and uses the same credentials needed when using the MyQ mobile application.\n+\n+ThingTypeUID:`account`\n+\n+### Garage Door\n+\n+This represents a garage door associated with an account.  Multiple garage doors are supported.\n+\n+ThingTypeUID:`garagedoor`\n+\n+### Lamp\n+\n+This represents a lamp associated with an account.  Multiple lamps are supported.\n+\n+ThingTypeUID:`lamp`\n+\n+## Discovery\n+\n+Once an account has been added, garage doors and lamps will automatically be discovered and added to the inbox.\n+\n+## Channels\n+\n+| Channel       | Item Type     | Thing Type       | Description              |\n+|---------------|---------------|------------------|--------------------------|\n+| status        | String        | garagedoor, lamp | Status of the device     |\n+| switch        | Switch        | garagedoor, lamp | ON (open), OFF (close)   |\n+| contact       | Contact       | garagedoor       | Open, Closed             |\n+| rollershutter | Rollershutter | garagedoor       | UP (open), DOWN (closed) |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk0MTU1MQ=="}, "originalCommit": {"oid": "b5c229bfaec596e8fe209df3946faf55db8b6b9d"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDU5OTE4NQ==", "bodyText": "thanks @Hilbrand for the feedback\n\nRollesshutter seems the most logically,but should accept percentage and move/stop.\n\nI would certainly like to , but since the api only responds to open/close and not a % or stop, and does not report %, how would you suggest i do that?\n\nThere should be only 1 channel.\n\nIdeally that would be awesome, but its not very black and white what item type is in use here. From a UI perspective, a rollershutter makes the most sense,  our widgets specifically have a UP/Down interface, but as I mentioned above, we can not support % or stop.  From a contact point of view this also makes sense, and in fact is useful when using this in a group of contacts with sensors  for perimeter monitoring (which i do) , but of course there is not a command type for a contact, so that can not be the only channel.  Many users have used a simple switch to control this.  I am trying to appease the current users of previous myq bindings that have been floating around.\nIs there another way to map multiple item types to a single channel?  In this case, i think the types i have here all make very logical sense, but picking only one will greatly limit the usability to our existing myq users.\ni am also taking a queue from other bindings,  like our Open Garage addon, which handles this in a similar way.\nI am open to suggestions, but i'm hoping this is not going to delay getting this 1.x replacement merged in.", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r554599185", "createdAt": "2021-01-10T17:37:06Z", "author": {"login": "digitaldan"}, "path": "bundles/org.openhab.binding.myq/README.md", "diffHunk": "@@ -0,0 +1,71 @@\n+# MyQ Binding\n+\n+This binding integrates with the [The Chamberlain Group MyQ](https://www.myq.com) cloud service. It allows monitoring and control over [MyQ](https://www.myq.com) enabled garage doors manufactured by LiftMaster, Chamberlain and Craftsman.\n+\n+## Supported Things\n+\n+### Account\n+\n+This represents the MyQ cloud account and uses the same credentials needed when using the MyQ mobile application.\n+\n+ThingTypeUID:`account`\n+\n+### Garage Door\n+\n+This represents a garage door associated with an account.  Multiple garage doors are supported.\n+\n+ThingTypeUID:`garagedoor`\n+\n+### Lamp\n+\n+This represents a lamp associated with an account.  Multiple lamps are supported.\n+\n+ThingTypeUID:`lamp`\n+\n+## Discovery\n+\n+Once an account has been added, garage doors and lamps will automatically be discovered and added to the inbox.\n+\n+## Channels\n+\n+| Channel       | Item Type     | Thing Type       | Description              |\n+|---------------|---------------|------------------|--------------------------|\n+| status        | String        | garagedoor, lamp | Status of the device     |\n+| switch        | Switch        | garagedoor, lamp | ON (open), OFF (close)   |\n+| contact       | Contact       | garagedoor       | Open, Closed             |\n+| rollershutter | Rollershutter | garagedoor       | UP (open), DOWN (closed) |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk0MTU1MQ=="}, "originalCommit": {"oid": "b5c229bfaec596e8fe209df3946faf55db8b6b9d"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTUzOTAxOQ==", "bodyText": "Regarding the rollershutter, you are correct i was not handling % commands and should have, so i have added that in my last commit.", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r555539019", "createdAt": "2021-01-12T06:24:32Z", "author": {"login": "digitaldan"}, "path": "bundles/org.openhab.binding.myq/README.md", "diffHunk": "@@ -0,0 +1,71 @@\n+# MyQ Binding\n+\n+This binding integrates with the [The Chamberlain Group MyQ](https://www.myq.com) cloud service. It allows monitoring and control over [MyQ](https://www.myq.com) enabled garage doors manufactured by LiftMaster, Chamberlain and Craftsman.\n+\n+## Supported Things\n+\n+### Account\n+\n+This represents the MyQ cloud account and uses the same credentials needed when using the MyQ mobile application.\n+\n+ThingTypeUID:`account`\n+\n+### Garage Door\n+\n+This represents a garage door associated with an account.  Multiple garage doors are supported.\n+\n+ThingTypeUID:`garagedoor`\n+\n+### Lamp\n+\n+This represents a lamp associated with an account.  Multiple lamps are supported.\n+\n+ThingTypeUID:`lamp`\n+\n+## Discovery\n+\n+Once an account has been added, garage doors and lamps will automatically be discovered and added to the inbox.\n+\n+## Channels\n+\n+| Channel       | Item Type     | Thing Type       | Description              |\n+|---------------|---------------|------------------|--------------------------|\n+| status        | String        | garagedoor, lamp | Status of the device     |\n+| switch        | Switch        | garagedoor, lamp | ON (open), OFF (close)   |\n+| contact       | Contact       | garagedoor       | Open, Closed             |\n+| rollershutter | Rollershutter | garagedoor       | UP (open), DOWN (closed) |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk0MTU1MQ=="}, "originalCommit": {"oid": "b5c229bfaec596e8fe209df3946faf55db8b6b9d"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njc2ODg4Mw==", "bodyText": "I go for the Contact type too, but what is the use case for the Switch in addition to the Rollershutter?", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r556768883", "createdAt": "2021-01-13T19:16:50Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.myq/README.md", "diffHunk": "@@ -0,0 +1,71 @@\n+# MyQ Binding\n+\n+This binding integrates with the [The Chamberlain Group MyQ](https://www.myq.com) cloud service. It allows monitoring and control over [MyQ](https://www.myq.com) enabled garage doors manufactured by LiftMaster, Chamberlain and Craftsman.\n+\n+## Supported Things\n+\n+### Account\n+\n+This represents the MyQ cloud account and uses the same credentials needed when using the MyQ mobile application.\n+\n+ThingTypeUID:`account`\n+\n+### Garage Door\n+\n+This represents a garage door associated with an account.  Multiple garage doors are supported.\n+\n+ThingTypeUID:`garagedoor`\n+\n+### Lamp\n+\n+This represents a lamp associated with an account.  Multiple lamps are supported.\n+\n+ThingTypeUID:`lamp`\n+\n+## Discovery\n+\n+Once an account has been added, garage doors and lamps will automatically be discovered and added to the inbox.\n+\n+## Channels\n+\n+| Channel       | Item Type     | Thing Type       | Description              |\n+|---------------|---------------|------------------|--------------------------|\n+| status        | String        | garagedoor, lamp | Status of the device     |\n+| switch        | Switch        | garagedoor, lamp | ON (open), OFF (close)   |\n+| contact       | Contact       | garagedoor       | Open, Closed             |\n+| rollershutter | Rollershutter | garagedoor       | UP (open), DOWN (closed) |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk0MTU1MQ=="}, "originalCommit": {"oid": "b5c229bfaec596e8fe209df3946faf55db8b6b9d"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzUxNDEyMA==", "bodyText": "I can live without the switch, it seemed to me a common UI element that users of the previous bindings were using, but a rollershutter covers this use case nicely.  I personally don't use it, so I'll remove it and see if anyone screams.", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r557514120", "createdAt": "2021-01-14T16:13:58Z", "author": {"login": "digitaldan"}, "path": "bundles/org.openhab.binding.myq/README.md", "diffHunk": "@@ -0,0 +1,71 @@\n+# MyQ Binding\n+\n+This binding integrates with the [The Chamberlain Group MyQ](https://www.myq.com) cloud service. It allows monitoring and control over [MyQ](https://www.myq.com) enabled garage doors manufactured by LiftMaster, Chamberlain and Craftsman.\n+\n+## Supported Things\n+\n+### Account\n+\n+This represents the MyQ cloud account and uses the same credentials needed when using the MyQ mobile application.\n+\n+ThingTypeUID:`account`\n+\n+### Garage Door\n+\n+This represents a garage door associated with an account.  Multiple garage doors are supported.\n+\n+ThingTypeUID:`garagedoor`\n+\n+### Lamp\n+\n+This represents a lamp associated with an account.  Multiple lamps are supported.\n+\n+ThingTypeUID:`lamp`\n+\n+## Discovery\n+\n+Once an account has been added, garage doors and lamps will automatically be discovered and added to the inbox.\n+\n+## Channels\n+\n+| Channel       | Item Type     | Thing Type       | Description              |\n+|---------------|---------------|------------------|--------------------------|\n+| status        | String        | garagedoor, lamp | Status of the device     |\n+| switch        | Switch        | garagedoor, lamp | ON (open), OFF (close)   |\n+| contact       | Contact       | garagedoor       | Open, Closed             |\n+| rollershutter | Rollershutter | garagedoor       | UP (open), DOWN (closed) |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk0MTU1MQ=="}, "originalCommit": {"oid": "b5c229bfaec596e8fe209df3946faf55db8b6b9d"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzUzNTg3Ng==", "bodyText": "I use the switch, please don't remove it. Other bindings have dimmers and on/offs for the same channel. I don't see how less choice is a good thing.", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r557535876", "createdAt": "2021-01-14T16:42:39Z", "author": {"login": "computergeek1507"}, "path": "bundles/org.openhab.binding.myq/README.md", "diffHunk": "@@ -0,0 +1,71 @@\n+# MyQ Binding\n+\n+This binding integrates with the [The Chamberlain Group MyQ](https://www.myq.com) cloud service. It allows monitoring and control over [MyQ](https://www.myq.com) enabled garage doors manufactured by LiftMaster, Chamberlain and Craftsman.\n+\n+## Supported Things\n+\n+### Account\n+\n+This represents the MyQ cloud account and uses the same credentials needed when using the MyQ mobile application.\n+\n+ThingTypeUID:`account`\n+\n+### Garage Door\n+\n+This represents a garage door associated with an account.  Multiple garage doors are supported.\n+\n+ThingTypeUID:`garagedoor`\n+\n+### Lamp\n+\n+This represents a lamp associated with an account.  Multiple lamps are supported.\n+\n+ThingTypeUID:`lamp`\n+\n+## Discovery\n+\n+Once an account has been added, garage doors and lamps will automatically be discovered and added to the inbox.\n+\n+## Channels\n+\n+| Channel       | Item Type     | Thing Type       | Description              |\n+|---------------|---------------|------------------|--------------------------|\n+| status        | String        | garagedoor, lamp | Status of the device     |\n+| switch        | Switch        | garagedoor, lamp | ON (open), OFF (close)   |\n+| contact       | Contact       | garagedoor       | Open, Closed             |\n+| rollershutter | Rollershutter | garagedoor       | UP (open), DOWN (closed) |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk0MTU1MQ=="}, "originalCommit": {"oid": "b5c229bfaec596e8fe209df3946faf55db8b6b9d"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY0MzE1NA==", "bodyText": "I'm ok leaving it in , although dimmers and switches are a different comparison, dimmer items also support ON/OFF commands and states, so you can map a Switch Item  to a dimmer channel and it will work, so i don't know a lot of bindings that do both channel types for the same function, or at least they should not.", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r557643154", "createdAt": "2021-01-14T19:29:49Z", "author": {"login": "digitaldan"}, "path": "bundles/org.openhab.binding.myq/README.md", "diffHunk": "@@ -0,0 +1,71 @@\n+# MyQ Binding\n+\n+This binding integrates with the [The Chamberlain Group MyQ](https://www.myq.com) cloud service. It allows monitoring and control over [MyQ](https://www.myq.com) enabled garage doors manufactured by LiftMaster, Chamberlain and Craftsman.\n+\n+## Supported Things\n+\n+### Account\n+\n+This represents the MyQ cloud account and uses the same credentials needed when using the MyQ mobile application.\n+\n+ThingTypeUID:`account`\n+\n+### Garage Door\n+\n+This represents a garage door associated with an account.  Multiple garage doors are supported.\n+\n+ThingTypeUID:`garagedoor`\n+\n+### Lamp\n+\n+This represents a lamp associated with an account.  Multiple lamps are supported.\n+\n+ThingTypeUID:`lamp`\n+\n+## Discovery\n+\n+Once an account has been added, garage doors and lamps will automatically be discovered and added to the inbox.\n+\n+## Channels\n+\n+| Channel       | Item Type     | Thing Type       | Description              |\n+|---------------|---------------|------------------|--------------------------|\n+| status        | String        | garagedoor, lamp | Status of the device     |\n+| switch        | Switch        | garagedoor, lamp | ON (open), OFF (close)   |\n+| contact       | Contact       | garagedoor       | Open, Closed             |\n+| rollershutter | Rollershutter | garagedoor       | UP (open), DOWN (closed) |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk0MTU1MQ=="}, "originalCommit": {"oid": "b5c229bfaec596e8fe209df3946faf55db8b6b9d"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY0NzQwMQ==", "bodyText": "I also use the switch.  It just makes some things cleaner across my rules.", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r557647401", "createdAt": "2021-01-14T19:37:28Z", "author": {"login": "morph166955"}, "path": "bundles/org.openhab.binding.myq/README.md", "diffHunk": "@@ -0,0 +1,71 @@\n+# MyQ Binding\n+\n+This binding integrates with the [The Chamberlain Group MyQ](https://www.myq.com) cloud service. It allows monitoring and control over [MyQ](https://www.myq.com) enabled garage doors manufactured by LiftMaster, Chamberlain and Craftsman.\n+\n+## Supported Things\n+\n+### Account\n+\n+This represents the MyQ cloud account and uses the same credentials needed when using the MyQ mobile application.\n+\n+ThingTypeUID:`account`\n+\n+### Garage Door\n+\n+This represents a garage door associated with an account.  Multiple garage doors are supported.\n+\n+ThingTypeUID:`garagedoor`\n+\n+### Lamp\n+\n+This represents a lamp associated with an account.  Multiple lamps are supported.\n+\n+ThingTypeUID:`lamp`\n+\n+## Discovery\n+\n+Once an account has been added, garage doors and lamps will automatically be discovered and added to the inbox.\n+\n+## Channels\n+\n+| Channel       | Item Type     | Thing Type       | Description              |\n+|---------------|---------------|------------------|--------------------------|\n+| status        | String        | garagedoor, lamp | Status of the device     |\n+| switch        | Switch        | garagedoor, lamp | ON (open), OFF (close)   |\n+| contact       | Contact       | garagedoor       | Open, Closed             |\n+| rollershutter | Rollershutter | garagedoor       | UP (open), DOWN (closed) |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk0MTU1MQ=="}, "originalCommit": {"oid": "b5c229bfaec596e8fe209df3946faf55db8b6b9d"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY5MDI3OQ==", "bodyText": "I left the switch there in my last commit, i vote we keep it for consistency with existing user's expectations.", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r557690279", "createdAt": "2021-01-14T20:50:05Z", "author": {"login": "digitaldan"}, "path": "bundles/org.openhab.binding.myq/README.md", "diffHunk": "@@ -0,0 +1,71 @@\n+# MyQ Binding\n+\n+This binding integrates with the [The Chamberlain Group MyQ](https://www.myq.com) cloud service. It allows monitoring and control over [MyQ](https://www.myq.com) enabled garage doors manufactured by LiftMaster, Chamberlain and Craftsman.\n+\n+## Supported Things\n+\n+### Account\n+\n+This represents the MyQ cloud account and uses the same credentials needed when using the MyQ mobile application.\n+\n+ThingTypeUID:`account`\n+\n+### Garage Door\n+\n+This represents a garage door associated with an account.  Multiple garage doors are supported.\n+\n+ThingTypeUID:`garagedoor`\n+\n+### Lamp\n+\n+This represents a lamp associated with an account.  Multiple lamps are supported.\n+\n+ThingTypeUID:`lamp`\n+\n+## Discovery\n+\n+Once an account has been added, garage doors and lamps will automatically be discovered and added to the inbox.\n+\n+## Channels\n+\n+| Channel       | Item Type     | Thing Type       | Description              |\n+|---------------|---------------|------------------|--------------------------|\n+| status        | String        | garagedoor, lamp | Status of the device     |\n+| switch        | Switch        | garagedoor, lamp | ON (open), OFF (close)   |\n+| contact       | Contact       | garagedoor       | Open, Closed             |\n+| rollershutter | Rollershutter | garagedoor       | UP (open), DOWN (closed) |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk0MTU1MQ=="}, "originalCommit": {"oid": "b5c229bfaec596e8fe209df3946faf55db8b6b9d"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzY5Mzk0OQ==", "bodyText": "Just putting in my two cents - I\u2019ve used a myQ plugin of some form for a few years now. When I first came to it, I was extremely confused that there were so many channels that seemingly did the same thing. Especially since the Rollershutter channel didn\u2019t respond to 0/100 which is what some things (HomeKit) automatically do instead of UP/DOWN. I saw you fixed that last part recently, and that\u2019s nice. There\u2019s just something to be said for presenting the simplest possible interface (with full functionality), and making users adapt it via rules if they want to use it say in a group with slightly different item types. As long as documentation is clear that these channels all actually do the same thing, I won\u2019t argue against keeping them though.", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r557693949", "createdAt": "2021-01-14T20:56:50Z", "author": {"login": "ccutrer"}, "path": "bundles/org.openhab.binding.myq/README.md", "diffHunk": "@@ -0,0 +1,71 @@\n+# MyQ Binding\n+\n+This binding integrates with the [The Chamberlain Group MyQ](https://www.myq.com) cloud service. It allows monitoring and control over [MyQ](https://www.myq.com) enabled garage doors manufactured by LiftMaster, Chamberlain and Craftsman.\n+\n+## Supported Things\n+\n+### Account\n+\n+This represents the MyQ cloud account and uses the same credentials needed when using the MyQ mobile application.\n+\n+ThingTypeUID:`account`\n+\n+### Garage Door\n+\n+This represents a garage door associated with an account.  Multiple garage doors are supported.\n+\n+ThingTypeUID:`garagedoor`\n+\n+### Lamp\n+\n+This represents a lamp associated with an account.  Multiple lamps are supported.\n+\n+ThingTypeUID:`lamp`\n+\n+## Discovery\n+\n+Once an account has been added, garage doors and lamps will automatically be discovered and added to the inbox.\n+\n+## Channels\n+\n+| Channel       | Item Type     | Thing Type       | Description              |\n+|---------------|---------------|------------------|--------------------------|\n+| status        | String        | garagedoor, lamp | Status of the device     |\n+| switch        | Switch        | garagedoor, lamp | ON (open), OFF (close)   |\n+| contact       | Contact       | garagedoor       | Open, Closed             |\n+| rollershutter | Rollershutter | garagedoor       | UP (open), DOWN (closed) |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk0MTU1MQ=="}, "originalCommit": {"oid": "b5c229bfaec596e8fe209df3946faf55db8b6b9d"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1ODk4MTQ5Nw==", "bodyText": "IMHO the current number of Channels for the same function are too much and therefore confusing. As several users seem to use the Switch, my suggestion would be to keep this and remove all others. As the garage door cannot be controlled with 0-100%, but only open/close, the Rollershutter doesn't have any benefit over the Switch. Keep it simple... If the user wants to do some more complex things, it's still possible by using rules. I think this fits good with openHAB concepts.", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r558981497", "createdAt": "2021-01-16T17:49:39Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.myq/README.md", "diffHunk": "@@ -0,0 +1,71 @@\n+# MyQ Binding\n+\n+This binding integrates with the [The Chamberlain Group MyQ](https://www.myq.com) cloud service. It allows monitoring and control over [MyQ](https://www.myq.com) enabled garage doors manufactured by LiftMaster, Chamberlain and Craftsman.\n+\n+## Supported Things\n+\n+### Account\n+\n+This represents the MyQ cloud account and uses the same credentials needed when using the MyQ mobile application.\n+\n+ThingTypeUID:`account`\n+\n+### Garage Door\n+\n+This represents a garage door associated with an account.  Multiple garage doors are supported.\n+\n+ThingTypeUID:`garagedoor`\n+\n+### Lamp\n+\n+This represents a lamp associated with an account.  Multiple lamps are supported.\n+\n+ThingTypeUID:`lamp`\n+\n+## Discovery\n+\n+Once an account has been added, garage doors and lamps will automatically be discovered and added to the inbox.\n+\n+## Channels\n+\n+| Channel       | Item Type     | Thing Type       | Description              |\n+|---------------|---------------|------------------|--------------------------|\n+| status        | String        | garagedoor, lamp | Status of the device     |\n+| switch        | Switch        | garagedoor, lamp | ON (open), OFF (close)   |\n+| contact       | Contact       | garagedoor       | Open, Closed             |\n+| rollershutter | Rollershutter | garagedoor       | UP (open), DOWN (closed) |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk0MTU1MQ=="}, "originalCommit": {"oid": "b5c229bfaec596e8fe209df3946faf55db8b6b9d"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTA0Mzc2NQ==", "bodyText": "I would agree with getting rid of the rollershutter and the contact.  Personally I use the switch and the status channels.  The switch to send commands, and the status for my rules (so that I can identify open vs. opening vs. closing. vs. closed).  If you really want it to say up/down, you can easily do that in the sitemap.", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r559043765", "createdAt": "2021-01-16T21:48:58Z", "author": {"login": "morph166955"}, "path": "bundles/org.openhab.binding.myq/README.md", "diffHunk": "@@ -0,0 +1,71 @@\n+# MyQ Binding\n+\n+This binding integrates with the [The Chamberlain Group MyQ](https://www.myq.com) cloud service. It allows monitoring and control over [MyQ](https://www.myq.com) enabled garage doors manufactured by LiftMaster, Chamberlain and Craftsman.\n+\n+## Supported Things\n+\n+### Account\n+\n+This represents the MyQ cloud account and uses the same credentials needed when using the MyQ mobile application.\n+\n+ThingTypeUID:`account`\n+\n+### Garage Door\n+\n+This represents a garage door associated with an account.  Multiple garage doors are supported.\n+\n+ThingTypeUID:`garagedoor`\n+\n+### Lamp\n+\n+This represents a lamp associated with an account.  Multiple lamps are supported.\n+\n+ThingTypeUID:`lamp`\n+\n+## Discovery\n+\n+Once an account has been added, garage doors and lamps will automatically be discovered and added to the inbox.\n+\n+## Channels\n+\n+| Channel       | Item Type     | Thing Type       | Description              |\n+|---------------|---------------|------------------|--------------------------|\n+| status        | String        | garagedoor, lamp | Status of the device     |\n+| switch        | Switch        | garagedoor, lamp | ON (open), OFF (close)   |\n+| contact       | Contact       | garagedoor       | Open, Closed             |\n+| rollershutter | Rollershutter | garagedoor       | UP (open), DOWN (closed) |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk0MTU1MQ=="}, "originalCommit": {"oid": "b5c229bfaec596e8fe209df3946faf55db8b6b9d"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTIwMDk0Ng==", "bodyText": "So i feel very strongly about keeping a roller shutter.  I never once refer to my door as being ON or OFF.   In our UIs the rollershutter widget makes sense, an on/off switch does not and is confusing IMHO (why is a door that is open ON? ).\n\ncannot be controlled with 0-100%\n\nThe binding does support 0%/100% as well as UP/DOWN, i don't think is uncommon for simple  roller shutters to  work this way, i have a unit which only goes up or down, not a %, i believe the motor simply inverts direction when the current is inverted.\n< If the user wants to do some more complex things, it's still possible by using rules.\nIf we are already working around an issue like this with rules before we have even submitted the binding i think we have lost from a usability POV.\nI would like  to drop the contact channel and keep the others as it is, i do feel strongly about this.  My reasoning is there a small amount of channels in the binding,  i don't think it's going to confuse users, there are other bindings that do this, and  the fact that we have so many opinions on this i think proves the value of keeping both channels types .", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r559200946", "createdAt": "2021-01-17T15:59:17Z", "author": {"login": "digitaldan"}, "path": "bundles/org.openhab.binding.myq/README.md", "diffHunk": "@@ -0,0 +1,71 @@\n+# MyQ Binding\n+\n+This binding integrates with the [The Chamberlain Group MyQ](https://www.myq.com) cloud service. It allows monitoring and control over [MyQ](https://www.myq.com) enabled garage doors manufactured by LiftMaster, Chamberlain and Craftsman.\n+\n+## Supported Things\n+\n+### Account\n+\n+This represents the MyQ cloud account and uses the same credentials needed when using the MyQ mobile application.\n+\n+ThingTypeUID:`account`\n+\n+### Garage Door\n+\n+This represents a garage door associated with an account.  Multiple garage doors are supported.\n+\n+ThingTypeUID:`garagedoor`\n+\n+### Lamp\n+\n+This represents a lamp associated with an account.  Multiple lamps are supported.\n+\n+ThingTypeUID:`lamp`\n+\n+## Discovery\n+\n+Once an account has been added, garage doors and lamps will automatically be discovered and added to the inbox.\n+\n+## Channels\n+\n+| Channel       | Item Type     | Thing Type       | Description              |\n+|---------------|---------------|------------------|--------------------------|\n+| status        | String        | garagedoor, lamp | Status of the device     |\n+| switch        | Switch        | garagedoor, lamp | ON (open), OFF (close)   |\n+| contact       | Contact       | garagedoor       | Open, Closed             |\n+| rollershutter | Rollershutter | garagedoor       | UP (open), DOWN (closed) |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk0MTU1MQ=="}, "originalCommit": {"oid": "b5c229bfaec596e8fe209df3946faf55db8b6b9d"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTIyMjUwOA==", "bodyText": "I'm cool with that.", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r559222508", "createdAt": "2021-01-17T18:50:47Z", "author": {"login": "morph166955"}, "path": "bundles/org.openhab.binding.myq/README.md", "diffHunk": "@@ -0,0 +1,71 @@\n+# MyQ Binding\n+\n+This binding integrates with the [The Chamberlain Group MyQ](https://www.myq.com) cloud service. It allows monitoring and control over [MyQ](https://www.myq.com) enabled garage doors manufactured by LiftMaster, Chamberlain and Craftsman.\n+\n+## Supported Things\n+\n+### Account\n+\n+This represents the MyQ cloud account and uses the same credentials needed when using the MyQ mobile application.\n+\n+ThingTypeUID:`account`\n+\n+### Garage Door\n+\n+This represents a garage door associated with an account.  Multiple garage doors are supported.\n+\n+ThingTypeUID:`garagedoor`\n+\n+### Lamp\n+\n+This represents a lamp associated with an account.  Multiple lamps are supported.\n+\n+ThingTypeUID:`lamp`\n+\n+## Discovery\n+\n+Once an account has been added, garage doors and lamps will automatically be discovered and added to the inbox.\n+\n+## Channels\n+\n+| Channel       | Item Type     | Thing Type       | Description              |\n+|---------------|---------------|------------------|--------------------------|\n+| status        | String        | garagedoor, lamp | Status of the device     |\n+| switch        | Switch        | garagedoor, lamp | ON (open), OFF (close)   |\n+| contact       | Contact       | garagedoor       | Open, Closed             |\n+| rollershutter | Rollershutter | garagedoor       | UP (open), DOWN (closed) |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk0MTU1MQ=="}, "originalCommit": {"oid": "b5c229bfaec596e8fe209df3946faf55db8b6b9d"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4MDEwNjI3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.myq/README.md", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMDoxNzo1MlrOIPU4bQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNFQxNjoxMzo1NVrOITr9Xw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk0MTY3Nw==", "bodyText": "Can you mention which state the user can expect?", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r552941677", "createdAt": "2021-01-06T20:17:52Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.myq/README.md", "diffHunk": "@@ -0,0 +1,71 @@\n+# MyQ Binding\n+\n+This binding integrates with the [The Chamberlain Group MyQ](https://www.myq.com) cloud service. It allows monitoring and control over [MyQ](https://www.myq.com) enabled garage doors manufactured by LiftMaster, Chamberlain and Craftsman.\n+\n+## Supported Things\n+\n+### Account\n+\n+This represents the MyQ cloud account and uses the same credentials needed when using the MyQ mobile application.\n+\n+ThingTypeUID:`account`\n+\n+### Garage Door\n+\n+This represents a garage door associated with an account.  Multiple garage doors are supported.\n+\n+ThingTypeUID:`garagedoor`\n+\n+### Lamp\n+\n+This represents a lamp associated with an account.  Multiple lamps are supported.\n+\n+ThingTypeUID:`lamp`\n+\n+## Discovery\n+\n+Once an account has been added, garage doors and lamps will automatically be discovered and added to the inbox.\n+\n+## Channels\n+\n+| Channel       | Item Type     | Thing Type       | Description              |\n+|---------------|---------------|------------------|--------------------------|\n+| status        | String        | garagedoor, lamp | Status of the device     |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b5c229bfaec596e8fe209df3946faf55db8b6b9d"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzYwMDMzMA==", "bodyText": "There are state descriptions in the XML as well.", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r553600330", "createdAt": "2021-01-07T21:30:57Z", "author": {"login": "digitaldan"}, "path": "bundles/org.openhab.binding.myq/README.md", "diffHunk": "@@ -0,0 +1,71 @@\n+# MyQ Binding\n+\n+This binding integrates with the [The Chamberlain Group MyQ](https://www.myq.com) cloud service. It allows monitoring and control over [MyQ](https://www.myq.com) enabled garage doors manufactured by LiftMaster, Chamberlain and Craftsman.\n+\n+## Supported Things\n+\n+### Account\n+\n+This represents the MyQ cloud account and uses the same credentials needed when using the MyQ mobile application.\n+\n+ThingTypeUID:`account`\n+\n+### Garage Door\n+\n+This represents a garage door associated with an account.  Multiple garage doors are supported.\n+\n+ThingTypeUID:`garagedoor`\n+\n+### Lamp\n+\n+This represents a lamp associated with an account.  Multiple lamps are supported.\n+\n+ThingTypeUID:`lamp`\n+\n+## Discovery\n+\n+Once an account has been added, garage doors and lamps will automatically be discovered and added to the inbox.\n+\n+## Channels\n+\n+| Channel       | Item Type     | Thing Type       | Description              |\n+|---------------|---------------|------------------|--------------------------|\n+| status        | String        | garagedoor, lamp | Status of the device     |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk0MTY3Nw=="}, "originalCommit": {"oid": "b5c229bfaec596e8fe209df3946faf55db8b6b9d"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njc2OTMwMg==", "bodyText": "Yeah, but do you want to ask the user to read the source? Better document it here.", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r556769302", "createdAt": "2021-01-13T19:17:37Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.myq/README.md", "diffHunk": "@@ -0,0 +1,71 @@\n+# MyQ Binding\n+\n+This binding integrates with the [The Chamberlain Group MyQ](https://www.myq.com) cloud service. It allows monitoring and control over [MyQ](https://www.myq.com) enabled garage doors manufactured by LiftMaster, Chamberlain and Craftsman.\n+\n+## Supported Things\n+\n+### Account\n+\n+This represents the MyQ cloud account and uses the same credentials needed when using the MyQ mobile application.\n+\n+ThingTypeUID:`account`\n+\n+### Garage Door\n+\n+This represents a garage door associated with an account.  Multiple garage doors are supported.\n+\n+ThingTypeUID:`garagedoor`\n+\n+### Lamp\n+\n+This represents a lamp associated with an account.  Multiple lamps are supported.\n+\n+ThingTypeUID:`lamp`\n+\n+## Discovery\n+\n+Once an account has been added, garage doors and lamps will automatically be discovered and added to the inbox.\n+\n+## Channels\n+\n+| Channel       | Item Type     | Thing Type       | Description              |\n+|---------------|---------------|------------------|--------------------------|\n+| status        | String        | garagedoor, lamp | Status of the device     |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk0MTY3Nw=="}, "originalCommit": {"oid": "b5c229bfaec596e8fe209df3946faf55db8b6b9d"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzUxNDA3OQ==", "bodyText": "fair enough", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r557514079", "createdAt": "2021-01-14T16:13:55Z", "author": {"login": "digitaldan"}, "path": "bundles/org.openhab.binding.myq/README.md", "diffHunk": "@@ -0,0 +1,71 @@\n+# MyQ Binding\n+\n+This binding integrates with the [The Chamberlain Group MyQ](https://www.myq.com) cloud service. It allows monitoring and control over [MyQ](https://www.myq.com) enabled garage doors manufactured by LiftMaster, Chamberlain and Craftsman.\n+\n+## Supported Things\n+\n+### Account\n+\n+This represents the MyQ cloud account and uses the same credentials needed when using the MyQ mobile application.\n+\n+ThingTypeUID:`account`\n+\n+### Garage Door\n+\n+This represents a garage door associated with an account.  Multiple garage doors are supported.\n+\n+ThingTypeUID:`garagedoor`\n+\n+### Lamp\n+\n+This represents a lamp associated with an account.  Multiple lamps are supported.\n+\n+ThingTypeUID:`lamp`\n+\n+## Discovery\n+\n+Once an account has been added, garage doors and lamps will automatically be discovered and added to the inbox.\n+\n+## Channels\n+\n+| Channel       | Item Type     | Thing Type       | Description              |\n+|---------------|---------------|------------------|--------------------------|\n+| status        | String        | garagedoor, lamp | Status of the device     |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk0MTY3Nw=="}, "originalCommit": {"oid": "b5c229bfaec596e8fe209df3946faf55db8b6b9d"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4MDEwNzc5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.myq/src/main/feature/feature.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMDoxODozMFrOIPU5SA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMDoxODozMFrOIPU5SA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk0MTg5Ng==", "bodyText": "The features.xml doesn't need a license header.", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r552941896", "createdAt": "2021-01-06T20:18:30Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.myq/src/main/feature/feature.xml", "diffHunk": "@@ -0,0 +1,23 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<!--\n+\n+\tCopyright (c) 2010-2020 Contributors to the openHAB project\n+\n+\tSee the NOTICE file(s) distributed with this work for additional\n+\tinformation.\n+\n+\tThis program and the accompanying materials are made available under the\n+\tterms of the Eclipse Public License 2.0 which is available at\n+\thttp://www.eclipse.org/legal/epl-2.0\n+\n+\tSPDX-License-Identifier: EPL-2.0\n+\n+-->", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b5c229bfaec596e8fe209df3946faf55db8b6b9d"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4MDExMjQ3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.myq/src/main/java/org/openhab/binding/myq/internal/MyQHandlerFactory.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMDoyMDoxM1rOIPU7-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xNFQxNjoxODozOVrOITsL_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk0MjU4NQ==", "bodyText": "You could use ThingHandlerService which would make this code unnecessary. The documentation for this is not yet merged, but available in the PR: https://github.com/openhab/openhab-docs/pull/1262/files#diff-c4a4d8725430bc2ea046182bfc73ac51349d989c7f6a8a6fa3001a226a09ad98R932", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r552942585", "createdAt": "2021-01-06T20:20:13Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.myq/src/main/java/org/openhab/binding/myq/internal/MyQHandlerFactory.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.myq.internal;\n+\n+import static org.openhab.binding.myq.internal.MyQBindingConstants.*;\n+\n+import java.util.Hashtable;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.openhab.binding.myq.internal.handler.MyQAccountHandler;\n+import org.openhab.binding.myq.internal.handler.MyQGarageDoorHandler;\n+import org.openhab.binding.myq.internal.handler.MyQLampHandler;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.BaseThingHandlerFactory;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerFactory;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link MyQHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Dan Cunningham - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(configurationPid = \"binding.myq\", service = ThingHandlerFactory.class)\n+public class MyQHandlerFactory extends BaseThingHandlerFactory {\n+    private final Map<ThingUID, ServiceRegistration<?>> discoveryServiceRegs = new ConcurrentHashMap<>();\n+    private final HttpClient httpClient;\n+\n+    @Activate\n+    public MyQHandlerFactory(final @Reference HttpClientFactory httpClientFactory) {\n+        this.httpClient = httpClientFactory.getCommonHttpClient();\n+    }\n+\n+    @Override\n+    public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n+        return SUPPORTED_THING_TYPES_UIDS.contains(thingTypeUID);\n+    }\n+\n+    @Override\n+    protected @Nullable ThingHandler createHandler(Thing thing) {\n+        ThingTypeUID thingTypeUID = thing.getThingTypeUID();\n+\n+        if (THING_TYPE_ACCOUNT.equals(thingTypeUID)) {\n+            MyQDiscoveryService discoveryService = new MyQDiscoveryService();\n+            MyQAccountHandler accountHandler = new MyQAccountHandler((Bridge) thing, httpClient, discoveryService);\n+            discoveryServiceRegs.put(accountHandler.getThing().getUID(), bundleContext\n+                    .registerService(DiscoveryService.class.getName(), discoveryService, new Hashtable<>()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b5c229bfaec596e8fe209df3946faf55db8b6b9d"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzYwMjI0OA==", "bodyText": "Thanks, but my discovery service does not need a reference to the bridge, rather the reverse.", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r553602248", "createdAt": "2021-01-07T21:35:18Z", "author": {"login": "digitaldan"}, "path": "bundles/org.openhab.binding.myq/src/main/java/org/openhab/binding/myq/internal/MyQHandlerFactory.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.myq.internal;\n+\n+import static org.openhab.binding.myq.internal.MyQBindingConstants.*;\n+\n+import java.util.Hashtable;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.openhab.binding.myq.internal.handler.MyQAccountHandler;\n+import org.openhab.binding.myq.internal.handler.MyQGarageDoorHandler;\n+import org.openhab.binding.myq.internal.handler.MyQLampHandler;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.BaseThingHandlerFactory;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerFactory;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link MyQHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Dan Cunningham - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(configurationPid = \"binding.myq\", service = ThingHandlerFactory.class)\n+public class MyQHandlerFactory extends BaseThingHandlerFactory {\n+    private final Map<ThingUID, ServiceRegistration<?>> discoveryServiceRegs = new ConcurrentHashMap<>();\n+    private final HttpClient httpClient;\n+\n+    @Activate\n+    public MyQHandlerFactory(final @Reference HttpClientFactory httpClientFactory) {\n+        this.httpClient = httpClientFactory.getCommonHttpClient();\n+    }\n+\n+    @Override\n+    public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n+        return SUPPORTED_THING_TYPES_UIDS.contains(thingTypeUID);\n+    }\n+\n+    @Override\n+    protected @Nullable ThingHandler createHandler(Thing thing) {\n+        ThingTypeUID thingTypeUID = thing.getThingTypeUID();\n+\n+        if (THING_TYPE_ACCOUNT.equals(thingTypeUID)) {\n+            MyQDiscoveryService discoveryService = new MyQDiscoveryService();\n+            MyQAccountHandler accountHandler = new MyQAccountHandler((Bridge) thing, httpClient, discoveryService);\n+            discoveryServiceRegs.put(accountHandler.getThing().getUID(), bundleContext\n+                    .registerService(DiscoveryService.class.getName(), discoveryService, new Hashtable<>()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk0MjU4NQ=="}, "originalCommit": {"oid": "b5c229bfaec596e8fe209df3946faf55db8b6b9d"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Njc2NzEzMg==", "bodyText": "Why not make it vice versa via a callback? Then, you could use the ThingHandlerService, which would make the code more maintainable.", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r556767132", "createdAt": "2021-01-13T19:13:54Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.myq/src/main/java/org/openhab/binding/myq/internal/MyQHandlerFactory.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.myq.internal;\n+\n+import static org.openhab.binding.myq.internal.MyQBindingConstants.*;\n+\n+import java.util.Hashtable;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.openhab.binding.myq.internal.handler.MyQAccountHandler;\n+import org.openhab.binding.myq.internal.handler.MyQGarageDoorHandler;\n+import org.openhab.binding.myq.internal.handler.MyQLampHandler;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.BaseThingHandlerFactory;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerFactory;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link MyQHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Dan Cunningham - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(configurationPid = \"binding.myq\", service = ThingHandlerFactory.class)\n+public class MyQHandlerFactory extends BaseThingHandlerFactory {\n+    private final Map<ThingUID, ServiceRegistration<?>> discoveryServiceRegs = new ConcurrentHashMap<>();\n+    private final HttpClient httpClient;\n+\n+    @Activate\n+    public MyQHandlerFactory(final @Reference HttpClientFactory httpClientFactory) {\n+        this.httpClient = httpClientFactory.getCommonHttpClient();\n+    }\n+\n+    @Override\n+    public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n+        return SUPPORTED_THING_TYPES_UIDS.contains(thingTypeUID);\n+    }\n+\n+    @Override\n+    protected @Nullable ThingHandler createHandler(Thing thing) {\n+        ThingTypeUID thingTypeUID = thing.getThingTypeUID();\n+\n+        if (THING_TYPE_ACCOUNT.equals(thingTypeUID)) {\n+            MyQDiscoveryService discoveryService = new MyQDiscoveryService();\n+            MyQAccountHandler accountHandler = new MyQAccountHandler((Bridge) thing, httpClient, discoveryService);\n+            discoveryServiceRegs.put(accountHandler.getThing().getUID(), bundleContext\n+                    .registerService(DiscoveryService.class.getName(), discoveryService, new Hashtable<>()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk0MjU4NQ=="}, "originalCommit": {"oid": "b5c229bfaec596e8fe209df3946faf55db8b6b9d"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzUxNzgyMQ==", "bodyText": "I looked at that, but it seemed to complicate things without any clear benefit. Right now the handlerFactory knows about the thingHandler and discoveryService and  the thingHandler also knows about the discoveryService, if i use a callback, then now the discoveryService has to know about the thingHandler as well, we now have all 3 of the classes knowing about each other which seems to be a circular dependency without a clear benefit.", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r557517821", "createdAt": "2021-01-14T16:18:39Z", "author": {"login": "digitaldan"}, "path": "bundles/org.openhab.binding.myq/src/main/java/org/openhab/binding/myq/internal/MyQHandlerFactory.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.myq.internal;\n+\n+import static org.openhab.binding.myq.internal.MyQBindingConstants.*;\n+\n+import java.util.Hashtable;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.openhab.binding.myq.internal.handler.MyQAccountHandler;\n+import org.openhab.binding.myq.internal.handler.MyQGarageDoorHandler;\n+import org.openhab.binding.myq.internal.handler.MyQLampHandler;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.io.net.http.HttpClientFactory;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.BaseThingHandlerFactory;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerFactory;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link MyQHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Dan Cunningham - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(configurationPid = \"binding.myq\", service = ThingHandlerFactory.class)\n+public class MyQHandlerFactory extends BaseThingHandlerFactory {\n+    private final Map<ThingUID, ServiceRegistration<?>> discoveryServiceRegs = new ConcurrentHashMap<>();\n+    private final HttpClient httpClient;\n+\n+    @Activate\n+    public MyQHandlerFactory(final @Reference HttpClientFactory httpClientFactory) {\n+        this.httpClient = httpClientFactory.getCommonHttpClient();\n+    }\n+\n+    @Override\n+    public boolean supportsThingType(ThingTypeUID thingTypeUID) {\n+        return SUPPORTED_THING_TYPES_UIDS.contains(thingTypeUID);\n+    }\n+\n+    @Override\n+    protected @Nullable ThingHandler createHandler(Thing thing) {\n+        ThingTypeUID thingTypeUID = thing.getThingTypeUID();\n+\n+        if (THING_TYPE_ACCOUNT.equals(thingTypeUID)) {\n+            MyQDiscoveryService discoveryService = new MyQDiscoveryService();\n+            MyQAccountHandler accountHandler = new MyQAccountHandler((Bridge) thing, httpClient, discoveryService);\n+            discoveryServiceRegs.put(accountHandler.getThing().getUID(), bundleContext\n+                    .registerService(DiscoveryService.class.getName(), discoveryService, new Hashtable<>()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk0MjU4NQ=="}, "originalCommit": {"oid": "b5c229bfaec596e8fe209df3946faf55db8b6b9d"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4MDExNTE4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.myq/src/main/java/org/openhab/binding/myq/internal/handler/MyQAccountHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMDoyMToxN1rOIPU9sQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMDoyMToxN1rOIPU9sQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk0MzAyNQ==", "bodyText": "Primitive types should be used where possible.\nIt's good practice to append the unit to the field name e.g. TIMEOUT_SEC.\nCan these be static final?\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Integer normalRefreshInterval = 60;\n          \n          \n            \n                private Integer rapidRefreshInterval = 5;\n          \n          \n            \n                private int normalRefreshInterval = 60;\n          \n          \n            \n                private int rapidRefreshInterval = 5;", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r552943025", "createdAt": "2021-01-06T20:21:17Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.myq/src/main/java/org/openhab/binding/myq/internal/handler/MyQAccountHandler.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.myq.internal.handler;\n+\n+import static org.openhab.binding.myq.internal.MyQBindingConstants.*;\n+\n+import java.util.Random;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentProvider;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.api.Result;\n+import org.eclipse.jetty.client.util.BufferingResponseListener;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.myq.internal.MyQConfiguration;\n+import org.openhab.binding.myq.internal.MyQDiscoveryService;\n+import org.openhab.binding.myq.internal.dto.AccountDTO;\n+import org.openhab.binding.myq.internal.dto.ActionDTO;\n+import org.openhab.binding.myq.internal.dto.DevicesDTO;\n+import org.openhab.binding.myq.internal.dto.LoginRequestDTO;\n+import org.openhab.binding.myq.internal.dto.LoginResponseDTO;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.FieldNamingPolicy;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+\n+/**\n+ * The {@link MyQAccountHandler} is responsible for communicating with the MyQ API based on an account.\n+ *\n+ * @author Dan Cunningham - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MyQAccountHandler extends BaseBridgeHandler {\n+    private static final String BASE_URL = \"https://api.myqdevice.com/api\";\n+    private final Logger logger = LoggerFactory.getLogger(MyQAccountHandler.class);\n+    private final Gson gsonUpperCase = new GsonBuilder().setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE)\n+            .create();\n+    private final Gson gsonLowerCase = new GsonBuilder()\n+            .setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES).create();\n+    private @Nullable Future<?> normalPollFuture;\n+    private @Nullable Future<?> rapidPollFuture;\n+    private @Nullable String securityToken;\n+    private @Nullable AccountDTO account;\n+    private MyQDiscoveryService discoveryService;\n+    private Integer normalRefreshInterval = 60;\n+    private Integer rapidRefreshInterval = 5;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b5c229bfaec596e8fe209df3946faf55db8b6b9d"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4MDEzNDI3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.myq/src/main/java/org/openhab/binding/myq/internal/handler/MyQAccountHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMDoyODowN1rOIPVIvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMDoyODowN1rOIPVIvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk0NTg1NQ==", "bodyText": "When using the ThingHandlerService, you could set a reference to the discovery service in ThingHandlerService.setThingHandler() to make it acccessible here.", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r552945855", "createdAt": "2021-01-06T20:28:07Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.myq/src/main/java/org/openhab/binding/myq/internal/handler/MyQAccountHandler.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.myq.internal.handler;\n+\n+import static org.openhab.binding.myq.internal.MyQBindingConstants.*;\n+\n+import java.util.Random;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentProvider;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.api.Result;\n+import org.eclipse.jetty.client.util.BufferingResponseListener;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.myq.internal.MyQConfiguration;\n+import org.openhab.binding.myq.internal.MyQDiscoveryService;\n+import org.openhab.binding.myq.internal.dto.AccountDTO;\n+import org.openhab.binding.myq.internal.dto.ActionDTO;\n+import org.openhab.binding.myq.internal.dto.DevicesDTO;\n+import org.openhab.binding.myq.internal.dto.LoginRequestDTO;\n+import org.openhab.binding.myq.internal.dto.LoginResponseDTO;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.FieldNamingPolicy;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+\n+/**\n+ * The {@link MyQAccountHandler} is responsible for communicating with the MyQ API based on an account.\n+ *\n+ * @author Dan Cunningham - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MyQAccountHandler extends BaseBridgeHandler {\n+    private static final String BASE_URL = \"https://api.myqdevice.com/api\";\n+    private final Logger logger = LoggerFactory.getLogger(MyQAccountHandler.class);\n+    private final Gson gsonUpperCase = new GsonBuilder().setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE)\n+            .create();\n+    private final Gson gsonLowerCase = new GsonBuilder()\n+            .setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES).create();\n+    private @Nullable Future<?> normalPollFuture;\n+    private @Nullable Future<?> rapidPollFuture;\n+    private @Nullable String securityToken;\n+    private @Nullable AccountDTO account;\n+    private MyQDiscoveryService discoveryService;\n+    private Integer normalRefreshInterval = 60;\n+    private Integer rapidRefreshInterval = 5;\n+    private HttpClient httpClient;\n+    private String username = \"\";\n+    private String password = \"\";\n+    private String userAgent = \"\";\n+\n+    public MyQAccountHandler(Bridge bridge, HttpClient httpClient, MyQDiscoveryService discoveryService) {\n+        super(bridge);\n+        this.httpClient = httpClient;\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        MyQConfiguration config = getConfigAs(MyQConfiguration.class);\n+        normalRefreshInterval = config.refreshInterval;\n+        username = config.username;\n+        password = config.password;\n+        // MyQ can get picky about blocking user agents apparently\n+        userAgent = MyQAccountHandler.randomString(40);\n+        securityToken = null;\n+        updateStatus(ThingStatus.UNKNOWN);\n+        restartPolls(false);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        stopPolls();\n+    }\n+\n+    /**\n+     * Sends an action to the MyQ API\n+     *\n+     * @param serialNumber\n+     * @param action\n+     */\n+    public void sendAction(String serialNumber, String action) {\n+        AccountDTO localAccount = account;\n+        if (localAccount != null) {\n+            try {\n+                HttpResult result = sendRequest(\n+                        String.format(\"%s/v5.1/Accounts/%s/Devices/%s/actions\", BASE_URL, localAccount.account.id,\n+                                serialNumber),\n+                        HttpMethod.PUT, securityToken,\n+                        new StringContentProvider(gsonLowerCase.toJson(new ActionDTO(action))), \"application/json\");\n+                if (HttpStatus.isSuccess(result.responseCode)) {\n+                    restartPolls(true);\n+                } else {\n+                    logger.debug(\"Failed to send action {} : {}\", action, result.content);\n+                }\n+            } catch (InterruptedException e) {\n+            }\n+        }\n+    }\n+\n+    private void stopPolls() {\n+        stopNormalPoll();\n+        stopRapidPoll();\n+    }\n+\n+    private synchronized void stopNormalPoll() {\n+        stopFuture(normalPollFuture);\n+        normalPollFuture = null;\n+    }\n+\n+    private synchronized void stopRapidPoll() {\n+        stopFuture(rapidPollFuture);\n+        rapidPollFuture = null;\n+    }\n+\n+    private void stopFuture(@Nullable Future<?> future) {\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+    }\n+\n+    private synchronized void restartPolls(boolean rapid) {\n+        stopPolls();\n+        if (rapid) {\n+            normalPollFuture = scheduler.scheduleWithFixedDelay(this::normalPoll, 35, normalRefreshInterval,\n+                    TimeUnit.SECONDS);\n+            rapidPollFuture = scheduler.scheduleWithFixedDelay(this::rapidPoll, 3, rapidRefreshInterval,\n+                    TimeUnit.SECONDS);\n+        } else {\n+            normalPollFuture = scheduler.scheduleWithFixedDelay(this::normalPoll, 0, normalRefreshInterval,\n+                    TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    private void normalPoll() {\n+        stopRapidPoll();\n+        fetchData();\n+    }\n+\n+    private void rapidPoll() {\n+        fetchData();\n+    }\n+\n+    private synchronized void fetchData() {\n+        try {\n+            if (securityToken == null) {\n+                login();\n+                if (securityToken != null) {\n+                    getAccount();\n+                }\n+            }\n+\n+            if (securityToken != null) {\n+                getDevices();\n+            }\n+        } catch (InterruptedException e) {\n+        }\n+    }\n+\n+    private void login() throws InterruptedException {\n+        HttpResult result = sendRequest(BASE_URL + \"/v5/Login\", HttpMethod.POST, null,\n+                new StringContentProvider(gsonUpperCase.toJson(new LoginRequestDTO(username, password))),\n+                \"application/json\");\n+        if (HttpStatus.isSuccess(result.responseCode)) {\n+            LoginResponseDTO loginResponse = gsonUpperCase.fromJson(result.content, LoginResponseDTO.class);\n+            if (loginResponse != null) {\n+                securityToken = loginResponse.securityToken;\n+                updateStatus(ThingStatus.ONLINE);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Invalid Response Body\");\n+            }\n+        } else {\n+            handleErrorResponse(result);\n+            if (thing.getStatusInfo().getStatusDetail() == ThingStatusDetail.CONFIGURATION_ERROR) {\n+                // bad credentials, stop trying to login\n+                stopPolls();\n+            }\n+        }\n+    }\n+\n+    private void getAccount() throws InterruptedException {\n+        HttpResult result = sendRequest(BASE_URL + \"/v5/My?expand=account\", HttpMethod.GET, securityToken, null, null);\n+        if (HttpStatus.isSuccess(result.responseCode)) {\n+            account = gsonUpperCase.fromJson(result.content, AccountDTO.class);\n+        } else {\n+            handleErrorResponse(result);\n+        }\n+    }\n+\n+    private void getDevices() throws InterruptedException {\n+        AccountDTO localAccount = account;\n+        if (localAccount == null) {\n+            return;\n+        }\n+        HttpResult result = sendRequest(String.format(\"%s/v5.1/Accounts/%s/Devices\", BASE_URL, localAccount.account.id),\n+                HttpMethod.GET, securityToken, null, null);\n+        if (HttpStatus.isSuccess(result.responseCode)) {\n+            if (getThing().getStatus() != ThingStatus.ONLINE) {\n+                updateStatus(ThingStatus.ONLINE);\n+            }\n+            DevicesDTO devices = gsonLowerCase.fromJson(result.content, DevicesDTO.class);\n+            if (devices != null) {\n+                devices.items.forEach(device -> {\n+                    ThingTypeUID thingTypeUID = new ThingTypeUID(BINDING_ID, device.deviceFamily);\n+                    if (SUPPORTED_DISCOVERY_THING_TYPES_UIDS.contains(thingTypeUID)) {\n+                        String id = device.serialNumber.toLowerCase();\n+                        for (Thing thing : getThing().getThings()) {\n+                            // support both upper and lower case serialIds\n+                            if (thing.getUID().getId().toLowerCase().equals(id)) {\n+                                ThingHandler handler = thing.getHandler();\n+                                if (handler != null) {\n+                                    ((MyQDeviceHandler) handler).handleDeviceUpdate(device);\n+                                }\n+                                return;\n+                            }\n+                        }\n+                        // did not find a thing, add it to the inbox\n+                        ThingUID thingUID = new ThingUID(thingTypeUID, getThing().getUID(), id);\n+                        discoveryService.deviceDiscovered(thingUID, getThing().getUID(), device.name);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b5c229bfaec596e8fe209df3946faf55db8b6b9d"}, "originalPosition": 253}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4MDEzODIyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.myq/src/main/java/org/openhab/binding/myq/internal/handler/MyQAccountHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMDoyOTozMFrOIPVLEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNlQyMDoyOTozMFrOIPVLEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk0NjQ0OA==", "bodyText": "Are you logging the stack trace by intention?", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r552946448", "createdAt": "2021-01-06T20:29:30Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.myq/src/main/java/org/openhab/binding/myq/internal/handler/MyQAccountHandler.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.myq.internal.handler;\n+\n+import static org.openhab.binding.myq.internal.MyQBindingConstants.*;\n+\n+import java.util.Random;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentProvider;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.api.Result;\n+import org.eclipse.jetty.client.util.BufferingResponseListener;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.myq.internal.MyQConfiguration;\n+import org.openhab.binding.myq.internal.MyQDiscoveryService;\n+import org.openhab.binding.myq.internal.dto.AccountDTO;\n+import org.openhab.binding.myq.internal.dto.ActionDTO;\n+import org.openhab.binding.myq.internal.dto.DevicesDTO;\n+import org.openhab.binding.myq.internal.dto.LoginRequestDTO;\n+import org.openhab.binding.myq.internal.dto.LoginResponseDTO;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.FieldNamingPolicy;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+\n+/**\n+ * The {@link MyQAccountHandler} is responsible for communicating with the MyQ API based on an account.\n+ *\n+ * @author Dan Cunningham - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MyQAccountHandler extends BaseBridgeHandler {\n+    private static final String BASE_URL = \"https://api.myqdevice.com/api\";\n+    private final Logger logger = LoggerFactory.getLogger(MyQAccountHandler.class);\n+    private final Gson gsonUpperCase = new GsonBuilder().setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE)\n+            .create();\n+    private final Gson gsonLowerCase = new GsonBuilder()\n+            .setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES).create();\n+    private @Nullable Future<?> normalPollFuture;\n+    private @Nullable Future<?> rapidPollFuture;\n+    private @Nullable String securityToken;\n+    private @Nullable AccountDTO account;\n+    private MyQDiscoveryService discoveryService;\n+    private Integer normalRefreshInterval = 60;\n+    private Integer rapidRefreshInterval = 5;\n+    private HttpClient httpClient;\n+    private String username = \"\";\n+    private String password = \"\";\n+    private String userAgent = \"\";\n+\n+    public MyQAccountHandler(Bridge bridge, HttpClient httpClient, MyQDiscoveryService discoveryService) {\n+        super(bridge);\n+        this.httpClient = httpClient;\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        MyQConfiguration config = getConfigAs(MyQConfiguration.class);\n+        normalRefreshInterval = config.refreshInterval;\n+        username = config.username;\n+        password = config.password;\n+        // MyQ can get picky about blocking user agents apparently\n+        userAgent = MyQAccountHandler.randomString(40);\n+        securityToken = null;\n+        updateStatus(ThingStatus.UNKNOWN);\n+        restartPolls(false);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        stopPolls();\n+    }\n+\n+    /**\n+     * Sends an action to the MyQ API\n+     *\n+     * @param serialNumber\n+     * @param action\n+     */\n+    public void sendAction(String serialNumber, String action) {\n+        AccountDTO localAccount = account;\n+        if (localAccount != null) {\n+            try {\n+                HttpResult result = sendRequest(\n+                        String.format(\"%s/v5.1/Accounts/%s/Devices/%s/actions\", BASE_URL, localAccount.account.id,\n+                                serialNumber),\n+                        HttpMethod.PUT, securityToken,\n+                        new StringContentProvider(gsonLowerCase.toJson(new ActionDTO(action))), \"application/json\");\n+                if (HttpStatus.isSuccess(result.responseCode)) {\n+                    restartPolls(true);\n+                } else {\n+                    logger.debug(\"Failed to send action {} : {}\", action, result.content);\n+                }\n+            } catch (InterruptedException e) {\n+            }\n+        }\n+    }\n+\n+    private void stopPolls() {\n+        stopNormalPoll();\n+        stopRapidPoll();\n+    }\n+\n+    private synchronized void stopNormalPoll() {\n+        stopFuture(normalPollFuture);\n+        normalPollFuture = null;\n+    }\n+\n+    private synchronized void stopRapidPoll() {\n+        stopFuture(rapidPollFuture);\n+        rapidPollFuture = null;\n+    }\n+\n+    private void stopFuture(@Nullable Future<?> future) {\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+    }\n+\n+    private synchronized void restartPolls(boolean rapid) {\n+        stopPolls();\n+        if (rapid) {\n+            normalPollFuture = scheduler.scheduleWithFixedDelay(this::normalPoll, 35, normalRefreshInterval,\n+                    TimeUnit.SECONDS);\n+            rapidPollFuture = scheduler.scheduleWithFixedDelay(this::rapidPoll, 3, rapidRefreshInterval,\n+                    TimeUnit.SECONDS);\n+        } else {\n+            normalPollFuture = scheduler.scheduleWithFixedDelay(this::normalPoll, 0, normalRefreshInterval,\n+                    TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    private void normalPoll() {\n+        stopRapidPoll();\n+        fetchData();\n+    }\n+\n+    private void rapidPoll() {\n+        fetchData();\n+    }\n+\n+    private synchronized void fetchData() {\n+        try {\n+            if (securityToken == null) {\n+                login();\n+                if (securityToken != null) {\n+                    getAccount();\n+                }\n+            }\n+\n+            if (securityToken != null) {\n+                getDevices();\n+            }\n+        } catch (InterruptedException e) {\n+        }\n+    }\n+\n+    private void login() throws InterruptedException {\n+        HttpResult result = sendRequest(BASE_URL + \"/v5/Login\", HttpMethod.POST, null,\n+                new StringContentProvider(gsonUpperCase.toJson(new LoginRequestDTO(username, password))),\n+                \"application/json\");\n+        if (HttpStatus.isSuccess(result.responseCode)) {\n+            LoginResponseDTO loginResponse = gsonUpperCase.fromJson(result.content, LoginResponseDTO.class);\n+            if (loginResponse != null) {\n+                securityToken = loginResponse.securityToken;\n+                updateStatus(ThingStatus.ONLINE);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Invalid Response Body\");\n+            }\n+        } else {\n+            handleErrorResponse(result);\n+            if (thing.getStatusInfo().getStatusDetail() == ThingStatusDetail.CONFIGURATION_ERROR) {\n+                // bad credentials, stop trying to login\n+                stopPolls();\n+            }\n+        }\n+    }\n+\n+    private void getAccount() throws InterruptedException {\n+        HttpResult result = sendRequest(BASE_URL + \"/v5/My?expand=account\", HttpMethod.GET, securityToken, null, null);\n+        if (HttpStatus.isSuccess(result.responseCode)) {\n+            account = gsonUpperCase.fromJson(result.content, AccountDTO.class);\n+        } else {\n+            handleErrorResponse(result);\n+        }\n+    }\n+\n+    private void getDevices() throws InterruptedException {\n+        AccountDTO localAccount = account;\n+        if (localAccount == null) {\n+            return;\n+        }\n+        HttpResult result = sendRequest(String.format(\"%s/v5.1/Accounts/%s/Devices\", BASE_URL, localAccount.account.id),\n+                HttpMethod.GET, securityToken, null, null);\n+        if (HttpStatus.isSuccess(result.responseCode)) {\n+            if (getThing().getStatus() != ThingStatus.ONLINE) {\n+                updateStatus(ThingStatus.ONLINE);\n+            }\n+            DevicesDTO devices = gsonLowerCase.fromJson(result.content, DevicesDTO.class);\n+            if (devices != null) {\n+                devices.items.forEach(device -> {\n+                    ThingTypeUID thingTypeUID = new ThingTypeUID(BINDING_ID, device.deviceFamily);\n+                    if (SUPPORTED_DISCOVERY_THING_TYPES_UIDS.contains(thingTypeUID)) {\n+                        String id = device.serialNumber.toLowerCase();\n+                        for (Thing thing : getThing().getThings()) {\n+                            // support both upper and lower case serialIds\n+                            if (thing.getUID().getId().toLowerCase().equals(id)) {\n+                                ThingHandler handler = thing.getHandler();\n+                                if (handler != null) {\n+                                    ((MyQDeviceHandler) handler).handleDeviceUpdate(device);\n+                                }\n+                                return;\n+                            }\n+                        }\n+                        // did not find a thing, add it to the inbox\n+                        ThingUID thingUID = new ThingUID(thingTypeUID, getThing().getUID(), id);\n+                        discoveryService.deviceDiscovered(thingUID, getThing().getUID(), device.name);\n+                    }\n+                });\n+            }\n+        } else {\n+            handleErrorResponse(result);\n+        }\n+    }\n+\n+    private synchronized HttpResult sendRequest(String url, HttpMethod method, @Nullable String token,\n+            @Nullable ContentProvider content, @Nullable String contentType) throws InterruptedException {\n+        try {\n+            Request request = httpClient.newRequest(url).method(method)\n+                    .header(\"MyQApplicationId\", \"JVM/G9Nwih5BwKgNCjLxiFUQxQijAebyyg8QUHr7JOrP+tuPb8iHfRHKwTmDzHOu\")\n+                    .header(\"ApiVersion\", \"5.1\").header(\"BrandId\", \"2\").header(\"Culture\", \"en\").agent(userAgent)\n+                    .timeout(10, TimeUnit.SECONDS);\n+            if (token != null) {\n+                request = request.header(\"SecurityToken\", token);\n+            }\n+            if (content != null & contentType != null) {\n+                request = request.content(content, contentType);\n+            }\n+            // use asyc jetty as the API service will response with a 401 error when credentials are wrong,\n+            // but not a WWW-Authenticate header which causes Jetty to throw a generic execution exception which\n+            // prevents us from knowing the response code\n+            logger.trace(\"Sending {} to {}\", request.getMethod(), request.getURI());\n+            final CompletableFuture<HttpResult> futureResult = new CompletableFuture<>();\n+            request.send(new BufferingResponseListener() {\n+                @NonNullByDefault({})\n+                @Override\n+                public void onComplete(Result result) {\n+                    futureResult.complete(new HttpResult(result.getResponse().getStatus(), getContentAsString()));\n+                }\n+            });\n+            HttpResult result = futureResult.get();\n+            logger.trace(\"Account Response - status: {} content: {}\", result.responseCode, result.content);\n+            return result;\n+        } catch (ExecutionException e) {\n+            logger.debug(\"request failed\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b5c229bfaec596e8fe209df3946faf55db8b6b9d"}, "originalPosition": 291}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzUyNjY5OTQ1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.myq/src/main/java/org/openhab/binding/myq/internal/handler/MyQAccountHandler.java", "isResolved": true, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0xOVQxMDoyOTowM1rOIWIH7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yM1QxNDo1MzoxNlrOIZEp6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDA3MjY4Nw==", "bodyText": "If I see correctly this method does the (background) discovery of devices. So, it's better to move this into the discovery service. Then, you won't have a problem with the depdendencies of handler and discovery service either.", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r560072687", "createdAt": "2021-01-19T10:29:03Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.myq/src/main/java/org/openhab/binding/myq/internal/handler/MyQAccountHandler.java", "diffHunk": "@@ -0,0 +1,329 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.myq.internal.handler;\n+\n+import static org.openhab.binding.myq.internal.MyQBindingConstants.*;\n+\n+import java.util.Random;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentProvider;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.api.Result;\n+import org.eclipse.jetty.client.util.BufferingResponseListener;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.myq.internal.MyQConfiguration;\n+import org.openhab.binding.myq.internal.MyQDiscoveryService;\n+import org.openhab.binding.myq.internal.dto.AccountDTO;\n+import org.openhab.binding.myq.internal.dto.ActionDTO;\n+import org.openhab.binding.myq.internal.dto.DevicesDTO;\n+import org.openhab.binding.myq.internal.dto.LoginRequestDTO;\n+import org.openhab.binding.myq.internal.dto.LoginResponseDTO;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.FieldNamingPolicy;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+\n+/**\n+ * The {@link MyQAccountHandler} is responsible for communicating with the MyQ API based on an account.\n+ *\n+ * @author Dan Cunningham - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MyQAccountHandler extends BaseBridgeHandler {\n+    private static final String BASE_URL = \"https://api.myqdevice.com/api\";\n+    private static final Integer RAPID_REFRESH_SECONDS = 5;\n+    private final Logger logger = LoggerFactory.getLogger(MyQAccountHandler.class);\n+    private final Gson gsonUpperCase = new GsonBuilder().setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE)\n+            .create();\n+    private final Gson gsonLowerCase = new GsonBuilder()\n+            .setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES).create();\n+    private @Nullable Future<?> normalPollFuture;\n+    private @Nullable Future<?> rapidPollFuture;\n+    private @Nullable String securityToken;\n+    private @Nullable AccountDTO account;\n+    private Integer normalRefreshSeconds = 60;\n+    private MyQDiscoveryService discoveryService;\n+    private HttpClient httpClient;\n+    private String username = \"\";\n+    private String password = \"\";\n+    private String userAgent = \"\";\n+\n+    public MyQAccountHandler(Bridge bridge, HttpClient httpClient, MyQDiscoveryService discoveryService) {\n+        super(bridge);\n+        this.httpClient = httpClient;\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        MyQConfiguration config = getConfigAs(MyQConfiguration.class);\n+        normalRefreshSeconds = config.refreshInterval;\n+        username = config.username;\n+        password = config.password;\n+        // MyQ can get picky about blocking user agents apparently\n+        userAgent = MyQAccountHandler.randomString(40);\n+        securityToken = null;\n+        updateStatus(ThingStatus.UNKNOWN);\n+        restartPolls(false);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        stopPolls();\n+    }\n+\n+    /**\n+     * Sends an action to the MyQ API\n+     *\n+     * @param serialNumber\n+     * @param action\n+     */\n+    public void sendAction(String serialNumber, String action) {\n+        AccountDTO localAccount = account;\n+        if (localAccount != null) {\n+            try {\n+                HttpResult result = sendRequest(\n+                        String.format(\"%s/v5.1/Accounts/%s/Devices/%s/actions\", BASE_URL, localAccount.account.id,\n+                                serialNumber),\n+                        HttpMethod.PUT, securityToken,\n+                        new StringContentProvider(gsonLowerCase.toJson(new ActionDTO(action))), \"application/json\");\n+                if (HttpStatus.isSuccess(result.responseCode)) {\n+                    restartPolls(true);\n+                } else {\n+                    logger.debug(\"Failed to send action {} : {}\", action, result.content);\n+                }\n+            } catch (InterruptedException e) {\n+            }\n+        }\n+    }\n+\n+    private void stopPolls() {\n+        stopNormalPoll();\n+        stopRapidPoll();\n+    }\n+\n+    private synchronized void stopNormalPoll() {\n+        stopFuture(normalPollFuture);\n+        normalPollFuture = null;\n+    }\n+\n+    private synchronized void stopRapidPoll() {\n+        stopFuture(rapidPollFuture);\n+        rapidPollFuture = null;\n+    }\n+\n+    private void stopFuture(@Nullable Future<?> future) {\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+    }\n+\n+    private synchronized void restartPolls(boolean rapid) {\n+        stopPolls();\n+        if (rapid) {\n+            normalPollFuture = scheduler.scheduleWithFixedDelay(this::normalPoll, 35, normalRefreshSeconds,\n+                    TimeUnit.SECONDS);\n+            rapidPollFuture = scheduler.scheduleWithFixedDelay(this::rapidPoll, 3, RAPID_REFRESH_SECONDS,\n+                    TimeUnit.SECONDS);\n+        } else {\n+            normalPollFuture = scheduler.scheduleWithFixedDelay(this::normalPoll, 0, normalRefreshSeconds,\n+                    TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    private void normalPoll() {\n+        stopRapidPoll();\n+        fetchData();\n+    }\n+\n+    private void rapidPoll() {\n+        fetchData();\n+    }\n+\n+    private synchronized void fetchData() {\n+        try {\n+            if (securityToken == null) {\n+                login();\n+                if (securityToken != null) {\n+                    getAccount();\n+                }\n+            }\n+\n+            if (securityToken != null) {\n+                getDevices();\n+            }\n+        } catch (InterruptedException e) {\n+        }\n+    }\n+\n+    private void login() throws InterruptedException {\n+        HttpResult result = sendRequest(BASE_URL + \"/v5/Login\", HttpMethod.POST, null,\n+                new StringContentProvider(gsonUpperCase.toJson(new LoginRequestDTO(username, password))),\n+                \"application/json\");\n+        if (HttpStatus.isSuccess(result.responseCode)) {\n+            LoginResponseDTO loginResponse = gsonUpperCase.fromJson(result.content, LoginResponseDTO.class);\n+            if (loginResponse != null) {\n+                securityToken = loginResponse.securityToken;\n+                updateStatus(ThingStatus.ONLINE);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Invalid Response Body\");\n+            }\n+        } else {\n+            handleErrorResponse(result);\n+            if (thing.getStatusInfo().getStatusDetail() == ThingStatusDetail.CONFIGURATION_ERROR) {\n+                // bad credentials, stop trying to login\n+                stopPolls();\n+            }\n+        }\n+    }\n+\n+    private void getAccount() throws InterruptedException {\n+        HttpResult result = sendRequest(BASE_URL + \"/v5/My?expand=account\", HttpMethod.GET, securityToken, null, null);\n+        if (HttpStatus.isSuccess(result.responseCode)) {\n+            account = gsonUpperCase.fromJson(result.content, AccountDTO.class);\n+        } else {\n+            handleErrorResponse(result);\n+        }\n+    }\n+\n+    private void getDevices() throws InterruptedException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bddbad680c579f681166de9de5a4aa2f6f76bee9"}, "originalPosition": 224}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDM2NTg2Mw==", "bodyText": "when i poll the API i get all devices, so every poll cycle (60 seconds default ) i have the opportunity to discover new devices. I assumed this would be more efficient than having to schedule a separate call to the bridge to do an additional poll just to discover devices, that seemed less efficient with more complexity.", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r560365863", "createdAt": "2021-01-19T17:44:43Z", "author": {"login": "digitaldan"}, "path": "bundles/org.openhab.binding.myq/src/main/java/org/openhab/binding/myq/internal/handler/MyQAccountHandler.java", "diffHunk": "@@ -0,0 +1,329 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.myq.internal.handler;\n+\n+import static org.openhab.binding.myq.internal.MyQBindingConstants.*;\n+\n+import java.util.Random;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentProvider;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.api.Result;\n+import org.eclipse.jetty.client.util.BufferingResponseListener;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.myq.internal.MyQConfiguration;\n+import org.openhab.binding.myq.internal.MyQDiscoveryService;\n+import org.openhab.binding.myq.internal.dto.AccountDTO;\n+import org.openhab.binding.myq.internal.dto.ActionDTO;\n+import org.openhab.binding.myq.internal.dto.DevicesDTO;\n+import org.openhab.binding.myq.internal.dto.LoginRequestDTO;\n+import org.openhab.binding.myq.internal.dto.LoginResponseDTO;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.FieldNamingPolicy;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+\n+/**\n+ * The {@link MyQAccountHandler} is responsible for communicating with the MyQ API based on an account.\n+ *\n+ * @author Dan Cunningham - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MyQAccountHandler extends BaseBridgeHandler {\n+    private static final String BASE_URL = \"https://api.myqdevice.com/api\";\n+    private static final Integer RAPID_REFRESH_SECONDS = 5;\n+    private final Logger logger = LoggerFactory.getLogger(MyQAccountHandler.class);\n+    private final Gson gsonUpperCase = new GsonBuilder().setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE)\n+            .create();\n+    private final Gson gsonLowerCase = new GsonBuilder()\n+            .setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES).create();\n+    private @Nullable Future<?> normalPollFuture;\n+    private @Nullable Future<?> rapidPollFuture;\n+    private @Nullable String securityToken;\n+    private @Nullable AccountDTO account;\n+    private Integer normalRefreshSeconds = 60;\n+    private MyQDiscoveryService discoveryService;\n+    private HttpClient httpClient;\n+    private String username = \"\";\n+    private String password = \"\";\n+    private String userAgent = \"\";\n+\n+    public MyQAccountHandler(Bridge bridge, HttpClient httpClient, MyQDiscoveryService discoveryService) {\n+        super(bridge);\n+        this.httpClient = httpClient;\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        MyQConfiguration config = getConfigAs(MyQConfiguration.class);\n+        normalRefreshSeconds = config.refreshInterval;\n+        username = config.username;\n+        password = config.password;\n+        // MyQ can get picky about blocking user agents apparently\n+        userAgent = MyQAccountHandler.randomString(40);\n+        securityToken = null;\n+        updateStatus(ThingStatus.UNKNOWN);\n+        restartPolls(false);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        stopPolls();\n+    }\n+\n+    /**\n+     * Sends an action to the MyQ API\n+     *\n+     * @param serialNumber\n+     * @param action\n+     */\n+    public void sendAction(String serialNumber, String action) {\n+        AccountDTO localAccount = account;\n+        if (localAccount != null) {\n+            try {\n+                HttpResult result = sendRequest(\n+                        String.format(\"%s/v5.1/Accounts/%s/Devices/%s/actions\", BASE_URL, localAccount.account.id,\n+                                serialNumber),\n+                        HttpMethod.PUT, securityToken,\n+                        new StringContentProvider(gsonLowerCase.toJson(new ActionDTO(action))), \"application/json\");\n+                if (HttpStatus.isSuccess(result.responseCode)) {\n+                    restartPolls(true);\n+                } else {\n+                    logger.debug(\"Failed to send action {} : {}\", action, result.content);\n+                }\n+            } catch (InterruptedException e) {\n+            }\n+        }\n+    }\n+\n+    private void stopPolls() {\n+        stopNormalPoll();\n+        stopRapidPoll();\n+    }\n+\n+    private synchronized void stopNormalPoll() {\n+        stopFuture(normalPollFuture);\n+        normalPollFuture = null;\n+    }\n+\n+    private synchronized void stopRapidPoll() {\n+        stopFuture(rapidPollFuture);\n+        rapidPollFuture = null;\n+    }\n+\n+    private void stopFuture(@Nullable Future<?> future) {\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+    }\n+\n+    private synchronized void restartPolls(boolean rapid) {\n+        stopPolls();\n+        if (rapid) {\n+            normalPollFuture = scheduler.scheduleWithFixedDelay(this::normalPoll, 35, normalRefreshSeconds,\n+                    TimeUnit.SECONDS);\n+            rapidPollFuture = scheduler.scheduleWithFixedDelay(this::rapidPoll, 3, RAPID_REFRESH_SECONDS,\n+                    TimeUnit.SECONDS);\n+        } else {\n+            normalPollFuture = scheduler.scheduleWithFixedDelay(this::normalPoll, 0, normalRefreshSeconds,\n+                    TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    private void normalPoll() {\n+        stopRapidPoll();\n+        fetchData();\n+    }\n+\n+    private void rapidPoll() {\n+        fetchData();\n+    }\n+\n+    private synchronized void fetchData() {\n+        try {\n+            if (securityToken == null) {\n+                login();\n+                if (securityToken != null) {\n+                    getAccount();\n+                }\n+            }\n+\n+            if (securityToken != null) {\n+                getDevices();\n+            }\n+        } catch (InterruptedException e) {\n+        }\n+    }\n+\n+    private void login() throws InterruptedException {\n+        HttpResult result = sendRequest(BASE_URL + \"/v5/Login\", HttpMethod.POST, null,\n+                new StringContentProvider(gsonUpperCase.toJson(new LoginRequestDTO(username, password))),\n+                \"application/json\");\n+        if (HttpStatus.isSuccess(result.responseCode)) {\n+            LoginResponseDTO loginResponse = gsonUpperCase.fromJson(result.content, LoginResponseDTO.class);\n+            if (loginResponse != null) {\n+                securityToken = loginResponse.securityToken;\n+                updateStatus(ThingStatus.ONLINE);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Invalid Response Body\");\n+            }\n+        } else {\n+            handleErrorResponse(result);\n+            if (thing.getStatusInfo().getStatusDetail() == ThingStatusDetail.CONFIGURATION_ERROR) {\n+                // bad credentials, stop trying to login\n+                stopPolls();\n+            }\n+        }\n+    }\n+\n+    private void getAccount() throws InterruptedException {\n+        HttpResult result = sendRequest(BASE_URL + \"/v5/My?expand=account\", HttpMethod.GET, securityToken, null, null);\n+        if (HttpStatus.isSuccess(result.responseCode)) {\n+            account = gsonUpperCase.fromJson(result.content, AccountDTO.class);\n+        } else {\n+            handleErrorResponse(result);\n+        }\n+    }\n+\n+    private void getDevices() throws InterruptedException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDA3MjY4Nw=="}, "originalCommit": {"oid": "bddbad680c579f681166de9de5a4aa2f6f76bee9"}, "originalPosition": 224}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDM4NDgxMA==", "bodyText": "Maybe the API has the ability to query only the state of one devices at a time? If not, I would do a discovery only if the user triggered a scan. That would reduce overall code complexity.", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r560384810", "createdAt": "2021-01-19T18:14:46Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.myq/src/main/java/org/openhab/binding/myq/internal/handler/MyQAccountHandler.java", "diffHunk": "@@ -0,0 +1,329 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.myq.internal.handler;\n+\n+import static org.openhab.binding.myq.internal.MyQBindingConstants.*;\n+\n+import java.util.Random;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentProvider;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.api.Result;\n+import org.eclipse.jetty.client.util.BufferingResponseListener;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.myq.internal.MyQConfiguration;\n+import org.openhab.binding.myq.internal.MyQDiscoveryService;\n+import org.openhab.binding.myq.internal.dto.AccountDTO;\n+import org.openhab.binding.myq.internal.dto.ActionDTO;\n+import org.openhab.binding.myq.internal.dto.DevicesDTO;\n+import org.openhab.binding.myq.internal.dto.LoginRequestDTO;\n+import org.openhab.binding.myq.internal.dto.LoginResponseDTO;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.FieldNamingPolicy;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+\n+/**\n+ * The {@link MyQAccountHandler} is responsible for communicating with the MyQ API based on an account.\n+ *\n+ * @author Dan Cunningham - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MyQAccountHandler extends BaseBridgeHandler {\n+    private static final String BASE_URL = \"https://api.myqdevice.com/api\";\n+    private static final Integer RAPID_REFRESH_SECONDS = 5;\n+    private final Logger logger = LoggerFactory.getLogger(MyQAccountHandler.class);\n+    private final Gson gsonUpperCase = new GsonBuilder().setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE)\n+            .create();\n+    private final Gson gsonLowerCase = new GsonBuilder()\n+            .setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES).create();\n+    private @Nullable Future<?> normalPollFuture;\n+    private @Nullable Future<?> rapidPollFuture;\n+    private @Nullable String securityToken;\n+    private @Nullable AccountDTO account;\n+    private Integer normalRefreshSeconds = 60;\n+    private MyQDiscoveryService discoveryService;\n+    private HttpClient httpClient;\n+    private String username = \"\";\n+    private String password = \"\";\n+    private String userAgent = \"\";\n+\n+    public MyQAccountHandler(Bridge bridge, HttpClient httpClient, MyQDiscoveryService discoveryService) {\n+        super(bridge);\n+        this.httpClient = httpClient;\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        MyQConfiguration config = getConfigAs(MyQConfiguration.class);\n+        normalRefreshSeconds = config.refreshInterval;\n+        username = config.username;\n+        password = config.password;\n+        // MyQ can get picky about blocking user agents apparently\n+        userAgent = MyQAccountHandler.randomString(40);\n+        securityToken = null;\n+        updateStatus(ThingStatus.UNKNOWN);\n+        restartPolls(false);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        stopPolls();\n+    }\n+\n+    /**\n+     * Sends an action to the MyQ API\n+     *\n+     * @param serialNumber\n+     * @param action\n+     */\n+    public void sendAction(String serialNumber, String action) {\n+        AccountDTO localAccount = account;\n+        if (localAccount != null) {\n+            try {\n+                HttpResult result = sendRequest(\n+                        String.format(\"%s/v5.1/Accounts/%s/Devices/%s/actions\", BASE_URL, localAccount.account.id,\n+                                serialNumber),\n+                        HttpMethod.PUT, securityToken,\n+                        new StringContentProvider(gsonLowerCase.toJson(new ActionDTO(action))), \"application/json\");\n+                if (HttpStatus.isSuccess(result.responseCode)) {\n+                    restartPolls(true);\n+                } else {\n+                    logger.debug(\"Failed to send action {} : {}\", action, result.content);\n+                }\n+            } catch (InterruptedException e) {\n+            }\n+        }\n+    }\n+\n+    private void stopPolls() {\n+        stopNormalPoll();\n+        stopRapidPoll();\n+    }\n+\n+    private synchronized void stopNormalPoll() {\n+        stopFuture(normalPollFuture);\n+        normalPollFuture = null;\n+    }\n+\n+    private synchronized void stopRapidPoll() {\n+        stopFuture(rapidPollFuture);\n+        rapidPollFuture = null;\n+    }\n+\n+    private void stopFuture(@Nullable Future<?> future) {\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+    }\n+\n+    private synchronized void restartPolls(boolean rapid) {\n+        stopPolls();\n+        if (rapid) {\n+            normalPollFuture = scheduler.scheduleWithFixedDelay(this::normalPoll, 35, normalRefreshSeconds,\n+                    TimeUnit.SECONDS);\n+            rapidPollFuture = scheduler.scheduleWithFixedDelay(this::rapidPoll, 3, RAPID_REFRESH_SECONDS,\n+                    TimeUnit.SECONDS);\n+        } else {\n+            normalPollFuture = scheduler.scheduleWithFixedDelay(this::normalPoll, 0, normalRefreshSeconds,\n+                    TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    private void normalPoll() {\n+        stopRapidPoll();\n+        fetchData();\n+    }\n+\n+    private void rapidPoll() {\n+        fetchData();\n+    }\n+\n+    private synchronized void fetchData() {\n+        try {\n+            if (securityToken == null) {\n+                login();\n+                if (securityToken != null) {\n+                    getAccount();\n+                }\n+            }\n+\n+            if (securityToken != null) {\n+                getDevices();\n+            }\n+        } catch (InterruptedException e) {\n+        }\n+    }\n+\n+    private void login() throws InterruptedException {\n+        HttpResult result = sendRequest(BASE_URL + \"/v5/Login\", HttpMethod.POST, null,\n+                new StringContentProvider(gsonUpperCase.toJson(new LoginRequestDTO(username, password))),\n+                \"application/json\");\n+        if (HttpStatus.isSuccess(result.responseCode)) {\n+            LoginResponseDTO loginResponse = gsonUpperCase.fromJson(result.content, LoginResponseDTO.class);\n+            if (loginResponse != null) {\n+                securityToken = loginResponse.securityToken;\n+                updateStatus(ThingStatus.ONLINE);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Invalid Response Body\");\n+            }\n+        } else {\n+            handleErrorResponse(result);\n+            if (thing.getStatusInfo().getStatusDetail() == ThingStatusDetail.CONFIGURATION_ERROR) {\n+                // bad credentials, stop trying to login\n+                stopPolls();\n+            }\n+        }\n+    }\n+\n+    private void getAccount() throws InterruptedException {\n+        HttpResult result = sendRequest(BASE_URL + \"/v5/My?expand=account\", HttpMethod.GET, securityToken, null, null);\n+        if (HttpStatus.isSuccess(result.responseCode)) {\n+            account = gsonUpperCase.fromJson(result.content, AccountDTO.class);\n+        } else {\n+            handleErrorResponse(result);\n+        }\n+    }\n+\n+    private void getDevices() throws InterruptedException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDA3MjY4Nw=="}, "originalCommit": {"oid": "bddbad680c579f681166de9de5a4aa2f6f76bee9"}, "originalPosition": 224}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDM5OTQwOQ==", "bodyText": "Its' a single api call that i'm using, the API is not documented and heavily rate limited, its not clear even if there is a single device endpoint (which i have not seen), if you had more then one, how that would blow through the rate limiting polling for each.  FYI i have a 2 bay garage, so i have 2 units under the same account.\n\nThat would reduce overall code complexity.\n\nI'm all for reducing complexity, but i'm not sure i see that happening, we would have the same discovery code that exists, PLUS i would need to add additional methods to call the same poll code, but this time not to update devices, just for discovery,  its going to be more code, additional coordination of outgoing requests and much more complex IMHO.", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r560399409", "createdAt": "2021-01-19T18:38:52Z", "author": {"login": "digitaldan"}, "path": "bundles/org.openhab.binding.myq/src/main/java/org/openhab/binding/myq/internal/handler/MyQAccountHandler.java", "diffHunk": "@@ -0,0 +1,329 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.myq.internal.handler;\n+\n+import static org.openhab.binding.myq.internal.MyQBindingConstants.*;\n+\n+import java.util.Random;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentProvider;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.api.Result;\n+import org.eclipse.jetty.client.util.BufferingResponseListener;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.myq.internal.MyQConfiguration;\n+import org.openhab.binding.myq.internal.MyQDiscoveryService;\n+import org.openhab.binding.myq.internal.dto.AccountDTO;\n+import org.openhab.binding.myq.internal.dto.ActionDTO;\n+import org.openhab.binding.myq.internal.dto.DevicesDTO;\n+import org.openhab.binding.myq.internal.dto.LoginRequestDTO;\n+import org.openhab.binding.myq.internal.dto.LoginResponseDTO;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.FieldNamingPolicy;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+\n+/**\n+ * The {@link MyQAccountHandler} is responsible for communicating with the MyQ API based on an account.\n+ *\n+ * @author Dan Cunningham - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MyQAccountHandler extends BaseBridgeHandler {\n+    private static final String BASE_URL = \"https://api.myqdevice.com/api\";\n+    private static final Integer RAPID_REFRESH_SECONDS = 5;\n+    private final Logger logger = LoggerFactory.getLogger(MyQAccountHandler.class);\n+    private final Gson gsonUpperCase = new GsonBuilder().setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE)\n+            .create();\n+    private final Gson gsonLowerCase = new GsonBuilder()\n+            .setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES).create();\n+    private @Nullable Future<?> normalPollFuture;\n+    private @Nullable Future<?> rapidPollFuture;\n+    private @Nullable String securityToken;\n+    private @Nullable AccountDTO account;\n+    private Integer normalRefreshSeconds = 60;\n+    private MyQDiscoveryService discoveryService;\n+    private HttpClient httpClient;\n+    private String username = \"\";\n+    private String password = \"\";\n+    private String userAgent = \"\";\n+\n+    public MyQAccountHandler(Bridge bridge, HttpClient httpClient, MyQDiscoveryService discoveryService) {\n+        super(bridge);\n+        this.httpClient = httpClient;\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        MyQConfiguration config = getConfigAs(MyQConfiguration.class);\n+        normalRefreshSeconds = config.refreshInterval;\n+        username = config.username;\n+        password = config.password;\n+        // MyQ can get picky about blocking user agents apparently\n+        userAgent = MyQAccountHandler.randomString(40);\n+        securityToken = null;\n+        updateStatus(ThingStatus.UNKNOWN);\n+        restartPolls(false);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        stopPolls();\n+    }\n+\n+    /**\n+     * Sends an action to the MyQ API\n+     *\n+     * @param serialNumber\n+     * @param action\n+     */\n+    public void sendAction(String serialNumber, String action) {\n+        AccountDTO localAccount = account;\n+        if (localAccount != null) {\n+            try {\n+                HttpResult result = sendRequest(\n+                        String.format(\"%s/v5.1/Accounts/%s/Devices/%s/actions\", BASE_URL, localAccount.account.id,\n+                                serialNumber),\n+                        HttpMethod.PUT, securityToken,\n+                        new StringContentProvider(gsonLowerCase.toJson(new ActionDTO(action))), \"application/json\");\n+                if (HttpStatus.isSuccess(result.responseCode)) {\n+                    restartPolls(true);\n+                } else {\n+                    logger.debug(\"Failed to send action {} : {}\", action, result.content);\n+                }\n+            } catch (InterruptedException e) {\n+            }\n+        }\n+    }\n+\n+    private void stopPolls() {\n+        stopNormalPoll();\n+        stopRapidPoll();\n+    }\n+\n+    private synchronized void stopNormalPoll() {\n+        stopFuture(normalPollFuture);\n+        normalPollFuture = null;\n+    }\n+\n+    private synchronized void stopRapidPoll() {\n+        stopFuture(rapidPollFuture);\n+        rapidPollFuture = null;\n+    }\n+\n+    private void stopFuture(@Nullable Future<?> future) {\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+    }\n+\n+    private synchronized void restartPolls(boolean rapid) {\n+        stopPolls();\n+        if (rapid) {\n+            normalPollFuture = scheduler.scheduleWithFixedDelay(this::normalPoll, 35, normalRefreshSeconds,\n+                    TimeUnit.SECONDS);\n+            rapidPollFuture = scheduler.scheduleWithFixedDelay(this::rapidPoll, 3, RAPID_REFRESH_SECONDS,\n+                    TimeUnit.SECONDS);\n+        } else {\n+            normalPollFuture = scheduler.scheduleWithFixedDelay(this::normalPoll, 0, normalRefreshSeconds,\n+                    TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    private void normalPoll() {\n+        stopRapidPoll();\n+        fetchData();\n+    }\n+\n+    private void rapidPoll() {\n+        fetchData();\n+    }\n+\n+    private synchronized void fetchData() {\n+        try {\n+            if (securityToken == null) {\n+                login();\n+                if (securityToken != null) {\n+                    getAccount();\n+                }\n+            }\n+\n+            if (securityToken != null) {\n+                getDevices();\n+            }\n+        } catch (InterruptedException e) {\n+        }\n+    }\n+\n+    private void login() throws InterruptedException {\n+        HttpResult result = sendRequest(BASE_URL + \"/v5/Login\", HttpMethod.POST, null,\n+                new StringContentProvider(gsonUpperCase.toJson(new LoginRequestDTO(username, password))),\n+                \"application/json\");\n+        if (HttpStatus.isSuccess(result.responseCode)) {\n+            LoginResponseDTO loginResponse = gsonUpperCase.fromJson(result.content, LoginResponseDTO.class);\n+            if (loginResponse != null) {\n+                securityToken = loginResponse.securityToken;\n+                updateStatus(ThingStatus.ONLINE);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Invalid Response Body\");\n+            }\n+        } else {\n+            handleErrorResponse(result);\n+            if (thing.getStatusInfo().getStatusDetail() == ThingStatusDetail.CONFIGURATION_ERROR) {\n+                // bad credentials, stop trying to login\n+                stopPolls();\n+            }\n+        }\n+    }\n+\n+    private void getAccount() throws InterruptedException {\n+        HttpResult result = sendRequest(BASE_URL + \"/v5/My?expand=account\", HttpMethod.GET, securityToken, null, null);\n+        if (HttpStatus.isSuccess(result.responseCode)) {\n+            account = gsonUpperCase.fromJson(result.content, AccountDTO.class);\n+        } else {\n+            handleErrorResponse(result);\n+        }\n+    }\n+\n+    private void getDevices() throws InterruptedException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDA3MjY4Nw=="}, "originalCommit": {"oid": "bddbad680c579f681166de9de5a4aa2f6f76bee9"}, "originalPosition": 224}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTEzMzI2Mw==", "bodyText": "It's reasonable to make one request for all devices due to the rate limit. Nevertheless, the discovery service could make its own request as it is not triggered permanently. This way you could cut off the counter intuitive reverse dependency of bridge handler and discovery service and you can implement the ThingHandlerService. Of course you could make getDevices() stateless and reuseable to use it in the bridge handler and the discovery service.", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r561133263", "createdAt": "2021-01-20T17:10:20Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.myq/src/main/java/org/openhab/binding/myq/internal/handler/MyQAccountHandler.java", "diffHunk": "@@ -0,0 +1,329 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.myq.internal.handler;\n+\n+import static org.openhab.binding.myq.internal.MyQBindingConstants.*;\n+\n+import java.util.Random;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentProvider;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.api.Result;\n+import org.eclipse.jetty.client.util.BufferingResponseListener;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.myq.internal.MyQConfiguration;\n+import org.openhab.binding.myq.internal.MyQDiscoveryService;\n+import org.openhab.binding.myq.internal.dto.AccountDTO;\n+import org.openhab.binding.myq.internal.dto.ActionDTO;\n+import org.openhab.binding.myq.internal.dto.DevicesDTO;\n+import org.openhab.binding.myq.internal.dto.LoginRequestDTO;\n+import org.openhab.binding.myq.internal.dto.LoginResponseDTO;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.FieldNamingPolicy;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+\n+/**\n+ * The {@link MyQAccountHandler} is responsible for communicating with the MyQ API based on an account.\n+ *\n+ * @author Dan Cunningham - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MyQAccountHandler extends BaseBridgeHandler {\n+    private static final String BASE_URL = \"https://api.myqdevice.com/api\";\n+    private static final Integer RAPID_REFRESH_SECONDS = 5;\n+    private final Logger logger = LoggerFactory.getLogger(MyQAccountHandler.class);\n+    private final Gson gsonUpperCase = new GsonBuilder().setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE)\n+            .create();\n+    private final Gson gsonLowerCase = new GsonBuilder()\n+            .setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES).create();\n+    private @Nullable Future<?> normalPollFuture;\n+    private @Nullable Future<?> rapidPollFuture;\n+    private @Nullable String securityToken;\n+    private @Nullable AccountDTO account;\n+    private Integer normalRefreshSeconds = 60;\n+    private MyQDiscoveryService discoveryService;\n+    private HttpClient httpClient;\n+    private String username = \"\";\n+    private String password = \"\";\n+    private String userAgent = \"\";\n+\n+    public MyQAccountHandler(Bridge bridge, HttpClient httpClient, MyQDiscoveryService discoveryService) {\n+        super(bridge);\n+        this.httpClient = httpClient;\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        MyQConfiguration config = getConfigAs(MyQConfiguration.class);\n+        normalRefreshSeconds = config.refreshInterval;\n+        username = config.username;\n+        password = config.password;\n+        // MyQ can get picky about blocking user agents apparently\n+        userAgent = MyQAccountHandler.randomString(40);\n+        securityToken = null;\n+        updateStatus(ThingStatus.UNKNOWN);\n+        restartPolls(false);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        stopPolls();\n+    }\n+\n+    /**\n+     * Sends an action to the MyQ API\n+     *\n+     * @param serialNumber\n+     * @param action\n+     */\n+    public void sendAction(String serialNumber, String action) {\n+        AccountDTO localAccount = account;\n+        if (localAccount != null) {\n+            try {\n+                HttpResult result = sendRequest(\n+                        String.format(\"%s/v5.1/Accounts/%s/Devices/%s/actions\", BASE_URL, localAccount.account.id,\n+                                serialNumber),\n+                        HttpMethod.PUT, securityToken,\n+                        new StringContentProvider(gsonLowerCase.toJson(new ActionDTO(action))), \"application/json\");\n+                if (HttpStatus.isSuccess(result.responseCode)) {\n+                    restartPolls(true);\n+                } else {\n+                    logger.debug(\"Failed to send action {} : {}\", action, result.content);\n+                }\n+            } catch (InterruptedException e) {\n+            }\n+        }\n+    }\n+\n+    private void stopPolls() {\n+        stopNormalPoll();\n+        stopRapidPoll();\n+    }\n+\n+    private synchronized void stopNormalPoll() {\n+        stopFuture(normalPollFuture);\n+        normalPollFuture = null;\n+    }\n+\n+    private synchronized void stopRapidPoll() {\n+        stopFuture(rapidPollFuture);\n+        rapidPollFuture = null;\n+    }\n+\n+    private void stopFuture(@Nullable Future<?> future) {\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+    }\n+\n+    private synchronized void restartPolls(boolean rapid) {\n+        stopPolls();\n+        if (rapid) {\n+            normalPollFuture = scheduler.scheduleWithFixedDelay(this::normalPoll, 35, normalRefreshSeconds,\n+                    TimeUnit.SECONDS);\n+            rapidPollFuture = scheduler.scheduleWithFixedDelay(this::rapidPoll, 3, RAPID_REFRESH_SECONDS,\n+                    TimeUnit.SECONDS);\n+        } else {\n+            normalPollFuture = scheduler.scheduleWithFixedDelay(this::normalPoll, 0, normalRefreshSeconds,\n+                    TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    private void normalPoll() {\n+        stopRapidPoll();\n+        fetchData();\n+    }\n+\n+    private void rapidPoll() {\n+        fetchData();\n+    }\n+\n+    private synchronized void fetchData() {\n+        try {\n+            if (securityToken == null) {\n+                login();\n+                if (securityToken != null) {\n+                    getAccount();\n+                }\n+            }\n+\n+            if (securityToken != null) {\n+                getDevices();\n+            }\n+        } catch (InterruptedException e) {\n+        }\n+    }\n+\n+    private void login() throws InterruptedException {\n+        HttpResult result = sendRequest(BASE_URL + \"/v5/Login\", HttpMethod.POST, null,\n+                new StringContentProvider(gsonUpperCase.toJson(new LoginRequestDTO(username, password))),\n+                \"application/json\");\n+        if (HttpStatus.isSuccess(result.responseCode)) {\n+            LoginResponseDTO loginResponse = gsonUpperCase.fromJson(result.content, LoginResponseDTO.class);\n+            if (loginResponse != null) {\n+                securityToken = loginResponse.securityToken;\n+                updateStatus(ThingStatus.ONLINE);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Invalid Response Body\");\n+            }\n+        } else {\n+            handleErrorResponse(result);\n+            if (thing.getStatusInfo().getStatusDetail() == ThingStatusDetail.CONFIGURATION_ERROR) {\n+                // bad credentials, stop trying to login\n+                stopPolls();\n+            }\n+        }\n+    }\n+\n+    private void getAccount() throws InterruptedException {\n+        HttpResult result = sendRequest(BASE_URL + \"/v5/My?expand=account\", HttpMethod.GET, securityToken, null, null);\n+        if (HttpStatus.isSuccess(result.responseCode)) {\n+            account = gsonUpperCase.fromJson(result.content, AccountDTO.class);\n+        } else {\n+            handleErrorResponse(result);\n+        }\n+    }\n+\n+    private void getDevices() throws InterruptedException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDA3MjY4Nw=="}, "originalCommit": {"oid": "bddbad680c579f681166de9de5a4aa2f6f76bee9"}, "originalPosition": 224}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjQxMjUyNw==", "bodyText": "Hi @fwolter  i have refactored the discover class to use the ThingHandlerService .  I did not realize this removed the need for all the boiler plate code in the handler factory to create, track and destroy the discovery service, so i agree this was worth the refactoring.", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r562412527", "createdAt": "2021-01-22T06:23:30Z", "author": {"login": "digitaldan"}, "path": "bundles/org.openhab.binding.myq/src/main/java/org/openhab/binding/myq/internal/handler/MyQAccountHandler.java", "diffHunk": "@@ -0,0 +1,329 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.myq.internal.handler;\n+\n+import static org.openhab.binding.myq.internal.MyQBindingConstants.*;\n+\n+import java.util.Random;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentProvider;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.api.Result;\n+import org.eclipse.jetty.client.util.BufferingResponseListener;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.myq.internal.MyQConfiguration;\n+import org.openhab.binding.myq.internal.MyQDiscoveryService;\n+import org.openhab.binding.myq.internal.dto.AccountDTO;\n+import org.openhab.binding.myq.internal.dto.ActionDTO;\n+import org.openhab.binding.myq.internal.dto.DevicesDTO;\n+import org.openhab.binding.myq.internal.dto.LoginRequestDTO;\n+import org.openhab.binding.myq.internal.dto.LoginResponseDTO;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.FieldNamingPolicy;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+\n+/**\n+ * The {@link MyQAccountHandler} is responsible for communicating with the MyQ API based on an account.\n+ *\n+ * @author Dan Cunningham - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MyQAccountHandler extends BaseBridgeHandler {\n+    private static final String BASE_URL = \"https://api.myqdevice.com/api\";\n+    private static final Integer RAPID_REFRESH_SECONDS = 5;\n+    private final Logger logger = LoggerFactory.getLogger(MyQAccountHandler.class);\n+    private final Gson gsonUpperCase = new GsonBuilder().setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE)\n+            .create();\n+    private final Gson gsonLowerCase = new GsonBuilder()\n+            .setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES).create();\n+    private @Nullable Future<?> normalPollFuture;\n+    private @Nullable Future<?> rapidPollFuture;\n+    private @Nullable String securityToken;\n+    private @Nullable AccountDTO account;\n+    private Integer normalRefreshSeconds = 60;\n+    private MyQDiscoveryService discoveryService;\n+    private HttpClient httpClient;\n+    private String username = \"\";\n+    private String password = \"\";\n+    private String userAgent = \"\";\n+\n+    public MyQAccountHandler(Bridge bridge, HttpClient httpClient, MyQDiscoveryService discoveryService) {\n+        super(bridge);\n+        this.httpClient = httpClient;\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        MyQConfiguration config = getConfigAs(MyQConfiguration.class);\n+        normalRefreshSeconds = config.refreshInterval;\n+        username = config.username;\n+        password = config.password;\n+        // MyQ can get picky about blocking user agents apparently\n+        userAgent = MyQAccountHandler.randomString(40);\n+        securityToken = null;\n+        updateStatus(ThingStatus.UNKNOWN);\n+        restartPolls(false);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        stopPolls();\n+    }\n+\n+    /**\n+     * Sends an action to the MyQ API\n+     *\n+     * @param serialNumber\n+     * @param action\n+     */\n+    public void sendAction(String serialNumber, String action) {\n+        AccountDTO localAccount = account;\n+        if (localAccount != null) {\n+            try {\n+                HttpResult result = sendRequest(\n+                        String.format(\"%s/v5.1/Accounts/%s/Devices/%s/actions\", BASE_URL, localAccount.account.id,\n+                                serialNumber),\n+                        HttpMethod.PUT, securityToken,\n+                        new StringContentProvider(gsonLowerCase.toJson(new ActionDTO(action))), \"application/json\");\n+                if (HttpStatus.isSuccess(result.responseCode)) {\n+                    restartPolls(true);\n+                } else {\n+                    logger.debug(\"Failed to send action {} : {}\", action, result.content);\n+                }\n+            } catch (InterruptedException e) {\n+            }\n+        }\n+    }\n+\n+    private void stopPolls() {\n+        stopNormalPoll();\n+        stopRapidPoll();\n+    }\n+\n+    private synchronized void stopNormalPoll() {\n+        stopFuture(normalPollFuture);\n+        normalPollFuture = null;\n+    }\n+\n+    private synchronized void stopRapidPoll() {\n+        stopFuture(rapidPollFuture);\n+        rapidPollFuture = null;\n+    }\n+\n+    private void stopFuture(@Nullable Future<?> future) {\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+    }\n+\n+    private synchronized void restartPolls(boolean rapid) {\n+        stopPolls();\n+        if (rapid) {\n+            normalPollFuture = scheduler.scheduleWithFixedDelay(this::normalPoll, 35, normalRefreshSeconds,\n+                    TimeUnit.SECONDS);\n+            rapidPollFuture = scheduler.scheduleWithFixedDelay(this::rapidPoll, 3, RAPID_REFRESH_SECONDS,\n+                    TimeUnit.SECONDS);\n+        } else {\n+            normalPollFuture = scheduler.scheduleWithFixedDelay(this::normalPoll, 0, normalRefreshSeconds,\n+                    TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    private void normalPoll() {\n+        stopRapidPoll();\n+        fetchData();\n+    }\n+\n+    private void rapidPoll() {\n+        fetchData();\n+    }\n+\n+    private synchronized void fetchData() {\n+        try {\n+            if (securityToken == null) {\n+                login();\n+                if (securityToken != null) {\n+                    getAccount();\n+                }\n+            }\n+\n+            if (securityToken != null) {\n+                getDevices();\n+            }\n+        } catch (InterruptedException e) {\n+        }\n+    }\n+\n+    private void login() throws InterruptedException {\n+        HttpResult result = sendRequest(BASE_URL + \"/v5/Login\", HttpMethod.POST, null,\n+                new StringContentProvider(gsonUpperCase.toJson(new LoginRequestDTO(username, password))),\n+                \"application/json\");\n+        if (HttpStatus.isSuccess(result.responseCode)) {\n+            LoginResponseDTO loginResponse = gsonUpperCase.fromJson(result.content, LoginResponseDTO.class);\n+            if (loginResponse != null) {\n+                securityToken = loginResponse.securityToken;\n+                updateStatus(ThingStatus.ONLINE);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Invalid Response Body\");\n+            }\n+        } else {\n+            handleErrorResponse(result);\n+            if (thing.getStatusInfo().getStatusDetail() == ThingStatusDetail.CONFIGURATION_ERROR) {\n+                // bad credentials, stop trying to login\n+                stopPolls();\n+            }\n+        }\n+    }\n+\n+    private void getAccount() throws InterruptedException {\n+        HttpResult result = sendRequest(BASE_URL + \"/v5/My?expand=account\", HttpMethod.GET, securityToken, null, null);\n+        if (HttpStatus.isSuccess(result.responseCode)) {\n+            account = gsonUpperCase.fromJson(result.content, AccountDTO.class);\n+        } else {\n+            handleErrorResponse(result);\n+        }\n+    }\n+\n+    private void getDevices() throws InterruptedException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDA3MjY4Nw=="}, "originalCommit": {"oid": "bddbad680c579f681166de9de5a4aa2f6f76bee9"}, "originalPosition": 224}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzE2MTU3Nw==", "bodyText": "Great!", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r563161577", "createdAt": "2021-01-23T14:53:16Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.myq/src/main/java/org/openhab/binding/myq/internal/handler/MyQAccountHandler.java", "diffHunk": "@@ -0,0 +1,329 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.myq.internal.handler;\n+\n+import static org.openhab.binding.myq.internal.MyQBindingConstants.*;\n+\n+import java.util.Random;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentProvider;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.api.Result;\n+import org.eclipse.jetty.client.util.BufferingResponseListener;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.myq.internal.MyQConfiguration;\n+import org.openhab.binding.myq.internal.MyQDiscoveryService;\n+import org.openhab.binding.myq.internal.dto.AccountDTO;\n+import org.openhab.binding.myq.internal.dto.ActionDTO;\n+import org.openhab.binding.myq.internal.dto.DevicesDTO;\n+import org.openhab.binding.myq.internal.dto.LoginRequestDTO;\n+import org.openhab.binding.myq.internal.dto.LoginResponseDTO;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.FieldNamingPolicy;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+\n+/**\n+ * The {@link MyQAccountHandler} is responsible for communicating with the MyQ API based on an account.\n+ *\n+ * @author Dan Cunningham - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MyQAccountHandler extends BaseBridgeHandler {\n+    private static final String BASE_URL = \"https://api.myqdevice.com/api\";\n+    private static final Integer RAPID_REFRESH_SECONDS = 5;\n+    private final Logger logger = LoggerFactory.getLogger(MyQAccountHandler.class);\n+    private final Gson gsonUpperCase = new GsonBuilder().setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE)\n+            .create();\n+    private final Gson gsonLowerCase = new GsonBuilder()\n+            .setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES).create();\n+    private @Nullable Future<?> normalPollFuture;\n+    private @Nullable Future<?> rapidPollFuture;\n+    private @Nullable String securityToken;\n+    private @Nullable AccountDTO account;\n+    private Integer normalRefreshSeconds = 60;\n+    private MyQDiscoveryService discoveryService;\n+    private HttpClient httpClient;\n+    private String username = \"\";\n+    private String password = \"\";\n+    private String userAgent = \"\";\n+\n+    public MyQAccountHandler(Bridge bridge, HttpClient httpClient, MyQDiscoveryService discoveryService) {\n+        super(bridge);\n+        this.httpClient = httpClient;\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        MyQConfiguration config = getConfigAs(MyQConfiguration.class);\n+        normalRefreshSeconds = config.refreshInterval;\n+        username = config.username;\n+        password = config.password;\n+        // MyQ can get picky about blocking user agents apparently\n+        userAgent = MyQAccountHandler.randomString(40);\n+        securityToken = null;\n+        updateStatus(ThingStatus.UNKNOWN);\n+        restartPolls(false);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        stopPolls();\n+    }\n+\n+    /**\n+     * Sends an action to the MyQ API\n+     *\n+     * @param serialNumber\n+     * @param action\n+     */\n+    public void sendAction(String serialNumber, String action) {\n+        AccountDTO localAccount = account;\n+        if (localAccount != null) {\n+            try {\n+                HttpResult result = sendRequest(\n+                        String.format(\"%s/v5.1/Accounts/%s/Devices/%s/actions\", BASE_URL, localAccount.account.id,\n+                                serialNumber),\n+                        HttpMethod.PUT, securityToken,\n+                        new StringContentProvider(gsonLowerCase.toJson(new ActionDTO(action))), \"application/json\");\n+                if (HttpStatus.isSuccess(result.responseCode)) {\n+                    restartPolls(true);\n+                } else {\n+                    logger.debug(\"Failed to send action {} : {}\", action, result.content);\n+                }\n+            } catch (InterruptedException e) {\n+            }\n+        }\n+    }\n+\n+    private void stopPolls() {\n+        stopNormalPoll();\n+        stopRapidPoll();\n+    }\n+\n+    private synchronized void stopNormalPoll() {\n+        stopFuture(normalPollFuture);\n+        normalPollFuture = null;\n+    }\n+\n+    private synchronized void stopRapidPoll() {\n+        stopFuture(rapidPollFuture);\n+        rapidPollFuture = null;\n+    }\n+\n+    private void stopFuture(@Nullable Future<?> future) {\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+    }\n+\n+    private synchronized void restartPolls(boolean rapid) {\n+        stopPolls();\n+        if (rapid) {\n+            normalPollFuture = scheduler.scheduleWithFixedDelay(this::normalPoll, 35, normalRefreshSeconds,\n+                    TimeUnit.SECONDS);\n+            rapidPollFuture = scheduler.scheduleWithFixedDelay(this::rapidPoll, 3, RAPID_REFRESH_SECONDS,\n+                    TimeUnit.SECONDS);\n+        } else {\n+            normalPollFuture = scheduler.scheduleWithFixedDelay(this::normalPoll, 0, normalRefreshSeconds,\n+                    TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    private void normalPoll() {\n+        stopRapidPoll();\n+        fetchData();\n+    }\n+\n+    private void rapidPoll() {\n+        fetchData();\n+    }\n+\n+    private synchronized void fetchData() {\n+        try {\n+            if (securityToken == null) {\n+                login();\n+                if (securityToken != null) {\n+                    getAccount();\n+                }\n+            }\n+\n+            if (securityToken != null) {\n+                getDevices();\n+            }\n+        } catch (InterruptedException e) {\n+        }\n+    }\n+\n+    private void login() throws InterruptedException {\n+        HttpResult result = sendRequest(BASE_URL + \"/v5/Login\", HttpMethod.POST, null,\n+                new StringContentProvider(gsonUpperCase.toJson(new LoginRequestDTO(username, password))),\n+                \"application/json\");\n+        if (HttpStatus.isSuccess(result.responseCode)) {\n+            LoginResponseDTO loginResponse = gsonUpperCase.fromJson(result.content, LoginResponseDTO.class);\n+            if (loginResponse != null) {\n+                securityToken = loginResponse.securityToken;\n+                updateStatus(ThingStatus.ONLINE);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Invalid Response Body\");\n+            }\n+        } else {\n+            handleErrorResponse(result);\n+            if (thing.getStatusInfo().getStatusDetail() == ThingStatusDetail.CONFIGURATION_ERROR) {\n+                // bad credentials, stop trying to login\n+                stopPolls();\n+            }\n+        }\n+    }\n+\n+    private void getAccount() throws InterruptedException {\n+        HttpResult result = sendRequest(BASE_URL + \"/v5/My?expand=account\", HttpMethod.GET, securityToken, null, null);\n+        if (HttpStatus.isSuccess(result.responseCode)) {\n+            account = gsonUpperCase.fromJson(result.content, AccountDTO.class);\n+        } else {\n+            handleErrorResponse(result);\n+        }\n+    }\n+\n+    private void getDevices() throws InterruptedException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDA3MjY4Nw=="}, "originalCommit": {"oid": "bddbad680c579f681166de9de5a4aa2f6f76bee9"}, "originalPosition": 224}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU0MjcxNjc3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.myq/src/main/java/org/openhab/binding/myq/internal/handler/MyQAccountHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQxMTo1MDo1MFrOIYhKVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQxNjo1NTo1OVrOIYso5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjU4MDA1NA==", "bodyText": "You're using the id as a unique identifier.  However the convention is that the user can give it any name allowed. So it should not be used as identifier. You should check here on the property serialNumber.", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r562580054", "createdAt": "2021-01-22T11:50:50Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.myq/src/main/java/org/openhab/binding/myq/internal/handler/MyQAccountHandler.java", "diffHunk": "@@ -107,6 +109,24 @@ public void dispose() {\n         stopPolls();\n     }\n \n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(MyQDiscoveryService.class);\n+    }\n+\n+    @Override\n+    public void childHandlerInitialized(ThingHandler childHandler, Thing childThing) {\n+        DevicesDTO localDeviceCaches = devicesCache;\n+        if (localDeviceCaches != null) {\n+            DeviceDTO device = localDeviceCaches.items.stream()\n+                    .filter(d -> childHandler.getThing().getUID().getId().equalsIgnoreCase(d.serialNumber)).findFirst()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "552b0f45cf19218af421fcabb93f4d8e4e012e88"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjc2ODEwMg==", "bodyText": "Good catch !", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r562768102", "createdAt": "2021-01-22T16:55:59Z", "author": {"login": "digitaldan"}, "path": "bundles/org.openhab.binding.myq/src/main/java/org/openhab/binding/myq/internal/handler/MyQAccountHandler.java", "diffHunk": "@@ -107,6 +109,24 @@ public void dispose() {\n         stopPolls();\n     }\n \n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(MyQDiscoveryService.class);\n+    }\n+\n+    @Override\n+    public void childHandlerInitialized(ThingHandler childHandler, Thing childThing) {\n+        DevicesDTO localDeviceCaches = devicesCache;\n+        if (localDeviceCaches != null) {\n+            DeviceDTO device = localDeviceCaches.items.stream()\n+                    .filter(d -> childHandler.getThing().getUID().getId().equalsIgnoreCase(d.serialNumber)).findFirst()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjU4MDA1NA=="}, "originalCommit": {"oid": "552b0f45cf19218af421fcabb93f4d8e4e012e88"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU0Mzk3MTExOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.myq/src/main/java/org/openhab/binding/myq/internal/handler/MyQAccountHandler.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQxNzowODo1OVrOIYtJpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yMlQxODowOTowM1rOIYviww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjc3NjQ4NA==", "bodyText": "In general it's not recommend to get the configuration everytime. I would suggest to make a method getSerialNumber() on the handler and also use equalsIgnoreCase. Something like:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        if (thing.getConfiguration().as(MyQDeviceConfiguration.class).serialNumber.toLowerCase()\n          \n          \n            \n                                                .equals(deviceSerial)) {\n          \n          \n            \n                                        if (((MyQDeviceHandler) thing.getHandler()).getSerialNumber().equalsIgnoreCase(deviceSerial)) {", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r562776484", "createdAt": "2021-01-22T17:08:59Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.myq/src/main/java/org/openhab/binding/myq/internal/handler/MyQAccountHandler.java", "diffHunk": "@@ -267,10 +269,11 @@ private void getDevices() throws InterruptedException {\n                 devices.items.forEach(device -> {\n                     ThingTypeUID thingTypeUID = new ThingTypeUID(BINDING_ID, device.deviceFamily);\n                     if (SUPPORTED_DISCOVERY_THING_TYPES_UIDS.contains(thingTypeUID)) {\n-                        String id = device.serialNumber.toLowerCase();\n+                        String deviceSerial = device.serialNumber.toLowerCase();\n                         for (Thing thing : getThing().getThings()) {\n                             // support both upper and lower case serialIds\n-                            if (thing.getUID().getId().toLowerCase().equals(id)) {\n+                            if (thing.getConfiguration().as(MyQDeviceConfiguration.class).serialNumber.toLowerCase()\n+                                    .equals(deviceSerial)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c497131432b338000225deb426ef06c0ee54bd6f"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjc5MzA3MA==", "bodyText": "In general it's not recommend to get the configuration everytime.\n\nYep agreed\n\non the handler and also use equalsIgnoreCase\n\nyeah, i'm not sure what i was thinking there", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r562793070", "createdAt": "2021-01-22T17:36:09Z", "author": {"login": "digitaldan"}, "path": "bundles/org.openhab.binding.myq/src/main/java/org/openhab/binding/myq/internal/handler/MyQAccountHandler.java", "diffHunk": "@@ -267,10 +269,11 @@ private void getDevices() throws InterruptedException {\n                 devices.items.forEach(device -> {\n                     ThingTypeUID thingTypeUID = new ThingTypeUID(BINDING_ID, device.deviceFamily);\n                     if (SUPPORTED_DISCOVERY_THING_TYPES_UIDS.contains(thingTypeUID)) {\n-                        String id = device.serialNumber.toLowerCase();\n+                        String deviceSerial = device.serialNumber.toLowerCase();\n                         for (Thing thing : getThing().getThings()) {\n                             // support both upper and lower case serialIds\n-                            if (thing.getUID().getId().toLowerCase().equals(id)) {\n+                            if (thing.getConfiguration().as(MyQDeviceConfiguration.class).serialNumber.toLowerCase()\n+                                    .equals(deviceSerial)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjc3NjQ4NA=="}, "originalCommit": {"oid": "c497131432b338000225deb426ef06c0ee54bd6f"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjgxNTY4Mw==", "bodyText": "done!", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r562815683", "createdAt": "2021-01-22T18:09:03Z", "author": {"login": "digitaldan"}, "path": "bundles/org.openhab.binding.myq/src/main/java/org/openhab/binding/myq/internal/handler/MyQAccountHandler.java", "diffHunk": "@@ -267,10 +269,11 @@ private void getDevices() throws InterruptedException {\n                 devices.items.forEach(device -> {\n                     ThingTypeUID thingTypeUID = new ThingTypeUID(BINDING_ID, device.deviceFamily);\n                     if (SUPPORTED_DISCOVERY_THING_TYPES_UIDS.contains(thingTypeUID)) {\n-                        String id = device.serialNumber.toLowerCase();\n+                        String deviceSerial = device.serialNumber.toLowerCase();\n                         for (Thing thing : getThing().getThings()) {\n                             // support both upper and lower case serialIds\n-                            if (thing.getUID().getId().toLowerCase().equals(id)) {\n+                            if (thing.getConfiguration().as(MyQDeviceConfiguration.class).serialNumber.toLowerCase()\n+                                    .equals(deviceSerial)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Mjc3NjQ4NA=="}, "originalCommit": {"oid": "c497131432b338000225deb426ef06c0ee54bd6f"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU1MTg0MTAxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.myq/src/main/java/org/openhab/binding/myq/internal/MyQDiscoveryService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNVQxNzo1NzoxNVrOIZzbRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNVQxNzo1NzoxNVrOIZzbRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzkyNzg3OQ==", "bodyText": "Unchecked exceptions don't need to be declared in throws.", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r563927879", "createdAt": "2021-01-25T17:57:15Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.myq/src/main/java/org/openhab/binding/myq/internal/MyQDiscoveryService.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.myq.internal;\n+\n+import static org.openhab.binding.myq.internal.MyQBindingConstants.BINDING_ID;\n+\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.myq.internal.dto.DevicesDTO;\n+import org.openhab.binding.myq.internal.handler.MyQAccountHandler;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+\n+/**\n+ * The {@link MyQDiscoveryService} is responsible for discovering MyQ things\n+ *\n+ * @author Dan Cunningham - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MyQDiscoveryService extends AbstractDiscoveryService implements DiscoveryService, ThingHandlerService {\n+    public MyQDiscoveryService() throws IllegalArgumentException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7c5daf34ac54a1ce6b0e76d699ec27c5abf3ad96"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU1MTg0MjQyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.myq/src/main/java/org/openhab/binding/myq/internal/MyQDiscoveryService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNVQxNzo1NzoyNlrOIZzcFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNVQxNzo1NzoyNlrOIZzcFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzkyODA4Ng==", "bodyText": "Please move fields to the top of the class.", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r563928086", "createdAt": "2021-01-25T17:57:26Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.myq/src/main/java/org/openhab/binding/myq/internal/MyQDiscoveryService.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.myq.internal;\n+\n+import static org.openhab.binding.myq.internal.MyQBindingConstants.BINDING_ID;\n+\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.myq.internal.dto.DevicesDTO;\n+import org.openhab.binding.myq.internal.handler.MyQAccountHandler;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+\n+/**\n+ * The {@link MyQDiscoveryService} is responsible for discovering MyQ things\n+ *\n+ * @author Dan Cunningham - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MyQDiscoveryService extends AbstractDiscoveryService implements DiscoveryService, ThingHandlerService {\n+    public MyQDiscoveryService() throws IllegalArgumentException {\n+        super(SUPPORTED_DISCOVERY_THING_TYPES_UIDS, 1, true);\n+    }\n+\n+    private static final Set<ThingTypeUID> SUPPORTED_DISCOVERY_THING_TYPES_UIDS = Set\n+            .of(MyQBindingConstants.THING_TYPE_GARAGEDOOR, MyQBindingConstants.THING_TYPE_LAMP);\n+\n+    private @Nullable MyQAccountHandler accountHandler;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7c5daf34ac54a1ce6b0e76d699ec27c5abf3ad96"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU1MTg0Nzc1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.myq/src/main/java/org/openhab/binding/myq/internal/MyQDiscoveryService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNVQxNzo1ODoxNFrOIZzfHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNVQxNzo1ODoxNFrOIZzfHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzkyODg2MA==", "bodyText": "There's a predefined constant for the serial number.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                            .withProperty(\"serialNumber\", thingUID.getId())\n          \n          \n            \n                                            .withProperty(Thing.PROPERTY_SERIAL_NUMBER, thingUID.getId())", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r563928860", "createdAt": "2021-01-25T17:58:14Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.myq/src/main/java/org/openhab/binding/myq/internal/MyQDiscoveryService.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.myq.internal;\n+\n+import static org.openhab.binding.myq.internal.MyQBindingConstants.BINDING_ID;\n+\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.myq.internal.dto.DevicesDTO;\n+import org.openhab.binding.myq.internal.handler.MyQAccountHandler;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.config.discovery.DiscoveryService;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+\n+/**\n+ * The {@link MyQDiscoveryService} is responsible for discovering MyQ things\n+ *\n+ * @author Dan Cunningham - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MyQDiscoveryService extends AbstractDiscoveryService implements DiscoveryService, ThingHandlerService {\n+    public MyQDiscoveryService() throws IllegalArgumentException {\n+        super(SUPPORTED_DISCOVERY_THING_TYPES_UIDS, 1, true);\n+    }\n+\n+    private static final Set<ThingTypeUID> SUPPORTED_DISCOVERY_THING_TYPES_UIDS = Set\n+            .of(MyQBindingConstants.THING_TYPE_GARAGEDOOR, MyQBindingConstants.THING_TYPE_LAMP);\n+\n+    private @Nullable MyQAccountHandler accountHandler;\n+\n+    @Override\n+    public Set<ThingTypeUID> getSupportedThingTypes() {\n+        return SUPPORTED_DISCOVERY_THING_TYPES_UIDS;\n+    }\n+\n+    @Override\n+    public void startScan() {\n+        MyQAccountHandler accountHandler = this.accountHandler;\n+        if (accountHandler != null) {\n+            DevicesDTO devices = accountHandler.devicesCache();\n+            if (devices != null) {\n+                devices.items.forEach(device -> {\n+                    ThingTypeUID thingTypeUID = new ThingTypeUID(BINDING_ID, device.deviceFamily);\n+                    if (SUPPORTED_DISCOVERY_THING_TYPES_UIDS.contains(thingTypeUID)) {\n+                        ThingUID thingUID = new ThingUID(thingTypeUID, accountHandler.getThing().getUID(),\n+                                device.serialNumber.toLowerCase());\n+                        DiscoveryResult result = DiscoveryResultBuilder.create(thingUID).withLabel(\"MyQ \" + device.name)\n+                                .withProperty(\"serialNumber\", thingUID.getId())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7c5daf34ac54a1ce6b0e76d699ec27c5abf3ad96"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU1MTg2NzA2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.myq/src/main/java/org/openhab/binding/myq/internal/handler/MyQAccountHandler.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNVQxODowMzoxN1rOIZzraw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0zMFQxODozOTozNVrOIdBDbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzkzMjAxMQ==", "bodyText": "The child handler can be of different type if the user made a mistake in the textual configuration. And syntactical sugar:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (localDeviceCaches != null) {\n          \n          \n            \n                        DeviceDTO device = localDeviceCaches.items.stream()\n          \n          \n            \n                                .filter(d -> ((MyQDeviceHandler) childHandler).getSerialNumber().equalsIgnoreCase(d.serialNumber))\n          \n          \n            \n                                .findFirst().orElse(null);\n          \n          \n            \n                        if (device != null) {\n          \n          \n            \n                            ((MyQDeviceHandler) childHandler).handleDeviceUpdate(device);\n          \n          \n            \n                        }\n          \n          \n            \n                    if (localDeviceCaches != null && childHandler instanceof MyQDeviceHandler) {\n          \n          \n            \n                        MyQDeviceHandler handler = (MyQDeviceHandler) childHandler;\n          \n          \n            \n                        localDeviceCaches.items.stream()\n          \n          \n            \n                                .filter(d -> ((MyQDeviceHandler) childHandler).getSerialNumber().equalsIgnoreCase(d.serialNumber))\n          \n          \n            \n                                .findFirst().ifPresent(handler::handleDeviceUpdate);", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r563932011", "createdAt": "2021-01-25T18:03:17Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.myq/src/main/java/org/openhab/binding/myq/internal/handler/MyQAccountHandler.java", "diffHunk": "@@ -0,0 +1,352 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.myq.internal.handler;\n+\n+import static org.openhab.binding.myq.internal.MyQBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Random;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentProvider;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.api.Result;\n+import org.eclipse.jetty.client.util.BufferingResponseListener;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.myq.internal.MyQDiscoveryService;\n+import org.openhab.binding.myq.internal.config.MyQAccountConfiguration;\n+import org.openhab.binding.myq.internal.dto.AccountDTO;\n+import org.openhab.binding.myq.internal.dto.ActionDTO;\n+import org.openhab.binding.myq.internal.dto.DeviceDTO;\n+import org.openhab.binding.myq.internal.dto.DevicesDTO;\n+import org.openhab.binding.myq.internal.dto.LoginRequestDTO;\n+import org.openhab.binding.myq.internal.dto.LoginResponseDTO;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.FieldNamingPolicy;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+\n+/**\n+ * The {@link MyQAccountHandler} is responsible for communicating with the MyQ API based on an account.\n+ *\n+ * @author Dan Cunningham - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MyQAccountHandler extends BaseBridgeHandler {\n+    private static final String BASE_URL = \"https://api.myqdevice.com/api\";\n+    private static final Integer RAPID_REFRESH_SECONDS = 5;\n+    private final Logger logger = LoggerFactory.getLogger(MyQAccountHandler.class);\n+    private final Gson gsonUpperCase = new GsonBuilder().setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE)\n+            .create();\n+    private final Gson gsonLowerCase = new GsonBuilder()\n+            .setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES).create();\n+    private @Nullable Future<?> normalPollFuture;\n+    private @Nullable Future<?> rapidPollFuture;\n+    private @Nullable String securityToken;\n+    private @Nullable AccountDTO account;\n+    private @Nullable DevicesDTO devicesCache;\n+    private Integer normalRefreshSeconds = 60;\n+    private HttpClient httpClient;\n+    private String username = \"\";\n+    private String password = \"\";\n+    private String userAgent = \"\";\n+\n+    public MyQAccountHandler(Bridge bridge, HttpClient httpClient) {\n+        super(bridge);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        MyQAccountConfiguration config = getConfigAs(MyQAccountConfiguration.class);\n+        normalRefreshSeconds = config.refreshInterval;\n+        username = config.username;\n+        password = config.password;\n+        // MyQ can get picky about blocking user agents apparently\n+        userAgent = MyQAccountHandler.randomString(40);\n+        securityToken = null;\n+        updateStatus(ThingStatus.UNKNOWN);\n+        restartPolls(false);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        stopPolls();\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(MyQDiscoveryService.class);\n+    }\n+\n+    @Override\n+    public void childHandlerInitialized(ThingHandler childHandler, Thing childThing) {\n+        DevicesDTO localDeviceCaches = devicesCache;\n+        if (localDeviceCaches != null) {\n+            DeviceDTO device = localDeviceCaches.items.stream()\n+                    .filter(d -> ((MyQDeviceHandler) childHandler).getSerialNumber().equalsIgnoreCase(d.serialNumber))\n+                    .findFirst().orElse(null);\n+            if (device != null) {\n+                ((MyQDeviceHandler) childHandler).handleDeviceUpdate(device);\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7c5daf34ac54a1ce6b0e76d699ec27c5abf3ad96"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDM3NzkwMw==", "bodyText": "Did you see the syntactical sugar in my suggestion?", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r564377903", "createdAt": "2021-01-26T09:47:04Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.myq/src/main/java/org/openhab/binding/myq/internal/handler/MyQAccountHandler.java", "diffHunk": "@@ -0,0 +1,352 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.myq.internal.handler;\n+\n+import static org.openhab.binding.myq.internal.MyQBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Random;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentProvider;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.api.Result;\n+import org.eclipse.jetty.client.util.BufferingResponseListener;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.myq.internal.MyQDiscoveryService;\n+import org.openhab.binding.myq.internal.config.MyQAccountConfiguration;\n+import org.openhab.binding.myq.internal.dto.AccountDTO;\n+import org.openhab.binding.myq.internal.dto.ActionDTO;\n+import org.openhab.binding.myq.internal.dto.DeviceDTO;\n+import org.openhab.binding.myq.internal.dto.DevicesDTO;\n+import org.openhab.binding.myq.internal.dto.LoginRequestDTO;\n+import org.openhab.binding.myq.internal.dto.LoginResponseDTO;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.FieldNamingPolicy;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+\n+/**\n+ * The {@link MyQAccountHandler} is responsible for communicating with the MyQ API based on an account.\n+ *\n+ * @author Dan Cunningham - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MyQAccountHandler extends BaseBridgeHandler {\n+    private static final String BASE_URL = \"https://api.myqdevice.com/api\";\n+    private static final Integer RAPID_REFRESH_SECONDS = 5;\n+    private final Logger logger = LoggerFactory.getLogger(MyQAccountHandler.class);\n+    private final Gson gsonUpperCase = new GsonBuilder().setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE)\n+            .create();\n+    private final Gson gsonLowerCase = new GsonBuilder()\n+            .setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES).create();\n+    private @Nullable Future<?> normalPollFuture;\n+    private @Nullable Future<?> rapidPollFuture;\n+    private @Nullable String securityToken;\n+    private @Nullable AccountDTO account;\n+    private @Nullable DevicesDTO devicesCache;\n+    private Integer normalRefreshSeconds = 60;\n+    private HttpClient httpClient;\n+    private String username = \"\";\n+    private String password = \"\";\n+    private String userAgent = \"\";\n+\n+    public MyQAccountHandler(Bridge bridge, HttpClient httpClient) {\n+        super(bridge);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        MyQAccountConfiguration config = getConfigAs(MyQAccountConfiguration.class);\n+        normalRefreshSeconds = config.refreshInterval;\n+        username = config.username;\n+        password = config.password;\n+        // MyQ can get picky about blocking user agents apparently\n+        userAgent = MyQAccountHandler.randomString(40);\n+        securityToken = null;\n+        updateStatus(ThingStatus.UNKNOWN);\n+        restartPolls(false);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        stopPolls();\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(MyQDiscoveryService.class);\n+    }\n+\n+    @Override\n+    public void childHandlerInitialized(ThingHandler childHandler, Thing childThing) {\n+        DevicesDTO localDeviceCaches = devicesCache;\n+        if (localDeviceCaches != null) {\n+            DeviceDTO device = localDeviceCaches.items.stream()\n+                    .filter(d -> ((MyQDeviceHandler) childHandler).getSerialNumber().equalsIgnoreCase(d.serialNumber))\n+                    .findFirst().orElse(null);\n+            if (device != null) {\n+                ((MyQDeviceHandler) childHandler).handleDeviceUpdate(device);\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzkzMjAxMQ=="}, "originalCommit": {"oid": "7c5daf34ac54a1ce6b0e76d699ec27c5abf3ad96"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzI5Njg3Ng==", "bodyText": "I did not, thanks for the hint", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r567296876", "createdAt": "2021-01-30T18:39:35Z", "author": {"login": "digitaldan"}, "path": "bundles/org.openhab.binding.myq/src/main/java/org/openhab/binding/myq/internal/handler/MyQAccountHandler.java", "diffHunk": "@@ -0,0 +1,352 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.myq.internal.handler;\n+\n+import static org.openhab.binding.myq.internal.MyQBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Random;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentProvider;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.api.Result;\n+import org.eclipse.jetty.client.util.BufferingResponseListener;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.myq.internal.MyQDiscoveryService;\n+import org.openhab.binding.myq.internal.config.MyQAccountConfiguration;\n+import org.openhab.binding.myq.internal.dto.AccountDTO;\n+import org.openhab.binding.myq.internal.dto.ActionDTO;\n+import org.openhab.binding.myq.internal.dto.DeviceDTO;\n+import org.openhab.binding.myq.internal.dto.DevicesDTO;\n+import org.openhab.binding.myq.internal.dto.LoginRequestDTO;\n+import org.openhab.binding.myq.internal.dto.LoginResponseDTO;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.FieldNamingPolicy;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+\n+/**\n+ * The {@link MyQAccountHandler} is responsible for communicating with the MyQ API based on an account.\n+ *\n+ * @author Dan Cunningham - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MyQAccountHandler extends BaseBridgeHandler {\n+    private static final String BASE_URL = \"https://api.myqdevice.com/api\";\n+    private static final Integer RAPID_REFRESH_SECONDS = 5;\n+    private final Logger logger = LoggerFactory.getLogger(MyQAccountHandler.class);\n+    private final Gson gsonUpperCase = new GsonBuilder().setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE)\n+            .create();\n+    private final Gson gsonLowerCase = new GsonBuilder()\n+            .setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES).create();\n+    private @Nullable Future<?> normalPollFuture;\n+    private @Nullable Future<?> rapidPollFuture;\n+    private @Nullable String securityToken;\n+    private @Nullable AccountDTO account;\n+    private @Nullable DevicesDTO devicesCache;\n+    private Integer normalRefreshSeconds = 60;\n+    private HttpClient httpClient;\n+    private String username = \"\";\n+    private String password = \"\";\n+    private String userAgent = \"\";\n+\n+    public MyQAccountHandler(Bridge bridge, HttpClient httpClient) {\n+        super(bridge);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        MyQAccountConfiguration config = getConfigAs(MyQAccountConfiguration.class);\n+        normalRefreshSeconds = config.refreshInterval;\n+        username = config.username;\n+        password = config.password;\n+        // MyQ can get picky about blocking user agents apparently\n+        userAgent = MyQAccountHandler.randomString(40);\n+        securityToken = null;\n+        updateStatus(ThingStatus.UNKNOWN);\n+        restartPolls(false);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        stopPolls();\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(MyQDiscoveryService.class);\n+    }\n+\n+    @Override\n+    public void childHandlerInitialized(ThingHandler childHandler, Thing childThing) {\n+        DevicesDTO localDeviceCaches = devicesCache;\n+        if (localDeviceCaches != null) {\n+            DeviceDTO device = localDeviceCaches.items.stream()\n+                    .filter(d -> ((MyQDeviceHandler) childHandler).getSerialNumber().equalsIgnoreCase(d.serialNumber))\n+                    .findFirst().orElse(null);\n+            if (device != null) {\n+                ((MyQDeviceHandler) childHandler).handleDeviceUpdate(device);\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzkzMjAxMQ=="}, "originalCommit": {"oid": "7c5daf34ac54a1ce6b0e76d699ec27c5abf3ad96"}, "originalPosition": 126}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU1MTg3NzU3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.myq/src/main/java/org/openhab/binding/myq/internal/handler/MyQAccountHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNVQxODowNjowM1rOIZzx2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0yNVQyMDoxMzo0NVrOIZ4qAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzkzMzY1Nw==", "bodyText": "This seems the same code as in line 126. Can you make it re-useable?", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r563933657", "createdAt": "2021-01-25T18:06:03Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.myq/src/main/java/org/openhab/binding/myq/internal/handler/MyQAccountHandler.java", "diffHunk": "@@ -0,0 +1,352 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.myq.internal.handler;\n+\n+import static org.openhab.binding.myq.internal.MyQBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Random;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentProvider;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.api.Result;\n+import org.eclipse.jetty.client.util.BufferingResponseListener;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.myq.internal.MyQDiscoveryService;\n+import org.openhab.binding.myq.internal.config.MyQAccountConfiguration;\n+import org.openhab.binding.myq.internal.dto.AccountDTO;\n+import org.openhab.binding.myq.internal.dto.ActionDTO;\n+import org.openhab.binding.myq.internal.dto.DeviceDTO;\n+import org.openhab.binding.myq.internal.dto.DevicesDTO;\n+import org.openhab.binding.myq.internal.dto.LoginRequestDTO;\n+import org.openhab.binding.myq.internal.dto.LoginResponseDTO;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.FieldNamingPolicy;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+\n+/**\n+ * The {@link MyQAccountHandler} is responsible for communicating with the MyQ API based on an account.\n+ *\n+ * @author Dan Cunningham - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MyQAccountHandler extends BaseBridgeHandler {\n+    private static final String BASE_URL = \"https://api.myqdevice.com/api\";\n+    private static final Integer RAPID_REFRESH_SECONDS = 5;\n+    private final Logger logger = LoggerFactory.getLogger(MyQAccountHandler.class);\n+    private final Gson gsonUpperCase = new GsonBuilder().setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE)\n+            .create();\n+    private final Gson gsonLowerCase = new GsonBuilder()\n+            .setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES).create();\n+    private @Nullable Future<?> normalPollFuture;\n+    private @Nullable Future<?> rapidPollFuture;\n+    private @Nullable String securityToken;\n+    private @Nullable AccountDTO account;\n+    private @Nullable DevicesDTO devicesCache;\n+    private Integer normalRefreshSeconds = 60;\n+    private HttpClient httpClient;\n+    private String username = \"\";\n+    private String password = \"\";\n+    private String userAgent = \"\";\n+\n+    public MyQAccountHandler(Bridge bridge, HttpClient httpClient) {\n+        super(bridge);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        MyQAccountConfiguration config = getConfigAs(MyQAccountConfiguration.class);\n+        normalRefreshSeconds = config.refreshInterval;\n+        username = config.username;\n+        password = config.password;\n+        // MyQ can get picky about blocking user agents apparently\n+        userAgent = MyQAccountHandler.randomString(40);\n+        securityToken = null;\n+        updateStatus(ThingStatus.UNKNOWN);\n+        restartPolls(false);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        stopPolls();\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(MyQDiscoveryService.class);\n+    }\n+\n+    @Override\n+    public void childHandlerInitialized(ThingHandler childHandler, Thing childThing) {\n+        DevicesDTO localDeviceCaches = devicesCache;\n+        if (localDeviceCaches != null) {\n+            DeviceDTO device = localDeviceCaches.items.stream()\n+                    .filter(d -> ((MyQDeviceHandler) childHandler).getSerialNumber().equalsIgnoreCase(d.serialNumber))\n+                    .findFirst().orElse(null);\n+            if (device != null) {\n+                ((MyQDeviceHandler) childHandler).handleDeviceUpdate(device);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Sends an action to the MyQ API\n+     *\n+     * @param serialNumber\n+     * @param action\n+     */\n+    public void sendAction(String serialNumber, String action) {\n+        AccountDTO localAccount = account;\n+        if (localAccount != null) {\n+            try {\n+                HttpResult result = sendRequest(\n+                        String.format(\"%s/v5.1/Accounts/%s/Devices/%s/actions\", BASE_URL, localAccount.account.id,\n+                                serialNumber),\n+                        HttpMethod.PUT, securityToken,\n+                        new StringContentProvider(gsonLowerCase.toJson(new ActionDTO(action))), \"application/json\");\n+                if (HttpStatus.isSuccess(result.responseCode)) {\n+                    restartPolls(true);\n+                } else {\n+                    logger.debug(\"Failed to send action {} : {}\", action, result.content);\n+                }\n+            } catch (InterruptedException e) {\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Last known state of MyQ Devices\n+     *\n+     * @return cached MyQ devices\n+     */\n+    public @Nullable DevicesDTO devicesCache() {\n+        return devicesCache;\n+    }\n+\n+    private void stopPolls() {\n+        stopNormalPoll();\n+        stopRapidPoll();\n+    }\n+\n+    private synchronized void stopNormalPoll() {\n+        stopFuture(normalPollFuture);\n+        normalPollFuture = null;\n+    }\n+\n+    private synchronized void stopRapidPoll() {\n+        stopFuture(rapidPollFuture);\n+        rapidPollFuture = null;\n+    }\n+\n+    private void stopFuture(@Nullable Future<?> future) {\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+    }\n+\n+    private synchronized void restartPolls(boolean rapid) {\n+        stopPolls();\n+        if (rapid) {\n+            normalPollFuture = scheduler.scheduleWithFixedDelay(this::normalPoll, 35, normalRefreshSeconds,\n+                    TimeUnit.SECONDS);\n+            rapidPollFuture = scheduler.scheduleWithFixedDelay(this::rapidPoll, 3, RAPID_REFRESH_SECONDS,\n+                    TimeUnit.SECONDS);\n+        } else {\n+            normalPollFuture = scheduler.scheduleWithFixedDelay(this::normalPoll, 0, normalRefreshSeconds,\n+                    TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    private void normalPoll() {\n+        stopRapidPoll();\n+        fetchData();\n+    }\n+\n+    private void rapidPoll() {\n+        fetchData();\n+    }\n+\n+    private synchronized void fetchData() {\n+        try {\n+            if (securityToken == null) {\n+                login();\n+                if (securityToken != null) {\n+                    getAccount();\n+                }\n+            }\n+\n+            if (securityToken != null) {\n+                getDevices();\n+            }\n+        } catch (InterruptedException e) {\n+        }\n+    }\n+\n+    private void login() throws InterruptedException {\n+        HttpResult result = sendRequest(BASE_URL + \"/v5/Login\", HttpMethod.POST, null,\n+                new StringContentProvider(gsonUpperCase.toJson(new LoginRequestDTO(username, password))),\n+                \"application/json\");\n+        if (HttpStatus.isSuccess(result.responseCode)) {\n+            LoginResponseDTO loginResponse = gsonUpperCase.fromJson(result.content, LoginResponseDTO.class);\n+            if (loginResponse != null) {\n+                securityToken = loginResponse.securityToken;\n+                updateStatus(ThingStatus.ONLINE);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Invalid Response Body\");\n+            }\n+        } else {\n+            handleErrorResponse(result);\n+            if (thing.getStatusInfo().getStatusDetail() == ThingStatusDetail.CONFIGURATION_ERROR) {\n+                // bad credentials, stop trying to login\n+                stopPolls();\n+            }\n+        }\n+    }\n+\n+    private void getAccount() throws InterruptedException {\n+        HttpResult result = sendRequest(BASE_URL + \"/v5/My?expand=account\", HttpMethod.GET, securityToken, null, null);\n+        if (HttpStatus.isSuccess(result.responseCode)) {\n+            account = gsonUpperCase.fromJson(result.content, AccountDTO.class);\n+        } else {\n+            handleErrorResponse(result);\n+        }\n+    }\n+\n+    private void getDevices() throws InterruptedException {\n+        AccountDTO localAccount = account;\n+        if (localAccount == null) {\n+            return;\n+        }\n+        HttpResult result = sendRequest(String.format(\"%s/v5.1/Accounts/%s/Devices\", BASE_URL, localAccount.account.id),\n+                HttpMethod.GET, securityToken, null, null);\n+        if (HttpStatus.isSuccess(result.responseCode)) {\n+            if (getThing().getStatus() != ThingStatus.ONLINE) {\n+                updateStatus(ThingStatus.ONLINE);\n+            }\n+            DevicesDTO devices = gsonLowerCase.fromJson(result.content, DevicesDTO.class);\n+            if (devices != null) {\n+                devicesCache = devices;\n+                devices.items.forEach(device -> {\n+                    ThingTypeUID thingTypeUID = new ThingTypeUID(BINDING_ID, device.deviceFamily);\n+                    if (SUPPORTED_DISCOVERY_THING_TYPES_UIDS.contains(thingTypeUID)) {\n+                        for (Thing thing : getThing().getThings()) {\n+                            ThingHandler handler = thing.getHandler();\n+                            if (handler != null && ((MyQDeviceHandler) handler).getSerialNumber()\n+                                    .equalsIgnoreCase(device.serialNumber)) {\n+                                ((MyQDeviceHandler) handler).handleDeviceUpdate(device);\n+                            }\n+                        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7c5daf34ac54a1ce6b0e76d699ec27c5abf3ad96"}, "originalPosition": 276}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NDAxMzU2OA==", "bodyText": "it looks similar, but different enough that i prefer to keep it the way it is", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r564013568", "createdAt": "2021-01-25T20:13:45Z", "author": {"login": "digitaldan"}, "path": "bundles/org.openhab.binding.myq/src/main/java/org/openhab/binding/myq/internal/handler/MyQAccountHandler.java", "diffHunk": "@@ -0,0 +1,352 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.myq.internal.handler;\n+\n+import static org.openhab.binding.myq.internal.MyQBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Random;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentProvider;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.api.Result;\n+import org.eclipse.jetty.client.util.BufferingResponseListener;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.myq.internal.MyQDiscoveryService;\n+import org.openhab.binding.myq.internal.config.MyQAccountConfiguration;\n+import org.openhab.binding.myq.internal.dto.AccountDTO;\n+import org.openhab.binding.myq.internal.dto.ActionDTO;\n+import org.openhab.binding.myq.internal.dto.DeviceDTO;\n+import org.openhab.binding.myq.internal.dto.DevicesDTO;\n+import org.openhab.binding.myq.internal.dto.LoginRequestDTO;\n+import org.openhab.binding.myq.internal.dto.LoginResponseDTO;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.FieldNamingPolicy;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+\n+/**\n+ * The {@link MyQAccountHandler} is responsible for communicating with the MyQ API based on an account.\n+ *\n+ * @author Dan Cunningham - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MyQAccountHandler extends BaseBridgeHandler {\n+    private static final String BASE_URL = \"https://api.myqdevice.com/api\";\n+    private static final Integer RAPID_REFRESH_SECONDS = 5;\n+    private final Logger logger = LoggerFactory.getLogger(MyQAccountHandler.class);\n+    private final Gson gsonUpperCase = new GsonBuilder().setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE)\n+            .create();\n+    private final Gson gsonLowerCase = new GsonBuilder()\n+            .setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES).create();\n+    private @Nullable Future<?> normalPollFuture;\n+    private @Nullable Future<?> rapidPollFuture;\n+    private @Nullable String securityToken;\n+    private @Nullable AccountDTO account;\n+    private @Nullable DevicesDTO devicesCache;\n+    private Integer normalRefreshSeconds = 60;\n+    private HttpClient httpClient;\n+    private String username = \"\";\n+    private String password = \"\";\n+    private String userAgent = \"\";\n+\n+    public MyQAccountHandler(Bridge bridge, HttpClient httpClient) {\n+        super(bridge);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        MyQAccountConfiguration config = getConfigAs(MyQAccountConfiguration.class);\n+        normalRefreshSeconds = config.refreshInterval;\n+        username = config.username;\n+        password = config.password;\n+        // MyQ can get picky about blocking user agents apparently\n+        userAgent = MyQAccountHandler.randomString(40);\n+        securityToken = null;\n+        updateStatus(ThingStatus.UNKNOWN);\n+        restartPolls(false);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        stopPolls();\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(MyQDiscoveryService.class);\n+    }\n+\n+    @Override\n+    public void childHandlerInitialized(ThingHandler childHandler, Thing childThing) {\n+        DevicesDTO localDeviceCaches = devicesCache;\n+        if (localDeviceCaches != null) {\n+            DeviceDTO device = localDeviceCaches.items.stream()\n+                    .filter(d -> ((MyQDeviceHandler) childHandler).getSerialNumber().equalsIgnoreCase(d.serialNumber))\n+                    .findFirst().orElse(null);\n+            if (device != null) {\n+                ((MyQDeviceHandler) childHandler).handleDeviceUpdate(device);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Sends an action to the MyQ API\n+     *\n+     * @param serialNumber\n+     * @param action\n+     */\n+    public void sendAction(String serialNumber, String action) {\n+        AccountDTO localAccount = account;\n+        if (localAccount != null) {\n+            try {\n+                HttpResult result = sendRequest(\n+                        String.format(\"%s/v5.1/Accounts/%s/Devices/%s/actions\", BASE_URL, localAccount.account.id,\n+                                serialNumber),\n+                        HttpMethod.PUT, securityToken,\n+                        new StringContentProvider(gsonLowerCase.toJson(new ActionDTO(action))), \"application/json\");\n+                if (HttpStatus.isSuccess(result.responseCode)) {\n+                    restartPolls(true);\n+                } else {\n+                    logger.debug(\"Failed to send action {} : {}\", action, result.content);\n+                }\n+            } catch (InterruptedException e) {\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Last known state of MyQ Devices\n+     *\n+     * @return cached MyQ devices\n+     */\n+    public @Nullable DevicesDTO devicesCache() {\n+        return devicesCache;\n+    }\n+\n+    private void stopPolls() {\n+        stopNormalPoll();\n+        stopRapidPoll();\n+    }\n+\n+    private synchronized void stopNormalPoll() {\n+        stopFuture(normalPollFuture);\n+        normalPollFuture = null;\n+    }\n+\n+    private synchronized void stopRapidPoll() {\n+        stopFuture(rapidPollFuture);\n+        rapidPollFuture = null;\n+    }\n+\n+    private void stopFuture(@Nullable Future<?> future) {\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+    }\n+\n+    private synchronized void restartPolls(boolean rapid) {\n+        stopPolls();\n+        if (rapid) {\n+            normalPollFuture = scheduler.scheduleWithFixedDelay(this::normalPoll, 35, normalRefreshSeconds,\n+                    TimeUnit.SECONDS);\n+            rapidPollFuture = scheduler.scheduleWithFixedDelay(this::rapidPoll, 3, RAPID_REFRESH_SECONDS,\n+                    TimeUnit.SECONDS);\n+        } else {\n+            normalPollFuture = scheduler.scheduleWithFixedDelay(this::normalPoll, 0, normalRefreshSeconds,\n+                    TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    private void normalPoll() {\n+        stopRapidPoll();\n+        fetchData();\n+    }\n+\n+    private void rapidPoll() {\n+        fetchData();\n+    }\n+\n+    private synchronized void fetchData() {\n+        try {\n+            if (securityToken == null) {\n+                login();\n+                if (securityToken != null) {\n+                    getAccount();\n+                }\n+            }\n+\n+            if (securityToken != null) {\n+                getDevices();\n+            }\n+        } catch (InterruptedException e) {\n+        }\n+    }\n+\n+    private void login() throws InterruptedException {\n+        HttpResult result = sendRequest(BASE_URL + \"/v5/Login\", HttpMethod.POST, null,\n+                new StringContentProvider(gsonUpperCase.toJson(new LoginRequestDTO(username, password))),\n+                \"application/json\");\n+        if (HttpStatus.isSuccess(result.responseCode)) {\n+            LoginResponseDTO loginResponse = gsonUpperCase.fromJson(result.content, LoginResponseDTO.class);\n+            if (loginResponse != null) {\n+                securityToken = loginResponse.securityToken;\n+                updateStatus(ThingStatus.ONLINE);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Invalid Response Body\");\n+            }\n+        } else {\n+            handleErrorResponse(result);\n+            if (thing.getStatusInfo().getStatusDetail() == ThingStatusDetail.CONFIGURATION_ERROR) {\n+                // bad credentials, stop trying to login\n+                stopPolls();\n+            }\n+        }\n+    }\n+\n+    private void getAccount() throws InterruptedException {\n+        HttpResult result = sendRequest(BASE_URL + \"/v5/My?expand=account\", HttpMethod.GET, securityToken, null, null);\n+        if (HttpStatus.isSuccess(result.responseCode)) {\n+            account = gsonUpperCase.fromJson(result.content, AccountDTO.class);\n+        } else {\n+            handleErrorResponse(result);\n+        }\n+    }\n+\n+    private void getDevices() throws InterruptedException {\n+        AccountDTO localAccount = account;\n+        if (localAccount == null) {\n+            return;\n+        }\n+        HttpResult result = sendRequest(String.format(\"%s/v5.1/Accounts/%s/Devices\", BASE_URL, localAccount.account.id),\n+                HttpMethod.GET, securityToken, null, null);\n+        if (HttpStatus.isSuccess(result.responseCode)) {\n+            if (getThing().getStatus() != ThingStatus.ONLINE) {\n+                updateStatus(ThingStatus.ONLINE);\n+            }\n+            DevicesDTO devices = gsonLowerCase.fromJson(result.content, DevicesDTO.class);\n+            if (devices != null) {\n+                devicesCache = devices;\n+                devices.items.forEach(device -> {\n+                    ThingTypeUID thingTypeUID = new ThingTypeUID(BINDING_ID, device.deviceFamily);\n+                    if (SUPPORTED_DISCOVERY_THING_TYPES_UIDS.contains(thingTypeUID)) {\n+                        for (Thing thing : getThing().getThings()) {\n+                            ThingHandler handler = thing.getHandler();\n+                            if (handler != null && ((MyQDeviceHandler) handler).getSerialNumber()\n+                                    .equalsIgnoreCase(device.serialNumber)) {\n+                                ((MyQDeviceHandler) handler).handleDeviceUpdate(device);\n+                            }\n+                        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MzkzMzY1Nw=="}, "originalCommit": {"oid": "7c5daf34ac54a1ce6b0e76d699ec27c5abf3ad96"}, "originalPosition": 276}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU5MTY4NjcwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.myq/src/main/java/org/openhab/binding/myq/internal/handler/MyQAccountHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNFQwNzowMToyM1rOIflTZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNFQwNzowMToyM1rOIflTZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTk4Nzk0Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    StringBuffer sb = new StringBuffer(length);\n          \n          \n            \n                    StringBuilder sb = new StringBuilder(length);", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r569987943", "createdAt": "2021-02-04T07:01:23Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.myq/src/main/java/org/openhab/binding/myq/internal/handler/MyQAccountHandler.java", "diffHunk": "@@ -0,0 +1,349 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.myq.internal.handler;\n+\n+import static org.openhab.binding.myq.internal.MyQBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Random;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentProvider;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.api.Result;\n+import org.eclipse.jetty.client.util.BufferingResponseListener;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.myq.internal.MyQDiscoveryService;\n+import org.openhab.binding.myq.internal.config.MyQAccountConfiguration;\n+import org.openhab.binding.myq.internal.dto.AccountDTO;\n+import org.openhab.binding.myq.internal.dto.ActionDTO;\n+import org.openhab.binding.myq.internal.dto.DevicesDTO;\n+import org.openhab.binding.myq.internal.dto.LoginRequestDTO;\n+import org.openhab.binding.myq.internal.dto.LoginResponseDTO;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.FieldNamingPolicy;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+\n+/**\n+ * The {@link MyQAccountHandler} is responsible for communicating with the MyQ API based on an account.\n+ *\n+ * @author Dan Cunningham - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MyQAccountHandler extends BaseBridgeHandler {\n+    private static final String BASE_URL = \"https://api.myqdevice.com/api\";\n+    private static final Integer RAPID_REFRESH_SECONDS = 5;\n+    private final Logger logger = LoggerFactory.getLogger(MyQAccountHandler.class);\n+    private final Gson gsonUpperCase = new GsonBuilder().setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE)\n+            .create();\n+    private final Gson gsonLowerCase = new GsonBuilder()\n+            .setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES).create();\n+    private @Nullable Future<?> normalPollFuture;\n+    private @Nullable Future<?> rapidPollFuture;\n+    private @Nullable String securityToken;\n+    private @Nullable AccountDTO account;\n+    private @Nullable DevicesDTO devicesCache;\n+    private Integer normalRefreshSeconds = 60;\n+    private HttpClient httpClient;\n+    private String username = \"\";\n+    private String password = \"\";\n+    private String userAgent = \"\";\n+\n+    public MyQAccountHandler(Bridge bridge, HttpClient httpClient) {\n+        super(bridge);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        MyQAccountConfiguration config = getConfigAs(MyQAccountConfiguration.class);\n+        normalRefreshSeconds = config.refreshInterval;\n+        username = config.username;\n+        password = config.password;\n+        // MyQ can get picky about blocking user agents apparently\n+        userAgent = MyQAccountHandler.randomString(40);\n+        securityToken = null;\n+        updateStatus(ThingStatus.UNKNOWN);\n+        restartPolls(false);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        stopPolls();\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(MyQDiscoveryService.class);\n+    }\n+\n+    @Override\n+    public void childHandlerInitialized(ThingHandler childHandler, Thing childThing) {\n+        DevicesDTO localDeviceCaches = devicesCache;\n+        if (localDeviceCaches != null && childHandler instanceof MyQDeviceHandler) {\n+            MyQDeviceHandler handler = (MyQDeviceHandler) childHandler;\n+            localDeviceCaches.items.stream()\n+                    .filter(d -> ((MyQDeviceHandler) childHandler).getSerialNumber().equalsIgnoreCase(d.serialNumber))\n+                    .findFirst().ifPresent(handler::handleDeviceUpdate);\n+        }\n+    }\n+\n+    /**\n+     * Sends an action to the MyQ API\n+     *\n+     * @param serialNumber\n+     * @param action\n+     */\n+    public void sendAction(String serialNumber, String action) {\n+        AccountDTO localAccount = account;\n+        if (localAccount != null) {\n+            try {\n+                HttpResult result = sendRequest(\n+                        String.format(\"%s/v5.1/Accounts/%s/Devices/%s/actions\", BASE_URL, localAccount.account.id,\n+                                serialNumber),\n+                        HttpMethod.PUT, securityToken,\n+                        new StringContentProvider(gsonLowerCase.toJson(new ActionDTO(action))), \"application/json\");\n+                if (HttpStatus.isSuccess(result.responseCode)) {\n+                    restartPolls(true);\n+                } else {\n+                    logger.debug(\"Failed to send action {} : {}\", action, result.content);\n+                }\n+            } catch (InterruptedException e) {\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Last known state of MyQ Devices\n+     *\n+     * @return cached MyQ devices\n+     */\n+    public @Nullable DevicesDTO devicesCache() {\n+        return devicesCache;\n+    }\n+\n+    private void stopPolls() {\n+        stopNormalPoll();\n+        stopRapidPoll();\n+    }\n+\n+    private synchronized void stopNormalPoll() {\n+        stopFuture(normalPollFuture);\n+        normalPollFuture = null;\n+    }\n+\n+    private synchronized void stopRapidPoll() {\n+        stopFuture(rapidPollFuture);\n+        rapidPollFuture = null;\n+    }\n+\n+    private void stopFuture(@Nullable Future<?> future) {\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+    }\n+\n+    private synchronized void restartPolls(boolean rapid) {\n+        stopPolls();\n+        if (rapid) {\n+            normalPollFuture = scheduler.scheduleWithFixedDelay(this::normalPoll, 35, normalRefreshSeconds,\n+                    TimeUnit.SECONDS);\n+            rapidPollFuture = scheduler.scheduleWithFixedDelay(this::rapidPoll, 3, RAPID_REFRESH_SECONDS,\n+                    TimeUnit.SECONDS);\n+        } else {\n+            normalPollFuture = scheduler.scheduleWithFixedDelay(this::normalPoll, 0, normalRefreshSeconds,\n+                    TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    private void normalPoll() {\n+        stopRapidPoll();\n+        fetchData();\n+    }\n+\n+    private void rapidPoll() {\n+        fetchData();\n+    }\n+\n+    private synchronized void fetchData() {\n+        try {\n+            if (securityToken == null) {\n+                login();\n+                if (securityToken != null) {\n+                    getAccount();\n+                }\n+            }\n+\n+            if (securityToken != null) {\n+                getDevices();\n+            }\n+        } catch (InterruptedException e) {\n+        }\n+    }\n+\n+    private void login() throws InterruptedException {\n+        HttpResult result = sendRequest(BASE_URL + \"/v5/Login\", HttpMethod.POST, null,\n+                new StringContentProvider(gsonUpperCase.toJson(new LoginRequestDTO(username, password))),\n+                \"application/json\");\n+        if (HttpStatus.isSuccess(result.responseCode)) {\n+            LoginResponseDTO loginResponse = gsonUpperCase.fromJson(result.content, LoginResponseDTO.class);\n+            if (loginResponse != null) {\n+                securityToken = loginResponse.securityToken;\n+                updateStatus(ThingStatus.ONLINE);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Invalid Response Body\");\n+            }\n+        } else {\n+            handleErrorResponse(result);\n+            if (thing.getStatusInfo().getStatusDetail() == ThingStatusDetail.CONFIGURATION_ERROR) {\n+                // bad credentials, stop trying to login\n+                stopPolls();\n+            }\n+        }\n+    }\n+\n+    private void getAccount() throws InterruptedException {\n+        HttpResult result = sendRequest(BASE_URL + \"/v5/My?expand=account\", HttpMethod.GET, securityToken, null, null);\n+        if (HttpStatus.isSuccess(result.responseCode)) {\n+            account = gsonUpperCase.fromJson(result.content, AccountDTO.class);\n+        } else {\n+            handleErrorResponse(result);\n+        }\n+    }\n+\n+    private void getDevices() throws InterruptedException {\n+        AccountDTO localAccount = account;\n+        if (localAccount == null) {\n+            return;\n+        }\n+        HttpResult result = sendRequest(String.format(\"%s/v5.1/Accounts/%s/Devices\", BASE_URL, localAccount.account.id),\n+                HttpMethod.GET, securityToken, null, null);\n+        if (HttpStatus.isSuccess(result.responseCode)) {\n+            if (getThing().getStatus() != ThingStatus.ONLINE) {\n+                updateStatus(ThingStatus.ONLINE);\n+            }\n+            DevicesDTO devices = gsonLowerCase.fromJson(result.content, DevicesDTO.class);\n+            if (devices != null) {\n+                devicesCache = devices;\n+                devices.items.forEach(device -> {\n+                    ThingTypeUID thingTypeUID = new ThingTypeUID(BINDING_ID, device.deviceFamily);\n+                    if (SUPPORTED_DISCOVERY_THING_TYPES_UIDS.contains(thingTypeUID)) {\n+                        for (Thing thing : getThing().getThings()) {\n+                            ThingHandler handler = thing.getHandler();\n+                            if (handler != null && ((MyQDeviceHandler) handler).getSerialNumber()\n+                                    .equalsIgnoreCase(device.serialNumber)) {\n+                                ((MyQDeviceHandler) handler).handleDeviceUpdate(device);\n+                            }\n+                        }\n+                    }\n+                });\n+            }\n+        } else {\n+            handleErrorResponse(result);\n+        }\n+    }\n+\n+    private synchronized HttpResult sendRequest(String url, HttpMethod method, @Nullable String token,\n+            @Nullable ContentProvider content, @Nullable String contentType) throws InterruptedException {\n+        try {\n+            Request request = httpClient.newRequest(url).method(method)\n+                    .header(\"MyQApplicationId\", \"JVM/G9Nwih5BwKgNCjLxiFUQxQijAebyyg8QUHr7JOrP+tuPb8iHfRHKwTmDzHOu\")\n+                    .header(\"ApiVersion\", \"5.1\").header(\"BrandId\", \"2\").header(\"Culture\", \"en\").agent(userAgent)\n+                    .timeout(10, TimeUnit.SECONDS);\n+            if (token != null) {\n+                request = request.header(\"SecurityToken\", token);\n+            }\n+            if (content != null & contentType != null) {\n+                request = request.content(content, contentType);\n+            }\n+            // use asyc jetty as the API service will response with a 401 error when credentials are wrong,\n+            // but not a WWW-Authenticate header which causes Jetty to throw a generic execution exception which\n+            // prevents us from knowing the response code\n+            logger.trace(\"Sending {} to {}\", request.getMethod(), request.getURI());\n+            final CompletableFuture<HttpResult> futureResult = new CompletableFuture<>();\n+            request.send(new BufferingResponseListener() {\n+                @NonNullByDefault({})\n+                @Override\n+                public void onComplete(Result result) {\n+                    futureResult.complete(new HttpResult(result.getResponse().getStatus(), getContentAsString()));\n+                }\n+            });\n+            HttpResult result = futureResult.get();\n+            logger.trace(\"Account Response - status: {} content: {}\", result.responseCode, result.content);\n+            return result;\n+        } catch (ExecutionException e) {\n+            return new HttpResult(0, e.getMessage());\n+        }\n+    }\n+\n+    private void handleErrorResponse(HttpResult result) {\n+        if (HttpStatus.isSuccess(result.responseCode)) {\n+            return;\n+        }\n+        if (result.responseCode == HttpStatus.UNAUTHORIZED_401) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Unauthorized - Check Credentials\");\n+            securityToken = null;\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Invalid Response \" + result.content);\n+        }\n+    }\n+\n+    public static class HttpResult {\n+        public final int responseCode;\n+        public @Nullable String content;\n+\n+        public HttpResult(int responseCode, @Nullable String content) {\n+            this.responseCode = responseCode;\n+            this.content = content;\n+        }\n+    }\n+\n+    private static String randomString(int length) {\n+        int low = 97; // a-z\n+        int high = 122; // A-Z\n+        StringBuffer sb = new StringBuffer(length);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37eb721dd5eaa1316fcdf433de624cb1c060450d"}, "originalPosition": 342}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzU5MTY4OTU5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.myq/src/main/java/org/openhab/binding/myq/internal/handler/MyQAccountHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wNFQwNzowMjozOVrOIflVEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xNVQyMToxODowNlrOIluRHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTk4ODM2OQ==", "bodyText": "You should catch the JsonSyntaxException that is thrown here.", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r569988369", "createdAt": "2021-02-04T07:02:39Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.myq/src/main/java/org/openhab/binding/myq/internal/handler/MyQAccountHandler.java", "diffHunk": "@@ -0,0 +1,349 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.myq.internal.handler;\n+\n+import static org.openhab.binding.myq.internal.MyQBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Random;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentProvider;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.api.Result;\n+import org.eclipse.jetty.client.util.BufferingResponseListener;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.myq.internal.MyQDiscoveryService;\n+import org.openhab.binding.myq.internal.config.MyQAccountConfiguration;\n+import org.openhab.binding.myq.internal.dto.AccountDTO;\n+import org.openhab.binding.myq.internal.dto.ActionDTO;\n+import org.openhab.binding.myq.internal.dto.DevicesDTO;\n+import org.openhab.binding.myq.internal.dto.LoginRequestDTO;\n+import org.openhab.binding.myq.internal.dto.LoginResponseDTO;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.FieldNamingPolicy;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+\n+/**\n+ * The {@link MyQAccountHandler} is responsible for communicating with the MyQ API based on an account.\n+ *\n+ * @author Dan Cunningham - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MyQAccountHandler extends BaseBridgeHandler {\n+    private static final String BASE_URL = \"https://api.myqdevice.com/api\";\n+    private static final Integer RAPID_REFRESH_SECONDS = 5;\n+    private final Logger logger = LoggerFactory.getLogger(MyQAccountHandler.class);\n+    private final Gson gsonUpperCase = new GsonBuilder().setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE)\n+            .create();\n+    private final Gson gsonLowerCase = new GsonBuilder()\n+            .setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES).create();\n+    private @Nullable Future<?> normalPollFuture;\n+    private @Nullable Future<?> rapidPollFuture;\n+    private @Nullable String securityToken;\n+    private @Nullable AccountDTO account;\n+    private @Nullable DevicesDTO devicesCache;\n+    private Integer normalRefreshSeconds = 60;\n+    private HttpClient httpClient;\n+    private String username = \"\";\n+    private String password = \"\";\n+    private String userAgent = \"\";\n+\n+    public MyQAccountHandler(Bridge bridge, HttpClient httpClient) {\n+        super(bridge);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        MyQAccountConfiguration config = getConfigAs(MyQAccountConfiguration.class);\n+        normalRefreshSeconds = config.refreshInterval;\n+        username = config.username;\n+        password = config.password;\n+        // MyQ can get picky about blocking user agents apparently\n+        userAgent = MyQAccountHandler.randomString(40);\n+        securityToken = null;\n+        updateStatus(ThingStatus.UNKNOWN);\n+        restartPolls(false);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        stopPolls();\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(MyQDiscoveryService.class);\n+    }\n+\n+    @Override\n+    public void childHandlerInitialized(ThingHandler childHandler, Thing childThing) {\n+        DevicesDTO localDeviceCaches = devicesCache;\n+        if (localDeviceCaches != null && childHandler instanceof MyQDeviceHandler) {\n+            MyQDeviceHandler handler = (MyQDeviceHandler) childHandler;\n+            localDeviceCaches.items.stream()\n+                    .filter(d -> ((MyQDeviceHandler) childHandler).getSerialNumber().equalsIgnoreCase(d.serialNumber))\n+                    .findFirst().ifPresent(handler::handleDeviceUpdate);\n+        }\n+    }\n+\n+    /**\n+     * Sends an action to the MyQ API\n+     *\n+     * @param serialNumber\n+     * @param action\n+     */\n+    public void sendAction(String serialNumber, String action) {\n+        AccountDTO localAccount = account;\n+        if (localAccount != null) {\n+            try {\n+                HttpResult result = sendRequest(\n+                        String.format(\"%s/v5.1/Accounts/%s/Devices/%s/actions\", BASE_URL, localAccount.account.id,\n+                                serialNumber),\n+                        HttpMethod.PUT, securityToken,\n+                        new StringContentProvider(gsonLowerCase.toJson(new ActionDTO(action))), \"application/json\");\n+                if (HttpStatus.isSuccess(result.responseCode)) {\n+                    restartPolls(true);\n+                } else {\n+                    logger.debug(\"Failed to send action {} : {}\", action, result.content);\n+                }\n+            } catch (InterruptedException e) {\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Last known state of MyQ Devices\n+     *\n+     * @return cached MyQ devices\n+     */\n+    public @Nullable DevicesDTO devicesCache() {\n+        return devicesCache;\n+    }\n+\n+    private void stopPolls() {\n+        stopNormalPoll();\n+        stopRapidPoll();\n+    }\n+\n+    private synchronized void stopNormalPoll() {\n+        stopFuture(normalPollFuture);\n+        normalPollFuture = null;\n+    }\n+\n+    private synchronized void stopRapidPoll() {\n+        stopFuture(rapidPollFuture);\n+        rapidPollFuture = null;\n+    }\n+\n+    private void stopFuture(@Nullable Future<?> future) {\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+    }\n+\n+    private synchronized void restartPolls(boolean rapid) {\n+        stopPolls();\n+        if (rapid) {\n+            normalPollFuture = scheduler.scheduleWithFixedDelay(this::normalPoll, 35, normalRefreshSeconds,\n+                    TimeUnit.SECONDS);\n+            rapidPollFuture = scheduler.scheduleWithFixedDelay(this::rapidPoll, 3, RAPID_REFRESH_SECONDS,\n+                    TimeUnit.SECONDS);\n+        } else {\n+            normalPollFuture = scheduler.scheduleWithFixedDelay(this::normalPoll, 0, normalRefreshSeconds,\n+                    TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    private void normalPoll() {\n+        stopRapidPoll();\n+        fetchData();\n+    }\n+\n+    private void rapidPoll() {\n+        fetchData();\n+    }\n+\n+    private synchronized void fetchData() {\n+        try {\n+            if (securityToken == null) {\n+                login();\n+                if (securityToken != null) {\n+                    getAccount();\n+                }\n+            }\n+\n+            if (securityToken != null) {\n+                getDevices();\n+            }\n+        } catch (InterruptedException e) {\n+        }\n+    }\n+\n+    private void login() throws InterruptedException {\n+        HttpResult result = sendRequest(BASE_URL + \"/v5/Login\", HttpMethod.POST, null,\n+                new StringContentProvider(gsonUpperCase.toJson(new LoginRequestDTO(username, password))),\n+                \"application/json\");\n+        if (HttpStatus.isSuccess(result.responseCode)) {\n+            LoginResponseDTO loginResponse = gsonUpperCase.fromJson(result.content, LoginResponseDTO.class);\n+            if (loginResponse != null) {\n+                securityToken = loginResponse.securityToken;\n+                updateStatus(ThingStatus.ONLINE);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Invalid Response Body\");\n+            }\n+        } else {\n+            handleErrorResponse(result);\n+            if (thing.getStatusInfo().getStatusDetail() == ThingStatusDetail.CONFIGURATION_ERROR) {\n+                // bad credentials, stop trying to login\n+                stopPolls();\n+            }\n+        }\n+    }\n+\n+    private void getAccount() throws InterruptedException {\n+        HttpResult result = sendRequest(BASE_URL + \"/v5/My?expand=account\", HttpMethod.GET, securityToken, null, null);\n+        if (HttpStatus.isSuccess(result.responseCode)) {\n+            account = gsonUpperCase.fromJson(result.content, AccountDTO.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37eb721dd5eaa1316fcdf433de624cb1c060450d"}, "originalPosition": 244}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NjQyNjI3MQ==", "bodyText": "Done.", "url": "https://github.com/openhab/openhab-addons/pull/9347#discussion_r576426271", "createdAt": "2021-02-15T21:18:06Z", "author": {"login": "digitaldan"}, "path": "bundles/org.openhab.binding.myq/src/main/java/org/openhab/binding/myq/internal/handler/MyQAccountHandler.java", "diffHunk": "@@ -0,0 +1,349 @@\n+/**\n+ * Copyright (c) 2010-2021 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.myq.internal.handler;\n+\n+import static org.openhab.binding.myq.internal.MyQBindingConstants.*;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Random;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.client.HttpClient;\n+import org.eclipse.jetty.client.api.ContentProvider;\n+import org.eclipse.jetty.client.api.Request;\n+import org.eclipse.jetty.client.api.Result;\n+import org.eclipse.jetty.client.util.BufferingResponseListener;\n+import org.eclipse.jetty.client.util.StringContentProvider;\n+import org.eclipse.jetty.http.HttpMethod;\n+import org.eclipse.jetty.http.HttpStatus;\n+import org.openhab.binding.myq.internal.MyQDiscoveryService;\n+import org.openhab.binding.myq.internal.config.MyQAccountConfiguration;\n+import org.openhab.binding.myq.internal.dto.AccountDTO;\n+import org.openhab.binding.myq.internal.dto.ActionDTO;\n+import org.openhab.binding.myq.internal.dto.DevicesDTO;\n+import org.openhab.binding.myq.internal.dto.LoginRequestDTO;\n+import org.openhab.binding.myq.internal.dto.LoginResponseDTO;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.binding.BaseBridgeHandler;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.FieldNamingPolicy;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+\n+/**\n+ * The {@link MyQAccountHandler} is responsible for communicating with the MyQ API based on an account.\n+ *\n+ * @author Dan Cunningham - Initial contribution\n+ */\n+@NonNullByDefault\n+public class MyQAccountHandler extends BaseBridgeHandler {\n+    private static final String BASE_URL = \"https://api.myqdevice.com/api\";\n+    private static final Integer RAPID_REFRESH_SECONDS = 5;\n+    private final Logger logger = LoggerFactory.getLogger(MyQAccountHandler.class);\n+    private final Gson gsonUpperCase = new GsonBuilder().setFieldNamingPolicy(FieldNamingPolicy.UPPER_CAMEL_CASE)\n+            .create();\n+    private final Gson gsonLowerCase = new GsonBuilder()\n+            .setFieldNamingPolicy(FieldNamingPolicy.LOWER_CASE_WITH_UNDERSCORES).create();\n+    private @Nullable Future<?> normalPollFuture;\n+    private @Nullable Future<?> rapidPollFuture;\n+    private @Nullable String securityToken;\n+    private @Nullable AccountDTO account;\n+    private @Nullable DevicesDTO devicesCache;\n+    private Integer normalRefreshSeconds = 60;\n+    private HttpClient httpClient;\n+    private String username = \"\";\n+    private String password = \"\";\n+    private String userAgent = \"\";\n+\n+    public MyQAccountHandler(Bridge bridge, HttpClient httpClient) {\n+        super(bridge);\n+        this.httpClient = httpClient;\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        MyQAccountConfiguration config = getConfigAs(MyQAccountConfiguration.class);\n+        normalRefreshSeconds = config.refreshInterval;\n+        username = config.username;\n+        password = config.password;\n+        // MyQ can get picky about blocking user agents apparently\n+        userAgent = MyQAccountHandler.randomString(40);\n+        securityToken = null;\n+        updateStatus(ThingStatus.UNKNOWN);\n+        restartPolls(false);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        stopPolls();\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(MyQDiscoveryService.class);\n+    }\n+\n+    @Override\n+    public void childHandlerInitialized(ThingHandler childHandler, Thing childThing) {\n+        DevicesDTO localDeviceCaches = devicesCache;\n+        if (localDeviceCaches != null && childHandler instanceof MyQDeviceHandler) {\n+            MyQDeviceHandler handler = (MyQDeviceHandler) childHandler;\n+            localDeviceCaches.items.stream()\n+                    .filter(d -> ((MyQDeviceHandler) childHandler).getSerialNumber().equalsIgnoreCase(d.serialNumber))\n+                    .findFirst().ifPresent(handler::handleDeviceUpdate);\n+        }\n+    }\n+\n+    /**\n+     * Sends an action to the MyQ API\n+     *\n+     * @param serialNumber\n+     * @param action\n+     */\n+    public void sendAction(String serialNumber, String action) {\n+        AccountDTO localAccount = account;\n+        if (localAccount != null) {\n+            try {\n+                HttpResult result = sendRequest(\n+                        String.format(\"%s/v5.1/Accounts/%s/Devices/%s/actions\", BASE_URL, localAccount.account.id,\n+                                serialNumber),\n+                        HttpMethod.PUT, securityToken,\n+                        new StringContentProvider(gsonLowerCase.toJson(new ActionDTO(action))), \"application/json\");\n+                if (HttpStatus.isSuccess(result.responseCode)) {\n+                    restartPolls(true);\n+                } else {\n+                    logger.debug(\"Failed to send action {} : {}\", action, result.content);\n+                }\n+            } catch (InterruptedException e) {\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Last known state of MyQ Devices\n+     *\n+     * @return cached MyQ devices\n+     */\n+    public @Nullable DevicesDTO devicesCache() {\n+        return devicesCache;\n+    }\n+\n+    private void stopPolls() {\n+        stopNormalPoll();\n+        stopRapidPoll();\n+    }\n+\n+    private synchronized void stopNormalPoll() {\n+        stopFuture(normalPollFuture);\n+        normalPollFuture = null;\n+    }\n+\n+    private synchronized void stopRapidPoll() {\n+        stopFuture(rapidPollFuture);\n+        rapidPollFuture = null;\n+    }\n+\n+    private void stopFuture(@Nullable Future<?> future) {\n+        if (future != null) {\n+            future.cancel(true);\n+        }\n+    }\n+\n+    private synchronized void restartPolls(boolean rapid) {\n+        stopPolls();\n+        if (rapid) {\n+            normalPollFuture = scheduler.scheduleWithFixedDelay(this::normalPoll, 35, normalRefreshSeconds,\n+                    TimeUnit.SECONDS);\n+            rapidPollFuture = scheduler.scheduleWithFixedDelay(this::rapidPoll, 3, RAPID_REFRESH_SECONDS,\n+                    TimeUnit.SECONDS);\n+        } else {\n+            normalPollFuture = scheduler.scheduleWithFixedDelay(this::normalPoll, 0, normalRefreshSeconds,\n+                    TimeUnit.SECONDS);\n+        }\n+    }\n+\n+    private void normalPoll() {\n+        stopRapidPoll();\n+        fetchData();\n+    }\n+\n+    private void rapidPoll() {\n+        fetchData();\n+    }\n+\n+    private synchronized void fetchData() {\n+        try {\n+            if (securityToken == null) {\n+                login();\n+                if (securityToken != null) {\n+                    getAccount();\n+                }\n+            }\n+\n+            if (securityToken != null) {\n+                getDevices();\n+            }\n+        } catch (InterruptedException e) {\n+        }\n+    }\n+\n+    private void login() throws InterruptedException {\n+        HttpResult result = sendRequest(BASE_URL + \"/v5/Login\", HttpMethod.POST, null,\n+                new StringContentProvider(gsonUpperCase.toJson(new LoginRequestDTO(username, password))),\n+                \"application/json\");\n+        if (HttpStatus.isSuccess(result.responseCode)) {\n+            LoginResponseDTO loginResponse = gsonUpperCase.fromJson(result.content, LoginResponseDTO.class);\n+            if (loginResponse != null) {\n+                securityToken = loginResponse.securityToken;\n+                updateStatus(ThingStatus.ONLINE);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"Invalid Response Body\");\n+            }\n+        } else {\n+            handleErrorResponse(result);\n+            if (thing.getStatusInfo().getStatusDetail() == ThingStatusDetail.CONFIGURATION_ERROR) {\n+                // bad credentials, stop trying to login\n+                stopPolls();\n+            }\n+        }\n+    }\n+\n+    private void getAccount() throws InterruptedException {\n+        HttpResult result = sendRequest(BASE_URL + \"/v5/My?expand=account\", HttpMethod.GET, securityToken, null, null);\n+        if (HttpStatus.isSuccess(result.responseCode)) {\n+            account = gsonUpperCase.fromJson(result.content, AccountDTO.class);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2OTk4ODM2OQ=="}, "originalCommit": {"oid": "37eb721dd5eaa1316fcdf433de624cb1c060450d"}, "originalPosition": 244}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3643, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}