{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA3MzA2NTI3", "number": 8819, "title": "[bluetooth.bluez] Complete Bluez rewrite", "bodyText": "Bluetooth BlueZ Binding rewrite\nThis is a totally new version of the BlueZ binding and as such replaces the old TinyB implementation. This binding does not use any JNI nor native/platform dependent library, but directly communicates through DBUS socket with the system, which makes it very stable, reliable, and easy to install.\nIt has been tested on my production installation since last summer, through the multiple versions 2.5.7/2.5.8/2.5.9 and finally 3.0.0 (Ubuntu 20.04.1 LTS / Kernel 5.4.0-48 / BlueZ 5.53).\nI have worked with @cpmeister which has integrated the new Bluetooth API requirements/fixes on it.\nWe can use this thread on the forum to follow up as well: https://community.openhab.org/t/revival-of-official-bluetooth-binding/92759/86", "createdAt": "2020-10-21T07:02:45Z", "url": "https://github.com/openhab/openhab-addons/pull/8819", "merged": true, "mergeCommit": {"oid": "72bf43cfa03ed0b9b348ac7df0d646c9a3d89705"}, "closed": true, "closedAt": "2020-10-25T14:54:34Z", "author": {"login": "blafois"}, "timelineItems": {"totalCount": 26, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdSHup5AH2gAyNTA3MzA2NTI3OmE5ZDQ3NTJlYzViODY0NjUzYTgxNTFmMjNjYTIzZmRmMjg2YzE2Y2M=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdV9gBlAFqTUxNjM0NTkzNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "a9d4752ec5b864653a8151f23ca23fdf286c16cc", "author": {"user": {"login": "blafois", "name": "Benjamin Lafois"}}, "url": "https://github.com/openhab/openhab-addons/commit/a9d4752ec5b864653a8151f23ca23fdf286c16cc", "committedDate": "2020-10-13T12:28:10Z", "message": "removed duplicate channel RSSI\n\nSigned-off-by: Benjamin Lafois <benjamin.lafois@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1e67777e5ee588d82fccd47bbdbbaa8d1f12d39d", "author": {"user": {"login": "blafois", "name": "Benjamin Lafois"}}, "url": "https://github.com/openhab/openhab-addons/commit/1e67777e5ee588d82fccd47bbdbbaa8d1f12d39d", "committedDate": "2020-10-20T18:39:47Z", "message": "replacement of old dbus binding by blueZ one, adapted to OH3\n\nSigned-off-by: Benjamin Lafois <benjamin.lafois@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTEzOTIwMjg4", "url": "https://github.com/openhab/openhab-addons/pull/8819#pullrequestreview-513920288", "createdAt": "2020-10-21T16:38:37Z", "commit": {"oid": "1e67777e5ee588d82fccd47bbdbbaa8d1f12d39d"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNjozODozN1rOHl1jOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxNzoyMDowN1rOHl3b1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQzNjczMA==", "bodyText": "Looks like I forgot to resolve the conflicts here from my own branch...\nJust leave it as\nBridge bluetooth:bluez:hci0 [ address=\"12:34:56:78:90:AB\", backgroundDiscovery=false ]", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r509436730", "createdAt": "2020-10-21T16:38:37Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/README.md", "diffHunk": "@@ -45,19 +12,26 @@ It defines the following bridge type:\n | bluez          | A Bluetooth adapter that is supported by BlueZ                            |\n \n \n-## Discovery\n-\n-If BlueZ is enabled and can be accessed, all available adapters are automatically discovered.\n-\n ## Bridge Configuration\n \n The bluez bridge requires the configuration parameter `address`, which corresponds to the Bluetooth address of the adapter (in format \"XX:XX:XX:XX:XX:XX\").\n+\n Additionally, the parameter `backgroundDiscovery` can be set to true/false.When set to true, any Bluetooth device of which broadcasts are received is added to the Inbox.\n \n ## Example\n \n This is how an BlueZ adapter can be configured textually in a *.things file:\n \n ```\n+<<<<<<< HEAD\n+Bridge bluetooth:bluez:hci0 [ address=\"12:34:56:78:90:AB\" ]\n+=======\n Bridge bluetooth:bluez:hci0 [ address=\"12:34:56:78:90:AB\", backgroundDiscovery=false ]\n+>>>>>>> bluetooth-channels", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e67777e5ee588d82fccd47bbdbbaa8d1f12d39d"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQzNjg5OQ==", "bodyText": "This should be left in.", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r509436899", "createdAt": "2020-10-21T16:38:55Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/README.md", "diffHunk": "@@ -45,19 +12,26 @@ It defines the following bridge type:\n | bluez          | A Bluetooth adapter that is supported by BlueZ                            |\n \n \n-## Discovery\n-\n-If BlueZ is enabled and can be accessed, all available adapters are automatically discovered.\n-", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e67777e5ee588d82fccd47bbdbbaa8d1f12d39d"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQzNzE2NQ==", "bodyText": "These setup notes should be left in as well.", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r509437165", "createdAt": "2020-10-21T16:39:18Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/README.md", "diffHunk": "@@ -1,40 +1,7 @@\n # Bluetooth BlueZ Adapter\n \n-This extension supports Bluetooth access via BlueZ on Linux (ARMv6hf).\n+This extension supports Bluetooth access via BlueZ and DBus on Linux. This is architecture agnostic and uses Unix Sockets.\n \n-# Setup\n-\n-Please note that at least BlueZ 5.43 is required, while 5.48 or above are [not (yet) supported](https://github.com/intel-iot-devkit/tinyb/issues/131) either.\n-\n-Some settings are required to ensure that openHAB has access to Bluez.\n-To allow openHAB to access Bluez via dbus you need to add the following entry within your dbus configuration in `/etc/dbus-1/system.d/bluetooth.conf`\n-\n-```xml\n-<busconfig>\n-  <policy user=\"root\">\n-    ...\n-  </policy>\n-  <policy group=\"bluetooth\">\n-    <allow send_destination=\"org.bluez\"/>\n-  </policy>\n-  ...\n-</busconfig>\n-```\n-\n-and add openHAB to the \"bluetooth\" group.\n-\n-```shell\n-sudo adduser openhab bluetooth\n-```\n-\n-Also, in case you don't want to manually enable your bluetooth adapters with `bluetoothctl`, ensure that it's automatically enabled by setting the option `AutoEnable` in your `/etc/bluetooth/main.conf` to `true`.\n-Restart running services for changes to take effect.\n-\n-```\n-systemctl restart dbus\n-systemctl restart bluetooth\n-systemctl restart openhab2\n-```", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e67777e5ee588d82fccd47bbdbbaa8d1f12d39d"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQzNzkwNg==", "bodyText": "This line isn't needed until the general bluetooth PR is committed, so feel free to remove this.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t<bundle dependency=\"true\">mvn:commons-beanutils/commons-beanutils/1.9.3</bundle>", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r509437906", "createdAt": "2020-10-21T16:40:22Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/feature/feature.xml", "diffHunk": "@@ -4,7 +4,9 @@\n \n \t<feature name=\"openhab-binding-bluetooth-bluez\" description=\"Bluetooth Binding Bluez\" version=\"${project.version}\">\n \t\t<feature>openhab-runtime-base</feature>\n-\t\t<feature>openhab-transport-serial</feature>\n+\n+\t\t<bundle dependency=\"true\">mvn:com.github.hypfvieh/bluez-dbus-osgi/0.1.3</bundle>\n+\t\t<bundle dependency=\"true\">mvn:commons-beanutils/commons-beanutils/1.9.3</bundle>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e67777e5ee588d82fccd47bbdbbaa8d1f12d39d"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQzOTIyNQ==", "bodyText": "This should be kept as is.", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r509439225", "createdAt": "2020-10-21T16:42:18Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZHandlerFactory.java", "diffHunk": "@@ -30,33 +30,47 @@\n import org.openhab.core.thing.binding.ThingHandler;\n import org.openhab.core.thing.binding.ThingHandlerFactory;\n import org.osgi.framework.ServiceRegistration;\n+import org.osgi.service.component.annotations.Activate;\n import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n /**\n  * The {@link BlueZHandlerFactory} is responsible for creating things and thing\n  * handlers.\n  *\n- * @author Kai Kreuzer - Initial contribution and API\n+ * @author Benjamin Lafois - Initial contribution and API", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e67777e5ee588d82fccd47bbdbbaa8d1f12d39d"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQzOTYyNg==", "bodyText": "remove blank line", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r509439626", "createdAt": "2020-10-21T16:42:55Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZPropertiesChangedHandler.java", "diffHunk": "@@ -0,0 +1,215 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.freedesktop.dbus.DBusMap;\n+import org.freedesktop.dbus.handlers.AbstractPropertiesChangedHandler;\n+import org.freedesktop.dbus.interfaces.Properties.PropertiesChanged;\n+import org.freedesktop.dbus.types.UInt16;\n+import org.freedesktop.dbus.types.Variant;\n+import org.openhab.binding.bluetooth.BluetoothAddress;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterDiscoveringChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterPoweredChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEventListener;\n+import org.openhab.binding.bluetooth.bluez.internal.events.CharacteristicUpdateEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ConnectedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ManufacturerDataEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.NameEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.RssiEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ServicesResolvedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.TXPowerEvent;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ *\n+ *\n+ * @author Benjamin Lafois - Initial contribution and API\n+ *\n+ */\n+@NonNullByDefault\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e67777e5ee588d82fccd47bbdbbaa8d1f12d39d"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQ0MDE0OA==", "bodyText": "I forgot to remove this earlier.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            @Component(service = DeviceManagerFactory.class, immediate = true)\n          \n          \n            \n            @Component(service = DeviceManagerFactory.class)", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r509440148", "createdAt": "2020-10-21T16:43:46Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/DeviceManagerFactory.java", "diffHunk": "@@ -0,0 +1,167 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.freedesktop.dbus.exceptions.DBusException;\n+import org.openhab.core.common.NamedThreadFactory;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.github.hypfvieh.bluetooth.DeviceManager;\n+\n+/**\n+ *\n+ * @author Connor Petty - Initial Contribution\n+ *\n+ */\n+@NonNullByDefault\n+@Component(service = DeviceManagerFactory.class, immediate = true)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e67777e5ee588d82fccd47bbdbbaa8d1f12d39d"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQ2MzQ0NA==", "bodyText": "This change shouldn't be part of this PR.", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r509463444", "createdAt": "2020-10-21T17:15:49Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bluetooth.daikinmadoka/src/main/resources/OH-INF/thing/daikinmadoka.xml", "diffHunk": "@@ -6,14 +6,13 @@\n \n \t<thing-type id=\"brc1h\">\n \t\t<supported-bridge-type-refs>\n-\t\t\t<bridge-type-ref id=\"dbusbluez\"/>\n+\t\t\t<bridge-type-ref id=\"bluez\"/>\n \t\t</supported-bridge-type-refs>\n \n \t\t<label>Daikin BRC1H Thermostat</label>\n \t\t<description>A Daikin Madoka BRC1H Thermostat (BLE)</description>\n \n \t\t<channels>\n-\t\t\t<channel id=\"rssi\" typeId=\"rssi\"/>\n \t\t\t<channel id=\"onOffStatus\" typeId=\"brc1h_onOffStatus\"/>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e67777e5ee588d82fccd47bbdbbaa8d1f12d39d"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQ2NDY4Mg==", "bodyText": "This shouldn't be changed", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r509464682", "createdAt": "2020-10-21T17:17:09Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZAdapterConfiguration.java", "diffHunk": "@@ -10,14 +10,14 @@\n  *\n  * SPDX-License-Identifier: EPL-2.0\n  */\n-package org.openhab.binding.bluetooth.bluez.handler;\n+package org.openhab.binding.bluetooth.bluez.internal;\n \n import org.openhab.binding.bluetooth.BaseBluetoothBridgeHandlerConfiguration;\n \n /**\n- * Configuration properties class.\n+ * Configuration properties for a bridge.\n  *\n- * @author Hilbrand Bouwkamp - Initial contribution\n+ * @author Benjamin Lafois - Initial contribution", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e67777e5ee588d82fccd47bbdbbaa8d1f12d39d"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQ2NjA5Mg==", "bodyText": "This can be removed", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r509466092", "createdAt": "2020-10-21T17:18:32Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBluetoothDevice.java", "diffHunk": "@@ -0,0 +1,501 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.bluez.exceptions.BluezFailedException;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.freedesktop.dbus.errors.NoReply;\n+import org.freedesktop.dbus.exceptions.DBusException;\n+import org.freedesktop.dbus.exceptions.DBusExecutionException;\n+import org.freedesktop.dbus.types.UInt16;\n+import org.openhab.binding.bluetooth.BaseBluetoothDevice;\n+import org.openhab.binding.bluetooth.BluetoothAddress;\n+import org.openhab.binding.bluetooth.BluetoothCharacteristic;\n+import org.openhab.binding.bluetooth.BluetoothCompletionStatus;\n+import org.openhab.binding.bluetooth.BluetoothDescriptor;\n+import org.openhab.binding.bluetooth.BluetoothService;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEventListener;\n+import org.openhab.binding.bluetooth.bluez.internal.events.CharacteristicUpdateEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ConnectedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ManufacturerDataEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.NameEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.RssiEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ServicesResolvedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.TXPowerEvent;\n+import org.openhab.binding.bluetooth.notification.BluetoothConnectionStatusNotification;\n+import org.openhab.binding.bluetooth.notification.BluetoothScanNotification;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.util.HexUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothDevice;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattCharacteristic;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattDescriptor;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattService;\n+\n+/**\n+ * Implementation of BluetoothDevice for BlueZ via DBus-BlueZ API\n+ *\n+ *\n+ * @author Benjamin Lafois - Initial contribution and API\n+ *\n+ */\n+@NonNullByDefault\n+public class BlueZBluetoothDevice extends BaseBluetoothDevice implements BlueZEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(BlueZBluetoothDevice.class);\n+\n+    // Device from native lib\n+    private @Nullable BluetoothDevice device = null;\n+\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager.getScheduledPool(\"bluetooth\");\n+\n+    protected final Map<UUID, BluetoothService> supportedServices = new HashMap<>();\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param adapter the bridge handler through which this device is connected\n+     * @param address the Bluetooth address of the device\n+     * @param name the name of the device\n+     */\n+    public BlueZBluetoothDevice(BlueZBridgeHandler adapter, BluetoothAddress address) {\n+        super(adapter, address);\n+        logger.debug(\"Creating DBusBlueZ device with address '{}'\", address);\n+    }\n+\n+    public synchronized void updateBlueZDevice(@Nullable BluetoothDevice blueZDevice) {\n+        if (this.device != null && this.device == blueZDevice) {\n+            // logger.debug(\"Objects representing the BT device {} has not changed. Exiting function.\", address);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e67777e5ee588d82fccd47bbdbbaa8d1f12d39d"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQ2NjI5Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                logger.error(\"error occured while trying to connect\", e);\n          \n          \n            \n                                logger.warn(\"error occured while trying to connect\", e);", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r509466292", "createdAt": "2020-10-21T17:18:48Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBluetoothDevice.java", "diffHunk": "@@ -0,0 +1,501 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.bluez.exceptions.BluezFailedException;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.freedesktop.dbus.errors.NoReply;\n+import org.freedesktop.dbus.exceptions.DBusException;\n+import org.freedesktop.dbus.exceptions.DBusExecutionException;\n+import org.freedesktop.dbus.types.UInt16;\n+import org.openhab.binding.bluetooth.BaseBluetoothDevice;\n+import org.openhab.binding.bluetooth.BluetoothAddress;\n+import org.openhab.binding.bluetooth.BluetoothCharacteristic;\n+import org.openhab.binding.bluetooth.BluetoothCompletionStatus;\n+import org.openhab.binding.bluetooth.BluetoothDescriptor;\n+import org.openhab.binding.bluetooth.BluetoothService;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEventListener;\n+import org.openhab.binding.bluetooth.bluez.internal.events.CharacteristicUpdateEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ConnectedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ManufacturerDataEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.NameEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.RssiEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ServicesResolvedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.TXPowerEvent;\n+import org.openhab.binding.bluetooth.notification.BluetoothConnectionStatusNotification;\n+import org.openhab.binding.bluetooth.notification.BluetoothScanNotification;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.util.HexUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothDevice;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattCharacteristic;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattDescriptor;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattService;\n+\n+/**\n+ * Implementation of BluetoothDevice for BlueZ via DBus-BlueZ API\n+ *\n+ *\n+ * @author Benjamin Lafois - Initial contribution and API\n+ *\n+ */\n+@NonNullByDefault\n+public class BlueZBluetoothDevice extends BaseBluetoothDevice implements BlueZEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(BlueZBluetoothDevice.class);\n+\n+    // Device from native lib\n+    private @Nullable BluetoothDevice device = null;\n+\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager.getScheduledPool(\"bluetooth\");\n+\n+    protected final Map<UUID, BluetoothService> supportedServices = new HashMap<>();\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param adapter the bridge handler through which this device is connected\n+     * @param address the Bluetooth address of the device\n+     * @param name the name of the device\n+     */\n+    public BlueZBluetoothDevice(BlueZBridgeHandler adapter, BluetoothAddress address) {\n+        super(adapter, address);\n+        logger.debug(\"Creating DBusBlueZ device with address '{}'\", address);\n+    }\n+\n+    public synchronized void updateBlueZDevice(@Nullable BluetoothDevice blueZDevice) {\n+        if (this.device != null && this.device == blueZDevice) {\n+            // logger.debug(\"Objects representing the BT device {} has not changed. Exiting function.\", address);\n+            return;\n+        }\n+        logger.debug(\"updateBlueZDevice({})\", blueZDevice);\n+\n+        this.device = blueZDevice;\n+\n+        if (blueZDevice == null) {\n+            return;\n+        }\n+\n+        Short rssi = blueZDevice.getRssi();\n+        if (rssi != null) {\n+            this.rssi = rssi.intValue();\n+        }\n+        this.name = blueZDevice.getName();\n+        Map<UInt16, byte[]> manData = blueZDevice.getManufacturerData();\n+        if (manData != null) {\n+            manData.entrySet().stream().map(Map.Entry::getKey).filter(Objects::nonNull).findFirst()\n+                    .ifPresent((UInt16 manufacturerId) ->\n+                    // Convert to unsigned int to match the convention in BluetoothCompanyIdentifiers\n+                    this.manufacturer = manufacturerId.intValue() & 0xFFFF);\n+        }\n+\n+        if (Boolean.TRUE.equals(blueZDevice.isConnected())) {\n+            setConnectionState(ConnectionState.CONNECTED);\n+        }\n+\n+        discoverServices();\n+    }\n+\n+    /**\n+     * Clean up and release memory.\n+     */\n+    @Override\n+    public void dispose() {\n+        BluetoothDevice dev = device;\n+        if (dev != null) {\n+            try {\n+                dev.getAdapter().removeDevice(dev.getRawDevice());\n+            } catch (DBusException ex) {\n+                if (ex.getMessage().contains(\"Does Not Exist\")) {\n+                    // this happens when the underlying device has already been removed\n+                    // but we don't have a way to check if that is the case beforehand so\n+                    // we will just eat the error here.\n+                } else {\n+                    logger.debug(\"Exception occurred when trying to remove inactive device '{}': {}\", address,\n+                            ex.getMessage());\n+                }\n+            } catch (RuntimeException ex) {\n+                // try to catch any other exceptions\n+                logger.debug(\"Exception occurred when trying to remove inactive device '{}': {}\", address,\n+                        ex.getMessage());\n+            }\n+        }\n+    }\n+\n+    private void setConnectionState(ConnectionState state) {\n+        if (this.connectionState != state) {\n+            this.connectionState = state;\n+            notifyListeners(BluetoothEventType.CONNECTION_STATE, new BluetoothConnectionStatusNotification(state));\n+        }\n+    }\n+\n+    @Override\n+    public boolean connect() {\n+        logger.debug(\"Connect({})\", device);\n+\n+        BluetoothDevice dev = device;\n+        if (dev != null) {\n+            if (Boolean.FALSE.equals(dev.isConnected())) {\n+                try {\n+                    boolean ret = dev.connect();\n+                    logger.debug(\"Connect result: {}\", ret);\n+                    return ret;\n+                } catch (NoReply e) {\n+                    // Have to double check because sometimes, exception but still worked\n+                    logger.debug(\"Got a timeout - but sometimes happen. Is Connected ? {}\", dev.isConnected());\n+                    if (Boolean.FALSE.equals(dev.isConnected())) {\n+\n+                        notifyListeners(BluetoothEventType.CONNECTION_STATE,\n+                                new BluetoothConnectionStatusNotification(ConnectionState.DISCONNECTED));\n+                        return false;\n+                    } else {\n+                        return true;\n+                    }\n+                } catch (DBusExecutionException e) {\n+                    // Catch \"software caused connection abort\"\n+                    return false;\n+                } catch (Exception e) {\n+                    logger.error(\"error occured while trying to connect\", e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e67777e5ee588d82fccd47bbdbbaa8d1f12d39d"}, "originalPosition": 179}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQ2NzEwMw==", "bodyText": "This can be removed", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r509467103", "createdAt": "2020-10-21T17:19:37Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBridgeHandler.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.List;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bluetooth.AbstractBluetoothBridgeHandler;\n+import org.openhab.binding.bluetooth.BluetoothAddress;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterDiscoveringChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterPoweredChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEventListener;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.github.hypfvieh.bluetooth.DeviceManager;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothAdapter;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothDevice;\n+\n+/**\n+ * The {@link BlueZBridgeHandler} is responsible for talking to the BlueZ stack, using DBus Unix Socket.\n+ * This Binding does not use any JNI.\n+ * It provides a private interface for {@link BlueZBluetoothDevice}s to access the stack and provides top\n+ * level adaptor functionality for scanning and arbitration.\n+ *\n+ * @author Benjamin Lafois - Initial contribution and API\n+ */\n+@NonNullByDefault\n+public class BlueZBridgeHandler extends AbstractBluetoothBridgeHandler<BlueZBluetoothDevice>\n+        implements BlueZEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(BlueZBridgeHandler.class);\n+\n+    // ADAPTER from BlueZ-DBus Library\n+    private @Nullable BluetoothAdapter adapter;\n+\n+    // Our BT address\n+    private @Nullable BluetoothAddress adapterAddress;\n+\n+    // private final ReentrantLock lockDiscoveryJob = new ReentrantLock();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e67777e5ee588d82fccd47bbdbbaa8d1f12d39d"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTQ2NzYwNQ==", "bodyText": "This can be removed", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r509467605", "createdAt": "2020-10-21T17:20:07Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBridgeHandler.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.List;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bluetooth.AbstractBluetoothBridgeHandler;\n+import org.openhab.binding.bluetooth.BluetoothAddress;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterDiscoveringChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterPoweredChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEventListener;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.github.hypfvieh.bluetooth.DeviceManager;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothAdapter;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothDevice;\n+\n+/**\n+ * The {@link BlueZBridgeHandler} is responsible for talking to the BlueZ stack, using DBus Unix Socket.\n+ * This Binding does not use any JNI.\n+ * It provides a private interface for {@link BlueZBluetoothDevice}s to access the stack and provides top\n+ * level adaptor functionality for scanning and arbitration.\n+ *\n+ * @author Benjamin Lafois - Initial contribution and API\n+ */\n+@NonNullByDefault\n+public class BlueZBridgeHandler extends AbstractBluetoothBridgeHandler<BlueZBluetoothDevice>\n+        implements BlueZEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(BlueZBridgeHandler.class);\n+\n+    // ADAPTER from BlueZ-DBus Library\n+    private @Nullable BluetoothAdapter adapter;\n+\n+    // Our BT address\n+    private @Nullable BluetoothAddress adapterAddress;\n+\n+    // private final ReentrantLock lockDiscoveryJob = new ReentrantLock();\n+\n+    private @Nullable ScheduledFuture<?> discoveryJob;\n+\n+    private final DeviceManagerFactory deviceManagerFactory;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param bridge the bridge definition for this handler\n+     */\n+    public BlueZBridgeHandler(Bridge bridge, DeviceManagerFactory deviceManagerFactory) {\n+        super(bridge);\n+        this.deviceManagerFactory = deviceManagerFactory;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+\n+        // Load configuration\n+        final BlueZAdapterConfiguration configuration = getConfigAs(BlueZAdapterConfiguration.class);\n+        if (configuration.address != null) {\n+            this.adapterAddress = new BluetoothAddress(configuration.address.toUpperCase());\n+        } else {\n+            // If configuration does not contain adapter address to use, exit with error.\n+            logger.info(\"Adapter MAC address not provided\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"address not set\");\n+            return;\n+        }\n+\n+        logger.debug(\"Creating BlueZ adapter with address '{}'\", adapterAddress);\n+\n+        updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.CONFIGURATION_PENDING, \"Initializing\");\n+\n+        deviceManagerFactory.getPropertiesChangedHandler().addListener(this);\n+\n+        discoveryJob = scheduler.scheduleWithFixedDelay(this::initializeAndRefreshDevices, 5, 10, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        deviceManagerFactory.getPropertiesChangedHandler().removeListener(this);\n+        logger.debug(\"Termination of DBus BlueZ handler\");\n+\n+        Future<?> job = discoveryJob;\n+        if (job != null) {\n+            job.cancel(false);\n+            discoveryJob = null;\n+        }\n+\n+        if (this.adapter != null) {\n+            ((@NonNull BluetoothAdapter) this.adapter).stopDiscovery();\n+            this.adapter = null;\n+        }\n+\n+        super.dispose();\n+    }\n+\n+    private static @Nullable BluetoothAdapter findAdapter(DeviceManager deviceManager, String address) {\n+        List<BluetoothAdapter> adapters = deviceManager.getAdapters();\n+        if (adapters != null) {\n+            for (BluetoothAdapter btAdapter : adapters) {\n+                if (btAdapter.getAddress() != null && btAdapter.getAddress().equalsIgnoreCase(address)) {\n+                    return btAdapter;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private boolean validateAdapter(DeviceManager deviceManager) {\n+\n+        // next lets check if we can find our adapter in the manager.\n+        BluetoothAdapter localAdapter = adapter;\n+        if (localAdapter == null) {\n+            if (adapterAddress != null) {\n+                localAdapter = adapter = findAdapter(deviceManager,\n+                        ((@NonNull BluetoothAddress) adapterAddress).toString());\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No adapter address provided\");\n+                return false;\n+            }\n+        }\n+        if (localAdapter == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Native adapter could not be found for address '\" + adapterAddress + \"'\");\n+            return false;\n+        }\n+        // now lets confirm that the adapter is powered\n+        if (!localAdapter.isPowered()) {\n+            localAdapter.setPowered(true);\n+            // give the device some time to power on\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.DUTY_CYCLE,\n+                    \"Adapter is not powered, attempting to turn on...\");\n+            return false;\n+        }\n+\n+        // now lets make sure that discovery is turned on\n+        if (!Boolean.TRUE.equals(localAdapter.isDiscovering())) {\n+            // we will check for devices next time around\n+            localAdapter.startDiscovery();\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.DUTY_CYCLE, \"Starting discovery\");\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    private void initializeAndRefreshDevices() {\n+        logger.debug(\"initializeAndRefreshDevice()\");\n+\n+        try {\n+            // first check if the device manager is ready\n+            DeviceManager deviceManager = deviceManagerFactory.getDeviceManager();\n+            if (deviceManager == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Bluez DeviceManager not available yet.\");\n+                return;\n+            }\n+\n+            if (!validateAdapter(deviceManager)) {\n+                return;\n+            }\n+\n+            // as we have already validated the adapteraddress in {@link #validateAdapter(DeviceAdapter)}, we can safely\n+            // assume that adapterAddress is not null.\n+            @NonNull\n+            BluetoothAddress adapterAddress = (@NonNull BluetoothAddress) this.adapterAddress;\n+\n+            // now lets refresh devices\n+            List<BluetoothDevice> bluezDevices = deviceManager.getDevices(adapterAddress.toString(), true);\n+            logger.debug(\"Found {} Bluetooth devices.\", bluezDevices.size());\n+            for (BluetoothDevice bluezDevice : bluezDevices) {\n+                // logger.debug(\"discovered device {}\", bluezDevice);\n+                if (bluezDevice.getAddress() == null) {\n+                    // For some reasons, sometimes the address is null..\n+                    continue;\n+                }\n+                BlueZBluetoothDevice device = getDevice(new BluetoothAddress(bluezDevice.getAddress()));\n+                device.updateBlueZDevice(bluezDevice);\n+                deviceDiscovered(device);\n+            }\n+            updateStatus(ThingStatus.ONLINE);\n+        } catch (Exception ex) {\n+            // don't know what kind of exception the bluez library might throw at us so lets catch them here so our\n+            // scheduler loop doesn't get terminated\n+            logger.warn(\"Unknown exception\", ex);\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, ex.getMessage());\n+        }\n+    }\n+\n+    @Override\n+    public @Nullable BluetoothAddress getAddress() {\n+        return adapterAddress;\n+    }\n+\n+    @Override\n+    protected BlueZBluetoothDevice createDevice(BluetoothAddress address) {\n+        logger.debug(\"createDevice {}\", address);\n+        BlueZBluetoothDevice device = new BlueZBluetoothDevice(this, address);\n+        return device;\n+    }\n+\n+    @Override\n+    public void onDBusBlueZEvent(BlueZEvent event) {\n+\n+        BluetoothAdapter localAdapter = this.adapter;\n+        String adapterName = event.getAdapterName();\n+        if (adapterName == null || localAdapter == null) {\n+            // We cannot be sure that this event concerns this adapter.. So ignore message\n+            return;\n+        }\n+        String localName = localAdapter.getDeviceName();\n+\n+        // logger.debug(\"Received event {}. Adapter={}. AdapterBridge={}\", event.getClass().getSimpleName(),\n+        // adapterName,\n+        // localName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e67777e5ee588d82fccd47bbdbbaa8d1f12d39d"}, "originalPosition": 235}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bb659f9e334d1a8366b4b9623d2afb54ea3c24ba", "author": {"user": {"login": "blafois", "name": "Benjamin Lafois"}}, "url": "https://github.com/openhab/openhab-addons/commit/bb659f9e334d1a8366b4b9623d2afb54ea3c24ba", "committedDate": "2020-10-21T17:59:59Z", "message": "PR Review by @cpmeister #1\n\nSigned-off-by: Benjamin Lafois <benjamin.lafois@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0MDY1NDI2", "url": "https://github.com/openhab/openhab-addons/pull/8819#pullrequestreview-514065426", "createdAt": "2020-10-21T18:33:19Z", "commit": {"oid": "bb659f9e334d1a8366b4b9623d2afb54ea3c24ba"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxODozMzoxOVrOHl9D-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMVQxODozOTowM1rOHl9YlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTU1OTgwMw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Bridge bluetooth:bluez:hci0 [ address=\"12:34:56:78:90:AB\" ]\n          \n          \n            \n            Bridge bluetooth:bluez:hci0 [ address=\"12:34:56:78:90:AB\", backgroundDiscovery=false ]", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r509559803", "createdAt": "2020-10-21T18:33:19Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/README.md", "diffHunk": "@@ -44,20 +44,27 @@ It defines the following bridge type:\n |----------------|---------------------------------------------------------------------------|\n | bluez          | A Bluetooth adapter that is supported by BlueZ                            |\n \n-\n ## Discovery\n \n If BlueZ is enabled and can be accessed, all available adapters are automatically discovered.\n \n+\n ## Bridge Configuration\n \n The bluez bridge requires the configuration parameter `address`, which corresponds to the Bluetooth address of the adapter (in format \"XX:XX:XX:XX:XX:XX\").\n+\n Additionally, the parameter `backgroundDiscovery` can be set to true/false.When set to true, any Bluetooth device of which broadcasts are received is added to the Inbox.\n \n ## Example\n \n This is how an BlueZ adapter can be configured textually in a *.things file:\n \n ```\n-Bridge bluetooth:bluez:hci0 [ address=\"12:34:56:78:90:AB\", backgroundDiscovery=false ]\n+Bridge bluetooth:bluez:hci0 [ address=\"12:34:56:78:90:AB\" ]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb659f9e334d1a8366b4b9623d2afb54ea3c24ba"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTU2MDE1Nw==", "bodyText": "This shouldn't be changed", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r509560157", "createdAt": "2020-10-21T18:33:54Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZAdapterConstants.java", "diffHunk": "@@ -20,7 +20,7 @@\n  * The {@link BlueZAdapterConstants} class defines common constants, which are\n  * used across the whole binding.\n  *\n- * @author Kai Kreuzer - Initial contribution and API\n+ * @author Benjamin Lafois - Initial contribution and API", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb659f9e334d1a8366b4b9623d2afb54ea3c24ba"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTU2MTgwOA==", "bodyText": "This should already be inherited from the BaseBluetoothDevice, so remove this field.", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r509561808", "createdAt": "2020-10-21T18:35:26Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBluetoothDevice.java", "diffHunk": "@@ -0,0 +1,500 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.bluez.exceptions.BluezFailedException;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.freedesktop.dbus.errors.NoReply;\n+import org.freedesktop.dbus.exceptions.DBusException;\n+import org.freedesktop.dbus.exceptions.DBusExecutionException;\n+import org.freedesktop.dbus.types.UInt16;\n+import org.openhab.binding.bluetooth.BaseBluetoothDevice;\n+import org.openhab.binding.bluetooth.BluetoothAddress;\n+import org.openhab.binding.bluetooth.BluetoothCharacteristic;\n+import org.openhab.binding.bluetooth.BluetoothCompletionStatus;\n+import org.openhab.binding.bluetooth.BluetoothDescriptor;\n+import org.openhab.binding.bluetooth.BluetoothService;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEventListener;\n+import org.openhab.binding.bluetooth.bluez.internal.events.CharacteristicUpdateEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ConnectedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ManufacturerDataEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.NameEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.RssiEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ServicesResolvedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.TXPowerEvent;\n+import org.openhab.binding.bluetooth.notification.BluetoothConnectionStatusNotification;\n+import org.openhab.binding.bluetooth.notification.BluetoothScanNotification;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.util.HexUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothDevice;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattCharacteristic;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattDescriptor;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattService;\n+\n+/**\n+ * Implementation of BluetoothDevice for BlueZ via DBus-BlueZ API\n+ *\n+ *\n+ * @author Benjamin Lafois - Initial contribution and API\n+ *\n+ */\n+@NonNullByDefault\n+public class BlueZBluetoothDevice extends BaseBluetoothDevice implements BlueZEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(BlueZBluetoothDevice.class);\n+\n+    // Device from native lib\n+    private @Nullable BluetoothDevice device = null;\n+\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager.getScheduledPool(\"bluetooth\");\n+\n+    protected final Map<UUID, BluetoothService> supportedServices = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb659f9e334d1a8366b4b9623d2afb54ea3c24ba"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTU2Mzc1Ng==", "bodyText": "We should keep the authoring tags.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             *\n          \n          \n            \n             * @author Benjamin Lafois - Initial contribution and API\n          \n          \n            \n             * @author Kai Kreuzer - Initial contribution and API\n          \n          \n            \n             * @author Benjamin Lafois - Reimplemented using Dbus instead of tinyB", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r509563756", "createdAt": "2020-10-21T18:37:36Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBluetoothDevice.java", "diffHunk": "@@ -0,0 +1,500 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.bluez.exceptions.BluezFailedException;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.freedesktop.dbus.errors.NoReply;\n+import org.freedesktop.dbus.exceptions.DBusException;\n+import org.freedesktop.dbus.exceptions.DBusExecutionException;\n+import org.freedesktop.dbus.types.UInt16;\n+import org.openhab.binding.bluetooth.BaseBluetoothDevice;\n+import org.openhab.binding.bluetooth.BluetoothAddress;\n+import org.openhab.binding.bluetooth.BluetoothCharacteristic;\n+import org.openhab.binding.bluetooth.BluetoothCompletionStatus;\n+import org.openhab.binding.bluetooth.BluetoothDescriptor;\n+import org.openhab.binding.bluetooth.BluetoothService;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEventListener;\n+import org.openhab.binding.bluetooth.bluez.internal.events.CharacteristicUpdateEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ConnectedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ManufacturerDataEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.NameEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.RssiEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ServicesResolvedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.TXPowerEvent;\n+import org.openhab.binding.bluetooth.notification.BluetoothConnectionStatusNotification;\n+import org.openhab.binding.bluetooth.notification.BluetoothScanNotification;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.util.HexUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothDevice;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattCharacteristic;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattDescriptor;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattService;\n+\n+/**\n+ * Implementation of BluetoothDevice for BlueZ via DBus-BlueZ API\n+ *\n+ *\n+ * @author Benjamin Lafois - Initial contribution and API", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb659f9e334d1a8366b4b9623d2afb54ea3c24ba"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTU2NTA3Nw==", "bodyText": "Are these null annotations required?", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r509565077", "createdAt": "2020-10-21T18:39:03Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBridgeHandler.java", "diffHunk": "@@ -0,0 +1,261 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.List;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNull;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bluetooth.AbstractBluetoothBridgeHandler;\n+import org.openhab.binding.bluetooth.BluetoothAddress;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterDiscoveringChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterPoweredChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEventListener;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.github.hypfvieh.bluetooth.DeviceManager;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothAdapter;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothDevice;\n+\n+/**\n+ * The {@link BlueZBridgeHandler} is responsible for talking to the BlueZ stack, using DBus Unix Socket.\n+ * This Binding does not use any JNI.\n+ * It provides a private interface for {@link BlueZBluetoothDevice}s to access the stack and provides top\n+ * level adaptor functionality for scanning and arbitration.\n+ *\n+ * @author Benjamin Lafois - Initial contribution and API\n+ */\n+@NonNullByDefault\n+public class BlueZBridgeHandler extends AbstractBluetoothBridgeHandler<BlueZBluetoothDevice>\n+        implements BlueZEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(BlueZBridgeHandler.class);\n+\n+    // ADAPTER from BlueZ-DBus Library\n+    private @Nullable BluetoothAdapter adapter;\n+\n+    // Our BT address\n+    private @Nullable BluetoothAddress adapterAddress;\n+\n+    private @Nullable ScheduledFuture<?> discoveryJob;\n+\n+    private final DeviceManagerFactory deviceManagerFactory;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param bridge the bridge definition for this handler\n+     */\n+    public BlueZBridgeHandler(Bridge bridge, DeviceManagerFactory deviceManagerFactory) {\n+        super(bridge);\n+        this.deviceManagerFactory = deviceManagerFactory;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+\n+        // Load configuration\n+        final BlueZAdapterConfiguration configuration = getConfigAs(BlueZAdapterConfiguration.class);\n+        if (configuration.address != null) {\n+            this.adapterAddress = new BluetoothAddress(configuration.address.toUpperCase());\n+        } else {\n+            // If configuration does not contain adapter address to use, exit with error.\n+            logger.info(\"Adapter MAC address not provided\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"address not set\");\n+            return;\n+        }\n+\n+        logger.debug(\"Creating BlueZ adapter with address '{}'\", adapterAddress);\n+\n+        updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.CONFIGURATION_PENDING, \"Initializing\");\n+\n+        deviceManagerFactory.getPropertiesChangedHandler().addListener(this);\n+\n+        discoveryJob = scheduler.scheduleWithFixedDelay(this::initializeAndRefreshDevices, 5, 10, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        deviceManagerFactory.getPropertiesChangedHandler().removeListener(this);\n+        logger.debug(\"Termination of DBus BlueZ handler\");\n+\n+        Future<?> job = discoveryJob;\n+        if (job != null) {\n+            job.cancel(false);\n+            discoveryJob = null;\n+        }\n+\n+        if (this.adapter != null) {\n+            ((@NonNull BluetoothAdapter) this.adapter).stopDiscovery();\n+            this.adapter = null;\n+        }\n+\n+        super.dispose();\n+    }\n+\n+    private static @Nullable BluetoothAdapter findAdapter(DeviceManager deviceManager, String address) {\n+        List<BluetoothAdapter> adapters = deviceManager.getAdapters();\n+        if (adapters != null) {\n+            for (BluetoothAdapter btAdapter : adapters) {\n+                if (btAdapter.getAddress() != null && btAdapter.getAddress().equalsIgnoreCase(address)) {\n+                    return btAdapter;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private boolean validateAdapter(DeviceManager deviceManager) {\n+\n+        // next lets check if we can find our adapter in the manager.\n+        BluetoothAdapter localAdapter = adapter;\n+        if (localAdapter == null) {\n+            if (adapterAddress != null) {\n+                localAdapter = adapter = findAdapter(deviceManager,\n+                        ((@NonNull BluetoothAddress) adapterAddress).toString());\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No adapter address provided\");\n+                return false;\n+            }\n+        }\n+        if (localAdapter == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Native adapter could not be found for address '\" + adapterAddress + \"'\");\n+            return false;\n+        }\n+        // now lets confirm that the adapter is powered\n+        if (!localAdapter.isPowered()) {\n+            localAdapter.setPowered(true);\n+            // give the device some time to power on\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.DUTY_CYCLE,\n+                    \"Adapter is not powered, attempting to turn on...\");\n+            return false;\n+        }\n+\n+        // now lets make sure that discovery is turned on\n+        if (!Boolean.TRUE.equals(localAdapter.isDiscovering())) {\n+            // we will check for devices next time around\n+            localAdapter.startDiscovery();\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.DUTY_CYCLE, \"Starting discovery\");\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    private void initializeAndRefreshDevices() {\n+        logger.debug(\"initializeAndRefreshDevice()\");\n+\n+        try {\n+            // first check if the device manager is ready\n+            DeviceManager deviceManager = deviceManagerFactory.getDeviceManager();\n+            if (deviceManager == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Bluez DeviceManager not available yet.\");\n+                return;\n+            }\n+\n+            if (!validateAdapter(deviceManager)) {\n+                return;\n+            }\n+\n+            // as we have already validated the adapteraddress in {@link #validateAdapter(DeviceAdapter)}, we can safely\n+            // assume that adapterAddress is not null.\n+            @NonNull\n+            BluetoothAddress adapterAddress = (@NonNull BluetoothAddress) this.adapterAddress;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb659f9e334d1a8366b4b9623d2afb54ea3c24ba"}, "originalPosition": 184}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4b8887e0f99f78f8884b8e8850c6e5bdc68bb727", "author": {"user": null}, "url": "https://github.com/openhab/openhab-addons/commit/4b8887e0f99f78f8884b8e8850c6e5bdc68bb727", "committedDate": "2020-10-21T21:47:26Z", "message": "Fix osgi dependencies\n\nSigned-off-by: Connor Petty <mistercpp2000+gitsignoff@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f668e2a4c133e778d4035428f244d9cae5255feb", "author": {"user": null}, "url": "https://github.com/openhab/openhab-addons/commit/f668e2a4c133e778d4035428f244d9cae5255feb", "committedDate": "2020-10-21T23:17:19Z", "message": "Added DeviceManagerWrapper for threadsafety along with other PR cleanup\n\nSigned-off-by: Connor Petty <mistercpp2000+gitsignoff@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1770c18c8383541c88c342d9cd3d9f97fcd6cc54", "author": {"user": null}, "url": "https://github.com/openhab/openhab-addons/commit/1770c18c8383541c88c342d9cd3d9f97fcd6cc54", "committedDate": "2020-10-21T23:30:21Z", "message": "Improved performance of dbus path parsing\n\nSigned-off-by: Connor Petty <mistercpp2000+gitsignoff@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d88709cfa46c168fedbf6372fc405093b2090f93", "author": {"user": null}, "url": "https://github.com/openhab/openhab-addons/commit/d88709cfa46c168fedbf6372fc405093b2090f93", "committedDate": "2020-10-22T00:30:36Z", "message": "Change BlueZEvent to use visitor pattern\n\nSigned-off-by: Connor Petty <mistercpp2000+gitsignoff@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9003c1c04beb787e21e9106379105f5584e89f48", "author": {"user": null}, "url": "https://github.com/openhab/openhab-addons/commit/9003c1c04beb787e21e9106379105f5584e89f48", "committedDate": "2020-10-22T00:52:43Z", "message": "Fill in essential javadocs\n\nSigned-off-by: Connor Petty <mistercpp2000+gitsignoff@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ac05fedaa480569b6c45f79aae2d68d1a5b674d8", "author": {"user": null}, "url": "https://github.com/openhab/openhab-addons/commit/ac05fedaa480569b6c45f79aae2d68d1a5b674d8", "committedDate": "2020-10-22T01:01:05Z", "message": "Revert changes in daikin madoka\n\nSigned-off-by: Connor Petty <mistercpp2000+gitsignoff@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0MjkxMDQy", "url": "https://github.com/openhab/openhab-addons/pull/8819#pullrequestreview-514291042", "createdAt": "2020-10-22T01:02:46Z", "commit": {"oid": "ac05fedaa480569b6c45f79aae2d68d1a5b674d8"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "00d70430420d1037e3a206a0b1c83549f7d151b5", "author": {"user": null}, "url": "https://github.com/openhab/openhab-addons/commit/00d70430420d1037e3a206a0b1c83549f7d151b5", "committedDate": "2020-10-22T06:37:18Z", "message": "Reduce build warnings\n\nSigned-off-by: Connor Petty <mistercpp2000+gitsignoff@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE0NDMzMjYy", "url": "https://github.com/openhab/openhab-addons/pull/8819#pullrequestreview-514433262", "createdAt": "2020-10-22T07:29:35Z", "commit": {"oid": "00d70430420d1037e3a206a0b1c83549f7d151b5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwNzoyOTozNVrOHmULpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQwNzoyOTozNVrOHmULpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTkzODU5Ng==", "bodyText": "Is this used by any other bundle or available from a core-bom? Otherwise change scope to compile and remove it from the feature.", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r509938596", "createdAt": "2020-10-22T07:29:35Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/pom.xml", "diffHunk": "@@ -15,18 +15,21 @@\n   <name>openHAB Add-ons :: Bundles :: BlueZ Bluetooth Adapter</name>\n \n   <dependencies>\n+\n     <dependency>\n       <groupId>org.openhab.addons.bundles</groupId>\n       <artifactId>org.openhab.binding.bluetooth</artifactId>\n       <version>${project.version}</version>\n       <scope>provided</scope>\n     </dependency>\n+\n     <dependency>\n-      <groupId>org.openhab.osgiify</groupId>\n-      <artifactId>intel-iot-devkit.tinyb</artifactId>\n-      <version>0.5.1</version>\n-      <scope>compile</scope>\n+      <groupId>com.github.hypfvieh</groupId>\n+      <artifactId>bluez-dbus-osgi</artifactId>\n+      <version>0.1.3</version>\n+      <scope>provided</scope>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00d70430420d1037e3a206a0b1c83549f7d151b5"}, "originalPosition": 20}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1MDI3NzI1", "url": "https://github.com/openhab/openhab-addons/pull/8819#pullrequestreview-515027725", "createdAt": "2020-10-22T18:56:07Z", "commit": {"oid": "00d70430420d1037e3a206a0b1c83549f7d151b5"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxODo1NjowN1rOHmvjCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxOTowMzoyOFrOHmvzhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM4Njk1Mw==", "bodyText": "Looking at this code I have an impression that it could be simplified with basic:\nif (deviceManager != null) deviceManager.closeConnection();\ndeviceManager = null\n\nIs there a concurrency issue that forces you to assign field to local variable?", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r510386953", "createdAt": "2020-10-22T18:56:07Z", "author": {"login": "splatch"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/DeviceManagerFactory.java", "diffHunk": "@@ -0,0 +1,174 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.freedesktop.dbus.exceptions.DBusException;\n+import org.openhab.core.common.NamedThreadFactory;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Deactivate;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.github.hypfvieh.bluetooth.DeviceManager;\n+\n+/**\n+ * This service handles the lifecycle of the {@link DeviceManager} singleton instance.\n+ * In addition, this class is responsible for managing the BlueZPropertiesChangedHandler instance\n+ * used by the binding for listening and dispatching dbus events from the DeviceManager.\n+ *\n+ * Creation of the DeviceManager is asynchronous and thus attempts to retrieve the DeviceManager\n+ * through 'getDeviceManager' may initially fail.\n+ *\n+ * @author Connor Petty - Initial Contribution\n+ *\n+ */\n+@NonNullByDefault\n+@Component(service = DeviceManagerFactory.class)\n+public class DeviceManagerFactory {\n+\n+    private final Logger logger = LoggerFactory.getLogger(DeviceManagerFactory.class);\n+    private final BlueZPropertiesChangedHandler changeHandler = new BlueZPropertiesChangedHandler();\n+\n+    private @Nullable ScheduledExecutorService scheduler;\n+    private @Nullable DeviceManager deviceManager;\n+    private @Nullable CompletableFuture<DeviceManagerWrapper> deviceManagerFuture;\n+\n+    public BlueZPropertiesChangedHandler getPropertiesChangedHandler() {\n+        return changeHandler;\n+    }\n+\n+    public @Nullable DeviceManagerWrapper getDeviceManager() {\n+        // we can cheat the null checker with casting here\n+        var future = (CompletableFuture<@Nullable DeviceManagerWrapper>) this.deviceManagerFuture;\n+        if (future != null) {\n+            return future.getNow(null);\n+        }\n+        return null;\n+    }\n+\n+    @Activate\n+    public void initialize() {\n+        logger.debug(\"initializing DeviceManagerFactory\");\n+        ScheduledThreadPoolExecutor scheduler = new ScheduledThreadPoolExecutor(1,\n+                new NamedThreadFactory(\"bluetooth.bluez-init\", true));\n+\n+        scheduler.setExecuteExistingDelayedTasksAfterShutdownPolicy(false);\n+        scheduler.setRemoveOnCancelPolicy(true);\n+\n+        this.scheduler = scheduler;\n+\n+        this.deviceManagerFuture = callAsync(() -> {\n+            try {\n+                // if this is the first call to the library, this call\n+                // should throw an exception (that we are catching)\n+                return DeviceManager.getInstance();\n+                // Experimental - seems reuse does not work\n+            } catch (IllegalStateException e) {\n+                // Exception caused by first call to the library\n+                return DeviceManager.createInstance(false);\n+            }\n+        }, scheduler)//\n+                .thenApply(devManager -> {\n+                    this.deviceManager = devManager;\n+                    return devManager;\n+                }).thenCompose(devManager -> registerPropertyHandler(devManager, scheduler))//\n+                .thenApply(DeviceManagerWrapper::new)//\n+                .whenComplete((devManager, th) -> {\n+                    if (th != null) {\n+                        logger.warn(\"Failed to initialize DeviceManager: {}\", th.getMessage());\n+                    }\n+                });\n+    }\n+\n+    @Deactivate\n+    public void dispose() {\n+        DeviceManager manager = deviceManager;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00d70430420d1037e3a206a0b1c83549f7d151b5"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM4Nzk0Nw==", "bodyText": "I believe that making key.toLowerCase() might be more reliable in case of future updates in bluez and eventual changes in property names.", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r510387947", "createdAt": "2020-10-22T18:57:54Z", "author": {"login": "splatch"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZPropertiesChangedHandler.java", "diffHunk": "@@ -0,0 +1,212 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArraySet;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.freedesktop.dbus.DBusMap;\n+import org.freedesktop.dbus.handlers.AbstractPropertiesChangedHandler;\n+import org.freedesktop.dbus.interfaces.Properties.PropertiesChanged;\n+import org.freedesktop.dbus.types.UInt16;\n+import org.freedesktop.dbus.types.Variant;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterDiscoveringChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterPoweredChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEventListener;\n+import org.openhab.binding.bluetooth.bluez.internal.events.CharacteristicUpdateEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ConnectedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ManufacturerDataEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.NameEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.RssiEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ServicesResolvedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.TXPowerEvent;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This is the PropertiesChangedHandler subclass used by the binding to handle/dispatch property change events\n+ * from bluez.\n+ *\n+ * @author Benjamin Lafois - Initial contribution and API\n+ * @author Connor Petty - Code cleanup\n+ */\n+@NonNullByDefault\n+public class BlueZPropertiesChangedHandler extends AbstractPropertiesChangedHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(BlueZPropertiesChangedHandler.class);\n+\n+    private final Set<BlueZEventListener> listeners = new CopyOnWriteArraySet<>();\n+\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager.getScheduledPool(\"bluetooth\");\n+\n+    public void addListener(BlueZEventListener listener) {\n+        this.listeners.add(listener);\n+    }\n+\n+    public void removeListener(BlueZEventListener listener) {\n+        this.listeners.remove(listener);\n+    }\n+\n+    private void notifyListeners(BlueZEvent event) {\n+        for (BlueZEventListener listener : this.listeners) {\n+            event.dispatch(listener);\n+        }\n+    }\n+\n+    @Override\n+    public void handle(@Nullable PropertiesChanged properties) {\n+        if (properties == null || properties.getPropertiesChanged() == null) {\n+            logger.debug(\"Null properties. Skipping.\");\n+            return;\n+        }\n+        Map<@Nullable String, @Nullable Variant<?>> changedProperties = properties.getPropertiesChanged();\n+        if (changedProperties == null) {\n+            logger.debug(\"Null properties changed. Skipping.\");\n+            return;\n+        }\n+\n+        // do this asynchronously so that we don't slow things down for the dbus event dispatcher\n+        scheduler.execute(() -> {\n+\n+            String dbusPath = properties.getPath();\n+            changedProperties.forEach((key, variant) -> {\n+                if (key == null || variant == null) {\n+                    return;\n+                }\n+                switch (key) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00d70430420d1037e3a206a0b1c83549f7d151b5"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM5MTE3Mw==", "bodyText": "I have dbus-java working under OSGi with no troubles using following feature:\n  <feature name=\"dbus\" description=\"DBus transport\" version=\"${project.version}\">\n    <feature prerequisite=\"true\">wrap</feature>\n    <bundle>mvn:com.github.jnr/jnr-unixsocket/0.33</bundle>\n    <bundle>mvn:com.github.jnr/jnr-constants/0.9.15</bundle>\n    <bundle>mvn:com.github.jnr/jnr-enxio/0.28</bundle>\n    <bundle>mvn:com.github.jnr/jnr-ffi/2.1.15</bundle>\n    <bundle>mvn:com.github.jnr/jnr-posix/3.0.58</bundle>\n    <bundle>wrap:mvn:com.github.jnr/jnr-a64asm/1.0.0</bundle>\n    <bundle>wrap:mvn:com.github.jnr/jnr-x86asm/1.0.2</bundle>\n    <bundle>mvn:com.github.jnr/jffi/1.2.23/jar/complete</bundle>\n    <bundle>wrap:mvn:com.github.jnr/jffi/1.2.23/jar/native</bundle>\n    <bundle>wrap:mvn:com.github.hypfvieh/dbus-java/3.2.3</bundle>\n    <bundle>wrap:mvn:com.github.hypfvieh/java-utils/1.0.6</bundle>\n  </feature>\n\nI discourage you from using bluez-dbus-osgi cause this packaging is really a fat jar which doesn't even make use of Bundle-NativeCode header. It doesn't have to, but it packs up all the jnr stuff making it pretty hard to run this with for example NetworkManager or ModemManager. Both use dbus as possible communication mechanism and give access to different parts related to network interfaces.\nTo try out with dbus stuff try adding this:\n<bundle>wrap:mvn:com.github.hypfvieh/bluez-dbus/0.1.3</bundle>", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r510391173", "createdAt": "2020-10-22T19:03:28Z", "author": {"login": "splatch"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/feature/feature.xml", "diffHunk": "@@ -4,7 +4,8 @@\n \n \t<feature name=\"openhab-binding-bluetooth-bluez\" description=\"Bluetooth Binding Bluez\" version=\"${project.version}\">\n \t\t<feature>openhab-runtime-base</feature>\n-\t\t<feature>openhab-transport-serial</feature>\n+\n+\t\t<bundle dependency=\"true\">mvn:com.github.hypfvieh/bluez-dbus-osgi/0.1.3</bundle>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00d70430420d1037e3a206a0b1c83549f7d151b5"}, "originalPosition": 6}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "322c500d36ee0ca9e3c19258023ab6f6371adeab", "author": {"user": null}, "url": "https://github.com/openhab/openhab-addons/commit/322c500d36ee0ca9e3c19258023ab6f6371adeab", "committedDate": "2020-10-22T22:13:38Z", "message": "Address review comments and improve threadsafety\n\nSigned-off-by: Connor Petty <mistercpp2000+gitsignoff@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4fede3bb2adf35fdf1b55c8a46e79712a553d812", "author": {"user": null}, "url": "https://github.com/openhab/openhab-addons/commit/4fede3bb2adf35fdf1b55c8a46e79712a553d812", "committedDate": "2020-10-23T04:27:16Z", "message": "minor code cleanup\n\nSigned-off-by: Connor Petty <mistercpp2000+gitsignoff@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9c2c484c0a68abcdb7f6e511a0635e2dd9353821", "author": {"user": null}, "url": "https://github.com/openhab/openhab-addons/commit/9c2c484c0a68abcdb7f6e511a0635e2dd9353821", "committedDate": "2020-10-23T04:46:07Z", "message": "Fix javadocs\n\nSigned-off-by: Connor Petty <mistercpp2000+gitsignoff@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2MDI0OTQ2", "url": "https://github.com/openhab/openhab-addons/pull/8819#pullrequestreview-516024946", "createdAt": "2020-10-23T21:39:06Z", "commit": {"oid": "9c2c484c0a68abcdb7f6e511a0635e2dd9353821"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QyMTozOTowNlrOHnfJxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QyMTo1NToxMFrOHnffVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE2NjkxNg==", "bodyText": "This should be removed, since we define that bundle to be part of the feature. So when it is correctly installed, the bundle will be there, no question.", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r511166916", "createdAt": "2020-10-23T21:39:06Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/README.md", "diffHunk": "@@ -61,3 +62,10 @@ This is how an BlueZ adapter can be configured textually in a *.things file:\n ```\n Bridge bluetooth:bluez:hci0 [ address=\"12:34:56:78:90:AB\", backgroundDiscovery=false ]\n ```\n+\n+##Troubleshooting", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c2c484c0a68abcdb7f6e511a0635e2dd9353821"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE2NzU5Mw==", "bodyText": "No idea, really. Maybe @J-N-K?", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r511167593", "createdAt": "2020-10-23T21:40:51Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/pom.xml", "diffHunk": "@@ -15,18 +15,21 @@\n   <name>openHAB Add-ons :: Bundles :: BlueZ Bluetooth Adapter</name>\n \n   <dependencies>\n+\n     <dependency>\n       <groupId>org.openhab.addons.bundles</groupId>\n       <artifactId>org.openhab.binding.bluetooth</artifactId>\n       <version>${project.version}</version>\n       <scope>provided</scope>\n     </dependency>\n+\n     <dependency>\n-      <groupId>org.openhab.osgiify</groupId>\n-      <artifactId>intel-iot-devkit.tinyb</artifactId>\n-      <version>0.5.1</version>\n-      <scope>compile</scope>\n+      <groupId>com.github.hypfvieh</groupId>\n+      <artifactId>bluez-dbus-osgi</artifactId>\n+      <version>0.1.3</version>\n+      <scope>provided</scope>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTkzODU5Ng=="}, "originalCommit": {"oid": "00d70430420d1037e3a206a0b1c83549f7d151b5"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE2ODU3MQ==", "bodyText": "What is this info telling to the user? Either he can ignore it, then debug should suffice or it is a problem in the configuration/device, then it should rather be a warning with more details.", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r511168571", "createdAt": "2020-10-23T21:43:44Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBluetoothDevice.java", "diffHunk": "@@ -0,0 +1,474 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.bluez.exceptions.BluezFailedException;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.freedesktop.dbus.errors.NoReply;\n+import org.freedesktop.dbus.exceptions.DBusException;\n+import org.freedesktop.dbus.exceptions.DBusExecutionException;\n+import org.freedesktop.dbus.types.UInt16;\n+import org.openhab.binding.bluetooth.BaseBluetoothDevice;\n+import org.openhab.binding.bluetooth.BluetoothAddress;\n+import org.openhab.binding.bluetooth.BluetoothCharacteristic;\n+import org.openhab.binding.bluetooth.BluetoothCompletionStatus;\n+import org.openhab.binding.bluetooth.BluetoothDescriptor;\n+import org.openhab.binding.bluetooth.BluetoothService;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEventListener;\n+import org.openhab.binding.bluetooth.bluez.internal.events.CharacteristicUpdateEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ConnectedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ManufacturerDataEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.NameEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.RssiEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ServicesResolvedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.TXPowerEvent;\n+import org.openhab.binding.bluetooth.notification.BluetoothConnectionStatusNotification;\n+import org.openhab.binding.bluetooth.notification.BluetoothScanNotification;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.util.HexUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothDevice;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattCharacteristic;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattDescriptor;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattService;\n+\n+/**\n+ * Implementation of BluetoothDevice for BlueZ via DBus-BlueZ API\n+ *\n+ * @author Kai Kreuzer - Initial contribution and API\n+ * @author Benjamin Lafois - Replaced tinyB with bluezDbus\n+ *\n+ */\n+@NonNullByDefault\n+public class BlueZBluetoothDevice extends BaseBluetoothDevice implements BlueZEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(BlueZBluetoothDevice.class);\n+\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager.getScheduledPool(\"bluetooth\");\n+\n+    // Device from native lib\n+    private @Nullable BluetoothDevice device = null;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param adapter the bridge handler through which this device is connected\n+     * @param address the Bluetooth address of the device\n+     * @param name the name of the device\n+     */\n+    public BlueZBluetoothDevice(BlueZBridgeHandler adapter, BluetoothAddress address) {\n+        super(adapter, address);\n+        logger.debug(\"Creating DBusBlueZ device with address '{}'\", address);\n+    }\n+\n+    public synchronized void updateBlueZDevice(@Nullable BluetoothDevice blueZDevice) {\n+        if (this.device != null && this.device == blueZDevice) {\n+            return;\n+        }\n+        logger.debug(\"updateBlueZDevice({})\", blueZDevice);\n+\n+        this.device = blueZDevice;\n+\n+        if (blueZDevice == null) {\n+            return;\n+        }\n+\n+        Short rssi = blueZDevice.getRssi();\n+        if (rssi != null) {\n+            this.rssi = rssi.intValue();\n+        }\n+        this.name = blueZDevice.getName();\n+        Map<UInt16, byte[]> manData = blueZDevice.getManufacturerData();\n+        if (manData != null) {\n+            manData.entrySet().stream().map(Map.Entry::getKey).filter(Objects::nonNull).findFirst()\n+                    .ifPresent((UInt16 manufacturerId) ->\n+                    // Convert to unsigned int to match the convention in BluetoothCompanyIdentifiers\n+                    this.manufacturer = manufacturerId.intValue() & 0xFFFF);\n+        }\n+\n+        if (Boolean.TRUE.equals(blueZDevice.isConnected())) {\n+            setConnectionState(ConnectionState.CONNECTED);\n+        }\n+\n+        discoverServices();\n+    }\n+\n+    /**\n+     * Clean up and release memory.\n+     */\n+    @Override\n+    public void dispose() {\n+        BluetoothDevice dev = device;\n+        if (dev != null) {\n+            try {\n+                dev.getAdapter().removeDevice(dev.getRawDevice());\n+            } catch (DBusException ex) {\n+                if (ex.getMessage().contains(\"Does Not Exist\")) {\n+                    // this happens when the underlying device has already been removed\n+                    // but we don't have a way to check if that is the case beforehand so\n+                    // we will just eat the error here.\n+                } else {\n+                    logger.debug(\"Exception occurred when trying to remove inactive device '{}': {}\", address,\n+                            ex.getMessage());\n+                }\n+            } catch (RuntimeException ex) {\n+                // try to catch any other exceptions\n+                logger.debug(\"Exception occurred when trying to remove inactive device '{}': {}\", address,\n+                        ex.getMessage());\n+            }\n+        }\n+    }\n+\n+    private void setConnectionState(ConnectionState state) {\n+        if (this.connectionState != state) {\n+            this.connectionState = state;\n+            notifyListeners(BluetoothEventType.CONNECTION_STATE, new BluetoothConnectionStatusNotification(state));\n+        }\n+    }\n+\n+    @Override\n+    public boolean connect() {\n+        logger.debug(\"Connect({})\", device);\n+\n+        BluetoothDevice dev = device;\n+        if (dev != null) {\n+            if (Boolean.FALSE.equals(dev.isConnected())) {\n+                try {\n+                    boolean ret = dev.connect();\n+                    logger.debug(\"Connect result: {}\", ret);\n+                    return ret;\n+                } catch (NoReply e) {\n+                    // Have to double check because sometimes, exception but still worked\n+                    logger.debug(\"Got a timeout - but sometimes happen. Is Connected ? {}\", dev.isConnected());\n+                    if (Boolean.FALSE.equals(dev.isConnected())) {\n+\n+                        notifyListeners(BluetoothEventType.CONNECTION_STATE,\n+                                new BluetoothConnectionStatusNotification(ConnectionState.DISCONNECTED));\n+                        return false;\n+                    } else {\n+                        return true;\n+                    }\n+                } catch (DBusExecutionException e) {\n+                    // Catch \"software caused connection abort\"\n+                    return false;\n+                } catch (Exception e) {\n+                    logger.warn(\"error occured while trying to connect\", e);\n+                }\n+\n+            } else {\n+                logger.debug(\"Device was already connected\");\n+                // we might be stuck in another state atm so we need to trigger a connected in this case\n+                setConnectionState(ConnectionState.CONNECTED);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean disconnect() {\n+        BluetoothDevice dev = device;\n+        if (dev != null) {\n+            logger.debug(\"Disconnecting '{}'\", address);\n+            return dev.disconnect();\n+        }\n+        return false;\n+    }\n+\n+    private void ensureConnected() {\n+        BluetoothDevice dev = device;\n+        if (dev == null || !dev.isConnected()) {\n+            throw new IllegalStateException(\"DBusBlueZ device is not set or not connected\");\n+        }\n+    }\n+\n+    private @Nullable BluetoothGattCharacteristic getDBusBlueZCharacteristicByUUID(String uuid) {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return null;\n+        }\n+        for (BluetoothGattService service : dev.getGattServices()) {\n+            for (BluetoothGattCharacteristic c : service.getGattCharacteristics()) {\n+                if (c.getUuid().equalsIgnoreCase(uuid)) {\n+                    return c;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private @Nullable BluetoothGattCharacteristic getDBusBlueZCharacteristicByDBusPath(String dBusPath) {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return null;\n+        }\n+        for (BluetoothGattService service : dev.getGattServices()) {\n+            if (dBusPath.startsWith(service.getDbusPath())) {\n+                for (BluetoothGattCharacteristic characteristic : service.getGattCharacteristics()) {\n+                    if (dBusPath.startsWith(characteristic.getDbusPath())) {\n+                        return characteristic;\n+                    }\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private @Nullable BluetoothGattDescriptor getDBusBlueZDescriptorByUUID(String uuid) {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return null;\n+        }\n+        for (BluetoothGattService service : dev.getGattServices()) {\n+            for (BluetoothGattCharacteristic c : service.getGattCharacteristics()) {\n+                for (BluetoothGattDescriptor d : c.getGattDescriptors()) {\n+                    if (d.getUuid().equalsIgnoreCase(uuid)) {\n+                        return d;\n+                    }\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public boolean enableNotifications(BluetoothCharacteristic characteristic) {\n+        ensureConnected();\n+\n+        BluetoothGattCharacteristic c = getDBusBlueZCharacteristicByUUID(characteristic.getUuid().toString());\n+        if (c != null) {\n+\n+            try {\n+                c.startNotify();\n+            } catch (DBusException e) {\n+                if (e.getMessage().contains(\"Already notifying\")) {\n+                    return false;\n+                } else if (e.getMessage().contains(\"In Progress\")) {\n+                    // let's retry in 10 seconds\n+                    scheduler.schedule(() -> enableNotifications(characteristic), 10, TimeUnit.SECONDS);\n+                } else {\n+                    logger.warn(\"Exception occurred while activating notifications on '{}'\", address, e);\n+                }\n+            }\n+            return true;\n+        } else {\n+            logger.warn(\"Characteristic '{}' is missing on device '{}'.\", characteristic.getUuid(), address);\n+            return false;\n+        }\n+    }\n+\n+    @Override\n+    public boolean writeCharacteristic(BluetoothCharacteristic characteristic) {\n+        logger.debug(\"writeCharacteristic()\");\n+\n+        ensureConnected();\n+\n+        BluetoothGattCharacteristic c = getDBusBlueZCharacteristicByUUID(characteristic.getUuid().toString());\n+        if (c == null) {\n+            logger.warn(\"Characteristic '{}' is missing on device '{}'.\", characteristic.getUuid(), address);\n+            return false;\n+        }\n+\n+        scheduler.submit(() -> {\n+            try {\n+                c.writeValue(characteristic.getByteValue(), null);\n+                notifyListeners(BluetoothEventType.CHARACTERISTIC_WRITE_COMPLETE, characteristic,\n+                        BluetoothCompletionStatus.SUCCESS);\n+\n+            } catch (DBusException e) {\n+                logger.debug(\"Exception occurred when trying to write characteristic '{}': {}\",\n+                        characteristic.getUuid(), e.getMessage());\n+                notifyListeners(BluetoothEventType.CHARACTERISTIC_WRITE_COMPLETE, characteristic,\n+                        BluetoothCompletionStatus.ERROR);\n+            }\n+        });\n+        return true;\n+    }\n+\n+    @Override\n+    public void onDBusBlueZEvent(BlueZEvent event) {\n+        logger.debug(\"Unsupported event: {}\", event);\n+    }\n+\n+    @Override\n+    public void onServicesResolved(ServicesResolvedEvent event) {\n+        if (event.isResolved()) {\n+            notifyListeners(BluetoothEventType.SERVICES_DISCOVERED);\n+        }\n+    }\n+\n+    @Override\n+    public void onNameUpdate(NameEvent event) {\n+        BluetoothScanNotification notification = new BluetoothScanNotification();\n+        notification.setDeviceName(event.getName());\n+        notifyListeners(BluetoothEventType.SCAN_RECORD, notification);\n+    }\n+\n+    @Override\n+    public void onManufacturerDataUpdate(ManufacturerDataEvent event) {\n+        for (Map.Entry<Short, byte[]> entry : event.getData().entrySet()) {\n+            BluetoothScanNotification notification = new BluetoothScanNotification();\n+            byte[] data = new byte[entry.getValue().length + 2];\n+            data[0] = (byte) (entry.getKey() & 0xFF);\n+            data[1] = (byte) (entry.getKey() >>> 8);\n+\n+            System.arraycopy(entry.getValue(), 0, data, 2, entry.getValue().length);\n+\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"Received manufacturer data for '{}': {}\", address, HexUtils.bytesToHex(data, \" \"));\n+            }\n+\n+            notification.setManufacturerData(data);\n+            notifyListeners(BluetoothEventType.SCAN_RECORD, notification);\n+        }\n+    }\n+\n+    @Override\n+    public void onTxPowerUpdate(TXPowerEvent event) {\n+        this.txPower = (int) event.getTxPower();\n+    }\n+\n+    @Override\n+    public void onCharacteristicNotify(CharacteristicUpdateEvent event) {\n+        // Here it is a bit special - as the event is linked to the DBUS path, not characteristic UUID.\n+        // So we need to find the characteristic by its DBUS path.\n+        BluetoothGattCharacteristic characteristic = getDBusBlueZCharacteristicByDBusPath(event.getDbusPath());\n+        if (characteristic == null) {\n+            logger.info(\"Received a notification for a characteristic not found on device.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c2c484c0a68abcdb7f6e511a0635e2dd9353821"}, "originalPosition": 357}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE2ODg5Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        logger.debug(\"Has notified that a characteristic has been updated\");\n          \n          \n            \n                        logger.debug(\"Notified that a characteristic has been updated\");", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r511168897", "createdAt": "2020-10-23T21:44:38Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBluetoothDevice.java", "diffHunk": "@@ -0,0 +1,474 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.bluez.exceptions.BluezFailedException;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.freedesktop.dbus.errors.NoReply;\n+import org.freedesktop.dbus.exceptions.DBusException;\n+import org.freedesktop.dbus.exceptions.DBusExecutionException;\n+import org.freedesktop.dbus.types.UInt16;\n+import org.openhab.binding.bluetooth.BaseBluetoothDevice;\n+import org.openhab.binding.bluetooth.BluetoothAddress;\n+import org.openhab.binding.bluetooth.BluetoothCharacteristic;\n+import org.openhab.binding.bluetooth.BluetoothCompletionStatus;\n+import org.openhab.binding.bluetooth.BluetoothDescriptor;\n+import org.openhab.binding.bluetooth.BluetoothService;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEventListener;\n+import org.openhab.binding.bluetooth.bluez.internal.events.CharacteristicUpdateEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ConnectedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ManufacturerDataEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.NameEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.RssiEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ServicesResolvedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.TXPowerEvent;\n+import org.openhab.binding.bluetooth.notification.BluetoothConnectionStatusNotification;\n+import org.openhab.binding.bluetooth.notification.BluetoothScanNotification;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.util.HexUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothDevice;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattCharacteristic;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattDescriptor;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattService;\n+\n+/**\n+ * Implementation of BluetoothDevice for BlueZ via DBus-BlueZ API\n+ *\n+ * @author Kai Kreuzer - Initial contribution and API\n+ * @author Benjamin Lafois - Replaced tinyB with bluezDbus\n+ *\n+ */\n+@NonNullByDefault\n+public class BlueZBluetoothDevice extends BaseBluetoothDevice implements BlueZEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(BlueZBluetoothDevice.class);\n+\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager.getScheduledPool(\"bluetooth\");\n+\n+    // Device from native lib\n+    private @Nullable BluetoothDevice device = null;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param adapter the bridge handler through which this device is connected\n+     * @param address the Bluetooth address of the device\n+     * @param name the name of the device\n+     */\n+    public BlueZBluetoothDevice(BlueZBridgeHandler adapter, BluetoothAddress address) {\n+        super(adapter, address);\n+        logger.debug(\"Creating DBusBlueZ device with address '{}'\", address);\n+    }\n+\n+    public synchronized void updateBlueZDevice(@Nullable BluetoothDevice blueZDevice) {\n+        if (this.device != null && this.device == blueZDevice) {\n+            return;\n+        }\n+        logger.debug(\"updateBlueZDevice({})\", blueZDevice);\n+\n+        this.device = blueZDevice;\n+\n+        if (blueZDevice == null) {\n+            return;\n+        }\n+\n+        Short rssi = blueZDevice.getRssi();\n+        if (rssi != null) {\n+            this.rssi = rssi.intValue();\n+        }\n+        this.name = blueZDevice.getName();\n+        Map<UInt16, byte[]> manData = blueZDevice.getManufacturerData();\n+        if (manData != null) {\n+            manData.entrySet().stream().map(Map.Entry::getKey).filter(Objects::nonNull).findFirst()\n+                    .ifPresent((UInt16 manufacturerId) ->\n+                    // Convert to unsigned int to match the convention in BluetoothCompanyIdentifiers\n+                    this.manufacturer = manufacturerId.intValue() & 0xFFFF);\n+        }\n+\n+        if (Boolean.TRUE.equals(blueZDevice.isConnected())) {\n+            setConnectionState(ConnectionState.CONNECTED);\n+        }\n+\n+        discoverServices();\n+    }\n+\n+    /**\n+     * Clean up and release memory.\n+     */\n+    @Override\n+    public void dispose() {\n+        BluetoothDevice dev = device;\n+        if (dev != null) {\n+            try {\n+                dev.getAdapter().removeDevice(dev.getRawDevice());\n+            } catch (DBusException ex) {\n+                if (ex.getMessage().contains(\"Does Not Exist\")) {\n+                    // this happens when the underlying device has already been removed\n+                    // but we don't have a way to check if that is the case beforehand so\n+                    // we will just eat the error here.\n+                } else {\n+                    logger.debug(\"Exception occurred when trying to remove inactive device '{}': {}\", address,\n+                            ex.getMessage());\n+                }\n+            } catch (RuntimeException ex) {\n+                // try to catch any other exceptions\n+                logger.debug(\"Exception occurred when trying to remove inactive device '{}': {}\", address,\n+                        ex.getMessage());\n+            }\n+        }\n+    }\n+\n+    private void setConnectionState(ConnectionState state) {\n+        if (this.connectionState != state) {\n+            this.connectionState = state;\n+            notifyListeners(BluetoothEventType.CONNECTION_STATE, new BluetoothConnectionStatusNotification(state));\n+        }\n+    }\n+\n+    @Override\n+    public boolean connect() {\n+        logger.debug(\"Connect({})\", device);\n+\n+        BluetoothDevice dev = device;\n+        if (dev != null) {\n+            if (Boolean.FALSE.equals(dev.isConnected())) {\n+                try {\n+                    boolean ret = dev.connect();\n+                    logger.debug(\"Connect result: {}\", ret);\n+                    return ret;\n+                } catch (NoReply e) {\n+                    // Have to double check because sometimes, exception but still worked\n+                    logger.debug(\"Got a timeout - but sometimes happen. Is Connected ? {}\", dev.isConnected());\n+                    if (Boolean.FALSE.equals(dev.isConnected())) {\n+\n+                        notifyListeners(BluetoothEventType.CONNECTION_STATE,\n+                                new BluetoothConnectionStatusNotification(ConnectionState.DISCONNECTED));\n+                        return false;\n+                    } else {\n+                        return true;\n+                    }\n+                } catch (DBusExecutionException e) {\n+                    // Catch \"software caused connection abort\"\n+                    return false;\n+                } catch (Exception e) {\n+                    logger.warn(\"error occured while trying to connect\", e);\n+                }\n+\n+            } else {\n+                logger.debug(\"Device was already connected\");\n+                // we might be stuck in another state atm so we need to trigger a connected in this case\n+                setConnectionState(ConnectionState.CONNECTED);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean disconnect() {\n+        BluetoothDevice dev = device;\n+        if (dev != null) {\n+            logger.debug(\"Disconnecting '{}'\", address);\n+            return dev.disconnect();\n+        }\n+        return false;\n+    }\n+\n+    private void ensureConnected() {\n+        BluetoothDevice dev = device;\n+        if (dev == null || !dev.isConnected()) {\n+            throw new IllegalStateException(\"DBusBlueZ device is not set or not connected\");\n+        }\n+    }\n+\n+    private @Nullable BluetoothGattCharacteristic getDBusBlueZCharacteristicByUUID(String uuid) {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return null;\n+        }\n+        for (BluetoothGattService service : dev.getGattServices()) {\n+            for (BluetoothGattCharacteristic c : service.getGattCharacteristics()) {\n+                if (c.getUuid().equalsIgnoreCase(uuid)) {\n+                    return c;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private @Nullable BluetoothGattCharacteristic getDBusBlueZCharacteristicByDBusPath(String dBusPath) {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return null;\n+        }\n+        for (BluetoothGattService service : dev.getGattServices()) {\n+            if (dBusPath.startsWith(service.getDbusPath())) {\n+                for (BluetoothGattCharacteristic characteristic : service.getGattCharacteristics()) {\n+                    if (dBusPath.startsWith(characteristic.getDbusPath())) {\n+                        return characteristic;\n+                    }\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private @Nullable BluetoothGattDescriptor getDBusBlueZDescriptorByUUID(String uuid) {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return null;\n+        }\n+        for (BluetoothGattService service : dev.getGattServices()) {\n+            for (BluetoothGattCharacteristic c : service.getGattCharacteristics()) {\n+                for (BluetoothGattDescriptor d : c.getGattDescriptors()) {\n+                    if (d.getUuid().equalsIgnoreCase(uuid)) {\n+                        return d;\n+                    }\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public boolean enableNotifications(BluetoothCharacteristic characteristic) {\n+        ensureConnected();\n+\n+        BluetoothGattCharacteristic c = getDBusBlueZCharacteristicByUUID(characteristic.getUuid().toString());\n+        if (c != null) {\n+\n+            try {\n+                c.startNotify();\n+            } catch (DBusException e) {\n+                if (e.getMessage().contains(\"Already notifying\")) {\n+                    return false;\n+                } else if (e.getMessage().contains(\"In Progress\")) {\n+                    // let's retry in 10 seconds\n+                    scheduler.schedule(() -> enableNotifications(characteristic), 10, TimeUnit.SECONDS);\n+                } else {\n+                    logger.warn(\"Exception occurred while activating notifications on '{}'\", address, e);\n+                }\n+            }\n+            return true;\n+        } else {\n+            logger.warn(\"Characteristic '{}' is missing on device '{}'.\", characteristic.getUuid(), address);\n+            return false;\n+        }\n+    }\n+\n+    @Override\n+    public boolean writeCharacteristic(BluetoothCharacteristic characteristic) {\n+        logger.debug(\"writeCharacteristic()\");\n+\n+        ensureConnected();\n+\n+        BluetoothGattCharacteristic c = getDBusBlueZCharacteristicByUUID(characteristic.getUuid().toString());\n+        if (c == null) {\n+            logger.warn(\"Characteristic '{}' is missing on device '{}'.\", characteristic.getUuid(), address);\n+            return false;\n+        }\n+\n+        scheduler.submit(() -> {\n+            try {\n+                c.writeValue(characteristic.getByteValue(), null);\n+                notifyListeners(BluetoothEventType.CHARACTERISTIC_WRITE_COMPLETE, characteristic,\n+                        BluetoothCompletionStatus.SUCCESS);\n+\n+            } catch (DBusException e) {\n+                logger.debug(\"Exception occurred when trying to write characteristic '{}': {}\",\n+                        characteristic.getUuid(), e.getMessage());\n+                notifyListeners(BluetoothEventType.CHARACTERISTIC_WRITE_COMPLETE, characteristic,\n+                        BluetoothCompletionStatus.ERROR);\n+            }\n+        });\n+        return true;\n+    }\n+\n+    @Override\n+    public void onDBusBlueZEvent(BlueZEvent event) {\n+        logger.debug(\"Unsupported event: {}\", event);\n+    }\n+\n+    @Override\n+    public void onServicesResolved(ServicesResolvedEvent event) {\n+        if (event.isResolved()) {\n+            notifyListeners(BluetoothEventType.SERVICES_DISCOVERED);\n+        }\n+    }\n+\n+    @Override\n+    public void onNameUpdate(NameEvent event) {\n+        BluetoothScanNotification notification = new BluetoothScanNotification();\n+        notification.setDeviceName(event.getName());\n+        notifyListeners(BluetoothEventType.SCAN_RECORD, notification);\n+    }\n+\n+    @Override\n+    public void onManufacturerDataUpdate(ManufacturerDataEvent event) {\n+        for (Map.Entry<Short, byte[]> entry : event.getData().entrySet()) {\n+            BluetoothScanNotification notification = new BluetoothScanNotification();\n+            byte[] data = new byte[entry.getValue().length + 2];\n+            data[0] = (byte) (entry.getKey() & 0xFF);\n+            data[1] = (byte) (entry.getKey() >>> 8);\n+\n+            System.arraycopy(entry.getValue(), 0, data, 2, entry.getValue().length);\n+\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"Received manufacturer data for '{}': {}\", address, HexUtils.bytesToHex(data, \" \"));\n+            }\n+\n+            notification.setManufacturerData(data);\n+            notifyListeners(BluetoothEventType.SCAN_RECORD, notification);\n+        }\n+    }\n+\n+    @Override\n+    public void onTxPowerUpdate(TXPowerEvent event) {\n+        this.txPower = (int) event.getTxPower();\n+    }\n+\n+    @Override\n+    public void onCharacteristicNotify(CharacteristicUpdateEvent event) {\n+        // Here it is a bit special - as the event is linked to the DBUS path, not characteristic UUID.\n+        // So we need to find the characteristic by its DBUS path.\n+        BluetoothGattCharacteristic characteristic = getDBusBlueZCharacteristicByDBusPath(event.getDbusPath());\n+        if (characteristic == null) {\n+            logger.info(\"Received a notification for a characteristic not found on device.\");\n+            return;\n+        }\n+        BluetoothCharacteristic c = getCharacteristic(UUID.fromString(characteristic.getUuid()));\n+        if (c != null) {\n+            c.setValue(event.getData());\n+            notifyListeners(BluetoothEventType.CHARACTERISTIC_UPDATED, c, BluetoothCompletionStatus.SUCCESS);\n+            logger.debug(\"Has notified that a characteristic has been updated\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c2c484c0a68abcdb7f6e511a0635e2dd9353821"}, "originalPosition": 364}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE2OTAxOA==", "bodyText": "Suggested change", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r511169018", "createdAt": "2020-10-23T21:44:56Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBluetoothDevice.java", "diffHunk": "@@ -0,0 +1,474 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.bluez.exceptions.BluezFailedException;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.freedesktop.dbus.errors.NoReply;\n+import org.freedesktop.dbus.exceptions.DBusException;\n+import org.freedesktop.dbus.exceptions.DBusExecutionException;\n+import org.freedesktop.dbus.types.UInt16;\n+import org.openhab.binding.bluetooth.BaseBluetoothDevice;\n+import org.openhab.binding.bluetooth.BluetoothAddress;\n+import org.openhab.binding.bluetooth.BluetoothCharacteristic;\n+import org.openhab.binding.bluetooth.BluetoothCompletionStatus;\n+import org.openhab.binding.bluetooth.BluetoothDescriptor;\n+import org.openhab.binding.bluetooth.BluetoothService;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEventListener;\n+import org.openhab.binding.bluetooth.bluez.internal.events.CharacteristicUpdateEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ConnectedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ManufacturerDataEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.NameEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.RssiEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ServicesResolvedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.TXPowerEvent;\n+import org.openhab.binding.bluetooth.notification.BluetoothConnectionStatusNotification;\n+import org.openhab.binding.bluetooth.notification.BluetoothScanNotification;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.util.HexUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothDevice;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattCharacteristic;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattDescriptor;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattService;\n+\n+/**\n+ * Implementation of BluetoothDevice for BlueZ via DBus-BlueZ API\n+ *\n+ * @author Kai Kreuzer - Initial contribution and API\n+ * @author Benjamin Lafois - Replaced tinyB with bluezDbus\n+ *\n+ */\n+@NonNullByDefault\n+public class BlueZBluetoothDevice extends BaseBluetoothDevice implements BlueZEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(BlueZBluetoothDevice.class);\n+\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager.getScheduledPool(\"bluetooth\");\n+\n+    // Device from native lib\n+    private @Nullable BluetoothDevice device = null;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param adapter the bridge handler through which this device is connected\n+     * @param address the Bluetooth address of the device\n+     * @param name the name of the device\n+     */\n+    public BlueZBluetoothDevice(BlueZBridgeHandler adapter, BluetoothAddress address) {\n+        super(adapter, address);\n+        logger.debug(\"Creating DBusBlueZ device with address '{}'\", address);\n+    }\n+\n+    public synchronized void updateBlueZDevice(@Nullable BluetoothDevice blueZDevice) {\n+        if (this.device != null && this.device == blueZDevice) {\n+            return;\n+        }\n+        logger.debug(\"updateBlueZDevice({})\", blueZDevice);\n+\n+        this.device = blueZDevice;\n+\n+        if (blueZDevice == null) {\n+            return;\n+        }\n+\n+        Short rssi = blueZDevice.getRssi();\n+        if (rssi != null) {\n+            this.rssi = rssi.intValue();\n+        }\n+        this.name = blueZDevice.getName();\n+        Map<UInt16, byte[]> manData = blueZDevice.getManufacturerData();\n+        if (manData != null) {\n+            manData.entrySet().stream().map(Map.Entry::getKey).filter(Objects::nonNull).findFirst()\n+                    .ifPresent((UInt16 manufacturerId) ->\n+                    // Convert to unsigned int to match the convention in BluetoothCompanyIdentifiers\n+                    this.manufacturer = manufacturerId.intValue() & 0xFFFF);\n+        }\n+\n+        if (Boolean.TRUE.equals(blueZDevice.isConnected())) {\n+            setConnectionState(ConnectionState.CONNECTED);\n+        }\n+\n+        discoverServices();\n+    }\n+\n+    /**\n+     * Clean up and release memory.\n+     */\n+    @Override\n+    public void dispose() {\n+        BluetoothDevice dev = device;\n+        if (dev != null) {\n+            try {\n+                dev.getAdapter().removeDevice(dev.getRawDevice());\n+            } catch (DBusException ex) {\n+                if (ex.getMessage().contains(\"Does Not Exist\")) {\n+                    // this happens when the underlying device has already been removed\n+                    // but we don't have a way to check if that is the case beforehand so\n+                    // we will just eat the error here.\n+                } else {\n+                    logger.debug(\"Exception occurred when trying to remove inactive device '{}': {}\", address,\n+                            ex.getMessage());\n+                }\n+            } catch (RuntimeException ex) {\n+                // try to catch any other exceptions\n+                logger.debug(\"Exception occurred when trying to remove inactive device '{}': {}\", address,\n+                        ex.getMessage());\n+            }\n+        }\n+    }\n+\n+    private void setConnectionState(ConnectionState state) {\n+        if (this.connectionState != state) {\n+            this.connectionState = state;\n+            notifyListeners(BluetoothEventType.CONNECTION_STATE, new BluetoothConnectionStatusNotification(state));\n+        }\n+    }\n+\n+    @Override\n+    public boolean connect() {\n+        logger.debug(\"Connect({})\", device);\n+\n+        BluetoothDevice dev = device;\n+        if (dev != null) {\n+            if (Boolean.FALSE.equals(dev.isConnected())) {\n+                try {\n+                    boolean ret = dev.connect();\n+                    logger.debug(\"Connect result: {}\", ret);\n+                    return ret;\n+                } catch (NoReply e) {\n+                    // Have to double check because sometimes, exception but still worked\n+                    logger.debug(\"Got a timeout - but sometimes happen. Is Connected ? {}\", dev.isConnected());\n+                    if (Boolean.FALSE.equals(dev.isConnected())) {\n+\n+                        notifyListeners(BluetoothEventType.CONNECTION_STATE,\n+                                new BluetoothConnectionStatusNotification(ConnectionState.DISCONNECTED));\n+                        return false;\n+                    } else {\n+                        return true;\n+                    }\n+                } catch (DBusExecutionException e) {\n+                    // Catch \"software caused connection abort\"\n+                    return false;\n+                } catch (Exception e) {\n+                    logger.warn(\"error occured while trying to connect\", e);\n+                }\n+\n+            } else {\n+                logger.debug(\"Device was already connected\");\n+                // we might be stuck in another state atm so we need to trigger a connected in this case\n+                setConnectionState(ConnectionState.CONNECTED);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean disconnect() {\n+        BluetoothDevice dev = device;\n+        if (dev != null) {\n+            logger.debug(\"Disconnecting '{}'\", address);\n+            return dev.disconnect();\n+        }\n+        return false;\n+    }\n+\n+    private void ensureConnected() {\n+        BluetoothDevice dev = device;\n+        if (dev == null || !dev.isConnected()) {\n+            throw new IllegalStateException(\"DBusBlueZ device is not set or not connected\");\n+        }\n+    }\n+\n+    private @Nullable BluetoothGattCharacteristic getDBusBlueZCharacteristicByUUID(String uuid) {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return null;\n+        }\n+        for (BluetoothGattService service : dev.getGattServices()) {\n+            for (BluetoothGattCharacteristic c : service.getGattCharacteristics()) {\n+                if (c.getUuid().equalsIgnoreCase(uuid)) {\n+                    return c;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private @Nullable BluetoothGattCharacteristic getDBusBlueZCharacteristicByDBusPath(String dBusPath) {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return null;\n+        }\n+        for (BluetoothGattService service : dev.getGattServices()) {\n+            if (dBusPath.startsWith(service.getDbusPath())) {\n+                for (BluetoothGattCharacteristic characteristic : service.getGattCharacteristics()) {\n+                    if (dBusPath.startsWith(characteristic.getDbusPath())) {\n+                        return characteristic;\n+                    }\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private @Nullable BluetoothGattDescriptor getDBusBlueZDescriptorByUUID(String uuid) {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return null;\n+        }\n+        for (BluetoothGattService service : dev.getGattServices()) {\n+            for (BluetoothGattCharacteristic c : service.getGattCharacteristics()) {\n+                for (BluetoothGattDescriptor d : c.getGattDescriptors()) {\n+                    if (d.getUuid().equalsIgnoreCase(uuid)) {\n+                        return d;\n+                    }\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public boolean enableNotifications(BluetoothCharacteristic characteristic) {\n+        ensureConnected();\n+\n+        BluetoothGattCharacteristic c = getDBusBlueZCharacteristicByUUID(characteristic.getUuid().toString());\n+        if (c != null) {\n+\n+            try {\n+                c.startNotify();\n+            } catch (DBusException e) {\n+                if (e.getMessage().contains(\"Already notifying\")) {\n+                    return false;\n+                } else if (e.getMessage().contains(\"In Progress\")) {\n+                    // let's retry in 10 seconds\n+                    scheduler.schedule(() -> enableNotifications(characteristic), 10, TimeUnit.SECONDS);\n+                } else {\n+                    logger.warn(\"Exception occurred while activating notifications on '{}'\", address, e);\n+                }\n+            }\n+            return true;\n+        } else {\n+            logger.warn(\"Characteristic '{}' is missing on device '{}'.\", characteristic.getUuid(), address);\n+            return false;\n+        }\n+    }\n+\n+    @Override\n+    public boolean writeCharacteristic(BluetoothCharacteristic characteristic) {\n+        logger.debug(\"writeCharacteristic()\");\n+\n+        ensureConnected();\n+\n+        BluetoothGattCharacteristic c = getDBusBlueZCharacteristicByUUID(characteristic.getUuid().toString());\n+        if (c == null) {\n+            logger.warn(\"Characteristic '{}' is missing on device '{}'.\", characteristic.getUuid(), address);\n+            return false;\n+        }\n+\n+        scheduler.submit(() -> {\n+            try {\n+                c.writeValue(characteristic.getByteValue(), null);\n+                notifyListeners(BluetoothEventType.CHARACTERISTIC_WRITE_COMPLETE, characteristic,\n+                        BluetoothCompletionStatus.SUCCESS);\n+\n+            } catch (DBusException e) {\n+                logger.debug(\"Exception occurred when trying to write characteristic '{}': {}\",\n+                        characteristic.getUuid(), e.getMessage());\n+                notifyListeners(BluetoothEventType.CHARACTERISTIC_WRITE_COMPLETE, characteristic,\n+                        BluetoothCompletionStatus.ERROR);\n+            }\n+        });\n+        return true;\n+    }\n+\n+    @Override\n+    public void onDBusBlueZEvent(BlueZEvent event) {\n+        logger.debug(\"Unsupported event: {}\", event);\n+    }\n+\n+    @Override\n+    public void onServicesResolved(ServicesResolvedEvent event) {\n+        if (event.isResolved()) {\n+            notifyListeners(BluetoothEventType.SERVICES_DISCOVERED);\n+        }\n+    }\n+\n+    @Override\n+    public void onNameUpdate(NameEvent event) {\n+        BluetoothScanNotification notification = new BluetoothScanNotification();\n+        notification.setDeviceName(event.getName());\n+        notifyListeners(BluetoothEventType.SCAN_RECORD, notification);\n+    }\n+\n+    @Override\n+    public void onManufacturerDataUpdate(ManufacturerDataEvent event) {\n+        for (Map.Entry<Short, byte[]> entry : event.getData().entrySet()) {\n+            BluetoothScanNotification notification = new BluetoothScanNotification();\n+            byte[] data = new byte[entry.getValue().length + 2];\n+            data[0] = (byte) (entry.getKey() & 0xFF);\n+            data[1] = (byte) (entry.getKey() >>> 8);\n+\n+            System.arraycopy(entry.getValue(), 0, data, 2, entry.getValue().length);\n+\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"Received manufacturer data for '{}': {}\", address, HexUtils.bytesToHex(data, \" \"));\n+            }\n+\n+            notification.setManufacturerData(data);\n+            notifyListeners(BluetoothEventType.SCAN_RECORD, notification);\n+        }\n+    }\n+\n+    @Override\n+    public void onTxPowerUpdate(TXPowerEvent event) {\n+        this.txPower = (int) event.getTxPower();\n+    }\n+\n+    @Override\n+    public void onCharacteristicNotify(CharacteristicUpdateEvent event) {\n+        // Here it is a bit special - as the event is linked to the DBUS path, not characteristic UUID.\n+        // So we need to find the characteristic by its DBUS path.\n+        BluetoothGattCharacteristic characteristic = getDBusBlueZCharacteristicByDBusPath(event.getDbusPath());\n+        if (characteristic == null) {\n+            logger.info(\"Received a notification for a characteristic not found on device.\");\n+            return;\n+        }\n+        BluetoothCharacteristic c = getCharacteristic(UUID.fromString(characteristic.getUuid()));\n+        if (c != null) {\n+            c.setValue(event.getData());\n+            notifyListeners(BluetoothEventType.CHARACTERISTIC_UPDATED, c, BluetoothCompletionStatus.SUCCESS);\n+            logger.debug(\"Has notified that a characteristic has been updated\");\n+        }\n+    }\n+\n+    @Override\n+    public void onRssiUpdate(RssiEvent event) {\n+        int rssiTmp = event.getRssi();\n+        this.rssi = rssiTmp;\n+        BluetoothScanNotification notification = new BluetoothScanNotification();\n+        notification.setRssi(rssiTmp);\n+        notifyListeners(BluetoothEventType.SCAN_RECORD, notification);\n+    }\n+\n+    @Override\n+    public void onConnectedStatusUpdate(ConnectedEvent event) {\n+        this.connectionState = event.isConnected() ? ConnectionState.CONNECTED : ConnectionState.DISCONNECTED;\n+        notifyListeners(BluetoothEventType.CONNECTION_STATE,\n+                new BluetoothConnectionStatusNotification(connectionState));\n+    }\n+\n+    @Override\n+    public boolean discoverServices() {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return false;\n+        }\n+        if (dev.getGattServices().size() > getServices().size()) {\n+\n+            for (BluetoothGattService dBusBlueZService : dev.getGattServices()) {\n+                BluetoothService service = new BluetoothService(UUID.fromString(dBusBlueZService.getUuid()),\n+                        dBusBlueZService.isPrimary());\n+\n+                for (BluetoothGattCharacteristic dBusBlueZCharacteristic : dBusBlueZService.getGattCharacteristics()) {\n+                    BluetoothCharacteristic characteristic = new BluetoothCharacteristic(\n+                            UUID.fromString(dBusBlueZCharacteristic.getUuid()), 0);\n+\n+                    for (BluetoothGattDescriptor dBusBlueZDescriptor : dBusBlueZCharacteristic.getGattDescriptors()) {\n+                        BluetoothDescriptor descriptor = new BluetoothDescriptor(characteristic,\n+                                UUID.fromString(dBusBlueZDescriptor.getUuid()));\n+                        characteristic.addDescriptor(descriptor);\n+                    }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c2c484c0a68abcdb7f6e511a0635e2dd9353821"}, "originalPosition": 405}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE2OTA3OQ==", "bodyText": "Suggested change", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r511169079", "createdAt": "2020-10-23T21:45:05Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBluetoothDevice.java", "diffHunk": "@@ -0,0 +1,474 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.bluez.exceptions.BluezFailedException;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.freedesktop.dbus.errors.NoReply;\n+import org.freedesktop.dbus.exceptions.DBusException;\n+import org.freedesktop.dbus.exceptions.DBusExecutionException;\n+import org.freedesktop.dbus.types.UInt16;\n+import org.openhab.binding.bluetooth.BaseBluetoothDevice;\n+import org.openhab.binding.bluetooth.BluetoothAddress;\n+import org.openhab.binding.bluetooth.BluetoothCharacteristic;\n+import org.openhab.binding.bluetooth.BluetoothCompletionStatus;\n+import org.openhab.binding.bluetooth.BluetoothDescriptor;\n+import org.openhab.binding.bluetooth.BluetoothService;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEventListener;\n+import org.openhab.binding.bluetooth.bluez.internal.events.CharacteristicUpdateEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ConnectedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ManufacturerDataEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.NameEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.RssiEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ServicesResolvedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.TXPowerEvent;\n+import org.openhab.binding.bluetooth.notification.BluetoothConnectionStatusNotification;\n+import org.openhab.binding.bluetooth.notification.BluetoothScanNotification;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.util.HexUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothDevice;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattCharacteristic;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattDescriptor;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattService;\n+\n+/**\n+ * Implementation of BluetoothDevice for BlueZ via DBus-BlueZ API\n+ *\n+ * @author Kai Kreuzer - Initial contribution and API\n+ * @author Benjamin Lafois - Replaced tinyB with bluezDbus\n+ *\n+ */\n+@NonNullByDefault\n+public class BlueZBluetoothDevice extends BaseBluetoothDevice implements BlueZEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(BlueZBluetoothDevice.class);\n+\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager.getScheduledPool(\"bluetooth\");\n+\n+    // Device from native lib\n+    private @Nullable BluetoothDevice device = null;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param adapter the bridge handler through which this device is connected\n+     * @param address the Bluetooth address of the device\n+     * @param name the name of the device\n+     */\n+    public BlueZBluetoothDevice(BlueZBridgeHandler adapter, BluetoothAddress address) {\n+        super(adapter, address);\n+        logger.debug(\"Creating DBusBlueZ device with address '{}'\", address);\n+    }\n+\n+    public synchronized void updateBlueZDevice(@Nullable BluetoothDevice blueZDevice) {\n+        if (this.device != null && this.device == blueZDevice) {\n+            return;\n+        }\n+        logger.debug(\"updateBlueZDevice({})\", blueZDevice);\n+\n+        this.device = blueZDevice;\n+\n+        if (blueZDevice == null) {\n+            return;\n+        }\n+\n+        Short rssi = blueZDevice.getRssi();\n+        if (rssi != null) {\n+            this.rssi = rssi.intValue();\n+        }\n+        this.name = blueZDevice.getName();\n+        Map<UInt16, byte[]> manData = blueZDevice.getManufacturerData();\n+        if (manData != null) {\n+            manData.entrySet().stream().map(Map.Entry::getKey).filter(Objects::nonNull).findFirst()\n+                    .ifPresent((UInt16 manufacturerId) ->\n+                    // Convert to unsigned int to match the convention in BluetoothCompanyIdentifiers\n+                    this.manufacturer = manufacturerId.intValue() & 0xFFFF);\n+        }\n+\n+        if (Boolean.TRUE.equals(blueZDevice.isConnected())) {\n+            setConnectionState(ConnectionState.CONNECTED);\n+        }\n+\n+        discoverServices();\n+    }\n+\n+    /**\n+     * Clean up and release memory.\n+     */\n+    @Override\n+    public void dispose() {\n+        BluetoothDevice dev = device;\n+        if (dev != null) {\n+            try {\n+                dev.getAdapter().removeDevice(dev.getRawDevice());\n+            } catch (DBusException ex) {\n+                if (ex.getMessage().contains(\"Does Not Exist\")) {\n+                    // this happens when the underlying device has already been removed\n+                    // but we don't have a way to check if that is the case beforehand so\n+                    // we will just eat the error here.\n+                } else {\n+                    logger.debug(\"Exception occurred when trying to remove inactive device '{}': {}\", address,\n+                            ex.getMessage());\n+                }\n+            } catch (RuntimeException ex) {\n+                // try to catch any other exceptions\n+                logger.debug(\"Exception occurred when trying to remove inactive device '{}': {}\", address,\n+                        ex.getMessage());\n+            }\n+        }\n+    }\n+\n+    private void setConnectionState(ConnectionState state) {\n+        if (this.connectionState != state) {\n+            this.connectionState = state;\n+            notifyListeners(BluetoothEventType.CONNECTION_STATE, new BluetoothConnectionStatusNotification(state));\n+        }\n+    }\n+\n+    @Override\n+    public boolean connect() {\n+        logger.debug(\"Connect({})\", device);\n+\n+        BluetoothDevice dev = device;\n+        if (dev != null) {\n+            if (Boolean.FALSE.equals(dev.isConnected())) {\n+                try {\n+                    boolean ret = dev.connect();\n+                    logger.debug(\"Connect result: {}\", ret);\n+                    return ret;\n+                } catch (NoReply e) {\n+                    // Have to double check because sometimes, exception but still worked\n+                    logger.debug(\"Got a timeout - but sometimes happen. Is Connected ? {}\", dev.isConnected());\n+                    if (Boolean.FALSE.equals(dev.isConnected())) {\n+\n+                        notifyListeners(BluetoothEventType.CONNECTION_STATE,\n+                                new BluetoothConnectionStatusNotification(ConnectionState.DISCONNECTED));\n+                        return false;\n+                    } else {\n+                        return true;\n+                    }\n+                } catch (DBusExecutionException e) {\n+                    // Catch \"software caused connection abort\"\n+                    return false;\n+                } catch (Exception e) {\n+                    logger.warn(\"error occured while trying to connect\", e);\n+                }\n+\n+            } else {\n+                logger.debug(\"Device was already connected\");\n+                // we might be stuck in another state atm so we need to trigger a connected in this case\n+                setConnectionState(ConnectionState.CONNECTED);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean disconnect() {\n+        BluetoothDevice dev = device;\n+        if (dev != null) {\n+            logger.debug(\"Disconnecting '{}'\", address);\n+            return dev.disconnect();\n+        }\n+        return false;\n+    }\n+\n+    private void ensureConnected() {\n+        BluetoothDevice dev = device;\n+        if (dev == null || !dev.isConnected()) {\n+            throw new IllegalStateException(\"DBusBlueZ device is not set or not connected\");\n+        }\n+    }\n+\n+    private @Nullable BluetoothGattCharacteristic getDBusBlueZCharacteristicByUUID(String uuid) {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return null;\n+        }\n+        for (BluetoothGattService service : dev.getGattServices()) {\n+            for (BluetoothGattCharacteristic c : service.getGattCharacteristics()) {\n+                if (c.getUuid().equalsIgnoreCase(uuid)) {\n+                    return c;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private @Nullable BluetoothGattCharacteristic getDBusBlueZCharacteristicByDBusPath(String dBusPath) {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return null;\n+        }\n+        for (BluetoothGattService service : dev.getGattServices()) {\n+            if (dBusPath.startsWith(service.getDbusPath())) {\n+                for (BluetoothGattCharacteristic characteristic : service.getGattCharacteristics()) {\n+                    if (dBusPath.startsWith(characteristic.getDbusPath())) {\n+                        return characteristic;\n+                    }\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private @Nullable BluetoothGattDescriptor getDBusBlueZDescriptorByUUID(String uuid) {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return null;\n+        }\n+        for (BluetoothGattService service : dev.getGattServices()) {\n+            for (BluetoothGattCharacteristic c : service.getGattCharacteristics()) {\n+                for (BluetoothGattDescriptor d : c.getGattDescriptors()) {\n+                    if (d.getUuid().equalsIgnoreCase(uuid)) {\n+                        return d;\n+                    }\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public boolean enableNotifications(BluetoothCharacteristic characteristic) {\n+        ensureConnected();\n+\n+        BluetoothGattCharacteristic c = getDBusBlueZCharacteristicByUUID(characteristic.getUuid().toString());\n+        if (c != null) {\n+\n+            try {\n+                c.startNotify();\n+            } catch (DBusException e) {\n+                if (e.getMessage().contains(\"Already notifying\")) {\n+                    return false;\n+                } else if (e.getMessage().contains(\"In Progress\")) {\n+                    // let's retry in 10 seconds\n+                    scheduler.schedule(() -> enableNotifications(characteristic), 10, TimeUnit.SECONDS);\n+                } else {\n+                    logger.warn(\"Exception occurred while activating notifications on '{}'\", address, e);\n+                }\n+            }\n+            return true;\n+        } else {\n+            logger.warn(\"Characteristic '{}' is missing on device '{}'.\", characteristic.getUuid(), address);\n+            return false;\n+        }\n+    }\n+\n+    @Override\n+    public boolean writeCharacteristic(BluetoothCharacteristic characteristic) {\n+        logger.debug(\"writeCharacteristic()\");\n+\n+        ensureConnected();\n+\n+        BluetoothGattCharacteristic c = getDBusBlueZCharacteristicByUUID(characteristic.getUuid().toString());\n+        if (c == null) {\n+            logger.warn(\"Characteristic '{}' is missing on device '{}'.\", characteristic.getUuid(), address);\n+            return false;\n+        }\n+\n+        scheduler.submit(() -> {\n+            try {\n+                c.writeValue(characteristic.getByteValue(), null);\n+                notifyListeners(BluetoothEventType.CHARACTERISTIC_WRITE_COMPLETE, characteristic,\n+                        BluetoothCompletionStatus.SUCCESS);\n+\n+            } catch (DBusException e) {\n+                logger.debug(\"Exception occurred when trying to write characteristic '{}': {}\",\n+                        characteristic.getUuid(), e.getMessage());\n+                notifyListeners(BluetoothEventType.CHARACTERISTIC_WRITE_COMPLETE, characteristic,\n+                        BluetoothCompletionStatus.ERROR);\n+            }\n+        });\n+        return true;\n+    }\n+\n+    @Override\n+    public void onDBusBlueZEvent(BlueZEvent event) {\n+        logger.debug(\"Unsupported event: {}\", event);\n+    }\n+\n+    @Override\n+    public void onServicesResolved(ServicesResolvedEvent event) {\n+        if (event.isResolved()) {\n+            notifyListeners(BluetoothEventType.SERVICES_DISCOVERED);\n+        }\n+    }\n+\n+    @Override\n+    public void onNameUpdate(NameEvent event) {\n+        BluetoothScanNotification notification = new BluetoothScanNotification();\n+        notification.setDeviceName(event.getName());\n+        notifyListeners(BluetoothEventType.SCAN_RECORD, notification);\n+    }\n+\n+    @Override\n+    public void onManufacturerDataUpdate(ManufacturerDataEvent event) {\n+        for (Map.Entry<Short, byte[]> entry : event.getData().entrySet()) {\n+            BluetoothScanNotification notification = new BluetoothScanNotification();\n+            byte[] data = new byte[entry.getValue().length + 2];\n+            data[0] = (byte) (entry.getKey() & 0xFF);\n+            data[1] = (byte) (entry.getKey() >>> 8);\n+\n+            System.arraycopy(entry.getValue(), 0, data, 2, entry.getValue().length);\n+\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"Received manufacturer data for '{}': {}\", address, HexUtils.bytesToHex(data, \" \"));\n+            }\n+\n+            notification.setManufacturerData(data);\n+            notifyListeners(BluetoothEventType.SCAN_RECORD, notification);\n+        }\n+    }\n+\n+    @Override\n+    public void onTxPowerUpdate(TXPowerEvent event) {\n+        this.txPower = (int) event.getTxPower();\n+    }\n+\n+    @Override\n+    public void onCharacteristicNotify(CharacteristicUpdateEvent event) {\n+        // Here it is a bit special - as the event is linked to the DBUS path, not characteristic UUID.\n+        // So we need to find the characteristic by its DBUS path.\n+        BluetoothGattCharacteristic characteristic = getDBusBlueZCharacteristicByDBusPath(event.getDbusPath());\n+        if (characteristic == null) {\n+            logger.info(\"Received a notification for a characteristic not found on device.\");\n+            return;\n+        }\n+        BluetoothCharacteristic c = getCharacteristic(UUID.fromString(characteristic.getUuid()));\n+        if (c != null) {\n+            c.setValue(event.getData());\n+            notifyListeners(BluetoothEventType.CHARACTERISTIC_UPDATED, c, BluetoothCompletionStatus.SUCCESS);\n+            logger.debug(\"Has notified that a characteristic has been updated\");\n+        }\n+    }\n+\n+    @Override\n+    public void onRssiUpdate(RssiEvent event) {\n+        int rssiTmp = event.getRssi();\n+        this.rssi = rssiTmp;\n+        BluetoothScanNotification notification = new BluetoothScanNotification();\n+        notification.setRssi(rssiTmp);\n+        notifyListeners(BluetoothEventType.SCAN_RECORD, notification);\n+    }\n+\n+    @Override\n+    public void onConnectedStatusUpdate(ConnectedEvent event) {\n+        this.connectionState = event.isConnected() ? ConnectionState.CONNECTED : ConnectionState.DISCONNECTED;\n+        notifyListeners(BluetoothEventType.CONNECTION_STATE,\n+                new BluetoothConnectionStatusNotification(connectionState));\n+    }\n+\n+    @Override\n+    public boolean discoverServices() {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return false;\n+        }\n+        if (dev.getGattServices().size() > getServices().size()) {\n+\n+            for (BluetoothGattService dBusBlueZService : dev.getGattServices()) {\n+                BluetoothService service = new BluetoothService(UUID.fromString(dBusBlueZService.getUuid()),\n+                        dBusBlueZService.isPrimary());\n+\n+                for (BluetoothGattCharacteristic dBusBlueZCharacteristic : dBusBlueZService.getGattCharacteristics()) {\n+                    BluetoothCharacteristic characteristic = new BluetoothCharacteristic(\n+                            UUID.fromString(dBusBlueZCharacteristic.getUuid()), 0);\n+\n+                    for (BluetoothGattDescriptor dBusBlueZDescriptor : dBusBlueZCharacteristic.getGattDescriptors()) {\n+                        BluetoothDescriptor descriptor = new BluetoothDescriptor(characteristic,\n+                                UUID.fromString(dBusBlueZDescriptor.getUuid()));\n+                        characteristic.addDescriptor(descriptor);\n+                    }\n+\n+                    service.addCharacteristic(characteristic);\n+                }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c2c484c0a68abcdb7f6e511a0635e2dd9353821"}, "originalPosition": 408}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE2OTE0OQ==", "bodyText": "Suggested change", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r511169149", "createdAt": "2020-10-23T21:45:15Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBluetoothDevice.java", "diffHunk": "@@ -0,0 +1,474 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.bluez.exceptions.BluezFailedException;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.freedesktop.dbus.errors.NoReply;\n+import org.freedesktop.dbus.exceptions.DBusException;\n+import org.freedesktop.dbus.exceptions.DBusExecutionException;\n+import org.freedesktop.dbus.types.UInt16;\n+import org.openhab.binding.bluetooth.BaseBluetoothDevice;\n+import org.openhab.binding.bluetooth.BluetoothAddress;\n+import org.openhab.binding.bluetooth.BluetoothCharacteristic;\n+import org.openhab.binding.bluetooth.BluetoothCompletionStatus;\n+import org.openhab.binding.bluetooth.BluetoothDescriptor;\n+import org.openhab.binding.bluetooth.BluetoothService;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEventListener;\n+import org.openhab.binding.bluetooth.bluez.internal.events.CharacteristicUpdateEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ConnectedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ManufacturerDataEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.NameEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.RssiEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ServicesResolvedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.TXPowerEvent;\n+import org.openhab.binding.bluetooth.notification.BluetoothConnectionStatusNotification;\n+import org.openhab.binding.bluetooth.notification.BluetoothScanNotification;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.util.HexUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothDevice;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattCharacteristic;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattDescriptor;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattService;\n+\n+/**\n+ * Implementation of BluetoothDevice for BlueZ via DBus-BlueZ API\n+ *\n+ * @author Kai Kreuzer - Initial contribution and API\n+ * @author Benjamin Lafois - Replaced tinyB with bluezDbus\n+ *\n+ */\n+@NonNullByDefault\n+public class BlueZBluetoothDevice extends BaseBluetoothDevice implements BlueZEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(BlueZBluetoothDevice.class);\n+\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager.getScheduledPool(\"bluetooth\");\n+\n+    // Device from native lib\n+    private @Nullable BluetoothDevice device = null;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param adapter the bridge handler through which this device is connected\n+     * @param address the Bluetooth address of the device\n+     * @param name the name of the device\n+     */\n+    public BlueZBluetoothDevice(BlueZBridgeHandler adapter, BluetoothAddress address) {\n+        super(adapter, address);\n+        logger.debug(\"Creating DBusBlueZ device with address '{}'\", address);\n+    }\n+\n+    public synchronized void updateBlueZDevice(@Nullable BluetoothDevice blueZDevice) {\n+        if (this.device != null && this.device == blueZDevice) {\n+            return;\n+        }\n+        logger.debug(\"updateBlueZDevice({})\", blueZDevice);\n+\n+        this.device = blueZDevice;\n+\n+        if (blueZDevice == null) {\n+            return;\n+        }\n+\n+        Short rssi = blueZDevice.getRssi();\n+        if (rssi != null) {\n+            this.rssi = rssi.intValue();\n+        }\n+        this.name = blueZDevice.getName();\n+        Map<UInt16, byte[]> manData = blueZDevice.getManufacturerData();\n+        if (manData != null) {\n+            manData.entrySet().stream().map(Map.Entry::getKey).filter(Objects::nonNull).findFirst()\n+                    .ifPresent((UInt16 manufacturerId) ->\n+                    // Convert to unsigned int to match the convention in BluetoothCompanyIdentifiers\n+                    this.manufacturer = manufacturerId.intValue() & 0xFFFF);\n+        }\n+\n+        if (Boolean.TRUE.equals(blueZDevice.isConnected())) {\n+            setConnectionState(ConnectionState.CONNECTED);\n+        }\n+\n+        discoverServices();\n+    }\n+\n+    /**\n+     * Clean up and release memory.\n+     */\n+    @Override\n+    public void dispose() {\n+        BluetoothDevice dev = device;\n+        if (dev != null) {\n+            try {\n+                dev.getAdapter().removeDevice(dev.getRawDevice());\n+            } catch (DBusException ex) {\n+                if (ex.getMessage().contains(\"Does Not Exist\")) {\n+                    // this happens when the underlying device has already been removed\n+                    // but we don't have a way to check if that is the case beforehand so\n+                    // we will just eat the error here.\n+                } else {\n+                    logger.debug(\"Exception occurred when trying to remove inactive device '{}': {}\", address,\n+                            ex.getMessage());\n+                }\n+            } catch (RuntimeException ex) {\n+                // try to catch any other exceptions\n+                logger.debug(\"Exception occurred when trying to remove inactive device '{}': {}\", address,\n+                        ex.getMessage());\n+            }\n+        }\n+    }\n+\n+    private void setConnectionState(ConnectionState state) {\n+        if (this.connectionState != state) {\n+            this.connectionState = state;\n+            notifyListeners(BluetoothEventType.CONNECTION_STATE, new BluetoothConnectionStatusNotification(state));\n+        }\n+    }\n+\n+    @Override\n+    public boolean connect() {\n+        logger.debug(\"Connect({})\", device);\n+\n+        BluetoothDevice dev = device;\n+        if (dev != null) {\n+            if (Boolean.FALSE.equals(dev.isConnected())) {\n+                try {\n+                    boolean ret = dev.connect();\n+                    logger.debug(\"Connect result: {}\", ret);\n+                    return ret;\n+                } catch (NoReply e) {\n+                    // Have to double check because sometimes, exception but still worked\n+                    logger.debug(\"Got a timeout - but sometimes happen. Is Connected ? {}\", dev.isConnected());\n+                    if (Boolean.FALSE.equals(dev.isConnected())) {\n+\n+                        notifyListeners(BluetoothEventType.CONNECTION_STATE,\n+                                new BluetoothConnectionStatusNotification(ConnectionState.DISCONNECTED));\n+                        return false;\n+                    } else {\n+                        return true;\n+                    }\n+                } catch (DBusExecutionException e) {\n+                    // Catch \"software caused connection abort\"\n+                    return false;\n+                } catch (Exception e) {\n+                    logger.warn(\"error occured while trying to connect\", e);\n+                }\n+\n+            } else {\n+                logger.debug(\"Device was already connected\");\n+                // we might be stuck in another state atm so we need to trigger a connected in this case\n+                setConnectionState(ConnectionState.CONNECTED);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean disconnect() {\n+        BluetoothDevice dev = device;\n+        if (dev != null) {\n+            logger.debug(\"Disconnecting '{}'\", address);\n+            return dev.disconnect();\n+        }\n+        return false;\n+    }\n+\n+    private void ensureConnected() {\n+        BluetoothDevice dev = device;\n+        if (dev == null || !dev.isConnected()) {\n+            throw new IllegalStateException(\"DBusBlueZ device is not set or not connected\");\n+        }\n+    }\n+\n+    private @Nullable BluetoothGattCharacteristic getDBusBlueZCharacteristicByUUID(String uuid) {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return null;\n+        }\n+        for (BluetoothGattService service : dev.getGattServices()) {\n+            for (BluetoothGattCharacteristic c : service.getGattCharacteristics()) {\n+                if (c.getUuid().equalsIgnoreCase(uuid)) {\n+                    return c;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private @Nullable BluetoothGattCharacteristic getDBusBlueZCharacteristicByDBusPath(String dBusPath) {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return null;\n+        }\n+        for (BluetoothGattService service : dev.getGattServices()) {\n+            if (dBusPath.startsWith(service.getDbusPath())) {\n+                for (BluetoothGattCharacteristic characteristic : service.getGattCharacteristics()) {\n+                    if (dBusPath.startsWith(characteristic.getDbusPath())) {\n+                        return characteristic;\n+                    }\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private @Nullable BluetoothGattDescriptor getDBusBlueZDescriptorByUUID(String uuid) {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return null;\n+        }\n+        for (BluetoothGattService service : dev.getGattServices()) {\n+            for (BluetoothGattCharacteristic c : service.getGattCharacteristics()) {\n+                for (BluetoothGattDescriptor d : c.getGattDescriptors()) {\n+                    if (d.getUuid().equalsIgnoreCase(uuid)) {\n+                        return d;\n+                    }\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public boolean enableNotifications(BluetoothCharacteristic characteristic) {\n+        ensureConnected();\n+\n+        BluetoothGattCharacteristic c = getDBusBlueZCharacteristicByUUID(characteristic.getUuid().toString());\n+        if (c != null) {\n+\n+            try {\n+                c.startNotify();\n+            } catch (DBusException e) {\n+                if (e.getMessage().contains(\"Already notifying\")) {\n+                    return false;\n+                } else if (e.getMessage().contains(\"In Progress\")) {\n+                    // let's retry in 10 seconds\n+                    scheduler.schedule(() -> enableNotifications(characteristic), 10, TimeUnit.SECONDS);\n+                } else {\n+                    logger.warn(\"Exception occurred while activating notifications on '{}'\", address, e);\n+                }\n+            }\n+            return true;\n+        } else {\n+            logger.warn(\"Characteristic '{}' is missing on device '{}'.\", characteristic.getUuid(), address);\n+            return false;\n+        }\n+    }\n+\n+    @Override\n+    public boolean writeCharacteristic(BluetoothCharacteristic characteristic) {\n+        logger.debug(\"writeCharacteristic()\");\n+\n+        ensureConnected();\n+\n+        BluetoothGattCharacteristic c = getDBusBlueZCharacteristicByUUID(characteristic.getUuid().toString());\n+        if (c == null) {\n+            logger.warn(\"Characteristic '{}' is missing on device '{}'.\", characteristic.getUuid(), address);\n+            return false;\n+        }\n+\n+        scheduler.submit(() -> {\n+            try {\n+                c.writeValue(characteristic.getByteValue(), null);\n+                notifyListeners(BluetoothEventType.CHARACTERISTIC_WRITE_COMPLETE, characteristic,\n+                        BluetoothCompletionStatus.SUCCESS);\n+\n+            } catch (DBusException e) {\n+                logger.debug(\"Exception occurred when trying to write characteristic '{}': {}\",\n+                        characteristic.getUuid(), e.getMessage());\n+                notifyListeners(BluetoothEventType.CHARACTERISTIC_WRITE_COMPLETE, characteristic,\n+                        BluetoothCompletionStatus.ERROR);\n+            }\n+        });\n+        return true;\n+    }\n+\n+    @Override\n+    public void onDBusBlueZEvent(BlueZEvent event) {\n+        logger.debug(\"Unsupported event: {}\", event);\n+    }\n+\n+    @Override\n+    public void onServicesResolved(ServicesResolvedEvent event) {\n+        if (event.isResolved()) {\n+            notifyListeners(BluetoothEventType.SERVICES_DISCOVERED);\n+        }\n+    }\n+\n+    @Override\n+    public void onNameUpdate(NameEvent event) {\n+        BluetoothScanNotification notification = new BluetoothScanNotification();\n+        notification.setDeviceName(event.getName());\n+        notifyListeners(BluetoothEventType.SCAN_RECORD, notification);\n+    }\n+\n+    @Override\n+    public void onManufacturerDataUpdate(ManufacturerDataEvent event) {\n+        for (Map.Entry<Short, byte[]> entry : event.getData().entrySet()) {\n+            BluetoothScanNotification notification = new BluetoothScanNotification();\n+            byte[] data = new byte[entry.getValue().length + 2];\n+            data[0] = (byte) (entry.getKey() & 0xFF);\n+            data[1] = (byte) (entry.getKey() >>> 8);\n+\n+            System.arraycopy(entry.getValue(), 0, data, 2, entry.getValue().length);\n+\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"Received manufacturer data for '{}': {}\", address, HexUtils.bytesToHex(data, \" \"));\n+            }\n+\n+            notification.setManufacturerData(data);\n+            notifyListeners(BluetoothEventType.SCAN_RECORD, notification);\n+        }\n+    }\n+\n+    @Override\n+    public void onTxPowerUpdate(TXPowerEvent event) {\n+        this.txPower = (int) event.getTxPower();\n+    }\n+\n+    @Override\n+    public void onCharacteristicNotify(CharacteristicUpdateEvent event) {\n+        // Here it is a bit special - as the event is linked to the DBUS path, not characteristic UUID.\n+        // So we need to find the characteristic by its DBUS path.\n+        BluetoothGattCharacteristic characteristic = getDBusBlueZCharacteristicByDBusPath(event.getDbusPath());\n+        if (characteristic == null) {\n+            logger.info(\"Received a notification for a characteristic not found on device.\");\n+            return;\n+        }\n+        BluetoothCharacteristic c = getCharacteristic(UUID.fromString(characteristic.getUuid()));\n+        if (c != null) {\n+            c.setValue(event.getData());\n+            notifyListeners(BluetoothEventType.CHARACTERISTIC_UPDATED, c, BluetoothCompletionStatus.SUCCESS);\n+            logger.debug(\"Has notified that a characteristic has been updated\");\n+        }\n+    }\n+\n+    @Override\n+    public void onRssiUpdate(RssiEvent event) {\n+        int rssiTmp = event.getRssi();\n+        this.rssi = rssiTmp;\n+        BluetoothScanNotification notification = new BluetoothScanNotification();\n+        notification.setRssi(rssiTmp);\n+        notifyListeners(BluetoothEventType.SCAN_RECORD, notification);\n+    }\n+\n+    @Override\n+    public void onConnectedStatusUpdate(ConnectedEvent event) {\n+        this.connectionState = event.isConnected() ? ConnectionState.CONNECTED : ConnectionState.DISCONNECTED;\n+        notifyListeners(BluetoothEventType.CONNECTION_STATE,\n+                new BluetoothConnectionStatusNotification(connectionState));\n+    }\n+\n+    @Override\n+    public boolean discoverServices() {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return false;\n+        }\n+        if (dev.getGattServices().size() > getServices().size()) {\n+\n+            for (BluetoothGattService dBusBlueZService : dev.getGattServices()) {\n+                BluetoothService service = new BluetoothService(UUID.fromString(dBusBlueZService.getUuid()),\n+                        dBusBlueZService.isPrimary());\n+\n+                for (BluetoothGattCharacteristic dBusBlueZCharacteristic : dBusBlueZService.getGattCharacteristics()) {\n+                    BluetoothCharacteristic characteristic = new BluetoothCharacteristic(\n+                            UUID.fromString(dBusBlueZCharacteristic.getUuid()), 0);\n+\n+                    for (BluetoothGattDescriptor dBusBlueZDescriptor : dBusBlueZCharacteristic.getGattDescriptors()) {\n+                        BluetoothDescriptor descriptor = new BluetoothDescriptor(characteristic,\n+                                UUID.fromString(dBusBlueZDescriptor.getUuid()));\n+                        characteristic.addDescriptor(descriptor);\n+                    }\n+\n+                    service.addCharacteristic(characteristic);\n+                }\n+\n+                addService(service);\n+            }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c2c484c0a68abcdb7f6e511a0635e2dd9353821"}, "originalPosition": 411}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE2OTI1Nw==", "bodyText": "Suggested change", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r511169257", "createdAt": "2020-10-23T21:45:33Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBluetoothDevice.java", "diffHunk": "@@ -0,0 +1,474 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.bluez.exceptions.BluezFailedException;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.freedesktop.dbus.errors.NoReply;\n+import org.freedesktop.dbus.exceptions.DBusException;\n+import org.freedesktop.dbus.exceptions.DBusExecutionException;\n+import org.freedesktop.dbus.types.UInt16;\n+import org.openhab.binding.bluetooth.BaseBluetoothDevice;\n+import org.openhab.binding.bluetooth.BluetoothAddress;\n+import org.openhab.binding.bluetooth.BluetoothCharacteristic;\n+import org.openhab.binding.bluetooth.BluetoothCompletionStatus;\n+import org.openhab.binding.bluetooth.BluetoothDescriptor;\n+import org.openhab.binding.bluetooth.BluetoothService;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEventListener;\n+import org.openhab.binding.bluetooth.bluez.internal.events.CharacteristicUpdateEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ConnectedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ManufacturerDataEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.NameEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.RssiEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.ServicesResolvedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.TXPowerEvent;\n+import org.openhab.binding.bluetooth.notification.BluetoothConnectionStatusNotification;\n+import org.openhab.binding.bluetooth.notification.BluetoothScanNotification;\n+import org.openhab.core.common.ThreadPoolManager;\n+import org.openhab.core.util.HexUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothDevice;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattCharacteristic;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattDescriptor;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothGattService;\n+\n+/**\n+ * Implementation of BluetoothDevice for BlueZ via DBus-BlueZ API\n+ *\n+ * @author Kai Kreuzer - Initial contribution and API\n+ * @author Benjamin Lafois - Replaced tinyB with bluezDbus\n+ *\n+ */\n+@NonNullByDefault\n+public class BlueZBluetoothDevice extends BaseBluetoothDevice implements BlueZEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(BlueZBluetoothDevice.class);\n+\n+    private final ScheduledExecutorService scheduler = ThreadPoolManager.getScheduledPool(\"bluetooth\");\n+\n+    // Device from native lib\n+    private @Nullable BluetoothDevice device = null;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param adapter the bridge handler through which this device is connected\n+     * @param address the Bluetooth address of the device\n+     * @param name the name of the device\n+     */\n+    public BlueZBluetoothDevice(BlueZBridgeHandler adapter, BluetoothAddress address) {\n+        super(adapter, address);\n+        logger.debug(\"Creating DBusBlueZ device with address '{}'\", address);\n+    }\n+\n+    public synchronized void updateBlueZDevice(@Nullable BluetoothDevice blueZDevice) {\n+        if (this.device != null && this.device == blueZDevice) {\n+            return;\n+        }\n+        logger.debug(\"updateBlueZDevice({})\", blueZDevice);\n+\n+        this.device = blueZDevice;\n+\n+        if (blueZDevice == null) {\n+            return;\n+        }\n+\n+        Short rssi = blueZDevice.getRssi();\n+        if (rssi != null) {\n+            this.rssi = rssi.intValue();\n+        }\n+        this.name = blueZDevice.getName();\n+        Map<UInt16, byte[]> manData = blueZDevice.getManufacturerData();\n+        if (manData != null) {\n+            manData.entrySet().stream().map(Map.Entry::getKey).filter(Objects::nonNull).findFirst()\n+                    .ifPresent((UInt16 manufacturerId) ->\n+                    // Convert to unsigned int to match the convention in BluetoothCompanyIdentifiers\n+                    this.manufacturer = manufacturerId.intValue() & 0xFFFF);\n+        }\n+\n+        if (Boolean.TRUE.equals(blueZDevice.isConnected())) {\n+            setConnectionState(ConnectionState.CONNECTED);\n+        }\n+\n+        discoverServices();\n+    }\n+\n+    /**\n+     * Clean up and release memory.\n+     */\n+    @Override\n+    public void dispose() {\n+        BluetoothDevice dev = device;\n+        if (dev != null) {\n+            try {\n+                dev.getAdapter().removeDevice(dev.getRawDevice());\n+            } catch (DBusException ex) {\n+                if (ex.getMessage().contains(\"Does Not Exist\")) {\n+                    // this happens when the underlying device has already been removed\n+                    // but we don't have a way to check if that is the case beforehand so\n+                    // we will just eat the error here.\n+                } else {\n+                    logger.debug(\"Exception occurred when trying to remove inactive device '{}': {}\", address,\n+                            ex.getMessage());\n+                }\n+            } catch (RuntimeException ex) {\n+                // try to catch any other exceptions\n+                logger.debug(\"Exception occurred when trying to remove inactive device '{}': {}\", address,\n+                        ex.getMessage());\n+            }\n+        }\n+    }\n+\n+    private void setConnectionState(ConnectionState state) {\n+        if (this.connectionState != state) {\n+            this.connectionState = state;\n+            notifyListeners(BluetoothEventType.CONNECTION_STATE, new BluetoothConnectionStatusNotification(state));\n+        }\n+    }\n+\n+    @Override\n+    public boolean connect() {\n+        logger.debug(\"Connect({})\", device);\n+\n+        BluetoothDevice dev = device;\n+        if (dev != null) {\n+            if (Boolean.FALSE.equals(dev.isConnected())) {\n+                try {\n+                    boolean ret = dev.connect();\n+                    logger.debug(\"Connect result: {}\", ret);\n+                    return ret;\n+                } catch (NoReply e) {\n+                    // Have to double check because sometimes, exception but still worked\n+                    logger.debug(\"Got a timeout - but sometimes happen. Is Connected ? {}\", dev.isConnected());\n+                    if (Boolean.FALSE.equals(dev.isConnected())) {\n+\n+                        notifyListeners(BluetoothEventType.CONNECTION_STATE,\n+                                new BluetoothConnectionStatusNotification(ConnectionState.DISCONNECTED));\n+                        return false;\n+                    } else {\n+                        return true;\n+                    }\n+                } catch (DBusExecutionException e) {\n+                    // Catch \"software caused connection abort\"\n+                    return false;\n+                } catch (Exception e) {\n+                    logger.warn(\"error occured while trying to connect\", e);\n+                }\n+\n+            } else {\n+                logger.debug(\"Device was already connected\");\n+                // we might be stuck in another state atm so we need to trigger a connected in this case\n+                setConnectionState(ConnectionState.CONNECTED);\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean disconnect() {\n+        BluetoothDevice dev = device;\n+        if (dev != null) {\n+            logger.debug(\"Disconnecting '{}'\", address);\n+            return dev.disconnect();\n+        }\n+        return false;\n+    }\n+\n+    private void ensureConnected() {\n+        BluetoothDevice dev = device;\n+        if (dev == null || !dev.isConnected()) {\n+            throw new IllegalStateException(\"DBusBlueZ device is not set or not connected\");\n+        }\n+    }\n+\n+    private @Nullable BluetoothGattCharacteristic getDBusBlueZCharacteristicByUUID(String uuid) {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return null;\n+        }\n+        for (BluetoothGattService service : dev.getGattServices()) {\n+            for (BluetoothGattCharacteristic c : service.getGattCharacteristics()) {\n+                if (c.getUuid().equalsIgnoreCase(uuid)) {\n+                    return c;\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private @Nullable BluetoothGattCharacteristic getDBusBlueZCharacteristicByDBusPath(String dBusPath) {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return null;\n+        }\n+        for (BluetoothGattService service : dev.getGattServices()) {\n+            if (dBusPath.startsWith(service.getDbusPath())) {\n+                for (BluetoothGattCharacteristic characteristic : service.getGattCharacteristics()) {\n+                    if (dBusPath.startsWith(characteristic.getDbusPath())) {\n+                        return characteristic;\n+                    }\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private @Nullable BluetoothGattDescriptor getDBusBlueZDescriptorByUUID(String uuid) {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return null;\n+        }\n+        for (BluetoothGattService service : dev.getGattServices()) {\n+            for (BluetoothGattCharacteristic c : service.getGattCharacteristics()) {\n+                for (BluetoothGattDescriptor d : c.getGattDescriptors()) {\n+                    if (d.getUuid().equalsIgnoreCase(uuid)) {\n+                        return d;\n+                    }\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public boolean enableNotifications(BluetoothCharacteristic characteristic) {\n+        ensureConnected();\n+\n+        BluetoothGattCharacteristic c = getDBusBlueZCharacteristicByUUID(characteristic.getUuid().toString());\n+        if (c != null) {\n+\n+            try {\n+                c.startNotify();\n+            } catch (DBusException e) {\n+                if (e.getMessage().contains(\"Already notifying\")) {\n+                    return false;\n+                } else if (e.getMessage().contains(\"In Progress\")) {\n+                    // let's retry in 10 seconds\n+                    scheduler.schedule(() -> enableNotifications(characteristic), 10, TimeUnit.SECONDS);\n+                } else {\n+                    logger.warn(\"Exception occurred while activating notifications on '{}'\", address, e);\n+                }\n+            }\n+            return true;\n+        } else {\n+            logger.warn(\"Characteristic '{}' is missing on device '{}'.\", characteristic.getUuid(), address);\n+            return false;\n+        }\n+    }\n+\n+    @Override\n+    public boolean writeCharacteristic(BluetoothCharacteristic characteristic) {\n+        logger.debug(\"writeCharacteristic()\");\n+\n+        ensureConnected();\n+\n+        BluetoothGattCharacteristic c = getDBusBlueZCharacteristicByUUID(characteristic.getUuid().toString());\n+        if (c == null) {\n+            logger.warn(\"Characteristic '{}' is missing on device '{}'.\", characteristic.getUuid(), address);\n+            return false;\n+        }\n+\n+        scheduler.submit(() -> {\n+            try {\n+                c.writeValue(characteristic.getByteValue(), null);\n+                notifyListeners(BluetoothEventType.CHARACTERISTIC_WRITE_COMPLETE, characteristic,\n+                        BluetoothCompletionStatus.SUCCESS);\n+\n+            } catch (DBusException e) {\n+                logger.debug(\"Exception occurred when trying to write characteristic '{}': {}\",\n+                        characteristic.getUuid(), e.getMessage());\n+                notifyListeners(BluetoothEventType.CHARACTERISTIC_WRITE_COMPLETE, characteristic,\n+                        BluetoothCompletionStatus.ERROR);\n+            }\n+        });\n+        return true;\n+    }\n+\n+    @Override\n+    public void onDBusBlueZEvent(BlueZEvent event) {\n+        logger.debug(\"Unsupported event: {}\", event);\n+    }\n+\n+    @Override\n+    public void onServicesResolved(ServicesResolvedEvent event) {\n+        if (event.isResolved()) {\n+            notifyListeners(BluetoothEventType.SERVICES_DISCOVERED);\n+        }\n+    }\n+\n+    @Override\n+    public void onNameUpdate(NameEvent event) {\n+        BluetoothScanNotification notification = new BluetoothScanNotification();\n+        notification.setDeviceName(event.getName());\n+        notifyListeners(BluetoothEventType.SCAN_RECORD, notification);\n+    }\n+\n+    @Override\n+    public void onManufacturerDataUpdate(ManufacturerDataEvent event) {\n+        for (Map.Entry<Short, byte[]> entry : event.getData().entrySet()) {\n+            BluetoothScanNotification notification = new BluetoothScanNotification();\n+            byte[] data = new byte[entry.getValue().length + 2];\n+            data[0] = (byte) (entry.getKey() & 0xFF);\n+            data[1] = (byte) (entry.getKey() >>> 8);\n+\n+            System.arraycopy(entry.getValue(), 0, data, 2, entry.getValue().length);\n+\n+            if (logger.isDebugEnabled()) {\n+                logger.debug(\"Received manufacturer data for '{}': {}\", address, HexUtils.bytesToHex(data, \" \"));\n+            }\n+\n+            notification.setManufacturerData(data);\n+            notifyListeners(BluetoothEventType.SCAN_RECORD, notification);\n+        }\n+    }\n+\n+    @Override\n+    public void onTxPowerUpdate(TXPowerEvent event) {\n+        this.txPower = (int) event.getTxPower();\n+    }\n+\n+    @Override\n+    public void onCharacteristicNotify(CharacteristicUpdateEvent event) {\n+        // Here it is a bit special - as the event is linked to the DBUS path, not characteristic UUID.\n+        // So we need to find the characteristic by its DBUS path.\n+        BluetoothGattCharacteristic characteristic = getDBusBlueZCharacteristicByDBusPath(event.getDbusPath());\n+        if (characteristic == null) {\n+            logger.info(\"Received a notification for a characteristic not found on device.\");\n+            return;\n+        }\n+        BluetoothCharacteristic c = getCharacteristic(UUID.fromString(characteristic.getUuid()));\n+        if (c != null) {\n+            c.setValue(event.getData());\n+            notifyListeners(BluetoothEventType.CHARACTERISTIC_UPDATED, c, BluetoothCompletionStatus.SUCCESS);\n+            logger.debug(\"Has notified that a characteristic has been updated\");\n+        }\n+    }\n+\n+    @Override\n+    public void onRssiUpdate(RssiEvent event) {\n+        int rssiTmp = event.getRssi();\n+        this.rssi = rssiTmp;\n+        BluetoothScanNotification notification = new BluetoothScanNotification();\n+        notification.setRssi(rssiTmp);\n+        notifyListeners(BluetoothEventType.SCAN_RECORD, notification);\n+    }\n+\n+    @Override\n+    public void onConnectedStatusUpdate(ConnectedEvent event) {\n+        this.connectionState = event.isConnected() ? ConnectionState.CONNECTED : ConnectionState.DISCONNECTED;\n+        notifyListeners(BluetoothEventType.CONNECTION_STATE,\n+                new BluetoothConnectionStatusNotification(connectionState));\n+    }\n+\n+    @Override\n+    public boolean discoverServices() {\n+        BluetoothDevice dev = device;\n+        if (dev == null) {\n+            return false;\n+        }\n+        if (dev.getGattServices().size() > getServices().size()) {\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c2c484c0a68abcdb7f6e511a0635e2dd9353821"}, "originalPosition": 391}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE2OTUyMg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    logger.debug(\"Creating BlueZ adapter with address '{}'\", adapterAddress);\n          \n          \n            \n            \n          \n          \n            \n                    updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.CONFIGURATION_PENDING, \"Initializing\");\n          \n          \n            \n            \n          \n          \n            \n                    deviceManagerFactory.getPropertiesChangedHandler().addListener(this);\n          \n          \n            \n            \n          \n          \n            \n                    discoveryJob = scheduler.scheduleWithFixedDelay(this::initializeAndRefreshDevices, 5, 10, TimeUnit.SECONDS);\n          \n          \n            \n                    logger.debug(\"Creating BlueZ adapter with address '{}'\", adapterAddress);\n          \n          \n            \n                    updateStatus(ThingStatus.UNKNOWN);\n          \n          \n            \n                    deviceManagerFactory.getPropertiesChangedHandler().addListener(this);\n          \n          \n            \n                    discoveryJob = scheduler.scheduleWithFixedDelay(this::initializeAndRefreshDevices, 5, 10, TimeUnit.SECONDS);", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r511169522", "createdAt": "2020-10-23T21:46:18Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBridgeHandler.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.List;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bluetooth.AbstractBluetoothBridgeHandler;\n+import org.openhab.binding.bluetooth.BluetoothAddress;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterDiscoveringChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterPoweredChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEventListener;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothAdapter;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothDevice;\n+\n+/**\n+ * The {@link BlueZBridgeHandler} is responsible for talking to the BlueZ stack, using DBus Unix Socket.\n+ * This Binding does not use any JNI.\n+ * It provides a private interface for {@link BlueZBluetoothDevice}s to access the stack and provides top\n+ * level adaptor functionality for scanning and arbitration.\n+ *\n+ * @author Kai Kreuzer - Initial contribution and API\n+ * @author Hilbrand Bouwkamp - Simplified calling scan and better handling manual scanning\n+ * @author Connor Petty - Simplified device scan logic\n+ * @author Benjamin Lafois - Replaced tinyB with bluezDbus\n+ *\n+ */\n+@NonNullByDefault\n+public class BlueZBridgeHandler extends AbstractBluetoothBridgeHandler<BlueZBluetoothDevice>\n+        implements BlueZEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(BlueZBridgeHandler.class);\n+\n+    // ADAPTER from BlueZ-DBus Library\n+    private @Nullable BluetoothAdapter adapter;\n+\n+    // Our BT address\n+    private @Nullable BluetoothAddress adapterAddress;\n+\n+    private @Nullable ScheduledFuture<?> discoveryJob;\n+\n+    private final DeviceManagerFactory deviceManagerFactory;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param bridge the bridge definition for this handler\n+     */\n+    public BlueZBridgeHandler(Bridge bridge, DeviceManagerFactory deviceManagerFactory) {\n+        super(bridge);\n+        this.deviceManagerFactory = deviceManagerFactory;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+\n+        // Load configuration\n+        final BlueZAdapterConfiguration configuration = getConfigAs(BlueZAdapterConfiguration.class);\n+        String addr = configuration.address;\n+        if (addr != null) {\n+            this.adapterAddress = new BluetoothAddress(addr.toUpperCase());\n+        } else {\n+            // If configuration does not contain adapter address to use, exit with error.\n+            logger.info(\"Adapter MAC address not provided\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"address not set\");\n+            return;\n+        }\n+\n+        logger.debug(\"Creating BlueZ adapter with address '{}'\", adapterAddress);\n+\n+        updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.CONFIGURATION_PENDING, \"Initializing\");\n+\n+        deviceManagerFactory.getPropertiesChangedHandler().addListener(this);\n+\n+        discoveryJob = scheduler.scheduleWithFixedDelay(this::initializeAndRefreshDevices, 5, 10, TimeUnit.SECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c2c484c0a68abcdb7f6e511a0635e2dd9353821"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE3MDIzNA==", "bodyText": "As far as I know, there isn't such a thing as duty cycle for BT - that's only a regulation on 868/900MHz. Better put detail to NONE.", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r511170234", "createdAt": "2020-10-23T21:48:36Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBridgeHandler.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.List;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bluetooth.AbstractBluetoothBridgeHandler;\n+import org.openhab.binding.bluetooth.BluetoothAddress;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterDiscoveringChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterPoweredChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEventListener;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothAdapter;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothDevice;\n+\n+/**\n+ * The {@link BlueZBridgeHandler} is responsible for talking to the BlueZ stack, using DBus Unix Socket.\n+ * This Binding does not use any JNI.\n+ * It provides a private interface for {@link BlueZBluetoothDevice}s to access the stack and provides top\n+ * level adaptor functionality for scanning and arbitration.\n+ *\n+ * @author Kai Kreuzer - Initial contribution and API\n+ * @author Hilbrand Bouwkamp - Simplified calling scan and better handling manual scanning\n+ * @author Connor Petty - Simplified device scan logic\n+ * @author Benjamin Lafois - Replaced tinyB with bluezDbus\n+ *\n+ */\n+@NonNullByDefault\n+public class BlueZBridgeHandler extends AbstractBluetoothBridgeHandler<BlueZBluetoothDevice>\n+        implements BlueZEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(BlueZBridgeHandler.class);\n+\n+    // ADAPTER from BlueZ-DBus Library\n+    private @Nullable BluetoothAdapter adapter;\n+\n+    // Our BT address\n+    private @Nullable BluetoothAddress adapterAddress;\n+\n+    private @Nullable ScheduledFuture<?> discoveryJob;\n+\n+    private final DeviceManagerFactory deviceManagerFactory;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param bridge the bridge definition for this handler\n+     */\n+    public BlueZBridgeHandler(Bridge bridge, DeviceManagerFactory deviceManagerFactory) {\n+        super(bridge);\n+        this.deviceManagerFactory = deviceManagerFactory;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+\n+        // Load configuration\n+        final BlueZAdapterConfiguration configuration = getConfigAs(BlueZAdapterConfiguration.class);\n+        String addr = configuration.address;\n+        if (addr != null) {\n+            this.adapterAddress = new BluetoothAddress(addr.toUpperCase());\n+        } else {\n+            // If configuration does not contain adapter address to use, exit with error.\n+            logger.info(\"Adapter MAC address not provided\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"address not set\");\n+            return;\n+        }\n+\n+        logger.debug(\"Creating BlueZ adapter with address '{}'\", adapterAddress);\n+\n+        updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.CONFIGURATION_PENDING, \"Initializing\");\n+\n+        deviceManagerFactory.getPropertiesChangedHandler().addListener(this);\n+\n+        discoveryJob = scheduler.scheduleWithFixedDelay(this::initializeAndRefreshDevices, 5, 10, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        deviceManagerFactory.getPropertiesChangedHandler().removeListener(this);\n+        logger.debug(\"Termination of DBus BlueZ handler\");\n+\n+        Future<?> job = discoveryJob;\n+        if (job != null) {\n+            job.cancel(false);\n+            discoveryJob = null;\n+        }\n+\n+        BluetoothAdapter localAdatper = this.adapter;\n+        if (localAdatper != null) {\n+            localAdatper.stopDiscovery();\n+            this.adapter = null;\n+        }\n+\n+        super.dispose();\n+    }\n+\n+    private @Nullable BluetoothAdapter prepareAdapter(DeviceManagerWrapper deviceManager) {\n+        // next lets check if we can find our adapter in the manager.\n+        BluetoothAdapter localAdapter = adapter;\n+        if (localAdapter == null) {\n+            BluetoothAddress localAddress = adapterAddress;\n+            if (localAddress != null) {\n+                localAdapter = adapter = deviceManager.getAdapter(localAddress);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No adapter address provided\");\n+                return null;\n+            }\n+        }\n+        if (localAdapter == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Native adapter could not be found for address '\" + adapterAddress + \"'\");\n+            return null;\n+        }\n+        // now lets confirm that the adapter is powered\n+        if (!localAdapter.isPowered()) {\n+            localAdapter.setPowered(true);\n+            // give the device some time to power on\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.DUTY_CYCLE,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c2c484c0a68abcdb7f6e511a0635e2dd9353821"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE3MTIyNw==", "bodyText": "Why OFFLINE? If you can start discovery on it, it seems to be available, i.e. ONLINE?", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r511171227", "createdAt": "2020-10-23T21:51:41Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBridgeHandler.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.List;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bluetooth.AbstractBluetoothBridgeHandler;\n+import org.openhab.binding.bluetooth.BluetoothAddress;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterDiscoveringChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterPoweredChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEventListener;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothAdapter;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothDevice;\n+\n+/**\n+ * The {@link BlueZBridgeHandler} is responsible for talking to the BlueZ stack, using DBus Unix Socket.\n+ * This Binding does not use any JNI.\n+ * It provides a private interface for {@link BlueZBluetoothDevice}s to access the stack and provides top\n+ * level adaptor functionality for scanning and arbitration.\n+ *\n+ * @author Kai Kreuzer - Initial contribution and API\n+ * @author Hilbrand Bouwkamp - Simplified calling scan and better handling manual scanning\n+ * @author Connor Petty - Simplified device scan logic\n+ * @author Benjamin Lafois - Replaced tinyB with bluezDbus\n+ *\n+ */\n+@NonNullByDefault\n+public class BlueZBridgeHandler extends AbstractBluetoothBridgeHandler<BlueZBluetoothDevice>\n+        implements BlueZEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(BlueZBridgeHandler.class);\n+\n+    // ADAPTER from BlueZ-DBus Library\n+    private @Nullable BluetoothAdapter adapter;\n+\n+    // Our BT address\n+    private @Nullable BluetoothAddress adapterAddress;\n+\n+    private @Nullable ScheduledFuture<?> discoveryJob;\n+\n+    private final DeviceManagerFactory deviceManagerFactory;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param bridge the bridge definition for this handler\n+     */\n+    public BlueZBridgeHandler(Bridge bridge, DeviceManagerFactory deviceManagerFactory) {\n+        super(bridge);\n+        this.deviceManagerFactory = deviceManagerFactory;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+\n+        // Load configuration\n+        final BlueZAdapterConfiguration configuration = getConfigAs(BlueZAdapterConfiguration.class);\n+        String addr = configuration.address;\n+        if (addr != null) {\n+            this.adapterAddress = new BluetoothAddress(addr.toUpperCase());\n+        } else {\n+            // If configuration does not contain adapter address to use, exit with error.\n+            logger.info(\"Adapter MAC address not provided\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"address not set\");\n+            return;\n+        }\n+\n+        logger.debug(\"Creating BlueZ adapter with address '{}'\", adapterAddress);\n+\n+        updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.CONFIGURATION_PENDING, \"Initializing\");\n+\n+        deviceManagerFactory.getPropertiesChangedHandler().addListener(this);\n+\n+        discoveryJob = scheduler.scheduleWithFixedDelay(this::initializeAndRefreshDevices, 5, 10, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        deviceManagerFactory.getPropertiesChangedHandler().removeListener(this);\n+        logger.debug(\"Termination of DBus BlueZ handler\");\n+\n+        Future<?> job = discoveryJob;\n+        if (job != null) {\n+            job.cancel(false);\n+            discoveryJob = null;\n+        }\n+\n+        BluetoothAdapter localAdatper = this.adapter;\n+        if (localAdatper != null) {\n+            localAdatper.stopDiscovery();\n+            this.adapter = null;\n+        }\n+\n+        super.dispose();\n+    }\n+\n+    private @Nullable BluetoothAdapter prepareAdapter(DeviceManagerWrapper deviceManager) {\n+        // next lets check if we can find our adapter in the manager.\n+        BluetoothAdapter localAdapter = adapter;\n+        if (localAdapter == null) {\n+            BluetoothAddress localAddress = adapterAddress;\n+            if (localAddress != null) {\n+                localAdapter = adapter = deviceManager.getAdapter(localAddress);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No adapter address provided\");\n+                return null;\n+            }\n+        }\n+        if (localAdapter == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Native adapter could not be found for address '\" + adapterAddress + \"'\");\n+            return null;\n+        }\n+        // now lets confirm that the adapter is powered\n+        if (!localAdapter.isPowered()) {\n+            localAdapter.setPowered(true);\n+            // give the device some time to power on\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.DUTY_CYCLE,\n+                    \"Adapter is not powered, attempting to turn on...\");\n+            return null;\n+        }\n+\n+        // now lets make sure that discovery is turned on\n+        if (!Boolean.TRUE.equals(localAdapter.isDiscovering())) {\n+            // we will check for devices next time around\n+            localAdapter.startDiscovery();\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.DUTY_CYCLE, \"Starting discovery\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c2c484c0a68abcdb7f6e511a0635e2dd9353821"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE3MTMxNA==", "bodyText": "can this line be removed?", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r511171314", "createdAt": "2020-10-23T21:51:56Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBridgeHandler.java", "diffHunk": "@@ -0,0 +1,241 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.List;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bluetooth.AbstractBluetoothBridgeHandler;\n+import org.openhab.binding.bluetooth.BluetoothAddress;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterDiscoveringChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterPoweredChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEventListener;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothAdapter;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothDevice;\n+\n+/**\n+ * The {@link BlueZBridgeHandler} is responsible for talking to the BlueZ stack, using DBus Unix Socket.\n+ * This Binding does not use any JNI.\n+ * It provides a private interface for {@link BlueZBluetoothDevice}s to access the stack and provides top\n+ * level adaptor functionality for scanning and arbitration.\n+ *\n+ * @author Kai Kreuzer - Initial contribution and API\n+ * @author Hilbrand Bouwkamp - Simplified calling scan and better handling manual scanning\n+ * @author Connor Petty - Simplified device scan logic\n+ * @author Benjamin Lafois - Replaced tinyB with bluezDbus\n+ *\n+ */\n+@NonNullByDefault\n+public class BlueZBridgeHandler extends AbstractBluetoothBridgeHandler<BlueZBluetoothDevice>\n+        implements BlueZEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(BlueZBridgeHandler.class);\n+\n+    // ADAPTER from BlueZ-DBus Library\n+    private @Nullable BluetoothAdapter adapter;\n+\n+    // Our BT address\n+    private @Nullable BluetoothAddress adapterAddress;\n+\n+    private @Nullable ScheduledFuture<?> discoveryJob;\n+\n+    private final DeviceManagerFactory deviceManagerFactory;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param bridge the bridge definition for this handler\n+     */\n+    public BlueZBridgeHandler(Bridge bridge, DeviceManagerFactory deviceManagerFactory) {\n+        super(bridge);\n+        this.deviceManagerFactory = deviceManagerFactory;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+\n+        // Load configuration\n+        final BlueZAdapterConfiguration configuration = getConfigAs(BlueZAdapterConfiguration.class);\n+        String addr = configuration.address;\n+        if (addr != null) {\n+            this.adapterAddress = new BluetoothAddress(addr.toUpperCase());\n+        } else {\n+            // If configuration does not contain adapter address to use, exit with error.\n+            logger.info(\"Adapter MAC address not provided\");\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"address not set\");\n+            return;\n+        }\n+\n+        logger.debug(\"Creating BlueZ adapter with address '{}'\", adapterAddress);\n+\n+        updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.CONFIGURATION_PENDING, \"Initializing\");\n+\n+        deviceManagerFactory.getPropertiesChangedHandler().addListener(this);\n+\n+        discoveryJob = scheduler.scheduleWithFixedDelay(this::initializeAndRefreshDevices, 5, 10, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        deviceManagerFactory.getPropertiesChangedHandler().removeListener(this);\n+        logger.debug(\"Termination of DBus BlueZ handler\");\n+\n+        Future<?> job = discoveryJob;\n+        if (job != null) {\n+            job.cancel(false);\n+            discoveryJob = null;\n+        }\n+\n+        BluetoothAdapter localAdatper = this.adapter;\n+        if (localAdatper != null) {\n+            localAdatper.stopDiscovery();\n+            this.adapter = null;\n+        }\n+\n+        super.dispose();\n+    }\n+\n+    private @Nullable BluetoothAdapter prepareAdapter(DeviceManagerWrapper deviceManager) {\n+        // next lets check if we can find our adapter in the manager.\n+        BluetoothAdapter localAdapter = adapter;\n+        if (localAdapter == null) {\n+            BluetoothAddress localAddress = adapterAddress;\n+            if (localAddress != null) {\n+                localAdapter = adapter = deviceManager.getAdapter(localAddress);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No adapter address provided\");\n+                return null;\n+            }\n+        }\n+        if (localAdapter == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Native adapter could not be found for address '\" + adapterAddress + \"'\");\n+            return null;\n+        }\n+        // now lets confirm that the adapter is powered\n+        if (!localAdapter.isPowered()) {\n+            localAdapter.setPowered(true);\n+            // give the device some time to power on\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.DUTY_CYCLE,\n+                    \"Adapter is not powered, attempting to turn on...\");\n+            return null;\n+        }\n+\n+        // now lets make sure that discovery is turned on\n+        if (!Boolean.TRUE.equals(localAdapter.isDiscovering())) {\n+            // we will check for devices next time around\n+            localAdapter.startDiscovery();\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.DUTY_CYCLE, \"Starting discovery\");\n+            return null;\n+        }\n+        return localAdapter;\n+    }\n+\n+    private void initializeAndRefreshDevices() {\n+        logger.debug(\"initializeAndRefreshDevice()\");\n+\n+        try {\n+            // first check if the device manager is ready\n+            DeviceManagerWrapper deviceManager = deviceManagerFactory.getDeviceManager();\n+            if (deviceManager == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Bluez DeviceManager not available yet.\");\n+                return;\n+            }\n+\n+            BluetoothAdapter adapter = prepareAdapter(deviceManager);\n+            if (adapter == null) {\n+                // adapter isn't prepared yet\n+                return;\n+            }\n+\n+            // now lets refresh devices\n+            List<BluetoothDevice> bluezDevices = deviceManager.getDevices(adapter);\n+            logger.debug(\"Found {} Bluetooth devices.\", bluezDevices.size());\n+            for (BluetoothDevice bluezDevice : bluezDevices) {\n+                // logger.debug(\"discovered device {}\", bluezDevice);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c2c484c0a68abcdb7f6e511a0635e2dd9353821"}, "originalPosition": 178}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE3MjQzOA==", "bodyText": "Could you please add a one line JavaDoc description here and in all the classes below with the same empty JavaDoc header?", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r511172438", "createdAt": "2020-10-23T21:55:10Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/events/CharacteristicUpdateEvent.java", "diffHunk": "@@ -0,0 +1,40 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal.events;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ *", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c2c484c0a68abcdb7f6e511a0635e2dd9353821"}, "originalPosition": 18}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8fd4da231bd4cef02f17b811d0226b3dcf6d54fc", "author": {"user": null}, "url": "https://github.com/openhab/openhab-addons/commit/8fd4da231bd4cef02f17b811d0226b3dcf6d54fc", "committedDate": "2020-10-24T00:05:53Z", "message": "Address review comments\n\nSigned-off-by: Connor Petty <mistercpp2000+gitsignoff@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aecda9ccb8b030a0133f717c528a429cbe8ee5d0", "author": {"user": null}, "url": "https://github.com/openhab/openhab-addons/commit/aecda9ccb8b030a0133f717c528a429cbe8ee5d0", "committedDate": "2020-10-24T00:31:19Z", "message": "fix comment\n\nSigned-off-by: Connor Petty <mistercpp2000+gitsignoff@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "00984dbaccb9f9fa3e6fd380ee55bdd7d5ba65d9", "author": {"user": null}, "url": "https://github.com/openhab/openhab-addons/commit/00984dbaccb9f9fa3e6fd380ee55bdd7d5ba65d9", "committedDate": "2020-10-24T01:43:11Z", "message": "Fix library version in NOTICE\n\nSigned-off-by: Connor Petty <mistercpp2000+gitsignoff@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2MjM3NTc3", "url": "https://github.com/openhab/openhab-addons/pull/8819#pullrequestreview-516237577", "createdAt": "2020-10-24T08:14:31Z", "commit": {"oid": "00984dbaccb9f9fa3e6fd380ee55bdd7d5ba65d9"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQwODoxNDozMVrOHnpd5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQwODoyMDo1OFrOHnpgGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMzNTkxMA==", "bodyText": "It seems you had missed this change - CONFIGURATION_PENDING is not a valid status detail here.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.CONFIGURATION_PENDING, \"Initializing\");\n          \n          \n            \n                    updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.NONE, \"Initializing\");", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r511335910", "createdAt": "2020-10-24T08:14:31Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBridgeHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.List;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bluetooth.AbstractBluetoothBridgeHandler;\n+import org.openhab.binding.bluetooth.BluetoothAddress;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterDiscoveringChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterPoweredChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEventListener;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothAdapter;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothDevice;\n+\n+/**\n+ * The {@link BlueZBridgeHandler} is responsible for talking to the BlueZ stack, using DBus Unix Socket.\n+ * This Binding does not use any JNI.\n+ * It provides a private interface for {@link BlueZBluetoothDevice}s to access the stack and provides top\n+ * level adaptor functionality for scanning and arbitration.\n+ *\n+ * @author Kai Kreuzer - Initial contribution and API\n+ * @author Hilbrand Bouwkamp - Simplified calling scan and better handling manual scanning\n+ * @author Connor Petty - Simplified device scan logic\n+ * @author Benjamin Lafois - Replaced tinyB with bluezDbus\n+ *\n+ */\n+@NonNullByDefault\n+public class BlueZBridgeHandler extends AbstractBluetoothBridgeHandler<BlueZBluetoothDevice>\n+        implements BlueZEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(BlueZBridgeHandler.class);\n+\n+    // ADAPTER from BlueZ-DBus Library\n+    private @Nullable BluetoothAdapter adapter;\n+\n+    // Our BT address\n+    private @Nullable BluetoothAddress adapterAddress;\n+\n+    private @Nullable ScheduledFuture<?> discoveryJob;\n+\n+    private final DeviceManagerFactory deviceManagerFactory;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param bridge the bridge definition for this handler\n+     */\n+    public BlueZBridgeHandler(Bridge bridge, DeviceManagerFactory deviceManagerFactory) {\n+        super(bridge);\n+        this.deviceManagerFactory = deviceManagerFactory;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+\n+        // Load configuration\n+        final BlueZAdapterConfiguration configuration = getConfigAs(BlueZAdapterConfiguration.class);\n+        String addr = configuration.address;\n+        if (addr != null) {\n+            this.adapterAddress = new BluetoothAddress(addr.toUpperCase());\n+        } else {\n+            // If configuration does not contain adapter address to use, exit with error.\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"address not set\");\n+            return;\n+        }\n+\n+        logger.debug(\"Creating BlueZ adapter with address '{}'\", adapterAddress);\n+        updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.CONFIGURATION_PENDING, \"Initializing\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00984dbaccb9f9fa3e6fd380ee55bdd7d5ba65d9"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTMzNjQ3Mg==", "bodyText": "I'm still not clear why it is OFFLINE here.\nThe message \"starting discovery\" seems to suggest that we are still initializing, so I would simply stay in UNKNOWN status that moment (until we know if the outcome is successful or not).\nIf I misunderstand the message and the comment above (\"make sure that discovery is turned on\") is actually correct by saying that we have discovered a situation where we expect discovery being enabled, while it isn't and we consider this a \"permanent\" issue with the adapter, then OFFLINE is indeed the right choice.\nCould you help me understand which one is right here?", "url": "https://github.com/openhab/openhab-addons/pull/8819#discussion_r511336472", "createdAt": "2020-10-24T08:20:58Z", "author": {"login": "kaikreuzer"}, "path": "bundles/org.openhab.binding.bluetooth.bluez/src/main/java/org/openhab/binding/bluetooth/bluez/internal/BlueZBridgeHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.bluetooth.bluez.internal;\n+\n+import java.util.List;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.bluetooth.AbstractBluetoothBridgeHandler;\n+import org.openhab.binding.bluetooth.BluetoothAddress;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterDiscoveringChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.AdapterPoweredChangedEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEvent;\n+import org.openhab.binding.bluetooth.bluez.internal.events.BlueZEventListener;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothAdapter;\n+import com.github.hypfvieh.bluetooth.wrapper.BluetoothDevice;\n+\n+/**\n+ * The {@link BlueZBridgeHandler} is responsible for talking to the BlueZ stack, using DBus Unix Socket.\n+ * This Binding does not use any JNI.\n+ * It provides a private interface for {@link BlueZBluetoothDevice}s to access the stack and provides top\n+ * level adaptor functionality for scanning and arbitration.\n+ *\n+ * @author Kai Kreuzer - Initial contribution and API\n+ * @author Hilbrand Bouwkamp - Simplified calling scan and better handling manual scanning\n+ * @author Connor Petty - Simplified device scan logic\n+ * @author Benjamin Lafois - Replaced tinyB with bluezDbus\n+ *\n+ */\n+@NonNullByDefault\n+public class BlueZBridgeHandler extends AbstractBluetoothBridgeHandler<BlueZBluetoothDevice>\n+        implements BlueZEventListener {\n+\n+    private final Logger logger = LoggerFactory.getLogger(BlueZBridgeHandler.class);\n+\n+    // ADAPTER from BlueZ-DBus Library\n+    private @Nullable BluetoothAdapter adapter;\n+\n+    // Our BT address\n+    private @Nullable BluetoothAddress adapterAddress;\n+\n+    private @Nullable ScheduledFuture<?> discoveryJob;\n+\n+    private final DeviceManagerFactory deviceManagerFactory;\n+\n+    /**\n+     * Constructor\n+     *\n+     * @param bridge the bridge definition for this handler\n+     */\n+    public BlueZBridgeHandler(Bridge bridge, DeviceManagerFactory deviceManagerFactory) {\n+        super(bridge);\n+        this.deviceManagerFactory = deviceManagerFactory;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        super.initialize();\n+\n+        // Load configuration\n+        final BlueZAdapterConfiguration configuration = getConfigAs(BlueZAdapterConfiguration.class);\n+        String addr = configuration.address;\n+        if (addr != null) {\n+            this.adapterAddress = new BluetoothAddress(addr.toUpperCase());\n+        } else {\n+            // If configuration does not contain adapter address to use, exit with error.\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"address not set\");\n+            return;\n+        }\n+\n+        logger.debug(\"Creating BlueZ adapter with address '{}'\", adapterAddress);\n+        updateStatus(ThingStatus.UNKNOWN, ThingStatusDetail.CONFIGURATION_PENDING, \"Initializing\");\n+        deviceManagerFactory.getPropertiesChangedHandler().addListener(this);\n+        discoveryJob = scheduler.scheduleWithFixedDelay(this::initializeAndRefreshDevices, 5, 10, TimeUnit.SECONDS);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        deviceManagerFactory.getPropertiesChangedHandler().removeListener(this);\n+        logger.debug(\"Termination of DBus BlueZ handler\");\n+\n+        Future<?> job = discoveryJob;\n+        if (job != null) {\n+            job.cancel(false);\n+            discoveryJob = null;\n+        }\n+\n+        BluetoothAdapter localAdatper = this.adapter;\n+        if (localAdatper != null) {\n+            localAdatper.stopDiscovery();\n+            this.adapter = null;\n+        }\n+\n+        super.dispose();\n+    }\n+\n+    private @Nullable BluetoothAdapter prepareAdapter(DeviceManagerWrapper deviceManager) {\n+        // next lets check if we can find our adapter in the manager.\n+        BluetoothAdapter localAdapter = adapter;\n+        if (localAdapter == null) {\n+            BluetoothAddress localAddress = adapterAddress;\n+            if (localAddress != null) {\n+                localAdapter = adapter = deviceManager.getAdapter(localAddress);\n+            } else {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"No adapter address provided\");\n+                return null;\n+            }\n+        }\n+        if (localAdapter == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Native adapter could not be found for address '\" + adapterAddress + \"'\");\n+            return null;\n+        }\n+        // now lets confirm that the adapter is powered\n+        if (!localAdapter.isPowered()) {\n+            localAdapter.setPowered(true);\n+            // give the device some time to power on\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE,\n+                    \"Adapter is not powered, attempting to turn on...\");\n+            return null;\n+        }\n+\n+        // now lets make sure that discovery is turned on\n+        if (!localAdapter.startDiscovery()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Starting discovery\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00984dbaccb9f9fa3e6fd380ee55bdd7d5ba65d9"}, "originalPosition": 144}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ca8cdab74d811957bb81481cd138616390db35ad", "author": {"user": null}, "url": "https://github.com/openhab/openhab-addons/commit/ca8cdab74d811957bb81481cd138616390db35ad", "committedDate": "2020-10-24T16:31:38Z", "message": "More review suggestions\n\nSigned-off-by: Connor Petty <mistercpp2000+gitsignoff@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4f31cba23c2929aa6c027e4af335058a9b64f8c5", "author": {"user": null}, "url": "https://github.com/openhab/openhab-addons/commit/4f31cba23c2929aa6c027e4af335058a9b64f8c5", "committedDate": "2020-10-25T00:43:50Z", "message": "Review changes\n\nSigned-off-by: Connor Petty <mistercpp2000+gitsignoff@gmail.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2MzQ1OTM0", "url": "https://github.com/openhab/openhab-addons/pull/8819#pullrequestreview-516345934", "createdAt": "2020-10-25T10:48:50Z", "commit": {"oid": "4f31cba23c2929aa6c027e4af335058a9b64f8c5"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4338, "cost": 1, "resetAt": "2021-10-28T20:13:43Z"}}}