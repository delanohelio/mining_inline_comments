{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc5MzUzNDM4", "number": 8394, "title": "[yioremote]YIO Remote Binding initial contribution", "bodyText": "Developing YIO Remote Binding\nPlease have  review on my first Binding for openhab.\nThis binding is for the YIO Remote to send recieve IR codes via the Dock. See here for more Details https://www.yio-remote.com/ and https://community.yio-remote.com/t/ir-tv-remote-integration/414/27.\nUnfortunately the YIO Remote is currently under developing the code can not implement everything and will be changed during the development regularly. Also the websocket commands are not completely integrated inthe YIO Dock therfore some work around is be done to avoid issues.\nImplementation of the thing is\n<parameter name=\"yiodockhostip\" type=\"text\" required=\"true\">\n                <label>IP Address of the YIO Dock</label>\n                <description>IP Address of the YIO Dock</description>\n            </parameter>\n            <parameter name=\"yiodockaccesstoken\" type=\"text\" required=\"true\">\n                <label>Access token for the YIO Dock</label>\n                <description>Access token for the YIO Dock</description>\n            </parameter>\n\nImplementation of the items is\nString sendircode \"IR Code for sending via the dock[%s]\" {channel=\"yioremote:yioremote:<thingid>:input#yiodocksendircode\"}\nSwitch irreceiverswitch \"Switch for Dis-/enabling the IR Reciever in the DOCK\" {channel=\"yioremote:yioremote:<thingid>:input#yiodockreceiverswitch\"}\nString receivedstatus  \"Status of the YIO Dock or displaying the IR CODE received[%s]\" {channel=\"yioremote:yioremote:<thingid>:output#yiodockstatus\"}\n\nThread about the Add-on in the openHAB community:\nhttps://community.openhab.org/t/beta-testing-and-coding-tips-needed-for-new-yio-remote-binding/104539/4", "createdAt": "2020-09-04T06:48:28Z", "url": "https://github.com/openhab/openhab-addons/pull/8394", "merged": true, "mergeCommit": {"oid": "9cb4601c9cc7b1fec3afb49ab2479758150862a5"}, "closed": true, "closedAt": "2020-09-19T20:48:05Z", "author": {"login": "miloit"}, "timelineItems": {"totalCount": 81, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdG94OQAFqTQ4NDQ1OTAwNg==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdKgfdSAFqTQ5MjE1NTI5Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0NDU5MDA2", "url": "https://github.com/openhab/openhab-addons/pull/8394#pullrequestreview-484459006", "createdAt": "2020-09-08T20:11:14Z", "commit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 43, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMDoxMToxNFrOHOsYIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQyMDo0NTowM1rOHOtZOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE2OTE4Nw==", "bodyText": "Can you mention the Thing Type ID?", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485169187", "createdAt": "2020-09-08T20:11:14Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/README.md", "diffHunk": "@@ -0,0 +1,59 @@\n+# YIOremote Binding\n+\n+This binding will control a YIO Dock/Remote combination. YIO Remote/Dock is a smart home solution that includes an IP based remote. More information can be found at [yio-remote](https://www.yio-remote.com/) or in the forums at [yio-remote](https://community.yio-remote.com/). \n+\n+This binding has been designed to compliment the YIO websocket Transport Protocol.\n+\n+Since this binding allows actual you to trigger IR send/receive actions on YIO Dock, this allows you to use the YIO Dock as an IR solution to openHAB and even learn new IR codes from your remotes. In other words, if the IR code is known then openHAB can use the YIO Dock to control that Device regardless if there is an openHAB binding for it or not.\n+\n+## Supported Things\n+\n+* Thing: YIO Dock.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE2OTU0Mg==", "bodyText": "The \"yiodock\" prefix could be removed as it is redundant for all config parameters/channels.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485169542", "createdAt": "2020-09-08T20:11:59Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/README.md", "diffHunk": "@@ -0,0 +1,59 @@\n+# YIOremote Binding\n+\n+This binding will control a YIO Dock/Remote combination. YIO Remote/Dock is a smart home solution that includes an IP based remote. More information can be found at [yio-remote](https://www.yio-remote.com/) or in the forums at [yio-remote](https://community.yio-remote.com/). \n+\n+This binding has been designed to compliment the YIO websocket Transport Protocol.\n+\n+Since this binding allows actual you to trigger IR send/receive actions on YIO Dock, this allows you to use the YIO Dock as an IR solution to openHAB and even learn new IR codes from your remotes. In other words, if the IR code is known then openHAB can use the YIO Dock to control that Device regardless if there is an openHAB binding for it or not.\n+\n+## Supported Things\n+\n+* Thing: YIO Dock.\n+\n+The following are the configurations available to each of the bridges/things:\n+\n+### YIO Dock\n+\n+| Name                 | Type    | Required | Default | Description                                                                                                    |\n+|----------------------|---------|----------|---------|----------------------------------------------------------------------------------------------------------------|\n+| yiodockhost\t       | string  | Yes      | (None)  | Host/IP Address or host name of the YIO Dock                                                                   |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE2OTg2Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            | yiodockreceiverswitch     | Input         | Switch       | The switch to enable diable the IR reciving diode/function                                 \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|\n          \n          \n            \n            | yiodockreceiverswitch     | Input         | Switch       | The switch to enable disable the IR receiving diode/function                                 \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485169862", "createdAt": "2020-09-08T20:12:38Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/README.md", "diffHunk": "@@ -0,0 +1,59 @@\n+# YIOremote Binding\n+\n+This binding will control a YIO Dock/Remote combination. YIO Remote/Dock is a smart home solution that includes an IP based remote. More information can be found at [yio-remote](https://www.yio-remote.com/) or in the forums at [yio-remote](https://community.yio-remote.com/). \n+\n+This binding has been designed to compliment the YIO websocket Transport Protocol.\n+\n+Since this binding allows actual you to trigger IR send/receive actions on YIO Dock, this allows you to use the YIO Dock as an IR solution to openHAB and even learn new IR codes from your remotes. In other words, if the IR code is known then openHAB can use the YIO Dock to control that Device regardless if there is an openHAB binding for it or not.\n+\n+## Supported Things\n+\n+* Thing: YIO Dock.\n+\n+The following are the configurations available to each of the bridges/things:\n+\n+### YIO Dock\n+\n+| Name                 | Type    | Required | Default | Description                                                                                                    |\n+|----------------------|---------|----------|---------|----------------------------------------------------------------------------------------------------------------|\n+| yiodockhost\t       | string  | Yes      | (None)  | Host/IP Address or host name of the YIO Dock                                                                   |\n+| yiodockaccesstoken   | string  | Yes      | 0       | The authentication token for the access currently 0                                                            |\n+                                                      \n+## Channels\n+\n+### YIO Dock\n+\n+The YIO Dock has the following channels:\n+\n+| Channel \t\t     \t\t| Input/Output \t| Item Type    | Description                                                                                \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|\n+|---------------------------|---------------|--------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| yiodockreceiverswitch     | Input         | Switch       | The switch to enable diable the IR reciving diode/function                                 \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3MDI5NA==", "bodyText": "This sounds rather an Action, than a Channel.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485170294", "createdAt": "2020-09-08T20:13:32Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/README.md", "diffHunk": "@@ -0,0 +1,59 @@\n+# YIOremote Binding\n+\n+This binding will control a YIO Dock/Remote combination. YIO Remote/Dock is a smart home solution that includes an IP based remote. More information can be found at [yio-remote](https://www.yio-remote.com/) or in the forums at [yio-remote](https://community.yio-remote.com/). \n+\n+This binding has been designed to compliment the YIO websocket Transport Protocol.\n+\n+Since this binding allows actual you to trigger IR send/receive actions on YIO Dock, this allows you to use the YIO Dock as an IR solution to openHAB and even learn new IR codes from your remotes. In other words, if the IR code is known then openHAB can use the YIO Dock to control that Device regardless if there is an openHAB binding for it or not.\n+\n+## Supported Things\n+\n+* Thing: YIO Dock.\n+\n+The following are the configurations available to each of the bridges/things:\n+\n+### YIO Dock\n+\n+| Name                 | Type    | Required | Default | Description                                                                                                    |\n+|----------------------|---------|----------|---------|----------------------------------------------------------------------------------------------------------------|\n+| yiodockhost\t       | string  | Yes      | (None)  | Host/IP Address or host name of the YIO Dock                                                                   |\n+| yiodockaccesstoken   | string  | Yes      | 0       | The authentication token for the access currently 0                                                            |\n+                                                      \n+## Channels\n+\n+### YIO Dock\n+\n+The YIO Dock has the following channels:\n+\n+| Channel \t\t     \t\t| Input/Output \t| Item Type    | Description                                                                                \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|\n+|---------------------------|---------------|--------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| yiodockreceiverswitch     | Input         | Switch       | The switch to enable diable the IR reciving diode/function                                 \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|\n+| yiodocksendircode\t\t    | Input         | String       | The IR Code Format(3;0x20DF40BF;32;0) which will send by the YIO Dock                     \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3MDc4Nw==", "bodyText": "This should be a trigger Channel.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485170787", "createdAt": "2020-09-08T20:14:31Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/README.md", "diffHunk": "@@ -0,0 +1,59 @@\n+# YIOremote Binding\n+\n+This binding will control a YIO Dock/Remote combination. YIO Remote/Dock is a smart home solution that includes an IP based remote. More information can be found at [yio-remote](https://www.yio-remote.com/) or in the forums at [yio-remote](https://community.yio-remote.com/). \n+\n+This binding has been designed to compliment the YIO websocket Transport Protocol.\n+\n+Since this binding allows actual you to trigger IR send/receive actions on YIO Dock, this allows you to use the YIO Dock as an IR solution to openHAB and even learn new IR codes from your remotes. In other words, if the IR code is known then openHAB can use the YIO Dock to control that Device regardless if there is an openHAB binding for it or not.\n+\n+## Supported Things\n+\n+* Thing: YIO Dock.\n+\n+The following are the configurations available to each of the bridges/things:\n+\n+### YIO Dock\n+\n+| Name                 | Type    | Required | Default | Description                                                                                                    |\n+|----------------------|---------|----------|---------|----------------------------------------------------------------------------------------------------------------|\n+| yiodockhost\t       | string  | Yes      | (None)  | Host/IP Address or host name of the YIO Dock                                                                   |\n+| yiodockaccesstoken   | string  | Yes      | 0       | The authentication token for the access currently 0                                                            |\n+                                                      \n+## Channels\n+\n+### YIO Dock\n+\n+The YIO Dock has the following channels:\n+\n+| Channel \t\t     \t\t| Input/Output \t| Item Type    | Description                                                                                \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|\n+|---------------------------|---------------|--------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| yiodockreceiverswitch     | Input         | Switch       | The switch to enable diable the IR reciving diode/function                                 \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|\n+| yiodocksendircode\t\t    | Input         | String       | The IR Code Format(3;0x20DF40BF;32;0) which will send by the YIO Dock                     \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|\n+| yiodockstatus\t\t\t    | Output        | String       | The status of the YIO Dock. If the reciever is on than the recognized IR code will be displayed otherwise the IR send status is displayed of the last IR code send.\t|", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3MTAxMw==", "bodyText": "Can this be removed?", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485171013", "createdAt": "2020-09-08T20:14:59Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteConfiguration.java", "diffHunk": "@@ -0,0 +1,31 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link YIOremoteConfiguration} class contains fields mapping thing configuration parameters.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteConfiguration {\n+\n+    /**\n+     * Sample configuration parameter. Replace with your own.\n+     */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3MTQyNQ==", "bodyText": "Can this message be replaced by using the debugger or by increasing the framework's log level? See point 4 https://www.openhab.org/docs/developer/guidelines.html#f-logging", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485171425", "createdAt": "2020-09-08T20:15:35Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3MjI2NA==", "bodyText": "You could store config to a local variable and do a null check on that to eliminate the compiler warning.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    config = getConfigAs(YIOremoteConfiguration.class);\n          \n          \n            \n                    YIOremoteConfiguration localConfig = config = getConfigAs(YIOremoteConfiguration.class);", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485172264", "createdAt": "2020-09-08T20:17:23Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3MjQxMg==", "bodyText": "Can this be removed?", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485172412", "createdAt": "2020-09-08T20:17:43Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3Mjc2Mg==", "bodyText": "Can you use the debugger instead of logging this? Same for below", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485172762", "createdAt": "2020-09-08T20:18:24Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3MjkxOA==", "bodyText": "Can you remove this?", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485172918", "createdAt": "2020-09-08T20:18:46Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3NDMzOA==", "bodyText": "initialize() should return fast. This should be executed in a scheduler task, like in the generated skeleton code.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485174338", "createdAt": "2020-09-08T20:21:27Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3NTEzNw==", "bodyText": "Please use camelCase. Same for below.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n          \n          \n            \n                private WebSocketClient yioRemoteDockwebSocketClient = new WebSocketClient();", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485175137", "createdAt": "2020-09-08T20:23:07Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3NTQ3Mw==", "bodyText": "What's the purpose of the sleep?", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485175473", "createdAt": "2020-09-08T20:23:51Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,\n+                        YIOremote_DockwebSocketClientrequest);\n+                logger.debug(\"Connected websocket client\");\n+\n+                logger.debug(\"Check for authentication requested by YIO Dock\");\n+                YIOremoteDockwebSocket_ClientSocket.getLatch().await();\n+                Thread.sleep(1000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3NTc1OA==", "bodyText": "Can you fix the formatting?", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485175758", "createdAt": "2020-09-08T20:24:27Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,\n+                        YIOremote_DockwebSocketClientrequest);\n+                logger.debug(\"Connected websocket client\");\n+\n+                logger.debug(\"Check for authentication requested by YIO Dock\");\n+                YIOremoteDockwebSocket_ClientSocket.getLatch().await();\n+                Thread.sleep(1000);\n+\n+                try {\n+                    if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_required()) {\n+                        logger.debug(\"send authentication to YIO dock\");\n+                        YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                config.yiodockaccesstoken);\n+                        Thread.sleep(1000);\n+\n+                        if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_ok()) {\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED;\n+\n+                        } else {\n+                            logger.debug(\"authentication to YIO dock not ok\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED_FAILED;\n+                        }\n+                    } else {\n+                        logger.debug(\"authentication error YIO dock\");\n+                    }\n+\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"JSON convertion failure {}\", e.toString());\n+                }\n+\n+            } catch (\n+\n+            Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3NTk1NA==", "bodyText": "You should specify the concrete exception you want to catch, since catching Exception catches also all runtime exceptions.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485175954", "createdAt": "2020-09-08T20:24:53Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,\n+                        YIOremote_DockwebSocketClientrequest);\n+                logger.debug(\"Connected websocket client\");\n+\n+                logger.debug(\"Check for authentication requested by YIO Dock\");\n+                YIOremoteDockwebSocket_ClientSocket.getLatch().await();\n+                Thread.sleep(1000);\n+\n+                try {\n+                    if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_required()) {\n+                        logger.debug(\"send authentication to YIO dock\");\n+                        YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                config.yiodockaccesstoken);\n+                        Thread.sleep(1000);\n+\n+                        if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_ok()) {\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED;\n+\n+                        } else {\n+                            logger.debug(\"authentication to YIO dock not ok\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED_FAILED;\n+                        }\n+                    } else {\n+                        logger.debug(\"authentication error YIO dock\");\n+                    }\n+\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"JSON convertion failure {}\", e.toString());\n+                }\n+\n+            } catch (\n+\n+            Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3NjcwMg==", "bodyText": "You could set the Thing to OFFLINE with updateStatus() instead of logging it. Then, the error message is logged and displayed in the UI. Same for above.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485176702", "createdAt": "2020-09-08T20:26:28Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,\n+                        YIOremote_DockwebSocketClientrequest);\n+                logger.debug(\"Connected websocket client\");\n+\n+                logger.debug(\"Check for authentication requested by YIO Dock\");\n+                YIOremoteDockwebSocket_ClientSocket.getLatch().await();\n+                Thread.sleep(1000);\n+\n+                try {\n+                    if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_required()) {\n+                        logger.debug(\"send authentication to YIO dock\");\n+                        YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                config.yiodockaccesstoken);\n+                        Thread.sleep(1000);\n+\n+                        if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_ok()) {\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED;\n+\n+                        } else {\n+                            logger.debug(\"authentication to YIO dock not ok\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED_FAILED;\n+                        }\n+                    } else {\n+                        logger.debug(\"authentication error YIO dock\");\n+                    }\n+\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"JSON convertion failure {}\", e.toString());\n+                }\n+\n+            } catch (\n+\n+            Exception e) {\n+                logger.warn(\"Web socket connect failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+        } catch (URISyntaxException e) {\n+            logger.debug(\"Initialize web socket failed {}\", e.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3NzE4NA==", "bodyText": "Better use the exception's message. Same for the others.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                logger.warn(\"JSON convertion failure {}\", e.toString());\n          \n          \n            \n                                logger.warn(\"JSON convertion failure {}\", e.getMessage());", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485177184", "createdAt": "2020-09-08T20:27:29Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,\n+                        YIOremote_DockwebSocketClientrequest);\n+                logger.debug(\"Connected websocket client\");\n+\n+                logger.debug(\"Check for authentication requested by YIO Dock\");\n+                YIOremoteDockwebSocket_ClientSocket.getLatch().await();\n+                Thread.sleep(1000);\n+\n+                try {\n+                    if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_required()) {\n+                        logger.debug(\"send authentication to YIO dock\");\n+                        YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                config.yiodockaccesstoken);\n+                        Thread.sleep(1000);\n+\n+                        if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_ok()) {\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED;\n+\n+                        } else {\n+                            logger.debug(\"authentication to YIO dock not ok\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED_FAILED;\n+                        }\n+                    } else {\n+                        logger.debug(\"authentication error YIO dock\");\n+                    }\n+\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"JSON convertion failure {}\", e.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3NzU0OA==", "bodyText": "This logging could be removed, as updateStatus() does it already.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485177548", "createdAt": "2020-09-08T20:28:14Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,\n+                        YIOremote_DockwebSocketClientrequest);\n+                logger.debug(\"Connected websocket client\");\n+\n+                logger.debug(\"Check for authentication requested by YIO Dock\");\n+                YIOremoteDockwebSocket_ClientSocket.getLatch().await();\n+                Thread.sleep(1000);\n+\n+                try {\n+                    if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_required()) {\n+                        logger.debug(\"send authentication to YIO dock\");\n+                        YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                config.yiodockaccesstoken);\n+                        Thread.sleep(1000);\n+\n+                        if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_ok()) {\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED;\n+\n+                        } else {\n+                            logger.debug(\"authentication to YIO dock not ok\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED_FAILED;\n+                        }\n+                    } else {\n+                        logger.debug(\"authentication error YIO dock\");\n+                    }\n+\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"JSON convertion failure {}\", e.toString());\n+                }\n+\n+            } catch (\n+\n+            Exception e) {\n+                logger.warn(\"Web socket connect failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+        } catch (URISyntaxException e) {\n+            logger.debug(\"Initialize web socket failed {}\", e.toString());\n+        }\n+\n+        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+            updateStatus(ThingStatus.ONLINE);\n+            Runnable heartbeatpolling = new Runnable() {\n+                @Override\n+                public void run() {\n+                    try {\n+                        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                            YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                            Thread.sleep(1000);\n+\n+                            if (YIOremoteDockwebSocket_ClientSocket.get_boolean_heartbeat()) {\n+                                logger.debug(\"heartbeat ok\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                        YIOremoteDockwebSocket_ClientSocket.get_string_receivedstatus());\n+                            } else {\n+                                logger.warn(\"Connection lost no ping from YIO DOCK\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3ODE0MQ==", "bodyText": "Better set the Channel to UnDefType.UNDEF instead of a custom string.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485178141", "createdAt": "2020-09-08T20:29:30Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,\n+                        YIOremote_DockwebSocketClientrequest);\n+                logger.debug(\"Connected websocket client\");\n+\n+                logger.debug(\"Check for authentication requested by YIO Dock\");\n+                YIOremoteDockwebSocket_ClientSocket.getLatch().await();\n+                Thread.sleep(1000);\n+\n+                try {\n+                    if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_required()) {\n+                        logger.debug(\"send authentication to YIO dock\");\n+                        YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                config.yiodockaccesstoken);\n+                        Thread.sleep(1000);\n+\n+                        if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_ok()) {\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED;\n+\n+                        } else {\n+                            logger.debug(\"authentication to YIO dock not ok\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED_FAILED;\n+                        }\n+                    } else {\n+                        logger.debug(\"authentication error YIO dock\");\n+                    }\n+\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"JSON convertion failure {}\", e.toString());\n+                }\n+\n+            } catch (\n+\n+            Exception e) {\n+                logger.warn(\"Web socket connect failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+        } catch (URISyntaxException e) {\n+            logger.debug(\"Initialize web socket failed {}\", e.toString());\n+        }\n+\n+        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+            updateStatus(ThingStatus.ONLINE);\n+            Runnable heartbeatpolling = new Runnable() {\n+                @Override\n+                public void run() {\n+                    try {\n+                        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                            YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                            Thread.sleep(1000);\n+\n+                            if (YIOremoteDockwebSocket_ClientSocket.get_boolean_heartbeat()) {\n+                                logger.debug(\"heartbeat ok\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                        YIOremoteDockwebSocket_ClientSocket.get_string_receivedstatus());\n+                            } else {\n+                                logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                                YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                        \"Connection lost no ping from YIO DOCK\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3ODQ5MA==", "bodyText": "What type of exception do you expect here? Can you specify the concrete type?", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485178490", "createdAt": "2020-09-08T20:30:07Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,\n+                        YIOremote_DockwebSocketClientrequest);\n+                logger.debug(\"Connected websocket client\");\n+\n+                logger.debug(\"Check for authentication requested by YIO Dock\");\n+                YIOremoteDockwebSocket_ClientSocket.getLatch().await();\n+                Thread.sleep(1000);\n+\n+                try {\n+                    if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_required()) {\n+                        logger.debug(\"send authentication to YIO dock\");\n+                        YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                config.yiodockaccesstoken);\n+                        Thread.sleep(1000);\n+\n+                        if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_ok()) {\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED;\n+\n+                        } else {\n+                            logger.debug(\"authentication to YIO dock not ok\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED_FAILED;\n+                        }\n+                    } else {\n+                        logger.debug(\"authentication error YIO dock\");\n+                    }\n+\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"JSON convertion failure {}\", e.toString());\n+                }\n+\n+            } catch (\n+\n+            Exception e) {\n+                logger.warn(\"Web socket connect failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+        } catch (URISyntaxException e) {\n+            logger.debug(\"Initialize web socket failed {}\", e.toString());\n+        }\n+\n+        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+            updateStatus(ThingStatus.ONLINE);\n+            Runnable heartbeatpolling = new Runnable() {\n+                @Override\n+                public void run() {\n+                    try {\n+                        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                            YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                            Thread.sleep(1000);\n+\n+                            if (YIOremoteDockwebSocket_ClientSocket.get_boolean_heartbeat()) {\n+                                logger.debug(\"heartbeat ok\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                        YIOremoteDockwebSocket_ClientSocket.get_string_receivedstatus());\n+                            } else {\n+                                logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                                YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                        \"Connection lost no ping from YIO DOCK\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                                pollingJob.cancel(true);\n+                            }\n+                        } else {\n+                            logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                    \"Connection lost no ping from YIO DOCK\");\n+                            updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                            pollingJob.cancel(true);\n+                        }\n+                    } catch (InterruptedException e) {\n+                        logger.warn(\"Error during initializing the WebSocket polling Thread {}\", e.toString());\n+                    }\n+                }\n+            };\n+            try {\n+                pollingJob = scheduler.scheduleWithFixedDelay(heartbeatpolling, 0, 30, TimeUnit.SECONDS);\n+            } catch (Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 166}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3ODgyNQ==", "bodyText": "Please use the debugger instead of logging it.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485178825", "createdAt": "2020-09-08T20:30:48Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,\n+                        YIOremote_DockwebSocketClientrequest);\n+                logger.debug(\"Connected websocket client\");\n+\n+                logger.debug(\"Check for authentication requested by YIO Dock\");\n+                YIOremoteDockwebSocket_ClientSocket.getLatch().await();\n+                Thread.sleep(1000);\n+\n+                try {\n+                    if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_required()) {\n+                        logger.debug(\"send authentication to YIO dock\");\n+                        YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                config.yiodockaccesstoken);\n+                        Thread.sleep(1000);\n+\n+                        if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_ok()) {\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED;\n+\n+                        } else {\n+                            logger.debug(\"authentication to YIO dock not ok\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED_FAILED;\n+                        }\n+                    } else {\n+                        logger.debug(\"authentication error YIO dock\");\n+                    }\n+\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"JSON convertion failure {}\", e.toString());\n+                }\n+\n+            } catch (\n+\n+            Exception e) {\n+                logger.warn(\"Web socket connect failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+        } catch (URISyntaxException e) {\n+            logger.debug(\"Initialize web socket failed {}\", e.toString());\n+        }\n+\n+        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+            updateStatus(ThingStatus.ONLINE);\n+            Runnable heartbeatpolling = new Runnable() {\n+                @Override\n+                public void run() {\n+                    try {\n+                        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                            YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                            Thread.sleep(1000);\n+\n+                            if (YIOremoteDockwebSocket_ClientSocket.get_boolean_heartbeat()) {\n+                                logger.debug(\"heartbeat ok\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                        YIOremoteDockwebSocket_ClientSocket.get_string_receivedstatus());\n+                            } else {\n+                                logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                                YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                        \"Connection lost no ping from YIO DOCK\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                                pollingJob.cancel(true);\n+                            }\n+                        } else {\n+                            logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                    \"Connection lost no ping from YIO DOCK\");\n+                            updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                            pollingJob.cancel(true);\n+                        }\n+                    } catch (InterruptedException e) {\n+                        logger.warn(\"Error during initializing the WebSocket polling Thread {}\", e.toString());\n+                    }\n+                }\n+            };\n+            try {\n+                pollingJob = scheduler.scheduleWithFixedDelay(heartbeatpolling, 0, 30, TimeUnit.SECONDS);\n+            } catch (Exception e) {\n+                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                logger.warn(\"Error during starting the WebSocket polling Thread {}\", e.toString());\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE);\n+        }\n+\n+        logger.debug(\"Finished initializing!\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3OTI3NA==", "bodyText": "You could store pollingJob to a local variable an do a null check on that, to eliminate the compiler warning.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485179274", "createdAt": "2020-09-08T20:31:44Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,\n+                        YIOremote_DockwebSocketClientrequest);\n+                logger.debug(\"Connected websocket client\");\n+\n+                logger.debug(\"Check for authentication requested by YIO Dock\");\n+                YIOremoteDockwebSocket_ClientSocket.getLatch().await();\n+                Thread.sleep(1000);\n+\n+                try {\n+                    if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_required()) {\n+                        logger.debug(\"send authentication to YIO dock\");\n+                        YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                config.yiodockaccesstoken);\n+                        Thread.sleep(1000);\n+\n+                        if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_ok()) {\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED;\n+\n+                        } else {\n+                            logger.debug(\"authentication to YIO dock not ok\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED_FAILED;\n+                        }\n+                    } else {\n+                        logger.debug(\"authentication error YIO dock\");\n+                    }\n+\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"JSON convertion failure {}\", e.toString());\n+                }\n+\n+            } catch (\n+\n+            Exception e) {\n+                logger.warn(\"Web socket connect failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+        } catch (URISyntaxException e) {\n+            logger.debug(\"Initialize web socket failed {}\", e.toString());\n+        }\n+\n+        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+            updateStatus(ThingStatus.ONLINE);\n+            Runnable heartbeatpolling = new Runnable() {\n+                @Override\n+                public void run() {\n+                    try {\n+                        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                            YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                            Thread.sleep(1000);\n+\n+                            if (YIOremoteDockwebSocket_ClientSocket.get_boolean_heartbeat()) {\n+                                logger.debug(\"heartbeat ok\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                        YIOremoteDockwebSocket_ClientSocket.get_string_receivedstatus());\n+                            } else {\n+                                logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                                YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                        \"Connection lost no ping from YIO DOCK\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                                pollingJob.cancel(true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3OTMzNA==", "bodyText": "See above", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485179334", "createdAt": "2020-09-08T20:31:51Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,\n+                        YIOremote_DockwebSocketClientrequest);\n+                logger.debug(\"Connected websocket client\");\n+\n+                logger.debug(\"Check for authentication requested by YIO Dock\");\n+                YIOremoteDockwebSocket_ClientSocket.getLatch().await();\n+                Thread.sleep(1000);\n+\n+                try {\n+                    if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_required()) {\n+                        logger.debug(\"send authentication to YIO dock\");\n+                        YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                config.yiodockaccesstoken);\n+                        Thread.sleep(1000);\n+\n+                        if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_ok()) {\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED;\n+\n+                        } else {\n+                            logger.debug(\"authentication to YIO dock not ok\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED_FAILED;\n+                        }\n+                    } else {\n+                        logger.debug(\"authentication error YIO dock\");\n+                    }\n+\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"JSON convertion failure {}\", e.toString());\n+                }\n+\n+            } catch (\n+\n+            Exception e) {\n+                logger.warn(\"Web socket connect failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+        } catch (URISyntaxException e) {\n+            logger.debug(\"Initialize web socket failed {}\", e.toString());\n+        }\n+\n+        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+            updateStatus(ThingStatus.ONLINE);\n+            Runnable heartbeatpolling = new Runnable() {\n+                @Override\n+                public void run() {\n+                    try {\n+                        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                            YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                            Thread.sleep(1000);\n+\n+                            if (YIOremoteDockwebSocket_ClientSocket.get_boolean_heartbeat()) {\n+                                logger.debug(\"heartbeat ok\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                        YIOremoteDockwebSocket_ClientSocket.get_string_receivedstatus());\n+                            } else {\n+                                logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                                YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                        \"Connection lost no ping from YIO DOCK\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                                pollingJob.cancel(true);\n+                            }\n+                        } else {\n+                            logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                    \"Connection lost no ping from YIO DOCK\");\n+                            updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                            pollingJob.cancel(true);\n+                        }\n+                    } catch (InterruptedException e) {\n+                        logger.warn(\"Error during initializing the WebSocket polling Thread {}\", e.toString());\n+                    }\n+                }\n+            };\n+            try {\n+                pollingJob = scheduler.scheduleWithFixedDelay(heartbeatpolling, 0, 30, TimeUnit.SECONDS);\n+            } catch (Exception e) {\n+                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                logger.warn(\"Error during starting the WebSocket polling Thread {}\", e.toString());\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE);\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+        pollingJob.cancel(true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 180}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3OTY4NQ==", "bodyText": "The framework takes care of the Channel values when the Thing is disposed. This can be removed.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485179685", "createdAt": "2020-09-08T20:32:31Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,\n+                        YIOremote_DockwebSocketClientrequest);\n+                logger.debug(\"Connected websocket client\");\n+\n+                logger.debug(\"Check for authentication requested by YIO Dock\");\n+                YIOremoteDockwebSocket_ClientSocket.getLatch().await();\n+                Thread.sleep(1000);\n+\n+                try {\n+                    if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_required()) {\n+                        logger.debug(\"send authentication to YIO dock\");\n+                        YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                config.yiodockaccesstoken);\n+                        Thread.sleep(1000);\n+\n+                        if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_ok()) {\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED;\n+\n+                        } else {\n+                            logger.debug(\"authentication to YIO dock not ok\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED_FAILED;\n+                        }\n+                    } else {\n+                        logger.debug(\"authentication error YIO dock\");\n+                    }\n+\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"JSON convertion failure {}\", e.toString());\n+                }\n+\n+            } catch (\n+\n+            Exception e) {\n+                logger.warn(\"Web socket connect failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+        } catch (URISyntaxException e) {\n+            logger.debug(\"Initialize web socket failed {}\", e.toString());\n+        }\n+\n+        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+            updateStatus(ThingStatus.ONLINE);\n+            Runnable heartbeatpolling = new Runnable() {\n+                @Override\n+                public void run() {\n+                    try {\n+                        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                            YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                            Thread.sleep(1000);\n+\n+                            if (YIOremoteDockwebSocket_ClientSocket.get_boolean_heartbeat()) {\n+                                logger.debug(\"heartbeat ok\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                        YIOremoteDockwebSocket_ClientSocket.get_string_receivedstatus());\n+                            } else {\n+                                logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                                YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                        \"Connection lost no ping from YIO DOCK\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                                pollingJob.cancel(true);\n+                            }\n+                        } else {\n+                            logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                    \"Connection lost no ping from YIO DOCK\");\n+                            updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                            pollingJob.cancel(true);\n+                        }\n+                    } catch (InterruptedException e) {\n+                        logger.warn(\"Error during initializing the WebSocket polling Thread {}\", e.toString());\n+                    }\n+                }\n+            };\n+            try {\n+                pollingJob = scheduler.scheduleWithFixedDelay(heartbeatpolling, 0, 30, TimeUnit.SECONDS);\n+            } catch (Exception e) {\n+                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                logger.warn(\"Error during starting the WebSocket polling Thread {}\", e.toString());\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE);\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 179}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3OTg2MA==", "bodyText": "Can you do this?", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485179860", "createdAt": "2020-09-08T20:32:51Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,\n+                        YIOremote_DockwebSocketClientrequest);\n+                logger.debug(\"Connected websocket client\");\n+\n+                logger.debug(\"Check for authentication requested by YIO Dock\");\n+                YIOremoteDockwebSocket_ClientSocket.getLatch().await();\n+                Thread.sleep(1000);\n+\n+                try {\n+                    if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_required()) {\n+                        logger.debug(\"send authentication to YIO dock\");\n+                        YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                config.yiodockaccesstoken);\n+                        Thread.sleep(1000);\n+\n+                        if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_ok()) {\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED;\n+\n+                        } else {\n+                            logger.debug(\"authentication to YIO dock not ok\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED_FAILED;\n+                        }\n+                    } else {\n+                        logger.debug(\"authentication error YIO dock\");\n+                    }\n+\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"JSON convertion failure {}\", e.toString());\n+                }\n+\n+            } catch (\n+\n+            Exception e) {\n+                logger.warn(\"Web socket connect failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+        } catch (URISyntaxException e) {\n+            logger.debug(\"Initialize web socket failed {}\", e.toString());\n+        }\n+\n+        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+            updateStatus(ThingStatus.ONLINE);\n+            Runnable heartbeatpolling = new Runnable() {\n+                @Override\n+                public void run() {\n+                    try {\n+                        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                            YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                            Thread.sleep(1000);\n+\n+                            if (YIOremoteDockwebSocket_ClientSocket.get_boolean_heartbeat()) {\n+                                logger.debug(\"heartbeat ok\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                        YIOremoteDockwebSocket_ClientSocket.get_string_receivedstatus());\n+                            } else {\n+                                logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                                YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                        \"Connection lost no ping from YIO DOCK\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                                pollingJob.cancel(true);\n+                            }\n+                        } else {\n+                            logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                    \"Connection lost no ping from YIO DOCK\");\n+                            updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                            pollingJob.cancel(true);\n+                        }\n+                    } catch (InterruptedException e) {\n+                        logger.warn(\"Error during initializing the WebSocket polling Thread {}\", e.toString());\n+                    }\n+                }\n+            };\n+            try {\n+                pollingJob = scheduler.scheduleWithFixedDelay(heartbeatpolling, 0, 30, TimeUnit.SECONDS);\n+            } catch (Exception e) {\n+                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                logger.warn(\"Error during starting the WebSocket polling Thread {}\", e.toString());\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE);\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+        pollingJob.cancel(true);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+\n+        if (YIODOCKRECEIVERSWITCH.equals(channelUID.getIdWithoutGroup())) {\n+            if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                if (command instanceof RefreshType) {\n+                    // TODO: handle data refresh", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 189}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4MDcyMw==", "bodyText": "If I see correctly this is a trigger channel. So a refresh doesn't need to be handled.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485180723", "createdAt": "2020-09-08T20:34:44Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,\n+                        YIOremote_DockwebSocketClientrequest);\n+                logger.debug(\"Connected websocket client\");\n+\n+                logger.debug(\"Check for authentication requested by YIO Dock\");\n+                YIOremoteDockwebSocket_ClientSocket.getLatch().await();\n+                Thread.sleep(1000);\n+\n+                try {\n+                    if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_required()) {\n+                        logger.debug(\"send authentication to YIO dock\");\n+                        YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                config.yiodockaccesstoken);\n+                        Thread.sleep(1000);\n+\n+                        if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_ok()) {\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED;\n+\n+                        } else {\n+                            logger.debug(\"authentication to YIO dock not ok\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED_FAILED;\n+                        }\n+                    } else {\n+                        logger.debug(\"authentication error YIO dock\");\n+                    }\n+\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"JSON convertion failure {}\", e.toString());\n+                }\n+\n+            } catch (\n+\n+            Exception e) {\n+                logger.warn(\"Web socket connect failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+        } catch (URISyntaxException e) {\n+            logger.debug(\"Initialize web socket failed {}\", e.toString());\n+        }\n+\n+        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+            updateStatus(ThingStatus.ONLINE);\n+            Runnable heartbeatpolling = new Runnable() {\n+                @Override\n+                public void run() {\n+                    try {\n+                        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                            YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                            Thread.sleep(1000);\n+\n+                            if (YIOremoteDockwebSocket_ClientSocket.get_boolean_heartbeat()) {\n+                                logger.debug(\"heartbeat ok\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                        YIOremoteDockwebSocket_ClientSocket.get_string_receivedstatus());\n+                            } else {\n+                                logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                                YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                        \"Connection lost no ping from YIO DOCK\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                                pollingJob.cancel(true);\n+                            }\n+                        } else {\n+                            logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                    \"Connection lost no ping from YIO DOCK\");\n+                            updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                            pollingJob.cancel(true);\n+                        }\n+                    } catch (InterruptedException e) {\n+                        logger.warn(\"Error during initializing the WebSocket polling Thread {}\", e.toString());\n+                    }\n+                }\n+            };\n+            try {\n+                pollingJob = scheduler.scheduleWithFixedDelay(heartbeatpolling, 0, 30, TimeUnit.SECONDS);\n+            } catch (Exception e) {\n+                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                logger.warn(\"Error during starting the WebSocket polling Thread {}\", e.toString());\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE);\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+        pollingJob.cancel(true);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+\n+        if (YIODOCKRECEIVERSWITCH.equals(channelUID.getIdWithoutGroup())) {\n+            if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                if (command instanceof RefreshType) {\n+                    // TODO: handle data refresh\n+\n+                }\n+\n+                if (command.toString().equals(\"ON\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVERON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVEROFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+\n+            } else {\n+                logger.warn(\"YIOremoteDockHandler not authenticated\");\n+            }\n+\n+        } else if (YIODOCKSENDIRCODE.equals(channelUID.getIdWithoutGroup())) {\n+            if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                if (command instanceof RefreshType) {\n+                    // TODO: handle data refresh\n+                    // logger.warn(\"YIOremoteDockHandler not authenticated\");\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 212}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4MTEzMQ==", "bodyText": "No harm in updating an unlinked Channel.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485181131", "createdAt": "2020-09-08T20:35:32Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,\n+                        YIOremote_DockwebSocketClientrequest);\n+                logger.debug(\"Connected websocket client\");\n+\n+                logger.debug(\"Check for authentication requested by YIO Dock\");\n+                YIOremoteDockwebSocket_ClientSocket.getLatch().await();\n+                Thread.sleep(1000);\n+\n+                try {\n+                    if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_required()) {\n+                        logger.debug(\"send authentication to YIO dock\");\n+                        YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                config.yiodockaccesstoken);\n+                        Thread.sleep(1000);\n+\n+                        if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_ok()) {\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED;\n+\n+                        } else {\n+                            logger.debug(\"authentication to YIO dock not ok\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED_FAILED;\n+                        }\n+                    } else {\n+                        logger.debug(\"authentication error YIO dock\");\n+                    }\n+\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"JSON convertion failure {}\", e.toString());\n+                }\n+\n+            } catch (\n+\n+            Exception e) {\n+                logger.warn(\"Web socket connect failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+        } catch (URISyntaxException e) {\n+            logger.debug(\"Initialize web socket failed {}\", e.toString());\n+        }\n+\n+        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+            updateStatus(ThingStatus.ONLINE);\n+            Runnable heartbeatpolling = new Runnable() {\n+                @Override\n+                public void run() {\n+                    try {\n+                        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                            YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                            Thread.sleep(1000);\n+\n+                            if (YIOremoteDockwebSocket_ClientSocket.get_boolean_heartbeat()) {\n+                                logger.debug(\"heartbeat ok\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                        YIOremoteDockwebSocket_ClientSocket.get_string_receivedstatus());\n+                            } else {\n+                                logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                                YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                        \"Connection lost no ping from YIO DOCK\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                                pollingJob.cancel(true);\n+                            }\n+                        } else {\n+                            logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                    \"Connection lost no ping from YIO DOCK\");\n+                            updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                            pollingJob.cancel(true);\n+                        }\n+                    } catch (InterruptedException e) {\n+                        logger.warn(\"Error during initializing the WebSocket polling Thread {}\", e.toString());\n+                    }\n+                }\n+            };\n+            try {\n+                pollingJob = scheduler.scheduleWithFixedDelay(heartbeatpolling, 0, 30, TimeUnit.SECONDS);\n+            } catch (Exception e) {\n+                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                logger.warn(\"Error during starting the WebSocket polling Thread {}\", e.toString());\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE);\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+        pollingJob.cancel(true);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+\n+        if (YIODOCKRECEIVERSWITCH.equals(channelUID.getIdWithoutGroup())) {\n+            if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                if (command instanceof RefreshType) {\n+                    // TODO: handle data refresh\n+\n+                }\n+\n+                if (command.toString().equals(\"ON\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVERON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVEROFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+\n+            } else {\n+                logger.warn(\"YIOremoteDockHandler not authenticated\");\n+            }\n+\n+        } else if (YIODOCKSENDIRCODE.equals(channelUID.getIdWithoutGroup())) {\n+            if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                if (command instanceof RefreshType) {\n+                    // TODO: handle data refresh\n+                    // logger.warn(\"YIOremoteDockHandler not authenticated\");\n+                }\n+                logger.debug(\"YIODOCKSENDIRCODE procedure: {}\", command.toString());\n+                send_ircode = command.toString();\n+                if (send_ircode.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.IRSEND, send_ircode);\n+                } else {\n+                    logger.warn(\"Wrong IR code Format {}\", send_ircode);\n+                    send_ircode = \"\";\n+                }\n+            } else {\n+                logger.warn(\"YIOremoteDockHandler not authenticated\");\n+            }\n+        }\n+    }\n+\n+    protected void updateChannelString(String group, String channelId, String value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+\n+        if (isLinked(id)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 230}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4MTI2MQ==", "bodyText": "See above. camelCase", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485181261", "createdAt": "2020-09-08T20:35:48Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockWebsocket.java", "diffHunk": "@@ -0,0 +1,250 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import java.io.IOException;\n+import java.util.concurrent.CountDownLatch;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.api.Session;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketConnect;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketError;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketMessage;\n+import org.eclipse.jetty.websocket.api.annotations.WebSocket;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockWebsocket} is responsible for the Websocket Connection to the YIO Remote Dock\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+@WebSocket\n+public class YIOremoteDockWebsocket {\n+\n+    private @Nullable Session session;\n+    private String string_receivedmessage = \"\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4MTUwNA==", "bodyText": "What type of exception do you expect here? Can you specify the concrete type?", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485181504", "createdAt": "2020-09-08T20:36:20Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockWebsocket.java", "diffHunk": "@@ -0,0 +1,250 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import java.io.IOException;\n+import java.util.concurrent.CountDownLatch;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.api.Session;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketConnect;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketError;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketMessage;\n+import org.eclipse.jetty.websocket.api.annotations.WebSocket;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockWebsocket} is responsible for the Websocket Connection to the YIO Remote Dock\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+@WebSocket\n+public class YIOremoteDockWebsocket {\n+\n+    private @Nullable Session session;\n+    private String string_receivedmessage = \"\";\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockWebsocket.class);\n+    private JsonObject JsonObject_recievedJsonObject = new JsonObject();\n+    private boolean boolean_authentication_required = false;\n+    private boolean boolean_heartbeat = false;\n+    private boolean boolean_authentication_ok = false;\n+    private boolean boolean_sendir_status = false;\n+    private String string_receivedstatus = \"\";\n+    private String string_lastsendircode = \"\";\n+\n+    CountDownLatch latch = new CountDownLatch(1);\n+\n+    @OnWebSocketMessage\n+    public void onText(Session session, String message) throws IOException {\n+        logger.debug(\"Message received from server: {}\", message);\n+        string_receivedmessage = message;\n+        JsonObject_recievedJsonObject = convert_StringtoJsonObject(string_receivedmessage);\n+        if (decode_receivedMessage(JsonObject_recievedJsonObject)) {\n+            logger.debug(\"Message {} decoded\", string_receivedmessage);\n+        } else {\n+            logger.debug(\"Error during message {} decoding\", string_receivedmessage);\n+        }\n+    }\n+\n+    public String get_string_receivedmessage() {\n+        return this.string_receivedmessage;\n+    }\n+\n+    @OnWebSocketConnect\n+    public void onConnect(Session session) {\n+        this.session = session;\n+        latch.countDown();\n+    }\n+\n+    @OnWebSocketError\n+    public void onError(Throwable cause) {\n+        try {\n+            boolean_heartbeat = false;\n+        } catch (Exception ex) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4MjA0Mw==", "bodyText": "Please use underscores to separate the words.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static enum YIOREMOTEHANDLESTATUS {\n          \n          \n            \n                public static enum YIO_REMOTE_HANDLE_STATUS {", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485182043", "createdAt": "2020-09-08T20:37:21Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteBindingConstants.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+\n+/**\n+ * The {@link YIOremoteBindingConstants} class defines common constants, which are\n+ * used across the whole binding.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteBindingConstants {\n+\n+    private static final String BINDING_ID = \"yioremote\";\n+\n+    // List of all used global variables\n+    public static enum YIOREMOTEHANDLESTATUS {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4MjM5Nw==", "bodyText": "The IOException is never thrown. So, this could be removed.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485182397", "createdAt": "2020-09-08T20:38:04Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockWebsocket.java", "diffHunk": "@@ -0,0 +1,250 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import java.io.IOException;\n+import java.util.concurrent.CountDownLatch;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.api.Session;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketConnect;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketError;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketMessage;\n+import org.eclipse.jetty.websocket.api.annotations.WebSocket;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockWebsocket} is responsible for the Websocket Connection to the YIO Remote Dock\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+@WebSocket\n+public class YIOremoteDockWebsocket {\n+\n+    private @Nullable Session session;\n+    private String string_receivedmessage = \"\";\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockWebsocket.class);\n+    private JsonObject JsonObject_recievedJsonObject = new JsonObject();\n+    private boolean boolean_authentication_required = false;\n+    private boolean boolean_heartbeat = false;\n+    private boolean boolean_authentication_ok = false;\n+    private boolean boolean_sendir_status = false;\n+    private String string_receivedstatus = \"\";\n+    private String string_lastsendircode = \"\";\n+\n+    CountDownLatch latch = new CountDownLatch(1);\n+\n+    @OnWebSocketMessage\n+    public void onText(Session session, String message) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4MjU0MQ==", "bodyText": "See above. null check", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485182541", "createdAt": "2020-09-08T20:38:22Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockWebsocket.java", "diffHunk": "@@ -0,0 +1,250 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import java.io.IOException;\n+import java.util.concurrent.CountDownLatch;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.api.Session;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketConnect;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketError;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketMessage;\n+import org.eclipse.jetty.websocket.api.annotations.WebSocket;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockWebsocket} is responsible for the Websocket Connection to the YIO Remote Dock\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+@WebSocket\n+public class YIOremoteDockWebsocket {\n+\n+    private @Nullable Session session;\n+    private String string_receivedmessage = \"\";\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockWebsocket.class);\n+    private JsonObject JsonObject_recievedJsonObject = new JsonObject();\n+    private boolean boolean_authentication_required = false;\n+    private boolean boolean_heartbeat = false;\n+    private boolean boolean_authentication_ok = false;\n+    private boolean boolean_sendir_status = false;\n+    private String string_receivedstatus = \"\";\n+    private String string_lastsendircode = \"\";\n+\n+    CountDownLatch latch = new CountDownLatch(1);\n+\n+    @OnWebSocketMessage\n+    public void onText(Session session, String message) throws IOException {\n+        logger.debug(\"Message received from server: {}\", message);\n+        string_receivedmessage = message;\n+        JsonObject_recievedJsonObject = convert_StringtoJsonObject(string_receivedmessage);\n+        if (decode_receivedMessage(JsonObject_recievedJsonObject)) {\n+            logger.debug(\"Message {} decoded\", string_receivedmessage);\n+        } else {\n+            logger.debug(\"Error during message {} decoding\", string_receivedmessage);\n+        }\n+    }\n+\n+    public String get_string_receivedmessage() {\n+        return this.string_receivedmessage;\n+    }\n+\n+    @OnWebSocketConnect\n+    public void onConnect(Session session) {\n+        this.session = session;\n+        latch.countDown();\n+    }\n+\n+    @OnWebSocketError\n+    public void onError(Throwable cause) {\n+        try {\n+            boolean_heartbeat = false;\n+        } catch (Exception ex) {\n+            logger.debug(\"WebSocketError\");\n+        }\n+    }\n+\n+    public void sendMessage(String str) {\n+        try {\n+            session.getRemote().sendString(str);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4MjgwNg==", "bodyText": "Please fix the formatting", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485182806", "createdAt": "2020-09-08T20:38:55Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockWebsocket.java", "diffHunk": "@@ -0,0 +1,250 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import java.io.IOException;\n+import java.util.concurrent.CountDownLatch;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.api.Session;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketConnect;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketError;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketMessage;\n+import org.eclipse.jetty.websocket.api.annotations.WebSocket;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockWebsocket} is responsible for the Websocket Connection to the YIO Remote Dock\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+@WebSocket\n+public class YIOremoteDockWebsocket {\n+\n+    private @Nullable Session session;\n+    private String string_receivedmessage = \"\";\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockWebsocket.class);\n+    private JsonObject JsonObject_recievedJsonObject = new JsonObject();\n+    private boolean boolean_authentication_required = false;\n+    private boolean boolean_heartbeat = false;\n+    private boolean boolean_authentication_ok = false;\n+    private boolean boolean_sendir_status = false;\n+    private String string_receivedstatus = \"\";\n+    private String string_lastsendircode = \"\";\n+\n+    CountDownLatch latch = new CountDownLatch(1);\n+\n+    @OnWebSocketMessage\n+    public void onText(Session session, String message) throws IOException {\n+        logger.debug(\"Message received from server: {}\", message);\n+        string_receivedmessage = message;\n+        JsonObject_recievedJsonObject = convert_StringtoJsonObject(string_receivedmessage);\n+        if (decode_receivedMessage(JsonObject_recievedJsonObject)) {\n+            logger.debug(\"Message {} decoded\", string_receivedmessage);\n+        } else {\n+            logger.debug(\"Error during message {} decoding\", string_receivedmessage);\n+        }\n+    }\n+\n+    public String get_string_receivedmessage() {\n+        return this.string_receivedmessage;\n+    }\n+\n+    @OnWebSocketConnect\n+    public void onConnect(Session session) {\n+        this.session = session;\n+        latch.countDown();\n+    }\n+\n+    @OnWebSocketError\n+    public void onError(Throwable cause) {\n+        try {\n+            boolean_heartbeat = false;\n+        } catch (Exception ex) {\n+            logger.debug(\"WebSocketError\");\n+        }\n+    }\n+\n+    public void sendMessage(String str) {\n+        try {\n+            session.getRemote().sendString(str);\n+        } catch (IOException e) {\n+            logger.warn(\"Error during sendMessage function {}\", e.toString());\n+        }\n+    }\n+\n+    public void sendMessage(YIOREMOTEMESSAGETYPE messagetype, String messagepyload) {\n+        try {\n+            if (messagetype.equals(YIOREMOTEMESSAGETYPE.AUTHENTICATE)) {\n+                session.getRemote().sendString(\"{\\\"type\\\":\\\"auth\\\", \\\"token\\\":\\\"\" + messagepyload + \"\\\"}\");\n+                logger.debug(\"sending authenticating message: \\\"{\\\"type\\\":\\\"auth\\\", \\\"token\\\":\\\"{}\\\"}\\\"\",\n+                        messagepyload);\n+            } else if (messagetype.equals(YIOREMOTEMESSAGETYPE.HEARTBEAT)) {\n+                string_lastsendircode = \"\\\"0;0x0;0;0\\\"\";\n+                session.getRemote().sendString(\n+                        \"{\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_send\\\",\\\"code\\\":\\\"0;0x0;0;0\\\", \\\"format\\\":\\\"hex\\\"}\");\n+                logger.debug(\n+                        \"sending heartbeat message: {\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_send\\\",\\\"code\\\":\\\"0;0x0;0;0\\\", \\\"format\\\":\\\"hex\\\"}\");\n+            } else if (messagetype.equals(YIOREMOTEMESSAGETYPE.IRRECEIVERON)) {\n+                session.getRemote().sendString(\"{\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_receive_on\\\"}\");\n+                logger.debug(\"sending heartbeat message: {\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_receive_on\\\"\");\n+            } else if (messagetype.equals(YIOREMOTEMESSAGETYPE.IRRECEIVEROFF)) {\n+                session.getRemote().sendString(\"{\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_receive_off\\\"}\");\n+                logger.debug(\"sending heartbeat message: {\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_receive_off\\\"\");\n+            } else if (messagetype.equals(YIOREMOTEMESSAGETYPE.IRSEND)) {\n+                session.getRemote().sendString(\"{\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_send\\\",\\\"code\\\":\\\"\" + messagepyload\n+                        + \"\\\", \\\"format\\\":\\\"hex\\\"}\");\n+                string_lastsendircode = messagepyload;\n+                logger.debug(\n+                        \"sending heartbeat message: {\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_send\\\",\\\"code\\\":\\\"{}\\\", \\\"format\\\":\\\"hex\\\"}\",\n+                        messagepyload);\n+            }\n+        } catch (\n+\n+        IOException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4MjkxMg==", "bodyText": "See above. camelCase", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485182912", "createdAt": "2020-09-08T20:39:09Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockWebsocket.java", "diffHunk": "@@ -0,0 +1,250 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import java.io.IOException;\n+import java.util.concurrent.CountDownLatch;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.api.Session;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketConnect;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketError;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketMessage;\n+import org.eclipse.jetty.websocket.api.annotations.WebSocket;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockWebsocket} is responsible for the Websocket Connection to the YIO Remote Dock\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+@WebSocket\n+public class YIOremoteDockWebsocket {\n+\n+    private @Nullable Session session;\n+    private String string_receivedmessage = \"\";\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockWebsocket.class);\n+    private JsonObject JsonObject_recievedJsonObject = new JsonObject();\n+    private boolean boolean_authentication_required = false;\n+    private boolean boolean_heartbeat = false;\n+    private boolean boolean_authentication_ok = false;\n+    private boolean boolean_sendir_status = false;\n+    private String string_receivedstatus = \"\";\n+    private String string_lastsendircode = \"\";\n+\n+    CountDownLatch latch = new CountDownLatch(1);\n+\n+    @OnWebSocketMessage\n+    public void onText(Session session, String message) throws IOException {\n+        logger.debug(\"Message received from server: {}\", message);\n+        string_receivedmessage = message;\n+        JsonObject_recievedJsonObject = convert_StringtoJsonObject(string_receivedmessage);\n+        if (decode_receivedMessage(JsonObject_recievedJsonObject)) {\n+            logger.debug(\"Message {} decoded\", string_receivedmessage);\n+        } else {\n+            logger.debug(\"Error during message {} decoding\", string_receivedmessage);\n+        }\n+    }\n+\n+    public String get_string_receivedmessage() {\n+        return this.string_receivedmessage;\n+    }\n+\n+    @OnWebSocketConnect\n+    public void onConnect(Session session) {\n+        this.session = session;\n+        latch.countDown();\n+    }\n+\n+    @OnWebSocketError\n+    public void onError(Throwable cause) {\n+        try {\n+            boolean_heartbeat = false;\n+        } catch (Exception ex) {\n+            logger.debug(\"WebSocketError\");\n+        }\n+    }\n+\n+    public void sendMessage(String str) {\n+        try {\n+            session.getRemote().sendString(str);\n+        } catch (IOException e) {\n+            logger.warn(\"Error during sendMessage function {}\", e.toString());\n+        }\n+    }\n+\n+    public void sendMessage(YIOREMOTEMESSAGETYPE messagetype, String messagepyload) {\n+        try {\n+            if (messagetype.equals(YIOREMOTEMESSAGETYPE.AUTHENTICATE)) {\n+                session.getRemote().sendString(\"{\\\"type\\\":\\\"auth\\\", \\\"token\\\":\\\"\" + messagepyload + \"\\\"}\");\n+                logger.debug(\"sending authenticating message: \\\"{\\\"type\\\":\\\"auth\\\", \\\"token\\\":\\\"{}\\\"}\\\"\",\n+                        messagepyload);\n+            } else if (messagetype.equals(YIOREMOTEMESSAGETYPE.HEARTBEAT)) {\n+                string_lastsendircode = \"\\\"0;0x0;0;0\\\"\";\n+                session.getRemote().sendString(\n+                        \"{\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_send\\\",\\\"code\\\":\\\"0;0x0;0;0\\\", \\\"format\\\":\\\"hex\\\"}\");\n+                logger.debug(\n+                        \"sending heartbeat message: {\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_send\\\",\\\"code\\\":\\\"0;0x0;0;0\\\", \\\"format\\\":\\\"hex\\\"}\");\n+            } else if (messagetype.equals(YIOREMOTEMESSAGETYPE.IRRECEIVERON)) {\n+                session.getRemote().sendString(\"{\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_receive_on\\\"}\");\n+                logger.debug(\"sending heartbeat message: {\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_receive_on\\\"\");\n+            } else if (messagetype.equals(YIOREMOTEMESSAGETYPE.IRRECEIVEROFF)) {\n+                session.getRemote().sendString(\"{\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_receive_off\\\"}\");\n+                logger.debug(\"sending heartbeat message: {\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_receive_off\\\"\");\n+            } else if (messagetype.equals(YIOREMOTEMESSAGETYPE.IRSEND)) {\n+                session.getRemote().sendString(\"{\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_send\\\",\\\"code\\\":\\\"\" + messagepyload\n+                        + \"\\\", \\\"format\\\":\\\"hex\\\"}\");\n+                string_lastsendircode = messagepyload;\n+                logger.debug(\n+                        \"sending heartbeat message: {\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_send\\\",\\\"code\\\":\\\"{}\\\", \\\"format\\\":\\\"hex\\\"}\",\n+                        messagepyload);\n+            }\n+        } catch (\n+\n+        IOException e) {\n+            logger.warn(\"Error during sendMessage function {}\", e.toString());\n+        }\n+    }\n+\n+    private boolean decode_receivedMessage(JsonObject JsonObject_recievedJsonObject) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4MzkxOQ==", "bodyText": "What's the purpose of this method?", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485183919", "createdAt": "2020-09-08T20:41:11Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteWebsocketPolling.java", "diffHunk": "@@ -0,0 +1,28 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The {@link YIOremoteHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteWebsocketPolling implements Runnable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4Mzk5NA==", "bodyText": "Could you be a bit more verbose, so that somebody who hasn't heard about it gets a clue what this is about?", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485183994", "createdAt": "2020-09-08T20:41:23Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/resources/ESH-INF/binding/binding.xml", "diffHunk": "@@ -0,0 +1,10 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<binding:binding id=\"yioremote\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:binding=\"https://openhab.org/schemas/binding/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/binding/v1.0.0 https://openhab.org/schemas/binding-1.0.0.xsd\">\n+\n+\t<name>YIOremote Binding</name>\n+\t<description>This is the binding for YIOremote.</description>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4NDExOA==", "bodyText": "Can these be removed?", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485184118", "createdAt": "2020-09-08T20:41:37Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/resources/ESH-INF/i18n/yioremote_de_DE.properties", "diffHunk": "@@ -0,0 +1,23 @@\n+# FIXME: please substitute the xx_XX with a proper locale, ie. de_DE\n+# FIXME: please do not add the file to the repo if you add or change no content", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4NDIyMA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            binding.yioremote.description = Diese Addon kontrolliert eine YIO Dock / Remote-Kombination\n          \n          \n            \n            binding.yioremote.description = Dieses Addon steuert eine YIO Dock / Remote-Kombination", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485184220", "createdAt": "2020-09-08T20:41:50Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/resources/ESH-INF/i18n/yioremote_de_DE.properties", "diffHunk": "@@ -0,0 +1,23 @@\n+# FIXME: please substitute the xx_XX with a proper locale, ie. de_DE\n+# FIXME: please do not add the file to the repo if you add or change no content\n+# binding\n+binding.yioremote.name = YIOremote Addon\n+binding.yioremote.description = Diese Addon kontrolliert eine YIO Dock / Remote-Kombination", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4NDg0Ng==", "bodyText": "Can this be removed?", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485184846", "createdAt": "2020-09-08T20:43:05Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,56 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"yioremote\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<!-- Sample Thing Type -->", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4NTExMQ==", "bodyText": "You could specify <context>network-address</context> to get a free validation.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485185111", "createdAt": "2020-09-08T20:43:37Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,56 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"yioremote\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<!-- Sample Thing Type -->\n+\t<thing-type id=\"yioremotedock\">\n+\t\t<label>YIOremote Dock Binding Thing</label>\n+\t\t<description>YIOremote Dock Binding Thing</description>\n+\t\t<channel-groups>\n+\t\t\t<channel-group id=\"input\" typeId=\"input\"/>\n+\t\t\t<channel-group id=\"output\" typeId=\"output\"/>\n+\t\t</channel-groups>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"yiodockhost\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Host/IP Address of the YIO Dock</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4NTQ0Ng==", "bodyText": "Can you make this speaking, as this is displayed in the UI. Same for the description", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485185446", "createdAt": "2020-09-08T20:44:16Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,56 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"yioremote\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<!-- Sample Thing Type -->\n+\t<thing-type id=\"yioremotedock\">\n+\t\t<label>YIOremote Dock Binding Thing</label>\n+\t\t<description>YIOremote Dock Binding Thing</description>\n+\t\t<channel-groups>\n+\t\t\t<channel-group id=\"input\" typeId=\"input\"/>\n+\t\t\t<channel-group id=\"output\" typeId=\"output\"/>\n+\t\t</channel-groups>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"yiodockhost\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Host/IP Address of the YIO Dock</label>\n+\t\t\t\t<description>Host/IP Address of the YIO Dock</description>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"yiodockaccesstoken\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Access token for the YIO Dock</label>\n+\t\t\t\t<description>Access token for the YIO Dock</description>\n+\t\t\t\t<default>0</default>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\t<channel-group-type id=\"input\">\n+\t\t<label>Inputs</label>\n+\t\t<description>The channels used for Input</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"yiodockreceiverswitch\" typeId=\"yiodockreceiverswitch\"/>\n+\t\t\t<channel id=\"yiodocksendircode\" typeId=\"yiodocksendircode\"/>\n+\t\t</channels>\n+\t</channel-group-type>\n+\t<channel-group-type id=\"output\">\n+\t\t<label>Results</label>\n+\t\t<description>The channels used for Input</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"yiodockstatus\" typeId=\"yiodockstatus\"/>\n+\t\t</channels>\n+\t</channel-group-type>\n+\t<channel-type id=\"yiodockreceiverswitch\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>yiodockreceiverswitch</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4NTg0OA==", "bodyText": "Can you leave the header as-is?", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485185848", "createdAt": "2020-09-08T20:45:03Z", "author": {"login": "fwolter"}, "path": "bundles/pom.xml", "diffHunk": "@@ -1,4 +1,6 @@\n-<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?><project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0Njg0MTYz", "url": "https://github.com/openhab/openhab-addons/pull/8394#pullrequestreview-484684163", "createdAt": "2020-09-09T06:03:27Z", "commit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "state": "COMMENTED", "comments": {"totalCount": 33, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwNjowMzoyN1rOHO35aQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMjoxMzo0M1rOHQHiRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM1NzkyOQ==", "bodyText": "Done", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485357929", "createdAt": "2020-09-09T06:03:27Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/README.md", "diffHunk": "@@ -0,0 +1,59 @@\n+# YIOremote Binding\n+\n+This binding will control a YIO Dock/Remote combination. YIO Remote/Dock is a smart home solution that includes an IP based remote. More information can be found at [yio-remote](https://www.yio-remote.com/) or in the forums at [yio-remote](https://community.yio-remote.com/). \n+\n+This binding has been designed to compliment the YIO websocket Transport Protocol.\n+\n+Since this binding allows actual you to trigger IR send/receive actions on YIO Dock, this allows you to use the YIO Dock as an IR solution to openHAB and even learn new IR codes from your remotes. In other words, if the IR code is known then openHAB can use the YIO Dock to control that Device regardless if there is an openHAB binding for it or not.\n+\n+## Supported Things\n+\n+* Thing: YIO Dock.\n+\n+The following are the configurations available to each of the bridges/things:\n+\n+### YIO Dock\n+\n+| Name                 | Type    | Required | Default | Description                                                                                                    |\n+|----------------------|---------|----------|---------|----------------------------------------------------------------------------------------------------------------|\n+| yiodockhost\t       | string  | Yes      | (None)  | Host/IP Address or host name of the YIO Dock                                                                   |", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE2OTU0Mg=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM1OTcyMw==", "bodyText": "Changed to correct YIO_REMOTE_DOCK_HANDLE_STATUS", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485359723", "createdAt": "2020-09-09T06:08:38Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteBindingConstants.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+\n+/**\n+ * The {@link YIOremoteBindingConstants} class defines common constants, which are\n+ * used across the whole binding.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteBindingConstants {\n+\n+    private static final String BINDING_ID = \"yioremote\";\n+\n+    // List of all used global variables\n+    public static enum YIOREMOTEHANDLESTATUS {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4MjA0Mw=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM2MDI5Nw==", "bodyText": "Done", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485360297", "createdAt": "2020-09-09T06:10:00Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteConfiguration.java", "diffHunk": "@@ -0,0 +1,31 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link YIOremoteConfiguration} class contains fields mapping thing configuration parameters.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteConfiguration {\n+\n+    /**\n+     * Sample configuration parameter. Replace with your own.\n+     */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3MTAxMw=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM2MDk2Mg==", "bodyText": "Done", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485360962", "createdAt": "2020-09-09T06:11:45Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3NTEzNw=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM2NDQ4NQ==", "bodyText": "Cool Idea thanks for the Help :)", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485364485", "createdAt": "2020-09-09T06:21:08Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3MjI2NA=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM2NTQxNQ==", "bodyText": "Done", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485365415", "createdAt": "2020-09-09T06:23:30Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,\n+                        YIOremote_DockwebSocketClientrequest);\n+                logger.debug(\"Connected websocket client\");\n+\n+                logger.debug(\"Check for authentication requested by YIO Dock\");\n+                YIOremoteDockwebSocket_ClientSocket.getLatch().await();\n+                Thread.sleep(1000);\n+\n+                try {\n+                    if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_required()) {\n+                        logger.debug(\"send authentication to YIO dock\");\n+                        YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                config.yiodockaccesstoken);\n+                        Thread.sleep(1000);\n+\n+                        if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_ok()) {\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED;\n+\n+                        } else {\n+                            logger.debug(\"authentication to YIO dock not ok\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED_FAILED;\n+                        }\n+                    } else {\n+                        logger.debug(\"authentication error YIO dock\");\n+                    }\n+\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"JSON convertion failure {}\", e.toString());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3NzE4NA=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM2NTc0Mg==", "bodyText": "Done", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485365742", "createdAt": "2020-09-09T06:24:18Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,\n+                        YIOremote_DockwebSocketClientrequest);\n+                logger.debug(\"Connected websocket client\");\n+\n+                logger.debug(\"Check for authentication requested by YIO Dock\");\n+                YIOremoteDockwebSocket_ClientSocket.getLatch().await();\n+                Thread.sleep(1000);\n+\n+                try {\n+                    if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_required()) {\n+                        logger.debug(\"send authentication to YIO dock\");\n+                        YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                config.yiodockaccesstoken);\n+                        Thread.sleep(1000);\n+\n+                        if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_ok()) {\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED;\n+\n+                        } else {\n+                            logger.debug(\"authentication to YIO dock not ok\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED_FAILED;\n+                        }\n+                    } else {\n+                        logger.debug(\"authentication error YIO dock\");\n+                    }\n+\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"JSON convertion failure {}\", e.toString());\n+                }\n+\n+            } catch (\n+\n+            Exception e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3NTc1OA=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM2NjIwMg==", "bodyText": "I deleted it...makes no sense", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485366202", "createdAt": "2020-09-09T06:25:19Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,\n+                        YIOremote_DockwebSocketClientrequest);\n+                logger.debug(\"Connected websocket client\");\n+\n+                logger.debug(\"Check for authentication requested by YIO Dock\");\n+                YIOremoteDockwebSocket_ClientSocket.getLatch().await();\n+                Thread.sleep(1000);\n+\n+                try {\n+                    if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_required()) {\n+                        logger.debug(\"send authentication to YIO dock\");\n+                        YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                config.yiodockaccesstoken);\n+                        Thread.sleep(1000);\n+\n+                        if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_ok()) {\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED;\n+\n+                        } else {\n+                            logger.debug(\"authentication to YIO dock not ok\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED_FAILED;\n+                        }\n+                    } else {\n+                        logger.debug(\"authentication error YIO dock\");\n+                    }\n+\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"JSON convertion failure {}\", e.toString());\n+                }\n+\n+            } catch (\n+\n+            Exception e) {\n+                logger.warn(\"Web socket connect failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+        } catch (URISyntaxException e) {\n+            logger.debug(\"Initialize web socket failed {}\", e.toString());\n+        }\n+\n+        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+            updateStatus(ThingStatus.ONLINE);\n+            Runnable heartbeatpolling = new Runnable() {\n+                @Override\n+                public void run() {\n+                    try {\n+                        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                            YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                            Thread.sleep(1000);\n+\n+                            if (YIOremoteDockwebSocket_ClientSocket.get_boolean_heartbeat()) {\n+                                logger.debug(\"heartbeat ok\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                        YIOremoteDockwebSocket_ClientSocket.get_string_receivedstatus());\n+                            } else {\n+                                logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                                YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                        \"Connection lost no ping from YIO DOCK\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                                pollingJob.cancel(true);\n+                            }\n+                        } else {\n+                            logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                    \"Connection lost no ping from YIO DOCK\");\n+                            updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                            pollingJob.cancel(true);\n+                        }\n+                    } catch (InterruptedException e) {\n+                        logger.warn(\"Error during initializing the WebSocket polling Thread {}\", e.toString());\n+                    }\n+                }\n+            };\n+            try {\n+                pollingJob = scheduler.scheduleWithFixedDelay(heartbeatpolling, 0, 30, TimeUnit.SECONDS);\n+            } catch (Exception e) {\n+                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                logger.warn(\"Error during starting the WebSocket polling Thread {}\", e.toString());\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE);\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+        pollingJob.cancel(true);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+\n+        if (YIODOCKRECEIVERSWITCH.equals(channelUID.getIdWithoutGroup())) {\n+            if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                if (command instanceof RefreshType) {\n+                    // TODO: handle data refresh", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3OTg2MA=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 189}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM2NzI1Mw==", "bodyText": "Cool thanks for the input changed", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r485367253", "createdAt": "2020-09-09T06:27:42Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,56 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"yioremote\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\t<!-- Sample Thing Type -->\n+\t<thing-type id=\"yioremotedock\">\n+\t\t<label>YIOremote Dock Binding Thing</label>\n+\t\t<description>YIOremote Dock Binding Thing</description>\n+\t\t<channel-groups>\n+\t\t\t<channel-group id=\"input\" typeId=\"input\"/>\n+\t\t\t<channel-group id=\"output\" typeId=\"output\"/>\n+\t\t</channel-groups>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"yiodockhost\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Host/IP Address of the YIO Dock</label>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4NTExMQ=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYxNDk3Mg==", "bodyText": "Don't Understand what you mean?", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r486614972", "createdAt": "2020-09-10T20:29:37Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/README.md", "diffHunk": "@@ -0,0 +1,59 @@\n+# YIOremote Binding\n+\n+This binding will control a YIO Dock/Remote combination. YIO Remote/Dock is a smart home solution that includes an IP based remote. More information can be found at [yio-remote](https://www.yio-remote.com/) or in the forums at [yio-remote](https://community.yio-remote.com/). \n+\n+This binding has been designed to compliment the YIO websocket Transport Protocol.\n+\n+Since this binding allows actual you to trigger IR send/receive actions on YIO Dock, this allows you to use the YIO Dock as an IR solution to openHAB and even learn new IR codes from your remotes. In other words, if the IR code is known then openHAB can use the YIO Dock to control that Device regardless if there is an openHAB binding for it or not.\n+\n+## Supported Things\n+\n+* Thing: YIO Dock.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE2OTE4Nw=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYxNTIxOA==", "bodyText": "Action Handler is implemented", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r486615218", "createdAt": "2020-09-10T20:30:06Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/README.md", "diffHunk": "@@ -0,0 +1,59 @@\n+# YIOremote Binding\n+\n+This binding will control a YIO Dock/Remote combination. YIO Remote/Dock is a smart home solution that includes an IP based remote. More information can be found at [yio-remote](https://www.yio-remote.com/) or in the forums at [yio-remote](https://community.yio-remote.com/). \n+\n+This binding has been designed to compliment the YIO websocket Transport Protocol.\n+\n+Since this binding allows actual you to trigger IR send/receive actions on YIO Dock, this allows you to use the YIO Dock as an IR solution to openHAB and even learn new IR codes from your remotes. In other words, if the IR code is known then openHAB can use the YIO Dock to control that Device regardless if there is an openHAB binding for it or not.\n+\n+## Supported Things\n+\n+* Thing: YIO Dock.\n+\n+The following are the configurations available to each of the bridges/things:\n+\n+### YIO Dock\n+\n+| Name                 | Type    | Required | Default | Description                                                                                                    |\n+|----------------------|---------|----------|---------|----------------------------------------------------------------------------------------------------------------|\n+| yiodockhost\t       | string  | Yes      | (None)  | Host/IP Address or host name of the YIO Dock                                                                   |\n+| yiodockaccesstoken   | string  | Yes      | 0       | The authentication token for the access currently 0                                                            |\n+                                                      \n+## Channels\n+\n+### YIO Dock\n+\n+The YIO Dock has the following channels:\n+\n+| Channel \t\t     \t\t| Input/Output \t| Item Type    | Description                                                                                \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|\n+|---------------------------|---------------|--------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| yiodockreceiverswitch     | Input         | Switch       | The switch to enable diable the IR reciving diode/function                                 \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|\n+| yiodocksendircode\t\t    | Input         | String       | The IR Code Format(3;0x20DF40BF;32;0) which will send by the YIO Dock                     \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3MDI5NA=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYxNTYwNQ==", "bodyText": "Done", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r486615605", "createdAt": "2020-09-10T20:30:55Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3MTQyNQ=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYxNTg5OA==", "bodyText": "Done", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r486615898", "createdAt": "2020-09-10T20:31:34Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3Mjc2Mg=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYxNjA3Nw==", "bodyText": "scheduler task implemented", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r486616077", "createdAt": "2020-09-10T20:31:53Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3NDMzOA=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYxNjE5Mw==", "bodyText": "to wait for the message", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r486616193", "createdAt": "2020-09-10T20:32:11Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,\n+                        YIOremote_DockwebSocketClientrequest);\n+                logger.debug(\"Connected websocket client\");\n+\n+                logger.debug(\"Check for authentication requested by YIO Dock\");\n+                YIOremoteDockwebSocket_ClientSocket.getLatch().await();\n+                Thread.sleep(1000);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3NTQ3Mw=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYxNjQ5NQ==", "bodyText": "removed the logging", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r486616495", "createdAt": "2020-09-10T20:32:51Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,\n+                        YIOremote_DockwebSocketClientrequest);\n+                logger.debug(\"Connected websocket client\");\n+\n+                logger.debug(\"Check for authentication requested by YIO Dock\");\n+                YIOremoteDockwebSocket_ClientSocket.getLatch().await();\n+                Thread.sleep(1000);\n+\n+                try {\n+                    if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_required()) {\n+                        logger.debug(\"send authentication to YIO dock\");\n+                        YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                config.yiodockaccesstoken);\n+                        Thread.sleep(1000);\n+\n+                        if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_ok()) {\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED;\n+\n+                        } else {\n+                            logger.debug(\"authentication to YIO dock not ok\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED_FAILED;\n+                        }\n+                    } else {\n+                        logger.debug(\"authentication error YIO dock\");\n+                    }\n+\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"JSON convertion failure {}\", e.toString());\n+                }\n+\n+            } catch (\n+\n+            Exception e) {\n+                logger.warn(\"Web socket connect failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+        } catch (URISyntaxException e) {\n+            logger.debug(\"Initialize web socket failed {}\", e.toString());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3NjcwMg=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYxNjYwOQ==", "bodyText": "removed", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r486616609", "createdAt": "2020-09-10T20:33:03Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,\n+                        YIOremote_DockwebSocketClientrequest);\n+                logger.debug(\"Connected websocket client\");\n+\n+                logger.debug(\"Check for authentication requested by YIO Dock\");\n+                YIOremoteDockwebSocket_ClientSocket.getLatch().await();\n+                Thread.sleep(1000);\n+\n+                try {\n+                    if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_required()) {\n+                        logger.debug(\"send authentication to YIO dock\");\n+                        YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                config.yiodockaccesstoken);\n+                        Thread.sleep(1000);\n+\n+                        if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_ok()) {\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED;\n+\n+                        } else {\n+                            logger.debug(\"authentication to YIO dock not ok\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED_FAILED;\n+                        }\n+                    } else {\n+                        logger.debug(\"authentication error YIO dock\");\n+                    }\n+\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"JSON convertion failure {}\", e.toString());\n+                }\n+\n+            } catch (\n+\n+            Exception e) {\n+                logger.warn(\"Web socket connect failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+        } catch (URISyntaxException e) {\n+            logger.debug(\"Initialize web socket failed {}\", e.toString());\n+        }\n+\n+        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+            updateStatus(ThingStatus.ONLINE);\n+            Runnable heartbeatpolling = new Runnable() {\n+                @Override\n+                public void run() {\n+                    try {\n+                        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                            YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                            Thread.sleep(1000);\n+\n+                            if (YIOremoteDockwebSocket_ClientSocket.get_boolean_heartbeat()) {\n+                                logger.debug(\"heartbeat ok\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                        YIOremoteDockwebSocket_ClientSocket.get_string_receivedstatus());\n+                            } else {\n+                                logger.warn(\"Connection lost no ping from YIO DOCK\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3NzU0OA=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY2MDYyMg==", "bodyText": "SOlved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r486660622", "createdAt": "2020-09-10T22:08:08Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,\n+                        YIOremote_DockwebSocketClientrequest);\n+                logger.debug(\"Connected websocket client\");\n+\n+                logger.debug(\"Check for authentication requested by YIO Dock\");\n+                YIOremoteDockwebSocket_ClientSocket.getLatch().await();\n+                Thread.sleep(1000);\n+\n+                try {\n+                    if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_required()) {\n+                        logger.debug(\"send authentication to YIO dock\");\n+                        YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                config.yiodockaccesstoken);\n+                        Thread.sleep(1000);\n+\n+                        if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_ok()) {\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED;\n+\n+                        } else {\n+                            logger.debug(\"authentication to YIO dock not ok\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED_FAILED;\n+                        }\n+                    } else {\n+                        logger.debug(\"authentication error YIO dock\");\n+                    }\n+\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"JSON convertion failure {}\", e.toString());\n+                }\n+\n+            } catch (\n+\n+            Exception e) {\n+                logger.warn(\"Web socket connect failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+        } catch (URISyntaxException e) {\n+            logger.debug(\"Initialize web socket failed {}\", e.toString());\n+        }\n+\n+        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+            updateStatus(ThingStatus.ONLINE);\n+            Runnable heartbeatpolling = new Runnable() {\n+                @Override\n+                public void run() {\n+                    try {\n+                        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                            YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                            Thread.sleep(1000);\n+\n+                            if (YIOremoteDockwebSocket_ClientSocket.get_boolean_heartbeat()) {\n+                                logger.debug(\"heartbeat ok\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                        YIOremoteDockwebSocket_ClientSocket.get_string_receivedstatus());\n+                            } else {\n+                                logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                                YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                        \"Connection lost no ping from YIO DOCK\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3ODE0MQ=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY2MDk0Ng==", "bodyText": "solved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r486660946", "createdAt": "2020-09-10T22:08:59Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,\n+                        YIOremote_DockwebSocketClientrequest);\n+                logger.debug(\"Connected websocket client\");\n+\n+                logger.debug(\"Check for authentication requested by YIO Dock\");\n+                YIOremoteDockwebSocket_ClientSocket.getLatch().await();\n+                Thread.sleep(1000);\n+\n+                try {\n+                    if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_required()) {\n+                        logger.debug(\"send authentication to YIO dock\");\n+                        YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                config.yiodockaccesstoken);\n+                        Thread.sleep(1000);\n+\n+                        if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_ok()) {\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED;\n+\n+                        } else {\n+                            logger.debug(\"authentication to YIO dock not ok\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED_FAILED;\n+                        }\n+                    } else {\n+                        logger.debug(\"authentication error YIO dock\");\n+                    }\n+\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"JSON convertion failure {}\", e.toString());\n+                }\n+\n+            } catch (\n+\n+            Exception e) {\n+                logger.warn(\"Web socket connect failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+        } catch (URISyntaxException e) {\n+            logger.debug(\"Initialize web socket failed {}\", e.toString());\n+        }\n+\n+        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+            updateStatus(ThingStatus.ONLINE);\n+            Runnable heartbeatpolling = new Runnable() {\n+                @Override\n+                public void run() {\n+                    try {\n+                        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                            YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                            Thread.sleep(1000);\n+\n+                            if (YIOremoteDockwebSocket_ClientSocket.get_boolean_heartbeat()) {\n+                                logger.debug(\"heartbeat ok\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                        YIOremoteDockwebSocket_ClientSocket.get_string_receivedstatus());\n+                            } else {\n+                                logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                                YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                        \"Connection lost no ping from YIO DOCK\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                                pollingJob.cancel(true);\n+                            }\n+                        } else {\n+                            logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                    \"Connection lost no ping from YIO DOCK\");\n+                            updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                            pollingJob.cancel(true);\n+                        }\n+                    } catch (InterruptedException e) {\n+                        logger.warn(\"Error during initializing the WebSocket polling Thread {}\", e.toString());\n+                    }\n+                }\n+            };\n+            try {\n+                pollingJob = scheduler.scheduleWithFixedDelay(heartbeatpolling, 0, 30, TimeUnit.SECONDS);\n+            } catch (Exception e) {\n+                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                logger.warn(\"Error during starting the WebSocket polling Thread {}\", e.toString());\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE);\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+        pollingJob.cancel(true);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+\n+        if (YIODOCKRECEIVERSWITCH.equals(channelUID.getIdWithoutGroup())) {\n+            if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                if (command instanceof RefreshType) {\n+                    // TODO: handle data refresh\n+\n+                }\n+\n+                if (command.toString().equals(\"ON\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVERON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVEROFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+\n+            } else {\n+                logger.warn(\"YIOremoteDockHandler not authenticated\");\n+            }\n+\n+        } else if (YIODOCKSENDIRCODE.equals(channelUID.getIdWithoutGroup())) {\n+            if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                if (command instanceof RefreshType) {\n+                    // TODO: handle data refresh\n+                    // logger.warn(\"YIOremoteDockHandler not authenticated\");\n+                }\n+                logger.debug(\"YIODOCKSENDIRCODE procedure: {}\", command.toString());\n+                send_ircode = command.toString();\n+                if (send_ircode.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.IRSEND, send_ircode);\n+                } else {\n+                    logger.warn(\"Wrong IR code Format {}\", send_ircode);\n+                    send_ircode = \"\";\n+                }\n+            } else {\n+                logger.warn(\"YIOremoteDockHandler not authenticated\");\n+            }\n+        }\n+    }\n+\n+    protected void updateChannelString(String group, String channelId, String value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+\n+        if (isLinked(id)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4MTEzMQ=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 230}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY2MTA5OQ==", "bodyText": "solved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r486661099", "createdAt": "2020-09-10T22:09:21Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockWebsocket.java", "diffHunk": "@@ -0,0 +1,250 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import java.io.IOException;\n+import java.util.concurrent.CountDownLatch;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.api.Session;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketConnect;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketError;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketMessage;\n+import org.eclipse.jetty.websocket.api.annotations.WebSocket;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockWebsocket} is responsible for the Websocket Connection to the YIO Remote Dock\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+@WebSocket\n+public class YIOremoteDockWebsocket {\n+\n+    private @Nullable Session session;\n+    private String string_receivedmessage = \"\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4MTI2MQ=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY2MTE5MA==", "bodyText": "solved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r486661190", "createdAt": "2020-09-10T22:09:35Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockWebsocket.java", "diffHunk": "@@ -0,0 +1,250 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import java.io.IOException;\n+import java.util.concurrent.CountDownLatch;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.api.Session;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketConnect;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketError;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketMessage;\n+import org.eclipse.jetty.websocket.api.annotations.WebSocket;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockWebsocket} is responsible for the Websocket Connection to the YIO Remote Dock\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+@WebSocket\n+public class YIOremoteDockWebsocket {\n+\n+    private @Nullable Session session;\n+    private String string_receivedmessage = \"\";\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockWebsocket.class);\n+    private JsonObject JsonObject_recievedJsonObject = new JsonObject();\n+    private boolean boolean_authentication_required = false;\n+    private boolean boolean_heartbeat = false;\n+    private boolean boolean_authentication_ok = false;\n+    private boolean boolean_sendir_status = false;\n+    private String string_receivedstatus = \"\";\n+    private String string_lastsendircode = \"\";\n+\n+    CountDownLatch latch = new CountDownLatch(1);\n+\n+    @OnWebSocketMessage\n+    public void onText(Session session, String message) throws IOException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4MjM5Nw=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY2MTI0Nw==", "bodyText": "not sure", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r486661247", "createdAt": "2020-09-10T22:09:45Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockWebsocket.java", "diffHunk": "@@ -0,0 +1,250 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import java.io.IOException;\n+import java.util.concurrent.CountDownLatch;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.api.Session;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketConnect;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketError;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketMessage;\n+import org.eclipse.jetty.websocket.api.annotations.WebSocket;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockWebsocket} is responsible for the Websocket Connection to the YIO Remote Dock\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+@WebSocket\n+public class YIOremoteDockWebsocket {\n+\n+    private @Nullable Session session;\n+    private String string_receivedmessage = \"\";\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockWebsocket.class);\n+    private JsonObject JsonObject_recievedJsonObject = new JsonObject();\n+    private boolean boolean_authentication_required = false;\n+    private boolean boolean_heartbeat = false;\n+    private boolean boolean_authentication_ok = false;\n+    private boolean boolean_sendir_status = false;\n+    private String string_receivedstatus = \"\";\n+    private String string_lastsendircode = \"\";\n+\n+    CountDownLatch latch = new CountDownLatch(1);\n+\n+    @OnWebSocketMessage\n+    public void onText(Session session, String message) throws IOException {\n+        logger.debug(\"Message received from server: {}\", message);\n+        string_receivedmessage = message;\n+        JsonObject_recievedJsonObject = convert_StringtoJsonObject(string_receivedmessage);\n+        if (decode_receivedMessage(JsonObject_recievedJsonObject)) {\n+            logger.debug(\"Message {} decoded\", string_receivedmessage);\n+        } else {\n+            logger.debug(\"Error during message {} decoding\", string_receivedmessage);\n+        }\n+    }\n+\n+    public String get_string_receivedmessage() {\n+        return this.string_receivedmessage;\n+    }\n+\n+    @OnWebSocketConnect\n+    public void onConnect(Session session) {\n+        this.session = session;\n+        latch.countDown();\n+    }\n+\n+    @OnWebSocketError\n+    public void onError(Throwable cause) {\n+        try {\n+            boolean_heartbeat = false;\n+        } catch (Exception ex) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4MTUwNA=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY2MTQ0MQ==", "bodyText": "solved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r486661441", "createdAt": "2020-09-10T22:10:17Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockWebsocket.java", "diffHunk": "@@ -0,0 +1,250 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import java.io.IOException;\n+import java.util.concurrent.CountDownLatch;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.api.Session;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketConnect;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketError;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketMessage;\n+import org.eclipse.jetty.websocket.api.annotations.WebSocket;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockWebsocket} is responsible for the Websocket Connection to the YIO Remote Dock\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+@WebSocket\n+public class YIOremoteDockWebsocket {\n+\n+    private @Nullable Session session;\n+    private String string_receivedmessage = \"\";\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockWebsocket.class);\n+    private JsonObject JsonObject_recievedJsonObject = new JsonObject();\n+    private boolean boolean_authentication_required = false;\n+    private boolean boolean_heartbeat = false;\n+    private boolean boolean_authentication_ok = false;\n+    private boolean boolean_sendir_status = false;\n+    private String string_receivedstatus = \"\";\n+    private String string_lastsendircode = \"\";\n+\n+    CountDownLatch latch = new CountDownLatch(1);\n+\n+    @OnWebSocketMessage\n+    public void onText(Session session, String message) throws IOException {\n+        logger.debug(\"Message received from server: {}\", message);\n+        string_receivedmessage = message;\n+        JsonObject_recievedJsonObject = convert_StringtoJsonObject(string_receivedmessage);\n+        if (decode_receivedMessage(JsonObject_recievedJsonObject)) {\n+            logger.debug(\"Message {} decoded\", string_receivedmessage);\n+        } else {\n+            logger.debug(\"Error during message {} decoding\", string_receivedmessage);\n+        }\n+    }\n+\n+    public String get_string_receivedmessage() {\n+        return this.string_receivedmessage;\n+    }\n+\n+    @OnWebSocketConnect\n+    public void onConnect(Session session) {\n+        this.session = session;\n+        latch.countDown();\n+    }\n+\n+    @OnWebSocketError\n+    public void onError(Throwable cause) {\n+        try {\n+            boolean_heartbeat = false;\n+        } catch (Exception ex) {\n+            logger.debug(\"WebSocketError\");\n+        }\n+    }\n+\n+    public void sendMessage(String str) {\n+        try {\n+            session.getRemote().sendString(str);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4MjU0MQ=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY2MTUxNA==", "bodyText": "fixed", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r486661514", "createdAt": "2020-09-10T22:10:27Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockWebsocket.java", "diffHunk": "@@ -0,0 +1,250 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import java.io.IOException;\n+import java.util.concurrent.CountDownLatch;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.api.Session;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketConnect;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketError;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketMessage;\n+import org.eclipse.jetty.websocket.api.annotations.WebSocket;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockWebsocket} is responsible for the Websocket Connection to the YIO Remote Dock\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+@WebSocket\n+public class YIOremoteDockWebsocket {\n+\n+    private @Nullable Session session;\n+    private String string_receivedmessage = \"\";\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockWebsocket.class);\n+    private JsonObject JsonObject_recievedJsonObject = new JsonObject();\n+    private boolean boolean_authentication_required = false;\n+    private boolean boolean_heartbeat = false;\n+    private boolean boolean_authentication_ok = false;\n+    private boolean boolean_sendir_status = false;\n+    private String string_receivedstatus = \"\";\n+    private String string_lastsendircode = \"\";\n+\n+    CountDownLatch latch = new CountDownLatch(1);\n+\n+    @OnWebSocketMessage\n+    public void onText(Session session, String message) throws IOException {\n+        logger.debug(\"Message received from server: {}\", message);\n+        string_receivedmessage = message;\n+        JsonObject_recievedJsonObject = convert_StringtoJsonObject(string_receivedmessage);\n+        if (decode_receivedMessage(JsonObject_recievedJsonObject)) {\n+            logger.debug(\"Message {} decoded\", string_receivedmessage);\n+        } else {\n+            logger.debug(\"Error during message {} decoding\", string_receivedmessage);\n+        }\n+    }\n+\n+    public String get_string_receivedmessage() {\n+        return this.string_receivedmessage;\n+    }\n+\n+    @OnWebSocketConnect\n+    public void onConnect(Session session) {\n+        this.session = session;\n+        latch.countDown();\n+    }\n+\n+    @OnWebSocketError\n+    public void onError(Throwable cause) {\n+        try {\n+            boolean_heartbeat = false;\n+        } catch (Exception ex) {\n+            logger.debug(\"WebSocketError\");\n+        }\n+    }\n+\n+    public void sendMessage(String str) {\n+        try {\n+            session.getRemote().sendString(str);\n+        } catch (IOException e) {\n+            logger.warn(\"Error during sendMessage function {}\", e.toString());\n+        }\n+    }\n+\n+    public void sendMessage(YIOREMOTEMESSAGETYPE messagetype, String messagepyload) {\n+        try {\n+            if (messagetype.equals(YIOREMOTEMESSAGETYPE.AUTHENTICATE)) {\n+                session.getRemote().sendString(\"{\\\"type\\\":\\\"auth\\\", \\\"token\\\":\\\"\" + messagepyload + \"\\\"}\");\n+                logger.debug(\"sending authenticating message: \\\"{\\\"type\\\":\\\"auth\\\", \\\"token\\\":\\\"{}\\\"}\\\"\",\n+                        messagepyload);\n+            } else if (messagetype.equals(YIOREMOTEMESSAGETYPE.HEARTBEAT)) {\n+                string_lastsendircode = \"\\\"0;0x0;0;0\\\"\";\n+                session.getRemote().sendString(\n+                        \"{\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_send\\\",\\\"code\\\":\\\"0;0x0;0;0\\\", \\\"format\\\":\\\"hex\\\"}\");\n+                logger.debug(\n+                        \"sending heartbeat message: {\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_send\\\",\\\"code\\\":\\\"0;0x0;0;0\\\", \\\"format\\\":\\\"hex\\\"}\");\n+            } else if (messagetype.equals(YIOREMOTEMESSAGETYPE.IRRECEIVERON)) {\n+                session.getRemote().sendString(\"{\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_receive_on\\\"}\");\n+                logger.debug(\"sending heartbeat message: {\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_receive_on\\\"\");\n+            } else if (messagetype.equals(YIOREMOTEMESSAGETYPE.IRRECEIVEROFF)) {\n+                session.getRemote().sendString(\"{\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_receive_off\\\"}\");\n+                logger.debug(\"sending heartbeat message: {\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_receive_off\\\"\");\n+            } else if (messagetype.equals(YIOREMOTEMESSAGETYPE.IRSEND)) {\n+                session.getRemote().sendString(\"{\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_send\\\",\\\"code\\\":\\\"\" + messagepyload\n+                        + \"\\\", \\\"format\\\":\\\"hex\\\"}\");\n+                string_lastsendircode = messagepyload;\n+                logger.debug(\n+                        \"sending heartbeat message: {\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_send\\\",\\\"code\\\":\\\"{}\\\", \\\"format\\\":\\\"hex\\\"}\",\n+                        messagepyload);\n+            }\n+        } catch (\n+\n+        IOException e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4MjgwNg=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY2MTYyNg==", "bodyText": "solved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r486661626", "createdAt": "2020-09-10T22:10:43Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/resources/ESH-INF/i18n/yioremote_de_DE.properties", "diffHunk": "@@ -0,0 +1,23 @@\n+# FIXME: please substitute the xx_XX with a proper locale, ie. de_DE\n+# FIXME: please do not add the file to the repo if you add or change no content\n+# binding\n+binding.yioremote.name = YIOremote Addon\n+binding.yioremote.description = Diese Addon kontrolliert eine YIO Dock / Remote-Kombination", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4NDIyMA=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY2MTcxNw==", "bodyText": "solved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r486661717", "createdAt": "2020-09-10T22:10:59Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockWebsocket.java", "diffHunk": "@@ -0,0 +1,250 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import java.io.IOException;\n+import java.util.concurrent.CountDownLatch;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.api.Session;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketConnect;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketError;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketMessage;\n+import org.eclipse.jetty.websocket.api.annotations.WebSocket;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockWebsocket} is responsible for the Websocket Connection to the YIO Remote Dock\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+@WebSocket\n+public class YIOremoteDockWebsocket {\n+\n+    private @Nullable Session session;\n+    private String string_receivedmessage = \"\";\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockWebsocket.class);\n+    private JsonObject JsonObject_recievedJsonObject = new JsonObject();\n+    private boolean boolean_authentication_required = false;\n+    private boolean boolean_heartbeat = false;\n+    private boolean boolean_authentication_ok = false;\n+    private boolean boolean_sendir_status = false;\n+    private String string_receivedstatus = \"\";\n+    private String string_lastsendircode = \"\";\n+\n+    CountDownLatch latch = new CountDownLatch(1);\n+\n+    @OnWebSocketMessage\n+    public void onText(Session session, String message) throws IOException {\n+        logger.debug(\"Message received from server: {}\", message);\n+        string_receivedmessage = message;\n+        JsonObject_recievedJsonObject = convert_StringtoJsonObject(string_receivedmessage);\n+        if (decode_receivedMessage(JsonObject_recievedJsonObject)) {\n+            logger.debug(\"Message {} decoded\", string_receivedmessage);\n+        } else {\n+            logger.debug(\"Error during message {} decoding\", string_receivedmessage);\n+        }\n+    }\n+\n+    public String get_string_receivedmessage() {\n+        return this.string_receivedmessage;\n+    }\n+\n+    @OnWebSocketConnect\n+    public void onConnect(Session session) {\n+        this.session = session;\n+        latch.countDown();\n+    }\n+\n+    @OnWebSocketError\n+    public void onError(Throwable cause) {\n+        try {\n+            boolean_heartbeat = false;\n+        } catch (Exception ex) {\n+            logger.debug(\"WebSocketError\");\n+        }\n+    }\n+\n+    public void sendMessage(String str) {\n+        try {\n+            session.getRemote().sendString(str);\n+        } catch (IOException e) {\n+            logger.warn(\"Error during sendMessage function {}\", e.toString());\n+        }\n+    }\n+\n+    public void sendMessage(YIOREMOTEMESSAGETYPE messagetype, String messagepyload) {\n+        try {\n+            if (messagetype.equals(YIOREMOTEMESSAGETYPE.AUTHENTICATE)) {\n+                session.getRemote().sendString(\"{\\\"type\\\":\\\"auth\\\", \\\"token\\\":\\\"\" + messagepyload + \"\\\"}\");\n+                logger.debug(\"sending authenticating message: \\\"{\\\"type\\\":\\\"auth\\\", \\\"token\\\":\\\"{}\\\"}\\\"\",\n+                        messagepyload);\n+            } else if (messagetype.equals(YIOREMOTEMESSAGETYPE.HEARTBEAT)) {\n+                string_lastsendircode = \"\\\"0;0x0;0;0\\\"\";\n+                session.getRemote().sendString(\n+                        \"{\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_send\\\",\\\"code\\\":\\\"0;0x0;0;0\\\", \\\"format\\\":\\\"hex\\\"}\");\n+                logger.debug(\n+                        \"sending heartbeat message: {\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_send\\\",\\\"code\\\":\\\"0;0x0;0;0\\\", \\\"format\\\":\\\"hex\\\"}\");\n+            } else if (messagetype.equals(YIOREMOTEMESSAGETYPE.IRRECEIVERON)) {\n+                session.getRemote().sendString(\"{\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_receive_on\\\"}\");\n+                logger.debug(\"sending heartbeat message: {\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_receive_on\\\"\");\n+            } else if (messagetype.equals(YIOREMOTEMESSAGETYPE.IRRECEIVEROFF)) {\n+                session.getRemote().sendString(\"{\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_receive_off\\\"}\");\n+                logger.debug(\"sending heartbeat message: {\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_receive_off\\\"\");\n+            } else if (messagetype.equals(YIOREMOTEMESSAGETYPE.IRSEND)) {\n+                session.getRemote().sendString(\"{\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_send\\\",\\\"code\\\":\\\"\" + messagepyload\n+                        + \"\\\", \\\"format\\\":\\\"hex\\\"}\");\n+                string_lastsendircode = messagepyload;\n+                logger.debug(\n+                        \"sending heartbeat message: {\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_send\\\",\\\"code\\\":\\\"{}\\\", \\\"format\\\":\\\"hex\\\"}\",\n+                        messagepyload);\n+            }\n+        } catch (\n+\n+        IOException e) {\n+            logger.warn(\"Error during sendMessage function {}\", e.toString());\n+        }\n+    }\n+\n+    private boolean decode_receivedMessage(JsonObject JsonObject_recievedJsonObject) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4MjkxMg=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY2MTgzOA==", "bodyText": "not sure therefore leve it as it is", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r486661838", "createdAt": "2020-09-10T22:11:18Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,\n+                        YIOremote_DockwebSocketClientrequest);\n+                logger.debug(\"Connected websocket client\");\n+\n+                logger.debug(\"Check for authentication requested by YIO Dock\");\n+                YIOremoteDockwebSocket_ClientSocket.getLatch().await();\n+                Thread.sleep(1000);\n+\n+                try {\n+                    if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_required()) {\n+                        logger.debug(\"send authentication to YIO dock\");\n+                        YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                config.yiodockaccesstoken);\n+                        Thread.sleep(1000);\n+\n+                        if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_ok()) {\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED;\n+\n+                        } else {\n+                            logger.debug(\"authentication to YIO dock not ok\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED_FAILED;\n+                        }\n+                    } else {\n+                        logger.debug(\"authentication error YIO dock\");\n+                    }\n+\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"JSON convertion failure {}\", e.toString());\n+                }\n+\n+            } catch (\n+\n+            Exception e) {\n+                logger.warn(\"Web socket connect failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+        } catch (URISyntaxException e) {\n+            logger.debug(\"Initialize web socket failed {}\", e.toString());\n+        }\n+\n+        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+            updateStatus(ThingStatus.ONLINE);\n+            Runnable heartbeatpolling = new Runnable() {\n+                @Override\n+                public void run() {\n+                    try {\n+                        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                            YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                            Thread.sleep(1000);\n+\n+                            if (YIOremoteDockwebSocket_ClientSocket.get_boolean_heartbeat()) {\n+                                logger.debug(\"heartbeat ok\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                        YIOremoteDockwebSocket_ClientSocket.get_string_receivedstatus());\n+                            } else {\n+                                logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                                YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                        \"Connection lost no ping from YIO DOCK\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                                pollingJob.cancel(true);\n+                            }\n+                        } else {\n+                            logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                    \"Connection lost no ping from YIO DOCK\");\n+                            updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                            pollingJob.cancel(true);\n+                        }\n+                    } catch (InterruptedException e) {\n+                        logger.warn(\"Error during initializing the WebSocket polling Thread {}\", e.toString());\n+                    }\n+                }\n+            };\n+            try {\n+                pollingJob = scheduler.scheduleWithFixedDelay(heartbeatpolling, 0, 30, TimeUnit.SECONDS);\n+            } catch (Exception e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3ODQ5MA=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 166}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY2MTkzMA==", "bodyText": "solved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r486661930", "createdAt": "2020-09-10T22:11:35Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,\n+                        YIOremote_DockwebSocketClientrequest);\n+                logger.debug(\"Connected websocket client\");\n+\n+                logger.debug(\"Check for authentication requested by YIO Dock\");\n+                YIOremoteDockwebSocket_ClientSocket.getLatch().await();\n+                Thread.sleep(1000);\n+\n+                try {\n+                    if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_required()) {\n+                        logger.debug(\"send authentication to YIO dock\");\n+                        YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                config.yiodockaccesstoken);\n+                        Thread.sleep(1000);\n+\n+                        if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_ok()) {\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED;\n+\n+                        } else {\n+                            logger.debug(\"authentication to YIO dock not ok\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED_FAILED;\n+                        }\n+                    } else {\n+                        logger.debug(\"authentication error YIO dock\");\n+                    }\n+\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"JSON convertion failure {}\", e.toString());\n+                }\n+\n+            } catch (\n+\n+            Exception e) {\n+                logger.warn(\"Web socket connect failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+        } catch (URISyntaxException e) {\n+            logger.debug(\"Initialize web socket failed {}\", e.toString());\n+        }\n+\n+        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+            updateStatus(ThingStatus.ONLINE);\n+            Runnable heartbeatpolling = new Runnable() {\n+                @Override\n+                public void run() {\n+                    try {\n+                        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                            YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                            Thread.sleep(1000);\n+\n+                            if (YIOremoteDockwebSocket_ClientSocket.get_boolean_heartbeat()) {\n+                                logger.debug(\"heartbeat ok\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                        YIOremoteDockwebSocket_ClientSocket.get_string_receivedstatus());\n+                            } else {\n+                                logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                                YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                        \"Connection lost no ping from YIO DOCK\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                                pollingJob.cancel(true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3OTI3NA=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY2MjEwMg==", "bodyText": "not sure which one....therefore leave it for the first release", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r486662102", "createdAt": "2020-09-10T22:12:06Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,\n+                        YIOremote_DockwebSocketClientrequest);\n+                logger.debug(\"Connected websocket client\");\n+\n+                logger.debug(\"Check for authentication requested by YIO Dock\");\n+                YIOremoteDockwebSocket_ClientSocket.getLatch().await();\n+                Thread.sleep(1000);\n+\n+                try {\n+                    if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_required()) {\n+                        logger.debug(\"send authentication to YIO dock\");\n+                        YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                config.yiodockaccesstoken);\n+                        Thread.sleep(1000);\n+\n+                        if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_ok()) {\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED;\n+\n+                        } else {\n+                            logger.debug(\"authentication to YIO dock not ok\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED_FAILED;\n+                        }\n+                    } else {\n+                        logger.debug(\"authentication error YIO dock\");\n+                    }\n+\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"JSON convertion failure {}\", e.toString());\n+                }\n+\n+            } catch (\n+\n+            Exception e) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3NTk1NA=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY2MjE5OQ==", "bodyText": "removed", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r486662199", "createdAt": "2020-09-10T22:12:18Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3MjkxOA=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY2MjU2MA==", "bodyText": "yes solved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r486662560", "createdAt": "2020-09-10T22:13:16Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3Mjc2Mg=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY2MjYxMQ==", "bodyText": "removed", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r486662611", "createdAt": "2020-09-10T22:13:25Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3MjQxMg=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY2MjcyNQ==", "bodyText": "changed to trigger channel", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r486662725", "createdAt": "2020-09-10T22:13:43Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/README.md", "diffHunk": "@@ -0,0 +1,59 @@\n+# YIOremote Binding\n+\n+This binding will control a YIO Dock/Remote combination. YIO Remote/Dock is a smart home solution that includes an IP based remote. More information can be found at [yio-remote](https://www.yio-remote.com/) or in the forums at [yio-remote](https://community.yio-remote.com/). \n+\n+This binding has been designed to compliment the YIO websocket Transport Protocol.\n+\n+Since this binding allows actual you to trigger IR send/receive actions on YIO Dock, this allows you to use the YIO Dock as an IR solution to openHAB and even learn new IR codes from your remotes. In other words, if the IR code is known then openHAB can use the YIO Dock to control that Device regardless if there is an openHAB binding for it or not.\n+\n+## Supported Things\n+\n+* Thing: YIO Dock.\n+\n+The following are the configurations available to each of the bridges/things:\n+\n+### YIO Dock\n+\n+| Name                 | Type    | Required | Default | Description                                                                                                    |\n+|----------------------|---------|----------|---------|----------------------------------------------------------------------------------------------------------------|\n+| yiodockhost\t       | string  | Yes      | (None)  | Host/IP Address or host name of the YIO Dock                                                                   |\n+| yiodockaccesstoken   | string  | Yes      | 0       | The authentication token for the access currently 0                                                            |\n+                                                      \n+## Channels\n+\n+### YIO Dock\n+\n+The YIO Dock has the following channels:\n+\n+| Channel \t\t     \t\t| Input/Output \t| Item Type    | Description                                                                                \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|\n+|---------------------------|---------------|--------------|------------------------------------------------------------------------------------------------------------------------------------------------------------------------|\n+| yiodockreceiverswitch     | Input         | Switch       | The switch to enable diable the IR reciving diode/function                                 \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|\n+| yiodocksendircode\t\t    | Input         | String       | The IR Code Format(3;0x20DF40BF;32;0) which will send by the YIO Dock                     \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t|\n+| yiodockstatus\t\t\t    | Output        | String       | The status of the YIO Dock. If the reciever is on than the recognized IR code will be displayed otherwise the IR send status is displayed of the last IR code send.\t|", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3MDc4Nw=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 32}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg3MjIxNzI1", "url": "https://github.com/openhab/openhab-addons/pull/8394#pullrequestreview-487221725", "createdAt": "2020-09-12T10:47:43Z", "commit": {"oid": "38f5564efadacf0ef4b99f120032e37f35477f87"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQxMDo0Nzo0M1rOHQ0Vaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQxMDo1MDo0MlrOHQ0WXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM5NjcxNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            * Thing: YIOREMOTEDOCK\n          \n          \n            \n            * Thing Type ID: `yioremotedock`", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487396715", "createdAt": "2020-09-12T10:47:43Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/README.md", "diffHunk": "@@ -0,0 +1,58 @@\n+# YIOremote Binding\n+\n+This binding will control a YIO Dock/Remote combination. YIO Remote/Dock is a smart home solution that includes an IP based remote. More information can be found at [yio-remote](https://www.yio-remote.com/) or in the forums at [yio-remote](https://community.yio-remote.com/). \n+\n+This binding has been designed to compliment the YIO websocket Transport Protocol.\n+\n+Since this binding allows actual you to trigger IR send/receive actions on YIO Dock, this allows you to use the YIO Dock as an IR solution to openHAB and even learn new IR codes from your remotes. In other words, if the IR code is known then openHAB can use the YIO Dock to control that Device regardless if there is an openHAB binding for it or not.\n+\n+## Supported Things\n+\n+* Thing: YIOREMOTEDOCK", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38f5564efadacf0ef4b99f120032e37f35477f87"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM5Njk1Ng==", "bodyText": "Did you push all of your changes? I still see this without underscores.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487396956", "createdAt": "2020-09-12T10:50:42Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteBindingConstants.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+\n+/**\n+ * The {@link YIOremoteBindingConstants} class defines common constants, which are\n+ * used across the whole binding.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteBindingConstants {\n+\n+    public static final String BINDING_ID = \"yioremote\";\n+\n+    // List of all used global variables\n+    public static enum YIOREMOTEDOCKHANDLESTATUS {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "38f5564efadacf0ef4b99f120032e37f35477f87"}, "originalPosition": 30}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg3MjI0MTI2", "url": "https://github.com/openhab/openhab-addons/pull/8394#pullrequestreview-487224126", "createdAt": "2020-09-12T11:36:55Z", "commit": {"oid": "5abbc4a5521ab2e1cf5965a3827a8d577dc07d2e"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQxMTozNjo1NVrOHQ0k8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQxMTozNjo1NVrOHQ0k8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQwMDY5MQ==", "bodyText": "There's a misunderstanding. The name of the Enum should be CamelCase and the members should be all uppercase and SNAKE_CASE.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487400691", "createdAt": "2020-09-12T11:36:55Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteBindingConstants.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+\n+/**\n+ * The {@link YIOremoteBindingConstants} class defines common constants, which are\n+ * used across the whole binding.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteBindingConstants {\n+\n+    public static final String BINDING_ID = \"yioremote\";\n+\n+    // List of all used global variables\n+    public static enum YIOREMOTEDOCKHANDLESTATUS {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzM5Njk1Ng=="}, "originalCommit": {"oid": "38f5564efadacf0ef4b99f120032e37f35477f87"}, "originalPosition": 30}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg3MjM1MTgx", "url": "https://github.com/openhab/openhab-addons/pull/8394#pullrequestreview-487235181", "createdAt": "2020-09-12T15:01:36Z", "commit": {"oid": "5abbc4a5521ab2e1cf5965a3827a8d577dc07d2e"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQxNTowMTozN1rOHQ1oog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQxNToxNzoyN1rOHQ1uPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQxODAxOA==", "bodyText": "Can the comment be removed?", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487418018", "createdAt": "2020-09-12T15:01:37Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockActions.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.binding.ThingActions;\n+import org.eclipse.smarthome.core.thing.binding.ThingActionsScope;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockActions} is responsible for handling the action commands\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@ThingActionsScope(name = \"yioremote\") // Your bindings id is usually the scope", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5abbc4a5521ab2e1cf5965a3827a8d577dc07d2e"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQxODE4MA==", "bodyText": "Can this be removed?", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487418180", "createdAt": "2020-09-12T15:03:38Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String sendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATIONPROCESS;\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.start();\n+                } catch (Exception e) {\n+                    logger.warn(\"Web socket start failed {}\", e.getMessage());\n+                    // throw new IOException(\"Web socket start failed\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5abbc4a5521ab2e1cf5965a3827a8d577dc07d2e"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQxODI5Nw==", "bodyText": "The logger is never used.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487418297", "createdAt": "2020-09-12T15:04:39Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockActions.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.binding.ThingActions;\n+import org.eclipse.smarthome.core.thing.binding.ThingActionsScope;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockActions} is responsible for handling the action commands\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@ThingActionsScope(name = \"yioremote\") // Your bindings id is usually the scope\n+@NonNullByDefault\n+public class YIOremoteDockActions implements ThingActions {\n+    private @Nullable YIOremoteDockHandler handler;\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockActions.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5abbc4a5521ab2e1cf5965a3827a8d577dc07d2e"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQxODMyMw==", "bodyText": "This is never used.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487418323", "createdAt": "2020-09-12T15:04:54Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String sendircode = \"\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5abbc4a5521ab2e1cf5965a3827a8d577dc07d2e"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQxODU3NQ==", "bodyText": "What happens if the connection never gets established? As this is a thread of a shared thread pool, it shouldn't block for a long time. A better approach would be to execute the code below from within onConnect().", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487418575", "createdAt": "2020-09-12T15:07:54Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String sendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATIONPROCESS;\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.start();\n+                } catch (Exception e) {\n+                    logger.warn(\"Web socket start failed {}\", e.getMessage());\n+                    // throw new IOException(\"Web socket start failed\");\n+                }\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient,\n+                            uriyiodockwebsocketaddress, yioremoteDockwebSocketClientrequest);\n+                    yioremoteDockwebSocketClient.getLatch().await();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5abbc4a5521ab2e1cf5965a3827a8d577dc07d2e"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQxODY4OA==", "bodyText": "If this sleep is really necessary, better schedule a task in 1sec. for executing the code below.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487418688", "createdAt": "2020-09-12T15:09:20Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String sendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATIONPROCESS;\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.start();\n+                } catch (Exception e) {\n+                    logger.warn(\"Web socket start failed {}\", e.getMessage());\n+                    // throw new IOException(\"Web socket start failed\");\n+                }\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient,\n+                            uriyiodockwebsocketaddress, yioremoteDockwebSocketClientrequest);\n+                    yioremoteDockwebSocketClient.getLatch().await();\n+                    Thread.sleep(1000);\n+                    try {\n+                        if (yioremoteDockwebSocketClient.getbooleanauthenticationrequired()) {\n+                            yioremoteDockwebSocketClient.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                    localConfig.accesstoken);\n+                            Thread.sleep(1000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5abbc4a5521ab2e1cf5965a3827a8d577dc07d2e"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQxODkxNQ==", "bodyText": "As this is nullable, you need to do a null check before. You can store pollingJob to a local variable and do the null check on that.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487418915", "createdAt": "2020-09-12T15:11:26Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String sendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATIONPROCESS;\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.start();\n+                } catch (Exception e) {\n+                    logger.warn(\"Web socket start failed {}\", e.getMessage());\n+                    // throw new IOException(\"Web socket start failed\");\n+                }\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient,\n+                            uriyiodockwebsocketaddress, yioremoteDockwebSocketClientrequest);\n+                    yioremoteDockwebSocketClient.getLatch().await();\n+                    Thread.sleep(1000);\n+                    try {\n+                        if (yioremoteDockwebSocketClient.getbooleanauthenticationrequired()) {\n+                            yioremoteDockwebSocketClient.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                    localConfig.accesstoken);\n+                            Thread.sleep(1000);\n+                            if (yioremoteDockwebSocketClient.getbooleanauthenticationok()) {\n+                                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATED;\n+                                logger.debug(\"authentication to YIO dock ok\");\n+                                updateStatus(ThingStatus.ONLINE);\n+                                try {\n+                                    Runnable heartbeatpolling = new Runnable() {\n+                                        @Override\n+                                        public void run() {\n+                                            try {\n+                                                if (yioremotedockactualstatus\n+                                                        .equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATED)) {\n+                                                    yioremoteDockwebSocketClient\n+                                                            .sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                                                    Thread.sleep(1000);\n+\n+                                                    if (yioremoteDockwebSocketClient.getbooleanheartbeat()) {\n+                                                        logger.debug(\"heartbeat ok\");\n+                                                        triggerChannel(getChannelUuid(GROUP_OUTPUT, YIODOCKSTATUS));\n+                                                        updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                                                yioremoteDockwebSocketClient.getstringreceivedstatus());\n+                                                    } else {\n+                                                        yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTIONFAILED;\n+                                                        updateStatus(ThingStatus.OFFLINE,\n+                                                                ThingStatusDetail.CONFIGURATION_ERROR,\n+                                                                \"Connection lost no ping from YIO DOCK\");\n+                                                        updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                                                        pollingJob.cancel(true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5abbc4a5521ab2e1cf5965a3827a8d577dc07d2e"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQxODk5OQ==", "bodyText": "You should specify the concrete exception you want to catch, since catching Exception catches also all runtime exceptions.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487418999", "createdAt": "2020-09-12T15:12:19Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String sendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATIONPROCESS;\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.start();\n+                } catch (Exception e) {\n+                    logger.warn(\"Web socket start failed {}\", e.getMessage());\n+                    // throw new IOException(\"Web socket start failed\");\n+                }\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient,\n+                            uriyiodockwebsocketaddress, yioremoteDockwebSocketClientrequest);\n+                    yioremoteDockwebSocketClient.getLatch().await();\n+                    Thread.sleep(1000);\n+                    try {\n+                        if (yioremoteDockwebSocketClient.getbooleanauthenticationrequired()) {\n+                            yioremoteDockwebSocketClient.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                    localConfig.accesstoken);\n+                            Thread.sleep(1000);\n+                            if (yioremoteDockwebSocketClient.getbooleanauthenticationok()) {\n+                                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATED;\n+                                logger.debug(\"authentication to YIO dock ok\");\n+                                updateStatus(ThingStatus.ONLINE);\n+                                try {\n+                                    Runnable heartbeatpolling = new Runnable() {\n+                                        @Override\n+                                        public void run() {\n+                                            try {\n+                                                if (yioremotedockactualstatus\n+                                                        .equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATED)) {\n+                                                    yioremoteDockwebSocketClient\n+                                                            .sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                                                    Thread.sleep(1000);\n+\n+                                                    if (yioremoteDockwebSocketClient.getbooleanheartbeat()) {\n+                                                        logger.debug(\"heartbeat ok\");\n+                                                        triggerChannel(getChannelUuid(GROUP_OUTPUT, YIODOCKSTATUS));\n+                                                        updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                                                yioremoteDockwebSocketClient.getstringreceivedstatus());\n+                                                    } else {\n+                                                        yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTIONFAILED;\n+                                                        updateStatus(ThingStatus.OFFLINE,\n+                                                                ThingStatusDetail.CONFIGURATION_ERROR,\n+                                                                \"Connection lost no ping from YIO DOCK\");\n+                                                        updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                                                        pollingJob.cancel(true);\n+                                                    }\n+                                                } else {\n+                                                    yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTIONFAILED;\n+                                                    updateStatus(ThingStatus.OFFLINE,\n+                                                            ThingStatusDetail.CONFIGURATION_ERROR,\n+                                                            \"Connection lost no ping from YIO DOCK\");\n+                                                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                                                    pollingJob.cancel(true);\n+                                                }\n+                                            } catch (Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5abbc4a5521ab2e1cf5965a3827a8d577dc07d2e"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQxOTAwNg==", "bodyText": "What type of exception do you expect here? Can you specify the concrete type?", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487419006", "createdAt": "2020-09-12T15:12:27Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String sendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATIONPROCESS;\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.start();\n+                } catch (Exception e) {\n+                    logger.warn(\"Web socket start failed {}\", e.getMessage());\n+                    // throw new IOException(\"Web socket start failed\");\n+                }\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient,\n+                            uriyiodockwebsocketaddress, yioremoteDockwebSocketClientrequest);\n+                    yioremoteDockwebSocketClient.getLatch().await();\n+                    Thread.sleep(1000);\n+                    try {\n+                        if (yioremoteDockwebSocketClient.getbooleanauthenticationrequired()) {\n+                            yioremoteDockwebSocketClient.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                    localConfig.accesstoken);\n+                            Thread.sleep(1000);\n+                            if (yioremoteDockwebSocketClient.getbooleanauthenticationok()) {\n+                                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATED;\n+                                logger.debug(\"authentication to YIO dock ok\");\n+                                updateStatus(ThingStatus.ONLINE);\n+                                try {\n+                                    Runnable heartbeatpolling = new Runnable() {\n+                                        @Override\n+                                        public void run() {\n+                                            try {\n+                                                if (yioremotedockactualstatus\n+                                                        .equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATED)) {\n+                                                    yioremoteDockwebSocketClient\n+                                                            .sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                                                    Thread.sleep(1000);\n+\n+                                                    if (yioremoteDockwebSocketClient.getbooleanheartbeat()) {\n+                                                        logger.debug(\"heartbeat ok\");\n+                                                        triggerChannel(getChannelUuid(GROUP_OUTPUT, YIODOCKSTATUS));\n+                                                        updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                                                yioremoteDockwebSocketClient.getstringreceivedstatus());\n+                                                    } else {\n+                                                        yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTIONFAILED;\n+                                                        updateStatus(ThingStatus.OFFLINE,\n+                                                                ThingStatusDetail.CONFIGURATION_ERROR,\n+                                                                \"Connection lost no ping from YIO DOCK\");\n+                                                        updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                                                        pollingJob.cancel(true);\n+                                                    }\n+                                                } else {\n+                                                    yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTIONFAILED;\n+                                                    updateStatus(ThingStatus.OFFLINE,\n+                                                            ThingStatusDetail.CONFIGURATION_ERROR,\n+                                                            \"Connection lost no ping from YIO DOCK\");\n+                                                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                                                    pollingJob.cancel(true);\n+                                                }\n+                                            } catch (Exception e) {\n+                                                logger.warn(\"Error during initializing the WebSocket polling Thread {}\",\n+                                                        e.getMessage());\n+                                            }\n+                                        }\n+                                    };\n+\n+                                    pollingJob = scheduler.scheduleWithFixedDelay(heartbeatpolling, 0, 30,\n+                                            TimeUnit.SECONDS);\n+                                } catch (Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5abbc4a5521ab2e1cf5965a3827a8d577dc07d2e"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQxOTA2Nw==", "bodyText": "See above", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487419067", "createdAt": "2020-09-12T15:13:04Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String sendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATIONPROCESS;\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.start();\n+                } catch (Exception e) {\n+                    logger.warn(\"Web socket start failed {}\", e.getMessage());\n+                    // throw new IOException(\"Web socket start failed\");\n+                }\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient,\n+                            uriyiodockwebsocketaddress, yioremoteDockwebSocketClientrequest);\n+                    yioremoteDockwebSocketClient.getLatch().await();\n+                    Thread.sleep(1000);\n+                    try {\n+                        if (yioremoteDockwebSocketClient.getbooleanauthenticationrequired()) {\n+                            yioremoteDockwebSocketClient.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                    localConfig.accesstoken);\n+                            Thread.sleep(1000);\n+                            if (yioremoteDockwebSocketClient.getbooleanauthenticationok()) {\n+                                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATED;\n+                                logger.debug(\"authentication to YIO dock ok\");\n+                                updateStatus(ThingStatus.ONLINE);\n+                                try {\n+                                    Runnable heartbeatpolling = new Runnable() {\n+                                        @Override\n+                                        public void run() {\n+                                            try {\n+                                                if (yioremotedockactualstatus\n+                                                        .equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATED)) {\n+                                                    yioremoteDockwebSocketClient\n+                                                            .sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                                                    Thread.sleep(1000);\n+\n+                                                    if (yioremoteDockwebSocketClient.getbooleanheartbeat()) {\n+                                                        logger.debug(\"heartbeat ok\");\n+                                                        triggerChannel(getChannelUuid(GROUP_OUTPUT, YIODOCKSTATUS));\n+                                                        updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                                                yioremoteDockwebSocketClient.getstringreceivedstatus());\n+                                                    } else {\n+                                                        yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTIONFAILED;\n+                                                        updateStatus(ThingStatus.OFFLINE,\n+                                                                ThingStatusDetail.CONFIGURATION_ERROR,\n+                                                                \"Connection lost no ping from YIO DOCK\");\n+                                                        updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                                                        pollingJob.cancel(true);\n+                                                    }\n+                                                } else {\n+                                                    yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTIONFAILED;\n+                                                    updateStatus(ThingStatus.OFFLINE,\n+                                                            ThingStatusDetail.CONFIGURATION_ERROR,\n+                                                            \"Connection lost no ping from YIO DOCK\");\n+                                                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                                                    pollingJob.cancel(true);\n+                                                }\n+                                            } catch (Exception e) {\n+                                                logger.warn(\"Error during initializing the WebSocket polling Thread {}\",\n+                                                        e.getMessage());\n+                                            }\n+                                        }\n+                                    };\n+\n+                                    pollingJob = scheduler.scheduleWithFixedDelay(heartbeatpolling, 0, 30,\n+                                            TimeUnit.SECONDS);\n+                                } catch (Exception e) {\n+                                    updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                                }\n+                            } else {\n+                                logger.debug(\"authentication to YIO dock not ok\");\n+                                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATEDFAILED;\n+                                updateStatus(ThingStatus.OFFLINE);\n+                            }\n+                        } else {\n+                            logger.debug(\"authentication error YIO dock\");\n+                        }\n+                    } catch (IllegalArgumentException e) {\n+                        logger.warn(\"JSON convertion failure {}\", e.getMessage());\n+                    }\n+                } catch (Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5abbc4a5521ab2e1cf5965a3827a8d577dc07d2e"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQxOTEzNA==", "bodyText": "Instead of logging it, you could set the Thing state to OFFLINE.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487419134", "createdAt": "2020-09-12T15:14:03Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String sendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATIONPROCESS;\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.start();\n+                } catch (Exception e) {\n+                    logger.warn(\"Web socket start failed {}\", e.getMessage());\n+                    // throw new IOException(\"Web socket start failed\");\n+                }\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient,\n+                            uriyiodockwebsocketaddress, yioremoteDockwebSocketClientrequest);\n+                    yioremoteDockwebSocketClient.getLatch().await();\n+                    Thread.sleep(1000);\n+                    try {\n+                        if (yioremoteDockwebSocketClient.getbooleanauthenticationrequired()) {\n+                            yioremoteDockwebSocketClient.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                    localConfig.accesstoken);\n+                            Thread.sleep(1000);\n+                            if (yioremoteDockwebSocketClient.getbooleanauthenticationok()) {\n+                                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATED;\n+                                logger.debug(\"authentication to YIO dock ok\");\n+                                updateStatus(ThingStatus.ONLINE);\n+                                try {\n+                                    Runnable heartbeatpolling = new Runnable() {\n+                                        @Override\n+                                        public void run() {\n+                                            try {\n+                                                if (yioremotedockactualstatus\n+                                                        .equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATED)) {\n+                                                    yioremoteDockwebSocketClient\n+                                                            .sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                                                    Thread.sleep(1000);\n+\n+                                                    if (yioremoteDockwebSocketClient.getbooleanheartbeat()) {\n+                                                        logger.debug(\"heartbeat ok\");\n+                                                        triggerChannel(getChannelUuid(GROUP_OUTPUT, YIODOCKSTATUS));\n+                                                        updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                                                yioremoteDockwebSocketClient.getstringreceivedstatus());\n+                                                    } else {\n+                                                        yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTIONFAILED;\n+                                                        updateStatus(ThingStatus.OFFLINE,\n+                                                                ThingStatusDetail.CONFIGURATION_ERROR,\n+                                                                \"Connection lost no ping from YIO DOCK\");\n+                                                        updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                                                        pollingJob.cancel(true);\n+                                                    }\n+                                                } else {\n+                                                    yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTIONFAILED;\n+                                                    updateStatus(ThingStatus.OFFLINE,\n+                                                            ThingStatusDetail.CONFIGURATION_ERROR,\n+                                                            \"Connection lost no ping from YIO DOCK\");\n+                                                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                                                    pollingJob.cancel(true);\n+                                                }\n+                                            } catch (Exception e) {\n+                                                logger.warn(\"Error during initializing the WebSocket polling Thread {}\",\n+                                                        e.getMessage());\n+                                            }\n+                                        }\n+                                    };\n+\n+                                    pollingJob = scheduler.scheduleWithFixedDelay(heartbeatpolling, 0, 30,\n+                                            TimeUnit.SECONDS);\n+                                } catch (Exception e) {\n+                                    updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                                }\n+                            } else {\n+                                logger.debug(\"authentication to YIO dock not ok\");\n+                                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATEDFAILED;\n+                                updateStatus(ThingStatus.OFFLINE);\n+                            }\n+                        } else {\n+                            logger.debug(\"authentication error YIO dock\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5abbc4a5521ab2e1cf5965a3827a8d577dc07d2e"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQxOTE3OA==", "bodyText": "As this is fatal, better set the Thing to OFFLINE with an appropriate detail message.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487419178", "createdAt": "2020-09-12T15:14:35Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String sendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATIONPROCESS;\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.start();\n+                } catch (Exception e) {\n+                    logger.warn(\"Web socket start failed {}\", e.getMessage());\n+                    // throw new IOException(\"Web socket start failed\");\n+                }\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient,\n+                            uriyiodockwebsocketaddress, yioremoteDockwebSocketClientrequest);\n+                    yioremoteDockwebSocketClient.getLatch().await();\n+                    Thread.sleep(1000);\n+                    try {\n+                        if (yioremoteDockwebSocketClient.getbooleanauthenticationrequired()) {\n+                            yioremoteDockwebSocketClient.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                    localConfig.accesstoken);\n+                            Thread.sleep(1000);\n+                            if (yioremoteDockwebSocketClient.getbooleanauthenticationok()) {\n+                                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATED;\n+                                logger.debug(\"authentication to YIO dock ok\");\n+                                updateStatus(ThingStatus.ONLINE);\n+                                try {\n+                                    Runnable heartbeatpolling = new Runnable() {\n+                                        @Override\n+                                        public void run() {\n+                                            try {\n+                                                if (yioremotedockactualstatus\n+                                                        .equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATED)) {\n+                                                    yioremoteDockwebSocketClient\n+                                                            .sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                                                    Thread.sleep(1000);\n+\n+                                                    if (yioremoteDockwebSocketClient.getbooleanheartbeat()) {\n+                                                        logger.debug(\"heartbeat ok\");\n+                                                        triggerChannel(getChannelUuid(GROUP_OUTPUT, YIODOCKSTATUS));\n+                                                        updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                                                yioremoteDockwebSocketClient.getstringreceivedstatus());\n+                                                    } else {\n+                                                        yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTIONFAILED;\n+                                                        updateStatus(ThingStatus.OFFLINE,\n+                                                                ThingStatusDetail.CONFIGURATION_ERROR,\n+                                                                \"Connection lost no ping from YIO DOCK\");\n+                                                        updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                                                        pollingJob.cancel(true);\n+                                                    }\n+                                                } else {\n+                                                    yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTIONFAILED;\n+                                                    updateStatus(ThingStatus.OFFLINE,\n+                                                            ThingStatusDetail.CONFIGURATION_ERROR,\n+                                                            \"Connection lost no ping from YIO DOCK\");\n+                                                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                                                    pollingJob.cancel(true);\n+                                                }\n+                                            } catch (Exception e) {\n+                                                logger.warn(\"Error during initializing the WebSocket polling Thread {}\",\n+                                                        e.getMessage());\n+                                            }\n+                                        }\n+                                    };\n+\n+                                    pollingJob = scheduler.scheduleWithFixedDelay(heartbeatpolling, 0, 30,\n+                                            TimeUnit.SECONDS);\n+                                } catch (Exception e) {\n+                                    updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                                }\n+                            } else {\n+                                logger.debug(\"authentication to YIO dock not ok\");\n+                                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATEDFAILED;\n+                                updateStatus(ThingStatus.OFFLINE);\n+                            }\n+                        } else {\n+                            logger.debug(\"authentication error YIO dock\");\n+                        }\n+                    } catch (IllegalArgumentException e) {\n+                        logger.warn(\"JSON convertion failure {}\", e.getMessage());\n+                    }\n+                } catch (Exception e) {\n+                    logger.warn(\"Web socket connect failed {}\", e.getMessage());\n+                }\n+            } catch (URISyntaxException e) {\n+                logger.debug(\"Initialize web socket failed {}\", e.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5abbc4a5521ab2e1cf5965a3827a8d577dc07d2e"}, "originalPosition": 154}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQxOTI2OQ==", "bodyText": "Instead of logging this, you could add the text as detail message to updateStatus().", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487419269", "createdAt": "2020-09-12T15:15:16Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String sendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATIONPROCESS;\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.start();\n+                } catch (Exception e) {\n+                    logger.warn(\"Web socket start failed {}\", e.getMessage());\n+                    // throw new IOException(\"Web socket start failed\");\n+                }\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient,\n+                            uriyiodockwebsocketaddress, yioremoteDockwebSocketClientrequest);\n+                    yioremoteDockwebSocketClient.getLatch().await();\n+                    Thread.sleep(1000);\n+                    try {\n+                        if (yioremoteDockwebSocketClient.getbooleanauthenticationrequired()) {\n+                            yioremoteDockwebSocketClient.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                    localConfig.accesstoken);\n+                            Thread.sleep(1000);\n+                            if (yioremoteDockwebSocketClient.getbooleanauthenticationok()) {\n+                                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATED;\n+                                logger.debug(\"authentication to YIO dock ok\");\n+                                updateStatus(ThingStatus.ONLINE);\n+                                try {\n+                                    Runnable heartbeatpolling = new Runnable() {\n+                                        @Override\n+                                        public void run() {\n+                                            try {\n+                                                if (yioremotedockactualstatus\n+                                                        .equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATED)) {\n+                                                    yioremoteDockwebSocketClient\n+                                                            .sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                                                    Thread.sleep(1000);\n+\n+                                                    if (yioremoteDockwebSocketClient.getbooleanheartbeat()) {\n+                                                        logger.debug(\"heartbeat ok\");\n+                                                        triggerChannel(getChannelUuid(GROUP_OUTPUT, YIODOCKSTATUS));\n+                                                        updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                                                yioremoteDockwebSocketClient.getstringreceivedstatus());\n+                                                    } else {\n+                                                        yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTIONFAILED;\n+                                                        updateStatus(ThingStatus.OFFLINE,\n+                                                                ThingStatusDetail.CONFIGURATION_ERROR,\n+                                                                \"Connection lost no ping from YIO DOCK\");\n+                                                        updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                                                        pollingJob.cancel(true);\n+                                                    }\n+                                                } else {\n+                                                    yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTIONFAILED;\n+                                                    updateStatus(ThingStatus.OFFLINE,\n+                                                            ThingStatusDetail.CONFIGURATION_ERROR,\n+                                                            \"Connection lost no ping from YIO DOCK\");\n+                                                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                                                    pollingJob.cancel(true);\n+                                                }\n+                                            } catch (Exception e) {\n+                                                logger.warn(\"Error during initializing the WebSocket polling Thread {}\",\n+                                                        e.getMessage());\n+                                            }\n+                                        }\n+                                    };\n+\n+                                    pollingJob = scheduler.scheduleWithFixedDelay(heartbeatpolling, 0, 30,\n+                                            TimeUnit.SECONDS);\n+                                } catch (Exception e) {\n+                                    updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                                }\n+                            } else {\n+                                logger.debug(\"authentication to YIO dock not ok\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5abbc4a5521ab2e1cf5965a3827a8d577dc07d2e"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQxOTMxMA==", "bodyText": "I don't see a null check.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487419310", "createdAt": "2020-09-12T15:15:42Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,\n+                        YIOremote_DockwebSocketClientrequest);\n+                logger.debug(\"Connected websocket client\");\n+\n+                logger.debug(\"Check for authentication requested by YIO Dock\");\n+                YIOremoteDockwebSocket_ClientSocket.getLatch().await();\n+                Thread.sleep(1000);\n+\n+                try {\n+                    if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_required()) {\n+                        logger.debug(\"send authentication to YIO dock\");\n+                        YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                config.yiodockaccesstoken);\n+                        Thread.sleep(1000);\n+\n+                        if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_ok()) {\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED;\n+\n+                        } else {\n+                            logger.debug(\"authentication to YIO dock not ok\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED_FAILED;\n+                        }\n+                    } else {\n+                        logger.debug(\"authentication error YIO dock\");\n+                    }\n+\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"JSON convertion failure {}\", e.toString());\n+                }\n+\n+            } catch (\n+\n+            Exception e) {\n+                logger.warn(\"Web socket connect failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+        } catch (URISyntaxException e) {\n+            logger.debug(\"Initialize web socket failed {}\", e.toString());\n+        }\n+\n+        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+            updateStatus(ThingStatus.ONLINE);\n+            Runnable heartbeatpolling = new Runnable() {\n+                @Override\n+                public void run() {\n+                    try {\n+                        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                            YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                            Thread.sleep(1000);\n+\n+                            if (YIOremoteDockwebSocket_ClientSocket.get_boolean_heartbeat()) {\n+                                logger.debug(\"heartbeat ok\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                        YIOremoteDockwebSocket_ClientSocket.get_string_receivedstatus());\n+                            } else {\n+                                logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                                YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                        \"Connection lost no ping from YIO DOCK\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                                pollingJob.cancel(true);\n+                            }\n+                        } else {\n+                            logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                    \"Connection lost no ping from YIO DOCK\");\n+                            updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                            pollingJob.cancel(true);\n+                        }\n+                    } catch (InterruptedException e) {\n+                        logger.warn(\"Error during initializing the WebSocket polling Thread {}\", e.toString());\n+                    }\n+                }\n+            };\n+            try {\n+                pollingJob = scheduler.scheduleWithFixedDelay(heartbeatpolling, 0, 30, TimeUnit.SECONDS);\n+            } catch (Exception e) {\n+                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                logger.warn(\"Error during starting the WebSocket polling Thread {}\", e.toString());\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE);\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+        pollingJob.cancel(true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3OTMzNA=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 180}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQxOTM3Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void sendircode(@Nullable String string_ircode) {\n          \n          \n            \n                public void sendircode(@Nullable String stringIRCode) {", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487419372", "createdAt": "2020-09-12T15:16:20Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String sendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATIONPROCESS;\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.start();\n+                } catch (Exception e) {\n+                    logger.warn(\"Web socket start failed {}\", e.getMessage());\n+                    // throw new IOException(\"Web socket start failed\");\n+                }\n+                try {\n+                    yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient,\n+                            uriyiodockwebsocketaddress, yioremoteDockwebSocketClientrequest);\n+                    yioremoteDockwebSocketClient.getLatch().await();\n+                    Thread.sleep(1000);\n+                    try {\n+                        if (yioremoteDockwebSocketClient.getbooleanauthenticationrequired()) {\n+                            yioremoteDockwebSocketClient.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                    localConfig.accesstoken);\n+                            Thread.sleep(1000);\n+                            if (yioremoteDockwebSocketClient.getbooleanauthenticationok()) {\n+                                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATED;\n+                                logger.debug(\"authentication to YIO dock ok\");\n+                                updateStatus(ThingStatus.ONLINE);\n+                                try {\n+                                    Runnable heartbeatpolling = new Runnable() {\n+                                        @Override\n+                                        public void run() {\n+                                            try {\n+                                                if (yioremotedockactualstatus\n+                                                        .equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATED)) {\n+                                                    yioremoteDockwebSocketClient\n+                                                            .sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                                                    Thread.sleep(1000);\n+\n+                                                    if (yioremoteDockwebSocketClient.getbooleanheartbeat()) {\n+                                                        logger.debug(\"heartbeat ok\");\n+                                                        triggerChannel(getChannelUuid(GROUP_OUTPUT, YIODOCKSTATUS));\n+                                                        updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                                                yioremoteDockwebSocketClient.getstringreceivedstatus());\n+                                                    } else {\n+                                                        yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTIONFAILED;\n+                                                        updateStatus(ThingStatus.OFFLINE,\n+                                                                ThingStatusDetail.CONFIGURATION_ERROR,\n+                                                                \"Connection lost no ping from YIO DOCK\");\n+                                                        updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                                                        pollingJob.cancel(true);\n+                                                    }\n+                                                } else {\n+                                                    yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTIONFAILED;\n+                                                    updateStatus(ThingStatus.OFFLINE,\n+                                                            ThingStatusDetail.CONFIGURATION_ERROR,\n+                                                            \"Connection lost no ping from YIO DOCK\");\n+                                                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                                                    pollingJob.cancel(true);\n+                                                }\n+                                            } catch (Exception e) {\n+                                                logger.warn(\"Error during initializing the WebSocket polling Thread {}\",\n+                                                        e.getMessage());\n+                                            }\n+                                        }\n+                                    };\n+\n+                                    pollingJob = scheduler.scheduleWithFixedDelay(heartbeatpolling, 0, 30,\n+                                            TimeUnit.SECONDS);\n+                                } catch (Exception e) {\n+                                    updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                                }\n+                            } else {\n+                                logger.debug(\"authentication to YIO dock not ok\");\n+                                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATEDFAILED;\n+                                updateStatus(ThingStatus.OFFLINE);\n+                            }\n+                        } else {\n+                            logger.debug(\"authentication error YIO dock\");\n+                        }\n+                    } catch (IllegalArgumentException e) {\n+                        logger.warn(\"JSON convertion failure {}\", e.getMessage());\n+                    }\n+                } catch (Exception e) {\n+                    logger.warn(\"Web socket connect failed {}\", e.getMessage());\n+                }\n+            } catch (URISyntaxException e) {\n+                logger.debug(\"Initialize web socket failed {}\", e.getMessage());\n+            }\n+        });\n+    }\n+\n+    protected void updateState(String group, String channelId, State value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        if (isLinked(id)) {\n+            updateState(id, value);\n+        }\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(YIOremoteDockActions.class);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        pollingJob.cancel(true);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (YIODOCKRECEIVERSWITCH.equals(channelUID.getIdWithoutGroup())) {\n+            if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATED)) {\n+                if (command.toString().equals(\"ON\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    yioremoteDockwebSocketClient.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVERON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    yioremoteDockwebSocketClient.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVEROFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void sendircode(@Nullable String string_ircode) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5abbc4a5521ab2e1cf5965a3827a8d577dc07d2e"}, "originalPosition": 193}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQxOTQ1Mg==", "bodyText": "I still see the if.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r487419452", "createdAt": "2020-09-12T15:17:27Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,\n+                        YIOremote_DockwebSocketClientrequest);\n+                logger.debug(\"Connected websocket client\");\n+\n+                logger.debug(\"Check for authentication requested by YIO Dock\");\n+                YIOremoteDockwebSocket_ClientSocket.getLatch().await();\n+                Thread.sleep(1000);\n+\n+                try {\n+                    if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_required()) {\n+                        logger.debug(\"send authentication to YIO dock\");\n+                        YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                config.yiodockaccesstoken);\n+                        Thread.sleep(1000);\n+\n+                        if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_ok()) {\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED;\n+\n+                        } else {\n+                            logger.debug(\"authentication to YIO dock not ok\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED_FAILED;\n+                        }\n+                    } else {\n+                        logger.debug(\"authentication error YIO dock\");\n+                    }\n+\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"JSON convertion failure {}\", e.toString());\n+                }\n+\n+            } catch (\n+\n+            Exception e) {\n+                logger.warn(\"Web socket connect failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+        } catch (URISyntaxException e) {\n+            logger.debug(\"Initialize web socket failed {}\", e.toString());\n+        }\n+\n+        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+            updateStatus(ThingStatus.ONLINE);\n+            Runnable heartbeatpolling = new Runnable() {\n+                @Override\n+                public void run() {\n+                    try {\n+                        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                            YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                            Thread.sleep(1000);\n+\n+                            if (YIOremoteDockwebSocket_ClientSocket.get_boolean_heartbeat()) {\n+                                logger.debug(\"heartbeat ok\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                        YIOremoteDockwebSocket_ClientSocket.get_string_receivedstatus());\n+                            } else {\n+                                logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                                YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                        \"Connection lost no ping from YIO DOCK\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                                pollingJob.cancel(true);\n+                            }\n+                        } else {\n+                            logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                    \"Connection lost no ping from YIO DOCK\");\n+                            updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                            pollingJob.cancel(true);\n+                        }\n+                    } catch (InterruptedException e) {\n+                        logger.warn(\"Error during initializing the WebSocket polling Thread {}\", e.toString());\n+                    }\n+                }\n+            };\n+            try {\n+                pollingJob = scheduler.scheduleWithFixedDelay(heartbeatpolling, 0, 30, TimeUnit.SECONDS);\n+            } catch (Exception e) {\n+                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                logger.warn(\"Error during starting the WebSocket polling Thread {}\", e.toString());\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE);\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+        pollingJob.cancel(true);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+\n+        if (YIODOCKRECEIVERSWITCH.equals(channelUID.getIdWithoutGroup())) {\n+            if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                if (command instanceof RefreshType) {\n+                    // TODO: handle data refresh\n+\n+                }\n+\n+                if (command.toString().equals(\"ON\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVERON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVEROFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+\n+            } else {\n+                logger.warn(\"YIOremoteDockHandler not authenticated\");\n+            }\n+\n+        } else if (YIODOCKSENDIRCODE.equals(channelUID.getIdWithoutGroup())) {\n+            if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                if (command instanceof RefreshType) {\n+                    // TODO: handle data refresh\n+                    // logger.warn(\"YIOremoteDockHandler not authenticated\");\n+                }\n+                logger.debug(\"YIODOCKSENDIRCODE procedure: {}\", command.toString());\n+                send_ircode = command.toString();\n+                if (send_ircode.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.IRSEND, send_ircode);\n+                } else {\n+                    logger.warn(\"Wrong IR code Format {}\", send_ircode);\n+                    send_ircode = \"\";\n+                }\n+            } else {\n+                logger.warn(\"YIOremoteDockHandler not authenticated\");\n+            }\n+        }\n+    }\n+\n+    protected void updateChannelString(String group, String channelId, String value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+\n+        if (isLinked(id)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4MTEzMQ=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 230}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg5MzQ0OTE3", "url": "https://github.com/openhab/openhab-addons/pull/8394#pullrequestreview-489344917", "createdAt": "2020-09-16T07:26:25Z", "commit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 37, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwNzoyNjoyNVrOHSjqaQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xNlQwODoxODowNVrOHSlhJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyMDcxMw==", "bodyText": "CamelCase and you don't need to repeat the name of the binding in the name necessarily as it is unique in the package.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static enum YIOREMOTEDOCKHANDLESTATUS {\n          \n          \n            \n                public static enum DockHandleStatus {", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489220713", "createdAt": "2020-09-16T07:26:25Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteBindingConstants.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+\n+/**\n+ * The {@link YIOremoteBindingConstants} class defines common constants, which are\n+ * used across the whole binding.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteBindingConstants {\n+\n+    public static final String BINDING_ID = \"yioremote\";\n+\n+    // List of all used global variables\n+    public static enum YIOREMOTEDOCKHANDLESTATUS {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyMDc2Nw==", "bodyText": "See above", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489220767", "createdAt": "2020-09-16T07:26:33Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteBindingConstants.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+\n+/**\n+ * The {@link YIOremoteBindingConstants} class defines common constants, which are\n+ * used across the whole binding.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteBindingConstants {\n+\n+    public static final String BINDING_ID = \"yioremote\";\n+\n+    // List of all used global variables\n+    public static enum YIOREMOTEDOCKHANDLESTATUS {\n+        UNINITIALIZED_STATE,\n+        AUTHENTICATION_PROCESS,\n+        AUTHENTICATION_FAILED,\n+        AUTHENTICATION_COMPLETE,\n+        CONNECTION_FAILED,\n+        CONNECTION_ESTABLISHED;\n+    }\n+\n+    public static enum YIOREMOTEMESSAGETYPE {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyMTQxNw==", "bodyText": "These should be SNAKE_CASE. The prefix could be dropped, too, as it is redundant. Suggestion for a more meaningful name. Same for below.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static final String YIODOCKRECEIVERSWITCH = \"receiverswitch\";\n          \n          \n            \n                public static final String RECEIVER_SWITCH_CHANNEL = \"receiverswitch\";", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489221417", "createdAt": "2020-09-16T07:27:42Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteBindingConstants.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+\n+/**\n+ * The {@link YIOremoteBindingConstants} class defines common constants, which are\n+ * used across the whole binding.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteBindingConstants {\n+\n+    public static final String BINDING_ID = \"yioremote\";\n+\n+    // List of all used global variables\n+    public static enum YIOREMOTEDOCKHANDLESTATUS {\n+        UNINITIALIZED_STATE,\n+        AUTHENTICATION_PROCESS,\n+        AUTHENTICATION_FAILED,\n+        AUTHENTICATION_COMPLETE,\n+        CONNECTION_FAILED,\n+        CONNECTION_ESTABLISHED;\n+    }\n+\n+    public static enum YIOREMOTEMESSAGETYPE {\n+        IRSEND,\n+        AUTHENTICATE,\n+        HEARTBEAT,\n+        IRRECEIVERON,\n+        IRRECEIVEROFF;\n+    }\n+\n+    // List of all Thing Type UIDs\n+    public static final ThingTypeUID THING_TYPE_YIOREMOTEDOCK = new ThingTypeUID(BINDING_ID, \"yioremotedock\");\n+\n+    // List of all Channel Groups Group Channel ids\n+    public static final String GROUP_INPUT = \"input\";\n+    public static final String GROUP_OUTPUT = \"output\";\n+\n+    // List of all Channel ids\n+    public static final String YIODOCKRECEIVERSWITCH = \"receiverswitch\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyMzUxNw==", "bodyText": "This method has no body. You might want to call sendircode().", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489223517", "createdAt": "2020-09-16T07:31:16Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockActions.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.binding.ThingActions;\n+import org.eclipse.smarthome.core.thing.binding.ThingActionsScope;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+\n+/**\n+ * The {@link YIOremoteDockActions} is responsible for handling the action commands\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@ThingActionsScope(name = \"yioremote\")\n+@NonNullByDefault\n+public class YIOremoteDockActions implements ThingActions {\n+    private @Nullable static YIOremoteDockHandler yioremotedockhandler;\n+\n+    @Override\n+    public void setThingHandler(@Nullable ThingHandler yiremotedockhandler) {\n+        yioremotedockhandler = (YIOremoteDockHandler) yiremotedockhandler;\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return yioremotedockhandler;\n+    }\n+\n+    @RuleAction(label = \"@text/actionLabel\", description = \"@text/actionDesc\")\n+    public void sendircode(\n+            @ActionInput(name = \"ircode\", label = \"@text/actionInputTopicLabel\", description = \"@text/actionInputTopicDesc\") @Nullable String ircode) {\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyMzY1Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private @Nullable static YIOremoteDockHandler yioremotedockhandler;\n          \n          \n            \n                private @Nullable static YIOremoteDockHandler dockHandler;", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489223653", "createdAt": "2020-09-16T07:31:32Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockActions.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.binding.ThingActions;\n+import org.eclipse.smarthome.core.thing.binding.ThingActionsScope;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+\n+/**\n+ * The {@link YIOremoteDockActions} is responsible for handling the action commands\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@ThingActionsScope(name = \"yioremote\")\n+@NonNullByDefault\n+public class YIOremoteDockActions implements ThingActions {\n+    private @Nullable static YIOremoteDockHandler yioremotedockhandler;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyMzk3NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n          \n          \n            \n                private WebSocketClient webSocketClient = new WebSocketClient();", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489223975", "createdAt": "2020-09-16T07:32:03Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private YIOremoteDockHandler yioremotedockhandler = this;\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyNDcxNg==", "bodyText": "Please don't prefix the field name with the type and drop the binding's name as these are both redundant. Please also use camelCase. Same for below.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private @Nullable URI uriyiodockwebsocketaddress;\n          \n          \n            \n                private @Nullable URI websocketAddress;", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489224716", "createdAt": "2020-09-16T07:33:27Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private YIOremoteDockHandler yioremotedockhandler = this;\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyNTMxNw==", "bodyText": "You could include the exception's message:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n          \n          \n            \n                                    \"Initialize web socket failed\");\n          \n          \n            \n                            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n          \n          \n            \n                                    \"Initialize web socket failed: \"+e.getMessage());", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489225317", "createdAt": "2020-09-16T07:34:33Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private YIOremoteDockHandler yioremotedockhandler = this;\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String stringreceivedmessage = \"\";\n+    private JsonObject jsonobjectrecievedJsonObject = new JsonObject();\n+    private boolean booleanheartbeat = false;\n+    private boolean booleanauthenticationok = false;\n+    private String stringreceivedstatus = \"\";\n+    private String stringlastsendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+        yioremotedockhandler = this;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyNjE2OA==", "bodyText": "Primitive types should be used where possible (boolean instead of Boolean).\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            public void onConnect(Boolean booleanconnectedflag) {\n          \n          \n            \n                            public void onConnect(boolean connected) {", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489226168", "createdAt": "2020-09-16T07:36:06Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private YIOremoteDockHandler yioremotedockhandler = this;\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String stringreceivedmessage = \"\";\n+    private JsonObject jsonobjectrecievedJsonObject = new JsonObject();\n+    private boolean booleanheartbeat = false;\n+    private boolean booleanauthenticationok = false;\n+    private String stringreceivedstatus = \"\";\n+    private String stringlastsendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+        yioremotedockhandler = this;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed\");\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(Boolean booleanconnectedflag) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 94}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIzMDg4NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private boolean decodereceivedMessage(JsonObject JsonObject_recievedJsonObject) {\n          \n          \n            \n                private boolean decodeReceivedMessage(JsonObject message) {", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489230884", "createdAt": "2020-09-16T07:44:17Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private YIOremoteDockHandler yioremotedockhandler = this;\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String stringreceivedmessage = \"\";\n+    private JsonObject jsonobjectrecievedJsonObject = new JsonObject();\n+    private boolean booleanheartbeat = false;\n+    private boolean booleanauthenticationok = false;\n+    private String stringreceivedstatus = \"\";\n+    private String stringlastsendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+        yioremotedockhandler = this;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed\");\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(Boolean booleanconnectedflag) {\n+                    if (booleanconnectedflag) {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_ESTABLISHED;\n+                        yioremotedockhandler.authenticate(booleanconnectedflag);\n+                    } else {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    yioremotedockhandler.stringreceivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    jsonobjectrecievedJsonObject = convertStringtoJsonObject(\n+                            yioremotedockhandler.stringreceivedmessage);\n+                    if (jsonobjectrecievedJsonObject.size() > 0) {\n+                        if (yioremotedockhandler.decodereceivedMessage(jsonobjectrecievedJsonObject)) {\n+                            yioremotedockhandler.triggerChannel(getChannelUuid(GROUP_OUTPUT, YIODOCKSTATUS));\n+                            yioremotedockhandler.updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                    yioremotedockhandler.stringreceivedstatus);\n+                            logger.debug(\"Message {} decoded\", yioremotedockhandler.stringreceivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\",\n+                                    yioremotedockhandler.stringreceivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                yioremoteDockHandlerwebSocketClient.start();\n+\n+                yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient, uriyiodockwebsocketaddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject JsonObject_recievedJsonObject) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIzMTE4OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    boolean booleanresult = false;\n          \n          \n            \n                    boolean success = false;", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489231188", "createdAt": "2020-09-16T07:44:46Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private YIOremoteDockHandler yioremotedockhandler = this;\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String stringreceivedmessage = \"\";\n+    private JsonObject jsonobjectrecievedJsonObject = new JsonObject();\n+    private boolean booleanheartbeat = false;\n+    private boolean booleanauthenticationok = false;\n+    private String stringreceivedstatus = \"\";\n+    private String stringlastsendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+        yioremotedockhandler = this;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed\");\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(Boolean booleanconnectedflag) {\n+                    if (booleanconnectedflag) {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_ESTABLISHED;\n+                        yioremotedockhandler.authenticate(booleanconnectedflag);\n+                    } else {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    yioremotedockhandler.stringreceivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    jsonobjectrecievedJsonObject = convertStringtoJsonObject(\n+                            yioremotedockhandler.stringreceivedmessage);\n+                    if (jsonobjectrecievedJsonObject.size() > 0) {\n+                        if (yioremotedockhandler.decodereceivedMessage(jsonobjectrecievedJsonObject)) {\n+                            yioremotedockhandler.triggerChannel(getChannelUuid(GROUP_OUTPUT, YIODOCKSTATUS));\n+                            yioremotedockhandler.updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                    yioremotedockhandler.stringreceivedstatus);\n+                            logger.debug(\"Message {} decoded\", yioremotedockhandler.stringreceivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\",\n+                                    yioremotedockhandler.stringreceivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                yioremoteDockHandlerwebSocketClient.start();\n+\n+                yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient, uriyiodockwebsocketaddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject JsonObject_recievedJsonObject) {\n+        boolean booleanresult = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIzMTc5MQ==", "bodyText": "What's the purpose of this assignment?", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489231791", "createdAt": "2020-09-16T07:45:47Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private YIOremoteDockHandler yioremotedockhandler = this;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIzMjAzMQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            yioremotedockhandler.booleanheartbeat = true;\n          \n          \n            \n                            booleanheartbeat = true;", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489232031", "createdAt": "2020-09-16T07:46:13Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private YIOremoteDockHandler yioremotedockhandler = this;\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String stringreceivedmessage = \"\";\n+    private JsonObject jsonobjectrecievedJsonObject = new JsonObject();\n+    private boolean booleanheartbeat = false;\n+    private boolean booleanauthenticationok = false;\n+    private String stringreceivedstatus = \"\";\n+    private String stringlastsendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+        yioremotedockhandler = this;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed\");\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(Boolean booleanconnectedflag) {\n+                    if (booleanconnectedflag) {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_ESTABLISHED;\n+                        yioremotedockhandler.authenticate(booleanconnectedflag);\n+                    } else {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    yioremotedockhandler.stringreceivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    jsonobjectrecievedJsonObject = convertStringtoJsonObject(\n+                            yioremotedockhandler.stringreceivedmessage);\n+                    if (jsonobjectrecievedJsonObject.size() > 0) {\n+                        if (yioremotedockhandler.decodereceivedMessage(jsonobjectrecievedJsonObject)) {\n+                            yioremotedockhandler.triggerChannel(getChannelUuid(GROUP_OUTPUT, YIODOCKSTATUS));\n+                            yioremotedockhandler.updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                    yioremotedockhandler.stringreceivedstatus);\n+                            logger.debug(\"Message {} decoded\", yioremotedockhandler.stringreceivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\",\n+                                    yioremotedockhandler.stringreceivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                yioremoteDockHandlerwebSocketClient.start();\n+\n+                yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient, uriyiodockwebsocketaddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject JsonObject_recievedJsonObject) {\n+        boolean booleanresult = false;\n+\n+        if (JsonObject_recievedJsonObject.has(\"type\")) {\n+            if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                yioremotedockhandler.booleanheartbeat = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 153}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIzMjM3MQ==", "bodyText": "See above.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489232371", "createdAt": "2020-09-16T07:46:47Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private YIOremoteDockHandler yioremotedockhandler = this;\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String stringreceivedmessage = \"\";\n+    private JsonObject jsonobjectrecievedJsonObject = new JsonObject();\n+    private boolean booleanheartbeat = false;\n+    private boolean booleanauthenticationok = false;\n+    private String stringreceivedstatus = \"\";\n+    private String stringlastsendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+        yioremotedockhandler = this;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIzMjkwNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    } else\n          \n          \n            \n            \n          \n          \n            \n                    {\n          \n          \n            \n                    } else {", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489232905", "createdAt": "2020-09-16T07:47:44Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private YIOremoteDockHandler yioremotedockhandler = this;\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String stringreceivedmessage = \"\";\n+    private JsonObject jsonobjectrecievedJsonObject = new JsonObject();\n+    private boolean booleanheartbeat = false;\n+    private boolean booleanauthenticationok = false;\n+    private String stringreceivedstatus = \"\";\n+    private String stringlastsendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+        yioremotedockhandler = this;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed\");\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(Boolean booleanconnectedflag) {\n+                    if (booleanconnectedflag) {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_ESTABLISHED;\n+                        yioremotedockhandler.authenticate(booleanconnectedflag);\n+                    } else {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    yioremotedockhandler.stringreceivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    jsonobjectrecievedJsonObject = convertStringtoJsonObject(\n+                            yioremotedockhandler.stringreceivedmessage);\n+                    if (jsonobjectrecievedJsonObject.size() > 0) {\n+                        if (yioremotedockhandler.decodereceivedMessage(jsonobjectrecievedJsonObject)) {\n+                            yioremotedockhandler.triggerChannel(getChannelUuid(GROUP_OUTPUT, YIODOCKSTATUS));\n+                            yioremotedockhandler.updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                    yioremotedockhandler.stringreceivedstatus);\n+                            logger.debug(\"Message {} decoded\", yioremotedockhandler.stringreceivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\",\n+                                    yioremotedockhandler.stringreceivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                yioremoteDockHandlerwebSocketClient.start();\n+\n+                yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient, uriyiodockwebsocketaddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject JsonObject_recievedJsonObject) {\n+        boolean booleanresult = false;\n+\n+        if (JsonObject_recievedJsonObject.has(\"type\")) {\n+            if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+                yioremotedockhandler.stringreceivedstatus = \"Authentication required\";\n+            } else if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                yioremotedockhandler.booleanauthenticationok = true;\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+                yioremotedockhandler.stringreceivedstatus = \"Authentication ok\";\n+            } else if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\")\n+                    && JsonObject_recievedJsonObject.has(\"message\"))\n+\n+            {\n+                if (JsonObject_recievedJsonObject.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (JsonObject_recievedJsonObject.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        yioremotedockhandler.stringreceivedstatus = \"Send IR Code successfully\";\n+                        yioremotedockhandler.booleanheartbeat = true;\n+                        booleanresult = true;\n+                    } else {\n+                        if (stringlastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            stringreceivedstatus = \"Send IR Code failure\";\n+                        }\n+                        yioremotedockhandler.booleanheartbeat = true;\n+                        booleanresult = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", stringreceivedmessage);\n+                    yioremotedockhandler.booleanheartbeat = false;\n+                    booleanresult = false;\n+                }\n+            } else if (JsonObject_recievedJsonObject.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                yioremotedockhandler.stringreceivedstatus = JsonObject_recievedJsonObject.get(\"code\").toString()\n+                        .replace(\"\\\"\", \"\");\n+                if (stringreceivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    yioremotedockhandler.stringreceivedstatus = JsonObject_recievedJsonObject.get(\"code\").toString()\n+                            .replace(\"\\\"\", \"\");\n+                } else {\n+                    yioremotedockhandler.stringreceivedstatus = \"\";\n+                }\n+                logger.debug(\"ir_receive message {}\", stringreceivedstatus);\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+            } else {\n+                logger.warn(\"No known message {}\", stringreceivedmessage);\n+                yioremotedockhandler.booleanheartbeat = false;\n+                booleanresult = false;\n+            }\n+        } else\n+\n+        {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 203}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIzNDMyNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    IRRECEIVERON,\n          \n          \n            \n                    IR_RECEIVER_ON,", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489234326", "createdAt": "2020-09-16T07:50:05Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteBindingConstants.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+\n+/**\n+ * The {@link YIOremoteBindingConstants} class defines common constants, which are\n+ * used across the whole binding.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteBindingConstants {\n+\n+    public static final String BINDING_ID = \"yioremote\";\n+\n+    // List of all used global variables\n+    public static enum YIOREMOTEDOCKHANDLESTATUS {\n+        UNINITIALIZED_STATE,\n+        AUTHENTICATION_PROCESS,\n+        AUTHENTICATION_FAILED,\n+        AUTHENTICATION_COMPLETE,\n+        CONNECTION_FAILED,\n+        CONNECTION_ESTABLISHED;\n+    }\n+\n+    public static enum YIOREMOTEMESSAGETYPE {\n+        IRSEND,\n+        AUTHENTICATE,\n+        HEARTBEAT,\n+        IRRECEIVERON,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIzNDUwNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public String accesstoken = \"0\";\n          \n          \n            \n                public String accessToken = \"0\";", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489234506", "createdAt": "2020-09-16T07:50:22Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteConfiguration.java", "diffHunk": "@@ -0,0 +1,27 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+\n+/**\n+ * The {@link YIOremoteConfiguration} class contains fields mapping thing configuration parameters.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteConfiguration {\n+    public @Nullable String host;\n+    public String accesstoken = \"0\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIzNjAzOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void sendircode(@Nullable String stringIRCode) {\n          \n          \n            \n                public void sendIRCode(@Nullable String code) {", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489236038", "createdAt": "2020-09-16T07:52:51Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private YIOremoteDockHandler yioremotedockhandler = this;\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String stringreceivedmessage = \"\";\n+    private JsonObject jsonobjectrecievedJsonObject = new JsonObject();\n+    private boolean booleanheartbeat = false;\n+    private boolean booleanauthenticationok = false;\n+    private String stringreceivedstatus = \"\";\n+    private String stringlastsendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+        yioremotedockhandler = this;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed\");\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(Boolean booleanconnectedflag) {\n+                    if (booleanconnectedflag) {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_ESTABLISHED;\n+                        yioremotedockhandler.authenticate(booleanconnectedflag);\n+                    } else {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    yioremotedockhandler.stringreceivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    jsonobjectrecievedJsonObject = convertStringtoJsonObject(\n+                            yioremotedockhandler.stringreceivedmessage);\n+                    if (jsonobjectrecievedJsonObject.size() > 0) {\n+                        if (yioremotedockhandler.decodereceivedMessage(jsonobjectrecievedJsonObject)) {\n+                            yioremotedockhandler.triggerChannel(getChannelUuid(GROUP_OUTPUT, YIODOCKSTATUS));\n+                            yioremotedockhandler.updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                    yioremotedockhandler.stringreceivedstatus);\n+                            logger.debug(\"Message {} decoded\", yioremotedockhandler.stringreceivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\",\n+                                    yioremotedockhandler.stringreceivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                yioremoteDockHandlerwebSocketClient.start();\n+\n+                yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient, uriyiodockwebsocketaddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject JsonObject_recievedJsonObject) {\n+        boolean booleanresult = false;\n+\n+        if (JsonObject_recievedJsonObject.has(\"type\")) {\n+            if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+                yioremotedockhandler.stringreceivedstatus = \"Authentication required\";\n+            } else if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                yioremotedockhandler.booleanauthenticationok = true;\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+                yioremotedockhandler.stringreceivedstatus = \"Authentication ok\";\n+            } else if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\")\n+                    && JsonObject_recievedJsonObject.has(\"message\"))\n+\n+            {\n+                if (JsonObject_recievedJsonObject.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (JsonObject_recievedJsonObject.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        yioremotedockhandler.stringreceivedstatus = \"Send IR Code successfully\";\n+                        yioremotedockhandler.booleanheartbeat = true;\n+                        booleanresult = true;\n+                    } else {\n+                        if (stringlastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            stringreceivedstatus = \"Send IR Code failure\";\n+                        }\n+                        yioremotedockhandler.booleanheartbeat = true;\n+                        booleanresult = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", stringreceivedmessage);\n+                    yioremotedockhandler.booleanheartbeat = false;\n+                    booleanresult = false;\n+                }\n+            } else if (JsonObject_recievedJsonObject.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                yioremotedockhandler.stringreceivedstatus = JsonObject_recievedJsonObject.get(\"code\").toString()\n+                        .replace(\"\\\"\", \"\");\n+                if (stringreceivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    yioremotedockhandler.stringreceivedstatus = JsonObject_recievedJsonObject.get(\"code\").toString()\n+                            .replace(\"\\\"\", \"\");\n+                } else {\n+                    yioremotedockhandler.stringreceivedstatus = \"\";\n+                }\n+                logger.debug(\"ir_receive message {}\", stringreceivedstatus);\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+            } else {\n+                logger.warn(\"No known message {}\", stringreceivedmessage);\n+                yioremotedockhandler.booleanheartbeat = false;\n+                booleanresult = false;\n+            }\n+        } else\n+\n+        {\n+            logger.warn(\"No known message {}\", stringreceivedmessage);\n+            yioremotedockhandler.booleanheartbeat = false;\n+            booleanresult = false;\n+        }\n+        return booleanresult;\n+    }\n+\n+    private JsonObject convertStringtoJsonObject(String jsonString) {\n+        try {\n+            JsonParser parser = new JsonParser();\n+            JsonElement jsonElement = parser.parse(jsonString);\n+            JsonObject result;\n+\n+            if (jsonElement instanceof JsonObject) {\n+                result = jsonElement.getAsJsonObject();\n+            } else {\n+                logger.debug(\"{} is not valid JSON stirng\", jsonString);\n+                result = new JsonObject();\n+                throw new IllegalArgumentException(jsonString + \"{} is not valid JSON stirng\");\n+            }\n+            return result;\n+        } catch (IllegalArgumentException e) {\n+            JsonObject result = new JsonObject();\n+            return result;\n+        }\n+    }\n+\n+    protected void updateState(String group, String channelId, State value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, value);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(YIOremoteDockActions.class);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (authenticationjob != null) {\n+            authenticationjob.cancel(true);\n+        }\n+        if (websocketpollingjob != null) {\n+            websocketpollingjob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (YIODOCKRECEIVERSWITCH.equals(channelUID.getIdWithoutGroup())) {\n+            if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_COMPLETE)) {\n+                if (command.toString().equals(\"ON\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVERON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVEROFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void sendircode(@Nullable String stringIRCode) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 268}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIzNjc3OA==", "bodyText": "The argument is not used in this method.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489236778", "createdAt": "2020-09-16T07:54:07Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private YIOremoteDockHandler yioremotedockhandler = this;\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String stringreceivedmessage = \"\";\n+    private JsonObject jsonobjectrecievedJsonObject = new JsonObject();\n+    private boolean booleanheartbeat = false;\n+    private boolean booleanauthenticationok = false;\n+    private String stringreceivedstatus = \"\";\n+    private String stringlastsendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+        yioremotedockhandler = this;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed\");\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(Boolean booleanconnectedflag) {\n+                    if (booleanconnectedflag) {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_ESTABLISHED;\n+                        yioremotedockhandler.authenticate(booleanconnectedflag);\n+                    } else {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    yioremotedockhandler.stringreceivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    jsonobjectrecievedJsonObject = convertStringtoJsonObject(\n+                            yioremotedockhandler.stringreceivedmessage);\n+                    if (jsonobjectrecievedJsonObject.size() > 0) {\n+                        if (yioremotedockhandler.decodereceivedMessage(jsonobjectrecievedJsonObject)) {\n+                            yioremotedockhandler.triggerChannel(getChannelUuid(GROUP_OUTPUT, YIODOCKSTATUS));\n+                            yioremotedockhandler.updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                    yioremotedockhandler.stringreceivedstatus);\n+                            logger.debug(\"Message {} decoded\", yioremotedockhandler.stringreceivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\",\n+                                    yioremotedockhandler.stringreceivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                yioremoteDockHandlerwebSocketClient.start();\n+\n+                yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient, uriyiodockwebsocketaddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject JsonObject_recievedJsonObject) {\n+        boolean booleanresult = false;\n+\n+        if (JsonObject_recievedJsonObject.has(\"type\")) {\n+            if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+                yioremotedockhandler.stringreceivedstatus = \"Authentication required\";\n+            } else if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                yioremotedockhandler.booleanauthenticationok = true;\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+                yioremotedockhandler.stringreceivedstatus = \"Authentication ok\";\n+            } else if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\")\n+                    && JsonObject_recievedJsonObject.has(\"message\"))\n+\n+            {\n+                if (JsonObject_recievedJsonObject.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (JsonObject_recievedJsonObject.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        yioremotedockhandler.stringreceivedstatus = \"Send IR Code successfully\";\n+                        yioremotedockhandler.booleanheartbeat = true;\n+                        booleanresult = true;\n+                    } else {\n+                        if (stringlastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            stringreceivedstatus = \"Send IR Code failure\";\n+                        }\n+                        yioremotedockhandler.booleanheartbeat = true;\n+                        booleanresult = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", stringreceivedmessage);\n+                    yioremotedockhandler.booleanheartbeat = false;\n+                    booleanresult = false;\n+                }\n+            } else if (JsonObject_recievedJsonObject.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                yioremotedockhandler.stringreceivedstatus = JsonObject_recievedJsonObject.get(\"code\").toString()\n+                        .replace(\"\\\"\", \"\");\n+                if (stringreceivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    yioremotedockhandler.stringreceivedstatus = JsonObject_recievedJsonObject.get(\"code\").toString()\n+                            .replace(\"\\\"\", \"\");\n+                } else {\n+                    yioremotedockhandler.stringreceivedstatus = \"\";\n+                }\n+                logger.debug(\"ir_receive message {}\", stringreceivedstatus);\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+            } else {\n+                logger.warn(\"No known message {}\", stringreceivedmessage);\n+                yioremotedockhandler.booleanheartbeat = false;\n+                booleanresult = false;\n+            }\n+        } else\n+\n+        {\n+            logger.warn(\"No known message {}\", stringreceivedmessage);\n+            yioremotedockhandler.booleanheartbeat = false;\n+            booleanresult = false;\n+        }\n+        return booleanresult;\n+    }\n+\n+    private JsonObject convertStringtoJsonObject(String jsonString) {\n+        try {\n+            JsonParser parser = new JsonParser();\n+            JsonElement jsonElement = parser.parse(jsonString);\n+            JsonObject result;\n+\n+            if (jsonElement instanceof JsonObject) {\n+                result = jsonElement.getAsJsonObject();\n+            } else {\n+                logger.debug(\"{} is not valid JSON stirng\", jsonString);\n+                result = new JsonObject();\n+                throw new IllegalArgumentException(jsonString + \"{} is not valid JSON stirng\");\n+            }\n+            return result;\n+        } catch (IllegalArgumentException e) {\n+            JsonObject result = new JsonObject();\n+            return result;\n+        }\n+    }\n+\n+    protected void updateState(String group, String channelId, State value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, value);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(YIOremoteDockActions.class);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (authenticationjob != null) {\n+            authenticationjob.cancel(true);\n+        }\n+        if (websocketpollingjob != null) {\n+            websocketpollingjob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (YIODOCKRECEIVERSWITCH.equals(channelUID.getIdWithoutGroup())) {\n+            if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_COMPLETE)) {\n+                if (command.toString().equals(\"ON\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVERON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVEROFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void sendircode(@Nullable String stringIRCode) {\n+        if (stringIRCode != null) {\n+            if (stringIRCode.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRSEND, stringIRCode);\n+            } else {\n+                logger.warn(\"Wrong ir code format {}\", stringIRCode);\n+            }\n+        }\n+    }\n+\n+    private ChannelUID getChannelUuid(String group, String typeId) {\n+        return new ChannelUID(getThing().getUID(), group, typeId);\n+    }\n+\n+    private void updateChannelString(String group, String channelId, String value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, new StringType(value));\n+    }\n+\n+    private void authenticate(boolean booleanconnectedflag) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 287}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIzOTY1Nw==", "bodyText": "Is it reasonable to send an authentication request every 5 sec.?", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489239657", "createdAt": "2020-09-16T07:58:43Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private YIOremoteDockHandler yioremotedockhandler = this;\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String stringreceivedmessage = \"\";\n+    private JsonObject jsonobjectrecievedJsonObject = new JsonObject();\n+    private boolean booleanheartbeat = false;\n+    private boolean booleanauthenticationok = false;\n+    private String stringreceivedstatus = \"\";\n+    private String stringlastsendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+        yioremotedockhandler = this;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed\");\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(Boolean booleanconnectedflag) {\n+                    if (booleanconnectedflag) {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_ESTABLISHED;\n+                        yioremotedockhandler.authenticate(booleanconnectedflag);\n+                    } else {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    yioremotedockhandler.stringreceivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    jsonobjectrecievedJsonObject = convertStringtoJsonObject(\n+                            yioremotedockhandler.stringreceivedmessage);\n+                    if (jsonobjectrecievedJsonObject.size() > 0) {\n+                        if (yioremotedockhandler.decodereceivedMessage(jsonobjectrecievedJsonObject)) {\n+                            yioremotedockhandler.triggerChannel(getChannelUuid(GROUP_OUTPUT, YIODOCKSTATUS));\n+                            yioremotedockhandler.updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                    yioremotedockhandler.stringreceivedstatus);\n+                            logger.debug(\"Message {} decoded\", yioremotedockhandler.stringreceivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\",\n+                                    yioremotedockhandler.stringreceivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                yioremoteDockHandlerwebSocketClient.start();\n+\n+                yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient, uriyiodockwebsocketaddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject JsonObject_recievedJsonObject) {\n+        boolean booleanresult = false;\n+\n+        if (JsonObject_recievedJsonObject.has(\"type\")) {\n+            if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+                yioremotedockhandler.stringreceivedstatus = \"Authentication required\";\n+            } else if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                yioremotedockhandler.booleanauthenticationok = true;\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+                yioremotedockhandler.stringreceivedstatus = \"Authentication ok\";\n+            } else if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\")\n+                    && JsonObject_recievedJsonObject.has(\"message\"))\n+\n+            {\n+                if (JsonObject_recievedJsonObject.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (JsonObject_recievedJsonObject.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        yioremotedockhandler.stringreceivedstatus = \"Send IR Code successfully\";\n+                        yioremotedockhandler.booleanheartbeat = true;\n+                        booleanresult = true;\n+                    } else {\n+                        if (stringlastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            stringreceivedstatus = \"Send IR Code failure\";\n+                        }\n+                        yioremotedockhandler.booleanheartbeat = true;\n+                        booleanresult = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", stringreceivedmessage);\n+                    yioremotedockhandler.booleanheartbeat = false;\n+                    booleanresult = false;\n+                }\n+            } else if (JsonObject_recievedJsonObject.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                yioremotedockhandler.stringreceivedstatus = JsonObject_recievedJsonObject.get(\"code\").toString()\n+                        .replace(\"\\\"\", \"\");\n+                if (stringreceivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    yioremotedockhandler.stringreceivedstatus = JsonObject_recievedJsonObject.get(\"code\").toString()\n+                            .replace(\"\\\"\", \"\");\n+                } else {\n+                    yioremotedockhandler.stringreceivedstatus = \"\";\n+                }\n+                logger.debug(\"ir_receive message {}\", stringreceivedstatus);\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+            } else {\n+                logger.warn(\"No known message {}\", stringreceivedmessage);\n+                yioremotedockhandler.booleanheartbeat = false;\n+                booleanresult = false;\n+            }\n+        } else\n+\n+        {\n+            logger.warn(\"No known message {}\", stringreceivedmessage);\n+            yioremotedockhandler.booleanheartbeat = false;\n+            booleanresult = false;\n+        }\n+        return booleanresult;\n+    }\n+\n+    private JsonObject convertStringtoJsonObject(String jsonString) {\n+        try {\n+            JsonParser parser = new JsonParser();\n+            JsonElement jsonElement = parser.parse(jsonString);\n+            JsonObject result;\n+\n+            if (jsonElement instanceof JsonObject) {\n+                result = jsonElement.getAsJsonObject();\n+            } else {\n+                logger.debug(\"{} is not valid JSON stirng\", jsonString);\n+                result = new JsonObject();\n+                throw new IllegalArgumentException(jsonString + \"{} is not valid JSON stirng\");\n+            }\n+            return result;\n+        } catch (IllegalArgumentException e) {\n+            JsonObject result = new JsonObject();\n+            return result;\n+        }\n+    }\n+\n+    protected void updateState(String group, String channelId, State value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, value);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(YIOremoteDockActions.class);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (authenticationjob != null) {\n+            authenticationjob.cancel(true);\n+        }\n+        if (websocketpollingjob != null) {\n+            websocketpollingjob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (YIODOCKRECEIVERSWITCH.equals(channelUID.getIdWithoutGroup())) {\n+            if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_COMPLETE)) {\n+                if (command.toString().equals(\"ON\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVERON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVEROFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void sendircode(@Nullable String stringIRCode) {\n+        if (stringIRCode != null) {\n+            if (stringIRCode.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRSEND, stringIRCode);\n+            } else {\n+                logger.warn(\"Wrong ir code format {}\", stringIRCode);\n+            }\n+        }\n+    }\n+\n+    private ChannelUID getChannelUuid(String group, String typeId) {\n+        return new ChannelUID(getThing().getUID(), group, typeId);\n+    }\n+\n+    private void updateChannelString(String group, String channelId, String value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, new StringType(value));\n+    }\n+\n+    private void authenticate(boolean booleanconnectedflag) {\n+        Runnable authenticationhread = new Runnable() {\n+            @Override\n+            public void run() {\n+                if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.CONNECTION_ESTABLISHED)) {\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                            yioremotedockhandler.localConfig.accesstoken);\n+                    yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS;\n+                } else if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS)) {\n+                    if (yioremotedockhandler.getbooleanauthenticationok()) {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_COMPLETE;\n+                        updateStatus(ThingStatus.ONLINE);\n+                        yioremotedockhandler.startwebsocketpollingthread();\n+                        if (authenticationjob != null) {\n+                            authenticationjob.cancel(true);\n+                        }\n+                    } else {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_FAILED;\n+                    }\n+                } else {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                }\n+            }\n+        };\n+        authenticationjob = scheduler.scheduleWithFixedDelay(authenticationhread, 0, 5, TimeUnit.SECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 313}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI0MTM3NQ==", "bodyText": "Is there a reason this method is protected? You could also access the flag directly. I make a suggestion below.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489241375", "createdAt": "2020-09-16T08:01:29Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private YIOremoteDockHandler yioremotedockhandler = this;\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String stringreceivedmessage = \"\";\n+    private JsonObject jsonobjectrecievedJsonObject = new JsonObject();\n+    private boolean booleanheartbeat = false;\n+    private boolean booleanauthenticationok = false;\n+    private String stringreceivedstatus = \"\";\n+    private String stringlastsendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+        yioremotedockhandler = this;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed\");\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(Boolean booleanconnectedflag) {\n+                    if (booleanconnectedflag) {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_ESTABLISHED;\n+                        yioremotedockhandler.authenticate(booleanconnectedflag);\n+                    } else {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    yioremotedockhandler.stringreceivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    jsonobjectrecievedJsonObject = convertStringtoJsonObject(\n+                            yioremotedockhandler.stringreceivedmessage);\n+                    if (jsonobjectrecievedJsonObject.size() > 0) {\n+                        if (yioremotedockhandler.decodereceivedMessage(jsonobjectrecievedJsonObject)) {\n+                            yioremotedockhandler.triggerChannel(getChannelUuid(GROUP_OUTPUT, YIODOCKSTATUS));\n+                            yioremotedockhandler.updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                    yioremotedockhandler.stringreceivedstatus);\n+                            logger.debug(\"Message {} decoded\", yioremotedockhandler.stringreceivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\",\n+                                    yioremotedockhandler.stringreceivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                yioremoteDockHandlerwebSocketClient.start();\n+\n+                yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient, uriyiodockwebsocketaddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject JsonObject_recievedJsonObject) {\n+        boolean booleanresult = false;\n+\n+        if (JsonObject_recievedJsonObject.has(\"type\")) {\n+            if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+                yioremotedockhandler.stringreceivedstatus = \"Authentication required\";\n+            } else if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                yioremotedockhandler.booleanauthenticationok = true;\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+                yioremotedockhandler.stringreceivedstatus = \"Authentication ok\";\n+            } else if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\")\n+                    && JsonObject_recievedJsonObject.has(\"message\"))\n+\n+            {\n+                if (JsonObject_recievedJsonObject.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (JsonObject_recievedJsonObject.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        yioremotedockhandler.stringreceivedstatus = \"Send IR Code successfully\";\n+                        yioremotedockhandler.booleanheartbeat = true;\n+                        booleanresult = true;\n+                    } else {\n+                        if (stringlastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            stringreceivedstatus = \"Send IR Code failure\";\n+                        }\n+                        yioremotedockhandler.booleanheartbeat = true;\n+                        booleanresult = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", stringreceivedmessage);\n+                    yioremotedockhandler.booleanheartbeat = false;\n+                    booleanresult = false;\n+                }\n+            } else if (JsonObject_recievedJsonObject.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                yioremotedockhandler.stringreceivedstatus = JsonObject_recievedJsonObject.get(\"code\").toString()\n+                        .replace(\"\\\"\", \"\");\n+                if (stringreceivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    yioremotedockhandler.stringreceivedstatus = JsonObject_recievedJsonObject.get(\"code\").toString()\n+                            .replace(\"\\\"\", \"\");\n+                } else {\n+                    yioremotedockhandler.stringreceivedstatus = \"\";\n+                }\n+                logger.debug(\"ir_receive message {}\", stringreceivedstatus);\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+            } else {\n+                logger.warn(\"No known message {}\", stringreceivedmessage);\n+                yioremotedockhandler.booleanheartbeat = false;\n+                booleanresult = false;\n+            }\n+        } else\n+\n+        {\n+            logger.warn(\"No known message {}\", stringreceivedmessage);\n+            yioremotedockhandler.booleanheartbeat = false;\n+            booleanresult = false;\n+        }\n+        return booleanresult;\n+    }\n+\n+    private JsonObject convertStringtoJsonObject(String jsonString) {\n+        try {\n+            JsonParser parser = new JsonParser();\n+            JsonElement jsonElement = parser.parse(jsonString);\n+            JsonObject result;\n+\n+            if (jsonElement instanceof JsonObject) {\n+                result = jsonElement.getAsJsonObject();\n+            } else {\n+                logger.debug(\"{} is not valid JSON stirng\", jsonString);\n+                result = new JsonObject();\n+                throw new IllegalArgumentException(jsonString + \"{} is not valid JSON stirng\");\n+            }\n+            return result;\n+        } catch (IllegalArgumentException e) {\n+            JsonObject result = new JsonObject();\n+            return result;\n+        }\n+    }\n+\n+    protected void updateState(String group, String channelId, State value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, value);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(YIOremoteDockActions.class);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (authenticationjob != null) {\n+            authenticationjob.cancel(true);\n+        }\n+        if (websocketpollingjob != null) {\n+            websocketpollingjob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (YIODOCKRECEIVERSWITCH.equals(channelUID.getIdWithoutGroup())) {\n+            if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_COMPLETE)) {\n+                if (command.toString().equals(\"ON\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVERON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVEROFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void sendircode(@Nullable String stringIRCode) {\n+        if (stringIRCode != null) {\n+            if (stringIRCode.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRSEND, stringIRCode);\n+            } else {\n+                logger.warn(\"Wrong ir code format {}\", stringIRCode);\n+            }\n+        }\n+    }\n+\n+    private ChannelUID getChannelUuid(String group, String typeId) {\n+        return new ChannelUID(getThing().getUID(), group, typeId);\n+    }\n+\n+    private void updateChannelString(String group, String channelId, String value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, new StringType(value));\n+    }\n+\n+    private void authenticate(boolean booleanconnectedflag) {\n+        Runnable authenticationhread = new Runnable() {\n+            @Override\n+            public void run() {\n+                if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.CONNECTION_ESTABLISHED)) {\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                            yioremotedockhandler.localConfig.accesstoken);\n+                    yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS;\n+                } else if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS)) {\n+                    if (yioremotedockhandler.getbooleanauthenticationok()) {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_COMPLETE;\n+                        updateStatus(ThingStatus.ONLINE);\n+                        yioremotedockhandler.startwebsocketpollingthread();\n+                        if (authenticationjob != null) {\n+                            authenticationjob.cancel(true);\n+                        }\n+                    } else {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_FAILED;\n+                    }\n+                } else {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                }\n+            }\n+        };\n+        authenticationjob = scheduler.scheduleWithFixedDelay(authenticationhread, 0, 5, TimeUnit.SECONDS);\n+    }\n+\n+    private void startwebsocketpollingthread() {\n+        Runnable websocketpollingthread = new Runnable() {\n+            @Override\n+            public void run() {\n+                if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_COMPLETE)) {\n+                    if (yioremotedockhandler.getbooleanheartbeat()) {\n+                        logger.debug(\"heartbeat ok\");\n+                        yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+                    } else {\n+                        yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_FAILED;\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Connection lost no ping from YIO DOCK\");\n+                        updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                        if (websocketpollingjob != null) {\n+                            websocketpollingjob.cancel(true);\n+                        }\n+                    }\n+                } else {\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                }\n+            }\n+        };\n+        websocketpollingjob = scheduler.scheduleWithFixedDelay(websocketpollingthread, 0, 30, TimeUnit.SECONDS);\n+    }\n+\n+    protected boolean getbooleanauthenticationok() {\n+        return yioremotedockhandler.booleanauthenticationok;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 348}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI0MTU3Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                if (yioremotedockhandler.getbooleanauthenticationok()) {\n          \n          \n            \n                                if (booleanauthenticationok) {", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489241576", "createdAt": "2020-09-16T08:01:48Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private YIOremoteDockHandler yioremotedockhandler = this;\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String stringreceivedmessage = \"\";\n+    private JsonObject jsonobjectrecievedJsonObject = new JsonObject();\n+    private boolean booleanheartbeat = false;\n+    private boolean booleanauthenticationok = false;\n+    private String stringreceivedstatus = \"\";\n+    private String stringlastsendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+        yioremotedockhandler = this;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed\");\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(Boolean booleanconnectedflag) {\n+                    if (booleanconnectedflag) {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_ESTABLISHED;\n+                        yioremotedockhandler.authenticate(booleanconnectedflag);\n+                    } else {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    yioremotedockhandler.stringreceivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    jsonobjectrecievedJsonObject = convertStringtoJsonObject(\n+                            yioremotedockhandler.stringreceivedmessage);\n+                    if (jsonobjectrecievedJsonObject.size() > 0) {\n+                        if (yioremotedockhandler.decodereceivedMessage(jsonobjectrecievedJsonObject)) {\n+                            yioremotedockhandler.triggerChannel(getChannelUuid(GROUP_OUTPUT, YIODOCKSTATUS));\n+                            yioremotedockhandler.updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                    yioremotedockhandler.stringreceivedstatus);\n+                            logger.debug(\"Message {} decoded\", yioremotedockhandler.stringreceivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\",\n+                                    yioremotedockhandler.stringreceivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                yioremoteDockHandlerwebSocketClient.start();\n+\n+                yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient, uriyiodockwebsocketaddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject JsonObject_recievedJsonObject) {\n+        boolean booleanresult = false;\n+\n+        if (JsonObject_recievedJsonObject.has(\"type\")) {\n+            if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+                yioremotedockhandler.stringreceivedstatus = \"Authentication required\";\n+            } else if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                yioremotedockhandler.booleanauthenticationok = true;\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+                yioremotedockhandler.stringreceivedstatus = \"Authentication ok\";\n+            } else if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\")\n+                    && JsonObject_recievedJsonObject.has(\"message\"))\n+\n+            {\n+                if (JsonObject_recievedJsonObject.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (JsonObject_recievedJsonObject.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        yioremotedockhandler.stringreceivedstatus = \"Send IR Code successfully\";\n+                        yioremotedockhandler.booleanheartbeat = true;\n+                        booleanresult = true;\n+                    } else {\n+                        if (stringlastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            stringreceivedstatus = \"Send IR Code failure\";\n+                        }\n+                        yioremotedockhandler.booleanheartbeat = true;\n+                        booleanresult = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", stringreceivedmessage);\n+                    yioremotedockhandler.booleanheartbeat = false;\n+                    booleanresult = false;\n+                }\n+            } else if (JsonObject_recievedJsonObject.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                yioremotedockhandler.stringreceivedstatus = JsonObject_recievedJsonObject.get(\"code\").toString()\n+                        .replace(\"\\\"\", \"\");\n+                if (stringreceivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    yioremotedockhandler.stringreceivedstatus = JsonObject_recievedJsonObject.get(\"code\").toString()\n+                            .replace(\"\\\"\", \"\");\n+                } else {\n+                    yioremotedockhandler.stringreceivedstatus = \"\";\n+                }\n+                logger.debug(\"ir_receive message {}\", stringreceivedstatus);\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+            } else {\n+                logger.warn(\"No known message {}\", stringreceivedmessage);\n+                yioremotedockhandler.booleanheartbeat = false;\n+                booleanresult = false;\n+            }\n+        } else\n+\n+        {\n+            logger.warn(\"No known message {}\", stringreceivedmessage);\n+            yioremotedockhandler.booleanheartbeat = false;\n+            booleanresult = false;\n+        }\n+        return booleanresult;\n+    }\n+\n+    private JsonObject convertStringtoJsonObject(String jsonString) {\n+        try {\n+            JsonParser parser = new JsonParser();\n+            JsonElement jsonElement = parser.parse(jsonString);\n+            JsonObject result;\n+\n+            if (jsonElement instanceof JsonObject) {\n+                result = jsonElement.getAsJsonObject();\n+            } else {\n+                logger.debug(\"{} is not valid JSON stirng\", jsonString);\n+                result = new JsonObject();\n+                throw new IllegalArgumentException(jsonString + \"{} is not valid JSON stirng\");\n+            }\n+            return result;\n+        } catch (IllegalArgumentException e) {\n+            JsonObject result = new JsonObject();\n+            return result;\n+        }\n+    }\n+\n+    protected void updateState(String group, String channelId, State value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, value);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(YIOremoteDockActions.class);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (authenticationjob != null) {\n+            authenticationjob.cancel(true);\n+        }\n+        if (websocketpollingjob != null) {\n+            websocketpollingjob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (YIODOCKRECEIVERSWITCH.equals(channelUID.getIdWithoutGroup())) {\n+            if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_COMPLETE)) {\n+                if (command.toString().equals(\"ON\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVERON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVEROFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void sendircode(@Nullable String stringIRCode) {\n+        if (stringIRCode != null) {\n+            if (stringIRCode.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRSEND, stringIRCode);\n+            } else {\n+                logger.warn(\"Wrong ir code format {}\", stringIRCode);\n+            }\n+        }\n+    }\n+\n+    private ChannelUID getChannelUuid(String group, String typeId) {\n+        return new ChannelUID(getThing().getUID(), group, typeId);\n+    }\n+\n+    private void updateChannelString(String group, String channelId, String value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, new StringType(value));\n+    }\n+\n+    private void authenticate(boolean booleanconnectedflag) {\n+        Runnable authenticationhread = new Runnable() {\n+            @Override\n+            public void run() {\n+                if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.CONNECTION_ESTABLISHED)) {\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                            yioremotedockhandler.localConfig.accesstoken);\n+                    yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS;\n+                } else if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS)) {\n+                    if (yioremotedockhandler.getbooleanauthenticationok()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 296}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI0MjU2NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                protected boolean getbooleanheartbeat() {\n          \n          \n            \n                    boolean booleanresult = yioremotedockhandler.booleanheartbeat;\n          \n          \n            \n                    yioremotedockhandler.booleanheartbeat = false;\n          \n          \n            \n                    return booleanresult;\n          \n          \n            \n                }\n          \n          \n            \n                private boolean getbooleanheartbeat() {\n          \n          \n            \n                    boolean result = booleanheartbeat;\n          \n          \n            \n                    booleanheartbeat = false;\n          \n          \n            \n                    return result;\n          \n          \n            \n                }", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489242565", "createdAt": "2020-09-16T08:03:38Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private YIOremoteDockHandler yioremotedockhandler = this;\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String stringreceivedmessage = \"\";\n+    private JsonObject jsonobjectrecievedJsonObject = new JsonObject();\n+    private boolean booleanheartbeat = false;\n+    private boolean booleanauthenticationok = false;\n+    private String stringreceivedstatus = \"\";\n+    private String stringlastsendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+        yioremotedockhandler = this;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed\");\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(Boolean booleanconnectedflag) {\n+                    if (booleanconnectedflag) {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_ESTABLISHED;\n+                        yioremotedockhandler.authenticate(booleanconnectedflag);\n+                    } else {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    yioremotedockhandler.stringreceivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    jsonobjectrecievedJsonObject = convertStringtoJsonObject(\n+                            yioremotedockhandler.stringreceivedmessage);\n+                    if (jsonobjectrecievedJsonObject.size() > 0) {\n+                        if (yioremotedockhandler.decodereceivedMessage(jsonobjectrecievedJsonObject)) {\n+                            yioremotedockhandler.triggerChannel(getChannelUuid(GROUP_OUTPUT, YIODOCKSTATUS));\n+                            yioremotedockhandler.updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                    yioremotedockhandler.stringreceivedstatus);\n+                            logger.debug(\"Message {} decoded\", yioremotedockhandler.stringreceivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\",\n+                                    yioremotedockhandler.stringreceivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                yioremoteDockHandlerwebSocketClient.start();\n+\n+                yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient, uriyiodockwebsocketaddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject JsonObject_recievedJsonObject) {\n+        boolean booleanresult = false;\n+\n+        if (JsonObject_recievedJsonObject.has(\"type\")) {\n+            if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+                yioremotedockhandler.stringreceivedstatus = \"Authentication required\";\n+            } else if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                yioremotedockhandler.booleanauthenticationok = true;\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+                yioremotedockhandler.stringreceivedstatus = \"Authentication ok\";\n+            } else if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\")\n+                    && JsonObject_recievedJsonObject.has(\"message\"))\n+\n+            {\n+                if (JsonObject_recievedJsonObject.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (JsonObject_recievedJsonObject.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        yioremotedockhandler.stringreceivedstatus = \"Send IR Code successfully\";\n+                        yioremotedockhandler.booleanheartbeat = true;\n+                        booleanresult = true;\n+                    } else {\n+                        if (stringlastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            stringreceivedstatus = \"Send IR Code failure\";\n+                        }\n+                        yioremotedockhandler.booleanheartbeat = true;\n+                        booleanresult = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", stringreceivedmessage);\n+                    yioremotedockhandler.booleanheartbeat = false;\n+                    booleanresult = false;\n+                }\n+            } else if (JsonObject_recievedJsonObject.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                yioremotedockhandler.stringreceivedstatus = JsonObject_recievedJsonObject.get(\"code\").toString()\n+                        .replace(\"\\\"\", \"\");\n+                if (stringreceivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    yioremotedockhandler.stringreceivedstatus = JsonObject_recievedJsonObject.get(\"code\").toString()\n+                            .replace(\"\\\"\", \"\");\n+                } else {\n+                    yioremotedockhandler.stringreceivedstatus = \"\";\n+                }\n+                logger.debug(\"ir_receive message {}\", stringreceivedstatus);\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+            } else {\n+                logger.warn(\"No known message {}\", stringreceivedmessage);\n+                yioremotedockhandler.booleanheartbeat = false;\n+                booleanresult = false;\n+            }\n+        } else\n+\n+        {\n+            logger.warn(\"No known message {}\", stringreceivedmessage);\n+            yioremotedockhandler.booleanheartbeat = false;\n+            booleanresult = false;\n+        }\n+        return booleanresult;\n+    }\n+\n+    private JsonObject convertStringtoJsonObject(String jsonString) {\n+        try {\n+            JsonParser parser = new JsonParser();\n+            JsonElement jsonElement = parser.parse(jsonString);\n+            JsonObject result;\n+\n+            if (jsonElement instanceof JsonObject) {\n+                result = jsonElement.getAsJsonObject();\n+            } else {\n+                logger.debug(\"{} is not valid JSON stirng\", jsonString);\n+                result = new JsonObject();\n+                throw new IllegalArgumentException(jsonString + \"{} is not valid JSON stirng\");\n+            }\n+            return result;\n+        } catch (IllegalArgumentException e) {\n+            JsonObject result = new JsonObject();\n+            return result;\n+        }\n+    }\n+\n+    protected void updateState(String group, String channelId, State value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, value);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(YIOremoteDockActions.class);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (authenticationjob != null) {\n+            authenticationjob.cancel(true);\n+        }\n+        if (websocketpollingjob != null) {\n+            websocketpollingjob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (YIODOCKRECEIVERSWITCH.equals(channelUID.getIdWithoutGroup())) {\n+            if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_COMPLETE)) {\n+                if (command.toString().equals(\"ON\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVERON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVEROFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void sendircode(@Nullable String stringIRCode) {\n+        if (stringIRCode != null) {\n+            if (stringIRCode.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRSEND, stringIRCode);\n+            } else {\n+                logger.warn(\"Wrong ir code format {}\", stringIRCode);\n+            }\n+        }\n+    }\n+\n+    private ChannelUID getChannelUuid(String group, String typeId) {\n+        return new ChannelUID(getThing().getUID(), group, typeId);\n+    }\n+\n+    private void updateChannelString(String group, String channelId, String value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, new StringType(value));\n+    }\n+\n+    private void authenticate(boolean booleanconnectedflag) {\n+        Runnable authenticationhread = new Runnable() {\n+            @Override\n+            public void run() {\n+                if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.CONNECTION_ESTABLISHED)) {\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                            yioremotedockhandler.localConfig.accesstoken);\n+                    yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS;\n+                } else if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS)) {\n+                    if (yioremotedockhandler.getbooleanauthenticationok()) {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_COMPLETE;\n+                        updateStatus(ThingStatus.ONLINE);\n+                        yioremotedockhandler.startwebsocketpollingthread();\n+                        if (authenticationjob != null) {\n+                            authenticationjob.cancel(true);\n+                        }\n+                    } else {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_FAILED;\n+                    }\n+                } else {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                }\n+            }\n+        };\n+        authenticationjob = scheduler.scheduleWithFixedDelay(authenticationhread, 0, 5, TimeUnit.SECONDS);\n+    }\n+\n+    private void startwebsocketpollingthread() {\n+        Runnable websocketpollingthread = new Runnable() {\n+            @Override\n+            public void run() {\n+                if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_COMPLETE)) {\n+                    if (yioremotedockhandler.getbooleanheartbeat()) {\n+                        logger.debug(\"heartbeat ok\");\n+                        yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+                    } else {\n+                        yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_FAILED;\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Connection lost no ping from YIO DOCK\");\n+                        updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                        if (websocketpollingjob != null) {\n+                            websocketpollingjob.cancel(true);\n+                        }\n+                    }\n+                } else {\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                }\n+            }\n+        };\n+        websocketpollingjob = scheduler.scheduleWithFixedDelay(websocketpollingthread, 0, 30, TimeUnit.SECONDS);\n+    }\n+\n+    protected boolean getbooleanauthenticationok() {\n+        return yioremotedockhandler.booleanauthenticationok;\n+    }\n+\n+    protected boolean getbooleanheartbeat() {\n+        boolean booleanresult = yioremotedockhandler.booleanheartbeat;\n+        yioremotedockhandler.booleanheartbeat = false;\n+        return booleanresult;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 354}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI0MzAwNA==", "bodyText": "See above. Access directly.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489243004", "createdAt": "2020-09-16T08:04:26Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private YIOremoteDockHandler yioremotedockhandler = this;\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String stringreceivedmessage = \"\";\n+    private JsonObject jsonobjectrecievedJsonObject = new JsonObject();\n+    private boolean booleanheartbeat = false;\n+    private boolean booleanauthenticationok = false;\n+    private String stringreceivedstatus = \"\";\n+    private String stringlastsendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+        yioremotedockhandler = this;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed\");\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(Boolean booleanconnectedflag) {\n+                    if (booleanconnectedflag) {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_ESTABLISHED;\n+                        yioremotedockhandler.authenticate(booleanconnectedflag);\n+                    } else {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    yioremotedockhandler.stringreceivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    jsonobjectrecievedJsonObject = convertStringtoJsonObject(\n+                            yioremotedockhandler.stringreceivedmessage);\n+                    if (jsonobjectrecievedJsonObject.size() > 0) {\n+                        if (yioremotedockhandler.decodereceivedMessage(jsonobjectrecievedJsonObject)) {\n+                            yioremotedockhandler.triggerChannel(getChannelUuid(GROUP_OUTPUT, YIODOCKSTATUS));\n+                            yioremotedockhandler.updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                    yioremotedockhandler.stringreceivedstatus);\n+                            logger.debug(\"Message {} decoded\", yioremotedockhandler.stringreceivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\",\n+                                    yioremotedockhandler.stringreceivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                yioremoteDockHandlerwebSocketClient.start();\n+\n+                yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient, uriyiodockwebsocketaddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject JsonObject_recievedJsonObject) {\n+        boolean booleanresult = false;\n+\n+        if (JsonObject_recievedJsonObject.has(\"type\")) {\n+            if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+                yioremotedockhandler.stringreceivedstatus = \"Authentication required\";\n+            } else if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                yioremotedockhandler.booleanauthenticationok = true;\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+                yioremotedockhandler.stringreceivedstatus = \"Authentication ok\";\n+            } else if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\")\n+                    && JsonObject_recievedJsonObject.has(\"message\"))\n+\n+            {\n+                if (JsonObject_recievedJsonObject.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (JsonObject_recievedJsonObject.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        yioremotedockhandler.stringreceivedstatus = \"Send IR Code successfully\";\n+                        yioremotedockhandler.booleanheartbeat = true;\n+                        booleanresult = true;\n+                    } else {\n+                        if (stringlastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            stringreceivedstatus = \"Send IR Code failure\";\n+                        }\n+                        yioremotedockhandler.booleanheartbeat = true;\n+                        booleanresult = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", stringreceivedmessage);\n+                    yioremotedockhandler.booleanheartbeat = false;\n+                    booleanresult = false;\n+                }\n+            } else if (JsonObject_recievedJsonObject.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                yioremotedockhandler.stringreceivedstatus = JsonObject_recievedJsonObject.get(\"code\").toString()\n+                        .replace(\"\\\"\", \"\");\n+                if (stringreceivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    yioremotedockhandler.stringreceivedstatus = JsonObject_recievedJsonObject.get(\"code\").toString()\n+                            .replace(\"\\\"\", \"\");\n+                } else {\n+                    yioremotedockhandler.stringreceivedstatus = \"\";\n+                }\n+                logger.debug(\"ir_receive message {}\", stringreceivedstatus);\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+            } else {\n+                logger.warn(\"No known message {}\", stringreceivedmessage);\n+                yioremotedockhandler.booleanheartbeat = false;\n+                booleanresult = false;\n+            }\n+        } else\n+\n+        {\n+            logger.warn(\"No known message {}\", stringreceivedmessage);\n+            yioremotedockhandler.booleanheartbeat = false;\n+            booleanresult = false;\n+        }\n+        return booleanresult;\n+    }\n+\n+    private JsonObject convertStringtoJsonObject(String jsonString) {\n+        try {\n+            JsonParser parser = new JsonParser();\n+            JsonElement jsonElement = parser.parse(jsonString);\n+            JsonObject result;\n+\n+            if (jsonElement instanceof JsonObject) {\n+                result = jsonElement.getAsJsonObject();\n+            } else {\n+                logger.debug(\"{} is not valid JSON stirng\", jsonString);\n+                result = new JsonObject();\n+                throw new IllegalArgumentException(jsonString + \"{} is not valid JSON stirng\");\n+            }\n+            return result;\n+        } catch (IllegalArgumentException e) {\n+            JsonObject result = new JsonObject();\n+            return result;\n+        }\n+    }\n+\n+    protected void updateState(String group, String channelId, State value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, value);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(YIOremoteDockActions.class);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (authenticationjob != null) {\n+            authenticationjob.cancel(true);\n+        }\n+        if (websocketpollingjob != null) {\n+            websocketpollingjob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (YIODOCKRECEIVERSWITCH.equals(channelUID.getIdWithoutGroup())) {\n+            if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_COMPLETE)) {\n+                if (command.toString().equals(\"ON\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVERON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVEROFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void sendircode(@Nullable String stringIRCode) {\n+        if (stringIRCode != null) {\n+            if (stringIRCode.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRSEND, stringIRCode);\n+            } else {\n+                logger.warn(\"Wrong ir code format {}\", stringIRCode);\n+            }\n+        }\n+    }\n+\n+    private ChannelUID getChannelUuid(String group, String typeId) {\n+        return new ChannelUID(getThing().getUID(), group, typeId);\n+    }\n+\n+    private void updateChannelString(String group, String channelId, String value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, new StringType(value));\n+    }\n+\n+    private void authenticate(boolean booleanconnectedflag) {\n+        Runnable authenticationhread = new Runnable() {\n+            @Override\n+            public void run() {\n+                if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.CONNECTION_ESTABLISHED)) {\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                            yioremotedockhandler.localConfig.accesstoken);\n+                    yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS;\n+                } else if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS)) {\n+                    if (yioremotedockhandler.getbooleanauthenticationok()) {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_COMPLETE;\n+                        updateStatus(ThingStatus.ONLINE);\n+                        yioremotedockhandler.startwebsocketpollingthread();\n+                        if (authenticationjob != null) {\n+                            authenticationjob.cancel(true);\n+                        }\n+                    } else {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_FAILED;\n+                    }\n+                } else {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                }\n+            }\n+        };\n+        authenticationjob = scheduler.scheduleWithFixedDelay(authenticationhread, 0, 5, TimeUnit.SECONDS);\n+    }\n+\n+    private void startwebsocketpollingthread() {\n+        Runnable websocketpollingthread = new Runnable() {\n+            @Override\n+            public void run() {\n+                if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_COMPLETE)) {\n+                    if (yioremotedockhandler.getbooleanheartbeat()) {\n+                        logger.debug(\"heartbeat ok\");\n+                        yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+                    } else {\n+                        yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_FAILED;\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Connection lost no ping from YIO DOCK\");\n+                        updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                        if (websocketpollingjob != null) {\n+                            websocketpollingjob.cancel(true);\n+                        }\n+                    }\n+                } else {\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                }\n+            }\n+        };\n+        websocketpollingjob = scheduler.scheduleWithFixedDelay(websocketpollingthread, 0, 30, TimeUnit.SECONDS);\n+    }\n+\n+    protected boolean getbooleanauthenticationok() {\n+        return yioremotedockhandler.booleanauthenticationok;\n+    }\n+\n+    protected boolean getbooleanheartbeat() {\n+        boolean booleanresult = yioremotedockhandler.booleanheartbeat;\n+        yioremotedockhandler.booleanheartbeat = false;\n+        return booleanresult;\n+    }\n+\n+    public YIOREMOTEDOCKHANDLESTATUS getyioremotedockactualstatus() {\n+        return yioremotedockhandler.yioremotedockactualstatus;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 358}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI0NTIzNg==", "bodyText": "You could use JSON DTOs to send and receive JSON data. See here for example: https://github.com/openhab/openhab-addons/pull/8050/files#diff-904c4bebdb6a68e4a2c9d9c8289bdffdR99", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489245236", "createdAt": "2020-09-16T08:08:06Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEDOCKHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private YIOremoteDockHandler yioremotedockhandler = this;\n+    private WebSocketClient yioremoteDockHandlerwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI uriyiodockwebsocketaddress;\n+    private YIOREMOTEDOCKHANDLESTATUS yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String stringreceivedmessage = \"\";\n+    private JsonObject jsonobjectrecievedJsonObject = new JsonObject();\n+    private boolean booleanheartbeat = false;\n+    private boolean booleanauthenticationok = false;\n+    private String stringreceivedstatus = \"\";\n+    private String stringlastsendircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+        yioremotedockhandler = this;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                uriyiodockwebsocketaddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed\");\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(Boolean booleanconnectedflag) {\n+                    if (booleanconnectedflag) {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_ESTABLISHED;\n+                        yioremotedockhandler.authenticate(booleanconnectedflag);\n+                    } else {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    yioremotedockhandler.stringreceivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    jsonobjectrecievedJsonObject = convertStringtoJsonObject(\n+                            yioremotedockhandler.stringreceivedmessage);\n+                    if (jsonobjectrecievedJsonObject.size() > 0) {\n+                        if (yioremotedockhandler.decodereceivedMessage(jsonobjectrecievedJsonObject)) {\n+                            yioremotedockhandler.triggerChannel(getChannelUuid(GROUP_OUTPUT, YIODOCKSTATUS));\n+                            yioremotedockhandler.updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                    yioremotedockhandler.stringreceivedstatus);\n+                            logger.debug(\"Message {} decoded\", yioremotedockhandler.stringreceivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\",\n+                                    yioremotedockhandler.stringreceivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                yioremoteDockHandlerwebSocketClient.start();\n+\n+                yioremoteDockHandlerwebSocketClient.connect(yioremoteDockwebSocketClient, uriyiodockwebsocketaddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject JsonObject_recievedJsonObject) {\n+        boolean booleanresult = false;\n+\n+        if (JsonObject_recievedJsonObject.has(\"type\")) {\n+            if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+                yioremotedockhandler.stringreceivedstatus = \"Authentication required\";\n+            } else if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                yioremotedockhandler.booleanauthenticationok = true;\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+                yioremotedockhandler.stringreceivedstatus = \"Authentication ok\";\n+            } else if (JsonObject_recievedJsonObject.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\")\n+                    && JsonObject_recievedJsonObject.has(\"message\"))\n+\n+            {\n+                if (JsonObject_recievedJsonObject.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (JsonObject_recievedJsonObject.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        yioremotedockhandler.stringreceivedstatus = \"Send IR Code successfully\";\n+                        yioremotedockhandler.booleanheartbeat = true;\n+                        booleanresult = true;\n+                    } else {\n+                        if (stringlastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            stringreceivedstatus = \"Send IR Code failure\";\n+                        }\n+                        yioremotedockhandler.booleanheartbeat = true;\n+                        booleanresult = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", stringreceivedmessage);\n+                    yioremotedockhandler.booleanheartbeat = false;\n+                    booleanresult = false;\n+                }\n+            } else if (JsonObject_recievedJsonObject.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                yioremotedockhandler.stringreceivedstatus = JsonObject_recievedJsonObject.get(\"code\").toString()\n+                        .replace(\"\\\"\", \"\");\n+                if (stringreceivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    yioremotedockhandler.stringreceivedstatus = JsonObject_recievedJsonObject.get(\"code\").toString()\n+                            .replace(\"\\\"\", \"\");\n+                } else {\n+                    yioremotedockhandler.stringreceivedstatus = \"\";\n+                }\n+                logger.debug(\"ir_receive message {}\", stringreceivedstatus);\n+                yioremotedockhandler.booleanheartbeat = true;\n+                booleanresult = true;\n+            } else {\n+                logger.warn(\"No known message {}\", stringreceivedmessage);\n+                yioremotedockhandler.booleanheartbeat = false;\n+                booleanresult = false;\n+            }\n+        } else\n+\n+        {\n+            logger.warn(\"No known message {}\", stringreceivedmessage);\n+            yioremotedockhandler.booleanheartbeat = false;\n+            booleanresult = false;\n+        }\n+        return booleanresult;\n+    }\n+\n+    private JsonObject convertStringtoJsonObject(String jsonString) {\n+        try {\n+            JsonParser parser = new JsonParser();\n+            JsonElement jsonElement = parser.parse(jsonString);\n+            JsonObject result;\n+\n+            if (jsonElement instanceof JsonObject) {\n+                result = jsonElement.getAsJsonObject();\n+            } else {\n+                logger.debug(\"{} is not valid JSON stirng\", jsonString);\n+                result = new JsonObject();\n+                throw new IllegalArgumentException(jsonString + \"{} is not valid JSON stirng\");\n+            }\n+            return result;\n+        } catch (IllegalArgumentException e) {\n+            JsonObject result = new JsonObject();\n+            return result;\n+        }\n+    }\n+\n+    protected void updateState(String group, String channelId, State value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, value);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(YIOremoteDockActions.class);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (authenticationjob != null) {\n+            authenticationjob.cancel(true);\n+        }\n+        if (websocketpollingjob != null) {\n+            websocketpollingjob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (YIODOCKRECEIVERSWITCH.equals(channelUID.getIdWithoutGroup())) {\n+            if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_COMPLETE)) {\n+                if (command.toString().equals(\"ON\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVERON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVEROFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void sendircode(@Nullable String stringIRCode) {\n+        if (stringIRCode != null) {\n+            if (stringIRCode.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.IRSEND, stringIRCode);\n+            } else {\n+                logger.warn(\"Wrong ir code format {}\", stringIRCode);\n+            }\n+        }\n+    }\n+\n+    private ChannelUID getChannelUuid(String group, String typeId) {\n+        return new ChannelUID(getThing().getUID(), group, typeId);\n+    }\n+\n+    private void updateChannelString(String group, String channelId, String value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, new StringType(value));\n+    }\n+\n+    private void authenticate(boolean booleanconnectedflag) {\n+        Runnable authenticationhread = new Runnable() {\n+            @Override\n+            public void run() {\n+                if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.CONNECTION_ESTABLISHED)) {\n+                    yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                            yioremotedockhandler.localConfig.accesstoken);\n+                    yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS;\n+                } else if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_PROCESS)) {\n+                    if (yioremotedockhandler.getbooleanauthenticationok()) {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_COMPLETE;\n+                        updateStatus(ThingStatus.ONLINE);\n+                        yioremotedockhandler.startwebsocketpollingthread();\n+                        if (authenticationjob != null) {\n+                            authenticationjob.cancel(true);\n+                        }\n+                    } else {\n+                        yioremotedockhandler.yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_FAILED;\n+                    }\n+                } else {\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                }\n+            }\n+        };\n+        authenticationjob = scheduler.scheduleWithFixedDelay(authenticationhread, 0, 5, TimeUnit.SECONDS);\n+    }\n+\n+    private void startwebsocketpollingthread() {\n+        Runnable websocketpollingthread = new Runnable() {\n+            @Override\n+            public void run() {\n+                if (yioremotedockactualstatus.equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_COMPLETE)) {\n+                    if (yioremotedockhandler.getbooleanheartbeat()) {\n+                        logger.debug(\"heartbeat ok\");\n+                        yioremotedockhandler.sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+                    } else {\n+                        yioremotedockactualstatus = YIOREMOTEDOCKHANDLESTATUS.CONNECTION_FAILED;\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Connection lost no ping from YIO DOCK\");\n+                        updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                        if (websocketpollingjob != null) {\n+                            websocketpollingjob.cancel(true);\n+                        }\n+                    }\n+                } else {\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, YIODOCKSTATUS, UnDefType.UNDEF);\n+                }\n+            }\n+        };\n+        websocketpollingjob = scheduler.scheduleWithFixedDelay(websocketpollingthread, 0, 30, TimeUnit.SECONDS);\n+    }\n+\n+    protected boolean getbooleanauthenticationok() {\n+        return yioremotedockhandler.booleanauthenticationok;\n+    }\n+\n+    protected boolean getbooleanheartbeat() {\n+        boolean booleanresult = yioremotedockhandler.booleanheartbeat;\n+        yioremotedockhandler.booleanheartbeat = false;\n+        return booleanresult;\n+    }\n+\n+    public YIOREMOTEDOCKHANDLESTATUS getyioremotedockactualstatus() {\n+        return yioremotedockhandler.yioremotedockactualstatus;\n+    }\n+\n+    public void sendMessage(YIOREMOTEMESSAGETYPE messagetype, String messagepyload) {\n+        if (messagetype.equals(YIOREMOTEMESSAGETYPE.AUTHENTICATE)) {\n+            yioremoteDockwebSocketClient.sendMessage(\"{\\\"type\\\":\\\"auth\\\", \\\"token\\\":\\\"\" + messagepyload + \"\\\"}\");\n+            logger.debug(\"sending authenticating message: \\\"{\\\"type\\\":\\\"auth\\\", \\\"token\\\":\\\"{}\\\"}\\\"\", messagepyload);\n+        } else if (messagetype.equals(YIOREMOTEMESSAGETYPE.HEARTBEAT)) {\n+            stringlastsendircode = \"\\\"0;0x0;0;0\\\"\";\n+            yioremoteDockwebSocketClient.sendMessage(\n+                    \"{\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_send\\\",\\\"code\\\":\\\"0;0x0;0;0\\\", \\\"format\\\":\\\"hex\\\"}\");\n+            logger.debug(\n+                    \"sending heartbeat message: {\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_send\\\",\\\"code\\\":\\\"0;0x0;0;0\\\", \\\"format\\\":\\\"hex\\\"}\");\n+        } else if (messagetype.equals(YIOREMOTEMESSAGETYPE.IRRECEIVERON) && yioremotedockhandler\n+                .getyioremotedockactualstatus().equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_COMPLETE)) {\n+            yioremoteDockwebSocketClient.sendMessage(\"{\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_receive_on\\\"}\");\n+            logger.debug(\"sending IR receiver on message: {\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_receive_on\\\"\");\n+        } else if (messagetype.equals(YIOREMOTEMESSAGETYPE.IRRECEIVEROFF) && yioremotedockhandler\n+                .getyioremotedockactualstatus().equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_COMPLETE)) {\n+            yioremoteDockwebSocketClient.sendMessage(\"{\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_receive_off\\\"}\");\n+            logger.debug(\"sending IR receiver off message: {\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_receive_off\\\"\");\n+        } else if (messagetype.equals(YIOREMOTEMESSAGETYPE.IRSEND) && yioremotedockhandler\n+                .getyioremotedockactualstatus().equals(YIOREMOTEDOCKHANDLESTATUS.AUTHENTICATION_COMPLETE)) {\n+            yioremoteDockwebSocketClient.sendMessage(\"{\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_send\\\",\\\"code\\\":\\\"\"\n+                    + messagepyload + \"\\\", \\\"format\\\":\\\"hex\\\"}\");\n+            stringlastsendircode = messagepyload;\n+            logger.debug(\n+                    \"sending IR message: {\\\"type\\\":\\\"dock\\\", \\\"command\\\":\\\"ir_send\\\",\\\"code\\\":\\\"{}\\\", \\\"format\\\":\\\"hex\\\"}\",\n+                    messagepyload);\n+        }\n+    }\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 388}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI0NjY0Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            thing-type.yioremote.yioremotedock.label = YIO Remote Dock Thing\n          \n          \n            \n            thing-type.yioremote.yioremotedock.label = YIO Remote Dock", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489246643", "createdAt": "2020-09-16T08:10:22Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/resources/ESH-INF/i18n/yioremote_de_DE.properties", "diffHunk": "@@ -0,0 +1,20 @@\n+# binding\n+binding.yioremote.name = YIOremote Addon\n+binding.yioremote.description = Dieses Addon steuert eine YIO Dock / Remote-Kombination\n+\n+# thing types\n+thing-type.yioremote.yioremotedock.label = YIO Remote Dock Thing", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI0NjkzNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            binding.yioremote.name = YIOremote Addon\n          \n          \n            \n            binding.yioremote.name = YIO Remote Binding", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489246937", "createdAt": "2020-09-16T08:10:51Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/resources/ESH-INF/i18n/yioremote_de_DE.properties", "diffHunk": "@@ -0,0 +1,20 @@\n+# binding\n+binding.yioremote.name = YIOremote Addon", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI0NzY0Mg==", "bodyText": "Can you use the same notation over the whole binding?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            thing-type.config.yioremote.yioremotedock.host.description = IP-Adresse oder Hostname des YIO-Docks\n          \n          \n            \n            thing-type.config.yioremote.yioremotedock.host.description = IP-Adresse oder Hostname des YIO Remote Docks", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489247642", "createdAt": "2020-09-16T08:12:03Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/resources/ESH-INF/i18n/yioremote_de_DE.properties", "diffHunk": "@@ -0,0 +1,20 @@\n+# binding\n+binding.yioremote.name = YIOremote Addon\n+binding.yioremote.description = Dieses Addon steuert eine YIO Dock / Remote-Kombination\n+\n+# thing types\n+thing-type.yioremote.yioremotedock.label = YIO Remote Dock Thing\n+thing-type.yioremote.yioremotedock.description = Stellt das YIO Remote Dock Thing bereit\n+\n+# thing type config description\n+thing-type.config.yioremote.yioremotedock.host.label = IP-Adresse oder Hostname\n+thing-type.config.yioremote.yioremotedock.host.description = IP-Adresse oder Hostname des YIO-Docks", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI0ODI0MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t<label>YIOremote Dock Binding Thing</label>\n          \n          \n            \n            \t\t<label>YIO Remote Dock</label>", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489248240", "createdAt": "2020-09-16T08:13:04Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,55 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"yioremote\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"yioremotedock\">\n+\t\t<label>YIOremote Dock Binding Thing</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI0ODcxOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t<thing-type id=\"yioremotedock\">\n          \n          \n            \n            \t<thing-type id=\"yioRemoteDock\">", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489248719", "createdAt": "2020-09-16T08:13:58Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,55 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"yioremote\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"yioremotedock\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI0OTcyNg==", "bodyText": "As you only have two Channels, you could add the Channels without groups, directly.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489249726", "createdAt": "2020-09-16T08:15:40Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,55 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"yioremote\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"yioremotedock\">\n+\t\t<label>YIOremote Dock Binding Thing</label>\n+\t\t<description>YIOremote Dock Binding Thing</description>\n+\t\t<channel-groups>\n+\t\t\t<channel-group id=\"input\" typeId=\"input\"/>\n+\t\t\t<channel-group id=\"output\" typeId=\"output\"/>\n+\t\t</channel-groups>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"host\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Network address of the YIO Remote Dock</label>\n+\t\t\t\t<description>Network address of the YIO Remote Dock</description>\n+\t\t\t\t<context>network-address</context>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"accesstoken\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Access token of the YIO Remote Dock</label>\n+\t\t\t\t<description>The authentication token for the access currently 0</description>\n+\t\t\t\t<default>0</default>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\t<channel-group-type id=\"input\">\n+\t\t<label>Inputs</label>\n+\t\t<description>The channels used for Input</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"receiverswitch\" typeId=\"receiverswitch\"/>\n+\t\t</channels>\n+\t</channel-group-type>\n+\t<channel-group-type id=\"output\">\n+\t\t<label>Outputs</label>\n+\t\t<description>The channels used for Output</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"status\" typeId=\"status\"/>\n+\t\t</channels>\n+\t</channel-group-type>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI0OTg3OQ==", "bodyText": "You don't need to repeat the binding or Thing name here.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t<label>YIO Remote Dock receiverswitch</label>\n          \n          \n            \n            \t\t<label>Receiver Switch</label>", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489249879", "createdAt": "2020-09-16T08:15:57Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,55 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"yioremote\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"yioremotedock\">\n+\t\t<label>YIOremote Dock Binding Thing</label>\n+\t\t<description>YIOremote Dock Binding Thing</description>\n+\t\t<channel-groups>\n+\t\t\t<channel-group id=\"input\" typeId=\"input\"/>\n+\t\t\t<channel-group id=\"output\" typeId=\"output\"/>\n+\t\t</channel-groups>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"host\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Network address of the YIO Remote Dock</label>\n+\t\t\t\t<description>Network address of the YIO Remote Dock</description>\n+\t\t\t\t<context>network-address</context>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"accesstoken\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Access token of the YIO Remote Dock</label>\n+\t\t\t\t<description>The authentication token for the access currently 0</description>\n+\t\t\t\t<default>0</default>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\t<channel-group-type id=\"input\">\n+\t\t<label>Inputs</label>\n+\t\t<description>The channels used for Input</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"receiverswitch\" typeId=\"receiverswitch\"/>\n+\t\t</channels>\n+\t</channel-group-type>\n+\t<channel-group-type id=\"output\">\n+\t\t<label>Outputs</label>\n+\t\t<description>The channels used for Output</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"status\" typeId=\"status\"/>\n+\t\t</channels>\n+\t</channel-group-type>\n+\t<channel-type id=\"receiverswitch\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>YIO Remote Dock receiverswitch</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI1MDIyOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t<label>YIO Remote Dock status</label>\n          \n          \n            \n            \t\t<label>Status</label>", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489250228", "createdAt": "2020-09-16T08:16:34Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,55 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"yioremote\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"yioremotedock\">\n+\t\t<label>YIOremote Dock Binding Thing</label>\n+\t\t<description>YIOremote Dock Binding Thing</description>\n+\t\t<channel-groups>\n+\t\t\t<channel-group id=\"input\" typeId=\"input\"/>\n+\t\t\t<channel-group id=\"output\" typeId=\"output\"/>\n+\t\t</channel-groups>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"host\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Network address of the YIO Remote Dock</label>\n+\t\t\t\t<description>Network address of the YIO Remote Dock</description>\n+\t\t\t\t<context>network-address</context>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"accesstoken\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Access token of the YIO Remote Dock</label>\n+\t\t\t\t<description>The authentication token for the access currently 0</description>\n+\t\t\t\t<default>0</default>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\t<channel-group-type id=\"input\">\n+\t\t<label>Inputs</label>\n+\t\t<description>The channels used for Input</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"receiverswitch\" typeId=\"receiverswitch\"/>\n+\t\t</channels>\n+\t</channel-group-type>\n+\t<channel-group-type id=\"output\">\n+\t\t<label>Outputs</label>\n+\t\t<description>The channels used for Output</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"status\" typeId=\"status\"/>\n+\t\t</channels>\n+\t</channel-group-type>\n+\t<channel-type id=\"receiverswitch\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>YIO Remote Dock receiverswitch</label>\n+\t\t<description>The switch to enable disable the IR receiving diode/function</description>\n+\t</channel-type>\n+\t<channel-type id=\"status\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>YIO Remote Dock status</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI1MDM1Ng==", "bodyText": "Please remove these empty lines.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489250356", "createdAt": "2020-09-16T08:16:47Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,55 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"yioremote\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"yioremotedock\">\n+\t\t<label>YIOremote Dock Binding Thing</label>\n+\t\t<description>YIOremote Dock Binding Thing</description>\n+\t\t<channel-groups>\n+\t\t\t<channel-group id=\"input\" typeId=\"input\"/>\n+\t\t\t<channel-group id=\"output\" typeId=\"output\"/>\n+\t\t</channel-groups>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"host\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Network address of the YIO Remote Dock</label>\n+\t\t\t\t<description>Network address of the YIO Remote Dock</description>\n+\t\t\t\t<context>network-address</context>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"accesstoken\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Access token of the YIO Remote Dock</label>\n+\t\t\t\t<description>The authentication token for the access currently 0</description>\n+\t\t\t\t<default>0</default>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\t<channel-group-type id=\"input\">\n+\t\t<label>Inputs</label>\n+\t\t<description>The channels used for Input</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"receiverswitch\" typeId=\"receiverswitch\"/>\n+\t\t</channels>\n+\t</channel-group-type>\n+\t<channel-group-type id=\"output\">\n+\t\t<label>Outputs</label>\n+\t\t<description>The channels used for Output</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"status\" typeId=\"status\"/>\n+\t\t</channels>\n+\t</channel-group-type>\n+\t<channel-type id=\"receiverswitch\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>YIO Remote Dock receiverswitch</label>\n+\t\t<description>The switch to enable disable the IR receiving diode/function</description>\n+\t</channel-type>\n+\t<channel-type id=\"status\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>YIO Remote Dock status</label>\n+\t\t<description>The status of the YIO Dock. If the reciever is on than the recognized IR code will be displayed otherwise\n+\t\t\tthe IR send status is displayed of the last IR code send.</description>\n+\n+\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI1MDgwOA==", "bodyText": "The header is still re-formatted by this PR.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489250808", "createdAt": "2020-09-16T08:17:35Z", "author": {"login": "fwolter"}, "path": "bundles/pom.xml", "diffHunk": "@@ -1,4 +1,6 @@\n-<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?><project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4NTg0OA=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI1MDkzMw==", "bodyText": "Can you leave this as-is?", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489250933", "createdAt": "2020-09-16T08:17:49Z", "author": {"login": "fwolter"}, "path": "bundles/pom.xml", "diffHunk": "@@ -236,7 +238,7 @@\n     <module>org.openhab.binding.snmp</module>\n     <module>org.openhab.binding.solaredge</module>\n     <module>org.openhab.binding.solarlog</module>\n-\t<module>org.openhab.binding.somfymylink</module>\n+    <module>org.openhab.binding.somfymylink</module>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI1MTEwOA==", "bodyText": "Can you leave this as-is?", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r489251108", "createdAt": "2020-09-16T08:18:05Z", "author": {"login": "fwolter"}, "path": "bundles/pom.xml", "diffHunk": "@@ -520,5 +523,4 @@\n       </build>\n     </profile>\n   </profiles>\n-", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 29}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkwNzkyMDc3", "url": "https://github.com/openhab/openhab-addons/pull/8394#pullrequestreview-490792077", "createdAt": "2020-09-17T16:40:03Z", "commit": {"oid": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 27, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNjo0MDowM1rOHTr9Pw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxNzoxNTowN1rOHTtR2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQwNTE4Mw==", "bodyText": "Same for below.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public String gettype() {\n          \n          \n            \n                public String getType() {", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490405183", "createdAt": "2020-09-17T16:40:03Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/AuthenticationMessage.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+import com.google.gson.JsonObject;\n+\n+/**\n+ * The {@link AuthenticationMessage} the AuthenticationMessage DTO\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AuthenticationMessage {\n+    private String type = \"auth\";\n+    private String token = \"0\";\n+\n+    public String gettype() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQwNTQwNw==", "bodyText": "Same for below.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    JsonObject authenticationmessagejsonobject = new JsonObject();\n          \n          \n            \n                    JsonObject authenticationMessage = new JsonObject();", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490405407", "createdAt": "2020-09-17T16:40:26Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/AuthenticationMessage.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+import com.google.gson.JsonObject;\n+\n+/**\n+ * The {@link AuthenticationMessage} the AuthenticationMessage DTO\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AuthenticationMessage {\n+    private String type = \"auth\";\n+    private String token = \"0\";\n+\n+    public String gettype() {\n+        return type;\n+    }\n+\n+    public String gettoken() {\n+        return token;\n+    }\n+\n+    public void settoken(String token) {\n+        this.token = token;\n+    }\n+\n+    public JsonObject getauthenticationmessagejsonobject() {\n+        JsonObject authenticationmessagejsonobject = new JsonObject();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQwNTkwNg==", "bodyText": "Same for the others\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public String getformat() {\n          \n          \n            \n                public String getFormat() {", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490405906", "createdAt": "2020-09-17T16:41:08Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/IRCode.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The {@link IRCode} the IRCode DTO\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class IRCode {\n+    private String code = \"0;0x0;0;0\";\n+    private String format = \"hex\";\n+\n+    public String getformat() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQwNjE2NQ==", "bodyText": "See above", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490406165", "createdAt": "2020-09-17T16:41:32Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/IRCodeSendMessage.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+import com.google.gson.JsonObject;\n+\n+/**\n+ * The {@link IRCodeSendMessage} the IRCodeSendMessage DTO\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class IRCodeSendMessage {\n+    private String type = \"dock\";\n+    private String command = \"ir_send\";\n+\n+    private IRCode ircode = new IRCode();\n+\n+    public IRCodeSendMessage(IRCode ircode) {\n+        this.ircode = ircode;\n+    }\n+\n+    public String getType() {\n+        return type;\n+    }\n+\n+    public String getCommand() {\n+        return command;\n+    }\n+\n+    public JsonObject getircodesendmessagejsonobject() {\n+        JsonObject ircodesendmessagejsonobject = new JsonObject();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQwNjUzOQ==", "bodyText": "Same for below\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void seton() {\n          \n          \n            \n                public void setOn() {", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490406539", "createdAt": "2020-09-17T16:42:07Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/IRReceiverMessage.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+import com.google.gson.JsonObject;\n+\n+/**\n+ * The {@link IRReceiverMessage} the IRReceiverMessage DTO\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class IRReceiverMessage {\n+    private String type = \"dock\";\n+    private String command = \"ir_receive_off\";\n+\n+    public void seton() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQwNzQ3NQ==", "bodyText": "Same for the other fields.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private YioRemoteDockHandleStatus yioremotedockactualstatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n          \n          \n            \n                private YioRemoteDockHandleStatus yioRemoteDockActualStatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490407475", "createdAt": "2020-09-17T16:43:35Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioremotedockactualstatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQwODEyMg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            public void onConnect(boolean connectedflag) {\n          \n          \n            \n                            public void onConnect(boolean connected) {", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490408122", "createdAt": "2020-09-17T16:44:34Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioremotedockactualstatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String receivedmessage = \"\";\n+    private JsonObject recievedjson = new JsonObject();\n+    private boolean heartbeat = false;\n+    private boolean authenticationok = false;\n+    private String receivedstatus = \"\";\n+    private String lastsendircode = \"\";\n+    private IRCode ircodereceivedhandler = new IRCode();\n+    private IRCode ircodesendhandler = new IRCode();\n+    private IRCodeSendMessage ircodesendmessagehandler = new IRCodeSendMessage(ircodesendhandler);\n+    private AuthenticationMessage authenticationmessagehandler = new AuthenticationMessage();\n+    private IRReceiverMessage irreceivermessagehandler = new IRReceiverMessage();\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                websocketAddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed \" + e.getMessage());\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(boolean connectedflag) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQwODI2Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    \"Initialize web socket failed \" + e.getMessage());\n          \n          \n            \n                                    \"Initialize web socket failed: \" + e.getMessage());", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490408267", "createdAt": "2020-09-17T16:44:47Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioremotedockactualstatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String receivedmessage = \"\";\n+    private JsonObject recievedjson = new JsonObject();\n+    private boolean heartbeat = false;\n+    private boolean authenticationok = false;\n+    private String receivedstatus = \"\";\n+    private String lastsendircode = \"\";\n+    private IRCode ircodereceivedhandler = new IRCode();\n+    private IRCode ircodesendhandler = new IRCode();\n+    private IRCodeSendMessage ircodesendmessagehandler = new IRCodeSendMessage(ircodesendhandler);\n+    private AuthenticationMessage authenticationmessagehandler = new AuthenticationMessage();\n+    private IRReceiverMessage irreceivermessagehandler = new IRReceiverMessage();\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                websocketAddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed \" + e.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQwODYxNw==", "bodyText": "Isn't this rather a CONFIGURATION_ERROR?", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490408617", "createdAt": "2020-09-17T16:45:17Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioremotedockactualstatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String receivedmessage = \"\";\n+    private JsonObject recievedjson = new JsonObject();\n+    private boolean heartbeat = false;\n+    private boolean authenticationok = false;\n+    private String receivedstatus = \"\";\n+    private String lastsendircode = \"\";\n+    private IRCode ircodereceivedhandler = new IRCode();\n+    private IRCode ircodesendhandler = new IRCode();\n+    private IRCodeSendMessage ircodesendmessagehandler = new IRCodeSendMessage(ircodesendhandler);\n+    private AuthenticationMessage authenticationmessagehandler = new AuthenticationMessage();\n+    private IRReceiverMessage irreceivermessagehandler = new IRReceiverMessage();\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                websocketAddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQwOTg2OA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private boolean decodereceivedMessage(JsonObject message) {\n          \n          \n            \n                private boolean decodeReceivedMessage(JsonObject message) {", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490409868", "createdAt": "2020-09-17T16:47:15Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioremotedockactualstatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String receivedmessage = \"\";\n+    private JsonObject recievedjson = new JsonObject();\n+    private boolean heartbeat = false;\n+    private boolean authenticationok = false;\n+    private String receivedstatus = \"\";\n+    private String lastsendircode = \"\";\n+    private IRCode ircodereceivedhandler = new IRCode();\n+    private IRCode ircodesendhandler = new IRCode();\n+    private IRCodeSendMessage ircodesendmessagehandler = new IRCodeSendMessage(ircodesendhandler);\n+    private AuthenticationMessage authenticationmessagehandler = new AuthenticationMessage();\n+    private IRReceiverMessage irreceivermessagehandler = new IRReceiverMessage();\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                websocketAddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed \" + e.getMessage());\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(boolean connectedflag) {\n+                    if (connectedflag) {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED;\n+                    } else {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    receivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    recievedjson = convertStringtoJsonObject(receivedmessage);\n+                    if (recievedjson.size() > 0) {\n+                        if (decodereceivedMessage(recievedjson)) {\n+                            triggerChannel(getChannelUuid(GROUP_OUTPUT, STATUS_STRING_CHANNEL));\n+                            updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL, receivedstatus);\n+                            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)\n+                                    || yioremotedockactualstatus\n+                                            .equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+                                authenticate();\n+                            }\n+                            logger.debug(\"Message {} decoded\", receivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\", receivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                webSocketClient.start();\n+\n+                webSocketClient.connect(yioremoteDockwebSocketClient, websocketAddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject message) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849"}, "originalPosition": 152}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQxMDIxNg==", "bodyText": "Empty line\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\") && message.has(\"message\"))\n          \n          \n            \n            \n          \n          \n            \n                        {\n          \n          \n            \n                        } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\") && message.has(\"message\")) {", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490410216", "createdAt": "2020-09-17T16:47:45Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioremotedockactualstatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String receivedmessage = \"\";\n+    private JsonObject recievedjson = new JsonObject();\n+    private boolean heartbeat = false;\n+    private boolean authenticationok = false;\n+    private String receivedstatus = \"\";\n+    private String lastsendircode = \"\";\n+    private IRCode ircodereceivedhandler = new IRCode();\n+    private IRCode ircodesendhandler = new IRCode();\n+    private IRCodeSendMessage ircodesendmessagehandler = new IRCodeSendMessage(ircodesendhandler);\n+    private AuthenticationMessage authenticationmessagehandler = new AuthenticationMessage();\n+    private IRReceiverMessage irreceivermessagehandler = new IRReceiverMessage();\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                websocketAddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed \" + e.getMessage());\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(boolean connectedflag) {\n+                    if (connectedflag) {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED;\n+                    } else {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    receivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    recievedjson = convertStringtoJsonObject(receivedmessage);\n+                    if (recievedjson.size() > 0) {\n+                        if (decodereceivedMessage(recievedjson)) {\n+                            triggerChannel(getChannelUuid(GROUP_OUTPUT, STATUS_STRING_CHANNEL));\n+                            updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL, receivedstatus);\n+                            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)\n+                                    || yioremotedockactualstatus\n+                                            .equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+                                authenticate();\n+                            }\n+                            logger.debug(\"Message {} decoded\", receivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\", receivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                webSocketClient.start();\n+\n+                webSocketClient.connect(yioremoteDockwebSocketClient, websocketAddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject message) {\n+        boolean success = false;\n+\n+        if (message.has(\"type\")) {\n+            if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication required\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                authenticationok = true;\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication ok\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\") && message.has(\"message\"))\n+\n+            {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849"}, "originalPosition": 167}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQxMDY0OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private JsonObject convertStringtoJsonObject(String jsonString) {\n          \n          \n            \n                private JsonObject convertStringToJsonObject(String jsonString) {", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490410649", "createdAt": "2020-09-17T16:48:18Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioremotedockactualstatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String receivedmessage = \"\";\n+    private JsonObject recievedjson = new JsonObject();\n+    private boolean heartbeat = false;\n+    private boolean authenticationok = false;\n+    private String receivedstatus = \"\";\n+    private String lastsendircode = \"\";\n+    private IRCode ircodereceivedhandler = new IRCode();\n+    private IRCode ircodesendhandler = new IRCode();\n+    private IRCodeSendMessage ircodesendmessagehandler = new IRCodeSendMessage(ircodesendhandler);\n+    private AuthenticationMessage authenticationmessagehandler = new AuthenticationMessage();\n+    private IRReceiverMessage irreceivermessagehandler = new IRReceiverMessage();\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                websocketAddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed \" + e.getMessage());\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(boolean connectedflag) {\n+                    if (connectedflag) {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED;\n+                    } else {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    receivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    recievedjson = convertStringtoJsonObject(receivedmessage);\n+                    if (recievedjson.size() > 0) {\n+                        if (decodereceivedMessage(recievedjson)) {\n+                            triggerChannel(getChannelUuid(GROUP_OUTPUT, STATUS_STRING_CHANNEL));\n+                            updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL, receivedstatus);\n+                            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)\n+                                    || yioremotedockactualstatus\n+                                            .equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+                                authenticate();\n+                            }\n+                            logger.debug(\"Message {} decoded\", receivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\", receivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                webSocketClient.start();\n+\n+                webSocketClient.connect(yioremoteDockwebSocketClient, websocketAddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject message) {\n+        boolean success = false;\n+\n+        if (message.has(\"type\")) {\n+            if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication required\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                authenticationok = true;\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication ok\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\") && message.has(\"message\"))\n+\n+            {\n+                if (message.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (message.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        receivedstatus = \"Send IR Code successfully\";\n+                        heartbeat = true;\n+                        success = true;\n+                    } else {\n+                        if (lastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            receivedstatus = \"Send IR Code failure\";\n+                        }\n+                        heartbeat = true;\n+                        success = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", receivedmessage);\n+                    heartbeat = false;\n+                    success = false;\n+                }\n+            } else if (message.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                receivedstatus = message.get(\"code\").toString().replace(\"\\\"\", \"\");\n+                if (receivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    ircodereceivedhandler.setcode(message.get(\"code\").toString().replace(\"\\\"\", \"\"));\n+                } else {\n+                    ircodereceivedhandler.setcode(\"\");\n+                }\n+                logger.debug(\"ir_receive message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = true;\n+                success = true;\n+            } else {\n+                logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = false;\n+                success = false;\n+            }\n+        } else {\n+            logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+            heartbeat = false;\n+            success = false;\n+        }\n+        return success;\n+    }\n+\n+    private JsonObject convertStringtoJsonObject(String jsonString) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849"}, "originalPosition": 210}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQxNzY4Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            if (command.toString().equals(\"ON\")) {\n          \n          \n            \n                            if (command == OnOffType.ON) {", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490417686", "createdAt": "2020-09-17T16:59:33Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioremotedockactualstatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String receivedmessage = \"\";\n+    private JsonObject recievedjson = new JsonObject();\n+    private boolean heartbeat = false;\n+    private boolean authenticationok = false;\n+    private String receivedstatus = \"\";\n+    private String lastsendircode = \"\";\n+    private IRCode ircodereceivedhandler = new IRCode();\n+    private IRCode ircodesendhandler = new IRCode();\n+    private IRCodeSendMessage ircodesendmessagehandler = new IRCodeSendMessage(ircodesendhandler);\n+    private AuthenticationMessage authenticationmessagehandler = new AuthenticationMessage();\n+    private IRReceiverMessage irreceivermessagehandler = new IRReceiverMessage();\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                websocketAddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed \" + e.getMessage());\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(boolean connectedflag) {\n+                    if (connectedflag) {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED;\n+                    } else {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    receivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    recievedjson = convertStringtoJsonObject(receivedmessage);\n+                    if (recievedjson.size() > 0) {\n+                        if (decodereceivedMessage(recievedjson)) {\n+                            triggerChannel(getChannelUuid(GROUP_OUTPUT, STATUS_STRING_CHANNEL));\n+                            updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL, receivedstatus);\n+                            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)\n+                                    || yioremotedockactualstatus\n+                                            .equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+                                authenticate();\n+                            }\n+                            logger.debug(\"Message {} decoded\", receivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\", receivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                webSocketClient.start();\n+\n+                webSocketClient.connect(yioremoteDockwebSocketClient, websocketAddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject message) {\n+        boolean success = false;\n+\n+        if (message.has(\"type\")) {\n+            if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication required\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                authenticationok = true;\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication ok\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\") && message.has(\"message\"))\n+\n+            {\n+                if (message.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (message.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        receivedstatus = \"Send IR Code successfully\";\n+                        heartbeat = true;\n+                        success = true;\n+                    } else {\n+                        if (lastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            receivedstatus = \"Send IR Code failure\";\n+                        }\n+                        heartbeat = true;\n+                        success = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", receivedmessage);\n+                    heartbeat = false;\n+                    success = false;\n+                }\n+            } else if (message.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                receivedstatus = message.get(\"code\").toString().replace(\"\\\"\", \"\");\n+                if (receivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    ircodereceivedhandler.setcode(message.get(\"code\").toString().replace(\"\\\"\", \"\"));\n+                } else {\n+                    ircodereceivedhandler.setcode(\"\");\n+                }\n+                logger.debug(\"ir_receive message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = true;\n+                success = true;\n+            } else {\n+                logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = false;\n+                success = false;\n+            }\n+        } else {\n+            logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+            heartbeat = false;\n+            success = false;\n+        }\n+        return success;\n+    }\n+\n+    private JsonObject convertStringtoJsonObject(String jsonString) {\n+        try {\n+            JsonParser parser = new JsonParser();\n+            JsonElement jsonElement = parser.parse(jsonString);\n+            JsonObject result;\n+\n+            if (jsonElement instanceof JsonObject) {\n+                result = jsonElement.getAsJsonObject();\n+            } else {\n+                logger.debug(\"{} is not valid JSON stirng\", jsonString);\n+                result = new JsonObject();\n+                throw new IllegalArgumentException(jsonString + \"{} is not valid JSON stirng\");\n+            }\n+            return result;\n+        } catch (IllegalArgumentException e) {\n+            JsonObject result = new JsonObject();\n+            return result;\n+        }\n+    }\n+\n+    public void updateState(String group, String channelId, State value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, value);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(YIOremoteDockActions.class);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (authenticationjob != null) {\n+            authenticationjob.cancel(true);\n+        }\n+        if (websocketpollingjob != null) {\n+            websocketpollingjob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (RECEIVER_SWITCH_CHANNEL.equals(channelUID.getIdWithoutGroup())) {\n+            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE)) {\n+                if (command.toString().equals(\"ON\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849"}, "originalPosition": 254}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQxODAxNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void sendircode(@Nullable String ircode) {\n          \n          \n            \n                public void sendIRCode(@Nullable String irCode) {", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490418016", "createdAt": "2020-09-17T17:00:05Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioremotedockactualstatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String receivedmessage = \"\";\n+    private JsonObject recievedjson = new JsonObject();\n+    private boolean heartbeat = false;\n+    private boolean authenticationok = false;\n+    private String receivedstatus = \"\";\n+    private String lastsendircode = \"\";\n+    private IRCode ircodereceivedhandler = new IRCode();\n+    private IRCode ircodesendhandler = new IRCode();\n+    private IRCodeSendMessage ircodesendmessagehandler = new IRCodeSendMessage(ircodesendhandler);\n+    private AuthenticationMessage authenticationmessagehandler = new AuthenticationMessage();\n+    private IRReceiverMessage irreceivermessagehandler = new IRReceiverMessage();\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                websocketAddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed \" + e.getMessage());\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(boolean connectedflag) {\n+                    if (connectedflag) {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED;\n+                    } else {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    receivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    recievedjson = convertStringtoJsonObject(receivedmessage);\n+                    if (recievedjson.size() > 0) {\n+                        if (decodereceivedMessage(recievedjson)) {\n+                            triggerChannel(getChannelUuid(GROUP_OUTPUT, STATUS_STRING_CHANNEL));\n+                            updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL, receivedstatus);\n+                            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)\n+                                    || yioremotedockactualstatus\n+                                            .equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+                                authenticate();\n+                            }\n+                            logger.debug(\"Message {} decoded\", receivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\", receivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                webSocketClient.start();\n+\n+                webSocketClient.connect(yioremoteDockwebSocketClient, websocketAddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject message) {\n+        boolean success = false;\n+\n+        if (message.has(\"type\")) {\n+            if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication required\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                authenticationok = true;\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication ok\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\") && message.has(\"message\"))\n+\n+            {\n+                if (message.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (message.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        receivedstatus = \"Send IR Code successfully\";\n+                        heartbeat = true;\n+                        success = true;\n+                    } else {\n+                        if (lastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            receivedstatus = \"Send IR Code failure\";\n+                        }\n+                        heartbeat = true;\n+                        success = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", receivedmessage);\n+                    heartbeat = false;\n+                    success = false;\n+                }\n+            } else if (message.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                receivedstatus = message.get(\"code\").toString().replace(\"\\\"\", \"\");\n+                if (receivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    ircodereceivedhandler.setcode(message.get(\"code\").toString().replace(\"\\\"\", \"\"));\n+                } else {\n+                    ircodereceivedhandler.setcode(\"\");\n+                }\n+                logger.debug(\"ir_receive message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = true;\n+                success = true;\n+            } else {\n+                logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = false;\n+                success = false;\n+            }\n+        } else {\n+            logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+            heartbeat = false;\n+            success = false;\n+        }\n+        return success;\n+    }\n+\n+    private JsonObject convertStringtoJsonObject(String jsonString) {\n+        try {\n+            JsonParser parser = new JsonParser();\n+            JsonElement jsonElement = parser.parse(jsonString);\n+            JsonObject result;\n+\n+            if (jsonElement instanceof JsonObject) {\n+                result = jsonElement.getAsJsonObject();\n+            } else {\n+                logger.debug(\"{} is not valid JSON stirng\", jsonString);\n+                result = new JsonObject();\n+                throw new IllegalArgumentException(jsonString + \"{} is not valid JSON stirng\");\n+            }\n+            return result;\n+        } catch (IllegalArgumentException e) {\n+            JsonObject result = new JsonObject();\n+            return result;\n+        }\n+    }\n+\n+    public void updateState(String group, String channelId, State value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, value);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(YIOremoteDockActions.class);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (authenticationjob != null) {\n+            authenticationjob.cancel(true);\n+        }\n+        if (websocketpollingjob != null) {\n+            websocketpollingjob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (RECEIVER_SWITCH_CHANNEL.equals(channelUID.getIdWithoutGroup())) {\n+            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE)) {\n+                if (command.toString().equals(\"ON\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    sendMessage(YioRemoteMessages.IR_RECEIVER_ON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    sendMessage(YioRemoteMessages.IR_RECEIVER_OFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void sendircode(@Nullable String ircode) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849"}, "originalPosition": 267}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQxODcyNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private void startwebsocketpollingthread() {\n          \n          \n            \n                private void startWebsocketPollingThread() {", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490418726", "createdAt": "2020-09-17T17:01:12Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioremotedockactualstatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String receivedmessage = \"\";\n+    private JsonObject recievedjson = new JsonObject();\n+    private boolean heartbeat = false;\n+    private boolean authenticationok = false;\n+    private String receivedstatus = \"\";\n+    private String lastsendircode = \"\";\n+    private IRCode ircodereceivedhandler = new IRCode();\n+    private IRCode ircodesendhandler = new IRCode();\n+    private IRCodeSendMessage ircodesendmessagehandler = new IRCodeSendMessage(ircodesendhandler);\n+    private AuthenticationMessage authenticationmessagehandler = new AuthenticationMessage();\n+    private IRReceiverMessage irreceivermessagehandler = new IRReceiverMessage();\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                websocketAddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed \" + e.getMessage());\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(boolean connectedflag) {\n+                    if (connectedflag) {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED;\n+                    } else {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    receivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    recievedjson = convertStringtoJsonObject(receivedmessage);\n+                    if (recievedjson.size() > 0) {\n+                        if (decodereceivedMessage(recievedjson)) {\n+                            triggerChannel(getChannelUuid(GROUP_OUTPUT, STATUS_STRING_CHANNEL));\n+                            updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL, receivedstatus);\n+                            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)\n+                                    || yioremotedockactualstatus\n+                                            .equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+                                authenticate();\n+                            }\n+                            logger.debug(\"Message {} decoded\", receivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\", receivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                webSocketClient.start();\n+\n+                webSocketClient.connect(yioremoteDockwebSocketClient, websocketAddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject message) {\n+        boolean success = false;\n+\n+        if (message.has(\"type\")) {\n+            if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication required\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                authenticationok = true;\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication ok\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\") && message.has(\"message\"))\n+\n+            {\n+                if (message.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (message.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        receivedstatus = \"Send IR Code successfully\";\n+                        heartbeat = true;\n+                        success = true;\n+                    } else {\n+                        if (lastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            receivedstatus = \"Send IR Code failure\";\n+                        }\n+                        heartbeat = true;\n+                        success = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", receivedmessage);\n+                    heartbeat = false;\n+                    success = false;\n+                }\n+            } else if (message.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                receivedstatus = message.get(\"code\").toString().replace(\"\\\"\", \"\");\n+                if (receivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    ircodereceivedhandler.setcode(message.get(\"code\").toString().replace(\"\\\"\", \"\"));\n+                } else {\n+                    ircodereceivedhandler.setcode(\"\");\n+                }\n+                logger.debug(\"ir_receive message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = true;\n+                success = true;\n+            } else {\n+                logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = false;\n+                success = false;\n+            }\n+        } else {\n+            logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+            heartbeat = false;\n+            success = false;\n+        }\n+        return success;\n+    }\n+\n+    private JsonObject convertStringtoJsonObject(String jsonString) {\n+        try {\n+            JsonParser parser = new JsonParser();\n+            JsonElement jsonElement = parser.parse(jsonString);\n+            JsonObject result;\n+\n+            if (jsonElement instanceof JsonObject) {\n+                result = jsonElement.getAsJsonObject();\n+            } else {\n+                logger.debug(\"{} is not valid JSON stirng\", jsonString);\n+                result = new JsonObject();\n+                throw new IllegalArgumentException(jsonString + \"{} is not valid JSON stirng\");\n+            }\n+            return result;\n+        } catch (IllegalArgumentException e) {\n+            JsonObject result = new JsonObject();\n+            return result;\n+        }\n+    }\n+\n+    public void updateState(String group, String channelId, State value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, value);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(YIOremoteDockActions.class);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (authenticationjob != null) {\n+            authenticationjob.cancel(true);\n+        }\n+        if (websocketpollingjob != null) {\n+            websocketpollingjob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (RECEIVER_SWITCH_CHANNEL.equals(channelUID.getIdWithoutGroup())) {\n+            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE)) {\n+                if (command.toString().equals(\"ON\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    sendMessage(YioRemoteMessages.IR_RECEIVER_ON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    sendMessage(YioRemoteMessages.IR_RECEIVER_OFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void sendircode(@Nullable String ircode) {\n+        if (ircode != null) {\n+            if (ircode.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                sendMessage(YioRemoteMessages.IR_SEND, ircode);\n+            } else {\n+                logger.warn(\"Wrong ir code format {}\", ircode);\n+            }\n+        }\n+    }\n+\n+    private ChannelUID getChannelUuid(String group, String typeId) {\n+        return new ChannelUID(getThing().getUID(), group, typeId);\n+    }\n+\n+    private void updateChannelString(String group, String channelId, String value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, new StringType(value));\n+    }\n+\n+    private void authenticate() {\n+        if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)) {\n+            authenticationmessagehandler.settoken(localConfig.accessToken);\n+            sendMessage(YioRemoteMessages.AUTHENTICATE_MESSAGE, localConfig.accessToken);\n+            yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+        } else if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+            if (getbooleanauthenticationok()) {\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE;\n+                updateStatus(ThingStatus.ONLINE);\n+                startwebsocketpollingthread();\n+                if (authenticationjob != null) {\n+                    authenticationjob.cancel(true);\n+                }\n+            } else {\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_FAILED;\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Connection lost no ping from YIO DOCK\");\n+            updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+        }\n+    }\n+\n+    private void startwebsocketpollingthread() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849"}, "originalPosition": 309}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQyMDEwMw==", "bodyText": "You could move the code within run() into a private method and then call the scheduler with this method:\nwebsocketpollingjob = scheduler.scheduleWithFixedDelay(this::myNewMethod, 0, 30, TimeUnit.SECONDS);\nThat avoids the boiler plate code of defining an anonymous class.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490420103", "createdAt": "2020-09-17T17:03:25Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioremotedockactualstatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String receivedmessage = \"\";\n+    private JsonObject recievedjson = new JsonObject();\n+    private boolean heartbeat = false;\n+    private boolean authenticationok = false;\n+    private String receivedstatus = \"\";\n+    private String lastsendircode = \"\";\n+    private IRCode ircodereceivedhandler = new IRCode();\n+    private IRCode ircodesendhandler = new IRCode();\n+    private IRCodeSendMessage ircodesendmessagehandler = new IRCodeSendMessage(ircodesendhandler);\n+    private AuthenticationMessage authenticationmessagehandler = new AuthenticationMessage();\n+    private IRReceiverMessage irreceivermessagehandler = new IRReceiverMessage();\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                websocketAddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed \" + e.getMessage());\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(boolean connectedflag) {\n+                    if (connectedflag) {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED;\n+                    } else {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    receivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    recievedjson = convertStringtoJsonObject(receivedmessage);\n+                    if (recievedjson.size() > 0) {\n+                        if (decodereceivedMessage(recievedjson)) {\n+                            triggerChannel(getChannelUuid(GROUP_OUTPUT, STATUS_STRING_CHANNEL));\n+                            updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL, receivedstatus);\n+                            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)\n+                                    || yioremotedockactualstatus\n+                                            .equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+                                authenticate();\n+                            }\n+                            logger.debug(\"Message {} decoded\", receivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\", receivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                webSocketClient.start();\n+\n+                webSocketClient.connect(yioremoteDockwebSocketClient, websocketAddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject message) {\n+        boolean success = false;\n+\n+        if (message.has(\"type\")) {\n+            if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication required\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                authenticationok = true;\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication ok\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\") && message.has(\"message\"))\n+\n+            {\n+                if (message.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (message.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        receivedstatus = \"Send IR Code successfully\";\n+                        heartbeat = true;\n+                        success = true;\n+                    } else {\n+                        if (lastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            receivedstatus = \"Send IR Code failure\";\n+                        }\n+                        heartbeat = true;\n+                        success = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", receivedmessage);\n+                    heartbeat = false;\n+                    success = false;\n+                }\n+            } else if (message.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                receivedstatus = message.get(\"code\").toString().replace(\"\\\"\", \"\");\n+                if (receivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    ircodereceivedhandler.setcode(message.get(\"code\").toString().replace(\"\\\"\", \"\"));\n+                } else {\n+                    ircodereceivedhandler.setcode(\"\");\n+                }\n+                logger.debug(\"ir_receive message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = true;\n+                success = true;\n+            } else {\n+                logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = false;\n+                success = false;\n+            }\n+        } else {\n+            logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+            heartbeat = false;\n+            success = false;\n+        }\n+        return success;\n+    }\n+\n+    private JsonObject convertStringtoJsonObject(String jsonString) {\n+        try {\n+            JsonParser parser = new JsonParser();\n+            JsonElement jsonElement = parser.parse(jsonString);\n+            JsonObject result;\n+\n+            if (jsonElement instanceof JsonObject) {\n+                result = jsonElement.getAsJsonObject();\n+            } else {\n+                logger.debug(\"{} is not valid JSON stirng\", jsonString);\n+                result = new JsonObject();\n+                throw new IllegalArgumentException(jsonString + \"{} is not valid JSON stirng\");\n+            }\n+            return result;\n+        } catch (IllegalArgumentException e) {\n+            JsonObject result = new JsonObject();\n+            return result;\n+        }\n+    }\n+\n+    public void updateState(String group, String channelId, State value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, value);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(YIOremoteDockActions.class);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (authenticationjob != null) {\n+            authenticationjob.cancel(true);\n+        }\n+        if (websocketpollingjob != null) {\n+            websocketpollingjob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (RECEIVER_SWITCH_CHANNEL.equals(channelUID.getIdWithoutGroup())) {\n+            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE)) {\n+                if (command.toString().equals(\"ON\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    sendMessage(YioRemoteMessages.IR_RECEIVER_ON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    sendMessage(YioRemoteMessages.IR_RECEIVER_OFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void sendircode(@Nullable String ircode) {\n+        if (ircode != null) {\n+            if (ircode.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                sendMessage(YioRemoteMessages.IR_SEND, ircode);\n+            } else {\n+                logger.warn(\"Wrong ir code format {}\", ircode);\n+            }\n+        }\n+    }\n+\n+    private ChannelUID getChannelUuid(String group, String typeId) {\n+        return new ChannelUID(getThing().getUID(), group, typeId);\n+    }\n+\n+    private void updateChannelString(String group, String channelId, String value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, new StringType(value));\n+    }\n+\n+    private void authenticate() {\n+        if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)) {\n+            authenticationmessagehandler.settoken(localConfig.accessToken);\n+            sendMessage(YioRemoteMessages.AUTHENTICATE_MESSAGE, localConfig.accessToken);\n+            yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+        } else if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+            if (getbooleanauthenticationok()) {\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE;\n+                updateStatus(ThingStatus.ONLINE);\n+                startwebsocketpollingthread();\n+                if (authenticationjob != null) {\n+                    authenticationjob.cancel(true);\n+                }\n+            } else {\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_FAILED;\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Connection lost no ping from YIO DOCK\");\n+            updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+        }\n+    }\n+\n+    private void startwebsocketpollingthread() {\n+        Runnable websocketpollingthread = new Runnable() {\n+            @Override\n+            public void run() {\n+                if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE)) {\n+                    if (getbooleanheartbeat()) {\n+                        updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL,\n+                                ircodereceivedhandler.getcode() + ircodereceivedhandler.getformat());\n+                        logger.debug(\"heartbeat ok\");\n+                        sendMessage(YioRemoteMessages.HEARTBEAT_MESSAGE, \"\");\n+                    } else {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Connection lost no ping from YIO DOCK\");\n+                        updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                        if (websocketpollingjob != null) {\n+                            websocketpollingjob.cancel(true);\n+                        }\n+                    }\n+                } else {\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                }\n+            }\n+        };\n+        websocketpollingjob = scheduler.scheduleWithFixedDelay(websocketpollingthread, 0, 30, TimeUnit.SECONDS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849"}, "originalPosition": 338}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQyMTE2Nw==", "bodyText": "This method is only used in this class. Is there a reason why you don't access the field directly?", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490421167", "createdAt": "2020-09-17T17:05:18Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioremotedockactualstatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String receivedmessage = \"\";\n+    private JsonObject recievedjson = new JsonObject();\n+    private boolean heartbeat = false;\n+    private boolean authenticationok = false;\n+    private String receivedstatus = \"\";\n+    private String lastsendircode = \"\";\n+    private IRCode ircodereceivedhandler = new IRCode();\n+    private IRCode ircodesendhandler = new IRCode();\n+    private IRCodeSendMessage ircodesendmessagehandler = new IRCodeSendMessage(ircodesendhandler);\n+    private AuthenticationMessage authenticationmessagehandler = new AuthenticationMessage();\n+    private IRReceiverMessage irreceivermessagehandler = new IRReceiverMessage();\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                websocketAddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed \" + e.getMessage());\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(boolean connectedflag) {\n+                    if (connectedflag) {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED;\n+                    } else {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    receivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    recievedjson = convertStringtoJsonObject(receivedmessage);\n+                    if (recievedjson.size() > 0) {\n+                        if (decodereceivedMessage(recievedjson)) {\n+                            triggerChannel(getChannelUuid(GROUP_OUTPUT, STATUS_STRING_CHANNEL));\n+                            updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL, receivedstatus);\n+                            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)\n+                                    || yioremotedockactualstatus\n+                                            .equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+                                authenticate();\n+                            }\n+                            logger.debug(\"Message {} decoded\", receivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\", receivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                webSocketClient.start();\n+\n+                webSocketClient.connect(yioremoteDockwebSocketClient, websocketAddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject message) {\n+        boolean success = false;\n+\n+        if (message.has(\"type\")) {\n+            if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication required\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                authenticationok = true;\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication ok\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\") && message.has(\"message\"))\n+\n+            {\n+                if (message.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (message.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        receivedstatus = \"Send IR Code successfully\";\n+                        heartbeat = true;\n+                        success = true;\n+                    } else {\n+                        if (lastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            receivedstatus = \"Send IR Code failure\";\n+                        }\n+                        heartbeat = true;\n+                        success = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", receivedmessage);\n+                    heartbeat = false;\n+                    success = false;\n+                }\n+            } else if (message.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                receivedstatus = message.get(\"code\").toString().replace(\"\\\"\", \"\");\n+                if (receivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    ircodereceivedhandler.setcode(message.get(\"code\").toString().replace(\"\\\"\", \"\"));\n+                } else {\n+                    ircodereceivedhandler.setcode(\"\");\n+                }\n+                logger.debug(\"ir_receive message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = true;\n+                success = true;\n+            } else {\n+                logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = false;\n+                success = false;\n+            }\n+        } else {\n+            logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+            heartbeat = false;\n+            success = false;\n+        }\n+        return success;\n+    }\n+\n+    private JsonObject convertStringtoJsonObject(String jsonString) {\n+        try {\n+            JsonParser parser = new JsonParser();\n+            JsonElement jsonElement = parser.parse(jsonString);\n+            JsonObject result;\n+\n+            if (jsonElement instanceof JsonObject) {\n+                result = jsonElement.getAsJsonObject();\n+            } else {\n+                logger.debug(\"{} is not valid JSON stirng\", jsonString);\n+                result = new JsonObject();\n+                throw new IllegalArgumentException(jsonString + \"{} is not valid JSON stirng\");\n+            }\n+            return result;\n+        } catch (IllegalArgumentException e) {\n+            JsonObject result = new JsonObject();\n+            return result;\n+        }\n+    }\n+\n+    public void updateState(String group, String channelId, State value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, value);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(YIOremoteDockActions.class);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (authenticationjob != null) {\n+            authenticationjob.cancel(true);\n+        }\n+        if (websocketpollingjob != null) {\n+            websocketpollingjob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (RECEIVER_SWITCH_CHANNEL.equals(channelUID.getIdWithoutGroup())) {\n+            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE)) {\n+                if (command.toString().equals(\"ON\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    sendMessage(YioRemoteMessages.IR_RECEIVER_ON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    sendMessage(YioRemoteMessages.IR_RECEIVER_OFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void sendircode(@Nullable String ircode) {\n+        if (ircode != null) {\n+            if (ircode.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                sendMessage(YioRemoteMessages.IR_SEND, ircode);\n+            } else {\n+                logger.warn(\"Wrong ir code format {}\", ircode);\n+            }\n+        }\n+    }\n+\n+    private ChannelUID getChannelUuid(String group, String typeId) {\n+        return new ChannelUID(getThing().getUID(), group, typeId);\n+    }\n+\n+    private void updateChannelString(String group, String channelId, String value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, new StringType(value));\n+    }\n+\n+    private void authenticate() {\n+        if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)) {\n+            authenticationmessagehandler.settoken(localConfig.accessToken);\n+            sendMessage(YioRemoteMessages.AUTHENTICATE_MESSAGE, localConfig.accessToken);\n+            yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+        } else if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+            if (getbooleanauthenticationok()) {\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE;\n+                updateStatus(ThingStatus.ONLINE);\n+                startwebsocketpollingthread();\n+                if (authenticationjob != null) {\n+                    authenticationjob.cancel(true);\n+                }\n+            } else {\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_FAILED;\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Connection lost no ping from YIO DOCK\");\n+            updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+        }\n+    }\n+\n+    private void startwebsocketpollingthread() {\n+        Runnable websocketpollingthread = new Runnable() {\n+            @Override\n+            public void run() {\n+                if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE)) {\n+                    if (getbooleanheartbeat()) {\n+                        updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL,\n+                                ircodereceivedhandler.getcode() + ircodereceivedhandler.getformat());\n+                        logger.debug(\"heartbeat ok\");\n+                        sendMessage(YioRemoteMessages.HEARTBEAT_MESSAGE, \"\");\n+                    } else {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Connection lost no ping from YIO DOCK\");\n+                        updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                        if (websocketpollingjob != null) {\n+                            websocketpollingjob.cancel(true);\n+                        }\n+                    }\n+                } else {\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                }\n+            }\n+        };\n+        websocketpollingjob = scheduler.scheduleWithFixedDelay(websocketpollingthread, 0, 30, TimeUnit.SECONDS);\n+    }\n+\n+    public boolean getbooleanauthenticationok() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849"}, "originalPosition": 341}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQyMTY1Ng==", "bodyText": "You could clarify in the method's name, that this isn't simply a getter.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public boolean getbooleanheartbeat() {\n          \n          \n            \n                public boolean getAndResetHeartbeat() {", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490421656", "createdAt": "2020-09-17T17:06:09Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioremotedockactualstatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String receivedmessage = \"\";\n+    private JsonObject recievedjson = new JsonObject();\n+    private boolean heartbeat = false;\n+    private boolean authenticationok = false;\n+    private String receivedstatus = \"\";\n+    private String lastsendircode = \"\";\n+    private IRCode ircodereceivedhandler = new IRCode();\n+    private IRCode ircodesendhandler = new IRCode();\n+    private IRCodeSendMessage ircodesendmessagehandler = new IRCodeSendMessage(ircodesendhandler);\n+    private AuthenticationMessage authenticationmessagehandler = new AuthenticationMessage();\n+    private IRReceiverMessage irreceivermessagehandler = new IRReceiverMessage();\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                websocketAddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed \" + e.getMessage());\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(boolean connectedflag) {\n+                    if (connectedflag) {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED;\n+                    } else {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    receivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    recievedjson = convertStringtoJsonObject(receivedmessage);\n+                    if (recievedjson.size() > 0) {\n+                        if (decodereceivedMessage(recievedjson)) {\n+                            triggerChannel(getChannelUuid(GROUP_OUTPUT, STATUS_STRING_CHANNEL));\n+                            updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL, receivedstatus);\n+                            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)\n+                                    || yioremotedockactualstatus\n+                                            .equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+                                authenticate();\n+                            }\n+                            logger.debug(\"Message {} decoded\", receivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\", receivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                webSocketClient.start();\n+\n+                webSocketClient.connect(yioremoteDockwebSocketClient, websocketAddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject message) {\n+        boolean success = false;\n+\n+        if (message.has(\"type\")) {\n+            if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication required\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                authenticationok = true;\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication ok\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\") && message.has(\"message\"))\n+\n+            {\n+                if (message.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (message.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        receivedstatus = \"Send IR Code successfully\";\n+                        heartbeat = true;\n+                        success = true;\n+                    } else {\n+                        if (lastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            receivedstatus = \"Send IR Code failure\";\n+                        }\n+                        heartbeat = true;\n+                        success = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", receivedmessage);\n+                    heartbeat = false;\n+                    success = false;\n+                }\n+            } else if (message.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                receivedstatus = message.get(\"code\").toString().replace(\"\\\"\", \"\");\n+                if (receivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    ircodereceivedhandler.setcode(message.get(\"code\").toString().replace(\"\\\"\", \"\"));\n+                } else {\n+                    ircodereceivedhandler.setcode(\"\");\n+                }\n+                logger.debug(\"ir_receive message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = true;\n+                success = true;\n+            } else {\n+                logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = false;\n+                success = false;\n+            }\n+        } else {\n+            logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+            heartbeat = false;\n+            success = false;\n+        }\n+        return success;\n+    }\n+\n+    private JsonObject convertStringtoJsonObject(String jsonString) {\n+        try {\n+            JsonParser parser = new JsonParser();\n+            JsonElement jsonElement = parser.parse(jsonString);\n+            JsonObject result;\n+\n+            if (jsonElement instanceof JsonObject) {\n+                result = jsonElement.getAsJsonObject();\n+            } else {\n+                logger.debug(\"{} is not valid JSON stirng\", jsonString);\n+                result = new JsonObject();\n+                throw new IllegalArgumentException(jsonString + \"{} is not valid JSON stirng\");\n+            }\n+            return result;\n+        } catch (IllegalArgumentException e) {\n+            JsonObject result = new JsonObject();\n+            return result;\n+        }\n+    }\n+\n+    public void updateState(String group, String channelId, State value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, value);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(YIOremoteDockActions.class);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (authenticationjob != null) {\n+            authenticationjob.cancel(true);\n+        }\n+        if (websocketpollingjob != null) {\n+            websocketpollingjob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (RECEIVER_SWITCH_CHANNEL.equals(channelUID.getIdWithoutGroup())) {\n+            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE)) {\n+                if (command.toString().equals(\"ON\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    sendMessage(YioRemoteMessages.IR_RECEIVER_ON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    sendMessage(YioRemoteMessages.IR_RECEIVER_OFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void sendircode(@Nullable String ircode) {\n+        if (ircode != null) {\n+            if (ircode.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                sendMessage(YioRemoteMessages.IR_SEND, ircode);\n+            } else {\n+                logger.warn(\"Wrong ir code format {}\", ircode);\n+            }\n+        }\n+    }\n+\n+    private ChannelUID getChannelUuid(String group, String typeId) {\n+        return new ChannelUID(getThing().getUID(), group, typeId);\n+    }\n+\n+    private void updateChannelString(String group, String channelId, String value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, new StringType(value));\n+    }\n+\n+    private void authenticate() {\n+        if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)) {\n+            authenticationmessagehandler.settoken(localConfig.accessToken);\n+            sendMessage(YioRemoteMessages.AUTHENTICATE_MESSAGE, localConfig.accessToken);\n+            yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+        } else if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+            if (getbooleanauthenticationok()) {\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE;\n+                updateStatus(ThingStatus.ONLINE);\n+                startwebsocketpollingthread();\n+                if (authenticationjob != null) {\n+                    authenticationjob.cancel(true);\n+                }\n+            } else {\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_FAILED;\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Connection lost no ping from YIO DOCK\");\n+            updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+        }\n+    }\n+\n+    private void startwebsocketpollingthread() {\n+        Runnable websocketpollingthread = new Runnable() {\n+            @Override\n+            public void run() {\n+                if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE)) {\n+                    if (getbooleanheartbeat()) {\n+                        updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL,\n+                                ircodereceivedhandler.getcode() + ircodereceivedhandler.getformat());\n+                        logger.debug(\"heartbeat ok\");\n+                        sendMessage(YioRemoteMessages.HEARTBEAT_MESSAGE, \"\");\n+                    } else {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Connection lost no ping from YIO DOCK\");\n+                        updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                        if (websocketpollingjob != null) {\n+                            websocketpollingjob.cancel(true);\n+                        }\n+                    }\n+                } else {\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                }\n+            }\n+        };\n+        websocketpollingjob = scheduler.scheduleWithFixedDelay(websocketpollingthread, 0, 30, TimeUnit.SECONDS);\n+    }\n+\n+    public boolean getbooleanauthenticationok() {\n+        return authenticationok;\n+    }\n+\n+    public boolean getbooleanheartbeat() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849"}, "originalPosition": 345}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQyMTkxMA==", "bodyText": "Same question as above.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490421910", "createdAt": "2020-09-17T17:06:36Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioremotedockactualstatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String receivedmessage = \"\";\n+    private JsonObject recievedjson = new JsonObject();\n+    private boolean heartbeat = false;\n+    private boolean authenticationok = false;\n+    private String receivedstatus = \"\";\n+    private String lastsendircode = \"\";\n+    private IRCode ircodereceivedhandler = new IRCode();\n+    private IRCode ircodesendhandler = new IRCode();\n+    private IRCodeSendMessage ircodesendmessagehandler = new IRCodeSendMessage(ircodesendhandler);\n+    private AuthenticationMessage authenticationmessagehandler = new AuthenticationMessage();\n+    private IRReceiverMessage irreceivermessagehandler = new IRReceiverMessage();\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                websocketAddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed \" + e.getMessage());\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(boolean connectedflag) {\n+                    if (connectedflag) {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED;\n+                    } else {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    receivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    recievedjson = convertStringtoJsonObject(receivedmessage);\n+                    if (recievedjson.size() > 0) {\n+                        if (decodereceivedMessage(recievedjson)) {\n+                            triggerChannel(getChannelUuid(GROUP_OUTPUT, STATUS_STRING_CHANNEL));\n+                            updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL, receivedstatus);\n+                            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)\n+                                    || yioremotedockactualstatus\n+                                            .equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+                                authenticate();\n+                            }\n+                            logger.debug(\"Message {} decoded\", receivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\", receivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                webSocketClient.start();\n+\n+                webSocketClient.connect(yioremoteDockwebSocketClient, websocketAddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject message) {\n+        boolean success = false;\n+\n+        if (message.has(\"type\")) {\n+            if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication required\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                authenticationok = true;\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication ok\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\") && message.has(\"message\"))\n+\n+            {\n+                if (message.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (message.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        receivedstatus = \"Send IR Code successfully\";\n+                        heartbeat = true;\n+                        success = true;\n+                    } else {\n+                        if (lastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            receivedstatus = \"Send IR Code failure\";\n+                        }\n+                        heartbeat = true;\n+                        success = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", receivedmessage);\n+                    heartbeat = false;\n+                    success = false;\n+                }\n+            } else if (message.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                receivedstatus = message.get(\"code\").toString().replace(\"\\\"\", \"\");\n+                if (receivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    ircodereceivedhandler.setcode(message.get(\"code\").toString().replace(\"\\\"\", \"\"));\n+                } else {\n+                    ircodereceivedhandler.setcode(\"\");\n+                }\n+                logger.debug(\"ir_receive message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = true;\n+                success = true;\n+            } else {\n+                logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = false;\n+                success = false;\n+            }\n+        } else {\n+            logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+            heartbeat = false;\n+            success = false;\n+        }\n+        return success;\n+    }\n+\n+    private JsonObject convertStringtoJsonObject(String jsonString) {\n+        try {\n+            JsonParser parser = new JsonParser();\n+            JsonElement jsonElement = parser.parse(jsonString);\n+            JsonObject result;\n+\n+            if (jsonElement instanceof JsonObject) {\n+                result = jsonElement.getAsJsonObject();\n+            } else {\n+                logger.debug(\"{} is not valid JSON stirng\", jsonString);\n+                result = new JsonObject();\n+                throw new IllegalArgumentException(jsonString + \"{} is not valid JSON stirng\");\n+            }\n+            return result;\n+        } catch (IllegalArgumentException e) {\n+            JsonObject result = new JsonObject();\n+            return result;\n+        }\n+    }\n+\n+    public void updateState(String group, String channelId, State value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, value);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(YIOremoteDockActions.class);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (authenticationjob != null) {\n+            authenticationjob.cancel(true);\n+        }\n+        if (websocketpollingjob != null) {\n+            websocketpollingjob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (RECEIVER_SWITCH_CHANNEL.equals(channelUID.getIdWithoutGroup())) {\n+            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE)) {\n+                if (command.toString().equals(\"ON\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    sendMessage(YioRemoteMessages.IR_RECEIVER_ON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    sendMessage(YioRemoteMessages.IR_RECEIVER_OFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void sendircode(@Nullable String ircode) {\n+        if (ircode != null) {\n+            if (ircode.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                sendMessage(YioRemoteMessages.IR_SEND, ircode);\n+            } else {\n+                logger.warn(\"Wrong ir code format {}\", ircode);\n+            }\n+        }\n+    }\n+\n+    private ChannelUID getChannelUuid(String group, String typeId) {\n+        return new ChannelUID(getThing().getUID(), group, typeId);\n+    }\n+\n+    private void updateChannelString(String group, String channelId, String value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, new StringType(value));\n+    }\n+\n+    private void authenticate() {\n+        if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)) {\n+            authenticationmessagehandler.settoken(localConfig.accessToken);\n+            sendMessage(YioRemoteMessages.AUTHENTICATE_MESSAGE, localConfig.accessToken);\n+            yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+        } else if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+            if (getbooleanauthenticationok()) {\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE;\n+                updateStatus(ThingStatus.ONLINE);\n+                startwebsocketpollingthread();\n+                if (authenticationjob != null) {\n+                    authenticationjob.cancel(true);\n+                }\n+            } else {\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_FAILED;\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Connection lost no ping from YIO DOCK\");\n+            updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+        }\n+    }\n+\n+    private void startwebsocketpollingthread() {\n+        Runnable websocketpollingthread = new Runnable() {\n+            @Override\n+            public void run() {\n+                if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE)) {\n+                    if (getbooleanheartbeat()) {\n+                        updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL,\n+                                ircodereceivedhandler.getcode() + ircodereceivedhandler.getformat());\n+                        logger.debug(\"heartbeat ok\");\n+                        sendMessage(YioRemoteMessages.HEARTBEAT_MESSAGE, \"\");\n+                    } else {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Connection lost no ping from YIO DOCK\");\n+                        updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                        if (websocketpollingjob != null) {\n+                            websocketpollingjob.cancel(true);\n+                        }\n+                    }\n+                } else {\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                }\n+            }\n+        };\n+        websocketpollingjob = scheduler.scheduleWithFixedDelay(websocketpollingthread, 0, 30, TimeUnit.SECONDS);\n+    }\n+\n+    public boolean getbooleanauthenticationok() {\n+        return authenticationok;\n+    }\n+\n+    public boolean getbooleanheartbeat() {\n+        boolean result = heartbeat;\n+        heartbeat = false;\n+        return result;\n+    }\n+\n+    public YioRemoteDockHandleStatus getyioremotedockactualstatus() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849"}, "originalPosition": 351}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQyMjU5Nw==", "bodyText": "Better use a switch/case to check the enum fields. This way you get a compiler warning if you miss to handle any enum constant.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490422597", "createdAt": "2020-09-17T17:07:43Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioremotedockactualstatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String receivedmessage = \"\";\n+    private JsonObject recievedjson = new JsonObject();\n+    private boolean heartbeat = false;\n+    private boolean authenticationok = false;\n+    private String receivedstatus = \"\";\n+    private String lastsendircode = \"\";\n+    private IRCode ircodereceivedhandler = new IRCode();\n+    private IRCode ircodesendhandler = new IRCode();\n+    private IRCodeSendMessage ircodesendmessagehandler = new IRCodeSendMessage(ircodesendhandler);\n+    private AuthenticationMessage authenticationmessagehandler = new AuthenticationMessage();\n+    private IRReceiverMessage irreceivermessagehandler = new IRReceiverMessage();\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                websocketAddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed \" + e.getMessage());\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(boolean connectedflag) {\n+                    if (connectedflag) {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED;\n+                    } else {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    receivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    recievedjson = convertStringtoJsonObject(receivedmessage);\n+                    if (recievedjson.size() > 0) {\n+                        if (decodereceivedMessage(recievedjson)) {\n+                            triggerChannel(getChannelUuid(GROUP_OUTPUT, STATUS_STRING_CHANNEL));\n+                            updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL, receivedstatus);\n+                            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)\n+                                    || yioremotedockactualstatus\n+                                            .equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+                                authenticate();\n+                            }\n+                            logger.debug(\"Message {} decoded\", receivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\", receivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                webSocketClient.start();\n+\n+                webSocketClient.connect(yioremoteDockwebSocketClient, websocketAddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject message) {\n+        boolean success = false;\n+\n+        if (message.has(\"type\")) {\n+            if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication required\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                authenticationok = true;\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication ok\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\") && message.has(\"message\"))\n+\n+            {\n+                if (message.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (message.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        receivedstatus = \"Send IR Code successfully\";\n+                        heartbeat = true;\n+                        success = true;\n+                    } else {\n+                        if (lastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            receivedstatus = \"Send IR Code failure\";\n+                        }\n+                        heartbeat = true;\n+                        success = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", receivedmessage);\n+                    heartbeat = false;\n+                    success = false;\n+                }\n+            } else if (message.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                receivedstatus = message.get(\"code\").toString().replace(\"\\\"\", \"\");\n+                if (receivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    ircodereceivedhandler.setcode(message.get(\"code\").toString().replace(\"\\\"\", \"\"));\n+                } else {\n+                    ircodereceivedhandler.setcode(\"\");\n+                }\n+                logger.debug(\"ir_receive message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = true;\n+                success = true;\n+            } else {\n+                logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = false;\n+                success = false;\n+            }\n+        } else {\n+            logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+            heartbeat = false;\n+            success = false;\n+        }\n+        return success;\n+    }\n+\n+    private JsonObject convertStringtoJsonObject(String jsonString) {\n+        try {\n+            JsonParser parser = new JsonParser();\n+            JsonElement jsonElement = parser.parse(jsonString);\n+            JsonObject result;\n+\n+            if (jsonElement instanceof JsonObject) {\n+                result = jsonElement.getAsJsonObject();\n+            } else {\n+                logger.debug(\"{} is not valid JSON stirng\", jsonString);\n+                result = new JsonObject();\n+                throw new IllegalArgumentException(jsonString + \"{} is not valid JSON stirng\");\n+            }\n+            return result;\n+        } catch (IllegalArgumentException e) {\n+            JsonObject result = new JsonObject();\n+            return result;\n+        }\n+    }\n+\n+    public void updateState(String group, String channelId, State value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, value);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(YIOremoteDockActions.class);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (authenticationjob != null) {\n+            authenticationjob.cancel(true);\n+        }\n+        if (websocketpollingjob != null) {\n+            websocketpollingjob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (RECEIVER_SWITCH_CHANNEL.equals(channelUID.getIdWithoutGroup())) {\n+            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE)) {\n+                if (command.toString().equals(\"ON\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    sendMessage(YioRemoteMessages.IR_RECEIVER_ON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    sendMessage(YioRemoteMessages.IR_RECEIVER_OFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void sendircode(@Nullable String ircode) {\n+        if (ircode != null) {\n+            if (ircode.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                sendMessage(YioRemoteMessages.IR_SEND, ircode);\n+            } else {\n+                logger.warn(\"Wrong ir code format {}\", ircode);\n+            }\n+        }\n+    }\n+\n+    private ChannelUID getChannelUuid(String group, String typeId) {\n+        return new ChannelUID(getThing().getUID(), group, typeId);\n+    }\n+\n+    private void updateChannelString(String group, String channelId, String value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, new StringType(value));\n+    }\n+\n+    private void authenticate() {\n+        if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)) {\n+            authenticationmessagehandler.settoken(localConfig.accessToken);\n+            sendMessage(YioRemoteMessages.AUTHENTICATE_MESSAGE, localConfig.accessToken);\n+            yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+        } else if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+            if (getbooleanauthenticationok()) {\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE;\n+                updateStatus(ThingStatus.ONLINE);\n+                startwebsocketpollingthread();\n+                if (authenticationjob != null) {\n+                    authenticationjob.cancel(true);\n+                }\n+            } else {\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_FAILED;\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Connection lost no ping from YIO DOCK\");\n+            updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+        }\n+    }\n+\n+    private void startwebsocketpollingthread() {\n+        Runnable websocketpollingthread = new Runnable() {\n+            @Override\n+            public void run() {\n+                if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE)) {\n+                    if (getbooleanheartbeat()) {\n+                        updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL,\n+                                ircodereceivedhandler.getcode() + ircodereceivedhandler.getformat());\n+                        logger.debug(\"heartbeat ok\");\n+                        sendMessage(YioRemoteMessages.HEARTBEAT_MESSAGE, \"\");\n+                    } else {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Connection lost no ping from YIO DOCK\");\n+                        updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                        if (websocketpollingjob != null) {\n+                            websocketpollingjob.cancel(true);\n+                        }\n+                    }\n+                } else {\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                }\n+            }\n+        };\n+        websocketpollingjob = scheduler.scheduleWithFixedDelay(websocketpollingthread, 0, 30, TimeUnit.SECONDS);\n+    }\n+\n+    public boolean getbooleanauthenticationok() {\n+        return authenticationok;\n+    }\n+\n+    public boolean getbooleanheartbeat() {\n+        boolean result = heartbeat;\n+        heartbeat = false;\n+        return result;\n+    }\n+\n+    public YioRemoteDockHandleStatus getyioremotedockactualstatus() {\n+        return yioremotedockactualstatus;\n+    }\n+\n+    public void sendMessage(YioRemoteMessages messagetype, String messagepyload) {\n+        if (messagetype.equals(YioRemoteMessages.AUTHENTICATE_MESSAGE)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849"}, "originalPosition": 356}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQyMjc5MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void sendMessage(YioRemoteMessages messagetype, String messagepyload) {\n          \n          \n            \n                public void sendMessage(YioRemoteMessages messageType, String messagePayload) {", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490422791", "createdAt": "2020-09-17T17:08:04Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioremotedockactualstatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String receivedmessage = \"\";\n+    private JsonObject recievedjson = new JsonObject();\n+    private boolean heartbeat = false;\n+    private boolean authenticationok = false;\n+    private String receivedstatus = \"\";\n+    private String lastsendircode = \"\";\n+    private IRCode ircodereceivedhandler = new IRCode();\n+    private IRCode ircodesendhandler = new IRCode();\n+    private IRCodeSendMessage ircodesendmessagehandler = new IRCodeSendMessage(ircodesendhandler);\n+    private AuthenticationMessage authenticationmessagehandler = new AuthenticationMessage();\n+    private IRReceiverMessage irreceivermessagehandler = new IRReceiverMessage();\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                websocketAddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed \" + e.getMessage());\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(boolean connectedflag) {\n+                    if (connectedflag) {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED;\n+                    } else {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    receivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    recievedjson = convertStringtoJsonObject(receivedmessage);\n+                    if (recievedjson.size() > 0) {\n+                        if (decodereceivedMessage(recievedjson)) {\n+                            triggerChannel(getChannelUuid(GROUP_OUTPUT, STATUS_STRING_CHANNEL));\n+                            updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL, receivedstatus);\n+                            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)\n+                                    || yioremotedockactualstatus\n+                                            .equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+                                authenticate();\n+                            }\n+                            logger.debug(\"Message {} decoded\", receivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\", receivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                webSocketClient.start();\n+\n+                webSocketClient.connect(yioremoteDockwebSocketClient, websocketAddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject message) {\n+        boolean success = false;\n+\n+        if (message.has(\"type\")) {\n+            if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication required\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                authenticationok = true;\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication ok\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\") && message.has(\"message\"))\n+\n+            {\n+                if (message.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (message.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        receivedstatus = \"Send IR Code successfully\";\n+                        heartbeat = true;\n+                        success = true;\n+                    } else {\n+                        if (lastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            receivedstatus = \"Send IR Code failure\";\n+                        }\n+                        heartbeat = true;\n+                        success = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", receivedmessage);\n+                    heartbeat = false;\n+                    success = false;\n+                }\n+            } else if (message.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                receivedstatus = message.get(\"code\").toString().replace(\"\\\"\", \"\");\n+                if (receivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    ircodereceivedhandler.setcode(message.get(\"code\").toString().replace(\"\\\"\", \"\"));\n+                } else {\n+                    ircodereceivedhandler.setcode(\"\");\n+                }\n+                logger.debug(\"ir_receive message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = true;\n+                success = true;\n+            } else {\n+                logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = false;\n+                success = false;\n+            }\n+        } else {\n+            logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+            heartbeat = false;\n+            success = false;\n+        }\n+        return success;\n+    }\n+\n+    private JsonObject convertStringtoJsonObject(String jsonString) {\n+        try {\n+            JsonParser parser = new JsonParser();\n+            JsonElement jsonElement = parser.parse(jsonString);\n+            JsonObject result;\n+\n+            if (jsonElement instanceof JsonObject) {\n+                result = jsonElement.getAsJsonObject();\n+            } else {\n+                logger.debug(\"{} is not valid JSON stirng\", jsonString);\n+                result = new JsonObject();\n+                throw new IllegalArgumentException(jsonString + \"{} is not valid JSON stirng\");\n+            }\n+            return result;\n+        } catch (IllegalArgumentException e) {\n+            JsonObject result = new JsonObject();\n+            return result;\n+        }\n+    }\n+\n+    public void updateState(String group, String channelId, State value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, value);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(YIOremoteDockActions.class);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (authenticationjob != null) {\n+            authenticationjob.cancel(true);\n+        }\n+        if (websocketpollingjob != null) {\n+            websocketpollingjob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (RECEIVER_SWITCH_CHANNEL.equals(channelUID.getIdWithoutGroup())) {\n+            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE)) {\n+                if (command.toString().equals(\"ON\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    sendMessage(YioRemoteMessages.IR_RECEIVER_ON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    sendMessage(YioRemoteMessages.IR_RECEIVER_OFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void sendircode(@Nullable String ircode) {\n+        if (ircode != null) {\n+            if (ircode.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                sendMessage(YioRemoteMessages.IR_SEND, ircode);\n+            } else {\n+                logger.warn(\"Wrong ir code format {}\", ircode);\n+            }\n+        }\n+    }\n+\n+    private ChannelUID getChannelUuid(String group, String typeId) {\n+        return new ChannelUID(getThing().getUID(), group, typeId);\n+    }\n+\n+    private void updateChannelString(String group, String channelId, String value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, new StringType(value));\n+    }\n+\n+    private void authenticate() {\n+        if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)) {\n+            authenticationmessagehandler.settoken(localConfig.accessToken);\n+            sendMessage(YioRemoteMessages.AUTHENTICATE_MESSAGE, localConfig.accessToken);\n+            yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+        } else if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+            if (getbooleanauthenticationok()) {\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE;\n+                updateStatus(ThingStatus.ONLINE);\n+                startwebsocketpollingthread();\n+                if (authenticationjob != null) {\n+                    authenticationjob.cancel(true);\n+                }\n+            } else {\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_FAILED;\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Connection lost no ping from YIO DOCK\");\n+            updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+        }\n+    }\n+\n+    private void startwebsocketpollingthread() {\n+        Runnable websocketpollingthread = new Runnable() {\n+            @Override\n+            public void run() {\n+                if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE)) {\n+                    if (getbooleanheartbeat()) {\n+                        updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL,\n+                                ircodereceivedhandler.getcode() + ircodereceivedhandler.getformat());\n+                        logger.debug(\"heartbeat ok\");\n+                        sendMessage(YioRemoteMessages.HEARTBEAT_MESSAGE, \"\");\n+                    } else {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                                \"Connection lost no ping from YIO DOCK\");\n+                        updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                        if (websocketpollingjob != null) {\n+                            websocketpollingjob.cancel(true);\n+                        }\n+                    }\n+                } else {\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                }\n+            }\n+        };\n+        websocketpollingjob = scheduler.scheduleWithFixedDelay(websocketpollingthread, 0, 30, TimeUnit.SECONDS);\n+    }\n+\n+    public boolean getbooleanauthenticationok() {\n+        return authenticationok;\n+    }\n+\n+    public boolean getbooleanheartbeat() {\n+        boolean result = heartbeat;\n+        heartbeat = false;\n+        return result;\n+    }\n+\n+    public YioRemoteDockHandleStatus getyioremotedockactualstatus() {\n+        return yioremotedockactualstatus;\n+    }\n+\n+    public void sendMessage(YioRemoteMessages messagetype, String messagepyload) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849"}, "originalPosition": 355}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQyMjg4MA==", "bodyText": "Suggested change", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490422880", "createdAt": "2020-09-17T17:08:17Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockWebsocket.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import java.io.IOException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.api.Session;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketConnect;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketError;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketMessage;\n+import org.eclipse.jetty.websocket.api.annotations.WebSocket;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockWebsocket} is responsible for the Websocket Connection to the YIO Remote Dock\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+@WebSocket\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQyNDgyOQ==", "bodyText": "Is this class really necessary? It would reduce the complexity of the binding if you don't use this wrapper class but access the web socket directly with an inner class in the handler. Like you do it with this wrapper class now.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490424829", "createdAt": "2020-09-17T17:11:39Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockWebsocket.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import java.io.IOException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.api.Session;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketConnect;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketError;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketMessage;\n+import org.eclipse.jetty.websocket.api.annotations.WebSocket;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockWebsocket} is responsible for the Websocket Connection to the YIO Remote Dock\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+@WebSocket\n+\n+public class YIOremoteDockWebsocket {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQyNTUwMw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t<parameter name=\"accesstoken\" type=\"text\" required=\"true\">\n          \n          \n            \n            \t\t\t<parameter name=\"accessToken\" type=\"text\" required=\"true\">", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490425503", "createdAt": "2020-09-17T17:12:50Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,55 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"yioremote\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"yioRemoteDock\">\n+\t\t<label>YIO Remote Dock</label>\n+\t\t<description>YIOremote Dock Binding Thing</description>\n+\t\t<channel-groups>\n+\t\t\t<channel-group id=\"input\" typeId=\"input\"/>\n+\t\t\t<channel-group id=\"output\" typeId=\"output\"/>\n+\t\t</channel-groups>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"host\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Network address of the YIO Remote Dock</label>\n+\t\t\t\t<description>Network address of the YIO Remote Dock</description>\n+\t\t\t\t<context>network-address</context>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"accesstoken\" type=\"text\" required=\"true\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQyNTcxNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t<label>Access token of the YIO Remote Dock</label>\n          \n          \n            \n            \t\t\t\t<label>Access Token</label>", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490425717", "createdAt": "2020-09-17T17:13:13Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,55 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"yioremote\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"yioRemoteDock\">\n+\t\t<label>YIO Remote Dock</label>\n+\t\t<description>YIOremote Dock Binding Thing</description>\n+\t\t<channel-groups>\n+\t\t\t<channel-group id=\"input\" typeId=\"input\"/>\n+\t\t\t<channel-group id=\"output\" typeId=\"output\"/>\n+\t\t</channel-groups>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"host\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Network address of the YIO Remote Dock</label>\n+\t\t\t\t<description>Network address of the YIO Remote Dock</description>\n+\t\t\t\t<context>network-address</context>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"accesstoken\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Access token of the YIO Remote Dock</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQyNjEzMg==", "bodyText": "Labels should be all upper case. The binding name could be removed, as it is redundant.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t<label>Network address of the YIO Remote Dock</label>\n          \n          \n            \n            \t\t\t\t<label>Network Address</label>", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490426132", "createdAt": "2020-09-17T17:13:58Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,55 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"yioremote\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"yioRemoteDock\">\n+\t\t<label>YIO Remote Dock</label>\n+\t\t<description>YIOremote Dock Binding Thing</description>\n+\t\t<channel-groups>\n+\t\t\t<channel-group id=\"input\" typeId=\"input\"/>\n+\t\t\t<channel-group id=\"output\" typeId=\"output\"/>\n+\t\t</channel-groups>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"host\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Network address of the YIO Remote Dock</label>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQyNjg0Mw==", "bodyText": "Did you push your changes? I still see the empty lines.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490426843", "createdAt": "2020-09-17T17:15:07Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,55 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"yioremote\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<thing-type id=\"yioremotedock\">\n+\t\t<label>YIOremote Dock Binding Thing</label>\n+\t\t<description>YIOremote Dock Binding Thing</description>\n+\t\t<channel-groups>\n+\t\t\t<channel-group id=\"input\" typeId=\"input\"/>\n+\t\t\t<channel-group id=\"output\" typeId=\"output\"/>\n+\t\t</channel-groups>\n+\t\t<config-description>\n+\t\t\t<parameter name=\"host\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Network address of the YIO Remote Dock</label>\n+\t\t\t\t<description>Network address of the YIO Remote Dock</description>\n+\t\t\t\t<context>network-address</context>\n+\t\t\t</parameter>\n+\t\t\t<parameter name=\"accesstoken\" type=\"text\" required=\"true\">\n+\t\t\t\t<label>Access token of the YIO Remote Dock</label>\n+\t\t\t\t<description>The authentication token for the access currently 0</description>\n+\t\t\t\t<default>0</default>\n+\t\t\t</parameter>\n+\t\t</config-description>\n+\t</thing-type>\n+\t<channel-group-type id=\"input\">\n+\t\t<label>Inputs</label>\n+\t\t<description>The channels used for Input</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"receiverswitch\" typeId=\"receiverswitch\"/>\n+\t\t</channels>\n+\t</channel-group-type>\n+\t<channel-group-type id=\"output\">\n+\t\t<label>Outputs</label>\n+\t\t<description>The channels used for Output</description>\n+\t\t<channels>\n+\t\t\t<channel id=\"status\" typeId=\"status\"/>\n+\t\t</channels>\n+\t</channel-group-type>\n+\t<channel-type id=\"receiverswitch\">\n+\t\t<item-type>Switch</item-type>\n+\t\t<label>YIO Remote Dock receiverswitch</label>\n+\t\t<description>The switch to enable disable the IR receiving diode/function</description>\n+\t</channel-type>\n+\t<channel-type id=\"status\">\n+\t\t<item-type>String</item-type>\n+\t\t<label>YIO Remote Dock status</label>\n+\t\t<description>The status of the YIO Dock. If the reciever is on than the recognized IR code will be displayed otherwise\n+\t\t\tthe IR send status is displayed of the last IR code send.</description>\n+\n+\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI1MDM1Ng=="}, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 53}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkwODY2Nzc5", "url": "https://github.com/openhab/openhab-addons/pull/8394#pullrequestreview-490866779", "createdAt": "2020-09-17T18:16:21Z", "commit": {"oid": "37458bc3cdd9883a88d8544b66acd7c91a4211c3"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxODoxNjoyMlrOHTvdkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xN1QxODoyNzozOVrOHTv2Ww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2MjYwOA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public JsonObject getauthenticationMessageJsonObject() {\n          \n          \n            \n                public JsonObject getAuthenticationMessageJsonObject() {", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490462608", "createdAt": "2020-09-17T18:16:22Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/AuthenticationMessage.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+import com.google.gson.JsonObject;\n+\n+/**\n+ * The {@link AuthenticationMessage} the AuthenticationMessage DTO\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AuthenticationMessage {\n+    private String type = \"auth\";\n+    private String token = \"0\";\n+\n+    public String getType() {\n+        return type;\n+    }\n+\n+    public String getToken() {\n+        return token;\n+    }\n+\n+    public void setToken(String token) {\n+        this.token = token;\n+    }\n+\n+    public JsonObject getauthenticationMessageJsonObject() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37458bc3cdd9883a88d8544b66acd7c91a4211c3"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2Mjc1MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public String getauthenticationMessageString() {\n          \n          \n            \n                public String getAuthenticationMessageString() {", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490462750", "createdAt": "2020-09-17T18:16:37Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/AuthenticationMessage.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+import com.google.gson.JsonObject;\n+\n+/**\n+ * The {@link AuthenticationMessage} the AuthenticationMessage DTO\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class AuthenticationMessage {\n+    private String type = \"auth\";\n+    private String token = \"0\";\n+\n+    public String getType() {\n+        return type;\n+    }\n+\n+    public String getToken() {\n+        return token;\n+    }\n+\n+    public void setToken(String token) {\n+        this.token = token;\n+    }\n+\n+    public JsonObject getauthenticationMessageJsonObject() {\n+        JsonObject authenticationMessage = new JsonObject();\n+        authenticationMessage.addProperty(\"type\", type);\n+        authenticationMessage.addProperty(\"token\", token);\n+        return authenticationMessage;\n+    }\n+\n+    public String getauthenticationMessageString() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37458bc3cdd9883a88d8544b66acd7c91a4211c3"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2MzAwNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public JsonObject getIRcodesendMessageJsonObject() {\n          \n          \n            \n                public JsonObject getIRcodeSendMessageJsonObject() {", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490463005", "createdAt": "2020-09-17T18:17:03Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/IRCodeSendMessage.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+import com.google.gson.JsonObject;\n+\n+/**\n+ * The {@link IRCodeSendMessage} the IRCodeSendMessage DTO\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class IRCodeSendMessage {\n+    private String type = \"dock\";\n+    private String command = \"ir_send\";\n+\n+    private IRCode ircode = new IRCode();\n+\n+    public IRCodeSendMessage(IRCode ircode) {\n+        this.ircode = ircode;\n+    }\n+\n+    public String getType() {\n+        return type;\n+    }\n+\n+    public String getCommand() {\n+        return command;\n+    }\n+\n+    public JsonObject getIRcodesendMessageJsonObject() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37458bc3cdd9883a88d8544b66acd7c91a4211c3"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2MzEwOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    JsonObject ircodesendmessage = new JsonObject();\n          \n          \n            \n                    JsonObject irCodeSendMessage = new JsonObject();", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490463109", "createdAt": "2020-09-17T18:17:14Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/IRCodeSendMessage.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+import com.google.gson.JsonObject;\n+\n+/**\n+ * The {@link IRCodeSendMessage} the IRCodeSendMessage DTO\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class IRCodeSendMessage {\n+    private String type = \"dock\";\n+    private String command = \"ir_send\";\n+\n+    private IRCode ircode = new IRCode();\n+\n+    public IRCodeSendMessage(IRCode ircode) {\n+        this.ircode = ircode;\n+    }\n+\n+    public String getType() {\n+        return type;\n+    }\n+\n+    public String getCommand() {\n+        return command;\n+    }\n+\n+    public JsonObject getIRcodesendMessageJsonObject() {\n+        JsonObject ircodesendmessage = new JsonObject();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37458bc3cdd9883a88d8544b66acd7c91a4211c3"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2MzI1NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    JsonObject ircodesendmessage = new JsonObject();\n          \n          \n            \n                    JsonObject irCodeSendMessage = new JsonObject();", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490463254", "createdAt": "2020-09-17T18:17:27Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/IRCodeSendMessage.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+import com.google.gson.JsonObject;\n+\n+/**\n+ * The {@link IRCodeSendMessage} the IRCodeSendMessage DTO\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class IRCodeSendMessage {\n+    private String type = \"dock\";\n+    private String command = \"ir_send\";\n+\n+    private IRCode ircode = new IRCode();\n+\n+    public IRCodeSendMessage(IRCode ircode) {\n+        this.ircode = ircode;\n+    }\n+\n+    public String getType() {\n+        return type;\n+    }\n+\n+    public String getCommand() {\n+        return command;\n+    }\n+\n+    public JsonObject getIRcodesendMessageJsonObject() {\n+        JsonObject ircodesendmessage = new JsonObject();\n+        ircodesendmessage.addProperty(\"type\", type);\n+        ircodesendmessage.addProperty(\"command\", command);\n+        ircodesendmessage.addProperty(\"code\", ircode.getCode());\n+        ircodesendmessage.addProperty(\"format\", ircode.getFormat());\n+        return ircodesendmessage;\n+    }\n+\n+    public String getIRcodesendMessageString() {\n+        JsonObject ircodesendmessage = new JsonObject();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37458bc3cdd9883a88d8544b66acd7c91a4211c3"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2MzQzNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    JsonObject irreceivermessage = new JsonObject();\n          \n          \n            \n                    JsonObject irReceiverMessage = new JsonObject();", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490463437", "createdAt": "2020-09-17T18:17:46Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/IRReceiverMessage.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+import com.google.gson.JsonObject;\n+\n+/**\n+ * The {@link IRReceiverMessage} the IRReceiverMessage DTO\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class IRReceiverMessage {\n+    private String type = \"dock\";\n+    private String command = \"ir_receive_off\";\n+\n+    public void setOn() {\n+        command = \"ir_receive_on\";\n+    }\n+\n+    public void setOff() {\n+        command = \"ir_receive_off\";\n+    }\n+\n+    public JsonObject getIRreceiverMessageJsonObject() {\n+        JsonObject irreceivermessage = new JsonObject();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37458bc3cdd9883a88d8544b66acd7c91a4211c3"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2MzU0MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    JsonObject irreceivermessage = new JsonObject();\n          \n          \n            \n                    JsonObject irReceiverMessage = new JsonObject();", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490463541", "createdAt": "2020-09-17T18:17:57Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/IRReceiverMessage.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+import com.google.gson.JsonObject;\n+\n+/**\n+ * The {@link IRReceiverMessage} the IRReceiverMessage DTO\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class IRReceiverMessage {\n+    private String type = \"dock\";\n+    private String command = \"ir_receive_off\";\n+\n+    public void setOn() {\n+        command = \"ir_receive_on\";\n+    }\n+\n+    public void setOff() {\n+        command = \"ir_receive_off\";\n+    }\n+\n+    public JsonObject getIRreceiverMessageJsonObject() {\n+        JsonObject irreceivermessage = new JsonObject();\n+        irreceivermessage.addProperty(\"type\", type);\n+        irreceivermessage.addProperty(\"command\", command);\n+        return irreceivermessage;\n+    }\n+\n+    public String getIRreceiverMessageString() {\n+        JsonObject irreceivermessage = new JsonObject();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37458bc3cdd9883a88d8544b66acd7c91a4211c3"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2Mzg3NQ==", "bodyText": "I still see all lower case", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490463875", "createdAt": "2020-09-17T18:18:35Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockActions.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.binding.ThingActions;\n+import org.eclipse.smarthome.core.thing.binding.ThingActionsScope;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+\n+/**\n+ * The {@link YIOremoteDockActions} is responsible for handling the action commands\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@ThingActionsScope(name = \"yioremote\")\n+@NonNullByDefault\n+public class YIOremoteDockActions implements ThingActions {\n+    private @Nullable static YIOremoteDockHandler yioremotedockhandler;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyMzY1Mw=="}, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2NDA5Ng==", "bodyText": "Can you comment on that?", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490464096", "createdAt": "2020-09-17T18:18:59Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockActions.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.binding.ThingActions;\n+import org.eclipse.smarthome.core.thing.binding.ThingActionsScope;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+\n+/**\n+ * The {@link YIOremoteDockActions} is responsible for handling the action commands\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@ThingActionsScope(name = \"yioremote\")\n+@NonNullByDefault\n+public class YIOremoteDockActions implements ThingActions {\n+    private @Nullable static YIOremoteDockHandler yioremotedockhandler;\n+\n+    @Override\n+    public void setThingHandler(@Nullable ThingHandler yiremotedockhandler) {\n+        yioremotedockhandler = (YIOremoteDockHandler) yiremotedockhandler;\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return yioremotedockhandler;\n+    }\n+\n+    @RuleAction(label = \"@text/actionLabel\", description = \"@text/actionDesc\")\n+    public void sendircode(\n+            @ActionInput(name = \"ircode\", label = \"@text/actionInputTopicLabel\", description = \"@text/actionInputTopicDesc\") @Nullable String ircode) {\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyMzUxNw=="}, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2NDQxNw==", "bodyText": "Please see all other fields.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private @Nullable Future<?> authenticationjob;\n          \n          \n            \n                private @Nullable Future<?> authenticationJob;", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490464417", "createdAt": "2020-09-17T18:19:33Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,380 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioRemoteDockActualStatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37458bc3cdd9883a88d8544b66acd7c91a4211c3"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2NTY3OQ==", "bodyText": "I overlooked that during the first reviews. Sorry for that. Please check all other Enum comparisons in all classes.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                        if (yioRemoteDockActualStatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)\n          \n          \n            \n                                                || yioRemoteDockActualStatus\n          \n          \n            \n                                                        .equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n          \n          \n            \n                                        if (yioremotedockactualstatus == YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED\n          \n          \n            \n                                                || yioremotedockactualstatus == YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS) {", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490465679", "createdAt": "2020-09-17T18:21:52Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,380 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioRemoteDockActualStatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String receivedmessage = \"\";\n+    private JsonObject recievedjson = new JsonObject();\n+    private boolean heartbeat = false;\n+    private boolean authenticationok = false;\n+    private String receivedstatus = \"\";\n+    private String lastsendircode = \"\";\n+    private IRCode ircodereceivedhandler = new IRCode();\n+    private IRCode ircodesendhandler = new IRCode();\n+    private IRCodeSendMessage ircodesendmessagehandler = new IRCodeSendMessage(ircodesendhandler);\n+    private AuthenticationMessage authenticationmessagehandler = new AuthenticationMessage();\n+    private IRReceiverMessage irreceivermessagehandler = new IRReceiverMessage();\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                websocketAddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioRemoteDockActualStatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Initialize web socket failed: \" + e.getMessage());\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(boolean connected) {\n+                    if (connected) {\n+                        yioRemoteDockActualStatus = YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED;\n+                    } else {\n+                        yioRemoteDockActualStatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    receivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    recievedjson = convertStringtoJsonObject(receivedmessage);\n+                    if (recievedjson.size() > 0) {\n+                        if (decodeReceivedMessage(recievedjson)) {\n+                            triggerChannel(getChannelUuid(GROUP_OUTPUT, STATUS_STRING_CHANNEL));\n+                            updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL, receivedstatus);\n+                            if (yioRemoteDockActualStatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)\n+                                    || yioRemoteDockActualStatus\n+                                            .equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37458bc3cdd9883a88d8544b66acd7c91a4211c3"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2NjIxMQ==", "bodyText": "Did you push your changes?", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490466211", "createdAt": "2020-09-17T18:22:53Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioremotedockactualstatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String receivedmessage = \"\";\n+    private JsonObject recievedjson = new JsonObject();\n+    private boolean heartbeat = false;\n+    private boolean authenticationok = false;\n+    private String receivedstatus = \"\";\n+    private String lastsendircode = \"\";\n+    private IRCode ircodereceivedhandler = new IRCode();\n+    private IRCode ircodesendhandler = new IRCode();\n+    private IRCodeSendMessage ircodesendmessagehandler = new IRCodeSendMessage(ircodesendhandler);\n+    private AuthenticationMessage authenticationmessagehandler = new AuthenticationMessage();\n+    private IRReceiverMessage irreceivermessagehandler = new IRReceiverMessage();\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                websocketAddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioremotedockactualstatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Initialize web socket failed \" + e.getMessage());\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(boolean connectedflag) {\n+                    if (connectedflag) {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED;\n+                    } else {\n+                        yioremotedockactualstatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    receivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    recievedjson = convertStringtoJsonObject(receivedmessage);\n+                    if (recievedjson.size() > 0) {\n+                        if (decodereceivedMessage(recievedjson)) {\n+                            triggerChannel(getChannelUuid(GROUP_OUTPUT, STATUS_STRING_CHANNEL));\n+                            updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL, receivedstatus);\n+                            if (yioremotedockactualstatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)\n+                                    || yioremotedockactualstatus\n+                                            .equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+                                authenticate();\n+                            }\n+                            logger.debug(\"Message {} decoded\", receivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\", receivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                webSocketClient.start();\n+\n+                webSocketClient.connect(yioremoteDockwebSocketClient, websocketAddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodereceivedMessage(JsonObject message) {\n+        boolean success = false;\n+\n+        if (message.has(\"type\")) {\n+            if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication required\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                authenticationok = true;\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication ok\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\") && message.has(\"message\"))\n+\n+            {\n+                if (message.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (message.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        receivedstatus = \"Send IR Code successfully\";\n+                        heartbeat = true;\n+                        success = true;\n+                    } else {\n+                        if (lastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            receivedstatus = \"Send IR Code failure\";\n+                        }\n+                        heartbeat = true;\n+                        success = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", receivedmessage);\n+                    heartbeat = false;\n+                    success = false;\n+                }\n+            } else if (message.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                receivedstatus = message.get(\"code\").toString().replace(\"\\\"\", \"\");\n+                if (receivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    ircodereceivedhandler.setcode(message.get(\"code\").toString().replace(\"\\\"\", \"\"));\n+                } else {\n+                    ircodereceivedhandler.setcode(\"\");\n+                }\n+                logger.debug(\"ir_receive message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = true;\n+                success = true;\n+            } else {\n+                logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+                heartbeat = false;\n+                success = false;\n+            }\n+        } else {\n+            logger.warn(\"No known message {}\", ircodereceivedhandler.getcode());\n+            heartbeat = false;\n+            success = false;\n+        }\n+        return success;\n+    }\n+\n+    private JsonObject convertStringtoJsonObject(String jsonString) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQxMDY0OQ=="}, "originalCommit": {"oid": "02a0f6a97bb9ae12d7f783b3484e33817f5a5849"}, "originalPosition": 210}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2NjQ2MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            } else if (command.toString().equals(\"OFF\")) {\n          \n          \n            \n                            } else if (command == OnOffType.OFF) {", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490466461", "createdAt": "2020-09-17T18:23:21Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,380 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioRemoteDockActualStatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String receivedmessage = \"\";\n+    private JsonObject recievedjson = new JsonObject();\n+    private boolean heartbeat = false;\n+    private boolean authenticationok = false;\n+    private String receivedstatus = \"\";\n+    private String lastsendircode = \"\";\n+    private IRCode ircodereceivedhandler = new IRCode();\n+    private IRCode ircodesendhandler = new IRCode();\n+    private IRCodeSendMessage ircodesendmessagehandler = new IRCodeSendMessage(ircodesendhandler);\n+    private AuthenticationMessage authenticationmessagehandler = new AuthenticationMessage();\n+    private IRReceiverMessage irreceivermessagehandler = new IRReceiverMessage();\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                websocketAddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioRemoteDockActualStatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Initialize web socket failed: \" + e.getMessage());\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(boolean connected) {\n+                    if (connected) {\n+                        yioRemoteDockActualStatus = YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED;\n+                    } else {\n+                        yioRemoteDockActualStatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    receivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    recievedjson = convertStringtoJsonObject(receivedmessage);\n+                    if (recievedjson.size() > 0) {\n+                        if (decodeReceivedMessage(recievedjson)) {\n+                            triggerChannel(getChannelUuid(GROUP_OUTPUT, STATUS_STRING_CHANNEL));\n+                            updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL, receivedstatus);\n+                            if (yioRemoteDockActualStatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)\n+                                    || yioRemoteDockActualStatus\n+                                            .equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+                                authenticate();\n+                            }\n+                            logger.debug(\"Message {} decoded\", receivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\", receivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                webSocketClient.start();\n+\n+                webSocketClient.connect(yioremoteDockwebSocketClient, websocketAddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodeReceivedMessage(JsonObject message) {\n+        boolean success = false;\n+\n+        if (message.has(\"type\")) {\n+            if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication required\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                authenticationok = true;\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication ok\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\") && message.has(\"message\")) {\n+                if (message.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (message.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        receivedstatus = \"Send IR Code successfully\";\n+                        heartbeat = true;\n+                        success = true;\n+                    } else {\n+                        if (lastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            receivedstatus = \"Send IR Code failure\";\n+                        }\n+                        heartbeat = true;\n+                        success = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", receivedmessage);\n+                    heartbeat = false;\n+                    success = false;\n+                }\n+            } else if (message.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                receivedstatus = message.get(\"code\").toString().replace(\"\\\"\", \"\");\n+                if (receivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    ircodereceivedhandler.setCode(message.get(\"code\").toString().replace(\"\\\"\", \"\"));\n+                } else {\n+                    ircodereceivedhandler.setCode(\"\");\n+                }\n+                logger.debug(\"ir_receive message {}\", ircodereceivedhandler.getCode());\n+                heartbeat = true;\n+                success = true;\n+            } else {\n+                logger.warn(\"No known message {}\", ircodereceivedhandler.getCode());\n+                heartbeat = false;\n+                success = false;\n+            }\n+        } else {\n+            logger.warn(\"No known message {}\", ircodereceivedhandler.getCode());\n+            heartbeat = false;\n+            success = false;\n+        }\n+        return success;\n+    }\n+\n+    private JsonObject convertStringtoJsonObject(String jsonString) {\n+        try {\n+            JsonParser parser = new JsonParser();\n+            JsonElement jsonElement = parser.parse(jsonString);\n+            JsonObject result;\n+\n+            if (jsonElement instanceof JsonObject) {\n+                result = jsonElement.getAsJsonObject();\n+            } else {\n+                logger.debug(\"{} is not valid JSON stirng\", jsonString);\n+                result = new JsonObject();\n+                throw new IllegalArgumentException(jsonString + \"{} is not valid JSON stirng\");\n+            }\n+            return result;\n+        } catch (IllegalArgumentException e) {\n+            JsonObject result = new JsonObject();\n+            return result;\n+        }\n+    }\n+\n+    public void updateState(String group, String channelId, State value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, value);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(YIOremoteDockActions.class);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (authenticationjob != null) {\n+            authenticationjob.cancel(true);\n+        }\n+        if (websocketpollingjob != null) {\n+            websocketpollingjob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (RECEIVER_SWITCH_CHANNEL.equals(channelUID.getIdWithoutGroup())) {\n+            if (yioRemoteDockActualStatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE)) {\n+                if (command == OnOffType.ON) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    sendMessage(YioRemoteMessages.IR_RECEIVER_ON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37458bc3cdd9883a88d8544b66acd7c91a4211c3"}, "originalPosition": 256}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2NzY5MQ==", "bodyText": "Can you access the field directly without using this method?", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490467691", "createdAt": "2020-09-17T18:25:27Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,380 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket yioremoteDockwebSocketClient = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioRemoteDockActualStatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> authenticationjob;\n+    private @Nullable Future<?> websocketpollingjob;\n+    public String receivedmessage = \"\";\n+    private JsonObject recievedjson = new JsonObject();\n+    private boolean heartbeat = false;\n+    private boolean authenticationok = false;\n+    private String receivedstatus = \"\";\n+    private String lastsendircode = \"\";\n+    private IRCode ircodereceivedhandler = new IRCode();\n+    private IRCode ircodesendhandler = new IRCode();\n+    private IRCodeSendMessage ircodesendmessagehandler = new IRCodeSendMessage(ircodesendhandler);\n+    private AuthenticationMessage authenticationmessagehandler = new AuthenticationMessage();\n+    private IRReceiverMessage irreceivermessagehandler = new IRReceiverMessage();\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                websocketAddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioRemoteDockActualStatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Initialize web socket failed: \" + e.getMessage());\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new YIOremoteDockWebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(boolean connected) {\n+                    if (connected) {\n+                        yioRemoteDockActualStatus = YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED;\n+                    } else {\n+                        yioRemoteDockActualStatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    receivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    recievedjson = convertStringtoJsonObject(receivedmessage);\n+                    if (recievedjson.size() > 0) {\n+                        if (decodeReceivedMessage(recievedjson)) {\n+                            triggerChannel(getChannelUuid(GROUP_OUTPUT, STATUS_STRING_CHANNEL));\n+                            updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL, receivedstatus);\n+                            if (yioRemoteDockActualStatus.equals(YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED)\n+                                    || yioRemoteDockActualStatus\n+                                            .equals(YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS)) {\n+                                authenticate();\n+                            }\n+                            logger.debug(\"Message {} decoded\", receivedmessage);\n+                        } else {\n+                            logger.debug(\"Error during message {} decoding\", receivedmessage);\n+                        }\n+                    }\n+                }\n+\n+                @Override\n+                public void onError() {\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                    if (websocketpollingjob != null) {\n+                        websocketpollingjob.cancel(true);\n+                    }\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                            \"Connection lost no ping from YIO DOCK\");\n+                    updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                }\n+            });\n+\n+            try {\n+                webSocketClient.start();\n+\n+                webSocketClient.connect(yioremoteDockwebSocketClient, websocketAddress,\n+                        yioremoteDockwebSocketClientrequest);\n+            } catch (Exception e) {\n+                logger.debug(\"Connection error {}\", e.getMessage());\n+            }\n+\n+        });\n+    }\n+\n+    private boolean decodeReceivedMessage(JsonObject message) {\n+        boolean success = false;\n+\n+        if (message.has(\"type\")) {\n+            if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_required\\\"\")) {\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication required\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"auth_ok\\\"\")) {\n+                authenticationok = true;\n+                heartbeat = true;\n+                success = true;\n+                receivedstatus = \"Authentication ok\";\n+            } else if (message.get(\"type\").toString().equalsIgnoreCase(\"\\\"dock\\\"\") && message.has(\"message\")) {\n+                if (message.get(\"message\").toString().equalsIgnoreCase(\"\\\"ir_send\\\"\")) {\n+                    if (message.get(\"success\").toString().equalsIgnoreCase(\"true\")) {\n+                        receivedstatus = \"Send IR Code successfully\";\n+                        heartbeat = true;\n+                        success = true;\n+                    } else {\n+                        if (lastsendircode.equalsIgnoreCase(\"\\\"0;0x0;0;0\\\"\")) {\n+                            logger.debug(\"Send heartbeat Code success\");\n+                        } else {\n+                            receivedstatus = \"Send IR Code failure\";\n+                        }\n+                        heartbeat = true;\n+                        success = true;\n+                    }\n+                } else {\n+                    logger.warn(\"No known message {}\", receivedmessage);\n+                    heartbeat = false;\n+                    success = false;\n+                }\n+            } else if (message.get(\"command\").toString().equalsIgnoreCase(\"\\\"ir_receive\\\"\")) {\n+                receivedstatus = message.get(\"code\").toString().replace(\"\\\"\", \"\");\n+                if (receivedstatus.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    ircodereceivedhandler.setCode(message.get(\"code\").toString().replace(\"\\\"\", \"\"));\n+                } else {\n+                    ircodereceivedhandler.setCode(\"\");\n+                }\n+                logger.debug(\"ir_receive message {}\", ircodereceivedhandler.getCode());\n+                heartbeat = true;\n+                success = true;\n+            } else {\n+                logger.warn(\"No known message {}\", ircodereceivedhandler.getCode());\n+                heartbeat = false;\n+                success = false;\n+            }\n+        } else {\n+            logger.warn(\"No known message {}\", ircodereceivedhandler.getCode());\n+            heartbeat = false;\n+            success = false;\n+        }\n+        return success;\n+    }\n+\n+    private JsonObject convertStringtoJsonObject(String jsonString) {\n+        try {\n+            JsonParser parser = new JsonParser();\n+            JsonElement jsonElement = parser.parse(jsonString);\n+            JsonObject result;\n+\n+            if (jsonElement instanceof JsonObject) {\n+                result = jsonElement.getAsJsonObject();\n+            } else {\n+                logger.debug(\"{} is not valid JSON stirng\", jsonString);\n+                result = new JsonObject();\n+                throw new IllegalArgumentException(jsonString + \"{} is not valid JSON stirng\");\n+            }\n+            return result;\n+        } catch (IllegalArgumentException e) {\n+            JsonObject result = new JsonObject();\n+            return result;\n+        }\n+    }\n+\n+    public void updateState(String group, String channelId, State value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, value);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(YIOremoteDockActions.class);\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (authenticationjob != null) {\n+            authenticationjob.cancel(true);\n+        }\n+        if (websocketpollingjob != null) {\n+            websocketpollingjob.cancel(true);\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (RECEIVER_SWITCH_CHANNEL.equals(channelUID.getIdWithoutGroup())) {\n+            if (yioRemoteDockActualStatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE)) {\n+                if (command == OnOffType.ON) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    sendMessage(YioRemoteMessages.IR_RECEIVER_ON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    sendMessage(YioRemoteMessages.IR_RECEIVER_OFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+            }\n+        }\n+    }\n+\n+    public void sendIRCode(@Nullable String irCode) {\n+        if (irCode != null) {\n+            if (irCode.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                sendMessage(YioRemoteMessages.IR_SEND, irCode);\n+            } else {\n+                logger.warn(\"Wrong ir code format {}\", irCode);\n+            }\n+        }\n+    }\n+\n+    private ChannelUID getChannelUuid(String group, String typeId) {\n+        return new ChannelUID(getThing().getUID(), group, typeId);\n+    }\n+\n+    private void updateChannelString(String group, String channelId, String value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+        updateState(id, new StringType(value));\n+    }\n+\n+    private void authenticate() {\n+        switch (yioRemoteDockActualStatus) {\n+            case CONNECTION_ESTABLISHED:\n+                authenticationmessagehandler.setToken(localConfig.accessToken);\n+                sendMessage(YioRemoteMessages.AUTHENTICATE_MESSAGE, localConfig.accessToken);\n+                yioRemoteDockActualStatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+                break;\n+            case AUTHENTICATION_PROCESS:\n+                if (authenticationok) {\n+                    yioRemoteDockActualStatus = YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE;\n+                    updateStatus(ThingStatus.ONLINE);\n+                    websocketpollingjob = scheduler.scheduleWithFixedDelay(this::pollingWebsocket, 0, 30,\n+                            TimeUnit.SECONDS);\n+                    if (authenticationjob != null) {\n+                        authenticationjob.cancel(true);\n+                    }\n+                } else {\n+                    yioRemoteDockActualStatus = YioRemoteDockHandleStatus.AUTHENTICATION_FAILED;\n+                }\n+                break;\n+            default:\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Connection lost no ping from YIO DOCK\");\n+                updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                break;\n+        }\n+    }\n+\n+    private void pollingWebsocket() {\n+        if (yioRemoteDockActualStatus.equals(YioRemoteDockHandleStatus.AUTHENTICATION_COMPLETE)) {\n+            if (getAndResetHeartbeat()) {\n+                updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL,\n+                        ircodereceivedhandler.getCode() + ircodereceivedhandler.getFormat());\n+                logger.debug(\"heartbeat ok\");\n+                sendMessage(YioRemoteMessages.HEARTBEAT_MESSAGE, \"\");\n+            } else {\n+                yioRemoteDockActualStatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                        \"Connection lost no ping from YIO DOCK\");\n+                updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+                if (websocketpollingjob != null) {\n+                    websocketpollingjob.cancel(true);\n+                }\n+            }\n+        } else {\n+            if (websocketpollingjob != null) {\n+                websocketpollingjob.cancel(true);\n+            }\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Connection lost no ping from YIO DOCK\");\n+            updateState(GROUP_OUTPUT, STATUS_STRING_CHANNEL, UnDefType.UNDEF);\n+        }\n+    }\n+\n+    public boolean getAndResetHeartbeat() {\n+        boolean result = heartbeat;\n+        heartbeat = false;\n+        return result;\n+    }\n+\n+    public YioRemoteDockHandleStatus getyioRemoteDockActualStatus() {\n+        return yioRemoteDockActualStatus;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37458bc3cdd9883a88d8544b66acd7c91a4211c3"}, "originalPosition": 347}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2ODM0Mg==", "bodyText": "This method is never used.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490468342", "createdAt": "2020-09-17T18:26:36Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockWebsocket.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import java.io.IOException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.api.Session;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketConnect;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketError;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketMessage;\n+import org.eclipse.jetty.websocket.api.annotations.WebSocket;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockWebsocket} is responsible for the Websocket Connection to the YIO Remote Dock\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+@WebSocket\n+public class YIOremoteDockWebsocket {\n+\n+    private @Nullable Session session;\n+    private String stringreceivedmessage = \"\";\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockWebsocket.class);\n+    private @Nullable YIOremoteDockWebsocketInterface yioremotedockwebsocketinterfacehandler;\n+\n+    public void addMessageHandler(YIOremoteDockWebsocketInterface yioremotedockwebsocketinterfacehandler) {\n+        this.yioremotedockwebsocketinterfacehandler = yioremotedockwebsocketinterfacehandler;\n+    }\n+\n+    @OnWebSocketMessage\n+    public void onText(Session session, String stringreceivedmessage) {\n+        if (yioremotedockwebsocketinterfacehandler != null) {\n+            yioremotedockwebsocketinterfacehandler.onMessage(stringreceivedmessage);\n+        }\n+    }\n+\n+    public String getstringreceivedmessage() {\n+        return this.stringreceivedmessage;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37458bc3cdd9883a88d8544b66acd7c91a4211c3"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2ODUwMQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void onText(Session session, String stringreceivedmessage) {\n          \n          \n            \n                public void onText(Session session, String receivedMessage) {", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490468501", "createdAt": "2020-09-17T18:26:52Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockWebsocket.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import java.io.IOException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.api.Session;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketConnect;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketError;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketMessage;\n+import org.eclipse.jetty.websocket.api.annotations.WebSocket;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockWebsocket} is responsible for the Websocket Connection to the YIO Remote Dock\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+@WebSocket\n+public class YIOremoteDockWebsocket {\n+\n+    private @Nullable Session session;\n+    private String stringreceivedmessage = \"\";\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockWebsocket.class);\n+    private @Nullable YIOremoteDockWebsocketInterface yioremotedockwebsocketinterfacehandler;\n+\n+    public void addMessageHandler(YIOremoteDockWebsocketInterface yioremotedockwebsocketinterfacehandler) {\n+        this.yioremotedockwebsocketinterfacehandler = yioremotedockwebsocketinterfacehandler;\n+    }\n+\n+    @OnWebSocketMessage\n+    public void onText(Session session, String stringreceivedmessage) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37458bc3cdd9883a88d8544b66acd7c91a4211c3"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2ODk1NQ==", "bodyText": "Please check all occurrences.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private @Nullable YIOremoteDockWebsocketInterface yioremotedockwebsocketinterfacehandler;\n          \n          \n            \n                private @Nullable YIOremoteDockWebsocketInterface websocketHandler;", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490468955", "createdAt": "2020-09-17T18:27:39Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockWebsocket.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import java.io.IOException;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.api.Session;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketConnect;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketError;\n+import org.eclipse.jetty.websocket.api.annotations.OnWebSocketMessage;\n+import org.eclipse.jetty.websocket.api.annotations.WebSocket;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockWebsocket} is responsible for the Websocket Connection to the YIO Remote Dock\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+\n+@NonNullByDefault\n+@WebSocket\n+public class YIOremoteDockWebsocket {\n+\n+    private @Nullable Session session;\n+    private String stringreceivedmessage = \"\";\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockWebsocket.class);\n+    private @Nullable YIOremoteDockWebsocketInterface yioremotedockwebsocketinterfacehandler;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "37458bc3cdd9883a88d8544b66acd7c91a4211c3"}, "originalPosition": 40}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkxMTgzOTA2", "url": "https://github.com/openhab/openhab-addons/pull/8394#pullrequestreview-491183906", "createdAt": "2020-09-18T06:31:05Z", "commit": {"oid": "bbbb24d288363c08194e7109cab3552e39fb8db7"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQwNjozMTowNVrOHT_ydA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQwNjozMToyMlrOHT_y9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDczMDEwMA==", "bodyText": "Solved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490730100", "createdAt": "2020-09-18T06:31:05Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,\n+                        YIOremote_DockwebSocketClientrequest);\n+                logger.debug(\"Connected websocket client\");\n+\n+                logger.debug(\"Check for authentication requested by YIO Dock\");\n+                YIOremoteDockwebSocket_ClientSocket.getLatch().await();\n+                Thread.sleep(1000);\n+\n+                try {\n+                    if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_required()) {\n+                        logger.debug(\"send authentication to YIO dock\");\n+                        YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                config.yiodockaccesstoken);\n+                        Thread.sleep(1000);\n+\n+                        if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_ok()) {\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED;\n+\n+                        } else {\n+                            logger.debug(\"authentication to YIO dock not ok\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED_FAILED;\n+                        }\n+                    } else {\n+                        logger.debug(\"authentication error YIO dock\");\n+                    }\n+\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"JSON convertion failure {}\", e.toString());\n+                }\n+\n+            } catch (\n+\n+            Exception e) {\n+                logger.warn(\"Web socket connect failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+        } catch (URISyntaxException e) {\n+            logger.debug(\"Initialize web socket failed {}\", e.toString());\n+        }\n+\n+        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+            updateStatus(ThingStatus.ONLINE);\n+            Runnable heartbeatpolling = new Runnable() {\n+                @Override\n+                public void run() {\n+                    try {\n+                        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                            YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                            Thread.sleep(1000);\n+\n+                            if (YIOremoteDockwebSocket_ClientSocket.get_boolean_heartbeat()) {\n+                                logger.debug(\"heartbeat ok\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                        YIOremoteDockwebSocket_ClientSocket.get_string_receivedstatus());\n+                            } else {\n+                                logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                                YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                        \"Connection lost no ping from YIO DOCK\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                                pollingJob.cancel(true);\n+                            }\n+                        } else {\n+                            logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                    \"Connection lost no ping from YIO DOCK\");\n+                            updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                            pollingJob.cancel(true);\n+                        }\n+                    } catch (InterruptedException e) {\n+                        logger.warn(\"Error during initializing the WebSocket polling Thread {}\", e.toString());\n+                    }\n+                }\n+            };\n+            try {\n+                pollingJob = scheduler.scheduleWithFixedDelay(heartbeatpolling, 0, 30, TimeUnit.SECONDS);\n+            } catch (Exception e) {\n+                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                logger.warn(\"Error during starting the WebSocket polling Thread {}\", e.toString());\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE);\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+        pollingJob.cancel(true);\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+\n+        if (YIODOCKRECEIVERSWITCH.equals(channelUID.getIdWithoutGroup())) {\n+            if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                if (command instanceof RefreshType) {\n+                    // TODO: handle data refresh\n+\n+                }\n+\n+                if (command.toString().equals(\"ON\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH ON procedure: Switching IR Receiver on\");\n+                    YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVERON, \"\");\n+                } else if (command.toString().equals(\"OFF\")) {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH OFF procedure: Switching IR Receiver off\");\n+                    YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.IRRECEIVEROFF, \"\");\n+                } else {\n+                    logger.debug(\"YIODOCKRECEIVERSWITCH no procedure\");\n+                }\n+\n+            } else {\n+                logger.warn(\"YIOremoteDockHandler not authenticated\");\n+            }\n+\n+        } else if (YIODOCKSENDIRCODE.equals(channelUID.getIdWithoutGroup())) {\n+            if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                if (command instanceof RefreshType) {\n+                    // TODO: handle data refresh\n+                    // logger.warn(\"YIOremoteDockHandler not authenticated\");\n+                }\n+                logger.debug(\"YIODOCKSENDIRCODE procedure: {}\", command.toString());\n+                send_ircode = command.toString();\n+                if (send_ircode.matches(\"[0-9][;]0[xX][0-9a-fA-F]+[;][0-9]+[;][0-9]\")) {\n+                    YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.IRSEND, send_ircode);\n+                } else {\n+                    logger.warn(\"Wrong IR code Format {}\", send_ircode);\n+                    send_ircode = \"\";\n+                }\n+            } else {\n+                logger.warn(\"YIOremoteDockHandler not authenticated\");\n+            }\n+        }\n+    }\n+\n+    protected void updateChannelString(String group, String channelId, String value) {\n+        ChannelUID id = new ChannelUID(getThing().getUID(), group, channelId);\n+\n+        if (isLinked(id)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4MTEzMQ=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 230}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDczMDIyOQ==", "bodyText": "Solved", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r490730229", "createdAt": "2020-09-18T06:31:22Z", "author": {"login": "miloit"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEHANDLESTATUS;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YIOREMOTEMESSAGETYPE;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    private @Nullable YIOremoteConfiguration config;\n+    private WebSocketClient YIOremote_DockwebSocketClient = new WebSocketClient();\n+    private YIOremoteDockWebsocket YIOremoteDockwebSocket_ClientSocket = new YIOremoteDockWebsocket();\n+    private ClientUpgradeRequest YIOremote_DockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI URI_yiodockwebsocketaddress;\n+    private YIOREMOTEHANDLESTATUS YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.UNINITIALIZED;\n+    private @Nullable Future<?> pollingJob;\n+    private String send_ircode = \"\";\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        logger.debug(\"Start initializing!\");\n+        config = getConfigAs(YIOremoteConfiguration.class);\n+\n+        // set the thing status to UNKNOWN temporarily and let the background task decide for the real status.\n+        // the framework is then able to reuse the resources from the thing handler initialization.\n+        // we set this upfront to reliably check status updates in unit tests.\n+        updateStatus(ThingStatus.UNKNOWN);\n+        try {\n+            logger.debug(\"Starting generating URI_yiodockwebsocketaddress\");\n+            URI_yiodockwebsocketaddress = new URI(\"ws://\" + config.yiodockhost + \":946\");\n+            logger.debug(\"Finished generating URI_yiodockwebsocketaddress\");\n+            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATION_PROCESS;\n+            try {\n+\n+                logger.debug(\"Starting websocket Client\");\n+                YIOremote_DockwebSocketClient.start();\n+                logger.debug(\"Started websocket Client\");\n+            } catch (Exception e) {\n+                logger.warn(\"Web socket start failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+            try {\n+                logger.debug(\"Connect websocket client\");\n+                YIOremote_DockwebSocketClient.connect(YIOremoteDockwebSocket_ClientSocket, URI_yiodockwebsocketaddress,\n+                        YIOremote_DockwebSocketClientrequest);\n+                logger.debug(\"Connected websocket client\");\n+\n+                logger.debug(\"Check for authentication requested by YIO Dock\");\n+                YIOremoteDockwebSocket_ClientSocket.getLatch().await();\n+                Thread.sleep(1000);\n+\n+                try {\n+                    if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_required()) {\n+                        logger.debug(\"send authentication to YIO dock\");\n+                        YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.AUTHENTICATE,\n+                                config.yiodockaccesstoken);\n+                        Thread.sleep(1000);\n+\n+                        if (YIOremoteDockwebSocket_ClientSocket.get_boolean_authentication_ok()) {\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED;\n+\n+                        } else {\n+                            logger.debug(\"authentication to YIO dock not ok\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.AUTHENTICATED_FAILED;\n+                        }\n+                    } else {\n+                        logger.debug(\"authentication error YIO dock\");\n+                    }\n+\n+                } catch (IllegalArgumentException e) {\n+                    logger.warn(\"JSON convertion failure {}\", e.toString());\n+                }\n+\n+            } catch (\n+\n+            Exception e) {\n+                logger.warn(\"Web socket connect failed {}\", e.toString());\n+                // throw new IOException(\"Web socket start failed\");\n+            }\n+        } catch (URISyntaxException e) {\n+            logger.debug(\"Initialize web socket failed {}\", e.toString());\n+        }\n+\n+        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+            updateStatus(ThingStatus.ONLINE);\n+            Runnable heartbeatpolling = new Runnable() {\n+                @Override\n+                public void run() {\n+                    try {\n+                        if (YIOREMOTEHANDLESTATUS_actualstatus.equals(YIOREMOTEHANDLESTATUS.AUTHENTICATED)) {\n+                            YIOremoteDockwebSocket_ClientSocket.sendMessage(YIOREMOTEMESSAGETYPE.HEARTBEAT, \"\");\n+\n+                            Thread.sleep(1000);\n+\n+                            if (YIOremoteDockwebSocket_ClientSocket.get_boolean_heartbeat()) {\n+                                logger.debug(\"heartbeat ok\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS,\n+                                        YIOremoteDockwebSocket_ClientSocket.get_string_receivedstatus());\n+                            } else {\n+                                logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                                YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                        \"Connection lost no ping from YIO DOCK\");\n+                                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                                pollingJob.cancel(true);\n+                            }\n+                        } else {\n+                            logger.warn(\"Connection lost no ping from YIO DOCK\");\n+                            YIOREMOTEHANDLESTATUS_actualstatus = YIOREMOTEHANDLESTATUS.CONNECTION_FAILED;\n+                            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                                    \"Connection lost no ping from YIO DOCK\");\n+                            updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                            pollingJob.cancel(true);\n+                        }\n+                    } catch (InterruptedException e) {\n+                        logger.warn(\"Error during initializing the WebSocket polling Thread {}\", e.toString());\n+                    }\n+                }\n+            };\n+            try {\n+                pollingJob = scheduler.scheduleWithFixedDelay(heartbeatpolling, 0, 30, TimeUnit.SECONDS);\n+            } catch (Exception e) {\n+                updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+                logger.warn(\"Error during starting the WebSocket polling Thread {}\", e.toString());\n+            }\n+        } else {\n+            updateStatus(ThingStatus.OFFLINE);\n+        }\n+\n+        logger.debug(\"Finished initializing!\");\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        updateChannelString(GROUP_OUTPUT, YIODOCKSTATUS, \"Connection/Configuration Error\");\n+        pollingJob.cancel(true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE3OTMzNA=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 180}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkxNTc2OTk4", "url": "https://github.com/openhab/openhab-addons/pull/8394#pullrequestreview-491576998", "createdAt": "2020-09-18T15:38:27Z", "commit": {"oid": "472243eeef11b587fc1b5e24490fe2522f785d04"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQxNTozODoyN1rOHUSPtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQxNTo1MDo0MVrOHUSscQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTAzMjUwMA==", "bodyText": "Package names should be all lower case. The directory name is upper case in your case. Also it's good practice to make the names singular. So, dto would be good.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r491032500", "createdAt": "2020-09-18T15:38:27Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/DTOs/AuthenticationMessage.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal.dtos;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "472243eeef11b587fc1b5e24490fe2522f785d04"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTAzMzM0NA==", "bodyText": "As this class can be instantiated for multiple Docks, if the user adds multiple Things, this must not be static. Each Action object has its own handler.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r491033344", "createdAt": "2020-09-18T15:39:51Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockActions.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.binding.ThingActions;\n+import org.eclipse.smarthome.core.thing.binding.ThingActionsScope;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+\n+/**\n+ * The {@link YIOremoteDockActions} is responsible for handling the action commands\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@ThingActionsScope(name = \"yioremote\")\n+@NonNullByDefault\n+public class YIOremoteDockActions implements ThingActions {\n+    private @Nullable static YIOremoteDockHandler dockHandler;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "472243eeef11b587fc1b5e24490fe2522f785d04"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTAzNDU1NQ==", "bodyText": "Just for the records, if you only check one Enum constant, an if is sufficient. You can keep this.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r491034555", "createdAt": "2020-09-18T15:41:54Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockActions.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.binding.ThingActions;\n+import org.eclipse.smarthome.core.thing.binding.ThingActionsScope;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+\n+/**\n+ * The {@link YIOremoteDockActions} is responsible for handling the action commands\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@ThingActionsScope(name = \"yioremote\")\n+@NonNullByDefault\n+public class YIOremoteDockActions implements ThingActions {\n+    private @Nullable static YIOremoteDockHandler dockHandler;\n+\n+    @Override\n+    public void setThingHandler(@Nullable ThingHandler yiremotedockhandler) {\n+        dockHandler = (YIOremoteDockHandler) yiremotedockhandler;\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return dockHandler;\n+    }\n+\n+    @RuleAction(label = \"@text/actionLabel\", description = \"@text/actionDesc\")\n+    public void sendIRCode(\n+            @ActionInput(name = \"IRCode\", label = \"@text/actionInputTopicLabel\", description = \"@text/actionInputTopicDesc\") @Nullable String irCode) {\n+        switch (dockHandler.getyioRemoteDockActualStatus()) {\n+            case AUTHENTICATION_COMPLETE:\n+                dockHandler.sendIRCode(irCode);\n+                break;\n+            default:\n+                break;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "472243eeef11b587fc1b5e24490fe2522f785d04"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTAzNTY5Nw==", "bodyText": "You can simply invoke the other method:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        switch (dockHandler.getyioRemoteDockActualStatus()) {\n          \n          \n            \n                            case AUTHENTICATION_COMPLETE:\n          \n          \n            \n                                dockHandler.sendIRCode(irCode);\n          \n          \n            \n                                break;\n          \n          \n            \n                        }\n          \n          \n            \n                        ((YIOremoteDockActions) actions).sendIRCode(irCode);", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r491035697", "createdAt": "2020-09-18T15:43:52Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockActions.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.binding.ThingActions;\n+import org.eclipse.smarthome.core.thing.binding.ThingActionsScope;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+\n+/**\n+ * The {@link YIOremoteDockActions} is responsible for handling the action commands\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@ThingActionsScope(name = \"yioremote\")\n+@NonNullByDefault\n+public class YIOremoteDockActions implements ThingActions {\n+    private @Nullable static YIOremoteDockHandler dockHandler;\n+\n+    @Override\n+    public void setThingHandler(@Nullable ThingHandler yiremotedockhandler) {\n+        dockHandler = (YIOremoteDockHandler) yiremotedockhandler;\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return dockHandler;\n+    }\n+\n+    @RuleAction(label = \"@text/actionLabel\", description = \"@text/actionDesc\")\n+    public void sendIRCode(\n+            @ActionInput(name = \"IRCode\", label = \"@text/actionInputTopicLabel\", description = \"@text/actionInputTopicDesc\") @Nullable String irCode) {\n+        switch (dockHandler.getyioRemoteDockActualStatus()) {\n+            case AUTHENTICATION_COMPLETE:\n+                dockHandler.sendIRCode(irCode);\n+                break;\n+            default:\n+                break;\n+        }\n+    }\n+\n+    public static void sendIRCode(@Nullable ThingActions actions, @Nullable String irCode) {\n+        if (actions instanceof YIOremoteDockActions && dockHandler != null) {\n+            switch (dockHandler.getyioRemoteDockActualStatus()) {\n+                case AUTHENTICATION_COMPLETE:\n+                    dockHandler.sendIRCode(irCode);\n+                    break;\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "472243eeef11b587fc1b5e24490fe2522f785d04"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTAzNjE2Mw==", "bodyText": "As dockHandler is nullable, you need to store it to a local variable and do a null check on it.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r491036163", "createdAt": "2020-09-18T15:44:40Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockActions.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.binding.ThingActions;\n+import org.eclipse.smarthome.core.thing.binding.ThingActionsScope;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+\n+/**\n+ * The {@link YIOremoteDockActions} is responsible for handling the action commands\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@ThingActionsScope(name = \"yioremote\")\n+@NonNullByDefault\n+public class YIOremoteDockActions implements ThingActions {\n+    private @Nullable static YIOremoteDockHandler dockHandler;\n+\n+    @Override\n+    public void setThingHandler(@Nullable ThingHandler yiremotedockhandler) {\n+        dockHandler = (YIOremoteDockHandler) yiremotedockhandler;\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return dockHandler;\n+    }\n+\n+    @RuleAction(label = \"@text/actionLabel\", description = \"@text/actionDesc\")\n+    public void sendIRCode(\n+            @ActionInput(name = \"IRCode\", label = \"@text/actionInputTopicLabel\", description = \"@text/actionInputTopicDesc\") @Nullable String irCode) {\n+        switch (dockHandler.getyioRemoteDockActualStatus()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "472243eeef11b587fc1b5e24490fe2522f785d04"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTAzNjk4NA==", "bodyText": "Please double check the capitalization, as mentioned in the previous reviews.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r491036984", "createdAt": "2020-09-18T15:45:57Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.openhab.binding.yioremote.internal.dtos.AuthenticationMessage;\n+import org.openhab.binding.yioremote.internal.dtos.IRCode;\n+import org.openhab.binding.yioremote.internal.dtos.IRCodeSendMessage;\n+import org.openhab.binding.yioremote.internal.dtos.IRReceiverMessage;\n+import org.openhab.binding.yioremote.internal.utils.Websocket;\n+import org.openhab.binding.yioremote.internal.utils.WebsocketInterface;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private Websocket yioremoteDockwebSocketClient = new Websocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioRemoteDockActualStatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> webSocketPollingJob;\n+    public String receivedmessage = \"\";\n+    private JsonObject recievedjson = new JsonObject();\n+    private boolean heartbeat = false;\n+    private boolean authenticationok = false;\n+    private String receivedstatus = \"\";\n+    private String lastsendircode = \"\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "472243eeef11b587fc1b5e24490fe2522f785d04"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTAzODE1NA==", "bodyText": "Syntactical sugar\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                            case CONNECTION_ESTABLISHED:\n          \n          \n            \n                                                authenticate();\n          \n          \n            \n                                                break;\n          \n          \n            \n                                            case AUTHENTICATION_PROCESS:\n          \n          \n            \n                                                authenticate();\n          \n          \n            \n                                                break;\n          \n          \n            \n                                            case CONNECTION_ESTABLISHED:\n          \n          \n            \n                                            case AUTHENTICATION_PROCESS:\n          \n          \n            \n                                                authenticate();\n          \n          \n            \n                                                break;", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r491038154", "createdAt": "2020-09-18T15:47:56Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockHandler.java", "diffHunk": "@@ -0,0 +1,388 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import static org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.*;\n+\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.jetty.websocket.client.ClientUpgradeRequest;\n+import org.eclipse.jetty.websocket.client.WebSocketClient;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.StringType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerService;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteDockHandleStatus;\n+import org.openhab.binding.yioremote.internal.YIOremoteBindingConstants.YioRemoteMessages;\n+import org.openhab.binding.yioremote.internal.dtos.AuthenticationMessage;\n+import org.openhab.binding.yioremote.internal.dtos.IRCode;\n+import org.openhab.binding.yioremote.internal.dtos.IRCodeSendMessage;\n+import org.openhab.binding.yioremote.internal.dtos.IRReceiverMessage;\n+import org.openhab.binding.yioremote.internal.utils.Websocket;\n+import org.openhab.binding.yioremote.internal.utils.WebsocketInterface;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParser;\n+\n+/**\n+ * The {@link YIOremoteDockHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@NonNullByDefault\n+public class YIOremoteDockHandler extends BaseThingHandler {\n+\n+    private final Logger logger = LoggerFactory.getLogger(YIOremoteDockHandler.class);\n+\n+    YIOremoteConfiguration localConfig = getConfigAs(YIOremoteConfiguration.class);\n+    private WebSocketClient webSocketClient = new WebSocketClient();\n+    private Websocket yioremoteDockwebSocketClient = new Websocket();\n+    private ClientUpgradeRequest yioremoteDockwebSocketClientrequest = new ClientUpgradeRequest();\n+    private @Nullable URI websocketAddress;\n+    private YioRemoteDockHandleStatus yioRemoteDockActualStatus = YioRemoteDockHandleStatus.UNINITIALIZED_STATE;\n+    private @Nullable Future<?> webSocketPollingJob;\n+    public String receivedmessage = \"\";\n+    private JsonObject recievedjson = new JsonObject();\n+    private boolean heartbeat = false;\n+    private boolean authenticationok = false;\n+    private String receivedstatus = \"\";\n+    private String lastsendircode = \"\";\n+    private IRCode irCodeReceivedHandler = new IRCode();\n+    private IRCode irCodeSendHandler = new IRCode();\n+    private IRCodeSendMessage irCodeSendMessageHandler = new IRCodeSendMessage(irCodeSendHandler);\n+    private AuthenticationMessage authenticationMessageHandler = new AuthenticationMessage();\n+    private IRReceiverMessage irReceiverMessageHandler = new IRReceiverMessage();\n+\n+    public YIOremoteDockHandler(Thing thing) {\n+        super(thing);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        updateStatus(ThingStatus.UNKNOWN);\n+        scheduler.execute(() -> {\n+            try {\n+                websocketAddress = new URI(\"ws://\" + localConfig.host + \":946\");\n+                yioRemoteDockActualStatus = YioRemoteDockHandleStatus.AUTHENTICATION_PROCESS;\n+            } catch (URISyntaxException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Initialize web socket failed: \" + e.getMessage());\n+            }\n+\n+            yioremoteDockwebSocketClient.addMessageHandler(new WebsocketInterface() {\n+\n+                @Override\n+                public void onConnect(boolean connected) {\n+                    if (connected) {\n+                        yioRemoteDockActualStatus = YioRemoteDockHandleStatus.CONNECTION_ESTABLISHED;\n+                    } else {\n+                        yioRemoteDockActualStatus = YioRemoteDockHandleStatus.CONNECTION_FAILED;\n+                    }\n+                }\n+\n+                @Override\n+                public void onMessage(String message) {\n+                    receivedmessage = message;\n+                    logger.debug(\"Message recieved {}\", message);\n+                    recievedjson = convertStringToJsonObject(receivedmessage);\n+                    if (recievedjson.size() > 0) {\n+                        if (decodeReceivedMessage(recievedjson)) {\n+                            triggerChannel(getChannelUuid(GROUP_OUTPUT, STATUS_STRING_CHANNEL));\n+                            updateChannelString(GROUP_OUTPUT, STATUS_STRING_CHANNEL, receivedstatus);\n+                            switch (yioRemoteDockActualStatus) {\n+                                case CONNECTION_ESTABLISHED:\n+                                    authenticate();\n+                                    break;\n+                                case AUTHENTICATION_PROCESS:\n+                                    authenticate();\n+                                    break;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "472243eeef11b587fc1b5e24490fe2522f785d04"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTAzOTYwOQ==", "bodyText": "I still see the re-formatting in the header.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r491039609", "createdAt": "2020-09-18T15:50:16Z", "author": {"login": "fwolter"}, "path": "bundles/pom.xml", "diffHunk": "@@ -1,4 +1,6 @@\n-<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?><project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+  xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTE4NTg0OA=="}, "originalCommit": {"oid": "0f272040f155fa011998af762c6688c23c06ac9e"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTAzOTcyMw==", "bodyText": "Here, too.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r491039723", "createdAt": "2020-09-18T15:50:27Z", "author": {"login": "fwolter"}, "path": "bundles/pom.xml", "diffHunk": "@@ -236,7 +238,7 @@\n     <module>org.openhab.binding.snmp</module>\n     <module>org.openhab.binding.solaredge</module>\n     <module>org.openhab.binding.solarlog</module>\n-\t<module>org.openhab.binding.somfymylink</module>\n+    <module>org.openhab.binding.somfymylink</module>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI1MDkzMw=="}, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTAzOTg1Nw==", "bodyText": "Here, too.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r491039857", "createdAt": "2020-09-18T15:50:41Z", "author": {"login": "fwolter"}, "path": "bundles/pom.xml", "diffHunk": "@@ -520,5 +523,4 @@\n       </build>\n     </profile>\n   </profiles>\n-", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI1MTEwOA=="}, "originalCommit": {"oid": "327f0e7b9e3f1817f672d564e65422a9d6482ad5"}, "originalPosition": 29}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkxNzI1MTg2", "url": "https://github.com/openhab/openhab-addons/pull/8394#pullrequestreview-491725186", "createdAt": "2020-09-18T19:22:22Z", "commit": {"oid": "df721cf32ddd8934a43fd4ad853bfdd163137ce4"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQxOToyMjoyM1rOHUZOAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xOFQxOToyMjoyM1rOHUZOAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE0Njc1NA==", "bodyText": "You need to store dockHandler to a local variable and do the null check on that to get rid of the compiler warning. As dockHandler is a field it could be modified by another thread exactly after the null check and before the access in the following lines.", "url": "https://github.com/openhab/openhab-addons/pull/8394#discussion_r491146754", "createdAt": "2020-09-18T19:22:23Z", "author": {"login": "fwolter"}, "path": "bundles/org.openhab.binding.yioremote/src/main/java/org/openhab/binding/yioremote/internal/YIOremoteDockActions.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.yioremote.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.binding.ThingActions;\n+import org.eclipse.smarthome.core.thing.binding.ThingActionsScope;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.openhab.core.automation.annotation.ActionInput;\n+import org.openhab.core.automation.annotation.RuleAction;\n+\n+/**\n+ * The {@link YIOremoteDockActions} is responsible for handling the action commands\n+ *\n+ *\n+ * @author Michael Loercher - Initial contribution\n+ */\n+@ThingActionsScope(name = \"yioremote\")\n+@NonNullByDefault\n+public class YIOremoteDockActions implements ThingActions {\n+    private @Nullable static YIOremoteDockHandler dockHandler;\n+\n+    @Override\n+    public void setThingHandler(@Nullable ThingHandler yiremotedockhandler) {\n+        dockHandler = (YIOremoteDockHandler) yiremotedockhandler;\n+    }\n+\n+    @Override\n+    public @Nullable ThingHandler getThingHandler() {\n+        return dockHandler;\n+    }\n+\n+    @RuleAction(label = \"@text/actionLabel\", description = \"@text/actionDesc\")\n+    public void sendIRCode(\n+            @ActionInput(name = \"IRCode\", label = \"@text/actionInputTopicLabel\", description = \"@text/actionInputTopicDesc\") @Nullable String irCode) {\n+        if (dockHandler != null) {\n+            switch (dockHandler.getyioRemoteDockActualStatus()) {\n+                case AUTHENTICATION_COMPLETE:\n+                    dockHandler.sendIRCode(irCode);\n+                    break;\n+                default:\n+                    break;\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "df721cf32ddd8934a43fd4ad853bfdd163137ce4"}, "originalPosition": 54}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkxNzcyNjQ1", "url": "https://github.com/openhab/openhab-addons/pull/8394#pullrequestreview-491772645", "createdAt": "2020-09-18T20:48:52Z", "commit": {"oid": "a817d4dca82337e636fbc5a70b61252cb209bb96"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "98045b9758cb63e8813b262d53660ea077d24b4e", "author": {"user": {"login": "miloit", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/98045b9758cb63e8813b262d53660ea077d24b4e", "committedDate": "2020-09-18T21:00:55Z", "message": "Initial\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0fa29da4356cb5e0d32a7e12daca69cb3f6e1bd2", "author": {"user": {"login": "miloit", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/0fa29da4356cb5e0d32a7e12daca69cb3f6e1bd2", "committedDate": "2020-09-18T21:00:55Z", "message": "Initial Websocket connect\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cb13441373c2f15360d8564d0771a9d6dd67f0f0", "author": {"user": {"login": "miloit", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/cb13441373c2f15360d8564d0771a9d6dd67f0f0", "committedDate": "2020-09-18T21:00:55Z", "message": "Initial websocket class\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "40edeb3de1d53d0ab0a98ae1627147c0260e33f9", "author": {"user": {"login": "miloit", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/40edeb3de1d53d0ab0a98ae1627147c0260e33f9", "committedDate": "2020-09-18T21:00:56Z", "message": "Initiel websocket Class cleaned\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c00022c2b178b2e05616ba142db0b12bb8fae8d8", "author": {"user": {"login": "miloit", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/c00022c2b178b2e05616ba142db0b12bb8fae8d8", "committedDate": "2020-09-18T21:00:56Z", "message": "Initial usage of Websocket client Class\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eebb8377aa8a854e6adf52875841f1fa662b9f9e", "author": {"user": {"login": "miloit", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/eebb8377aa8a854e6adf52875841f1fa662b9f9e", "committedDate": "2020-09-18T21:00:56Z", "message": "Cleaning up YIOremoteHandler.class\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "265ff4655d4de629dc990a33f593cb6280458939", "author": {"user": {"login": "miloit", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/265ff4655d4de629dc990a33f593cb6280458939", "committedDate": "2020-09-18T21:00:56Z", "message": "Implementation of correct authentification procedure and error managment\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6e35d7c7f86d5719b629ca34d9b32f7462658275", "author": {"user": {"login": "miloit", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/6e35d7c7f86d5719b629ca34d9b32f7462658275", "committedDate": "2020-09-18T21:00:56Z", "message": "Implementation of the Input and Output Channels\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b080edd42ae1ed760b6e47ef64cd45a65581b0c0", "author": {"user": {"login": "miloit", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/b080edd42ae1ed760b6e47ef64cd45a65581b0c0", "committedDate": "2020-09-18T21:00:56Z", "message": "Renaming configuration\n\nRenaming\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d66823c2b9049d0994e83e1e143f59119df3c385", "author": {"user": {"login": "miloit", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/d66823c2b9049d0994e83e1e143f59119df3c385", "committedDate": "2020-09-18T21:00:56Z", "message": "Implementing of YIODOCKRECEIVERSWITCH procedure\nImplementing of @OnWebSocketError procedure\nImplementing of string channel yiodocksendircode\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4032bc745f3dae0fcd735a6c6941f38b8bb36766", "author": {"user": {"login": "miloit", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/4032bc745f3dae0fcd735a6c6941f38b8bb36766", "committedDate": "2020-09-18T21:00:56Z", "message": "Implementation of polling Thread\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8871db53de7caa5da96eea31a33aa66e1162d221", "author": {"user": {"login": "miloit", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/8871db53de7caa5da96eea31a33aa66e1162d221", "committedDate": "2020-09-18T21:00:56Z", "message": "Implementation of right heartbeat function\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5b4521bb29a7ec665071a3e4f4f39263ebfc3441", "author": {"user": {"login": "miloit", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/5b4521bb29a7ec665071a3e4f4f39263ebfc3441", "committedDate": "2020-09-18T21:00:57Z", "message": "Rework of send message procedure\nRework of heartbeat procedure\ncleaning up the code\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ff542c8625b89822595e45a68bd318f3bc08921e", "author": {"user": {"login": "miloit", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/ff542c8625b89822595e45a68bd318f3bc08921e", "committedDate": "2020-09-18T21:00:57Z", "message": "Dfinition of correct channels\nImplementing of channels\nError managment\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ec1f9622bce5076f96fc195042ed1fc94ba1a5aa", "author": {"user": {"login": "miloit", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/ec1f9622bce5076f96fc195042ed1fc94ba1a5aa", "committedDate": "2020-09-18T21:00:57Z", "message": "Some error optimizing\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f3748fe4405aa2cac39a5e980ff2ecc270df7a5a", "author": {"user": {"login": "miloit", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/f3748fe4405aa2cac39a5e980ff2ecc270df7a5a", "committedDate": "2020-09-18T21:00:57Z", "message": "Implementation of general status channel to the Binding instead of a only ir recieved code channel\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6bd01c7cf947a3d653746a9b879dcf30468fb7f4", "author": {"user": {"login": "miloit", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/6bd01c7cf947a3d653746a9b879dcf30468fb7f4", "committedDate": "2020-09-18T21:00:57Z", "message": "Deleting some useless comments\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1ecebfe3432728753478bf0d6cd8d842275f7958", "author": {"user": {"login": "miloit", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/1ecebfe3432728753478bf0d6cd8d842275f7958", "committedDate": "2020-09-18T21:00:57Z", "message": "Implementing of correct error handling during heartbeat\nAdding more debug informations\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1002f9e5acb6915402fd7758900ded5a970a5ec4", "author": {"user": {"login": "miloit", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/1002f9e5acb6915402fd7758900ded5a970a5ec4", "committedDate": "2020-09-18T21:00:57Z", "message": "Update the readme.md\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6093be076b3908570e9cc4429f7735af6659aec3", "author": {"user": {"login": "miloit", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/6093be076b3908570e9cc4429f7735af6659aec3", "committedDate": "2020-09-18T21:00:57Z", "message": "Update readme.md\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "37284dc55609be01fd7cfdb968b7a193cac73239", "author": {"user": {"login": "miloit", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/37284dc55609be01fd7cfdb968b7a193cac73239", "committedDate": "2020-09-18T21:00:57Z", "message": "Update readme.md\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "858e7d3cf6162fcb871614b851774fc7a951bbdd", "author": {"user": {"login": "miloit", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/858e7d3cf6162fcb871614b851774fc7a951bbdd", "committedDate": "2020-09-18T21:00:58Z", "message": "Update readme.md\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "34cd29af2720b3fb14838e5df0101de8eff95df3", "author": {"user": {"login": "miloit", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/34cd29af2720b3fb14838e5df0101de8eff95df3", "committedDate": "2020-09-18T21:00:58Z", "message": "readme.md update\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "20d35ba864d89a1ad9b5b1ed729eb1adb3ccc05c", "author": {"user": {"login": "miloit", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/20d35ba864d89a1ad9b5b1ed729eb1adb3ccc05c", "committedDate": "2020-09-18T21:00:58Z", "message": "Update of readme.md\nUpdate of Default values\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1eaf7b569716ef0b00d9540de79b72991df5f837", "author": {"user": {"login": "miloit", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/1eaf7b569716ef0b00d9540de79b72991df5f837", "committedDate": "2020-09-18T21:00:58Z", "message": "readme.md update\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8cd8e124751d3710ac4e63f02a20439e6a6122cd", "author": {"user": {"login": "miloit", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/8cd8e124751d3710ac4e63f02a20439e6a6122cd", "committedDate": "2020-09-18T21:00:58Z", "message": "readme.md update\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fb8e49e91f4047e1db36ae0f214682c3ffe5c351", "author": {"user": {"login": "miloit", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/fb8e49e91f4047e1db36ae0f214682c3ffe5c351", "committedDate": "2020-09-18T21:00:58Z", "message": "cleaning error\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "825e02ed784fd0f529a85e733dd7e4618a1f18a8", "author": {"user": {"login": "miloit", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/825e02ed784fd0f529a85e733dd7e4618a1f18a8", "committedDate": "2020-09-18T21:00:58Z", "message": "cleaning coding errors\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f4cdbea843e784b3568c0d4f8b66423f3ff79375", "author": {"user": {"login": "miloit", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/f4cdbea843e784b3568c0d4f8b66423f3ff79375", "committedDate": "2020-09-18T21:00:58Z", "message": "add yioremote binding to the POM\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "931ebd9070c4daa89e714dc8a81725697b6f5282", "author": {"user": {"login": "miloit", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/931ebd9070c4daa89e714dc8a81725697b6f5282", "committedDate": "2020-09-18T21:00:58Z", "message": "applying coding style\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "77d5da401964ebc3fc0027f806095afde531c63f", "author": {"user": {"login": "miloit", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/77d5da401964ebc3fc0027f806095afde531c63f", "committedDate": "2020-09-18T21:00:59Z", "message": "Adding localisation de_DE\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "14ce2c451f0d0bed77d36e4c314ef0f72c76ad55", "author": {"user": {"login": "miloit", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/14ce2c451f0d0bed77d36e4c314ef0f72c76ad55", "committedDate": "2020-09-18T21:00:59Z", "message": "pom.xml update\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "883ba80fd5a6e3927351c02f1e2707ec1860a564", "author": {"user": {"login": "miloit", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/883ba80fd5a6e3927351c02f1e2707ec1860a564", "committedDate": "2020-09-18T21:00:59Z", "message": "Renaming of thing to Dock thing\nRenaming of the hostip parameter to simply host\nupdating readme\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0d978dd5408a40e3d7a0fcaa0892f8ec8bb38e86", "author": {"user": {"login": "miloit", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/0d978dd5408a40e3d7a0fcaa0892f8ec8bb38e86", "committedDate": "2020-09-18T21:00:59Z", "message": "remove of the prefix yiodock of all channels\nReadme Update\nDeleting non used comments\nChanged some coding according to the review\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1a0eeeb04b69d1094d5d7907cdce0874f5f23138", "author": {"user": {"login": "miloit", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/1a0eeeb04b69d1094d5d7907cdce0874f5f23138", "committedDate": "2020-09-18T21:00:59Z", "message": "Signed-off-by: miloit <MichaelLoercher@web.de>\n\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ecf5f3a752e7a3ab819d1b1844109be998134f63", "author": {"user": {"login": "miloit", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/ecf5f3a752e7a3ab819d1b1844109be998134f63", "committedDate": "2020-09-18T21:00:59Z", "message": "Changed initialization to background\nReadme Update\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6c6165df24dc94a4fa997880ce0863ea56412baa", "author": {"user": {"login": "miloit", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/6c6165df24dc94a4fa997880ce0863ea56412baa", "committedDate": "2020-09-18T21:00:59Z", "message": "implementing Action Handler\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c5b27997bda8b0796704a3354c4c45fdbd967111", "author": {"user": {"login": "miloit", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/c5b27997bda8b0796704a3354c4c45fdbd967111", "committedDate": "2020-09-18T21:01:00Z", "message": "Removing of Input label and adding action sendircode handler\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "78b4eaa722fff3d40380884dca01185c046d4866", "author": {"user": {"login": "miloit", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/78b4eaa722fff3d40380884dca01185c046d4866", "committedDate": "2020-09-18T21:01:00Z", "message": "minor code changed\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9f263cc4d17eba31f856b962360cf113f7ee6c3d", "author": {"user": {"login": "miloit", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/9f263cc4d17eba31f856b962360cf113f7ee6c3d", "committedDate": "2020-09-18T21:01:00Z", "message": "Signed-off-by: miloit <MichaelLoercher@web.de>\n\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "35f9ac7c9f881b114c1644269ca2bcf17b775d0a", "author": {"user": {"login": "miloit", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/35f9ac7c9f881b114c1644269ca2bcf17b775d0a", "committedDate": "2020-09-18T21:01:00Z", "message": "Signed-off-by: miloit <MichaelLoercher@web.de>\n\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c055f3638661d09acb881f72070830709993961b", "author": {"user": {"login": "miloit", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/c055f3638661d09acb881f72070830709993961b", "committedDate": "2020-09-18T21:01:00Z", "message": "Signed-off-by: miloit <MichaelLoercher@web.de>\n\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3aee8c30bc86e2936b12b13233ae143d74b29d08", "author": {"user": {"login": "miloit", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/3aee8c30bc86e2936b12b13233ae143d74b29d08", "committedDate": "2020-09-18T21:01:00Z", "message": "Signed-off-by: miloit <MichaelLoercher@web.de>\n\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dbe56095e7e892f2f988e4bf82412de674c4980b", "author": {"user": {"login": "miloit", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/dbe56095e7e892f2f988e4bf82412de674c4980b", "committedDate": "2020-09-18T21:01:00Z", "message": "Signed-off-by: miloit <MichaelLoercher@web.de>\n\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5eeea7bd9bcdee70db9f1336b0139d6946153084", "author": {"user": {"login": "miloit", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/5eeea7bd9bcdee70db9f1336b0139d6946153084", "committedDate": "2020-09-18T21:01:00Z", "message": "COde Stzle changes\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ed2bf7a5e1c9f3b70a676fc8fc9f3f7ef49a0036", "author": {"user": {"login": "miloit", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/ed2bf7a5e1c9f3b70a676fc8fc9f3f7ef49a0036", "committedDate": "2020-09-18T21:01:01Z", "message": "Code styling\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bfe156b279899b2c96c2bc8e446e2a7a0ac139a6", "author": {"user": {"login": "miloit", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/bfe156b279899b2c96c2bc8e446e2a7a0ac139a6", "committedDate": "2020-09-18T21:01:01Z", "message": "Update bundles/org.openhab.binding.yioremote/README.md\n\nCo-authored-by: Fabian Wolter <github@fabian-wolter.de>\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2bb29c7b39e1ad2370c23b3964a9b0b2ab906880", "author": {"user": {"login": "miloit", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/2bb29c7b39e1ad2370c23b3964a9b0b2ab906880", "committedDate": "2020-09-18T21:01:01Z", "message": "Signed-off-by: miloit <MichaelLoercher@web.de>\n\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f92a114c75bfe112c7d349a5364f63ccbe5b809e", "author": {"user": {"login": "miloit", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/f92a114c75bfe112c7d349a5364f63ccbe5b809e", "committedDate": "2020-09-18T21:01:01Z", "message": "Complete rewrite of the YIO Dock Handler\nIntroducing of Websocket interface\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f887ede2273c00182f8714e73e88ea96c9d7ed6f", "author": {"user": {"login": "miloit", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/f887ede2273c00182f8714e73e88ea96c9d7ed6f", "committedDate": "2020-09-18T21:01:01Z", "message": "code optimization error managment improved\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a299b70c2dfb44cfc5b493f60477229712feecb3", "author": {"user": {"login": "miloit", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/a299b70c2dfb44cfc5b493f60477229712feecb3", "committedDate": "2020-09-18T21:01:01Z", "message": "Forgot to set the thing online - solved\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d831aad8b8f7e0e3f77cb14d5b2ad7dbc11fadf3", "author": {"user": {"login": "miloit", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/d831aad8b8f7e0e3f77cb14d5b2ad7dbc11fadf3", "committedDate": "2020-09-18T21:01:01Z", "message": "Minor code improvements\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "07164d3b4aae4e9d2625cf6e9640179cc8405d76", "author": {"user": {"login": "miloit", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/07164d3b4aae4e9d2625cf6e9640179cc8405d76", "committedDate": "2020-09-18T21:01:01Z", "message": "changes from github review\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c7577d9c3e4bc83777bed6959cea06fc7297a5d1", "author": {"user": {"login": "miloit", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/c7577d9c3e4bc83777bed6959cea06fc7297a5d1", "committedDate": "2020-09-18T21:01:01Z", "message": "json object used\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a6d288e8099e83402ae0c940fd671be21b69ca32", "author": {"user": {"login": "miloit", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/a6d288e8099e83402ae0c940fd671be21b69ca32", "committedDate": "2020-09-18T21:01:02Z", "message": "Signed-off-by: miloit <MichaelLoercher@web.de>\n\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0c75aa8ac38c849d0a05a02ecf2527c26a571630", "author": {"user": {"login": "miloit", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/0c75aa8ac38c849d0a05a02ecf2527c26a571630", "committedDate": "2020-09-18T21:01:02Z", "message": "Faster authentication process\nIntroducing DTOs\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "854a640735809855e2161c51f58f7af04e427751", "author": {"user": {"login": "miloit", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/854a640735809855e2161c51f58f7af04e427751", "committedDate": "2020-09-18T21:01:02Z", "message": "code cleaning\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1b826869aafda8117bfd1c1c0df9a5d3992badbc", "author": {"user": {"login": "miloit", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/1b826869aafda8117bfd1c1c0df9a5d3992badbc", "committedDate": "2020-09-18T21:01:02Z", "message": "resolved code review\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2bd78ff2b268d306eec5b7eb0c077257a45b7950", "author": {"user": {"login": "miloit", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/2bd78ff2b268d306eec5b7eb0c077257a45b7950", "committedDate": "2020-09-18T21:01:02Z", "message": "github issues solved\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "37e14c2c5189772a0e6a48a26c644e83da0358db", "author": {"user": {"login": "miloit", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/37e14c2c5189772a0e6a48a26c644e83da0358db", "committedDate": "2020-09-18T21:01:02Z", "message": "code changes\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9fec3159d22ae80fad6794e8651aa2597a425f3e", "author": {"user": {"login": "miloit", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/9fec3159d22ae80fad6794e8651aa2597a425f3e", "committedDate": "2020-09-18T21:01:02Z", "message": "minor code changes\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4ba40be747dd4b3e6c82512c3b71f007a48d57bf", "author": {"user": {"login": "miloit", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/4ba40be747dd4b3e6c82512c3b71f007a48d57bf", "committedDate": "2020-09-18T21:01:02Z", "message": "Readme Update\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "894d8616f6a85ba8d2d6f5bf4fbe28ab10ba34bd", "author": {"user": {"login": "miloit", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/894d8616f6a85ba8d2d6f5bf4fbe28ab10ba34bd", "committedDate": "2020-09-18T21:01:02Z", "message": "readme update\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c4b2b63a85ca7891c6af5330acf4f77533401c56", "author": {"user": {"login": "miloit", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/c4b2b63a85ca7891c6af5330acf4f77533401c56", "committedDate": "2020-09-18T21:01:03Z", "message": "files reorganisation\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0b38fff027189a7a8a249004e91d95bbc1a2b95f", "author": {"user": {"login": "miloit", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/0b38fff027189a7a8a249004e91d95bbc1a2b95f", "committedDate": "2020-09-18T21:01:03Z", "message": "package renaming\n\nSigned-off-by: miloit <MichaelLoercher@web.de>\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "64697ad7fb9ed2c0703e422d1c698934dbd41608", "author": {"user": {"login": "miloit", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/64697ad7fb9ed2c0703e422d1c698934dbd41608", "committedDate": "2020-09-18T21:01:03Z", "message": "Signed-off-by: miloit <MichaelLoercher@web.de>\n\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6acd6489da27c8f3f99670757b34dd17ea4da6d2", "author": {"user": {"login": "miloit", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/6acd6489da27c8f3f99670757b34dd17ea4da6d2", "committedDate": "2020-09-18T21:01:03Z", "message": "Signed-off-by: miloit <MichaelLoercher@web.de>\n\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "200461587c5241f52be8561fcb0c175b6e3b1a35", "author": {"user": {"login": "miloit", "name": null}}, "url": "https://github.com/openhab/openhab-addons/commit/200461587c5241f52be8561fcb0c175b6e3b1a35", "committedDate": "2020-09-18T21:01:03Z", "message": "Signed-off-by: miloit <MichaelLoercher@web.de>\n\nSigned-off-by: Michael Loercher <MichaelLoercher@web.de>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDkyMTU1Mjk3", "url": "https://github.com/openhab/openhab-addons/pull/8394#pullrequestreview-492155297", "createdAt": "2020-09-19T20:47:48Z", "commit": {"oid": "200461587c5241f52be8561fcb0c175b6e3b1a35"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4804, "cost": 1, "resetAt": "2021-10-28T20:13:43Z"}}}