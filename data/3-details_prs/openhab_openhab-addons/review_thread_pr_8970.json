{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE3MDk2Nzg5", "number": 8970, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNFQwNToyOToxN1rOE47Xiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNFQwNToyOToxN1rOE47Xiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4MTI4Mzk1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.bluetooth/src/main/java/org/openhab/binding/bluetooth/ConnectedBluetoothHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNFQwNToyOToxN1rOHzIjFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNFQwNToyOToxN1rOHzIjFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzM3OTQ3OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        if (device.connect()) {\n          \n          \n            \n                        if (!device.connect()) {", "url": "https://github.com/openhab/openhab-addons/pull/8970#discussion_r523379479", "createdAt": "2020-11-14T05:29:17Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.bluetooth/src/main/java/org/openhab/binding/bluetooth/ConnectedBluetoothHandler.java", "diffHunk": "@@ -12,108 +12,237 @@\n  */\n package org.openhab.binding.bluetooth;\n \n-import java.util.Set;\n-import java.util.concurrent.CopyOnWriteArraySet;\n-import java.util.concurrent.ScheduledFuture;\n+import java.util.UUID;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledThreadPoolExecutor;\n import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n \n-import org.eclipse.jdt.annotation.DefaultLocation;\n import org.eclipse.jdt.annotation.NonNullByDefault;\n import org.eclipse.jdt.annotation.Nullable;\n-import org.openhab.binding.bluetooth.BluetoothCharacteristic.GattCharacteristic;\n import org.openhab.binding.bluetooth.BluetoothDevice.ConnectionState;\n import org.openhab.binding.bluetooth.notification.BluetoothConnectionStatusNotification;\n-import org.openhab.core.library.types.DecimalType;\n-import org.openhab.core.thing.Channel;\n-import org.openhab.core.thing.ChannelUID;\n-import org.openhab.core.thing.DefaultSystemChannelTypeProvider;\n+import org.openhab.core.common.NamedThreadFactory;\n import org.openhab.core.thing.Thing;\n import org.openhab.core.thing.ThingStatus;\n import org.openhab.core.thing.ThingStatusDetail;\n-import org.openhab.core.thing.binding.builder.ChannelBuilder;\n-import org.openhab.core.thing.binding.builder.ThingBuilder;\n-import org.openhab.core.thing.type.ChannelTypeUID;\n-import org.openhab.core.types.Command;\n-import org.openhab.core.types.RefreshType;\n import org.openhab.core.util.HexUtils;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n /**\n- * This is a handler for generic Bluetooth devices in connected mode, which at the same time can be used\n- * as a base implementation for more specific thing handlers.\n+ * This is a base implementation for more specific thing handlers that require constant connection to bluetooth devices.\n  *\n  * @author Kai Kreuzer - Initial contribution and API\n- *\n  */\n-@NonNullByDefault({ DefaultLocation.PARAMETER, DefaultLocation.RETURN_TYPE, DefaultLocation.ARRAY_CONTENTS,\n-        DefaultLocation.TYPE_ARGUMENT, DefaultLocation.TYPE_BOUND, DefaultLocation.TYPE_PARAMETER })\n+@NonNullByDefault\n public class ConnectedBluetoothHandler extends BeaconBluetoothHandler {\n \n     private final Logger logger = LoggerFactory.getLogger(ConnectedBluetoothHandler.class);\n-    private ScheduledFuture<?> connectionJob;\n+    private @Nullable Future<?> reconnectJob;\n+    private @Nullable Future<?> pendingDisconnect;\n \n-    // internal flag for the service resolution status\n-    protected volatile boolean resolved = false;\n+    private boolean connectOnDemand;\n+    private int idleDisconnectDelay = 1000;\n \n-    protected final Set<BluetoothCharacteristic> deviceCharacteristics = new CopyOnWriteArraySet<>();\n+    private @Nullable ScheduledExecutorService connectionTaskExecutor;\n \n     public ConnectedBluetoothHandler(Thing thing) {\n         super(thing);\n     }\n \n     @Override\n     public void initialize() {\n+\n+        // super.initialize adds callbacks that might require the connectionTaskExecutor to be present, so we initialize\n+        // the connectionTaskExecutor first\n+        ScheduledThreadPoolExecutor executor = new ScheduledThreadPoolExecutor(1,\n+                new NamedThreadFactory(\"bluetooth-connection\" + thing.getThingTypeUID(), true));\n+        connectionTaskExecutor = executor;\n+\n         super.initialize();\n \n-        connectionJob = scheduler.scheduleWithFixedDelay(() -> {\n-            if (device.getConnectionState() != ConnectionState.CONNECTED) {\n-                device.connect();\n-                // we do not set the Thing status here, because we will anyhow receive a call to onConnectionStateChange\n-            }\n-            updateRSSI();\n-        }, 0, 30, TimeUnit.SECONDS);\n+        Object connectOnDemandRaw = getConfig().get(BluetoothBindingConstants.CONFIGURATION_CONNECT_ON_DEMAND);\n+        connectOnDemand = Boolean.TRUE.equals(connectOnDemandRaw);\n+\n+        Object idleDisconnectDelayRaw = getConfig().get(BluetoothBindingConstants.CONFIGURATION_IDLE_DISCONNECT_DELAY);\n+        idleDisconnectDelay = 1000;\n+        if (idleDisconnectDelayRaw instanceof Number) {\n+            idleDisconnectDelay = ((Number) idleDisconnectDelayRaw).intValue();\n+        }\n+\n+        if (!connectOnDemand) {\n+            reconnectJob = executor.scheduleWithFixedDelay(() -> {\n+                try {\n+                    if (device.getConnectionState() != ConnectionState.CONNECTED) {\n+                        device.connect();\n+                        // we do not set the Thing status here, because we will anyhow receive a call to\n+                        // onConnectionStateChange\n+                    } else {\n+                        // just in case it was already connected to begin with\n+                        updateStatus(ThingStatus.ONLINE);\n+                        if (!device.isServicesDiscovered() && !device.discoverServices()) {\n+                            logger.debug(\"Error while discovering services\");\n+                        }\n+                    }\n+                } catch (RuntimeException ex) {\n+                    logger.warn(\"Unexpected error occurred\", ex);\n+                }\n+            }, 0, 30, TimeUnit.SECONDS);\n+        }\n     }\n \n     @Override\n     public void dispose() {\n-        if (connectionJob != null) {\n-            connectionJob.cancel(true);\n-            connectionJob = null;\n+        cancel(reconnectJob);\n+        reconnectJob = null;\n+        cancel(pendingDisconnect);\n+        pendingDisconnect = null;\n+\n+        super.dispose();\n+\n+        shutdown(connectionTaskExecutor);\n+        connectionTaskExecutor = null;\n+    }\n+\n+    private static void cancel(@Nullable Future<?> future) {\n+        if (future != null) {\n+            future.cancel(true);\n         }\n-        scheduler.submit(() -> {\n-            try {\n-                deviceLock.lock();\n-                if (device != null) {\n-                    device.removeListener(this);\n-                    device.disconnect();\n-                    device = null;\n-                }\n-            } finally {\n-                deviceLock.unlock();\n+    }\n+\n+    private void shutdown(@Nullable ScheduledExecutorService executor) {\n+        if (executor != null) {\n+            executor.shutdownNow();\n+        }\n+    }\n+\n+    private ScheduledExecutorService getConnectionTaskExecutor() {\n+        var executor = connectionTaskExecutor;\n+        if (executor == null) {\n+            throw new IllegalStateException(\"characteristicScheduler has not been initialized\");\n+        }\n+        return executor;\n+    }\n+\n+    private void scheduleDisconnect() {\n+        cancel(pendingDisconnect);\n+        pendingDisconnect = getConnectionTaskExecutor().schedule(device::disconnect, idleDisconnectDelay,\n+                TimeUnit.MILLISECONDS);\n+    }\n+\n+    private void connectAndWait() throws ConnectionException, TimeoutException, InterruptedException {\n+        if (device.getConnectionState() == ConnectionState.CONNECTED) {\n+            return;\n+        }\n+        if (device.getConnectionState() != ConnectionState.CONNECTING) {\n+            if (device.connect()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e16984aedfb7a3e193818d612bee3b0b09ab4007"}, "originalPosition": 174}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4049, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}