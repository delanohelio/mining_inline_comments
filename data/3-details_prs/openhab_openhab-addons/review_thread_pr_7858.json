{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI4MTIxNTAy", "number": 7858, "reviewThreads": {"totalCount": 28, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMjo1MToxMlrOECwqfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNzowMjozOFrOEGb-cg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMzI5OTE4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationHandlerFactory.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMjo1MToxMlrOGfam1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwNToyNDoyMlrOGfgy8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU5NDk2NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private @NonNullByDefault({}) SerialPortManager serialPortManager;\n          \n          \n            \n                private SerialPortManager serialPortManager;", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r435594964", "createdAt": "2020-06-04T22:51:12Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationHandlerFactory.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import static org.openhab.binding.heliosventilation.internal.HeliosVentilationBindingConstants.THING_TYPE_HELIOS_VENTILATION;\n+\n+import java.util.Collections;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link HeliosVentilationHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(configurationPid = \"binding.heliosventilation\", service = ThingHandlerFactory.class)\n+public class HeliosVentilationHandlerFactory extends BaseThingHandlerFactory {\n+\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections\n+            .singleton(THING_TYPE_HELIOS_VENTILATION);\n+\n+    private @NonNullByDefault({}) SerialPortManager serialPortManager;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "361703be6950354911240a431cfdce7604537cb6"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY5NjM3MQ==", "bodyText": "Can be final", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r435696371", "createdAt": "2020-06-05T05:24:22Z", "author": {"login": "Hilbrand"}, "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationHandlerFactory.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import static org.openhab.binding.heliosventilation.internal.HeliosVentilationBindingConstants.THING_TYPE_HELIOS_VENTILATION;\n+\n+import java.util.Collections;\n+import java.util.Set;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandlerFactory;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandler;\n+import org.eclipse.smarthome.core.thing.binding.ThingHandlerFactory;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.component.annotations.Component;\n+import org.osgi.service.component.annotations.Reference;\n+\n+/**\n+ * The {@link HeliosVentilationHandlerFactory} is responsible for creating things and thing\n+ * handlers.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+@Component(configurationPid = \"binding.heliosventilation\", service = ThingHandlerFactory.class)\n+public class HeliosVentilationHandlerFactory extends BaseThingHandlerFactory {\n+\n+    private static final Set<ThingTypeUID> SUPPORTED_THING_TYPES_UIDS = Collections\n+            .singleton(THING_TYPE_HELIOS_VENTILATION);\n+\n+    private @NonNullByDefault({}) SerialPortManager serialPortManager;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU5NDk2NA=="}, "originalCommit": {"oid": "361703be6950354911240a431cfdce7604537cb6"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMzMxNDYxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQyMjo1Nzo1OFrOGfavqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMDoxMTozMlrOGf8ATA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU5NzIyNQ==", "bodyText": "Why do you need to sleep here? Does InputStream.read not block for input?", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r435597225", "createdAt": "2020-06-04T22:57:58Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationHandler.java", "diffHunk": "@@ -0,0 +1,438 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.lang.invoke.MethodHandles;\n+import java.util.HashMap;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HeliosVentilationHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosVentilationHandler extends BaseThingHandler implements SerialPortEventListener {\n+    private static final int BUSMEMBER_MAINBOARD = 0x11;\n+    private static final int BUSMEMBER_SLAVEBOARDS = 0x10;\n+    private static final byte BUSMEMBER_CONTROLBOARDS = (byte) 0x20;\n+    private static final int BUSMEMBER_REC_MASK = 0xF0; // interpreting frames delivered to BUSMEMBER_ME &\n+                                                        // BUSMEMBER_REC_MASK\n+    private static final int BUSMEMBER_ME = 0x2F; // used as sender when communicating with the helios system\n+    private static final int POLL_OFFLINE_THRESHOLD = 3;\n+\n+    /** Logger Instance */\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private @NonNullByDefault({}) HeliosVentilationConfiguration config;\n+\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable SerialPort serialPort;\n+    private @Nullable InputStream inputStream;\n+    private @Nullable OutputStream outputStream;\n+\n+    private @Nullable ScheduledFuture<?> pollingTask;\n+    private int pollCounter;\n+\n+    /**\n+     * store received data for read-modify-write operations on bitlevel\n+     */\n+    private HashMap<Byte, Byte> memory = new HashMap<Byte, Byte>();\n+\n+    public HeliosVentilationHandler(Thing thing, final SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(HeliosVentilationConfiguration.class);\n+\n+        logger.debug(\"Serial Port: {}, 9600 baud, PollPeriod: {}\", config.serialPort, config.pollPeriod);\n+\n+        if (config.serialPort.length() < 1) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port must be set!\");\n+            return;\n+        } else {\n+            updateStatus(ThingStatus.UNKNOWN);\n+            if (this.config.pollPeriod > 0) {\n+                startPolling();\n+            }\n+        }\n+\n+        scheduler.execute(this::connect);\n+    }\n+\n+    private synchronized void connect() {\n+        logger.debug(\"HeliosVentilation: connecting...\");\n+        // parse ports and if the port is found, initialize the reader\n+        SerialPortIdentifier portId = serialPortManager.getIdentifier(config.serialPort);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Port \" + config.serialPort + \" is not known!\");\n+            serialPort = null;\n+            IOUtils.closeQuietly(inputStream);\n+            IOUtils.closeQuietly(outputStream);\n+        } else if (!isConnected()) {\n+            // initialize serial port\n+            try {\n+                SerialPort serial = portId.open(getThing().getUID().toString(), 2000);\n+                serial.setSerialPortParams(9600, SerialPort.DATABITS_8, SerialPort.STOPBITS_1, SerialPort.PARITY_NONE);\n+                serial.addEventListener(this);\n+\n+                IOUtils.closeQuietly(inputStream);\n+                IOUtils.closeQuietly(outputStream);\n+                inputStream = serial.getInputStream();\n+                outputStream = serial.getOutputStream();\n+\n+                // activate the DATA_AVAILABLE notifier\n+                serial.notifyOnDataAvailable(true);\n+                serialPort = serial;\n+                updateStatus(ThingStatus.UNKNOWN);\n+            } catch (final IOException ex) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"I/O error!\");\n+            } catch (PortInUseException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"Port is in use!\");\n+            } catch (TooManyListenersException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Cannot attach listener to port!\");\n+            } catch (UnsupportedCommOperationException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Serial port does not support the RS485 parameters of the Helios remote protocol.\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        stopPolling();\n+        disconnect();\n+        super.dispose();\n+    }\n+\n+    /**\n+     * Start the polling task.\n+     */\n+    public synchronized void startPolling() {\n+        final ScheduledFuture<?> task = pollingTask;\n+        if (task != null && task.isCancelled()) {\n+            task.cancel(true);\n+        }\n+        if (config.pollPeriod > 0) {\n+            pollingTask = scheduler.scheduleWithFixedDelay(this::polling, 10, config.pollPeriod, TimeUnit.SECONDS);\n+        } else {\n+            pollingTask = null;\n+        }\n+    }\n+\n+    /**\n+     * Stop the polling task.\n+     */\n+    public synchronized void stopPolling() {\n+        final ScheduledFuture<?> task = pollingTask;\n+        if (task != null && !task.isCancelled()) {\n+            task.cancel(true);\n+            pollingTask = null;\n+        }\n+    }\n+\n+    /**\n+     * Method for polling the RS485 Helios RemoteContol bus\n+     */\n+    public synchronized void polling() {\n+        if (logger.isTraceEnabled()) {\n+            logger.trace(\"HeliosVentilation Polling data for '{}'\", getThing().getUID());\n+        }\n+        pollCounter++;\n+        if (pollCounter > POLL_OFFLINE_THRESHOLD) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.GONE, \"No data received!\");\n+            logger.info(\"No data received for '{}' disconnecting now...\", getThing().getUID());\n+            disconnect();\n+        }\n+\n+        if (!isConnected()) {\n+            connect(); // let's try to reconnect if the connection failed or was never established before\n+        }\n+\n+        HeliosVentilationBindingConstants.DATAPOINTS.values().forEach((v) -> {\n+            if (isLinked(v.getName())) {\n+                poll(v);\n+            }\n+        });\n+    }\n+\n+    private void disconnect() {\n+        if (thing.getStatus() != ThingStatus.REMOVING) {\n+            updateStatus(ThingStatus.OFFLINE);\n+        }\n+        synchronized (this) {\n+            SerialPort serial = serialPort;\n+            if (serial != null) {\n+                serial.close();\n+            }\n+        }\n+        IOUtils.closeQuietly(inputStream);\n+        IOUtils.closeQuietly(outputStream);\n+        outputStream = null;\n+        inputStream = null;\n+        serialPort = null;\n+    }\n+\n+    private void poll(HeliosVentilationDataPoint v) {\n+        byte txFrame[] = { 0x01, BUSMEMBER_ME, BUSMEMBER_MAINBOARD, 0x00, v.address(), 0x00 };\n+        txFrame[5] = (byte) checksum(txFrame);\n+\n+        tx(txFrame);\n+    }\n+\n+    /*\n+     * transmit a frame\n+     */\n+    private void tx(byte[] txFrame) {\n+        try {\n+            OutputStream out = outputStream;\n+            if (out != null) {\n+                if (logger.isTraceEnabled()) {\n+                    logger.trace(\"HeliosVentilation: Write to serial port: {}\",\n+                            String.format(\"%02x %02x %02x %02x\", txFrame[1], txFrame[2], txFrame[3], txFrame[4]));\n+                }\n+\n+                out.write(txFrame);\n+                out.flush();\n+                // after each frame we have to wait.\n+                // 30 ms is taken from what we roughly see the original remote control is doing\n+                Thread.sleep(30);\n+            }\n+        } catch (IOException e) {\n+            // in case we cannot write the connection is somehow broken, let's officially disconnect\n+            disconnect();\n+            connect();\n+        } catch (InterruptedException e) {\n+            // ignore if we got interrupted\n+        }\n+    }\n+\n+    /**\n+     * Check connection status\n+     *\n+     * @return true if currently connected\n+     */\n+    private boolean isConnected() {\n+        return serialPort != null && inputStream != null && outputStream != null;\n+    }\n+\n+    @Override\n+    public synchronized void serialEvent(SerialPortEvent event) {\n+        switch (event.getEventType()) {\n+            case SerialPortEvent.DATA_AVAILABLE:\n+                // we get here if data has been received\n+\n+                try {\n+                    // Wait roughly a frame length to increase the likelihood that the complete frame is already\n+                    // buffered. This improves the robustness for RS485/USB converters which sometimes duplicate bytes\n+                    // otherwise\n+                    Thread.sleep(8);\n+                } catch (InterruptedException e) {\n+                    // ignore interruption\n+                }\n+\n+                byte frame[] = { 0, 0, 0, 0, 0, 0 };\n+                InputStream in = inputStream;\n+                if (in != null) {\n+                    try {\n+                        do {\n+                            int cnt = 0;\n+                            do {\n+                                // read data from serial device\n+                                while (cnt < 6 && in.available() > 0) {\n+                                    final int bytes = in.read(frame, cnt, 1);\n+                                    if (cnt > 0 || frame[0] == 0x01) {\n+                                        // only proceed if the first byte was 0x01\n+                                        cnt += bytes;\n+                                    }\n+                                }\n+\n+                                if (cnt < 6 && in.available() < 1) {\n+                                    // frame not yet complete but no input available, let's wait a little to merge\n+                                    // interrupted transmissions\n+\n+                                    // 9600 baud yields about 1ms per byte, so let's wait the expected remaining time\n+                                    // for a frame\n+                                    try {\n+                                        Thread.sleep(1 * (6 - cnt));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "361703be6950354911240a431cfdce7604537cb6"}, "originalPosition": 303}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE0MjE1Ng==", "bodyText": "good point. It is a relic from the early times, which I even reworked recently but I agree that it is not needed at all. Will remove it.", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r436142156", "createdAt": "2020-06-05T20:11:32Z", "author": {"login": "ramack"}, "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationHandler.java", "diffHunk": "@@ -0,0 +1,438 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.lang.invoke.MethodHandles;\n+import java.util.HashMap;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HeliosVentilationHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosVentilationHandler extends BaseThingHandler implements SerialPortEventListener {\n+    private static final int BUSMEMBER_MAINBOARD = 0x11;\n+    private static final int BUSMEMBER_SLAVEBOARDS = 0x10;\n+    private static final byte BUSMEMBER_CONTROLBOARDS = (byte) 0x20;\n+    private static final int BUSMEMBER_REC_MASK = 0xF0; // interpreting frames delivered to BUSMEMBER_ME &\n+                                                        // BUSMEMBER_REC_MASK\n+    private static final int BUSMEMBER_ME = 0x2F; // used as sender when communicating with the helios system\n+    private static final int POLL_OFFLINE_THRESHOLD = 3;\n+\n+    /** Logger Instance */\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private @NonNullByDefault({}) HeliosVentilationConfiguration config;\n+\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable SerialPort serialPort;\n+    private @Nullable InputStream inputStream;\n+    private @Nullable OutputStream outputStream;\n+\n+    private @Nullable ScheduledFuture<?> pollingTask;\n+    private int pollCounter;\n+\n+    /**\n+     * store received data for read-modify-write operations on bitlevel\n+     */\n+    private HashMap<Byte, Byte> memory = new HashMap<Byte, Byte>();\n+\n+    public HeliosVentilationHandler(Thing thing, final SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(HeliosVentilationConfiguration.class);\n+\n+        logger.debug(\"Serial Port: {}, 9600 baud, PollPeriod: {}\", config.serialPort, config.pollPeriod);\n+\n+        if (config.serialPort.length() < 1) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port must be set!\");\n+            return;\n+        } else {\n+            updateStatus(ThingStatus.UNKNOWN);\n+            if (this.config.pollPeriod > 0) {\n+                startPolling();\n+            }\n+        }\n+\n+        scheduler.execute(this::connect);\n+    }\n+\n+    private synchronized void connect() {\n+        logger.debug(\"HeliosVentilation: connecting...\");\n+        // parse ports and if the port is found, initialize the reader\n+        SerialPortIdentifier portId = serialPortManager.getIdentifier(config.serialPort);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Port \" + config.serialPort + \" is not known!\");\n+            serialPort = null;\n+            IOUtils.closeQuietly(inputStream);\n+            IOUtils.closeQuietly(outputStream);\n+        } else if (!isConnected()) {\n+            // initialize serial port\n+            try {\n+                SerialPort serial = portId.open(getThing().getUID().toString(), 2000);\n+                serial.setSerialPortParams(9600, SerialPort.DATABITS_8, SerialPort.STOPBITS_1, SerialPort.PARITY_NONE);\n+                serial.addEventListener(this);\n+\n+                IOUtils.closeQuietly(inputStream);\n+                IOUtils.closeQuietly(outputStream);\n+                inputStream = serial.getInputStream();\n+                outputStream = serial.getOutputStream();\n+\n+                // activate the DATA_AVAILABLE notifier\n+                serial.notifyOnDataAvailable(true);\n+                serialPort = serial;\n+                updateStatus(ThingStatus.UNKNOWN);\n+            } catch (final IOException ex) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"I/O error!\");\n+            } catch (PortInUseException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"Port is in use!\");\n+            } catch (TooManyListenersException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Cannot attach listener to port!\");\n+            } catch (UnsupportedCommOperationException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Serial port does not support the RS485 parameters of the Helios remote protocol.\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        stopPolling();\n+        disconnect();\n+        super.dispose();\n+    }\n+\n+    /**\n+     * Start the polling task.\n+     */\n+    public synchronized void startPolling() {\n+        final ScheduledFuture<?> task = pollingTask;\n+        if (task != null && task.isCancelled()) {\n+            task.cancel(true);\n+        }\n+        if (config.pollPeriod > 0) {\n+            pollingTask = scheduler.scheduleWithFixedDelay(this::polling, 10, config.pollPeriod, TimeUnit.SECONDS);\n+        } else {\n+            pollingTask = null;\n+        }\n+    }\n+\n+    /**\n+     * Stop the polling task.\n+     */\n+    public synchronized void stopPolling() {\n+        final ScheduledFuture<?> task = pollingTask;\n+        if (task != null && !task.isCancelled()) {\n+            task.cancel(true);\n+            pollingTask = null;\n+        }\n+    }\n+\n+    /**\n+     * Method for polling the RS485 Helios RemoteContol bus\n+     */\n+    public synchronized void polling() {\n+        if (logger.isTraceEnabled()) {\n+            logger.trace(\"HeliosVentilation Polling data for '{}'\", getThing().getUID());\n+        }\n+        pollCounter++;\n+        if (pollCounter > POLL_OFFLINE_THRESHOLD) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.GONE, \"No data received!\");\n+            logger.info(\"No data received for '{}' disconnecting now...\", getThing().getUID());\n+            disconnect();\n+        }\n+\n+        if (!isConnected()) {\n+            connect(); // let's try to reconnect if the connection failed or was never established before\n+        }\n+\n+        HeliosVentilationBindingConstants.DATAPOINTS.values().forEach((v) -> {\n+            if (isLinked(v.getName())) {\n+                poll(v);\n+            }\n+        });\n+    }\n+\n+    private void disconnect() {\n+        if (thing.getStatus() != ThingStatus.REMOVING) {\n+            updateStatus(ThingStatus.OFFLINE);\n+        }\n+        synchronized (this) {\n+            SerialPort serial = serialPort;\n+            if (serial != null) {\n+                serial.close();\n+            }\n+        }\n+        IOUtils.closeQuietly(inputStream);\n+        IOUtils.closeQuietly(outputStream);\n+        outputStream = null;\n+        inputStream = null;\n+        serialPort = null;\n+    }\n+\n+    private void poll(HeliosVentilationDataPoint v) {\n+        byte txFrame[] = { 0x01, BUSMEMBER_ME, BUSMEMBER_MAINBOARD, 0x00, v.address(), 0x00 };\n+        txFrame[5] = (byte) checksum(txFrame);\n+\n+        tx(txFrame);\n+    }\n+\n+    /*\n+     * transmit a frame\n+     */\n+    private void tx(byte[] txFrame) {\n+        try {\n+            OutputStream out = outputStream;\n+            if (out != null) {\n+                if (logger.isTraceEnabled()) {\n+                    logger.trace(\"HeliosVentilation: Write to serial port: {}\",\n+                            String.format(\"%02x %02x %02x %02x\", txFrame[1], txFrame[2], txFrame[3], txFrame[4]));\n+                }\n+\n+                out.write(txFrame);\n+                out.flush();\n+                // after each frame we have to wait.\n+                // 30 ms is taken from what we roughly see the original remote control is doing\n+                Thread.sleep(30);\n+            }\n+        } catch (IOException e) {\n+            // in case we cannot write the connection is somehow broken, let's officially disconnect\n+            disconnect();\n+            connect();\n+        } catch (InterruptedException e) {\n+            // ignore if we got interrupted\n+        }\n+    }\n+\n+    /**\n+     * Check connection status\n+     *\n+     * @return true if currently connected\n+     */\n+    private boolean isConnected() {\n+        return serialPort != null && inputStream != null && outputStream != null;\n+    }\n+\n+    @Override\n+    public synchronized void serialEvent(SerialPortEvent event) {\n+        switch (event.getEventType()) {\n+            case SerialPortEvent.DATA_AVAILABLE:\n+                // we get here if data has been received\n+\n+                try {\n+                    // Wait roughly a frame length to increase the likelihood that the complete frame is already\n+                    // buffered. This improves the robustness for RS485/USB converters which sometimes duplicate bytes\n+                    // otherwise\n+                    Thread.sleep(8);\n+                } catch (InterruptedException e) {\n+                    // ignore interruption\n+                }\n+\n+                byte frame[] = { 0, 0, 0, 0, 0, 0 };\n+                InputStream in = inputStream;\n+                if (in != null) {\n+                    try {\n+                        do {\n+                            int cnt = 0;\n+                            do {\n+                                // read data from serial device\n+                                while (cnt < 6 && in.available() > 0) {\n+                                    final int bytes = in.read(frame, cnt, 1);\n+                                    if (cnt > 0 || frame[0] == 0x01) {\n+                                        // only proceed if the first byte was 0x01\n+                                        cnt += bytes;\n+                                    }\n+                                }\n+\n+                                if (cnt < 6 && in.available() < 1) {\n+                                    // frame not yet complete but no input available, let's wait a little to merge\n+                                    // interrupted transmissions\n+\n+                                    // 9600 baud yields about 1ms per byte, so let's wait the expected remaining time\n+                                    // for a frame\n+                                    try {\n+                                        Thread.sleep(1 * (6 - cnt));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU5NzIyNQ=="}, "originalCommit": {"oid": "361703be6950354911240a431cfdce7604537cb6"}, "originalPosition": 303}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMzUwNTE2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwMDozMTo1OVrOGfcqyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwMDozMTo1OVrOGfcqyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYyODc0NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private HashMap<Byte, Byte> memory = new HashMap<Byte, Byte>();\n          \n          \n            \n                private Map<Byte, Byte> memory = new HashMap<>();", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r435628745", "createdAt": "2020-06-05T00:31:59Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationHandler.java", "diffHunk": "@@ -0,0 +1,438 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.lang.invoke.MethodHandles;\n+import java.util.HashMap;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HeliosVentilationHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosVentilationHandler extends BaseThingHandler implements SerialPortEventListener {\n+    private static final int BUSMEMBER_MAINBOARD = 0x11;\n+    private static final int BUSMEMBER_SLAVEBOARDS = 0x10;\n+    private static final byte BUSMEMBER_CONTROLBOARDS = (byte) 0x20;\n+    private static final int BUSMEMBER_REC_MASK = 0xF0; // interpreting frames delivered to BUSMEMBER_ME &\n+                                                        // BUSMEMBER_REC_MASK\n+    private static final int BUSMEMBER_ME = 0x2F; // used as sender when communicating with the helios system\n+    private static final int POLL_OFFLINE_THRESHOLD = 3;\n+\n+    /** Logger Instance */\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private @NonNullByDefault({}) HeliosVentilationConfiguration config;\n+\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable SerialPort serialPort;\n+    private @Nullable InputStream inputStream;\n+    private @Nullable OutputStream outputStream;\n+\n+    private @Nullable ScheduledFuture<?> pollingTask;\n+    private int pollCounter;\n+\n+    /**\n+     * store received data for read-modify-write operations on bitlevel\n+     */\n+    private HashMap<Byte, Byte> memory = new HashMap<Byte, Byte>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "361703be6950354911240a431cfdce7604537cb6"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMzUwODU5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosPropertiesFormatException.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwMDozNDoxOVrOGfcs3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwMDozNDoxOVrOGfcs3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTYyOTI3OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private String channelName;\n          \n          \n            \n                private String fullSpec;\n          \n          \n            \n                private String reason;\n          \n          \n            \n                private final String channelName;\n          \n          \n            \n                private final String fullSpec;\n          \n          \n            \n                private final String reason;", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r435629278", "createdAt": "2020-06-05T00:34:19Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosPropertiesFormatException.java", "diffHunk": "@@ -0,0 +1,47 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+\n+/**\n+ * The {@link HeliosPropertiesFormatException} class defines an exception to describe parsing format errors\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosPropertiesFormatException extends Exception {\n+    private static final long serialVersionUID = 8051109351111509577L;\n+    private String channelName;\n+    private String fullSpec;\n+    private String reason;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "361703be6950354911240a431cfdce7604537cb6"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMzkxNjQ0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.heliosventilation/src/main/resources/datapoints.properties", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwNTowOTo0MVrOGfglZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMDoxNTo0N1rOGf8G4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY5MjkwMA==", "bodyText": "Is there a reason that you didn't store this data as an enum in the source code?", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r435692900", "createdAt": "2020-06-05T05:09:41Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.heliosventilation/src/main/resources/datapoints.properties", "diffHunk": "@@ -0,0 +1,48 @@\n+#\n+# datapoints.properties - This file defines the datapoints of the Helios ventilation system\n+#\n+# Format: <name> = <address(:bitspec)>,writable,type\n+#\n+#         bitspec is\n+#         - a single digit in range 0-7 or\n+#         - start:end (where start is the number of the LSB and end the number of the MSB of the field)\n+#\n+#         type is one of\n+#         - TEMPERATURE\n+#         - FANSPEED\n+#         - PERCENT\n+#         - BYTE_PERCENT\n+#         - SWITCH\n+#         - NUMBER\n+#         - HYSTERESIS\n+#\n+# on change of this file, ensure that the thing-types.xml is consistent\n+\n+fanspeed = 0x29,true,FANSPEED", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "361703be6950354911240a431cfdce7604537cb6"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE0Mzg0Mg==", "bodyText": "initially it was hardcoded, but during the reviews of the first version of this PR (#5831) it was recommended to move it into a properties file.", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r436143842", "createdAt": "2020-06-05T20:15:47Z", "author": {"login": "ramack"}, "path": "bundles/org.openhab.binding.heliosventilation/src/main/resources/datapoints.properties", "diffHunk": "@@ -0,0 +1,48 @@\n+#\n+# datapoints.properties - This file defines the datapoints of the Helios ventilation system\n+#\n+# Format: <name> = <address(:bitspec)>,writable,type\n+#\n+#         bitspec is\n+#         - a single digit in range 0-7 or\n+#         - start:end (where start is the number of the LSB and end the number of the MSB of the field)\n+#\n+#         type is one of\n+#         - TEMPERATURE\n+#         - FANSPEED\n+#         - PERCENT\n+#         - BYTE_PERCENT\n+#         - SWITCH\n+#         - NUMBER\n+#         - HYSTERESIS\n+#\n+# on change of this file, ensure that the thing-types.xml is consistent\n+\n+fanspeed = 0x29,true,FANSPEED", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY5MjkwMA=="}, "originalCommit": {"oid": "361703be6950354911240a431cfdce7604537cb6"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMzkyMDU4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwNToxMjoxN1rOGfgn5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwNToxMjoxN1rOGfgn5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY5MzU0MQ==", "bodyText": "We are trying to migrate away from using the apache util libraries. Can you implement this without using IOUtils?", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r435693541", "createdAt": "2020-06-05T05:12:17Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationHandler.java", "diffHunk": "@@ -0,0 +1,438 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.lang.invoke.MethodHandles;\n+import java.util.HashMap;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HeliosVentilationHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosVentilationHandler extends BaseThingHandler implements SerialPortEventListener {\n+    private static final int BUSMEMBER_MAINBOARD = 0x11;\n+    private static final int BUSMEMBER_SLAVEBOARDS = 0x10;\n+    private static final byte BUSMEMBER_CONTROLBOARDS = (byte) 0x20;\n+    private static final int BUSMEMBER_REC_MASK = 0xF0; // interpreting frames delivered to BUSMEMBER_ME &\n+                                                        // BUSMEMBER_REC_MASK\n+    private static final int BUSMEMBER_ME = 0x2F; // used as sender when communicating with the helios system\n+    private static final int POLL_OFFLINE_THRESHOLD = 3;\n+\n+    /** Logger Instance */\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private @NonNullByDefault({}) HeliosVentilationConfiguration config;\n+\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable SerialPort serialPort;\n+    private @Nullable InputStream inputStream;\n+    private @Nullable OutputStream outputStream;\n+\n+    private @Nullable ScheduledFuture<?> pollingTask;\n+    private int pollCounter;\n+\n+    /**\n+     * store received data for read-modify-write operations on bitlevel\n+     */\n+    private HashMap<Byte, Byte> memory = new HashMap<Byte, Byte>();\n+\n+    public HeliosVentilationHandler(Thing thing, final SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(HeliosVentilationConfiguration.class);\n+\n+        logger.debug(\"Serial Port: {}, 9600 baud, PollPeriod: {}\", config.serialPort, config.pollPeriod);\n+\n+        if (config.serialPort.length() < 1) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port must be set!\");\n+            return;\n+        } else {\n+            updateStatus(ThingStatus.UNKNOWN);\n+            if (this.config.pollPeriod > 0) {\n+                startPolling();\n+            }\n+        }\n+\n+        scheduler.execute(this::connect);\n+    }\n+\n+    private synchronized void connect() {\n+        logger.debug(\"HeliosVentilation: connecting...\");\n+        // parse ports and if the port is found, initialize the reader\n+        SerialPortIdentifier portId = serialPortManager.getIdentifier(config.serialPort);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Port \" + config.serialPort + \" is not known!\");\n+            serialPort = null;\n+            IOUtils.closeQuietly(inputStream);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "361703be6950354911240a431cfdce7604537cb6"}, "originalPosition": 115}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxMzkyNjE5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationDataPoint.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwNToxNTo0N1rOGfgrEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQyMTo1ODo1OVrOGf-dlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY5NDM1Mg==", "bodyText": "I'm not sure that this does a proper conversion if the QuantityType supplied here is of an unexpected unit.", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r435694352", "createdAt": "2020-06-05T05:15:47Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationDataPoint.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+\n+/**\n+ * The {@link HeliosVentilationDataPoint} is a description of a datapoint in the Helios ventilation system.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosVentilationDataPoint {\n+    public enum DataType {\n+        TEMPERATURE,\n+        HYSTERESIS,\n+        FANSPEED,\n+        SWITCH,\n+        BYTE_PERCENT,\n+        PERCENT,\n+        NUMBER\n+    }\n+\n+    /**\n+     * mapping from temperature byte values to \u00b0C\n+     */\n+    private static final int TEMP_MAP[] = { -74, -70, -66, -62, -59, -56, -54, -52, -50, -48, -47, -46, -44, -43, -42,\n+            -41, -40, -39, -38, -37, -36, -35, -34, -33, -33, -32, -31, -30, -30, -29, -28, -28, -27, -27, -26, -25,\n+            -25, -24, -24, -23, -23, -22, -22, -21, -21, -20, -20, -19, -19, -19, -18, -18, -17, -17, -16, -16, -16,\n+            -15, -15, -14, -14, -14, -13, -13, -12, -12, -12, -11, -11, -11, -10, -10, -9, -9, -9, -8, -8, -8, -7, -7,\n+            -7, -6, -6, -6, -5, -5, -5, -4, -4, -4, -3, -3, -3, -2, -2, -2, -1, -1, -1, -1, 0, 0, 0, 1, 1, 1, 2, 2, 2,\n+            3, 3, 3, 4, 4, 4, 5, 5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 13,\n+            13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 18, 18, 18, 19, 19, 19, 20, 20, 21, 21, 21, 22, 22, 22,\n+            23, 23, 24, 24, 24, 25, 25, 26, 26, 27, 27, 27, 28, 28, 29, 29, 30, 30, 31, 31, 32, 32, 33, 33, 34, 34, 35,\n+            35, 36, 36, 37, 37, 38, 38, 39, 40, 40, 41, 41, 42, 43, 43, 44, 45, 45, 46, 47, 48, 48, 49, 50, 51, 52, 53,\n+            53, 54, 55, 56, 57, 59, 60, 61, 62, 63, 65, 66, 68, 69, 71, 73, 75, 77, 79, 81, 82, 86, 90, 93, 97, 100,\n+            100, 100, 100, 100, 100, 100, 100, 100 };\n+\n+    /**\n+     * mapping from human readable fanspeed to raw value\n+     */\n+    private static final int FANSPEED_MAP[] = { 0, 1, 3, 7, 15, 31, 63, 127, 255 };\n+\n+    private static final int BYTE_PERCENT_OFFSET = 52;\n+\n+    private String name;\n+    private boolean writable;\n+    private DataType datatype;\n+    private byte address;\n+    private int bitStart;\n+    private int bitLength;\n+\n+    private @Nullable HeliosVentilationDataPoint link;\n+\n+    /**\n+     * parse fullSpec in the properties format to declare a datapoint\n+     *\n+     * @param name the name of the datapoint\n+     * @param fullSpec datapoint specification, see format in datapoints.properties\n+     * @throws HeliosPropertiesFormatException in case fullSpec is not parsable\n+     */\n+    public HeliosVentilationDataPoint(String name, String fullSpec) throws HeliosPropertiesFormatException {\n+        String specWithoutComment;\n+        if (fullSpec.contains(\"#\")) {\n+            specWithoutComment = fullSpec.substring(0, fullSpec.indexOf(\"#\"));\n+        } else {\n+            specWithoutComment = fullSpec;\n+        }\n+        String[] tokens = specWithoutComment.split(\",\");\n+        this.name = name;\n+        if (tokens.length != 3) {\n+            throw new HeliosPropertiesFormatException(\"invalid length\", name, fullSpec);\n+        }\n+        try {\n+            String addr = tokens[0];\n+            String[] addrTokens;\n+            if (addr.contains(\":\")) {\n+                addrTokens = addr.split(\":\");\n+            } else {\n+                addrTokens = new String[] { addr };\n+            }\n+            bitLength = 8;\n+            bitStart = 0;\n+            this.address = (byte) (int) Integer.decode(addrTokens[0]);\n+            if (addrTokens.length > 1) {\n+                bitStart = (byte) (int) Integer.decode(addrTokens[1]);\n+                bitLength = 1;\n+            }\n+            if (addrTokens.length > 2) {\n+                bitLength = (byte) (int) Integer.decode(addrTokens[2]) - bitStart + 1;\n+            }\n+            if (addrTokens.length > 3) {\n+                throw new HeliosPropertiesFormatException(\n+                        \"invalid address spec: too many separators in bit specification\", name, fullSpec);\n+            }\n+        } catch (NumberFormatException e) {\n+            throw new HeliosPropertiesFormatException(\"invalid address spec\", name, fullSpec);\n+        }\n+\n+        this.writable = Boolean.parseBoolean(tokens[1]);\n+        try {\n+            this.datatype = DataType.valueOf(tokens[2].replaceAll(\"\\\\s+\", \"\"));\n+        } catch (IllegalArgumentException e) {\n+            throw new HeliosPropertiesFormatException(\"invalid type spec\", name, fullSpec);\n+        }\n+    }\n+\n+    public HeliosVentilationDataPoint(String name, byte address, boolean writable, DataType datatype) {\n+        this.datatype = datatype;\n+        this.writable = writable;\n+        this.name = name;\n+        this.address = address;\n+    }\n+\n+    public boolean isWritable() {\n+        return writable;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return name;\n+    }\n+\n+    /**\n+     *\n+     * @return the name of the variable, which is also the channel name\n+     */\n+    public String getName() {\n+        return name;\n+    }\n+\n+    /**\n+     *\n+     * @return address of the variable\n+     */\n+    public byte address() {\n+        return address;\n+    }\n+\n+    /**\n+     * @return the bit mask of the data point. 0xFF in case the full byte is used.\n+     */\n+    public byte bitMask() {\n+        byte mask = (byte) 0xff;\n+        if (datatype == DataType.NUMBER || datatype == DataType.SWITCH) {\n+            mask = (byte) (((1 << bitLength) - 1) << bitStart);\n+        }\n+        return mask;\n+    }\n+\n+    /**\n+     * interpret the given byte b and return the value as State.\n+     *\n+     * @param b\n+     * @return state representation of byte value b in current datatype\n+     */\n+    public State asState(byte b) {\n+        int val = b & 0xff;\n+        if (datatype == DataType.TEMPERATURE) {\n+            return new QuantityType<>(TEMP_MAP[val], SIUnits.CELSIUS);\n+        } else if (datatype == DataType.BYTE_PERCENT) {\n+            return new QuantityType<>((int) ((val - BYTE_PERCENT_OFFSET) * 100.0 / (255 - BYTE_PERCENT_OFFSET)),\n+                    SmartHomeUnits.PERCENT);\n+        } else if (datatype == DataType.SWITCH && bitLength == 1) {\n+            if ((b & (1 << bitStart)) != 0) {\n+                return OnOffType.ON;\n+            } else {\n+                return OnOffType.OFF;\n+            }\n+        } else if (datatype == DataType.NUMBER) {\n+            int value = (b & bitMask()) >> bitStart;\n+            return new DecimalType(value);\n+        } else if (datatype == DataType.PERCENT) {\n+            return new QuantityType<>(val, SmartHomeUnits.PERCENT);\n+        } else if (datatype == DataType.FANSPEED) {\n+            int i = 1;\n+            while (i < FANSPEED_MAP.length && FANSPEED_MAP[i] < val) {\n+                i++;\n+            }\n+            return new DecimalType(i);\n+        } else if (datatype == DataType.HYSTERESIS) {\n+            return new QuantityType<>(val / 3, SIUnits.CELSIUS);\n+        }\n+\n+        return UnDefType.UNDEF;\n+    }\n+\n+    /**\n+     * interpret the given byte b and return the value as string.\n+     *\n+     * @param b\n+     * @return sting representation of byte value b in current datatype\n+     */\n+    public String asString(byte b) {\n+        State ste = asState(b);\n+        String str = ste.toString();\n+        if (ste instanceof UnDefType) {\n+            return String.format(\"<unknown type> %02X \", b);\n+        } else {\n+            return str;\n+        }\n+    }\n+\n+    /**\n+     * generate byte data to transmit\n+     *\n+     * @param val is the state of a channel\n+     * @return byte value with RS485 representation. Bit level values are returned in the correct location, but other\n+     *         bits/datapoints in the same address are zero.\n+     */\n+    public byte getTransmitDataFor(State val) {\n+        byte result = 0;\n+        DecimalType value = val.as(DecimalType.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "361703be6950354911240a431cfdce7604537cb6"}, "originalPosition": 231}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE1MDgyMQ==", "bodyText": "With the unexpected unit we anyhow cannot do anything reasonable which is why the if (value == null) block is empty. And due to the thing/item types we should not get anything unexpected, should we?\nDo you have a concrete case in mind where this could happen and can you suggest something what to do here?", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r436150821", "createdAt": "2020-06-05T20:32:48Z", "author": {"login": "ramack"}, "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationDataPoint.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+\n+/**\n+ * The {@link HeliosVentilationDataPoint} is a description of a datapoint in the Helios ventilation system.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosVentilationDataPoint {\n+    public enum DataType {\n+        TEMPERATURE,\n+        HYSTERESIS,\n+        FANSPEED,\n+        SWITCH,\n+        BYTE_PERCENT,\n+        PERCENT,\n+        NUMBER\n+    }\n+\n+    /**\n+     * mapping from temperature byte values to \u00b0C\n+     */\n+    private static final int TEMP_MAP[] = { -74, -70, -66, -62, -59, -56, -54, -52, -50, -48, -47, -46, -44, -43, -42,\n+            -41, -40, -39, -38, -37, -36, -35, -34, -33, -33, -32, -31, -30, -30, -29, -28, -28, -27, -27, -26, -25,\n+            -25, -24, -24, -23, -23, -22, -22, -21, -21, -20, -20, -19, -19, -19, -18, -18, -17, -17, -16, -16, -16,\n+            -15, -15, -14, -14, -14, -13, -13, -12, -12, -12, -11, -11, -11, -10, -10, -9, -9, -9, -8, -8, -8, -7, -7,\n+            -7, -6, -6, -6, -5, -5, -5, -4, -4, -4, -3, -3, -3, -2, -2, -2, -1, -1, -1, -1, 0, 0, 0, 1, 1, 1, 2, 2, 2,\n+            3, 3, 3, 4, 4, 4, 5, 5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 13,\n+            13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 18, 18, 18, 19, 19, 19, 20, 20, 21, 21, 21, 22, 22, 22,\n+            23, 23, 24, 24, 24, 25, 25, 26, 26, 27, 27, 27, 28, 28, 29, 29, 30, 30, 31, 31, 32, 32, 33, 33, 34, 34, 35,\n+            35, 36, 36, 37, 37, 38, 38, 39, 40, 40, 41, 41, 42, 43, 43, 44, 45, 45, 46, 47, 48, 48, 49, 50, 51, 52, 53,\n+            53, 54, 55, 56, 57, 59, 60, 61, 62, 63, 65, 66, 68, 69, 71, 73, 75, 77, 79, 81, 82, 86, 90, 93, 97, 100,\n+            100, 100, 100, 100, 100, 100, 100, 100 };\n+\n+    /**\n+     * mapping from human readable fanspeed to raw value\n+     */\n+    private static final int FANSPEED_MAP[] = { 0, 1, 3, 7, 15, 31, 63, 127, 255 };\n+\n+    private static final int BYTE_PERCENT_OFFSET = 52;\n+\n+    private String name;\n+    private boolean writable;\n+    private DataType datatype;\n+    private byte address;\n+    private int bitStart;\n+    private int bitLength;\n+\n+    private @Nullable HeliosVentilationDataPoint link;\n+\n+    /**\n+     * parse fullSpec in the properties format to declare a datapoint\n+     *\n+     * @param name the name of the datapoint\n+     * @param fullSpec datapoint specification, see format in datapoints.properties\n+     * @throws HeliosPropertiesFormatException in case fullSpec is not parsable\n+     */\n+    public HeliosVentilationDataPoint(String name, String fullSpec) throws HeliosPropertiesFormatException {\n+        String specWithoutComment;\n+        if (fullSpec.contains(\"#\")) {\n+            specWithoutComment = fullSpec.substring(0, fullSpec.indexOf(\"#\"));\n+        } else {\n+            specWithoutComment = fullSpec;\n+        }\n+        String[] tokens = specWithoutComment.split(\",\");\n+        this.name = name;\n+        if (tokens.length != 3) {\n+            throw new HeliosPropertiesFormatException(\"invalid length\", name, fullSpec);\n+        }\n+        try {\n+            String addr = tokens[0];\n+            String[] addrTokens;\n+            if (addr.contains(\":\")) {\n+                addrTokens = addr.split(\":\");\n+            } else {\n+                addrTokens = new String[] { addr };\n+            }\n+            bitLength = 8;\n+            bitStart = 0;\n+            this.address = (byte) (int) Integer.decode(addrTokens[0]);\n+            if (addrTokens.length > 1) {\n+                bitStart = (byte) (int) Integer.decode(addrTokens[1]);\n+                bitLength = 1;\n+            }\n+            if (addrTokens.length > 2) {\n+                bitLength = (byte) (int) Integer.decode(addrTokens[2]) - bitStart + 1;\n+            }\n+            if (addrTokens.length > 3) {\n+                throw new HeliosPropertiesFormatException(\n+                        \"invalid address spec: too many separators in bit specification\", name, fullSpec);\n+            }\n+        } catch (NumberFormatException e) {\n+            throw new HeliosPropertiesFormatException(\"invalid address spec\", name, fullSpec);\n+        }\n+\n+        this.writable = Boolean.parseBoolean(tokens[1]);\n+        try {\n+            this.datatype = DataType.valueOf(tokens[2].replaceAll(\"\\\\s+\", \"\"));\n+        } catch (IllegalArgumentException e) {\n+            throw new HeliosPropertiesFormatException(\"invalid type spec\", name, fullSpec);\n+        }\n+    }\n+\n+    public HeliosVentilationDataPoint(String name, byte address, boolean writable, DataType datatype) {\n+        this.datatype = datatype;\n+        this.writable = writable;\n+        this.name = name;\n+        this.address = address;\n+    }\n+\n+    public boolean isWritable() {\n+        return writable;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return name;\n+    }\n+\n+    /**\n+     *\n+     * @return the name of the variable, which is also the channel name\n+     */\n+    public String getName() {\n+        return name;\n+    }\n+\n+    /**\n+     *\n+     * @return address of the variable\n+     */\n+    public byte address() {\n+        return address;\n+    }\n+\n+    /**\n+     * @return the bit mask of the data point. 0xFF in case the full byte is used.\n+     */\n+    public byte bitMask() {\n+        byte mask = (byte) 0xff;\n+        if (datatype == DataType.NUMBER || datatype == DataType.SWITCH) {\n+            mask = (byte) (((1 << bitLength) - 1) << bitStart);\n+        }\n+        return mask;\n+    }\n+\n+    /**\n+     * interpret the given byte b and return the value as State.\n+     *\n+     * @param b\n+     * @return state representation of byte value b in current datatype\n+     */\n+    public State asState(byte b) {\n+        int val = b & 0xff;\n+        if (datatype == DataType.TEMPERATURE) {\n+            return new QuantityType<>(TEMP_MAP[val], SIUnits.CELSIUS);\n+        } else if (datatype == DataType.BYTE_PERCENT) {\n+            return new QuantityType<>((int) ((val - BYTE_PERCENT_OFFSET) * 100.0 / (255 - BYTE_PERCENT_OFFSET)),\n+                    SmartHomeUnits.PERCENT);\n+        } else if (datatype == DataType.SWITCH && bitLength == 1) {\n+            if ((b & (1 << bitStart)) != 0) {\n+                return OnOffType.ON;\n+            } else {\n+                return OnOffType.OFF;\n+            }\n+        } else if (datatype == DataType.NUMBER) {\n+            int value = (b & bitMask()) >> bitStart;\n+            return new DecimalType(value);\n+        } else if (datatype == DataType.PERCENT) {\n+            return new QuantityType<>(val, SmartHomeUnits.PERCENT);\n+        } else if (datatype == DataType.FANSPEED) {\n+            int i = 1;\n+            while (i < FANSPEED_MAP.length && FANSPEED_MAP[i] < val) {\n+                i++;\n+            }\n+            return new DecimalType(i);\n+        } else if (datatype == DataType.HYSTERESIS) {\n+            return new QuantityType<>(val / 3, SIUnits.CELSIUS);\n+        }\n+\n+        return UnDefType.UNDEF;\n+    }\n+\n+    /**\n+     * interpret the given byte b and return the value as string.\n+     *\n+     * @param b\n+     * @return sting representation of byte value b in current datatype\n+     */\n+    public String asString(byte b) {\n+        State ste = asState(b);\n+        String str = ste.toString();\n+        if (ste instanceof UnDefType) {\n+            return String.format(\"<unknown type> %02X \", b);\n+        } else {\n+            return str;\n+        }\n+    }\n+\n+    /**\n+     * generate byte data to transmit\n+     *\n+     * @param val is the state of a channel\n+     * @return byte value with RS485 representation. Bit level values are returned in the correct location, but other\n+     *         bits/datapoints in the same address are zero.\n+     */\n+    public byte getTransmitDataFor(State val) {\n+        byte result = 0;\n+        DecimalType value = val.as(DecimalType.class);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY5NDM1Mg=="}, "originalCommit": {"oid": "361703be6950354911240a431cfdce7604537cb6"}, "originalPosition": 231}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE4MjQyMA==", "bodyText": "You simply need to convert the quantity type to the value you want:\n((QuantityType<?>) val).toUnit(SIUnits.CELSIUS).doubleValue()", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r436182420", "createdAt": "2020-06-05T21:58:59Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationDataPoint.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+\n+/**\n+ * The {@link HeliosVentilationDataPoint} is a description of a datapoint in the Helios ventilation system.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosVentilationDataPoint {\n+    public enum DataType {\n+        TEMPERATURE,\n+        HYSTERESIS,\n+        FANSPEED,\n+        SWITCH,\n+        BYTE_PERCENT,\n+        PERCENT,\n+        NUMBER\n+    }\n+\n+    /**\n+     * mapping from temperature byte values to \u00b0C\n+     */\n+    private static final int TEMP_MAP[] = { -74, -70, -66, -62, -59, -56, -54, -52, -50, -48, -47, -46, -44, -43, -42,\n+            -41, -40, -39, -38, -37, -36, -35, -34, -33, -33, -32, -31, -30, -30, -29, -28, -28, -27, -27, -26, -25,\n+            -25, -24, -24, -23, -23, -22, -22, -21, -21, -20, -20, -19, -19, -19, -18, -18, -17, -17, -16, -16, -16,\n+            -15, -15, -14, -14, -14, -13, -13, -12, -12, -12, -11, -11, -11, -10, -10, -9, -9, -9, -8, -8, -8, -7, -7,\n+            -7, -6, -6, -6, -5, -5, -5, -4, -4, -4, -3, -3, -3, -2, -2, -2, -1, -1, -1, -1, 0, 0, 0, 1, 1, 1, 2, 2, 2,\n+            3, 3, 3, 4, 4, 4, 5, 5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 13,\n+            13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 18, 18, 18, 19, 19, 19, 20, 20, 21, 21, 21, 22, 22, 22,\n+            23, 23, 24, 24, 24, 25, 25, 26, 26, 27, 27, 27, 28, 28, 29, 29, 30, 30, 31, 31, 32, 32, 33, 33, 34, 34, 35,\n+            35, 36, 36, 37, 37, 38, 38, 39, 40, 40, 41, 41, 42, 43, 43, 44, 45, 45, 46, 47, 48, 48, 49, 50, 51, 52, 53,\n+            53, 54, 55, 56, 57, 59, 60, 61, 62, 63, 65, 66, 68, 69, 71, 73, 75, 77, 79, 81, 82, 86, 90, 93, 97, 100,\n+            100, 100, 100, 100, 100, 100, 100, 100 };\n+\n+    /**\n+     * mapping from human readable fanspeed to raw value\n+     */\n+    private static final int FANSPEED_MAP[] = { 0, 1, 3, 7, 15, 31, 63, 127, 255 };\n+\n+    private static final int BYTE_PERCENT_OFFSET = 52;\n+\n+    private String name;\n+    private boolean writable;\n+    private DataType datatype;\n+    private byte address;\n+    private int bitStart;\n+    private int bitLength;\n+\n+    private @Nullable HeliosVentilationDataPoint link;\n+\n+    /**\n+     * parse fullSpec in the properties format to declare a datapoint\n+     *\n+     * @param name the name of the datapoint\n+     * @param fullSpec datapoint specification, see format in datapoints.properties\n+     * @throws HeliosPropertiesFormatException in case fullSpec is not parsable\n+     */\n+    public HeliosVentilationDataPoint(String name, String fullSpec) throws HeliosPropertiesFormatException {\n+        String specWithoutComment;\n+        if (fullSpec.contains(\"#\")) {\n+            specWithoutComment = fullSpec.substring(0, fullSpec.indexOf(\"#\"));\n+        } else {\n+            specWithoutComment = fullSpec;\n+        }\n+        String[] tokens = specWithoutComment.split(\",\");\n+        this.name = name;\n+        if (tokens.length != 3) {\n+            throw new HeliosPropertiesFormatException(\"invalid length\", name, fullSpec);\n+        }\n+        try {\n+            String addr = tokens[0];\n+            String[] addrTokens;\n+            if (addr.contains(\":\")) {\n+                addrTokens = addr.split(\":\");\n+            } else {\n+                addrTokens = new String[] { addr };\n+            }\n+            bitLength = 8;\n+            bitStart = 0;\n+            this.address = (byte) (int) Integer.decode(addrTokens[0]);\n+            if (addrTokens.length > 1) {\n+                bitStart = (byte) (int) Integer.decode(addrTokens[1]);\n+                bitLength = 1;\n+            }\n+            if (addrTokens.length > 2) {\n+                bitLength = (byte) (int) Integer.decode(addrTokens[2]) - bitStart + 1;\n+            }\n+            if (addrTokens.length > 3) {\n+                throw new HeliosPropertiesFormatException(\n+                        \"invalid address spec: too many separators in bit specification\", name, fullSpec);\n+            }\n+        } catch (NumberFormatException e) {\n+            throw new HeliosPropertiesFormatException(\"invalid address spec\", name, fullSpec);\n+        }\n+\n+        this.writable = Boolean.parseBoolean(tokens[1]);\n+        try {\n+            this.datatype = DataType.valueOf(tokens[2].replaceAll(\"\\\\s+\", \"\"));\n+        } catch (IllegalArgumentException e) {\n+            throw new HeliosPropertiesFormatException(\"invalid type spec\", name, fullSpec);\n+        }\n+    }\n+\n+    public HeliosVentilationDataPoint(String name, byte address, boolean writable, DataType datatype) {\n+        this.datatype = datatype;\n+        this.writable = writable;\n+        this.name = name;\n+        this.address = address;\n+    }\n+\n+    public boolean isWritable() {\n+        return writable;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return name;\n+    }\n+\n+    /**\n+     *\n+     * @return the name of the variable, which is also the channel name\n+     */\n+    public String getName() {\n+        return name;\n+    }\n+\n+    /**\n+     *\n+     * @return address of the variable\n+     */\n+    public byte address() {\n+        return address;\n+    }\n+\n+    /**\n+     * @return the bit mask of the data point. 0xFF in case the full byte is used.\n+     */\n+    public byte bitMask() {\n+        byte mask = (byte) 0xff;\n+        if (datatype == DataType.NUMBER || datatype == DataType.SWITCH) {\n+            mask = (byte) (((1 << bitLength) - 1) << bitStart);\n+        }\n+        return mask;\n+    }\n+\n+    /**\n+     * interpret the given byte b and return the value as State.\n+     *\n+     * @param b\n+     * @return state representation of byte value b in current datatype\n+     */\n+    public State asState(byte b) {\n+        int val = b & 0xff;\n+        if (datatype == DataType.TEMPERATURE) {\n+            return new QuantityType<>(TEMP_MAP[val], SIUnits.CELSIUS);\n+        } else if (datatype == DataType.BYTE_PERCENT) {\n+            return new QuantityType<>((int) ((val - BYTE_PERCENT_OFFSET) * 100.0 / (255 - BYTE_PERCENT_OFFSET)),\n+                    SmartHomeUnits.PERCENT);\n+        } else if (datatype == DataType.SWITCH && bitLength == 1) {\n+            if ((b & (1 << bitStart)) != 0) {\n+                return OnOffType.ON;\n+            } else {\n+                return OnOffType.OFF;\n+            }\n+        } else if (datatype == DataType.NUMBER) {\n+            int value = (b & bitMask()) >> bitStart;\n+            return new DecimalType(value);\n+        } else if (datatype == DataType.PERCENT) {\n+            return new QuantityType<>(val, SmartHomeUnits.PERCENT);\n+        } else if (datatype == DataType.FANSPEED) {\n+            int i = 1;\n+            while (i < FANSPEED_MAP.length && FANSPEED_MAP[i] < val) {\n+                i++;\n+            }\n+            return new DecimalType(i);\n+        } else if (datatype == DataType.HYSTERESIS) {\n+            return new QuantityType<>(val / 3, SIUnits.CELSIUS);\n+        }\n+\n+        return UnDefType.UNDEF;\n+    }\n+\n+    /**\n+     * interpret the given byte b and return the value as string.\n+     *\n+     * @param b\n+     * @return sting representation of byte value b in current datatype\n+     */\n+    public String asString(byte b) {\n+        State ste = asState(b);\n+        String str = ste.toString();\n+        if (ste instanceof UnDefType) {\n+            return String.format(\"<unknown type> %02X \", b);\n+        } else {\n+            return str;\n+        }\n+    }\n+\n+    /**\n+     * generate byte data to transmit\n+     *\n+     * @param val is the state of a channel\n+     * @return byte value with RS485 representation. Bit level values are returned in the correct location, but other\n+     *         bits/datapoints in the same address are zero.\n+     */\n+    public byte getTransmitDataFor(State val) {\n+        byte result = 0;\n+        DecimalType value = val.as(DecimalType.class);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY5NDM1Mg=="}, "originalCommit": {"oid": "361703be6950354911240a431cfdce7604537cb6"}, "originalPosition": 231}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNzkzMjcxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationBindingConstants.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QwMTo0Mjo1MlrOGgGnnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QwMTo0Mjo1MlrOGgGnnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMxNjA2MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static HashMap<Byte, HeliosVentilationDataPoint> readChannelProperties() {\n          \n          \n            \n                private static Map<Byte, HeliosVentilationDataPoint> readChannelProperties() {", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r436316061", "createdAt": "2020-06-07T01:42:52Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationBindingConstants.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import java.io.IOException;\n+import java.net.URL;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.Properties;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HeliosVentilationBindingConstants} class defines common constants, which are\n+ * used across the whole binding.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosVentilationBindingConstants {\n+\n+    public static final String BINDING_ID = \"heliosventilation\";\n+\n+    public static final String DATAPOINT_FILE = \"datapoints.properties\";\n+\n+    // List of all Thing Type UIDs\n+    public static final ThingTypeUID THING_TYPE_HELIOS_VENTILATION = new ThingTypeUID(BINDING_ID, \"ventilation\");\n+\n+    public static final HashMap<Byte, HeliosVentilationDataPoint> DATAPOINTS;\n+\n+    private static final Logger LOGGER;\n+    static {\n+        /* logger is used by readChannelProperties() so we need to initialize logger first. */\n+        LOGGER = LoggerFactory.getLogger(HeliosVentilationBindingConstants.class);\n+        DATAPOINTS = readChannelProperties();\n+    }\n+    // List of all Channel ids\n+    // Channel ids are only in datapoints.properties and thing-types.xml\n+\n+    /**\n+     * parse datapoints from properties\n+     *\n+     */\n+    private static HashMap<Byte, HeliosVentilationDataPoint> readChannelProperties() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a59f77d1c606a32180e2511e5df9e06ceb1807b"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxNzkzMjczOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationBindingConstants.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QwMTo0Mjo1OVrOGgGnoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QwMTo0Mjo1OVrOGgGnoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMxNjA2NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static final HashMap<Byte, HeliosVentilationDataPoint> DATAPOINTS;\n          \n          \n            \n                public static final Map<Byte, HeliosVentilationDataPoint> DATAPOINTS;", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r436316064", "createdAt": "2020-06-07T01:42:59Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationBindingConstants.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import java.io.IOException;\n+import java.net.URL;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.Properties;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HeliosVentilationBindingConstants} class defines common constants, which are\n+ * used across the whole binding.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosVentilationBindingConstants {\n+\n+    public static final String BINDING_ID = \"heliosventilation\";\n+\n+    public static final String DATAPOINT_FILE = \"datapoints.properties\";\n+\n+    // List of all Thing Type UIDs\n+    public static final ThingTypeUID THING_TYPE_HELIOS_VENTILATION = new ThingTypeUID(BINDING_ID, \"ventilation\");\n+\n+    public static final HashMap<Byte, HeliosVentilationDataPoint> DATAPOINTS;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a59f77d1c606a32180e2511e5df9e06ceb1807b"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxODUyOTc2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QxOTo0MzozOVrOGgLdeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQyMDo0MDo1NFrOGjREAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM5NTM4NQ==", "bodyText": "configuration errors should be done in the initialize method, try to move this logic there instead.", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r436395385", "createdAt": "2020-06-07T19:43:39Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationHandler.java", "diffHunk": "@@ -0,0 +1,454 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.lang.invoke.MethodHandles;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HeliosVentilationHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosVentilationHandler extends BaseThingHandler implements SerialPortEventListener {\n+    private static final int BUSMEMBER_MAINBOARD = 0x11;\n+    private static final int BUSMEMBER_SLAVEBOARDS = 0x10;\n+    private static final byte BUSMEMBER_CONTROLBOARDS = (byte) 0x20;\n+    private static final int BUSMEMBER_REC_MASK = 0xF0; // interpreting frames delivered to BUSMEMBER_ME &\n+                                                        // BUSMEMBER_REC_MASK\n+    private static final int BUSMEMBER_ME = 0x2F; // used as sender when communicating with the helios system\n+    private static final int POLL_OFFLINE_THRESHOLD = 3;\n+\n+    /** Logger Instance */\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private @NonNullByDefault({}) HeliosVentilationConfiguration config;\n+\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable SerialPort serialPort;\n+    private @Nullable InputStream inputStream;\n+    private @Nullable OutputStream outputStream;\n+\n+    private @Nullable ScheduledFuture<?> pollingTask;\n+    private int pollCounter;\n+\n+    /**\n+     * store received data for read-modify-write operations on bitlevel\n+     */\n+    private Map<Byte, Byte> memory = new HashMap<Byte, Byte>();\n+\n+    public HeliosVentilationHandler(Thing thing, final SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(HeliosVentilationConfiguration.class);\n+\n+        logger.debug(\"Serial Port: {}, 9600 baud, PollPeriod: {}\", config.serialPort, config.pollPeriod);\n+\n+        if (config.serialPort.length() < 1) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port must be set!\");\n+            return;\n+        } else {\n+            updateStatus(ThingStatus.UNKNOWN);\n+            if (this.config.pollPeriod > 0) {\n+                startPolling();\n+            }\n+        }\n+\n+        scheduler.execute(this::connect);\n+    }\n+\n+    private synchronized void connect() {\n+        logger.debug(\"HeliosVentilation: connecting...\");\n+        // parse ports and if the port is found, initialize the reader\n+        SerialPortIdentifier portId = serialPortManager.getIdentifier(config.serialPort);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Port \" + config.serialPort + \" is not known!\");\n+            serialPort = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a59f77d1c606a32180e2511e5df9e06ceb1807b"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTYzMjg5OQ==", "bodyText": "As the port can also get removed after init (e.g. if a USB interface is unplugged) I think we should keep it here, but for sure we can add it in initialize().", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r439632899", "createdAt": "2020-06-12T20:40:54Z", "author": {"login": "ramack"}, "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationHandler.java", "diffHunk": "@@ -0,0 +1,454 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.lang.invoke.MethodHandles;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HeliosVentilationHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosVentilationHandler extends BaseThingHandler implements SerialPortEventListener {\n+    private static final int BUSMEMBER_MAINBOARD = 0x11;\n+    private static final int BUSMEMBER_SLAVEBOARDS = 0x10;\n+    private static final byte BUSMEMBER_CONTROLBOARDS = (byte) 0x20;\n+    private static final int BUSMEMBER_REC_MASK = 0xF0; // interpreting frames delivered to BUSMEMBER_ME &\n+                                                        // BUSMEMBER_REC_MASK\n+    private static final int BUSMEMBER_ME = 0x2F; // used as sender when communicating with the helios system\n+    private static final int POLL_OFFLINE_THRESHOLD = 3;\n+\n+    /** Logger Instance */\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private @NonNullByDefault({}) HeliosVentilationConfiguration config;\n+\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable SerialPort serialPort;\n+    private @Nullable InputStream inputStream;\n+    private @Nullable OutputStream outputStream;\n+\n+    private @Nullable ScheduledFuture<?> pollingTask;\n+    private int pollCounter;\n+\n+    /**\n+     * store received data for read-modify-write operations on bitlevel\n+     */\n+    private Map<Byte, Byte> memory = new HashMap<Byte, Byte>();\n+\n+    public HeliosVentilationHandler(Thing thing, final SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(HeliosVentilationConfiguration.class);\n+\n+        logger.debug(\"Serial Port: {}, 9600 baud, PollPeriod: {}\", config.serialPort, config.pollPeriod);\n+\n+        if (config.serialPort.length() < 1) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port must be set!\");\n+            return;\n+        } else {\n+            updateStatus(ThingStatus.UNKNOWN);\n+            if (this.config.pollPeriod > 0) {\n+                startPolling();\n+            }\n+        }\n+\n+        scheduler.execute(this::connect);\n+    }\n+\n+    private synchronized void connect() {\n+        logger.debug(\"HeliosVentilation: connecting...\");\n+        // parse ports and if the port is found, initialize the reader\n+        SerialPortIdentifier portId = serialPortManager.getIdentifier(config.serialPort);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Port \" + config.serialPort + \" is not known!\");\n+            serialPort = null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM5NTM4NQ=="}, "originalCommit": {"oid": "1a59f77d1c606a32180e2511e5df9e06ceb1807b"}, "originalPosition": 114}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxODUzMjMyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.heliosventilation/src/main/resources/ESH-INF/thing/thing-types.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QxOTo0Nzo1N1rOGgLe1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QxOTo0Nzo1N1rOGgLe1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM5NTczNQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t<parameter name=\"pollPeriod\" type=\"integer\" min=\"0\">\n          \n          \n            \n            \t\t\t<parameter name=\"pollPeriod\" type=\"integer\" min=\"0\" unit=\"s\">", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r436395735", "createdAt": "2020-06-07T19:47:57Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.heliosventilation/src/main/resources/ESH-INF/thing/thing-types.xml", "diffHunk": "@@ -0,0 +1,233 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<thing:thing-descriptions bindingId=\"heliosventilation\"\n+\txmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+\txmlns:thing=\"https://openhab.org/schemas/thing-description/v1.0.0\"\n+\txsi:schemaLocation=\"https://openhab.org/schemas/thing-description/v1.0.0 https://openhab.org/schemas/thing-description-1.0.0.xsd\">\n+\n+\t<!-- Ventilation Thing Type -->\n+\t<thing-type id=\"ventilation\">\n+\t\t<label>HeliosVentilation (KWL)</label>\n+\t\t<description>A domestic ventilation system (KWL) from Helios.</description>\n+\n+\t\t<channels>\n+\t\t\t<channel id=\"outsideTemp\" typeId=\"outside_temperature\" />\n+\t\t\t<channel id=\"outgoingTemp\" typeId=\"outgoing_temperature\" />\n+\t\t\t<channel id=\"extractTemp\" typeId=\"extract_temperature\" />\n+\t\t\t<channel id=\"supplyTemp\" typeId=\"supply_temperature\" />\n+\t\t\t<channel id=\"setTemp\" typeId=\"set_temperature\" />\n+\t\t\t<channel id=\"bypassTemp\" typeId=\"bypass_temperature\" />\n+\t\t\t<channel id=\"supplyStopTemp\" typeId=\"supply_stop_temperature\" />\n+\t\t\t<channel id=\"preheatTemp\" typeId=\"preheat_temperature\" />\n+\t\t\t<channel id=\"minFanspeed\" typeId=\"min_fanspeed\" />\n+\t\t\t<channel id=\"maxFanspeed\" typeId=\"max_fanspeed\" />\n+\t\t\t<channel id=\"fanspeed\" typeId=\"fanspeed\" />\n+\t\t\t<channel id=\"rhLimit\" typeId=\"rh_limit\" />\n+\t\t\t<channel id=\"hysteresis\" typeId=\"hysteresis\" />\n+\t\t\t<channel id=\"DCFanExtract\" typeId=\"dc_fan_extract\" />\n+\t\t\t<channel id=\"DCFanSupply\" typeId=\"dc_fan_supply\" />\n+\t\t\t<channel id=\"maintenanceInterval\" typeId=\"maintenance_interval\" />\n+\n+\t\t\t<channel id=\"radiatorType\" typeId=\"radiator_type\" />\n+\t\t\t<channel id=\"switchType\" typeId=\"switch_type\" />\n+\t\t\t<channel id=\"cascade\" typeId=\"cascade_mode\" />\n+\t\t\t<channel id=\"RHLevelAuto\" typeId=\"rh_level_auto\" />\n+\t\t\t<channel id=\"powerState\" typeId=\"power_state\" />\n+\t\t\t<channel id=\"co2State\" typeId=\"co2_state\" />\n+\t\t\t<channel id=\"rhState\" typeId=\"rh_state\" />\n+\t\t\t<channel id=\"winterMode\" typeId=\"winter_state\" />\n+\t\t\t<channel id=\"adjustInveral\" typeId=\"adjust_interval\" />\n+\t\t</channels>\n+\n+\t\t<config-description>\n+\t\t\t<parameter name=\"serialPort\" type=\"text\" required=\"true\">\n+\t\t\t\t<context>serial-port</context>\n+\t\t\t\t<label>RS485 Interface Serial Port</label>\n+\t\t\t\t<description>The serial port name for the RS485 interfaces. Valid values are e.g. COM1 for Windows and /dev/ttyS0 or /dev/ttyUSB0 for Linux.</description>\n+\t\t\t</parameter>\n+\n+\t\t\t<parameter name=\"pollPeriod\" type=\"integer\" min=\"0\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a59f77d1c606a32180e2511e5df9e06ceb1807b"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxODUzMjgzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationHandler.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QxOTo0OTowNVrOGgLfJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQyMDo0Njo1MFrOGjRNHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM5NTgxNQ==", "bodyText": "it doesn't look like this outer while loop serves any purpose.", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r436395815", "createdAt": "2020-06-07T19:49:05Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationHandler.java", "diffHunk": "@@ -0,0 +1,454 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.lang.invoke.MethodHandles;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HeliosVentilationHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosVentilationHandler extends BaseThingHandler implements SerialPortEventListener {\n+    private static final int BUSMEMBER_MAINBOARD = 0x11;\n+    private static final int BUSMEMBER_SLAVEBOARDS = 0x10;\n+    private static final byte BUSMEMBER_CONTROLBOARDS = (byte) 0x20;\n+    private static final int BUSMEMBER_REC_MASK = 0xF0; // interpreting frames delivered to BUSMEMBER_ME &\n+                                                        // BUSMEMBER_REC_MASK\n+    private static final int BUSMEMBER_ME = 0x2F; // used as sender when communicating with the helios system\n+    private static final int POLL_OFFLINE_THRESHOLD = 3;\n+\n+    /** Logger Instance */\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private @NonNullByDefault({}) HeliosVentilationConfiguration config;\n+\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable SerialPort serialPort;\n+    private @Nullable InputStream inputStream;\n+    private @Nullable OutputStream outputStream;\n+\n+    private @Nullable ScheduledFuture<?> pollingTask;\n+    private int pollCounter;\n+\n+    /**\n+     * store received data for read-modify-write operations on bitlevel\n+     */\n+    private Map<Byte, Byte> memory = new HashMap<Byte, Byte>();\n+\n+    public HeliosVentilationHandler(Thing thing, final SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(HeliosVentilationConfiguration.class);\n+\n+        logger.debug(\"Serial Port: {}, 9600 baud, PollPeriod: {}\", config.serialPort, config.pollPeriod);\n+\n+        if (config.serialPort.length() < 1) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port must be set!\");\n+            return;\n+        } else {\n+            updateStatus(ThingStatus.UNKNOWN);\n+            if (this.config.pollPeriod > 0) {\n+                startPolling();\n+            }\n+        }\n+\n+        scheduler.execute(this::connect);\n+    }\n+\n+    private synchronized void connect() {\n+        logger.debug(\"HeliosVentilation: connecting...\");\n+        // parse ports and if the port is found, initialize the reader\n+        SerialPortIdentifier portId = serialPortManager.getIdentifier(config.serialPort);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Port \" + config.serialPort + \" is not known!\");\n+            serialPort = null;\n+\n+            disconnect();\n+        } else if (!isConnected()) {\n+            // initialize serial port\n+            try {\n+                SerialPort serial = portId.open(getThing().getUID().toString(), 2000);\n+                serial.setSerialPortParams(9600, SerialPort.DATABITS_8, SerialPort.STOPBITS_1, SerialPort.PARITY_NONE);\n+                serial.addEventListener(this);\n+\n+                try {\n+                    if (inputStream != null) {\n+                        inputStream.close();\n+                    }\n+                } catch (IOException e) {\n+                    // ignore the exception on close\n+                    inputStream = null;\n+                }\n+                try {\n+                    if (outputStream != null) {\n+                        outputStream.close();\n+                    }\n+                } catch (IOException e) {\n+                    // ignore the exception on close\n+                    outputStream = null;\n+                }\n+\n+                inputStream = serial.getInputStream();\n+                outputStream = serial.getOutputStream();\n+\n+                // activate the DATA_AVAILABLE notifier\n+                serial.notifyOnDataAvailable(true);\n+                serialPort = serial;\n+                updateStatus(ThingStatus.UNKNOWN);\n+            } catch (final IOException ex) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"I/O error!\");\n+            } catch (PortInUseException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"Port is in use!\");\n+            } catch (TooManyListenersException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Cannot attach listener to port!\");\n+            } catch (UnsupportedCommOperationException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Serial port does not support the RS485 parameters of the Helios remote protocol.\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        stopPolling();\n+        disconnect();\n+        super.dispose();\n+    }\n+\n+    /**\n+     * Start the polling task.\n+     */\n+    public synchronized void startPolling() {\n+        final ScheduledFuture<?> task = pollingTask;\n+        if (task != null && task.isCancelled()) {\n+            task.cancel(true);\n+        }\n+        if (config.pollPeriod > 0) {\n+            pollingTask = scheduler.scheduleWithFixedDelay(this::polling, 10, config.pollPeriod, TimeUnit.SECONDS);\n+        } else {\n+            pollingTask = null;\n+        }\n+    }\n+\n+    /**\n+     * Stop the polling task.\n+     */\n+    public synchronized void stopPolling() {\n+        final ScheduledFuture<?> task = pollingTask;\n+        if (task != null && !task.isCancelled()) {\n+            task.cancel(true);\n+            pollingTask = null;\n+        }\n+    }\n+\n+    /**\n+     * Method for polling the RS485 Helios RemoteContol bus\n+     */\n+    public synchronized void polling() {\n+        if (logger.isTraceEnabled()) {\n+            logger.trace(\"HeliosVentilation Polling data for '{}'\", getThing().getUID());\n+        }\n+        pollCounter++;\n+        if (pollCounter > POLL_OFFLINE_THRESHOLD) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.GONE, \"No data received!\");\n+            logger.info(\"No data received for '{}' disconnecting now...\", getThing().getUID());\n+            disconnect();\n+        }\n+\n+        if (!isConnected()) {\n+            connect(); // let's try to reconnect if the connection failed or was never established before\n+        }\n+\n+        HeliosVentilationBindingConstants.DATAPOINTS.values().forEach((v) -> {\n+            if (isLinked(v.getName())) {\n+                poll(v);\n+            }\n+        });\n+    }\n+\n+    private void disconnect() {\n+        if (thing.getStatus() != ThingStatus.REMOVING) {\n+            updateStatus(ThingStatus.OFFLINE);\n+        }\n+        synchronized (this) {\n+            try {\n+                if (inputStream != null) {\n+                    inputStream.close();\n+                }\n+            } catch (IOException e) {\n+                // ignore the exception on close\n+                inputStream = null;\n+            }\n+            try {\n+                if (outputStream != null) {\n+                    outputStream.close();\n+                }\n+            } catch (IOException e) {\n+                // ignore the exception on close\n+                outputStream = null;\n+            }\n+\n+            SerialPort serial = serialPort;\n+            if (serial != null) {\n+                serial.close();\n+            }\n+            serialPort = null;\n+        }\n+\n+    }\n+\n+    private void poll(HeliosVentilationDataPoint v) {\n+        byte txFrame[] = { 0x01, BUSMEMBER_ME, BUSMEMBER_MAINBOARD, 0x00, v.address(), 0x00 };\n+        txFrame[5] = (byte) checksum(txFrame);\n+\n+        tx(txFrame);\n+    }\n+\n+    /*\n+     * transmit a frame\n+     */\n+    private void tx(byte[] txFrame) {\n+        try {\n+            OutputStream out = outputStream;\n+            if (out != null) {\n+                if (logger.isTraceEnabled()) {\n+                    logger.trace(\"HeliosVentilation: Write to serial port: {}\",\n+                            String.format(\"%02x %02x %02x %02x\", txFrame[1], txFrame[2], txFrame[3], txFrame[4]));\n+                }\n+\n+                out.write(txFrame);\n+                out.flush();\n+                // after each frame we have to wait.\n+                // 30 ms is taken from what we roughly see the original remote control is doing\n+                Thread.sleep(30);\n+            }\n+        } catch (IOException e) {\n+            // in case we cannot write the connection is somehow broken, let's officially disconnect\n+            disconnect();\n+            connect();\n+        } catch (InterruptedException e) {\n+            // ignore if we got interrupted\n+        }\n+    }\n+\n+    /**\n+     * Check connection status\n+     *\n+     * @return true if currently connected\n+     */\n+    private boolean isConnected() {\n+        return serialPort != null && inputStream != null && outputStream != null;\n+    }\n+\n+    @Override\n+    public synchronized void serialEvent(SerialPortEvent event) {\n+        switch (event.getEventType()) {\n+            case SerialPortEvent.DATA_AVAILABLE:\n+                // we get here if data has been received\n+\n+                try {\n+                    // Wait roughly a frame length to increase the likelihood that the complete frame is already\n+                    // buffered. This improves the robustness for RS485/USB converters which sometimes duplicate bytes\n+                    // otherwise\n+                    Thread.sleep(8);\n+                } catch (InterruptedException e) {\n+                    // ignore interruption\n+                }\n+\n+                byte frame[] = { 0, 0, 0, 0, 0, 0 };\n+                InputStream in = inputStream;\n+                if (in != null) {\n+                    try {\n+                        do {\n+                            int cnt = 0;\n+                            do {\n+                                // read data from serial device\n+                                while (cnt < 6 && in.available() > 0) {\n+                                    final int bytes = in.read(frame, cnt, 1);\n+                                    if (cnt > 0 || frame[0] == 0x01) {\n+                                        // only proceed if the first byte was 0x01\n+                                        cnt += bytes;\n+                                    }\n+                                }\n+                            } while (in.available() > 0 && cnt < 6);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a59f77d1c606a32180e2511e5df9e06ceb1807b"}, "originalPosition": 324}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTYzNDQ1Ng==", "bodyText": "in case there are already more than 6 bytes read, the outer loop is there to start reading directly the next (already partially received) frame", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r439634456", "createdAt": "2020-06-12T20:44:53Z", "author": {"login": "ramack"}, "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationHandler.java", "diffHunk": "@@ -0,0 +1,454 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.lang.invoke.MethodHandles;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HeliosVentilationHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosVentilationHandler extends BaseThingHandler implements SerialPortEventListener {\n+    private static final int BUSMEMBER_MAINBOARD = 0x11;\n+    private static final int BUSMEMBER_SLAVEBOARDS = 0x10;\n+    private static final byte BUSMEMBER_CONTROLBOARDS = (byte) 0x20;\n+    private static final int BUSMEMBER_REC_MASK = 0xF0; // interpreting frames delivered to BUSMEMBER_ME &\n+                                                        // BUSMEMBER_REC_MASK\n+    private static final int BUSMEMBER_ME = 0x2F; // used as sender when communicating with the helios system\n+    private static final int POLL_OFFLINE_THRESHOLD = 3;\n+\n+    /** Logger Instance */\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private @NonNullByDefault({}) HeliosVentilationConfiguration config;\n+\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable SerialPort serialPort;\n+    private @Nullable InputStream inputStream;\n+    private @Nullable OutputStream outputStream;\n+\n+    private @Nullable ScheduledFuture<?> pollingTask;\n+    private int pollCounter;\n+\n+    /**\n+     * store received data for read-modify-write operations on bitlevel\n+     */\n+    private Map<Byte, Byte> memory = new HashMap<Byte, Byte>();\n+\n+    public HeliosVentilationHandler(Thing thing, final SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(HeliosVentilationConfiguration.class);\n+\n+        logger.debug(\"Serial Port: {}, 9600 baud, PollPeriod: {}\", config.serialPort, config.pollPeriod);\n+\n+        if (config.serialPort.length() < 1) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port must be set!\");\n+            return;\n+        } else {\n+            updateStatus(ThingStatus.UNKNOWN);\n+            if (this.config.pollPeriod > 0) {\n+                startPolling();\n+            }\n+        }\n+\n+        scheduler.execute(this::connect);\n+    }\n+\n+    private synchronized void connect() {\n+        logger.debug(\"HeliosVentilation: connecting...\");\n+        // parse ports and if the port is found, initialize the reader\n+        SerialPortIdentifier portId = serialPortManager.getIdentifier(config.serialPort);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Port \" + config.serialPort + \" is not known!\");\n+            serialPort = null;\n+\n+            disconnect();\n+        } else if (!isConnected()) {\n+            // initialize serial port\n+            try {\n+                SerialPort serial = portId.open(getThing().getUID().toString(), 2000);\n+                serial.setSerialPortParams(9600, SerialPort.DATABITS_8, SerialPort.STOPBITS_1, SerialPort.PARITY_NONE);\n+                serial.addEventListener(this);\n+\n+                try {\n+                    if (inputStream != null) {\n+                        inputStream.close();\n+                    }\n+                } catch (IOException e) {\n+                    // ignore the exception on close\n+                    inputStream = null;\n+                }\n+                try {\n+                    if (outputStream != null) {\n+                        outputStream.close();\n+                    }\n+                } catch (IOException e) {\n+                    // ignore the exception on close\n+                    outputStream = null;\n+                }\n+\n+                inputStream = serial.getInputStream();\n+                outputStream = serial.getOutputStream();\n+\n+                // activate the DATA_AVAILABLE notifier\n+                serial.notifyOnDataAvailable(true);\n+                serialPort = serial;\n+                updateStatus(ThingStatus.UNKNOWN);\n+            } catch (final IOException ex) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"I/O error!\");\n+            } catch (PortInUseException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"Port is in use!\");\n+            } catch (TooManyListenersException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Cannot attach listener to port!\");\n+            } catch (UnsupportedCommOperationException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Serial port does not support the RS485 parameters of the Helios remote protocol.\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        stopPolling();\n+        disconnect();\n+        super.dispose();\n+    }\n+\n+    /**\n+     * Start the polling task.\n+     */\n+    public synchronized void startPolling() {\n+        final ScheduledFuture<?> task = pollingTask;\n+        if (task != null && task.isCancelled()) {\n+            task.cancel(true);\n+        }\n+        if (config.pollPeriod > 0) {\n+            pollingTask = scheduler.scheduleWithFixedDelay(this::polling, 10, config.pollPeriod, TimeUnit.SECONDS);\n+        } else {\n+            pollingTask = null;\n+        }\n+    }\n+\n+    /**\n+     * Stop the polling task.\n+     */\n+    public synchronized void stopPolling() {\n+        final ScheduledFuture<?> task = pollingTask;\n+        if (task != null && !task.isCancelled()) {\n+            task.cancel(true);\n+            pollingTask = null;\n+        }\n+    }\n+\n+    /**\n+     * Method for polling the RS485 Helios RemoteContol bus\n+     */\n+    public synchronized void polling() {\n+        if (logger.isTraceEnabled()) {\n+            logger.trace(\"HeliosVentilation Polling data for '{}'\", getThing().getUID());\n+        }\n+        pollCounter++;\n+        if (pollCounter > POLL_OFFLINE_THRESHOLD) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.GONE, \"No data received!\");\n+            logger.info(\"No data received for '{}' disconnecting now...\", getThing().getUID());\n+            disconnect();\n+        }\n+\n+        if (!isConnected()) {\n+            connect(); // let's try to reconnect if the connection failed or was never established before\n+        }\n+\n+        HeliosVentilationBindingConstants.DATAPOINTS.values().forEach((v) -> {\n+            if (isLinked(v.getName())) {\n+                poll(v);\n+            }\n+        });\n+    }\n+\n+    private void disconnect() {\n+        if (thing.getStatus() != ThingStatus.REMOVING) {\n+            updateStatus(ThingStatus.OFFLINE);\n+        }\n+        synchronized (this) {\n+            try {\n+                if (inputStream != null) {\n+                    inputStream.close();\n+                }\n+            } catch (IOException e) {\n+                // ignore the exception on close\n+                inputStream = null;\n+            }\n+            try {\n+                if (outputStream != null) {\n+                    outputStream.close();\n+                }\n+            } catch (IOException e) {\n+                // ignore the exception on close\n+                outputStream = null;\n+            }\n+\n+            SerialPort serial = serialPort;\n+            if (serial != null) {\n+                serial.close();\n+            }\n+            serialPort = null;\n+        }\n+\n+    }\n+\n+    private void poll(HeliosVentilationDataPoint v) {\n+        byte txFrame[] = { 0x01, BUSMEMBER_ME, BUSMEMBER_MAINBOARD, 0x00, v.address(), 0x00 };\n+        txFrame[5] = (byte) checksum(txFrame);\n+\n+        tx(txFrame);\n+    }\n+\n+    /*\n+     * transmit a frame\n+     */\n+    private void tx(byte[] txFrame) {\n+        try {\n+            OutputStream out = outputStream;\n+            if (out != null) {\n+                if (logger.isTraceEnabled()) {\n+                    logger.trace(\"HeliosVentilation: Write to serial port: {}\",\n+                            String.format(\"%02x %02x %02x %02x\", txFrame[1], txFrame[2], txFrame[3], txFrame[4]));\n+                }\n+\n+                out.write(txFrame);\n+                out.flush();\n+                // after each frame we have to wait.\n+                // 30 ms is taken from what we roughly see the original remote control is doing\n+                Thread.sleep(30);\n+            }\n+        } catch (IOException e) {\n+            // in case we cannot write the connection is somehow broken, let's officially disconnect\n+            disconnect();\n+            connect();\n+        } catch (InterruptedException e) {\n+            // ignore if we got interrupted\n+        }\n+    }\n+\n+    /**\n+     * Check connection status\n+     *\n+     * @return true if currently connected\n+     */\n+    private boolean isConnected() {\n+        return serialPort != null && inputStream != null && outputStream != null;\n+    }\n+\n+    @Override\n+    public synchronized void serialEvent(SerialPortEvent event) {\n+        switch (event.getEventType()) {\n+            case SerialPortEvent.DATA_AVAILABLE:\n+                // we get here if data has been received\n+\n+                try {\n+                    // Wait roughly a frame length to increase the likelihood that the complete frame is already\n+                    // buffered. This improves the robustness for RS485/USB converters which sometimes duplicate bytes\n+                    // otherwise\n+                    Thread.sleep(8);\n+                } catch (InterruptedException e) {\n+                    // ignore interruption\n+                }\n+\n+                byte frame[] = { 0, 0, 0, 0, 0, 0 };\n+                InputStream in = inputStream;\n+                if (in != null) {\n+                    try {\n+                        do {\n+                            int cnt = 0;\n+                            do {\n+                                // read data from serial device\n+                                while (cnt < 6 && in.available() > 0) {\n+                                    final int bytes = in.read(frame, cnt, 1);\n+                                    if (cnt > 0 || frame[0] == 0x01) {\n+                                        // only proceed if the first byte was 0x01\n+                                        cnt += bytes;\n+                                    }\n+                                }\n+                            } while (in.available() > 0 && cnt < 6);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM5NTgxNQ=="}, "originalCommit": {"oid": "1a59f77d1c606a32180e2511e5df9e06ceb1807b"}, "originalPosition": 324}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTYzNTIyOQ==", "bodyText": "ah no, you mean the \"inner\" outer loop :-) that one is useless I agree.", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r439635229", "createdAt": "2020-06-12T20:46:50Z", "author": {"login": "ramack"}, "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationHandler.java", "diffHunk": "@@ -0,0 +1,454 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.lang.invoke.MethodHandles;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HeliosVentilationHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosVentilationHandler extends BaseThingHandler implements SerialPortEventListener {\n+    private static final int BUSMEMBER_MAINBOARD = 0x11;\n+    private static final int BUSMEMBER_SLAVEBOARDS = 0x10;\n+    private static final byte BUSMEMBER_CONTROLBOARDS = (byte) 0x20;\n+    private static final int BUSMEMBER_REC_MASK = 0xF0; // interpreting frames delivered to BUSMEMBER_ME &\n+                                                        // BUSMEMBER_REC_MASK\n+    private static final int BUSMEMBER_ME = 0x2F; // used as sender when communicating with the helios system\n+    private static final int POLL_OFFLINE_THRESHOLD = 3;\n+\n+    /** Logger Instance */\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private @NonNullByDefault({}) HeliosVentilationConfiguration config;\n+\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable SerialPort serialPort;\n+    private @Nullable InputStream inputStream;\n+    private @Nullable OutputStream outputStream;\n+\n+    private @Nullable ScheduledFuture<?> pollingTask;\n+    private int pollCounter;\n+\n+    /**\n+     * store received data for read-modify-write operations on bitlevel\n+     */\n+    private Map<Byte, Byte> memory = new HashMap<Byte, Byte>();\n+\n+    public HeliosVentilationHandler(Thing thing, final SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(HeliosVentilationConfiguration.class);\n+\n+        logger.debug(\"Serial Port: {}, 9600 baud, PollPeriod: {}\", config.serialPort, config.pollPeriod);\n+\n+        if (config.serialPort.length() < 1) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port must be set!\");\n+            return;\n+        } else {\n+            updateStatus(ThingStatus.UNKNOWN);\n+            if (this.config.pollPeriod > 0) {\n+                startPolling();\n+            }\n+        }\n+\n+        scheduler.execute(this::connect);\n+    }\n+\n+    private synchronized void connect() {\n+        logger.debug(\"HeliosVentilation: connecting...\");\n+        // parse ports and if the port is found, initialize the reader\n+        SerialPortIdentifier portId = serialPortManager.getIdentifier(config.serialPort);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Port \" + config.serialPort + \" is not known!\");\n+            serialPort = null;\n+\n+            disconnect();\n+        } else if (!isConnected()) {\n+            // initialize serial port\n+            try {\n+                SerialPort serial = portId.open(getThing().getUID().toString(), 2000);\n+                serial.setSerialPortParams(9600, SerialPort.DATABITS_8, SerialPort.STOPBITS_1, SerialPort.PARITY_NONE);\n+                serial.addEventListener(this);\n+\n+                try {\n+                    if (inputStream != null) {\n+                        inputStream.close();\n+                    }\n+                } catch (IOException e) {\n+                    // ignore the exception on close\n+                    inputStream = null;\n+                }\n+                try {\n+                    if (outputStream != null) {\n+                        outputStream.close();\n+                    }\n+                } catch (IOException e) {\n+                    // ignore the exception on close\n+                    outputStream = null;\n+                }\n+\n+                inputStream = serial.getInputStream();\n+                outputStream = serial.getOutputStream();\n+\n+                // activate the DATA_AVAILABLE notifier\n+                serial.notifyOnDataAvailable(true);\n+                serialPort = serial;\n+                updateStatus(ThingStatus.UNKNOWN);\n+            } catch (final IOException ex) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"I/O error!\");\n+            } catch (PortInUseException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"Port is in use!\");\n+            } catch (TooManyListenersException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Cannot attach listener to port!\");\n+            } catch (UnsupportedCommOperationException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Serial port does not support the RS485 parameters of the Helios remote protocol.\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        stopPolling();\n+        disconnect();\n+        super.dispose();\n+    }\n+\n+    /**\n+     * Start the polling task.\n+     */\n+    public synchronized void startPolling() {\n+        final ScheduledFuture<?> task = pollingTask;\n+        if (task != null && task.isCancelled()) {\n+            task.cancel(true);\n+        }\n+        if (config.pollPeriod > 0) {\n+            pollingTask = scheduler.scheduleWithFixedDelay(this::polling, 10, config.pollPeriod, TimeUnit.SECONDS);\n+        } else {\n+            pollingTask = null;\n+        }\n+    }\n+\n+    /**\n+     * Stop the polling task.\n+     */\n+    public synchronized void stopPolling() {\n+        final ScheduledFuture<?> task = pollingTask;\n+        if (task != null && !task.isCancelled()) {\n+            task.cancel(true);\n+            pollingTask = null;\n+        }\n+    }\n+\n+    /**\n+     * Method for polling the RS485 Helios RemoteContol bus\n+     */\n+    public synchronized void polling() {\n+        if (logger.isTraceEnabled()) {\n+            logger.trace(\"HeliosVentilation Polling data for '{}'\", getThing().getUID());\n+        }\n+        pollCounter++;\n+        if (pollCounter > POLL_OFFLINE_THRESHOLD) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.GONE, \"No data received!\");\n+            logger.info(\"No data received for '{}' disconnecting now...\", getThing().getUID());\n+            disconnect();\n+        }\n+\n+        if (!isConnected()) {\n+            connect(); // let's try to reconnect if the connection failed or was never established before\n+        }\n+\n+        HeliosVentilationBindingConstants.DATAPOINTS.values().forEach((v) -> {\n+            if (isLinked(v.getName())) {\n+                poll(v);\n+            }\n+        });\n+    }\n+\n+    private void disconnect() {\n+        if (thing.getStatus() != ThingStatus.REMOVING) {\n+            updateStatus(ThingStatus.OFFLINE);\n+        }\n+        synchronized (this) {\n+            try {\n+                if (inputStream != null) {\n+                    inputStream.close();\n+                }\n+            } catch (IOException e) {\n+                // ignore the exception on close\n+                inputStream = null;\n+            }\n+            try {\n+                if (outputStream != null) {\n+                    outputStream.close();\n+                }\n+            } catch (IOException e) {\n+                // ignore the exception on close\n+                outputStream = null;\n+            }\n+\n+            SerialPort serial = serialPort;\n+            if (serial != null) {\n+                serial.close();\n+            }\n+            serialPort = null;\n+        }\n+\n+    }\n+\n+    private void poll(HeliosVentilationDataPoint v) {\n+        byte txFrame[] = { 0x01, BUSMEMBER_ME, BUSMEMBER_MAINBOARD, 0x00, v.address(), 0x00 };\n+        txFrame[5] = (byte) checksum(txFrame);\n+\n+        tx(txFrame);\n+    }\n+\n+    /*\n+     * transmit a frame\n+     */\n+    private void tx(byte[] txFrame) {\n+        try {\n+            OutputStream out = outputStream;\n+            if (out != null) {\n+                if (logger.isTraceEnabled()) {\n+                    logger.trace(\"HeliosVentilation: Write to serial port: {}\",\n+                            String.format(\"%02x %02x %02x %02x\", txFrame[1], txFrame[2], txFrame[3], txFrame[4]));\n+                }\n+\n+                out.write(txFrame);\n+                out.flush();\n+                // after each frame we have to wait.\n+                // 30 ms is taken from what we roughly see the original remote control is doing\n+                Thread.sleep(30);\n+            }\n+        } catch (IOException e) {\n+            // in case we cannot write the connection is somehow broken, let's officially disconnect\n+            disconnect();\n+            connect();\n+        } catch (InterruptedException e) {\n+            // ignore if we got interrupted\n+        }\n+    }\n+\n+    /**\n+     * Check connection status\n+     *\n+     * @return true if currently connected\n+     */\n+    private boolean isConnected() {\n+        return serialPort != null && inputStream != null && outputStream != null;\n+    }\n+\n+    @Override\n+    public synchronized void serialEvent(SerialPortEvent event) {\n+        switch (event.getEventType()) {\n+            case SerialPortEvent.DATA_AVAILABLE:\n+                // we get here if data has been received\n+\n+                try {\n+                    // Wait roughly a frame length to increase the likelihood that the complete frame is already\n+                    // buffered. This improves the robustness for RS485/USB converters which sometimes duplicate bytes\n+                    // otherwise\n+                    Thread.sleep(8);\n+                } catch (InterruptedException e) {\n+                    // ignore interruption\n+                }\n+\n+                byte frame[] = { 0, 0, 0, 0, 0, 0 };\n+                InputStream in = inputStream;\n+                if (in != null) {\n+                    try {\n+                        do {\n+                            int cnt = 0;\n+                            do {\n+                                // read data from serial device\n+                                while (cnt < 6 && in.available() > 0) {\n+                                    final int bytes = in.read(frame, cnt, 1);\n+                                    if (cnt > 0 || frame[0] == 0x01) {\n+                                        // only proceed if the first byte was 0x01\n+                                        cnt += bytes;\n+                                    }\n+                                }\n+                            } while (in.available() > 0 && cnt < 6);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM5NTgxNQ=="}, "originalCommit": {"oid": "1a59f77d1c606a32180e2511e5df9e06ceb1807b"}, "originalPosition": 324}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxODUzNDE5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QxOTo1MToxMFrOGgLf4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQyMDo1NDozMVrOGjRYGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM5NjAwMA==", "bodyText": "why do you mean \"increase the likelihood\"? Is it possible to implement this in a foolproof manner?", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r436396000", "createdAt": "2020-06-07T19:51:10Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationHandler.java", "diffHunk": "@@ -0,0 +1,454 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.lang.invoke.MethodHandles;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HeliosVentilationHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosVentilationHandler extends BaseThingHandler implements SerialPortEventListener {\n+    private static final int BUSMEMBER_MAINBOARD = 0x11;\n+    private static final int BUSMEMBER_SLAVEBOARDS = 0x10;\n+    private static final byte BUSMEMBER_CONTROLBOARDS = (byte) 0x20;\n+    private static final int BUSMEMBER_REC_MASK = 0xF0; // interpreting frames delivered to BUSMEMBER_ME &\n+                                                        // BUSMEMBER_REC_MASK\n+    private static final int BUSMEMBER_ME = 0x2F; // used as sender when communicating with the helios system\n+    private static final int POLL_OFFLINE_THRESHOLD = 3;\n+\n+    /** Logger Instance */\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private @NonNullByDefault({}) HeliosVentilationConfiguration config;\n+\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable SerialPort serialPort;\n+    private @Nullable InputStream inputStream;\n+    private @Nullable OutputStream outputStream;\n+\n+    private @Nullable ScheduledFuture<?> pollingTask;\n+    private int pollCounter;\n+\n+    /**\n+     * store received data for read-modify-write operations on bitlevel\n+     */\n+    private Map<Byte, Byte> memory = new HashMap<Byte, Byte>();\n+\n+    public HeliosVentilationHandler(Thing thing, final SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(HeliosVentilationConfiguration.class);\n+\n+        logger.debug(\"Serial Port: {}, 9600 baud, PollPeriod: {}\", config.serialPort, config.pollPeriod);\n+\n+        if (config.serialPort.length() < 1) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port must be set!\");\n+            return;\n+        } else {\n+            updateStatus(ThingStatus.UNKNOWN);\n+            if (this.config.pollPeriod > 0) {\n+                startPolling();\n+            }\n+        }\n+\n+        scheduler.execute(this::connect);\n+    }\n+\n+    private synchronized void connect() {\n+        logger.debug(\"HeliosVentilation: connecting...\");\n+        // parse ports and if the port is found, initialize the reader\n+        SerialPortIdentifier portId = serialPortManager.getIdentifier(config.serialPort);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Port \" + config.serialPort + \" is not known!\");\n+            serialPort = null;\n+\n+            disconnect();\n+        } else if (!isConnected()) {\n+            // initialize serial port\n+            try {\n+                SerialPort serial = portId.open(getThing().getUID().toString(), 2000);\n+                serial.setSerialPortParams(9600, SerialPort.DATABITS_8, SerialPort.STOPBITS_1, SerialPort.PARITY_NONE);\n+                serial.addEventListener(this);\n+\n+                try {\n+                    if (inputStream != null) {\n+                        inputStream.close();\n+                    }\n+                } catch (IOException e) {\n+                    // ignore the exception on close\n+                    inputStream = null;\n+                }\n+                try {\n+                    if (outputStream != null) {\n+                        outputStream.close();\n+                    }\n+                } catch (IOException e) {\n+                    // ignore the exception on close\n+                    outputStream = null;\n+                }\n+\n+                inputStream = serial.getInputStream();\n+                outputStream = serial.getOutputStream();\n+\n+                // activate the DATA_AVAILABLE notifier\n+                serial.notifyOnDataAvailable(true);\n+                serialPort = serial;\n+                updateStatus(ThingStatus.UNKNOWN);\n+            } catch (final IOException ex) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"I/O error!\");\n+            } catch (PortInUseException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"Port is in use!\");\n+            } catch (TooManyListenersException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Cannot attach listener to port!\");\n+            } catch (UnsupportedCommOperationException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Serial port does not support the RS485 parameters of the Helios remote protocol.\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        stopPolling();\n+        disconnect();\n+        super.dispose();\n+    }\n+\n+    /**\n+     * Start the polling task.\n+     */\n+    public synchronized void startPolling() {\n+        final ScheduledFuture<?> task = pollingTask;\n+        if (task != null && task.isCancelled()) {\n+            task.cancel(true);\n+        }\n+        if (config.pollPeriod > 0) {\n+            pollingTask = scheduler.scheduleWithFixedDelay(this::polling, 10, config.pollPeriod, TimeUnit.SECONDS);\n+        } else {\n+            pollingTask = null;\n+        }\n+    }\n+\n+    /**\n+     * Stop the polling task.\n+     */\n+    public synchronized void stopPolling() {\n+        final ScheduledFuture<?> task = pollingTask;\n+        if (task != null && !task.isCancelled()) {\n+            task.cancel(true);\n+            pollingTask = null;\n+        }\n+    }\n+\n+    /**\n+     * Method for polling the RS485 Helios RemoteContol bus\n+     */\n+    public synchronized void polling() {\n+        if (logger.isTraceEnabled()) {\n+            logger.trace(\"HeliosVentilation Polling data for '{}'\", getThing().getUID());\n+        }\n+        pollCounter++;\n+        if (pollCounter > POLL_OFFLINE_THRESHOLD) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.GONE, \"No data received!\");\n+            logger.info(\"No data received for '{}' disconnecting now...\", getThing().getUID());\n+            disconnect();\n+        }\n+\n+        if (!isConnected()) {\n+            connect(); // let's try to reconnect if the connection failed or was never established before\n+        }\n+\n+        HeliosVentilationBindingConstants.DATAPOINTS.values().forEach((v) -> {\n+            if (isLinked(v.getName())) {\n+                poll(v);\n+            }\n+        });\n+    }\n+\n+    private void disconnect() {\n+        if (thing.getStatus() != ThingStatus.REMOVING) {\n+            updateStatus(ThingStatus.OFFLINE);\n+        }\n+        synchronized (this) {\n+            try {\n+                if (inputStream != null) {\n+                    inputStream.close();\n+                }\n+            } catch (IOException e) {\n+                // ignore the exception on close\n+                inputStream = null;\n+            }\n+            try {\n+                if (outputStream != null) {\n+                    outputStream.close();\n+                }\n+            } catch (IOException e) {\n+                // ignore the exception on close\n+                outputStream = null;\n+            }\n+\n+            SerialPort serial = serialPort;\n+            if (serial != null) {\n+                serial.close();\n+            }\n+            serialPort = null;\n+        }\n+\n+    }\n+\n+    private void poll(HeliosVentilationDataPoint v) {\n+        byte txFrame[] = { 0x01, BUSMEMBER_ME, BUSMEMBER_MAINBOARD, 0x00, v.address(), 0x00 };\n+        txFrame[5] = (byte) checksum(txFrame);\n+\n+        tx(txFrame);\n+    }\n+\n+    /*\n+     * transmit a frame\n+     */\n+    private void tx(byte[] txFrame) {\n+        try {\n+            OutputStream out = outputStream;\n+            if (out != null) {\n+                if (logger.isTraceEnabled()) {\n+                    logger.trace(\"HeliosVentilation: Write to serial port: {}\",\n+                            String.format(\"%02x %02x %02x %02x\", txFrame[1], txFrame[2], txFrame[3], txFrame[4]));\n+                }\n+\n+                out.write(txFrame);\n+                out.flush();\n+                // after each frame we have to wait.\n+                // 30 ms is taken from what we roughly see the original remote control is doing\n+                Thread.sleep(30);\n+            }\n+        } catch (IOException e) {\n+            // in case we cannot write the connection is somehow broken, let's officially disconnect\n+            disconnect();\n+            connect();\n+        } catch (InterruptedException e) {\n+            // ignore if we got interrupted\n+        }\n+    }\n+\n+    /**\n+     * Check connection status\n+     *\n+     * @return true if currently connected\n+     */\n+    private boolean isConnected() {\n+        return serialPort != null && inputStream != null && outputStream != null;\n+    }\n+\n+    @Override\n+    public synchronized void serialEvent(SerialPortEvent event) {\n+        switch (event.getEventType()) {\n+            case SerialPortEvent.DATA_AVAILABLE:\n+                // we get here if data has been received\n+\n+                try {\n+                    // Wait roughly a frame length to increase the likelihood that the complete frame is already\n+                    // buffered. This improves the robustness for RS485/USB converters which sometimes duplicate bytes\n+                    // otherwise\n+                    Thread.sleep(8);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a59f77d1c606a32180e2511e5df9e06ceb1807b"}, "originalPosition": 304}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTYzODA0Mw==", "bodyText": "I recently changed that already compared to the initial (abandoned) PR from 5 to 8, which was the change from \"improving\" to surly waiting until the frame is fully buffered. Will update the comment accordingly.", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r439638043", "createdAt": "2020-06-12T20:54:31Z", "author": {"login": "ramack"}, "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationHandler.java", "diffHunk": "@@ -0,0 +1,454 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.lang.invoke.MethodHandles;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HeliosVentilationHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosVentilationHandler extends BaseThingHandler implements SerialPortEventListener {\n+    private static final int BUSMEMBER_MAINBOARD = 0x11;\n+    private static final int BUSMEMBER_SLAVEBOARDS = 0x10;\n+    private static final byte BUSMEMBER_CONTROLBOARDS = (byte) 0x20;\n+    private static final int BUSMEMBER_REC_MASK = 0xF0; // interpreting frames delivered to BUSMEMBER_ME &\n+                                                        // BUSMEMBER_REC_MASK\n+    private static final int BUSMEMBER_ME = 0x2F; // used as sender when communicating with the helios system\n+    private static final int POLL_OFFLINE_THRESHOLD = 3;\n+\n+    /** Logger Instance */\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private @NonNullByDefault({}) HeliosVentilationConfiguration config;\n+\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable SerialPort serialPort;\n+    private @Nullable InputStream inputStream;\n+    private @Nullable OutputStream outputStream;\n+\n+    private @Nullable ScheduledFuture<?> pollingTask;\n+    private int pollCounter;\n+\n+    /**\n+     * store received data for read-modify-write operations on bitlevel\n+     */\n+    private Map<Byte, Byte> memory = new HashMap<Byte, Byte>();\n+\n+    public HeliosVentilationHandler(Thing thing, final SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(HeliosVentilationConfiguration.class);\n+\n+        logger.debug(\"Serial Port: {}, 9600 baud, PollPeriod: {}\", config.serialPort, config.pollPeriod);\n+\n+        if (config.serialPort.length() < 1) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port must be set!\");\n+            return;\n+        } else {\n+            updateStatus(ThingStatus.UNKNOWN);\n+            if (this.config.pollPeriod > 0) {\n+                startPolling();\n+            }\n+        }\n+\n+        scheduler.execute(this::connect);\n+    }\n+\n+    private synchronized void connect() {\n+        logger.debug(\"HeliosVentilation: connecting...\");\n+        // parse ports and if the port is found, initialize the reader\n+        SerialPortIdentifier portId = serialPortManager.getIdentifier(config.serialPort);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Port \" + config.serialPort + \" is not known!\");\n+            serialPort = null;\n+\n+            disconnect();\n+        } else if (!isConnected()) {\n+            // initialize serial port\n+            try {\n+                SerialPort serial = portId.open(getThing().getUID().toString(), 2000);\n+                serial.setSerialPortParams(9600, SerialPort.DATABITS_8, SerialPort.STOPBITS_1, SerialPort.PARITY_NONE);\n+                serial.addEventListener(this);\n+\n+                try {\n+                    if (inputStream != null) {\n+                        inputStream.close();\n+                    }\n+                } catch (IOException e) {\n+                    // ignore the exception on close\n+                    inputStream = null;\n+                }\n+                try {\n+                    if (outputStream != null) {\n+                        outputStream.close();\n+                    }\n+                } catch (IOException e) {\n+                    // ignore the exception on close\n+                    outputStream = null;\n+                }\n+\n+                inputStream = serial.getInputStream();\n+                outputStream = serial.getOutputStream();\n+\n+                // activate the DATA_AVAILABLE notifier\n+                serial.notifyOnDataAvailable(true);\n+                serialPort = serial;\n+                updateStatus(ThingStatus.UNKNOWN);\n+            } catch (final IOException ex) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"I/O error!\");\n+            } catch (PortInUseException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"Port is in use!\");\n+            } catch (TooManyListenersException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Cannot attach listener to port!\");\n+            } catch (UnsupportedCommOperationException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Serial port does not support the RS485 parameters of the Helios remote protocol.\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        stopPolling();\n+        disconnect();\n+        super.dispose();\n+    }\n+\n+    /**\n+     * Start the polling task.\n+     */\n+    public synchronized void startPolling() {\n+        final ScheduledFuture<?> task = pollingTask;\n+        if (task != null && task.isCancelled()) {\n+            task.cancel(true);\n+        }\n+        if (config.pollPeriod > 0) {\n+            pollingTask = scheduler.scheduleWithFixedDelay(this::polling, 10, config.pollPeriod, TimeUnit.SECONDS);\n+        } else {\n+            pollingTask = null;\n+        }\n+    }\n+\n+    /**\n+     * Stop the polling task.\n+     */\n+    public synchronized void stopPolling() {\n+        final ScheduledFuture<?> task = pollingTask;\n+        if (task != null && !task.isCancelled()) {\n+            task.cancel(true);\n+            pollingTask = null;\n+        }\n+    }\n+\n+    /**\n+     * Method for polling the RS485 Helios RemoteContol bus\n+     */\n+    public synchronized void polling() {\n+        if (logger.isTraceEnabled()) {\n+            logger.trace(\"HeliosVentilation Polling data for '{}'\", getThing().getUID());\n+        }\n+        pollCounter++;\n+        if (pollCounter > POLL_OFFLINE_THRESHOLD) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.GONE, \"No data received!\");\n+            logger.info(\"No data received for '{}' disconnecting now...\", getThing().getUID());\n+            disconnect();\n+        }\n+\n+        if (!isConnected()) {\n+            connect(); // let's try to reconnect if the connection failed or was never established before\n+        }\n+\n+        HeliosVentilationBindingConstants.DATAPOINTS.values().forEach((v) -> {\n+            if (isLinked(v.getName())) {\n+                poll(v);\n+            }\n+        });\n+    }\n+\n+    private void disconnect() {\n+        if (thing.getStatus() != ThingStatus.REMOVING) {\n+            updateStatus(ThingStatus.OFFLINE);\n+        }\n+        synchronized (this) {\n+            try {\n+                if (inputStream != null) {\n+                    inputStream.close();\n+                }\n+            } catch (IOException e) {\n+                // ignore the exception on close\n+                inputStream = null;\n+            }\n+            try {\n+                if (outputStream != null) {\n+                    outputStream.close();\n+                }\n+            } catch (IOException e) {\n+                // ignore the exception on close\n+                outputStream = null;\n+            }\n+\n+            SerialPort serial = serialPort;\n+            if (serial != null) {\n+                serial.close();\n+            }\n+            serialPort = null;\n+        }\n+\n+    }\n+\n+    private void poll(HeliosVentilationDataPoint v) {\n+        byte txFrame[] = { 0x01, BUSMEMBER_ME, BUSMEMBER_MAINBOARD, 0x00, v.address(), 0x00 };\n+        txFrame[5] = (byte) checksum(txFrame);\n+\n+        tx(txFrame);\n+    }\n+\n+    /*\n+     * transmit a frame\n+     */\n+    private void tx(byte[] txFrame) {\n+        try {\n+            OutputStream out = outputStream;\n+            if (out != null) {\n+                if (logger.isTraceEnabled()) {\n+                    logger.trace(\"HeliosVentilation: Write to serial port: {}\",\n+                            String.format(\"%02x %02x %02x %02x\", txFrame[1], txFrame[2], txFrame[3], txFrame[4]));\n+                }\n+\n+                out.write(txFrame);\n+                out.flush();\n+                // after each frame we have to wait.\n+                // 30 ms is taken from what we roughly see the original remote control is doing\n+                Thread.sleep(30);\n+            }\n+        } catch (IOException e) {\n+            // in case we cannot write the connection is somehow broken, let's officially disconnect\n+            disconnect();\n+            connect();\n+        } catch (InterruptedException e) {\n+            // ignore if we got interrupted\n+        }\n+    }\n+\n+    /**\n+     * Check connection status\n+     *\n+     * @return true if currently connected\n+     */\n+    private boolean isConnected() {\n+        return serialPort != null && inputStream != null && outputStream != null;\n+    }\n+\n+    @Override\n+    public synchronized void serialEvent(SerialPortEvent event) {\n+        switch (event.getEventType()) {\n+            case SerialPortEvent.DATA_AVAILABLE:\n+                // we get here if data has been received\n+\n+                try {\n+                    // Wait roughly a frame length to increase the likelihood that the complete frame is already\n+                    // buffered. This improves the robustness for RS485/USB converters which sometimes duplicate bytes\n+                    // otherwise\n+                    Thread.sleep(8);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM5NjAwMA=="}, "originalCommit": {"oid": "1a59f77d1c606a32180e2511e5df9e06ceb1807b"}, "originalPosition": 304}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxODUzNTAzOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QxOTo1MjoyOVrOGgLgTw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QxOTo1MjoyOVrOGgLgTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM5NjExMQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            byte frame[] = { 0, 0, 0, 0, 0, 0 };\n          \n          \n            \n                            byte[] frame = { 0, 0, 0, 0, 0, 0 };", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r436396111", "createdAt": "2020-06-07T19:52:29Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationHandler.java", "diffHunk": "@@ -0,0 +1,454 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.lang.invoke.MethodHandles;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HeliosVentilationHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosVentilationHandler extends BaseThingHandler implements SerialPortEventListener {\n+    private static final int BUSMEMBER_MAINBOARD = 0x11;\n+    private static final int BUSMEMBER_SLAVEBOARDS = 0x10;\n+    private static final byte BUSMEMBER_CONTROLBOARDS = (byte) 0x20;\n+    private static final int BUSMEMBER_REC_MASK = 0xF0; // interpreting frames delivered to BUSMEMBER_ME &\n+                                                        // BUSMEMBER_REC_MASK\n+    private static final int BUSMEMBER_ME = 0x2F; // used as sender when communicating with the helios system\n+    private static final int POLL_OFFLINE_THRESHOLD = 3;\n+\n+    /** Logger Instance */\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private @NonNullByDefault({}) HeliosVentilationConfiguration config;\n+\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable SerialPort serialPort;\n+    private @Nullable InputStream inputStream;\n+    private @Nullable OutputStream outputStream;\n+\n+    private @Nullable ScheduledFuture<?> pollingTask;\n+    private int pollCounter;\n+\n+    /**\n+     * store received data for read-modify-write operations on bitlevel\n+     */\n+    private Map<Byte, Byte> memory = new HashMap<Byte, Byte>();\n+\n+    public HeliosVentilationHandler(Thing thing, final SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(HeliosVentilationConfiguration.class);\n+\n+        logger.debug(\"Serial Port: {}, 9600 baud, PollPeriod: {}\", config.serialPort, config.pollPeriod);\n+\n+        if (config.serialPort.length() < 1) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port must be set!\");\n+            return;\n+        } else {\n+            updateStatus(ThingStatus.UNKNOWN);\n+            if (this.config.pollPeriod > 0) {\n+                startPolling();\n+            }\n+        }\n+\n+        scheduler.execute(this::connect);\n+    }\n+\n+    private synchronized void connect() {\n+        logger.debug(\"HeliosVentilation: connecting...\");\n+        // parse ports and if the port is found, initialize the reader\n+        SerialPortIdentifier portId = serialPortManager.getIdentifier(config.serialPort);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Port \" + config.serialPort + \" is not known!\");\n+            serialPort = null;\n+\n+            disconnect();\n+        } else if (!isConnected()) {\n+            // initialize serial port\n+            try {\n+                SerialPort serial = portId.open(getThing().getUID().toString(), 2000);\n+                serial.setSerialPortParams(9600, SerialPort.DATABITS_8, SerialPort.STOPBITS_1, SerialPort.PARITY_NONE);\n+                serial.addEventListener(this);\n+\n+                try {\n+                    if (inputStream != null) {\n+                        inputStream.close();\n+                    }\n+                } catch (IOException e) {\n+                    // ignore the exception on close\n+                    inputStream = null;\n+                }\n+                try {\n+                    if (outputStream != null) {\n+                        outputStream.close();\n+                    }\n+                } catch (IOException e) {\n+                    // ignore the exception on close\n+                    outputStream = null;\n+                }\n+\n+                inputStream = serial.getInputStream();\n+                outputStream = serial.getOutputStream();\n+\n+                // activate the DATA_AVAILABLE notifier\n+                serial.notifyOnDataAvailable(true);\n+                serialPort = serial;\n+                updateStatus(ThingStatus.UNKNOWN);\n+            } catch (final IOException ex) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"I/O error!\");\n+            } catch (PortInUseException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"Port is in use!\");\n+            } catch (TooManyListenersException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Cannot attach listener to port!\");\n+            } catch (UnsupportedCommOperationException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Serial port does not support the RS485 parameters of the Helios remote protocol.\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        stopPolling();\n+        disconnect();\n+        super.dispose();\n+    }\n+\n+    /**\n+     * Start the polling task.\n+     */\n+    public synchronized void startPolling() {\n+        final ScheduledFuture<?> task = pollingTask;\n+        if (task != null && task.isCancelled()) {\n+            task.cancel(true);\n+        }\n+        if (config.pollPeriod > 0) {\n+            pollingTask = scheduler.scheduleWithFixedDelay(this::polling, 10, config.pollPeriod, TimeUnit.SECONDS);\n+        } else {\n+            pollingTask = null;\n+        }\n+    }\n+\n+    /**\n+     * Stop the polling task.\n+     */\n+    public synchronized void stopPolling() {\n+        final ScheduledFuture<?> task = pollingTask;\n+        if (task != null && !task.isCancelled()) {\n+            task.cancel(true);\n+            pollingTask = null;\n+        }\n+    }\n+\n+    /**\n+     * Method for polling the RS485 Helios RemoteContol bus\n+     */\n+    public synchronized void polling() {\n+        if (logger.isTraceEnabled()) {\n+            logger.trace(\"HeliosVentilation Polling data for '{}'\", getThing().getUID());\n+        }\n+        pollCounter++;\n+        if (pollCounter > POLL_OFFLINE_THRESHOLD) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.GONE, \"No data received!\");\n+            logger.info(\"No data received for '{}' disconnecting now...\", getThing().getUID());\n+            disconnect();\n+        }\n+\n+        if (!isConnected()) {\n+            connect(); // let's try to reconnect if the connection failed or was never established before\n+        }\n+\n+        HeliosVentilationBindingConstants.DATAPOINTS.values().forEach((v) -> {\n+            if (isLinked(v.getName())) {\n+                poll(v);\n+            }\n+        });\n+    }\n+\n+    private void disconnect() {\n+        if (thing.getStatus() != ThingStatus.REMOVING) {\n+            updateStatus(ThingStatus.OFFLINE);\n+        }\n+        synchronized (this) {\n+            try {\n+                if (inputStream != null) {\n+                    inputStream.close();\n+                }\n+            } catch (IOException e) {\n+                // ignore the exception on close\n+                inputStream = null;\n+            }\n+            try {\n+                if (outputStream != null) {\n+                    outputStream.close();\n+                }\n+            } catch (IOException e) {\n+                // ignore the exception on close\n+                outputStream = null;\n+            }\n+\n+            SerialPort serial = serialPort;\n+            if (serial != null) {\n+                serial.close();\n+            }\n+            serialPort = null;\n+        }\n+\n+    }\n+\n+    private void poll(HeliosVentilationDataPoint v) {\n+        byte txFrame[] = { 0x01, BUSMEMBER_ME, BUSMEMBER_MAINBOARD, 0x00, v.address(), 0x00 };\n+        txFrame[5] = (byte) checksum(txFrame);\n+\n+        tx(txFrame);\n+    }\n+\n+    /*\n+     * transmit a frame\n+     */\n+    private void tx(byte[] txFrame) {\n+        try {\n+            OutputStream out = outputStream;\n+            if (out != null) {\n+                if (logger.isTraceEnabled()) {\n+                    logger.trace(\"HeliosVentilation: Write to serial port: {}\",\n+                            String.format(\"%02x %02x %02x %02x\", txFrame[1], txFrame[2], txFrame[3], txFrame[4]));\n+                }\n+\n+                out.write(txFrame);\n+                out.flush();\n+                // after each frame we have to wait.\n+                // 30 ms is taken from what we roughly see the original remote control is doing\n+                Thread.sleep(30);\n+            }\n+        } catch (IOException e) {\n+            // in case we cannot write the connection is somehow broken, let's officially disconnect\n+            disconnect();\n+            connect();\n+        } catch (InterruptedException e) {\n+            // ignore if we got interrupted\n+        }\n+    }\n+\n+    /**\n+     * Check connection status\n+     *\n+     * @return true if currently connected\n+     */\n+    private boolean isConnected() {\n+        return serialPort != null && inputStream != null && outputStream != null;\n+    }\n+\n+    @Override\n+    public synchronized void serialEvent(SerialPortEvent event) {\n+        switch (event.getEventType()) {\n+            case SerialPortEvent.DATA_AVAILABLE:\n+                // we get here if data has been received\n+\n+                try {\n+                    // Wait roughly a frame length to increase the likelihood that the complete frame is already\n+                    // buffered. This improves the robustness for RS485/USB converters which sometimes duplicate bytes\n+                    // otherwise\n+                    Thread.sleep(8);\n+                } catch (InterruptedException e) {\n+                    // ignore interruption\n+                }\n+\n+                byte frame[] = { 0, 0, 0, 0, 0, 0 };", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a59f77d1c606a32180e2511e5df9e06ceb1807b"}, "originalPosition": 309}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcxODUzNjE2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QxOTo1NDo1NFrOGgLg6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wN1QxOTo1NDo1NFrOGgLg6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM5NjI2NA==", "bodyText": "There is a bug in the core that causes handleCommand to sometimes get called before the handler's initialize is called. So we recommend to just populate the configuration with a default instance to avoid NPE issues.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private @NonNullByDefault({}) HeliosVentilationConfiguration config;\n          \n          \n            \n                private HeliosVentilationConfiguration config = new HeliosVentilationConfiguration();", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r436396264", "createdAt": "2020-06-07T19:54:54Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationHandler.java", "diffHunk": "@@ -0,0 +1,454 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.lang.invoke.MethodHandles;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HeliosVentilationHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosVentilationHandler extends BaseThingHandler implements SerialPortEventListener {\n+    private static final int BUSMEMBER_MAINBOARD = 0x11;\n+    private static final int BUSMEMBER_SLAVEBOARDS = 0x10;\n+    private static final byte BUSMEMBER_CONTROLBOARDS = (byte) 0x20;\n+    private static final int BUSMEMBER_REC_MASK = 0xF0; // interpreting frames delivered to BUSMEMBER_ME &\n+                                                        // BUSMEMBER_REC_MASK\n+    private static final int BUSMEMBER_ME = 0x2F; // used as sender when communicating with the helios system\n+    private static final int POLL_OFFLINE_THRESHOLD = 3;\n+\n+    /** Logger Instance */\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    private @NonNullByDefault({}) HeliosVentilationConfiguration config;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a59f77d1c606a32180e2511e5df9e06ceb1807b"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczOTAyMjYyOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationHandler.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQyMzo0NDoxMFrOGjUB8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMVQxOTozMTo1OVrOGmt0YA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4MTUyMA==", "bodyText": "if thing.getStatus() == ThingStatus.REMOVING shouldn't you exit early?", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r439681520", "createdAt": "2020-06-12T23:44:10Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationHandler.java", "diffHunk": "@@ -0,0 +1,459 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.lang.invoke.MethodHandles;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HeliosVentilationHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosVentilationHandler extends BaseThingHandler implements SerialPortEventListener {\n+    private static final int BUSMEMBER_MAINBOARD = 0x11;\n+    private static final int BUSMEMBER_SLAVEBOARDS = 0x10;\n+    private static final byte BUSMEMBER_CONTROLBOARDS = (byte) 0x20;\n+    private static final int BUSMEMBER_REC_MASK = 0xF0; // interpreting frames delivered to BUSMEMBER_ME &\n+                                                        // BUSMEMBER_REC_MASK\n+    private static final int BUSMEMBER_ME = 0x2F; // used as sender when communicating with the helios system\n+    private static final int POLL_OFFLINE_THRESHOLD = 3;\n+\n+    /** Logger Instance */\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    /* init to default to avoid NPE in case handleCommand() is called before initialize() */\n+    private HeliosVentilationConfiguration config = new HeliosVentilationConfiguration();\n+\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable SerialPort serialPort;\n+    private @Nullable InputStream inputStream;\n+    private @Nullable OutputStream outputStream;\n+\n+    private @Nullable ScheduledFuture<?> pollingTask;\n+    private int pollCounter;\n+\n+    /**\n+     * store received data for read-modify-write operations on bitlevel\n+     */\n+    private Map<Byte, Byte> memory = new HashMap<Byte, Byte>();\n+\n+    public HeliosVentilationHandler(Thing thing, final SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(HeliosVentilationConfiguration.class);\n+\n+        logger.debug(\"Serial Port: {}, 9600 baud, PollPeriod: {}\", config.serialPort, config.pollPeriod);\n+\n+        if (config.serialPort.length() < 1) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port must be set!\");\n+            return;\n+        } else {\n+            SerialPortIdentifier portId = serialPortManager.getIdentifier(config.serialPort);\n+            if (portId == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Port \" + config.serialPort + \" is not known!\");\n+                serialPort = null;\n+            } else {\n+                updateStatus(ThingStatus.UNKNOWN);\n+                if (this.config.pollPeriod > 0) {\n+                    startPolling();\n+                }\n+            }\n+        }\n+\n+        scheduler.execute(this::connect);\n+    }\n+\n+    private synchronized void connect() {\n+        logger.debug(\"HeliosVentilation: connecting...\");\n+        // parse ports and if the port is found, initialize the reader\n+        SerialPortIdentifier portId = serialPortManager.getIdentifier(config.serialPort);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Port \" + config.serialPort + \" is not known!\");\n+            serialPort = null;\n+\n+            disconnect();\n+        } else if (!isConnected()) {\n+            // initialize serial port\n+            try {\n+                SerialPort serial = portId.open(getThing().getUID().toString(), 2000);\n+                serial.setSerialPortParams(9600, SerialPort.DATABITS_8, SerialPort.STOPBITS_1, SerialPort.PARITY_NONE);\n+                serial.addEventListener(this);\n+\n+                try {\n+                    if (inputStream != null) {\n+                        inputStream.close();\n+                    }\n+                } catch (IOException e) {\n+                    // ignore the exception on close\n+                    inputStream = null;\n+                }\n+                try {\n+                    if (outputStream != null) {\n+                        outputStream.close();\n+                    }\n+                } catch (IOException e) {\n+                    // ignore the exception on close\n+                    outputStream = null;\n+                }\n+\n+                inputStream = serial.getInputStream();\n+                outputStream = serial.getOutputStream();\n+\n+                // activate the DATA_AVAILABLE notifier\n+                serial.notifyOnDataAvailable(true);\n+                serialPort = serial;\n+                updateStatus(ThingStatus.UNKNOWN);\n+            } catch (final IOException ex) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"I/O error!\");\n+            } catch (PortInUseException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"Port is in use!\");\n+            } catch (TooManyListenersException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Cannot attach listener to port!\");\n+            } catch (UnsupportedCommOperationException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Serial port does not support the RS485 parameters of the Helios remote protocol.\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        stopPolling();\n+        disconnect();\n+        super.dispose();\n+    }\n+\n+    /**\n+     * Start the polling task.\n+     */\n+    public synchronized void startPolling() {\n+        final ScheduledFuture<?> task = pollingTask;\n+        if (task != null && task.isCancelled()) {\n+            task.cancel(true);\n+        }\n+        if (config.pollPeriod > 0) {\n+            pollingTask = scheduler.scheduleWithFixedDelay(this::polling, 10, config.pollPeriod, TimeUnit.SECONDS);\n+        } else {\n+            pollingTask = null;\n+        }\n+    }\n+\n+    /**\n+     * Stop the polling task.\n+     */\n+    public synchronized void stopPolling() {\n+        final ScheduledFuture<?> task = pollingTask;\n+        if (task != null && !task.isCancelled()) {\n+            task.cancel(true);\n+            pollingTask = null;\n+        }\n+    }\n+\n+    /**\n+     * Method for polling the RS485 Helios RemoteContol bus\n+     */\n+    public synchronized void polling() {\n+        if (logger.isTraceEnabled()) {\n+            logger.trace(\"HeliosVentilation Polling data for '{}'\", getThing().getUID());\n+        }\n+        pollCounter++;\n+        if (pollCounter > POLL_OFFLINE_THRESHOLD) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.GONE, \"No data received!\");\n+            logger.info(\"No data received for '{}' disconnecting now...\", getThing().getUID());\n+            disconnect();\n+        }\n+\n+        if (!isConnected()) {\n+            connect(); // let's try to reconnect if the connection failed or was never established before\n+        }\n+\n+        HeliosVentilationBindingConstants.DATAPOINTS.values().forEach((v) -> {\n+            if (isLinked(v.getName())) {\n+                poll(v);\n+            }\n+        });\n+    }\n+\n+    private void disconnect() {\n+        if (thing.getStatus() != ThingStatus.REMOVING) {\n+            updateStatus(ThingStatus.OFFLINE);\n+        }\n+        synchronized (this) {\n+            try {\n+                if (inputStream != null) {\n+                    inputStream.close();\n+                }\n+            } catch (IOException e) {\n+                // ignore the exception on close\n+                inputStream = null;\n+            }\n+            try {\n+                if (outputStream != null) {\n+                    outputStream.close();\n+                }\n+            } catch (IOException e) {\n+                // ignore the exception on close\n+                outputStream = null;\n+            }\n+\n+            SerialPort serial = serialPort;\n+            if (serial != null) {\n+                serial.close();\n+            }\n+            serialPort = null;\n+        }\n+\n+    }\n+\n+    private void poll(HeliosVentilationDataPoint v) {\n+        byte[] txFrame = { 0x01, BUSMEMBER_ME, BUSMEMBER_MAINBOARD, 0x00, v.address(), 0x00 };\n+        txFrame[5] = (byte) checksum(txFrame);\n+\n+        tx(txFrame);\n+    }\n+\n+    /*\n+     * transmit a frame\n+     */\n+    private void tx(byte[] txFrame) {\n+        try {\n+            OutputStream out = outputStream;\n+            if (out != null) {\n+                if (logger.isTraceEnabled()) {\n+                    logger.trace(\"HeliosVentilation: Write to serial port: {}\",\n+                            String.format(\"%02x %02x %02x %02x\", txFrame[1], txFrame[2], txFrame[3], txFrame[4]));\n+                }\n+\n+                out.write(txFrame);\n+                out.flush();\n+                // after each frame we have to wait.\n+                // 30 ms is taken from what we roughly see the original remote control is doing\n+                Thread.sleep(30);\n+            }\n+        } catch (IOException e) {\n+            // in case we cannot write the connection is somehow broken, let's officially disconnect\n+            disconnect();\n+            connect();\n+        } catch (InterruptedException e) {\n+            // ignore if we got interrupted\n+        }\n+    }\n+\n+    /**\n+     * Check connection status\n+     *\n+     * @return true if currently connected\n+     */\n+    private boolean isConnected() {\n+        return serialPort != null && inputStream != null && outputStream != null;\n+    }\n+\n+    @Override\n+    public synchronized void serialEvent(SerialPortEvent event) {\n+        switch (event.getEventType()) {\n+            case SerialPortEvent.DATA_AVAILABLE:\n+                // we get here if data has been received\n+\n+                try {\n+                    // Wait roughly a frame length to ensure that the complete frame is already buffered. This improves\n+                    // the robustness for RS485/USB converters which sometimes duplicate bytes otherwise.\n+                    Thread.sleep(8);\n+                } catch (InterruptedException e) {\n+                    // ignore interruption\n+                }\n+\n+                byte[] frame = { 0, 0, 0, 0, 0, 0 };\n+                InputStream in = inputStream;\n+                if (in != null) {\n+                    try {\n+                        do {\n+                            int cnt = 0;\n+                            // read data from serial device\n+                            while (cnt < 6 && in.available() > 0) {\n+                                final int bytes = in.read(frame, cnt, 1);\n+                                if (cnt > 0 || frame[0] == 0x01) {\n+                                    // only proceed if the first byte was 0x01\n+                                    cnt += bytes;\n+                                }\n+                            }\n+                            int sum = checksum(frame);\n+                            if (sum == (frame[5] & 0xff)) {\n+                                if (logger.isTraceEnabled()) {\n+                                    logger.trace(\"HeliosVentilation: Read from serial port: {}\", String\n+                                            .format(\"%02x %02x %02x %02x\", frame[1], frame[2], frame[3], frame[4]));\n+                                }\n+                                interpretFrame(frame);\n+\n+                            } else {\n+                                if (logger.isTraceEnabled()) {\n+                                    logger.trace(\n+                                            \"HeliosVentilation: Read frame with not matching checksum from serial port: {}\",\n+                                            String.format(\"%02x %02x %02x %02x %02x %02x (expected %02x)\", frame[0],\n+                                                    frame[1], frame[2], frame[3], frame[4], frame[5], sum));\n+                                }\n+\n+                            }\n+\n+                        } while (in.available() > 0);\n+\n+                    } catch (IOException e1) {\n+                        logger.debug(\"Error reading from serial port: {}\", e1.getMessage(), e1);\n+                    }\n+                }\n+                break;\n+            default:\n+                break;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            scheduler.execute(this::polling);\n+        } else if (command instanceof DecimalType || command instanceof QuantityType || command instanceof OnOffType) {\n+            scheduler.execute(() -> update(channelUID, command));\n+        }\n+    }\n+\n+    /**\n+     * Update the variable corresponding to given channel/command\n+     *\n+     * @param channelUID UID of the channel to update\n+     * @param command data element to write\n+     *\n+     */\n+    public void update(ChannelUID channelUID, Command command) {\n+        HeliosVentilationBindingConstants.DATAPOINTS.values().forEach((outer) -> {\n+            HeliosVentilationDataPoint v = outer;\n+            do {\n+                if (channelUID.getThingUID().equals(thing.getUID()) && v.getName().equals(channelUID.getId())) {\n+                    if (v.isWritable()) {\n+                        byte[] txFrame = { 0x01, BUSMEMBER_ME, BUSMEMBER_CONTROLBOARDS, v.address(), 0x00, 0x00 };\n+                        txFrame[4] = v.getTransmitDataFor((State) command);\n+                        if (v.requiresReadModifyWrite()) {\n+                            txFrame[4] |= memory.get(v.address()) & ~v.bitMask();\n+                            memory.put(v.address(), txFrame[4]);\n+                        }\n+                        txFrame[5] = (byte) checksum(txFrame);\n+                        tx(txFrame);\n+\n+                        txFrame[2] = BUSMEMBER_SLAVEBOARDS;\n+                        txFrame[5] = (byte) checksum(txFrame);\n+                        tx(txFrame);\n+\n+                        txFrame[2] = BUSMEMBER_MAINBOARD;\n+                        txFrame[5] = (byte) checksum(txFrame);\n+                        tx(txFrame);\n+                    }\n+                }\n+                v = v.link();\n+            } while (v != null);\n+        });\n+\n+    }\n+\n+    /**\n+     * calculate checksum of a frame\n+     *\n+     * @param frame filled with 5 bytes\n+     * @return checksum of the first 5 bytes of frame\n+     */\n+    private int checksum(byte[] frame) {\n+        int sum = 0;\n+        for (int a = 0; a < 5; a++) {\n+            sum += frame[a] & 0xff;\n+        }\n+        sum %= 256;\n+        return sum;\n+    }\n+\n+    /**\n+     * interpret a frame, which is already validated to be in correct format with valid checksum\n+     *\n+     * @param frame 6 bytes long data with 0x01, sender, receiver, address, value, checksum\n+     */\n+    private void interpretFrame(byte[] frame) {\n+        if ((frame[2] & BUSMEMBER_REC_MASK) == (BUSMEMBER_ME & BUSMEMBER_REC_MASK)) {\n+            // something to read for us\n+            byte var = frame[3];\n+            byte val = frame[4];\n+            if (HeliosVentilationBindingConstants.DATAPOINTS.containsKey(var)) {\n+                HeliosVentilationDataPoint datapoint = HeliosVentilationBindingConstants.DATAPOINTS.get(var);\n+                if (datapoint.requiresReadModifyWrite()) {\n+                    memory.put(var, val);\n+                }\n+                do {\n+                    if (logger.isTraceEnabled()) {\n+                        String t = datapoint.asString(val);\n+                        logger.trace(\"Received {} = {}\", datapoint, t);\n+                    }\n+                    if (thing.getStatus() != ThingStatus.REMOVING) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b1658af39ccc8a2f98f4cc318896c32ee4ff9a4"}, "originalPosition": 441}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTgzNzk1OQ==", "bodyText": "I didn't put this for fun but think that I had an issue that serialEvent was still called in another thread before everything was closed, and updating state and status doesn't in this case doesn't make any sense.", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r439837959", "createdAt": "2020-06-14T14:55:30Z", "author": {"login": "ramack"}, "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationHandler.java", "diffHunk": "@@ -0,0 +1,459 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.lang.invoke.MethodHandles;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HeliosVentilationHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosVentilationHandler extends BaseThingHandler implements SerialPortEventListener {\n+    private static final int BUSMEMBER_MAINBOARD = 0x11;\n+    private static final int BUSMEMBER_SLAVEBOARDS = 0x10;\n+    private static final byte BUSMEMBER_CONTROLBOARDS = (byte) 0x20;\n+    private static final int BUSMEMBER_REC_MASK = 0xF0; // interpreting frames delivered to BUSMEMBER_ME &\n+                                                        // BUSMEMBER_REC_MASK\n+    private static final int BUSMEMBER_ME = 0x2F; // used as sender when communicating with the helios system\n+    private static final int POLL_OFFLINE_THRESHOLD = 3;\n+\n+    /** Logger Instance */\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    /* init to default to avoid NPE in case handleCommand() is called before initialize() */\n+    private HeliosVentilationConfiguration config = new HeliosVentilationConfiguration();\n+\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable SerialPort serialPort;\n+    private @Nullable InputStream inputStream;\n+    private @Nullable OutputStream outputStream;\n+\n+    private @Nullable ScheduledFuture<?> pollingTask;\n+    private int pollCounter;\n+\n+    /**\n+     * store received data for read-modify-write operations on bitlevel\n+     */\n+    private Map<Byte, Byte> memory = new HashMap<Byte, Byte>();\n+\n+    public HeliosVentilationHandler(Thing thing, final SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(HeliosVentilationConfiguration.class);\n+\n+        logger.debug(\"Serial Port: {}, 9600 baud, PollPeriod: {}\", config.serialPort, config.pollPeriod);\n+\n+        if (config.serialPort.length() < 1) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port must be set!\");\n+            return;\n+        } else {\n+            SerialPortIdentifier portId = serialPortManager.getIdentifier(config.serialPort);\n+            if (portId == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Port \" + config.serialPort + \" is not known!\");\n+                serialPort = null;\n+            } else {\n+                updateStatus(ThingStatus.UNKNOWN);\n+                if (this.config.pollPeriod > 0) {\n+                    startPolling();\n+                }\n+            }\n+        }\n+\n+        scheduler.execute(this::connect);\n+    }\n+\n+    private synchronized void connect() {\n+        logger.debug(\"HeliosVentilation: connecting...\");\n+        // parse ports and if the port is found, initialize the reader\n+        SerialPortIdentifier portId = serialPortManager.getIdentifier(config.serialPort);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Port \" + config.serialPort + \" is not known!\");\n+            serialPort = null;\n+\n+            disconnect();\n+        } else if (!isConnected()) {\n+            // initialize serial port\n+            try {\n+                SerialPort serial = portId.open(getThing().getUID().toString(), 2000);\n+                serial.setSerialPortParams(9600, SerialPort.DATABITS_8, SerialPort.STOPBITS_1, SerialPort.PARITY_NONE);\n+                serial.addEventListener(this);\n+\n+                try {\n+                    if (inputStream != null) {\n+                        inputStream.close();\n+                    }\n+                } catch (IOException e) {\n+                    // ignore the exception on close\n+                    inputStream = null;\n+                }\n+                try {\n+                    if (outputStream != null) {\n+                        outputStream.close();\n+                    }\n+                } catch (IOException e) {\n+                    // ignore the exception on close\n+                    outputStream = null;\n+                }\n+\n+                inputStream = serial.getInputStream();\n+                outputStream = serial.getOutputStream();\n+\n+                // activate the DATA_AVAILABLE notifier\n+                serial.notifyOnDataAvailable(true);\n+                serialPort = serial;\n+                updateStatus(ThingStatus.UNKNOWN);\n+            } catch (final IOException ex) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"I/O error!\");\n+            } catch (PortInUseException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"Port is in use!\");\n+            } catch (TooManyListenersException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Cannot attach listener to port!\");\n+            } catch (UnsupportedCommOperationException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Serial port does not support the RS485 parameters of the Helios remote protocol.\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        stopPolling();\n+        disconnect();\n+        super.dispose();\n+    }\n+\n+    /**\n+     * Start the polling task.\n+     */\n+    public synchronized void startPolling() {\n+        final ScheduledFuture<?> task = pollingTask;\n+        if (task != null && task.isCancelled()) {\n+            task.cancel(true);\n+        }\n+        if (config.pollPeriod > 0) {\n+            pollingTask = scheduler.scheduleWithFixedDelay(this::polling, 10, config.pollPeriod, TimeUnit.SECONDS);\n+        } else {\n+            pollingTask = null;\n+        }\n+    }\n+\n+    /**\n+     * Stop the polling task.\n+     */\n+    public synchronized void stopPolling() {\n+        final ScheduledFuture<?> task = pollingTask;\n+        if (task != null && !task.isCancelled()) {\n+            task.cancel(true);\n+            pollingTask = null;\n+        }\n+    }\n+\n+    /**\n+     * Method for polling the RS485 Helios RemoteContol bus\n+     */\n+    public synchronized void polling() {\n+        if (logger.isTraceEnabled()) {\n+            logger.trace(\"HeliosVentilation Polling data for '{}'\", getThing().getUID());\n+        }\n+        pollCounter++;\n+        if (pollCounter > POLL_OFFLINE_THRESHOLD) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.GONE, \"No data received!\");\n+            logger.info(\"No data received for '{}' disconnecting now...\", getThing().getUID());\n+            disconnect();\n+        }\n+\n+        if (!isConnected()) {\n+            connect(); // let's try to reconnect if the connection failed or was never established before\n+        }\n+\n+        HeliosVentilationBindingConstants.DATAPOINTS.values().forEach((v) -> {\n+            if (isLinked(v.getName())) {\n+                poll(v);\n+            }\n+        });\n+    }\n+\n+    private void disconnect() {\n+        if (thing.getStatus() != ThingStatus.REMOVING) {\n+            updateStatus(ThingStatus.OFFLINE);\n+        }\n+        synchronized (this) {\n+            try {\n+                if (inputStream != null) {\n+                    inputStream.close();\n+                }\n+            } catch (IOException e) {\n+                // ignore the exception on close\n+                inputStream = null;\n+            }\n+            try {\n+                if (outputStream != null) {\n+                    outputStream.close();\n+                }\n+            } catch (IOException e) {\n+                // ignore the exception on close\n+                outputStream = null;\n+            }\n+\n+            SerialPort serial = serialPort;\n+            if (serial != null) {\n+                serial.close();\n+            }\n+            serialPort = null;\n+        }\n+\n+    }\n+\n+    private void poll(HeliosVentilationDataPoint v) {\n+        byte[] txFrame = { 0x01, BUSMEMBER_ME, BUSMEMBER_MAINBOARD, 0x00, v.address(), 0x00 };\n+        txFrame[5] = (byte) checksum(txFrame);\n+\n+        tx(txFrame);\n+    }\n+\n+    /*\n+     * transmit a frame\n+     */\n+    private void tx(byte[] txFrame) {\n+        try {\n+            OutputStream out = outputStream;\n+            if (out != null) {\n+                if (logger.isTraceEnabled()) {\n+                    logger.trace(\"HeliosVentilation: Write to serial port: {}\",\n+                            String.format(\"%02x %02x %02x %02x\", txFrame[1], txFrame[2], txFrame[3], txFrame[4]));\n+                }\n+\n+                out.write(txFrame);\n+                out.flush();\n+                // after each frame we have to wait.\n+                // 30 ms is taken from what we roughly see the original remote control is doing\n+                Thread.sleep(30);\n+            }\n+        } catch (IOException e) {\n+            // in case we cannot write the connection is somehow broken, let's officially disconnect\n+            disconnect();\n+            connect();\n+        } catch (InterruptedException e) {\n+            // ignore if we got interrupted\n+        }\n+    }\n+\n+    /**\n+     * Check connection status\n+     *\n+     * @return true if currently connected\n+     */\n+    private boolean isConnected() {\n+        return serialPort != null && inputStream != null && outputStream != null;\n+    }\n+\n+    @Override\n+    public synchronized void serialEvent(SerialPortEvent event) {\n+        switch (event.getEventType()) {\n+            case SerialPortEvent.DATA_AVAILABLE:\n+                // we get here if data has been received\n+\n+                try {\n+                    // Wait roughly a frame length to ensure that the complete frame is already buffered. This improves\n+                    // the robustness for RS485/USB converters which sometimes duplicate bytes otherwise.\n+                    Thread.sleep(8);\n+                } catch (InterruptedException e) {\n+                    // ignore interruption\n+                }\n+\n+                byte[] frame = { 0, 0, 0, 0, 0, 0 };\n+                InputStream in = inputStream;\n+                if (in != null) {\n+                    try {\n+                        do {\n+                            int cnt = 0;\n+                            // read data from serial device\n+                            while (cnt < 6 && in.available() > 0) {\n+                                final int bytes = in.read(frame, cnt, 1);\n+                                if (cnt > 0 || frame[0] == 0x01) {\n+                                    // only proceed if the first byte was 0x01\n+                                    cnt += bytes;\n+                                }\n+                            }\n+                            int sum = checksum(frame);\n+                            if (sum == (frame[5] & 0xff)) {\n+                                if (logger.isTraceEnabled()) {\n+                                    logger.trace(\"HeliosVentilation: Read from serial port: {}\", String\n+                                            .format(\"%02x %02x %02x %02x\", frame[1], frame[2], frame[3], frame[4]));\n+                                }\n+                                interpretFrame(frame);\n+\n+                            } else {\n+                                if (logger.isTraceEnabled()) {\n+                                    logger.trace(\n+                                            \"HeliosVentilation: Read frame with not matching checksum from serial port: {}\",\n+                                            String.format(\"%02x %02x %02x %02x %02x %02x (expected %02x)\", frame[0],\n+                                                    frame[1], frame[2], frame[3], frame[4], frame[5], sum));\n+                                }\n+\n+                            }\n+\n+                        } while (in.available() > 0);\n+\n+                    } catch (IOException e1) {\n+                        logger.debug(\"Error reading from serial port: {}\", e1.getMessage(), e1);\n+                    }\n+                }\n+                break;\n+            default:\n+                break;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            scheduler.execute(this::polling);\n+        } else if (command instanceof DecimalType || command instanceof QuantityType || command instanceof OnOffType) {\n+            scheduler.execute(() -> update(channelUID, command));\n+        }\n+    }\n+\n+    /**\n+     * Update the variable corresponding to given channel/command\n+     *\n+     * @param channelUID UID of the channel to update\n+     * @param command data element to write\n+     *\n+     */\n+    public void update(ChannelUID channelUID, Command command) {\n+        HeliosVentilationBindingConstants.DATAPOINTS.values().forEach((outer) -> {\n+            HeliosVentilationDataPoint v = outer;\n+            do {\n+                if (channelUID.getThingUID().equals(thing.getUID()) && v.getName().equals(channelUID.getId())) {\n+                    if (v.isWritable()) {\n+                        byte[] txFrame = { 0x01, BUSMEMBER_ME, BUSMEMBER_CONTROLBOARDS, v.address(), 0x00, 0x00 };\n+                        txFrame[4] = v.getTransmitDataFor((State) command);\n+                        if (v.requiresReadModifyWrite()) {\n+                            txFrame[4] |= memory.get(v.address()) & ~v.bitMask();\n+                            memory.put(v.address(), txFrame[4]);\n+                        }\n+                        txFrame[5] = (byte) checksum(txFrame);\n+                        tx(txFrame);\n+\n+                        txFrame[2] = BUSMEMBER_SLAVEBOARDS;\n+                        txFrame[5] = (byte) checksum(txFrame);\n+                        tx(txFrame);\n+\n+                        txFrame[2] = BUSMEMBER_MAINBOARD;\n+                        txFrame[5] = (byte) checksum(txFrame);\n+                        tx(txFrame);\n+                    }\n+                }\n+                v = v.link();\n+            } while (v != null);\n+        });\n+\n+    }\n+\n+    /**\n+     * calculate checksum of a frame\n+     *\n+     * @param frame filled with 5 bytes\n+     * @return checksum of the first 5 bytes of frame\n+     */\n+    private int checksum(byte[] frame) {\n+        int sum = 0;\n+        for (int a = 0; a < 5; a++) {\n+            sum += frame[a] & 0xff;\n+        }\n+        sum %= 256;\n+        return sum;\n+    }\n+\n+    /**\n+     * interpret a frame, which is already validated to be in correct format with valid checksum\n+     *\n+     * @param frame 6 bytes long data with 0x01, sender, receiver, address, value, checksum\n+     */\n+    private void interpretFrame(byte[] frame) {\n+        if ((frame[2] & BUSMEMBER_REC_MASK) == (BUSMEMBER_ME & BUSMEMBER_REC_MASK)) {\n+            // something to read for us\n+            byte var = frame[3];\n+            byte val = frame[4];\n+            if (HeliosVentilationBindingConstants.DATAPOINTS.containsKey(var)) {\n+                HeliosVentilationDataPoint datapoint = HeliosVentilationBindingConstants.DATAPOINTS.get(var);\n+                if (datapoint.requiresReadModifyWrite()) {\n+                    memory.put(var, val);\n+                }\n+                do {\n+                    if (logger.isTraceEnabled()) {\n+                        String t = datapoint.asString(val);\n+                        logger.trace(\"Received {} = {}\", datapoint, t);\n+                    }\n+                    if (thing.getStatus() != ThingStatus.REMOVING) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4MTUyMA=="}, "originalCommit": {"oid": "7b1658af39ccc8a2f98f4cc318896c32ee4ff9a4"}, "originalPosition": 441}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY5NzUzOQ==", "bodyText": "Interesting. Before the thing is removed, it should have completed dispose() and nothing should be alive then. If this happens, either this is a bug in the framework or something from the serial handling is still alive when dispose() finished.", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r441697539", "createdAt": "2020-06-17T17:07:19Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationHandler.java", "diffHunk": "@@ -0,0 +1,459 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.lang.invoke.MethodHandles;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HeliosVentilationHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosVentilationHandler extends BaseThingHandler implements SerialPortEventListener {\n+    private static final int BUSMEMBER_MAINBOARD = 0x11;\n+    private static final int BUSMEMBER_SLAVEBOARDS = 0x10;\n+    private static final byte BUSMEMBER_CONTROLBOARDS = (byte) 0x20;\n+    private static final int BUSMEMBER_REC_MASK = 0xF0; // interpreting frames delivered to BUSMEMBER_ME &\n+                                                        // BUSMEMBER_REC_MASK\n+    private static final int BUSMEMBER_ME = 0x2F; // used as sender when communicating with the helios system\n+    private static final int POLL_OFFLINE_THRESHOLD = 3;\n+\n+    /** Logger Instance */\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    /* init to default to avoid NPE in case handleCommand() is called before initialize() */\n+    private HeliosVentilationConfiguration config = new HeliosVentilationConfiguration();\n+\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable SerialPort serialPort;\n+    private @Nullable InputStream inputStream;\n+    private @Nullable OutputStream outputStream;\n+\n+    private @Nullable ScheduledFuture<?> pollingTask;\n+    private int pollCounter;\n+\n+    /**\n+     * store received data for read-modify-write operations on bitlevel\n+     */\n+    private Map<Byte, Byte> memory = new HashMap<Byte, Byte>();\n+\n+    public HeliosVentilationHandler(Thing thing, final SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(HeliosVentilationConfiguration.class);\n+\n+        logger.debug(\"Serial Port: {}, 9600 baud, PollPeriod: {}\", config.serialPort, config.pollPeriod);\n+\n+        if (config.serialPort.length() < 1) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port must be set!\");\n+            return;\n+        } else {\n+            SerialPortIdentifier portId = serialPortManager.getIdentifier(config.serialPort);\n+            if (portId == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Port \" + config.serialPort + \" is not known!\");\n+                serialPort = null;\n+            } else {\n+                updateStatus(ThingStatus.UNKNOWN);\n+                if (this.config.pollPeriod > 0) {\n+                    startPolling();\n+                }\n+            }\n+        }\n+\n+        scheduler.execute(this::connect);\n+    }\n+\n+    private synchronized void connect() {\n+        logger.debug(\"HeliosVentilation: connecting...\");\n+        // parse ports and if the port is found, initialize the reader\n+        SerialPortIdentifier portId = serialPortManager.getIdentifier(config.serialPort);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Port \" + config.serialPort + \" is not known!\");\n+            serialPort = null;\n+\n+            disconnect();\n+        } else if (!isConnected()) {\n+            // initialize serial port\n+            try {\n+                SerialPort serial = portId.open(getThing().getUID().toString(), 2000);\n+                serial.setSerialPortParams(9600, SerialPort.DATABITS_8, SerialPort.STOPBITS_1, SerialPort.PARITY_NONE);\n+                serial.addEventListener(this);\n+\n+                try {\n+                    if (inputStream != null) {\n+                        inputStream.close();\n+                    }\n+                } catch (IOException e) {\n+                    // ignore the exception on close\n+                    inputStream = null;\n+                }\n+                try {\n+                    if (outputStream != null) {\n+                        outputStream.close();\n+                    }\n+                } catch (IOException e) {\n+                    // ignore the exception on close\n+                    outputStream = null;\n+                }\n+\n+                inputStream = serial.getInputStream();\n+                outputStream = serial.getOutputStream();\n+\n+                // activate the DATA_AVAILABLE notifier\n+                serial.notifyOnDataAvailable(true);\n+                serialPort = serial;\n+                updateStatus(ThingStatus.UNKNOWN);\n+            } catch (final IOException ex) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"I/O error!\");\n+            } catch (PortInUseException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"Port is in use!\");\n+            } catch (TooManyListenersException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Cannot attach listener to port!\");\n+            } catch (UnsupportedCommOperationException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Serial port does not support the RS485 parameters of the Helios remote protocol.\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        stopPolling();\n+        disconnect();\n+        super.dispose();\n+    }\n+\n+    /**\n+     * Start the polling task.\n+     */\n+    public synchronized void startPolling() {\n+        final ScheduledFuture<?> task = pollingTask;\n+        if (task != null && task.isCancelled()) {\n+            task.cancel(true);\n+        }\n+        if (config.pollPeriod > 0) {\n+            pollingTask = scheduler.scheduleWithFixedDelay(this::polling, 10, config.pollPeriod, TimeUnit.SECONDS);\n+        } else {\n+            pollingTask = null;\n+        }\n+    }\n+\n+    /**\n+     * Stop the polling task.\n+     */\n+    public synchronized void stopPolling() {\n+        final ScheduledFuture<?> task = pollingTask;\n+        if (task != null && !task.isCancelled()) {\n+            task.cancel(true);\n+            pollingTask = null;\n+        }\n+    }\n+\n+    /**\n+     * Method for polling the RS485 Helios RemoteContol bus\n+     */\n+    public synchronized void polling() {\n+        if (logger.isTraceEnabled()) {\n+            logger.trace(\"HeliosVentilation Polling data for '{}'\", getThing().getUID());\n+        }\n+        pollCounter++;\n+        if (pollCounter > POLL_OFFLINE_THRESHOLD) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.GONE, \"No data received!\");\n+            logger.info(\"No data received for '{}' disconnecting now...\", getThing().getUID());\n+            disconnect();\n+        }\n+\n+        if (!isConnected()) {\n+            connect(); // let's try to reconnect if the connection failed or was never established before\n+        }\n+\n+        HeliosVentilationBindingConstants.DATAPOINTS.values().forEach((v) -> {\n+            if (isLinked(v.getName())) {\n+                poll(v);\n+            }\n+        });\n+    }\n+\n+    private void disconnect() {\n+        if (thing.getStatus() != ThingStatus.REMOVING) {\n+            updateStatus(ThingStatus.OFFLINE);\n+        }\n+        synchronized (this) {\n+            try {\n+                if (inputStream != null) {\n+                    inputStream.close();\n+                }\n+            } catch (IOException e) {\n+                // ignore the exception on close\n+                inputStream = null;\n+            }\n+            try {\n+                if (outputStream != null) {\n+                    outputStream.close();\n+                }\n+            } catch (IOException e) {\n+                // ignore the exception on close\n+                outputStream = null;\n+            }\n+\n+            SerialPort serial = serialPort;\n+            if (serial != null) {\n+                serial.close();\n+            }\n+            serialPort = null;\n+        }\n+\n+    }\n+\n+    private void poll(HeliosVentilationDataPoint v) {\n+        byte[] txFrame = { 0x01, BUSMEMBER_ME, BUSMEMBER_MAINBOARD, 0x00, v.address(), 0x00 };\n+        txFrame[5] = (byte) checksum(txFrame);\n+\n+        tx(txFrame);\n+    }\n+\n+    /*\n+     * transmit a frame\n+     */\n+    private void tx(byte[] txFrame) {\n+        try {\n+            OutputStream out = outputStream;\n+            if (out != null) {\n+                if (logger.isTraceEnabled()) {\n+                    logger.trace(\"HeliosVentilation: Write to serial port: {}\",\n+                            String.format(\"%02x %02x %02x %02x\", txFrame[1], txFrame[2], txFrame[3], txFrame[4]));\n+                }\n+\n+                out.write(txFrame);\n+                out.flush();\n+                // after each frame we have to wait.\n+                // 30 ms is taken from what we roughly see the original remote control is doing\n+                Thread.sleep(30);\n+            }\n+        } catch (IOException e) {\n+            // in case we cannot write the connection is somehow broken, let's officially disconnect\n+            disconnect();\n+            connect();\n+        } catch (InterruptedException e) {\n+            // ignore if we got interrupted\n+        }\n+    }\n+\n+    /**\n+     * Check connection status\n+     *\n+     * @return true if currently connected\n+     */\n+    private boolean isConnected() {\n+        return serialPort != null && inputStream != null && outputStream != null;\n+    }\n+\n+    @Override\n+    public synchronized void serialEvent(SerialPortEvent event) {\n+        switch (event.getEventType()) {\n+            case SerialPortEvent.DATA_AVAILABLE:\n+                // we get here if data has been received\n+\n+                try {\n+                    // Wait roughly a frame length to ensure that the complete frame is already buffered. This improves\n+                    // the robustness for RS485/USB converters which sometimes duplicate bytes otherwise.\n+                    Thread.sleep(8);\n+                } catch (InterruptedException e) {\n+                    // ignore interruption\n+                }\n+\n+                byte[] frame = { 0, 0, 0, 0, 0, 0 };\n+                InputStream in = inputStream;\n+                if (in != null) {\n+                    try {\n+                        do {\n+                            int cnt = 0;\n+                            // read data from serial device\n+                            while (cnt < 6 && in.available() > 0) {\n+                                final int bytes = in.read(frame, cnt, 1);\n+                                if (cnt > 0 || frame[0] == 0x01) {\n+                                    // only proceed if the first byte was 0x01\n+                                    cnt += bytes;\n+                                }\n+                            }\n+                            int sum = checksum(frame);\n+                            if (sum == (frame[5] & 0xff)) {\n+                                if (logger.isTraceEnabled()) {\n+                                    logger.trace(\"HeliosVentilation: Read from serial port: {}\", String\n+                                            .format(\"%02x %02x %02x %02x\", frame[1], frame[2], frame[3], frame[4]));\n+                                }\n+                                interpretFrame(frame);\n+\n+                            } else {\n+                                if (logger.isTraceEnabled()) {\n+                                    logger.trace(\n+                                            \"HeliosVentilation: Read frame with not matching checksum from serial port: {}\",\n+                                            String.format(\"%02x %02x %02x %02x %02x %02x (expected %02x)\", frame[0],\n+                                                    frame[1], frame[2], frame[3], frame[4], frame[5], sum));\n+                                }\n+\n+                            }\n+\n+                        } while (in.available() > 0);\n+\n+                    } catch (IOException e1) {\n+                        logger.debug(\"Error reading from serial port: {}\", e1.getMessage(), e1);\n+                    }\n+                }\n+                break;\n+            default:\n+                break;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            scheduler.execute(this::polling);\n+        } else if (command instanceof DecimalType || command instanceof QuantityType || command instanceof OnOffType) {\n+            scheduler.execute(() -> update(channelUID, command));\n+        }\n+    }\n+\n+    /**\n+     * Update the variable corresponding to given channel/command\n+     *\n+     * @param channelUID UID of the channel to update\n+     * @param command data element to write\n+     *\n+     */\n+    public void update(ChannelUID channelUID, Command command) {\n+        HeliosVentilationBindingConstants.DATAPOINTS.values().forEach((outer) -> {\n+            HeliosVentilationDataPoint v = outer;\n+            do {\n+                if (channelUID.getThingUID().equals(thing.getUID()) && v.getName().equals(channelUID.getId())) {\n+                    if (v.isWritable()) {\n+                        byte[] txFrame = { 0x01, BUSMEMBER_ME, BUSMEMBER_CONTROLBOARDS, v.address(), 0x00, 0x00 };\n+                        txFrame[4] = v.getTransmitDataFor((State) command);\n+                        if (v.requiresReadModifyWrite()) {\n+                            txFrame[4] |= memory.get(v.address()) & ~v.bitMask();\n+                            memory.put(v.address(), txFrame[4]);\n+                        }\n+                        txFrame[5] = (byte) checksum(txFrame);\n+                        tx(txFrame);\n+\n+                        txFrame[2] = BUSMEMBER_SLAVEBOARDS;\n+                        txFrame[5] = (byte) checksum(txFrame);\n+                        tx(txFrame);\n+\n+                        txFrame[2] = BUSMEMBER_MAINBOARD;\n+                        txFrame[5] = (byte) checksum(txFrame);\n+                        tx(txFrame);\n+                    }\n+                }\n+                v = v.link();\n+            } while (v != null);\n+        });\n+\n+    }\n+\n+    /**\n+     * calculate checksum of a frame\n+     *\n+     * @param frame filled with 5 bytes\n+     * @return checksum of the first 5 bytes of frame\n+     */\n+    private int checksum(byte[] frame) {\n+        int sum = 0;\n+        for (int a = 0; a < 5; a++) {\n+            sum += frame[a] & 0xff;\n+        }\n+        sum %= 256;\n+        return sum;\n+    }\n+\n+    /**\n+     * interpret a frame, which is already validated to be in correct format with valid checksum\n+     *\n+     * @param frame 6 bytes long data with 0x01, sender, receiver, address, value, checksum\n+     */\n+    private void interpretFrame(byte[] frame) {\n+        if ((frame[2] & BUSMEMBER_REC_MASK) == (BUSMEMBER_ME & BUSMEMBER_REC_MASK)) {\n+            // something to read for us\n+            byte var = frame[3];\n+            byte val = frame[4];\n+            if (HeliosVentilationBindingConstants.DATAPOINTS.containsKey(var)) {\n+                HeliosVentilationDataPoint datapoint = HeliosVentilationBindingConstants.DATAPOINTS.get(var);\n+                if (datapoint.requiresReadModifyWrite()) {\n+                    memory.put(var, val);\n+                }\n+                do {\n+                    if (logger.isTraceEnabled()) {\n+                        String t = datapoint.asString(val);\n+                        logger.trace(\"Received {} = {}\", datapoint, t);\n+                    }\n+                    if (thing.getStatus() != ThingStatus.REMOVING) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4MTUyMA=="}, "originalCommit": {"oid": "7b1658af39ccc8a2f98f4cc318896c32ee4ff9a4"}, "originalPosition": 441}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI0OTc2MA==", "bodyText": "ok, I tried again and the need for this condition did not show up again, so I removed it now. I believe that one of the recently added synchronized keywords helped here or the openhab core changed since I initially wrote that some months ago.", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r443249760", "createdAt": "2020-06-21T19:31:59Z", "author": {"login": "ramack"}, "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationHandler.java", "diffHunk": "@@ -0,0 +1,459 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.lang.invoke.MethodHandles;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HeliosVentilationHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosVentilationHandler extends BaseThingHandler implements SerialPortEventListener {\n+    private static final int BUSMEMBER_MAINBOARD = 0x11;\n+    private static final int BUSMEMBER_SLAVEBOARDS = 0x10;\n+    private static final byte BUSMEMBER_CONTROLBOARDS = (byte) 0x20;\n+    private static final int BUSMEMBER_REC_MASK = 0xF0; // interpreting frames delivered to BUSMEMBER_ME &\n+                                                        // BUSMEMBER_REC_MASK\n+    private static final int BUSMEMBER_ME = 0x2F; // used as sender when communicating with the helios system\n+    private static final int POLL_OFFLINE_THRESHOLD = 3;\n+\n+    /** Logger Instance */\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    /* init to default to avoid NPE in case handleCommand() is called before initialize() */\n+    private HeliosVentilationConfiguration config = new HeliosVentilationConfiguration();\n+\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable SerialPort serialPort;\n+    private @Nullable InputStream inputStream;\n+    private @Nullable OutputStream outputStream;\n+\n+    private @Nullable ScheduledFuture<?> pollingTask;\n+    private int pollCounter;\n+\n+    /**\n+     * store received data for read-modify-write operations on bitlevel\n+     */\n+    private Map<Byte, Byte> memory = new HashMap<Byte, Byte>();\n+\n+    public HeliosVentilationHandler(Thing thing, final SerialPortManager serialPortManager) {\n+        super(thing);\n+        this.serialPortManager = serialPortManager;\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        config = getConfigAs(HeliosVentilationConfiguration.class);\n+\n+        logger.debug(\"Serial Port: {}, 9600 baud, PollPeriod: {}\", config.serialPort, config.pollPeriod);\n+\n+        if (config.serialPort.length() < 1) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR, \"Port must be set!\");\n+            return;\n+        } else {\n+            SerialPortIdentifier portId = serialPortManager.getIdentifier(config.serialPort);\n+            if (portId == null) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                        \"Port \" + config.serialPort + \" is not known!\");\n+                serialPort = null;\n+            } else {\n+                updateStatus(ThingStatus.UNKNOWN);\n+                if (this.config.pollPeriod > 0) {\n+                    startPolling();\n+                }\n+            }\n+        }\n+\n+        scheduler.execute(this::connect);\n+    }\n+\n+    private synchronized void connect() {\n+        logger.debug(\"HeliosVentilation: connecting...\");\n+        // parse ports and if the port is found, initialize the reader\n+        SerialPortIdentifier portId = serialPortManager.getIdentifier(config.serialPort);\n+        if (portId == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.CONFIGURATION_ERROR,\n+                    \"Port \" + config.serialPort + \" is not known!\");\n+            serialPort = null;\n+\n+            disconnect();\n+        } else if (!isConnected()) {\n+            // initialize serial port\n+            try {\n+                SerialPort serial = portId.open(getThing().getUID().toString(), 2000);\n+                serial.setSerialPortParams(9600, SerialPort.DATABITS_8, SerialPort.STOPBITS_1, SerialPort.PARITY_NONE);\n+                serial.addEventListener(this);\n+\n+                try {\n+                    if (inputStream != null) {\n+                        inputStream.close();\n+                    }\n+                } catch (IOException e) {\n+                    // ignore the exception on close\n+                    inputStream = null;\n+                }\n+                try {\n+                    if (outputStream != null) {\n+                        outputStream.close();\n+                    }\n+                } catch (IOException e) {\n+                    // ignore the exception on close\n+                    outputStream = null;\n+                }\n+\n+                inputStream = serial.getInputStream();\n+                outputStream = serial.getOutputStream();\n+\n+                // activate the DATA_AVAILABLE notifier\n+                serial.notifyOnDataAvailable(true);\n+                serialPort = serial;\n+                updateStatus(ThingStatus.UNKNOWN);\n+            } catch (final IOException ex) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"I/O error!\");\n+            } catch (PortInUseException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, \"Port is in use!\");\n+            } catch (TooManyListenersException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Cannot attach listener to port!\");\n+            } catch (UnsupportedCommOperationException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR,\n+                        \"Serial port does not support the RS485 parameters of the Helios remote protocol.\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        stopPolling();\n+        disconnect();\n+        super.dispose();\n+    }\n+\n+    /**\n+     * Start the polling task.\n+     */\n+    public synchronized void startPolling() {\n+        final ScheduledFuture<?> task = pollingTask;\n+        if (task != null && task.isCancelled()) {\n+            task.cancel(true);\n+        }\n+        if (config.pollPeriod > 0) {\n+            pollingTask = scheduler.scheduleWithFixedDelay(this::polling, 10, config.pollPeriod, TimeUnit.SECONDS);\n+        } else {\n+            pollingTask = null;\n+        }\n+    }\n+\n+    /**\n+     * Stop the polling task.\n+     */\n+    public synchronized void stopPolling() {\n+        final ScheduledFuture<?> task = pollingTask;\n+        if (task != null && !task.isCancelled()) {\n+            task.cancel(true);\n+            pollingTask = null;\n+        }\n+    }\n+\n+    /**\n+     * Method for polling the RS485 Helios RemoteContol bus\n+     */\n+    public synchronized void polling() {\n+        if (logger.isTraceEnabled()) {\n+            logger.trace(\"HeliosVentilation Polling data for '{}'\", getThing().getUID());\n+        }\n+        pollCounter++;\n+        if (pollCounter > POLL_OFFLINE_THRESHOLD) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.GONE, \"No data received!\");\n+            logger.info(\"No data received for '{}' disconnecting now...\", getThing().getUID());\n+            disconnect();\n+        }\n+\n+        if (!isConnected()) {\n+            connect(); // let's try to reconnect if the connection failed or was never established before\n+        }\n+\n+        HeliosVentilationBindingConstants.DATAPOINTS.values().forEach((v) -> {\n+            if (isLinked(v.getName())) {\n+                poll(v);\n+            }\n+        });\n+    }\n+\n+    private void disconnect() {\n+        if (thing.getStatus() != ThingStatus.REMOVING) {\n+            updateStatus(ThingStatus.OFFLINE);\n+        }\n+        synchronized (this) {\n+            try {\n+                if (inputStream != null) {\n+                    inputStream.close();\n+                }\n+            } catch (IOException e) {\n+                // ignore the exception on close\n+                inputStream = null;\n+            }\n+            try {\n+                if (outputStream != null) {\n+                    outputStream.close();\n+                }\n+            } catch (IOException e) {\n+                // ignore the exception on close\n+                outputStream = null;\n+            }\n+\n+            SerialPort serial = serialPort;\n+            if (serial != null) {\n+                serial.close();\n+            }\n+            serialPort = null;\n+        }\n+\n+    }\n+\n+    private void poll(HeliosVentilationDataPoint v) {\n+        byte[] txFrame = { 0x01, BUSMEMBER_ME, BUSMEMBER_MAINBOARD, 0x00, v.address(), 0x00 };\n+        txFrame[5] = (byte) checksum(txFrame);\n+\n+        tx(txFrame);\n+    }\n+\n+    /*\n+     * transmit a frame\n+     */\n+    private void tx(byte[] txFrame) {\n+        try {\n+            OutputStream out = outputStream;\n+            if (out != null) {\n+                if (logger.isTraceEnabled()) {\n+                    logger.trace(\"HeliosVentilation: Write to serial port: {}\",\n+                            String.format(\"%02x %02x %02x %02x\", txFrame[1], txFrame[2], txFrame[3], txFrame[4]));\n+                }\n+\n+                out.write(txFrame);\n+                out.flush();\n+                // after each frame we have to wait.\n+                // 30 ms is taken from what we roughly see the original remote control is doing\n+                Thread.sleep(30);\n+            }\n+        } catch (IOException e) {\n+            // in case we cannot write the connection is somehow broken, let's officially disconnect\n+            disconnect();\n+            connect();\n+        } catch (InterruptedException e) {\n+            // ignore if we got interrupted\n+        }\n+    }\n+\n+    /**\n+     * Check connection status\n+     *\n+     * @return true if currently connected\n+     */\n+    private boolean isConnected() {\n+        return serialPort != null && inputStream != null && outputStream != null;\n+    }\n+\n+    @Override\n+    public synchronized void serialEvent(SerialPortEvent event) {\n+        switch (event.getEventType()) {\n+            case SerialPortEvent.DATA_AVAILABLE:\n+                // we get here if data has been received\n+\n+                try {\n+                    // Wait roughly a frame length to ensure that the complete frame is already buffered. This improves\n+                    // the robustness for RS485/USB converters which sometimes duplicate bytes otherwise.\n+                    Thread.sleep(8);\n+                } catch (InterruptedException e) {\n+                    // ignore interruption\n+                }\n+\n+                byte[] frame = { 0, 0, 0, 0, 0, 0 };\n+                InputStream in = inputStream;\n+                if (in != null) {\n+                    try {\n+                        do {\n+                            int cnt = 0;\n+                            // read data from serial device\n+                            while (cnt < 6 && in.available() > 0) {\n+                                final int bytes = in.read(frame, cnt, 1);\n+                                if (cnt > 0 || frame[0] == 0x01) {\n+                                    // only proceed if the first byte was 0x01\n+                                    cnt += bytes;\n+                                }\n+                            }\n+                            int sum = checksum(frame);\n+                            if (sum == (frame[5] & 0xff)) {\n+                                if (logger.isTraceEnabled()) {\n+                                    logger.trace(\"HeliosVentilation: Read from serial port: {}\", String\n+                                            .format(\"%02x %02x %02x %02x\", frame[1], frame[2], frame[3], frame[4]));\n+                                }\n+                                interpretFrame(frame);\n+\n+                            } else {\n+                                if (logger.isTraceEnabled()) {\n+                                    logger.trace(\n+                                            \"HeliosVentilation: Read frame with not matching checksum from serial port: {}\",\n+                                            String.format(\"%02x %02x %02x %02x %02x %02x (expected %02x)\", frame[0],\n+                                                    frame[1], frame[2], frame[3], frame[4], frame[5], sum));\n+                                }\n+\n+                            }\n+\n+                        } while (in.available() > 0);\n+\n+                    } catch (IOException e1) {\n+                        logger.debug(\"Error reading from serial port: {}\", e1.getMessage(), e1);\n+                    }\n+                }\n+                break;\n+            default:\n+                break;\n+        }\n+    }\n+\n+    @Override\n+    public void handleCommand(ChannelUID channelUID, Command command) {\n+        if (command instanceof RefreshType) {\n+            scheduler.execute(this::polling);\n+        } else if (command instanceof DecimalType || command instanceof QuantityType || command instanceof OnOffType) {\n+            scheduler.execute(() -> update(channelUID, command));\n+        }\n+    }\n+\n+    /**\n+     * Update the variable corresponding to given channel/command\n+     *\n+     * @param channelUID UID of the channel to update\n+     * @param command data element to write\n+     *\n+     */\n+    public void update(ChannelUID channelUID, Command command) {\n+        HeliosVentilationBindingConstants.DATAPOINTS.values().forEach((outer) -> {\n+            HeliosVentilationDataPoint v = outer;\n+            do {\n+                if (channelUID.getThingUID().equals(thing.getUID()) && v.getName().equals(channelUID.getId())) {\n+                    if (v.isWritable()) {\n+                        byte[] txFrame = { 0x01, BUSMEMBER_ME, BUSMEMBER_CONTROLBOARDS, v.address(), 0x00, 0x00 };\n+                        txFrame[4] = v.getTransmitDataFor((State) command);\n+                        if (v.requiresReadModifyWrite()) {\n+                            txFrame[4] |= memory.get(v.address()) & ~v.bitMask();\n+                            memory.put(v.address(), txFrame[4]);\n+                        }\n+                        txFrame[5] = (byte) checksum(txFrame);\n+                        tx(txFrame);\n+\n+                        txFrame[2] = BUSMEMBER_SLAVEBOARDS;\n+                        txFrame[5] = (byte) checksum(txFrame);\n+                        tx(txFrame);\n+\n+                        txFrame[2] = BUSMEMBER_MAINBOARD;\n+                        txFrame[5] = (byte) checksum(txFrame);\n+                        tx(txFrame);\n+                    }\n+                }\n+                v = v.link();\n+            } while (v != null);\n+        });\n+\n+    }\n+\n+    /**\n+     * calculate checksum of a frame\n+     *\n+     * @param frame filled with 5 bytes\n+     * @return checksum of the first 5 bytes of frame\n+     */\n+    private int checksum(byte[] frame) {\n+        int sum = 0;\n+        for (int a = 0; a < 5; a++) {\n+            sum += frame[a] & 0xff;\n+        }\n+        sum %= 256;\n+        return sum;\n+    }\n+\n+    /**\n+     * interpret a frame, which is already validated to be in correct format with valid checksum\n+     *\n+     * @param frame 6 bytes long data with 0x01, sender, receiver, address, value, checksum\n+     */\n+    private void interpretFrame(byte[] frame) {\n+        if ((frame[2] & BUSMEMBER_REC_MASK) == (BUSMEMBER_ME & BUSMEMBER_REC_MASK)) {\n+            // something to read for us\n+            byte var = frame[3];\n+            byte val = frame[4];\n+            if (HeliosVentilationBindingConstants.DATAPOINTS.containsKey(var)) {\n+                HeliosVentilationDataPoint datapoint = HeliosVentilationBindingConstants.DATAPOINTS.get(var);\n+                if (datapoint.requiresReadModifyWrite()) {\n+                    memory.put(var, val);\n+                }\n+                do {\n+                    if (logger.isTraceEnabled()) {\n+                        String t = datapoint.asString(val);\n+                        logger.trace(\"Received {} = {}\", datapoint, t);\n+                    }\n+                    if (thing.getStatus() != ThingStatus.REMOVING) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4MTUyMA=="}, "originalCommit": {"oid": "7b1658af39ccc8a2f98f4cc318896c32ee4ff9a4"}, "originalPosition": 441}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczOTAyMzg4OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQyMzo0NToyNlrOGjUCuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQyMzo0NToyNlrOGjUCuw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4MTcyMw==", "bodyText": "I suspect this might be used by multiple threads at once, so lets make it thread-safe and final.\nThen move the final fields above all the non-final fields.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private Map<Byte, Byte> memory = new HashMap<Byte, Byte>();\n          \n          \n            \n                private final Map<Byte, Byte> memory = new ConcurrentHashMap<Byte, Byte>();", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r439681723", "createdAt": "2020-06-12T23:45:26Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationHandler.java", "diffHunk": "@@ -0,0 +1,459 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.lang.invoke.MethodHandles;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HeliosVentilationHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosVentilationHandler extends BaseThingHandler implements SerialPortEventListener {\n+    private static final int BUSMEMBER_MAINBOARD = 0x11;\n+    private static final int BUSMEMBER_SLAVEBOARDS = 0x10;\n+    private static final byte BUSMEMBER_CONTROLBOARDS = (byte) 0x20;\n+    private static final int BUSMEMBER_REC_MASK = 0xF0; // interpreting frames delivered to BUSMEMBER_ME &\n+                                                        // BUSMEMBER_REC_MASK\n+    private static final int BUSMEMBER_ME = 0x2F; // used as sender when communicating with the helios system\n+    private static final int POLL_OFFLINE_THRESHOLD = 3;\n+\n+    /** Logger Instance */\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    /* init to default to avoid NPE in case handleCommand() is called before initialize() */\n+    private HeliosVentilationConfiguration config = new HeliosVentilationConfiguration();\n+\n+    private SerialPortManager serialPortManager;\n+\n+    private @Nullable SerialPort serialPort;\n+    private @Nullable InputStream inputStream;\n+    private @Nullable OutputStream outputStream;\n+\n+    private @Nullable ScheduledFuture<?> pollingTask;\n+    private int pollCounter;\n+\n+    /**\n+     * store received data for read-modify-write operations on bitlevel\n+     */\n+    private Map<Byte, Byte> memory = new HashMap<Byte, Byte>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b1658af39ccc8a2f98f4cc318896c32ee4ff9a4"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczOTAyNTcwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQyMzo0NzoxMFrOGjUDzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQyMzo0NzoxMFrOGjUDzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4MTk5OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private SerialPortManager serialPortManager;\n          \n          \n            \n                private final SerialPortManager serialPortManager;", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r439681998", "createdAt": "2020-06-12T23:47:10Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationHandler.java", "diffHunk": "@@ -0,0 +1,459 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.lang.invoke.MethodHandles;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HeliosVentilationHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosVentilationHandler extends BaseThingHandler implements SerialPortEventListener {\n+    private static final int BUSMEMBER_MAINBOARD = 0x11;\n+    private static final int BUSMEMBER_SLAVEBOARDS = 0x10;\n+    private static final byte BUSMEMBER_CONTROLBOARDS = (byte) 0x20;\n+    private static final int BUSMEMBER_REC_MASK = 0xF0; // interpreting frames delivered to BUSMEMBER_ME &\n+                                                        // BUSMEMBER_REC_MASK\n+    private static final int BUSMEMBER_ME = 0x2F; // used as sender when communicating with the helios system\n+    private static final int POLL_OFFLINE_THRESHOLD = 3;\n+\n+    /** Logger Instance */\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+    /* init to default to avoid NPE in case handleCommand() is called before initialize() */\n+    private HeliosVentilationConfiguration config = new HeliosVentilationConfiguration();\n+\n+    private SerialPortManager serialPortManager;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b1658af39ccc8a2f98f4cc318896c32ee4ff9a4"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczOTAzMTAwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationDataPoint.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQyMzo1MjowMFrOGjUG5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQyMzo1MjowMFrOGjUG5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4Mjc5MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final int FANSPEED_MAP[] = { 0, 1, 3, 7, 15, 31, 63, 127, 255 };\n          \n          \n            \n                private static final int[] FANSPEED_MAP = { 0, 1, 3, 7, 15, 31, 63, 127, 255 };", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r439682791", "createdAt": "2020-06-12T23:52:00Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationDataPoint.java", "diffHunk": "@@ -0,0 +1,324 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+\n+/**\n+ * The {@link HeliosVentilationDataPoint} is a description of a datapoint in the Helios ventilation system.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosVentilationDataPoint {\n+    public enum DataType {\n+        TEMPERATURE,\n+        HYSTERESIS,\n+        FANSPEED,\n+        SWITCH,\n+        BYTE_PERCENT,\n+        PERCENT,\n+        NUMBER\n+    }\n+\n+    /**\n+     * mapping from temperature byte values to \u00b0C\n+     */\n+    private static final int TEMP_MAP[] = { -74, -70, -66, -62, -59, -56, -54, -52, -50, -48, -47, -46, -44, -43, -42,\n+            -41, -40, -39, -38, -37, -36, -35, -34, -33, -33, -32, -31, -30, -30, -29, -28, -28, -27, -27, -26, -25,\n+            -25, -24, -24, -23, -23, -22, -22, -21, -21, -20, -20, -19, -19, -19, -18, -18, -17, -17, -16, -16, -16,\n+            -15, -15, -14, -14, -14, -13, -13, -12, -12, -12, -11, -11, -11, -10, -10, -9, -9, -9, -8, -8, -8, -7, -7,\n+            -7, -6, -6, -6, -5, -5, -5, -4, -4, -4, -3, -3, -3, -2, -2, -2, -1, -1, -1, -1, 0, 0, 0, 1, 1, 1, 2, 2, 2,\n+            3, 3, 3, 4, 4, 4, 5, 5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 13,\n+            13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 18, 18, 18, 19, 19, 19, 20, 20, 21, 21, 21, 22, 22, 22,\n+            23, 23, 24, 24, 24, 25, 25, 26, 26, 27, 27, 27, 28, 28, 29, 29, 30, 30, 31, 31, 32, 32, 33, 33, 34, 34, 35,\n+            35, 36, 36, 37, 37, 38, 38, 39, 40, 40, 41, 41, 42, 43, 43, 44, 45, 45, 46, 47, 48, 48, 49, 50, 51, 52, 53,\n+            53, 54, 55, 56, 57, 59, 60, 61, 62, 63, 65, 66, 68, 69, 71, 73, 75, 77, 79, 81, 82, 86, 90, 93, 97, 100,\n+            100, 100, 100, 100, 100, 100, 100, 100 };\n+\n+    /**\n+     * mapping from human readable fanspeed to raw value\n+     */\n+    private static final int FANSPEED_MAP[] = { 0, 1, 3, 7, 15, 31, 63, 127, 255 };", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b1658af39ccc8a2f98f4cc318896c32ee4ff9a4"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczOTAzMTE0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationDataPoint.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQyMzo1MjowN1rOGjUG_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQyMzo1MjowN1rOGjUG_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4MjgxMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static final int TEMP_MAP[] = { -74, -70, -66, -62, -59, -56, -54, -52, -50, -48, -47, -46, -44, -43, -42,\n          \n          \n            \n                private static final int[] TEMP_MAP = { -74, -70, -66, -62, -59, -56, -54, -52, -50, -48, -47, -46, -44, -43, -42,", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r439682812", "createdAt": "2020-06-12T23:52:07Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationDataPoint.java", "diffHunk": "@@ -0,0 +1,324 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+\n+/**\n+ * The {@link HeliosVentilationDataPoint} is a description of a datapoint in the Helios ventilation system.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosVentilationDataPoint {\n+    public enum DataType {\n+        TEMPERATURE,\n+        HYSTERESIS,\n+        FANSPEED,\n+        SWITCH,\n+        BYTE_PERCENT,\n+        PERCENT,\n+        NUMBER\n+    }\n+\n+    /**\n+     * mapping from temperature byte values to \u00b0C\n+     */\n+    private static final int TEMP_MAP[] = { -74, -70, -66, -62, -59, -56, -54, -52, -50, -48, -47, -46, -44, -43, -42,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b1658af39ccc8a2f98f4cc318896c32ee4ff9a4"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczOTAzNDc2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationDataPoint.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQyMzo1NTozNVrOGjUJJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQyMzo1NTozNVrOGjUJJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4MzM2NQ==", "bodyText": "QuantityType extend Number so you don't need to convert them to a DecimalType.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            value = quantvalue.as(DecimalType.class);\n          \n          \n            \n                            if (value != null) {\n          \n          \n            \n                                result = (byte) (value.intValue() * 3);\n          \n          \n            \n                            }\n          \n          \n            \n                            result = (byte) (quantvalue.intValue() * 3);", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r439683365", "createdAt": "2020-06-12T23:55:35Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationDataPoint.java", "diffHunk": "@@ -0,0 +1,324 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+\n+/**\n+ * The {@link HeliosVentilationDataPoint} is a description of a datapoint in the Helios ventilation system.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosVentilationDataPoint {\n+    public enum DataType {\n+        TEMPERATURE,\n+        HYSTERESIS,\n+        FANSPEED,\n+        SWITCH,\n+        BYTE_PERCENT,\n+        PERCENT,\n+        NUMBER\n+    }\n+\n+    /**\n+     * mapping from temperature byte values to \u00b0C\n+     */\n+    private static final int TEMP_MAP[] = { -74, -70, -66, -62, -59, -56, -54, -52, -50, -48, -47, -46, -44, -43, -42,\n+            -41, -40, -39, -38, -37, -36, -35, -34, -33, -33, -32, -31, -30, -30, -29, -28, -28, -27, -27, -26, -25,\n+            -25, -24, -24, -23, -23, -22, -22, -21, -21, -20, -20, -19, -19, -19, -18, -18, -17, -17, -16, -16, -16,\n+            -15, -15, -14, -14, -14, -13, -13, -12, -12, -12, -11, -11, -11, -10, -10, -9, -9, -9, -8, -8, -8, -7, -7,\n+            -7, -6, -6, -6, -5, -5, -5, -4, -4, -4, -3, -3, -3, -2, -2, -2, -1, -1, -1, -1, 0, 0, 0, 1, 1, 1, 2, 2, 2,\n+            3, 3, 3, 4, 4, 4, 5, 5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 13,\n+            13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 18, 18, 18, 19, 19, 19, 20, 20, 21, 21, 21, 22, 22, 22,\n+            23, 23, 24, 24, 24, 25, 25, 26, 26, 27, 27, 27, 28, 28, 29, 29, 30, 30, 31, 31, 32, 32, 33, 33, 34, 34, 35,\n+            35, 36, 36, 37, 37, 38, 38, 39, 40, 40, 41, 41, 42, 43, 43, 44, 45, 45, 46, 47, 48, 48, 49, 50, 51, 52, 53,\n+            53, 54, 55, 56, 57, 59, 60, 61, 62, 63, 65, 66, 68, 69, 71, 73, 75, 77, 79, 81, 82, 86, 90, 93, 97, 100,\n+            100, 100, 100, 100, 100, 100, 100, 100 };\n+\n+    /**\n+     * mapping from human readable fanspeed to raw value\n+     */\n+    private static final int FANSPEED_MAP[] = { 0, 1, 3, 7, 15, 31, 63, 127, 255 };\n+\n+    private static final int BYTE_PERCENT_OFFSET = 52;\n+\n+    private String name;\n+    private boolean writable;\n+    private DataType datatype;\n+    private byte address;\n+    private int bitStart;\n+    private int bitLength;\n+\n+    private @Nullable HeliosVentilationDataPoint link;\n+\n+    /**\n+     * parse fullSpec in the properties format to declare a datapoint\n+     *\n+     * @param name the name of the datapoint\n+     * @param fullSpec datapoint specification, see format in datapoints.properties\n+     * @throws HeliosPropertiesFormatException in case fullSpec is not parsable\n+     */\n+    public HeliosVentilationDataPoint(String name, String fullSpec) throws HeliosPropertiesFormatException {\n+        String specWithoutComment;\n+        if (fullSpec.contains(\"#\")) {\n+            specWithoutComment = fullSpec.substring(0, fullSpec.indexOf(\"#\"));\n+        } else {\n+            specWithoutComment = fullSpec;\n+        }\n+        String[] tokens = specWithoutComment.split(\",\");\n+        this.name = name;\n+        if (tokens.length != 3) {\n+            throw new HeliosPropertiesFormatException(\"invalid length\", name, fullSpec);\n+        }\n+        try {\n+            String addr = tokens[0];\n+            String[] addrTokens;\n+            if (addr.contains(\":\")) {\n+                addrTokens = addr.split(\":\");\n+            } else {\n+                addrTokens = new String[] { addr };\n+            }\n+            bitLength = 8;\n+            bitStart = 0;\n+            this.address = (byte) (int) Integer.decode(addrTokens[0]);\n+            if (addrTokens.length > 1) {\n+                bitStart = (byte) (int) Integer.decode(addrTokens[1]);\n+                bitLength = 1;\n+            }\n+            if (addrTokens.length > 2) {\n+                bitLength = (byte) (int) Integer.decode(addrTokens[2]) - bitStart + 1;\n+            }\n+            if (addrTokens.length > 3) {\n+                throw new HeliosPropertiesFormatException(\n+                        \"invalid address spec: too many separators in bit specification\", name, fullSpec);\n+            }\n+        } catch (NumberFormatException e) {\n+            throw new HeliosPropertiesFormatException(\"invalid address spec\", name, fullSpec);\n+        }\n+\n+        this.writable = Boolean.parseBoolean(tokens[1]);\n+        try {\n+            this.datatype = DataType.valueOf(tokens[2].replaceAll(\"\\\\s+\", \"\"));\n+        } catch (IllegalArgumentException e) {\n+            throw new HeliosPropertiesFormatException(\"invalid type spec\", name, fullSpec);\n+        }\n+    }\n+\n+    public HeliosVentilationDataPoint(String name, byte address, boolean writable, DataType datatype) {\n+        this.datatype = datatype;\n+        this.writable = writable;\n+        this.name = name;\n+        this.address = address;\n+    }\n+\n+    public boolean isWritable() {\n+        return writable;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return name;\n+    }\n+\n+    /**\n+     *\n+     * @return the name of the variable, which is also the channel name\n+     */\n+    public String getName() {\n+        return name;\n+    }\n+\n+    /**\n+     *\n+     * @return address of the variable\n+     */\n+    public byte address() {\n+        return address;\n+    }\n+\n+    /**\n+     * @return the bit mask of the data point. 0xFF in case the full byte is used.\n+     */\n+    public byte bitMask() {\n+        byte mask = (byte) 0xff;\n+        if (datatype == DataType.NUMBER || datatype == DataType.SWITCH) {\n+            mask = (byte) (((1 << bitLength) - 1) << bitStart);\n+        }\n+        return mask;\n+    }\n+\n+    /**\n+     * interpret the given byte b and return the value as State.\n+     *\n+     * @param b\n+     * @return state representation of byte value b in current datatype\n+     */\n+    public State asState(byte b) {\n+        int val = b & 0xff;\n+        if (datatype == DataType.TEMPERATURE) {\n+            return new QuantityType<>(TEMP_MAP[val], SIUnits.CELSIUS);\n+        } else if (datatype == DataType.BYTE_PERCENT) {\n+            return new QuantityType<>((int) ((val - BYTE_PERCENT_OFFSET) * 100.0 / (255 - BYTE_PERCENT_OFFSET)),\n+                    SmartHomeUnits.PERCENT);\n+        } else if (datatype == DataType.SWITCH && bitLength == 1) {\n+            if ((b & (1 << bitStart)) != 0) {\n+                return OnOffType.ON;\n+            } else {\n+                return OnOffType.OFF;\n+            }\n+        } else if (datatype == DataType.NUMBER) {\n+            int value = (b & bitMask()) >> bitStart;\n+            return new DecimalType(value);\n+        } else if (datatype == DataType.PERCENT) {\n+            return new QuantityType<>(val, SmartHomeUnits.PERCENT);\n+        } else if (datatype == DataType.FANSPEED) {\n+            int i = 1;\n+            while (i < FANSPEED_MAP.length && FANSPEED_MAP[i] < val) {\n+                i++;\n+            }\n+            return new DecimalType(i);\n+        } else if (datatype == DataType.HYSTERESIS) {\n+            return new QuantityType<>(val / 3, SIUnits.CELSIUS);\n+        }\n+\n+        return UnDefType.UNDEF;\n+    }\n+\n+    /**\n+     * interpret the given byte b and return the value as string.\n+     *\n+     * @param b\n+     * @return sting representation of byte value b in current datatype\n+     */\n+    public String asString(byte b) {\n+        State ste = asState(b);\n+        String str = ste.toString();\n+        if (ste instanceof UnDefType) {\n+            return String.format(\"<unknown type> %02X \", b);\n+        } else {\n+            return str;\n+        }\n+    }\n+\n+    /**\n+     * generate byte data to transmit\n+     *\n+     * @param val is the state of a channel\n+     * @return byte value with RS485 representation. Bit level values are returned in the correct location, but other\n+     *         bits/datapoints in the same address are zero.\n+     */\n+    public byte getTransmitDataFor(State val) {\n+        byte result = 0;\n+        DecimalType value = val.as(DecimalType.class);\n+        if (value == null) {\n+            /*\n+             * if value is not convertible to a numeric type we cannot do anything reasonable with it, let's use the\n+             * initial value for it\n+             */\n+        } else if (datatype == DataType.TEMPERATURE) {\n+            QuantityType<?> quantvalue = ((QuantityType<?>) val);\n+            quantvalue = quantvalue.toUnit(SIUnits.CELSIUS);\n+            if (quantvalue != null) {\n+                value = quantvalue.as(DecimalType.class);\n+                if (value != null) {\n+                    int temp = (int) Math.round(value.doubleValue());\n+                    int i = 0;\n+                    while (i < TEMP_MAP.length && TEMP_MAP[i] < temp) {\n+                        i++;\n+                    }\n+                    result = (byte) i;\n+                }\n+            }\n+        } else if (datatype == DataType.FANSPEED) {\n+            int i = value.intValue();\n+            if (i < 0) {\n+                i = 0;\n+            } else if (i > 8) {\n+                i = 8;\n+            }\n+            result = (byte) FANSPEED_MAP[i];\n+        } else if (datatype == DataType.BYTE_PERCENT) {\n+            result = (byte) ((value.doubleValue() / 100.0) * (255 - BYTE_PERCENT_OFFSET) + BYTE_PERCENT_OFFSET);\n+        } else if (datatype == DataType.PERCENT) {\n+            double d = (Math.round(value.doubleValue()));\n+            if (d < 0.0) {\n+                d = 0.0;\n+            } else if (d > 100.0) {\n+                d = 100.0;\n+            }\n+            result = (byte) d;\n+        } else if (datatype == DataType.HYSTERESIS) {\n+            QuantityType<?> quantvalue = ((QuantityType<?>) val);\n+            quantvalue = quantvalue.toUnit(SIUnits.CELSIUS);\n+            if (quantvalue != null) {\n+                value = quantvalue.as(DecimalType.class);\n+                if (value != null) {\n+                    result = (byte) (value.intValue() * 3);\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b1658af39ccc8a2f98f4cc318896c32ee4ff9a4"}, "originalPosition": 276}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczOTAzNzc3OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationDataPoint.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQyMzo1ODoxOFrOGjUK7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNFQxNTowNDozMlrOGjdoHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4MzgyMg==", "bodyText": "This would be a good place to use a switch statement.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    } else if (datatype == DataType.TEMPERATURE) {\n          \n          \n            \n                    } else switch(datatype) {\n          \n          \n            \n                        case TEMPERATURE:", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r439683822", "createdAt": "2020-06-12T23:58:18Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationDataPoint.java", "diffHunk": "@@ -0,0 +1,324 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+\n+/**\n+ * The {@link HeliosVentilationDataPoint} is a description of a datapoint in the Helios ventilation system.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosVentilationDataPoint {\n+    public enum DataType {\n+        TEMPERATURE,\n+        HYSTERESIS,\n+        FANSPEED,\n+        SWITCH,\n+        BYTE_PERCENT,\n+        PERCENT,\n+        NUMBER\n+    }\n+\n+    /**\n+     * mapping from temperature byte values to \u00b0C\n+     */\n+    private static final int TEMP_MAP[] = { -74, -70, -66, -62, -59, -56, -54, -52, -50, -48, -47, -46, -44, -43, -42,\n+            -41, -40, -39, -38, -37, -36, -35, -34, -33, -33, -32, -31, -30, -30, -29, -28, -28, -27, -27, -26, -25,\n+            -25, -24, -24, -23, -23, -22, -22, -21, -21, -20, -20, -19, -19, -19, -18, -18, -17, -17, -16, -16, -16,\n+            -15, -15, -14, -14, -14, -13, -13, -12, -12, -12, -11, -11, -11, -10, -10, -9, -9, -9, -8, -8, -8, -7, -7,\n+            -7, -6, -6, -6, -5, -5, -5, -4, -4, -4, -3, -3, -3, -2, -2, -2, -1, -1, -1, -1, 0, 0, 0, 1, 1, 1, 2, 2, 2,\n+            3, 3, 3, 4, 4, 4, 5, 5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 13,\n+            13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 18, 18, 18, 19, 19, 19, 20, 20, 21, 21, 21, 22, 22, 22,\n+            23, 23, 24, 24, 24, 25, 25, 26, 26, 27, 27, 27, 28, 28, 29, 29, 30, 30, 31, 31, 32, 32, 33, 33, 34, 34, 35,\n+            35, 36, 36, 37, 37, 38, 38, 39, 40, 40, 41, 41, 42, 43, 43, 44, 45, 45, 46, 47, 48, 48, 49, 50, 51, 52, 53,\n+            53, 54, 55, 56, 57, 59, 60, 61, 62, 63, 65, 66, 68, 69, 71, 73, 75, 77, 79, 81, 82, 86, 90, 93, 97, 100,\n+            100, 100, 100, 100, 100, 100, 100, 100 };\n+\n+    /**\n+     * mapping from human readable fanspeed to raw value\n+     */\n+    private static final int FANSPEED_MAP[] = { 0, 1, 3, 7, 15, 31, 63, 127, 255 };\n+\n+    private static final int BYTE_PERCENT_OFFSET = 52;\n+\n+    private String name;\n+    private boolean writable;\n+    private DataType datatype;\n+    private byte address;\n+    private int bitStart;\n+    private int bitLength;\n+\n+    private @Nullable HeliosVentilationDataPoint link;\n+\n+    /**\n+     * parse fullSpec in the properties format to declare a datapoint\n+     *\n+     * @param name the name of the datapoint\n+     * @param fullSpec datapoint specification, see format in datapoints.properties\n+     * @throws HeliosPropertiesFormatException in case fullSpec is not parsable\n+     */\n+    public HeliosVentilationDataPoint(String name, String fullSpec) throws HeliosPropertiesFormatException {\n+        String specWithoutComment;\n+        if (fullSpec.contains(\"#\")) {\n+            specWithoutComment = fullSpec.substring(0, fullSpec.indexOf(\"#\"));\n+        } else {\n+            specWithoutComment = fullSpec;\n+        }\n+        String[] tokens = specWithoutComment.split(\",\");\n+        this.name = name;\n+        if (tokens.length != 3) {\n+            throw new HeliosPropertiesFormatException(\"invalid length\", name, fullSpec);\n+        }\n+        try {\n+            String addr = tokens[0];\n+            String[] addrTokens;\n+            if (addr.contains(\":\")) {\n+                addrTokens = addr.split(\":\");\n+            } else {\n+                addrTokens = new String[] { addr };\n+            }\n+            bitLength = 8;\n+            bitStart = 0;\n+            this.address = (byte) (int) Integer.decode(addrTokens[0]);\n+            if (addrTokens.length > 1) {\n+                bitStart = (byte) (int) Integer.decode(addrTokens[1]);\n+                bitLength = 1;\n+            }\n+            if (addrTokens.length > 2) {\n+                bitLength = (byte) (int) Integer.decode(addrTokens[2]) - bitStart + 1;\n+            }\n+            if (addrTokens.length > 3) {\n+                throw new HeliosPropertiesFormatException(\n+                        \"invalid address spec: too many separators in bit specification\", name, fullSpec);\n+            }\n+        } catch (NumberFormatException e) {\n+            throw new HeliosPropertiesFormatException(\"invalid address spec\", name, fullSpec);\n+        }\n+\n+        this.writable = Boolean.parseBoolean(tokens[1]);\n+        try {\n+            this.datatype = DataType.valueOf(tokens[2].replaceAll(\"\\\\s+\", \"\"));\n+        } catch (IllegalArgumentException e) {\n+            throw new HeliosPropertiesFormatException(\"invalid type spec\", name, fullSpec);\n+        }\n+    }\n+\n+    public HeliosVentilationDataPoint(String name, byte address, boolean writable, DataType datatype) {\n+        this.datatype = datatype;\n+        this.writable = writable;\n+        this.name = name;\n+        this.address = address;\n+    }\n+\n+    public boolean isWritable() {\n+        return writable;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return name;\n+    }\n+\n+    /**\n+     *\n+     * @return the name of the variable, which is also the channel name\n+     */\n+    public String getName() {\n+        return name;\n+    }\n+\n+    /**\n+     *\n+     * @return address of the variable\n+     */\n+    public byte address() {\n+        return address;\n+    }\n+\n+    /**\n+     * @return the bit mask of the data point. 0xFF in case the full byte is used.\n+     */\n+    public byte bitMask() {\n+        byte mask = (byte) 0xff;\n+        if (datatype == DataType.NUMBER || datatype == DataType.SWITCH) {\n+            mask = (byte) (((1 << bitLength) - 1) << bitStart);\n+        }\n+        return mask;\n+    }\n+\n+    /**\n+     * interpret the given byte b and return the value as State.\n+     *\n+     * @param b\n+     * @return state representation of byte value b in current datatype\n+     */\n+    public State asState(byte b) {\n+        int val = b & 0xff;\n+        if (datatype == DataType.TEMPERATURE) {\n+            return new QuantityType<>(TEMP_MAP[val], SIUnits.CELSIUS);\n+        } else if (datatype == DataType.BYTE_PERCENT) {\n+            return new QuantityType<>((int) ((val - BYTE_PERCENT_OFFSET) * 100.0 / (255 - BYTE_PERCENT_OFFSET)),\n+                    SmartHomeUnits.PERCENT);\n+        } else if (datatype == DataType.SWITCH && bitLength == 1) {\n+            if ((b & (1 << bitStart)) != 0) {\n+                return OnOffType.ON;\n+            } else {\n+                return OnOffType.OFF;\n+            }\n+        } else if (datatype == DataType.NUMBER) {\n+            int value = (b & bitMask()) >> bitStart;\n+            return new DecimalType(value);\n+        } else if (datatype == DataType.PERCENT) {\n+            return new QuantityType<>(val, SmartHomeUnits.PERCENT);\n+        } else if (datatype == DataType.FANSPEED) {\n+            int i = 1;\n+            while (i < FANSPEED_MAP.length && FANSPEED_MAP[i] < val) {\n+                i++;\n+            }\n+            return new DecimalType(i);\n+        } else if (datatype == DataType.HYSTERESIS) {\n+            return new QuantityType<>(val / 3, SIUnits.CELSIUS);\n+        }\n+\n+        return UnDefType.UNDEF;\n+    }\n+\n+    /**\n+     * interpret the given byte b and return the value as string.\n+     *\n+     * @param b\n+     * @return sting representation of byte value b in current datatype\n+     */\n+    public String asString(byte b) {\n+        State ste = asState(b);\n+        String str = ste.toString();\n+        if (ste instanceof UnDefType) {\n+            return String.format(\"<unknown type> %02X \", b);\n+        } else {\n+            return str;\n+        }\n+    }\n+\n+    /**\n+     * generate byte data to transmit\n+     *\n+     * @param val is the state of a channel\n+     * @return byte value with RS485 representation. Bit level values are returned in the correct location, but other\n+     *         bits/datapoints in the same address are zero.\n+     */\n+    public byte getTransmitDataFor(State val) {\n+        byte result = 0;\n+        DecimalType value = val.as(DecimalType.class);\n+        if (value == null) {\n+            /*\n+             * if value is not convertible to a numeric type we cannot do anything reasonable with it, let's use the\n+             * initial value for it\n+             */\n+        } else if (datatype == DataType.TEMPERATURE) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b1658af39ccc8a2f98f4cc318896c32ee4ff9a4"}, "originalPosition": 237}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTgzODc1MQ==", "bodyText": "I will do that, but can you explain me why that is better in your eyes?", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r439838751", "createdAt": "2020-06-14T15:04:32Z", "author": {"login": "ramack"}, "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationDataPoint.java", "diffHunk": "@@ -0,0 +1,324 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+\n+/**\n+ * The {@link HeliosVentilationDataPoint} is a description of a datapoint in the Helios ventilation system.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosVentilationDataPoint {\n+    public enum DataType {\n+        TEMPERATURE,\n+        HYSTERESIS,\n+        FANSPEED,\n+        SWITCH,\n+        BYTE_PERCENT,\n+        PERCENT,\n+        NUMBER\n+    }\n+\n+    /**\n+     * mapping from temperature byte values to \u00b0C\n+     */\n+    private static final int TEMP_MAP[] = { -74, -70, -66, -62, -59, -56, -54, -52, -50, -48, -47, -46, -44, -43, -42,\n+            -41, -40, -39, -38, -37, -36, -35, -34, -33, -33, -32, -31, -30, -30, -29, -28, -28, -27, -27, -26, -25,\n+            -25, -24, -24, -23, -23, -22, -22, -21, -21, -20, -20, -19, -19, -19, -18, -18, -17, -17, -16, -16, -16,\n+            -15, -15, -14, -14, -14, -13, -13, -12, -12, -12, -11, -11, -11, -10, -10, -9, -9, -9, -8, -8, -8, -7, -7,\n+            -7, -6, -6, -6, -5, -5, -5, -4, -4, -4, -3, -3, -3, -2, -2, -2, -1, -1, -1, -1, 0, 0, 0, 1, 1, 1, 2, 2, 2,\n+            3, 3, 3, 4, 4, 4, 5, 5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 13,\n+            13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 18, 18, 18, 19, 19, 19, 20, 20, 21, 21, 21, 22, 22, 22,\n+            23, 23, 24, 24, 24, 25, 25, 26, 26, 27, 27, 27, 28, 28, 29, 29, 30, 30, 31, 31, 32, 32, 33, 33, 34, 34, 35,\n+            35, 36, 36, 37, 37, 38, 38, 39, 40, 40, 41, 41, 42, 43, 43, 44, 45, 45, 46, 47, 48, 48, 49, 50, 51, 52, 53,\n+            53, 54, 55, 56, 57, 59, 60, 61, 62, 63, 65, 66, 68, 69, 71, 73, 75, 77, 79, 81, 82, 86, 90, 93, 97, 100,\n+            100, 100, 100, 100, 100, 100, 100, 100 };\n+\n+    /**\n+     * mapping from human readable fanspeed to raw value\n+     */\n+    private static final int FANSPEED_MAP[] = { 0, 1, 3, 7, 15, 31, 63, 127, 255 };\n+\n+    private static final int BYTE_PERCENT_OFFSET = 52;\n+\n+    private String name;\n+    private boolean writable;\n+    private DataType datatype;\n+    private byte address;\n+    private int bitStart;\n+    private int bitLength;\n+\n+    private @Nullable HeliosVentilationDataPoint link;\n+\n+    /**\n+     * parse fullSpec in the properties format to declare a datapoint\n+     *\n+     * @param name the name of the datapoint\n+     * @param fullSpec datapoint specification, see format in datapoints.properties\n+     * @throws HeliosPropertiesFormatException in case fullSpec is not parsable\n+     */\n+    public HeliosVentilationDataPoint(String name, String fullSpec) throws HeliosPropertiesFormatException {\n+        String specWithoutComment;\n+        if (fullSpec.contains(\"#\")) {\n+            specWithoutComment = fullSpec.substring(0, fullSpec.indexOf(\"#\"));\n+        } else {\n+            specWithoutComment = fullSpec;\n+        }\n+        String[] tokens = specWithoutComment.split(\",\");\n+        this.name = name;\n+        if (tokens.length != 3) {\n+            throw new HeliosPropertiesFormatException(\"invalid length\", name, fullSpec);\n+        }\n+        try {\n+            String addr = tokens[0];\n+            String[] addrTokens;\n+            if (addr.contains(\":\")) {\n+                addrTokens = addr.split(\":\");\n+            } else {\n+                addrTokens = new String[] { addr };\n+            }\n+            bitLength = 8;\n+            bitStart = 0;\n+            this.address = (byte) (int) Integer.decode(addrTokens[0]);\n+            if (addrTokens.length > 1) {\n+                bitStart = (byte) (int) Integer.decode(addrTokens[1]);\n+                bitLength = 1;\n+            }\n+            if (addrTokens.length > 2) {\n+                bitLength = (byte) (int) Integer.decode(addrTokens[2]) - bitStart + 1;\n+            }\n+            if (addrTokens.length > 3) {\n+                throw new HeliosPropertiesFormatException(\n+                        \"invalid address spec: too many separators in bit specification\", name, fullSpec);\n+            }\n+        } catch (NumberFormatException e) {\n+            throw new HeliosPropertiesFormatException(\"invalid address spec\", name, fullSpec);\n+        }\n+\n+        this.writable = Boolean.parseBoolean(tokens[1]);\n+        try {\n+            this.datatype = DataType.valueOf(tokens[2].replaceAll(\"\\\\s+\", \"\"));\n+        } catch (IllegalArgumentException e) {\n+            throw new HeliosPropertiesFormatException(\"invalid type spec\", name, fullSpec);\n+        }\n+    }\n+\n+    public HeliosVentilationDataPoint(String name, byte address, boolean writable, DataType datatype) {\n+        this.datatype = datatype;\n+        this.writable = writable;\n+        this.name = name;\n+        this.address = address;\n+    }\n+\n+    public boolean isWritable() {\n+        return writable;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return name;\n+    }\n+\n+    /**\n+     *\n+     * @return the name of the variable, which is also the channel name\n+     */\n+    public String getName() {\n+        return name;\n+    }\n+\n+    /**\n+     *\n+     * @return address of the variable\n+     */\n+    public byte address() {\n+        return address;\n+    }\n+\n+    /**\n+     * @return the bit mask of the data point. 0xFF in case the full byte is used.\n+     */\n+    public byte bitMask() {\n+        byte mask = (byte) 0xff;\n+        if (datatype == DataType.NUMBER || datatype == DataType.SWITCH) {\n+            mask = (byte) (((1 << bitLength) - 1) << bitStart);\n+        }\n+        return mask;\n+    }\n+\n+    /**\n+     * interpret the given byte b and return the value as State.\n+     *\n+     * @param b\n+     * @return state representation of byte value b in current datatype\n+     */\n+    public State asState(byte b) {\n+        int val = b & 0xff;\n+        if (datatype == DataType.TEMPERATURE) {\n+            return new QuantityType<>(TEMP_MAP[val], SIUnits.CELSIUS);\n+        } else if (datatype == DataType.BYTE_PERCENT) {\n+            return new QuantityType<>((int) ((val - BYTE_PERCENT_OFFSET) * 100.0 / (255 - BYTE_PERCENT_OFFSET)),\n+                    SmartHomeUnits.PERCENT);\n+        } else if (datatype == DataType.SWITCH && bitLength == 1) {\n+            if ((b & (1 << bitStart)) != 0) {\n+                return OnOffType.ON;\n+            } else {\n+                return OnOffType.OFF;\n+            }\n+        } else if (datatype == DataType.NUMBER) {\n+            int value = (b & bitMask()) >> bitStart;\n+            return new DecimalType(value);\n+        } else if (datatype == DataType.PERCENT) {\n+            return new QuantityType<>(val, SmartHomeUnits.PERCENT);\n+        } else if (datatype == DataType.FANSPEED) {\n+            int i = 1;\n+            while (i < FANSPEED_MAP.length && FANSPEED_MAP[i] < val) {\n+                i++;\n+            }\n+            return new DecimalType(i);\n+        } else if (datatype == DataType.HYSTERESIS) {\n+            return new QuantityType<>(val / 3, SIUnits.CELSIUS);\n+        }\n+\n+        return UnDefType.UNDEF;\n+    }\n+\n+    /**\n+     * interpret the given byte b and return the value as string.\n+     *\n+     * @param b\n+     * @return sting representation of byte value b in current datatype\n+     */\n+    public String asString(byte b) {\n+        State ste = asState(b);\n+        String str = ste.toString();\n+        if (ste instanceof UnDefType) {\n+            return String.format(\"<unknown type> %02X \", b);\n+        } else {\n+            return str;\n+        }\n+    }\n+\n+    /**\n+     * generate byte data to transmit\n+     *\n+     * @param val is the state of a channel\n+     * @return byte value with RS485 representation. Bit level values are returned in the correct location, but other\n+     *         bits/datapoints in the same address are zero.\n+     */\n+    public byte getTransmitDataFor(State val) {\n+        byte result = 0;\n+        DecimalType value = val.as(DecimalType.class);\n+        if (value == null) {\n+            /*\n+             * if value is not convertible to a numeric type we cannot do anything reasonable with it, let's use the\n+             * initial value for it\n+             */\n+        } else if (datatype == DataType.TEMPERATURE) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4MzgyMg=="}, "originalCommit": {"oid": "7b1658af39ccc8a2f98f4cc318896c32ee4ff9a4"}, "originalPosition": 237}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczOTAzOTIwOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationDataPoint.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQyMzo1OTo1N1rOGjUL1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQyMzo1OTo1N1rOGjUL1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4NDA1Mw==", "bodyText": "I'd prefer if you renamed the field and this method to next.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public @Nullable HeliosVentilationDataPoint link() {\n          \n          \n            \n                    return link;\n          \n          \n            \n                }\n          \n          \n            \n                public @Nullable HeliosVentilationDataPoint next() {\n          \n          \n            \n                    return next;\n          \n          \n            \n                }", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r439684053", "createdAt": "2020-06-12T23:59:57Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationDataPoint.java", "diffHunk": "@@ -0,0 +1,324 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+\n+/**\n+ * The {@link HeliosVentilationDataPoint} is a description of a datapoint in the Helios ventilation system.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosVentilationDataPoint {\n+    public enum DataType {\n+        TEMPERATURE,\n+        HYSTERESIS,\n+        FANSPEED,\n+        SWITCH,\n+        BYTE_PERCENT,\n+        PERCENT,\n+        NUMBER\n+    }\n+\n+    /**\n+     * mapping from temperature byte values to \u00b0C\n+     */\n+    private static final int TEMP_MAP[] = { -74, -70, -66, -62, -59, -56, -54, -52, -50, -48, -47, -46, -44, -43, -42,\n+            -41, -40, -39, -38, -37, -36, -35, -34, -33, -33, -32, -31, -30, -30, -29, -28, -28, -27, -27, -26, -25,\n+            -25, -24, -24, -23, -23, -22, -22, -21, -21, -20, -20, -19, -19, -19, -18, -18, -17, -17, -16, -16, -16,\n+            -15, -15, -14, -14, -14, -13, -13, -12, -12, -12, -11, -11, -11, -10, -10, -9, -9, -9, -8, -8, -8, -7, -7,\n+            -7, -6, -6, -6, -5, -5, -5, -4, -4, -4, -3, -3, -3, -2, -2, -2, -1, -1, -1, -1, 0, 0, 0, 1, 1, 1, 2, 2, 2,\n+            3, 3, 3, 4, 4, 4, 5, 5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 13,\n+            13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 18, 18, 18, 19, 19, 19, 20, 20, 21, 21, 21, 22, 22, 22,\n+            23, 23, 24, 24, 24, 25, 25, 26, 26, 27, 27, 27, 28, 28, 29, 29, 30, 30, 31, 31, 32, 32, 33, 33, 34, 34, 35,\n+            35, 36, 36, 37, 37, 38, 38, 39, 40, 40, 41, 41, 42, 43, 43, 44, 45, 45, 46, 47, 48, 48, 49, 50, 51, 52, 53,\n+            53, 54, 55, 56, 57, 59, 60, 61, 62, 63, 65, 66, 68, 69, 71, 73, 75, 77, 79, 81, 82, 86, 90, 93, 97, 100,\n+            100, 100, 100, 100, 100, 100, 100, 100 };\n+\n+    /**\n+     * mapping from human readable fanspeed to raw value\n+     */\n+    private static final int FANSPEED_MAP[] = { 0, 1, 3, 7, 15, 31, 63, 127, 255 };\n+\n+    private static final int BYTE_PERCENT_OFFSET = 52;\n+\n+    private String name;\n+    private boolean writable;\n+    private DataType datatype;\n+    private byte address;\n+    private int bitStart;\n+    private int bitLength;\n+\n+    private @Nullable HeliosVentilationDataPoint link;\n+\n+    /**\n+     * parse fullSpec in the properties format to declare a datapoint\n+     *\n+     * @param name the name of the datapoint\n+     * @param fullSpec datapoint specification, see format in datapoints.properties\n+     * @throws HeliosPropertiesFormatException in case fullSpec is not parsable\n+     */\n+    public HeliosVentilationDataPoint(String name, String fullSpec) throws HeliosPropertiesFormatException {\n+        String specWithoutComment;\n+        if (fullSpec.contains(\"#\")) {\n+            specWithoutComment = fullSpec.substring(0, fullSpec.indexOf(\"#\"));\n+        } else {\n+            specWithoutComment = fullSpec;\n+        }\n+        String[] tokens = specWithoutComment.split(\",\");\n+        this.name = name;\n+        if (tokens.length != 3) {\n+            throw new HeliosPropertiesFormatException(\"invalid length\", name, fullSpec);\n+        }\n+        try {\n+            String addr = tokens[0];\n+            String[] addrTokens;\n+            if (addr.contains(\":\")) {\n+                addrTokens = addr.split(\":\");\n+            } else {\n+                addrTokens = new String[] { addr };\n+            }\n+            bitLength = 8;\n+            bitStart = 0;\n+            this.address = (byte) (int) Integer.decode(addrTokens[0]);\n+            if (addrTokens.length > 1) {\n+                bitStart = (byte) (int) Integer.decode(addrTokens[1]);\n+                bitLength = 1;\n+            }\n+            if (addrTokens.length > 2) {\n+                bitLength = (byte) (int) Integer.decode(addrTokens[2]) - bitStart + 1;\n+            }\n+            if (addrTokens.length > 3) {\n+                throw new HeliosPropertiesFormatException(\n+                        \"invalid address spec: too many separators in bit specification\", name, fullSpec);\n+            }\n+        } catch (NumberFormatException e) {\n+            throw new HeliosPropertiesFormatException(\"invalid address spec\", name, fullSpec);\n+        }\n+\n+        this.writable = Boolean.parseBoolean(tokens[1]);\n+        try {\n+            this.datatype = DataType.valueOf(tokens[2].replaceAll(\"\\\\s+\", \"\"));\n+        } catch (IllegalArgumentException e) {\n+            throw new HeliosPropertiesFormatException(\"invalid type spec\", name, fullSpec);\n+        }\n+    }\n+\n+    public HeliosVentilationDataPoint(String name, byte address, boolean writable, DataType datatype) {\n+        this.datatype = datatype;\n+        this.writable = writable;\n+        this.name = name;\n+        this.address = address;\n+    }\n+\n+    public boolean isWritable() {\n+        return writable;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return name;\n+    }\n+\n+    /**\n+     *\n+     * @return the name of the variable, which is also the channel name\n+     */\n+    public String getName() {\n+        return name;\n+    }\n+\n+    /**\n+     *\n+     * @return address of the variable\n+     */\n+    public byte address() {\n+        return address;\n+    }\n+\n+    /**\n+     * @return the bit mask of the data point. 0xFF in case the full byte is used.\n+     */\n+    public byte bitMask() {\n+        byte mask = (byte) 0xff;\n+        if (datatype == DataType.NUMBER || datatype == DataType.SWITCH) {\n+            mask = (byte) (((1 << bitLength) - 1) << bitStart);\n+        }\n+        return mask;\n+    }\n+\n+    /**\n+     * interpret the given byte b and return the value as State.\n+     *\n+     * @param b\n+     * @return state representation of byte value b in current datatype\n+     */\n+    public State asState(byte b) {\n+        int val = b & 0xff;\n+        if (datatype == DataType.TEMPERATURE) {\n+            return new QuantityType<>(TEMP_MAP[val], SIUnits.CELSIUS);\n+        } else if (datatype == DataType.BYTE_PERCENT) {\n+            return new QuantityType<>((int) ((val - BYTE_PERCENT_OFFSET) * 100.0 / (255 - BYTE_PERCENT_OFFSET)),\n+                    SmartHomeUnits.PERCENT);\n+        } else if (datatype == DataType.SWITCH && bitLength == 1) {\n+            if ((b & (1 << bitStart)) != 0) {\n+                return OnOffType.ON;\n+            } else {\n+                return OnOffType.OFF;\n+            }\n+        } else if (datatype == DataType.NUMBER) {\n+            int value = (b & bitMask()) >> bitStart;\n+            return new DecimalType(value);\n+        } else if (datatype == DataType.PERCENT) {\n+            return new QuantityType<>(val, SmartHomeUnits.PERCENT);\n+        } else if (datatype == DataType.FANSPEED) {\n+            int i = 1;\n+            while (i < FANSPEED_MAP.length && FANSPEED_MAP[i] < val) {\n+                i++;\n+            }\n+            return new DecimalType(i);\n+        } else if (datatype == DataType.HYSTERESIS) {\n+            return new QuantityType<>(val / 3, SIUnits.CELSIUS);\n+        }\n+\n+        return UnDefType.UNDEF;\n+    }\n+\n+    /**\n+     * interpret the given byte b and return the value as string.\n+     *\n+     * @param b\n+     * @return sting representation of byte value b in current datatype\n+     */\n+    public String asString(byte b) {\n+        State ste = asState(b);\n+        String str = ste.toString();\n+        if (ste instanceof UnDefType) {\n+            return String.format(\"<unknown type> %02X \", b);\n+        } else {\n+            return str;\n+        }\n+    }\n+\n+    /**\n+     * generate byte data to transmit\n+     *\n+     * @param val is the state of a channel\n+     * @return byte value with RS485 representation. Bit level values are returned in the correct location, but other\n+     *         bits/datapoints in the same address are zero.\n+     */\n+    public byte getTransmitDataFor(State val) {\n+        byte result = 0;\n+        DecimalType value = val.as(DecimalType.class);\n+        if (value == null) {\n+            /*\n+             * if value is not convertible to a numeric type we cannot do anything reasonable with it, let's use the\n+             * initial value for it\n+             */\n+        } else if (datatype == DataType.TEMPERATURE) {\n+            QuantityType<?> quantvalue = ((QuantityType<?>) val);\n+            quantvalue = quantvalue.toUnit(SIUnits.CELSIUS);\n+            if (quantvalue != null) {\n+                value = quantvalue.as(DecimalType.class);\n+                if (value != null) {\n+                    int temp = (int) Math.round(value.doubleValue());\n+                    int i = 0;\n+                    while (i < TEMP_MAP.length && TEMP_MAP[i] < temp) {\n+                        i++;\n+                    }\n+                    result = (byte) i;\n+                }\n+            }\n+        } else if (datatype == DataType.FANSPEED) {\n+            int i = value.intValue();\n+            if (i < 0) {\n+                i = 0;\n+            } else if (i > 8) {\n+                i = 8;\n+            }\n+            result = (byte) FANSPEED_MAP[i];\n+        } else if (datatype == DataType.BYTE_PERCENT) {\n+            result = (byte) ((value.doubleValue() / 100.0) * (255 - BYTE_PERCENT_OFFSET) + BYTE_PERCENT_OFFSET);\n+        } else if (datatype == DataType.PERCENT) {\n+            double d = (Math.round(value.doubleValue()));\n+            if (d < 0.0) {\n+                d = 0.0;\n+            } else if (d > 100.0) {\n+                d = 100.0;\n+            }\n+            result = (byte) d;\n+        } else if (datatype == DataType.HYSTERESIS) {\n+            QuantityType<?> quantvalue = ((QuantityType<?>) val);\n+            quantvalue = quantvalue.toUnit(SIUnits.CELSIUS);\n+            if (quantvalue != null) {\n+                value = quantvalue.as(DecimalType.class);\n+                if (value != null) {\n+                    result = (byte) (value.intValue() * 3);\n+                }\n+            }\n+        } else if (datatype == DataType.SWITCH || datatype == DataType.NUMBER) {\n+            // those are the types supporting bit level specification\n+            // output only the relevant bits\n+            result = (byte) (value.intValue() << bitStart);\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Get further datapoint linked to the same address.\n+     *\n+     * @return sister datapoint\n+     */\n+    public @Nullable HeliosVentilationDataPoint link() {\n+        return link;\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b1658af39ccc8a2f98f4cc318896c32ee4ff9a4"}, "originalPosition": 294}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczOTAzOTkxOnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationDataPoint.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QwMDowMDo0NlrOGjUMOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xM1QwMDowMDo0NlrOGjUMOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4NDE1Mw==", "bodyText": "You can use a switch statement here as well.", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r439684153", "createdAt": "2020-06-13T00:00:46Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationDataPoint.java", "diffHunk": "@@ -0,0 +1,324 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+\n+/**\n+ * The {@link HeliosVentilationDataPoint} is a description of a datapoint in the Helios ventilation system.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosVentilationDataPoint {\n+    public enum DataType {\n+        TEMPERATURE,\n+        HYSTERESIS,\n+        FANSPEED,\n+        SWITCH,\n+        BYTE_PERCENT,\n+        PERCENT,\n+        NUMBER\n+    }\n+\n+    /**\n+     * mapping from temperature byte values to \u00b0C\n+     */\n+    private static final int TEMP_MAP[] = { -74, -70, -66, -62, -59, -56, -54, -52, -50, -48, -47, -46, -44, -43, -42,\n+            -41, -40, -39, -38, -37, -36, -35, -34, -33, -33, -32, -31, -30, -30, -29, -28, -28, -27, -27, -26, -25,\n+            -25, -24, -24, -23, -23, -22, -22, -21, -21, -20, -20, -19, -19, -19, -18, -18, -17, -17, -16, -16, -16,\n+            -15, -15, -14, -14, -14, -13, -13, -12, -12, -12, -11, -11, -11, -10, -10, -9, -9, -9, -8, -8, -8, -7, -7,\n+            -7, -6, -6, -6, -5, -5, -5, -4, -4, -4, -3, -3, -3, -2, -2, -2, -1, -1, -1, -1, 0, 0, 0, 1, 1, 1, 2, 2, 2,\n+            3, 3, 3, 4, 4, 4, 5, 5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 13,\n+            13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 18, 18, 18, 19, 19, 19, 20, 20, 21, 21, 21, 22, 22, 22,\n+            23, 23, 24, 24, 24, 25, 25, 26, 26, 27, 27, 27, 28, 28, 29, 29, 30, 30, 31, 31, 32, 32, 33, 33, 34, 34, 35,\n+            35, 36, 36, 37, 37, 38, 38, 39, 40, 40, 41, 41, 42, 43, 43, 44, 45, 45, 46, 47, 48, 48, 49, 50, 51, 52, 53,\n+            53, 54, 55, 56, 57, 59, 60, 61, 62, 63, 65, 66, 68, 69, 71, 73, 75, 77, 79, 81, 82, 86, 90, 93, 97, 100,\n+            100, 100, 100, 100, 100, 100, 100, 100 };\n+\n+    /**\n+     * mapping from human readable fanspeed to raw value\n+     */\n+    private static final int FANSPEED_MAP[] = { 0, 1, 3, 7, 15, 31, 63, 127, 255 };\n+\n+    private static final int BYTE_PERCENT_OFFSET = 52;\n+\n+    private String name;\n+    private boolean writable;\n+    private DataType datatype;\n+    private byte address;\n+    private int bitStart;\n+    private int bitLength;\n+\n+    private @Nullable HeliosVentilationDataPoint link;\n+\n+    /**\n+     * parse fullSpec in the properties format to declare a datapoint\n+     *\n+     * @param name the name of the datapoint\n+     * @param fullSpec datapoint specification, see format in datapoints.properties\n+     * @throws HeliosPropertiesFormatException in case fullSpec is not parsable\n+     */\n+    public HeliosVentilationDataPoint(String name, String fullSpec) throws HeliosPropertiesFormatException {\n+        String specWithoutComment;\n+        if (fullSpec.contains(\"#\")) {\n+            specWithoutComment = fullSpec.substring(0, fullSpec.indexOf(\"#\"));\n+        } else {\n+            specWithoutComment = fullSpec;\n+        }\n+        String[] tokens = specWithoutComment.split(\",\");\n+        this.name = name;\n+        if (tokens.length != 3) {\n+            throw new HeliosPropertiesFormatException(\"invalid length\", name, fullSpec);\n+        }\n+        try {\n+            String addr = tokens[0];\n+            String[] addrTokens;\n+            if (addr.contains(\":\")) {\n+                addrTokens = addr.split(\":\");\n+            } else {\n+                addrTokens = new String[] { addr };\n+            }\n+            bitLength = 8;\n+            bitStart = 0;\n+            this.address = (byte) (int) Integer.decode(addrTokens[0]);\n+            if (addrTokens.length > 1) {\n+                bitStart = (byte) (int) Integer.decode(addrTokens[1]);\n+                bitLength = 1;\n+            }\n+            if (addrTokens.length > 2) {\n+                bitLength = (byte) (int) Integer.decode(addrTokens[2]) - bitStart + 1;\n+            }\n+            if (addrTokens.length > 3) {\n+                throw new HeliosPropertiesFormatException(\n+                        \"invalid address spec: too many separators in bit specification\", name, fullSpec);\n+            }\n+        } catch (NumberFormatException e) {\n+            throw new HeliosPropertiesFormatException(\"invalid address spec\", name, fullSpec);\n+        }\n+\n+        this.writable = Boolean.parseBoolean(tokens[1]);\n+        try {\n+            this.datatype = DataType.valueOf(tokens[2].replaceAll(\"\\\\s+\", \"\"));\n+        } catch (IllegalArgumentException e) {\n+            throw new HeliosPropertiesFormatException(\"invalid type spec\", name, fullSpec);\n+        }\n+    }\n+\n+    public HeliosVentilationDataPoint(String name, byte address, boolean writable, DataType datatype) {\n+        this.datatype = datatype;\n+        this.writable = writable;\n+        this.name = name;\n+        this.address = address;\n+    }\n+\n+    public boolean isWritable() {\n+        return writable;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return name;\n+    }\n+\n+    /**\n+     *\n+     * @return the name of the variable, which is also the channel name\n+     */\n+    public String getName() {\n+        return name;\n+    }\n+\n+    /**\n+     *\n+     * @return address of the variable\n+     */\n+    public byte address() {\n+        return address;\n+    }\n+\n+    /**\n+     * @return the bit mask of the data point. 0xFF in case the full byte is used.\n+     */\n+    public byte bitMask() {\n+        byte mask = (byte) 0xff;\n+        if (datatype == DataType.NUMBER || datatype == DataType.SWITCH) {\n+            mask = (byte) (((1 << bitLength) - 1) << bitStart);\n+        }\n+        return mask;\n+    }\n+\n+    /**\n+     * interpret the given byte b and return the value as State.\n+     *\n+     * @param b\n+     * @return state representation of byte value b in current datatype\n+     */\n+    public State asState(byte b) {\n+        int val = b & 0xff;\n+        if (datatype == DataType.TEMPERATURE) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7b1658af39ccc8a2f98f4cc318896c32ee4ff9a4"}, "originalPosition": 177}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MTY5NzA1OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.heliosventilation/README.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNjoyMDo0MFrOGlNUug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNjoyMDo0MFrOGlNUug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY2ODc5NA==", "bodyText": "In the xml, this is Number:Dimensionless.", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r441668794", "createdAt": "2020-06-17T16:20:40Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.heliosventilation/README.md", "diffHunk": "@@ -0,0 +1,111 @@\n+# HeliosVentilation Binding\n+\n+This is the binding for Helios Ventilation Systems KWL EC 200/300/500 Pro.\n+It requires a connection to the RS485 bus used by the original remote controls KWL-FB (9417) and does not use the Modbus/TCP interface of the newer EasyControl devices.\n+\n+For electrical connection it is recommended to use an USB-RS485 interface, but any RS485 interface that shows up as a serial port will do.\n+Setup the device as described in https://www.openhab.org/docs/administration/serial.html.\n+\n+The binding will use the remote control address 15 for communication, so make sure that this is not assigned to a physically present remote control.\n+\n+## Supported Things\n+\n+There is only one thing type supported by this binding: a Helios Ventilation System KWL EC 200/300/500 Pro from Helios.\n+The binding was developed and test on a KWL EC 200 Pro device.\n+\n+## Binding Configuration\n+\n+The binding requires access to the serial device connecting to the RS485 bus as described in https://www.openhab.org/docs/administration/serial.html.\n+Otherwise only thing configuration is needed.\n+\n+## Thing Configuration\n+\n+The binding supports only one thing and requires the configuration of the serial port (typically /dev/ttyUSB0 on Linux and COM3 on Windows) and optionally the polling time which is the cycle time after which the binding tries to reconnect to the bus and requests data updates.\n+\n+## Channels\n+\n+Supported operation channels:\n+\n+| channel            | type               | description                                   |\n+|--------------------|--------------------|-----------------------------------------------|\n+| outsideTemp        | Number:Temperature | Temperature sensor in the outside air flow    |\n+| outgoingTemp       | Number:Temperature | Temperature sensor in the outgoing air flow   |\n+| extractTemp        | Number:Temperature | Temperature sensor in the extract air flow    |\n+| supplyTemp         | Number:Temperature | Temperature sensor in the supply air flow     |\n+| setTemp            | Number:Temperature | Set temperature for supply (not always used)  |\n+| fanspeed           | Number             | Level of the fanspeed (1-8)                   |\n+| powerState         | Switch             | Main power switch                             |\n+| co2State           | Switch             | Switch for CO2 regulation                     |\n+| rhState            | Switch             | Switch for humidity regulation                |\n+| winterMode         | Switch             | Switch to set winter mode                     |\n+\n+Supported configuration channels:\n+\n+| channel            | type               | description                                   |\n+|--------------------|--------------------|-----------------------------------------------|\n+| bypassTemp         | Number:Temperature | Temperature to disable the bypass function    |\n+| supplyStopTemp     | Number:Temperature | Temperature to stop supply fan for defrosting |\n+| preheatTemp        | Number:Temperature | Temperature to enable the preheater           |\n+| minFanspeed        | Number             | Minimal level of the fanspeed (1-8)           |\n+| maxFanspeed        | Number             | Maximal level of the fanspeed (1-8)           |\n+| rhLimit            | Number             | Limit for relative humidity sensor            |", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ca34287fdd55df6f75df4d9f2af94a9b46ff6c4"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MTcxNTU0OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationBindingConstants.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNjoyNToyOFrOGlNgVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNjoyNToyOFrOGlNgVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY3MTc2NA==", "bodyText": "Since this does not affect the stability of openHAB, ERROR is too much. Please reduce to WARN. The question is: if this can't be read, the binding won't work, correct? I wonder if we should throw an exception so that the binding initialization fails.\nSidenote: I know the log level is wrong in onewire. Will fix that.", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r441671764", "createdAt": "2020-06-17T16:25:28Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationBindingConstants.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import java.io.IOException;\n+import java.net.URL;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.smarthome.core.thing.ThingTypeUID;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HeliosVentilationBindingConstants} class defines common constants, which are\n+ * used across the whole binding.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosVentilationBindingConstants {\n+\n+    public static final String BINDING_ID = \"heliosventilation\";\n+\n+    public static final String DATAPOINT_FILE = \"datapoints.properties\";\n+\n+    // List of all Thing Type UIDs\n+    public static final ThingTypeUID THING_TYPE_HELIOS_VENTILATION = new ThingTypeUID(BINDING_ID, \"ventilation\");\n+\n+    public static final Map<Byte, HeliosVentilationDataPoint> DATAPOINTS;\n+\n+    private static final Logger LOGGER;\n+    static {\n+        /* logger is used by readChannelProperties() so we need to initialize logger first. */\n+        LOGGER = LoggerFactory.getLogger(HeliosVentilationBindingConstants.class);\n+        DATAPOINTS = readChannelProperties();\n+    }\n+    // List of all Channel ids\n+    // Channel ids are only in datapoints.properties and thing-types.xml\n+\n+    /**\n+     * parse datapoints from properties\n+     *\n+     */\n+    private static Map<Byte, HeliosVentilationDataPoint> readChannelProperties() {\n+        HashMap<Byte, HeliosVentilationDataPoint> result = new HashMap<Byte, HeliosVentilationDataPoint>();\n+\n+        URL resource = Thread.currentThread().getContextClassLoader().getResource(DATAPOINT_FILE);\n+        Properties properties = new Properties();\n+        try {\n+            properties.load(resource.openStream());\n+\n+            Enumeration<Object> keys = properties.keys();\n+            while (keys.hasMoreElements()) {\n+                String channel = (String) keys.nextElement();\n+                HeliosVentilationDataPoint dp;\n+                try {\n+                    dp = new HeliosVentilationDataPoint(channel, properties.getProperty(channel));\n+                    if (result.containsKey(dp.address())) {\n+                        result.get(dp.address()).append(dp);\n+                    } else {\n+                        result.put(dp.address(), dp);\n+                    }\n+                } catch (HeliosPropertiesFormatException e) {\n+                    LOGGER.error(\"could not read resource file {}, binding will probably fail: {}\", DATAPOINT_FILE,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ca34287fdd55df6f75df4d9f2af94a9b46ff6c4"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MTcyMjg5OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationDataPoint.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNjoyNzoyNlrOGlNlHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNjoyNzoyNlrOGlNlHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY3Mjk4OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @return true iff writing to this datapoint requires a read-modify-write on the address\n          \n          \n            \n                 * @return true if writing to this datapoint requires a read-modify-write on the address", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r441672989", "createdAt": "2020-06-17T16:27:26Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationDataPoint.java", "diffHunk": "@@ -0,0 +1,334 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.library.unit.SIUnits;\n+import org.eclipse.smarthome.core.library.unit.SmartHomeUnits;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.core.types.UnDefType;\n+\n+/**\n+ * The {@next HeliosVentilationDataPoint} is a description of a datapoint in the Helios ventilation system.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosVentilationDataPoint {\n+    public enum DataType {\n+        TEMPERATURE,\n+        HYSTERESIS,\n+        FANSPEED,\n+        SWITCH,\n+        BYTE_PERCENT,\n+        PERCENT,\n+        NUMBER\n+    }\n+\n+    /**\n+     * mapping from temperature byte values to \u00b0C\n+     */\n+    private static final int[] TEMP_MAP = { -74, -70, -66, -62, -59, -56, -54, -52, -50, -48, -47, -46, -44, -43, -42,\n+            -41, -40, -39, -38, -37, -36, -35, -34, -33, -33, -32, -31, -30, -30, -29, -28, -28, -27, -27, -26, -25,\n+            -25, -24, -24, -23, -23, -22, -22, -21, -21, -20, -20, -19, -19, -19, -18, -18, -17, -17, -16, -16, -16,\n+            -15, -15, -14, -14, -14, -13, -13, -12, -12, -12, -11, -11, -11, -10, -10, -9, -9, -9, -8, -8, -8, -7, -7,\n+            -7, -6, -6, -6, -5, -5, -5, -4, -4, -4, -3, -3, -3, -2, -2, -2, -1, -1, -1, -1, 0, 0, 0, 1, 1, 1, 2, 2, 2,\n+            3, 3, 3, 4, 4, 4, 5, 5, 5, 5, 6, 6, 6, 7, 7, 7, 8, 8, 8, 9, 9, 9, 10, 10, 10, 11, 11, 11, 12, 12, 12, 13,\n+            13, 13, 14, 14, 14, 15, 15, 15, 16, 16, 16, 17, 17, 18, 18, 18, 19, 19, 19, 20, 20, 21, 21, 21, 22, 22, 22,\n+            23, 23, 24, 24, 24, 25, 25, 26, 26, 27, 27, 27, 28, 28, 29, 29, 30, 30, 31, 31, 32, 32, 33, 33, 34, 34, 35,\n+            35, 36, 36, 37, 37, 38, 38, 39, 40, 40, 41, 41, 42, 43, 43, 44, 45, 45, 46, 47, 48, 48, 49, 50, 51, 52, 53,\n+            53, 54, 55, 56, 57, 59, 60, 61, 62, 63, 65, 66, 68, 69, 71, 73, 75, 77, 79, 81, 82, 86, 90, 93, 97, 100,\n+            100, 100, 100, 100, 100, 100, 100, 100 };\n+\n+    /**\n+     * mapping from human readable fanspeed to raw value\n+     */\n+    private static final int[] FANSPEED_MAP = { 0, 1, 3, 7, 15, 31, 63, 127, 255 };\n+\n+    private static final int BYTE_PERCENT_OFFSET = 52;\n+\n+    private String name;\n+    private boolean writable;\n+    private DataType datatype;\n+    private byte address;\n+    private int bitStart;\n+    private int bitLength;\n+\n+    private @Nullable HeliosVentilationDataPoint next;\n+\n+    /**\n+     * parse fullSpec in the properties format to declare a datapoint\n+     *\n+     * @param name the name of the datapoint\n+     * @param fullSpec datapoint specification, see format in datapoints.properties\n+     * @throws HeliosPropertiesFormatException in case fullSpec is not parsable\n+     */\n+    public HeliosVentilationDataPoint(String name, String fullSpec) throws HeliosPropertiesFormatException {\n+        String specWithoutComment;\n+        if (fullSpec.contains(\"#\")) {\n+            specWithoutComment = fullSpec.substring(0, fullSpec.indexOf(\"#\"));\n+        } else {\n+            specWithoutComment = fullSpec;\n+        }\n+        String[] tokens = specWithoutComment.split(\",\");\n+        this.name = name;\n+        if (tokens.length != 3) {\n+            throw new HeliosPropertiesFormatException(\"invalid length\", name, fullSpec);\n+        }\n+        try {\n+            String addr = tokens[0];\n+            String[] addrTokens;\n+            if (addr.contains(\":\")) {\n+                addrTokens = addr.split(\":\");\n+            } else {\n+                addrTokens = new String[] { addr };\n+            }\n+            bitLength = 8;\n+            bitStart = 0;\n+            this.address = (byte) (int) Integer.decode(addrTokens[0]);\n+            if (addrTokens.length > 1) {\n+                bitStart = (byte) (int) Integer.decode(addrTokens[1]);\n+                bitLength = 1;\n+            }\n+            if (addrTokens.length > 2) {\n+                bitLength = (byte) (int) Integer.decode(addrTokens[2]) - bitStart + 1;\n+            }\n+            if (addrTokens.length > 3) {\n+                throw new HeliosPropertiesFormatException(\n+                        \"invalid address spec: too many separators in bit specification\", name, fullSpec);\n+            }\n+        } catch (NumberFormatException e) {\n+            throw new HeliosPropertiesFormatException(\"invalid address spec\", name, fullSpec);\n+        }\n+\n+        this.writable = Boolean.parseBoolean(tokens[1]);\n+        try {\n+            this.datatype = DataType.valueOf(tokens[2].replaceAll(\"\\\\s+\", \"\"));\n+        } catch (IllegalArgumentException e) {\n+            throw new HeliosPropertiesFormatException(\"invalid type spec\", name, fullSpec);\n+        }\n+    }\n+\n+    public HeliosVentilationDataPoint(String name, byte address, boolean writable, DataType datatype) {\n+        this.datatype = datatype;\n+        this.writable = writable;\n+        this.name = name;\n+        this.address = address;\n+    }\n+\n+    public boolean isWritable() {\n+        return writable;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return name;\n+    }\n+\n+    /**\n+     *\n+     * @return the name of the variable, which is also the channel name\n+     */\n+    public String getName() {\n+        return name;\n+    }\n+\n+    /**\n+     *\n+     * @return address of the variable\n+     */\n+    public byte address() {\n+        return address;\n+    }\n+\n+    /**\n+     * @return the bit mask of the data point. 0xFF in case the full byte is used.\n+     */\n+    public byte bitMask() {\n+        byte mask = (byte) 0xff;\n+        if (datatype == DataType.NUMBER || datatype == DataType.SWITCH) {\n+            mask = (byte) (((1 << bitLength) - 1) << bitStart);\n+        }\n+        return mask;\n+    }\n+\n+    /**\n+     * interpret the given byte b and return the value as State.\n+     *\n+     * @param b\n+     * @return state representation of byte value b in current datatype\n+     */\n+    public State asState(byte b) {\n+        int val = b & 0xff;\n+        switch (datatype) {\n+            case TEMPERATURE:\n+                return new QuantityType<>(TEMP_MAP[val], SIUnits.CELSIUS);\n+            case BYTE_PERCENT:\n+                return new QuantityType<>((int) ((val - BYTE_PERCENT_OFFSET) * 100.0 / (255 - BYTE_PERCENT_OFFSET)),\n+                        SmartHomeUnits.PERCENT);\n+            case SWITCH:\n+                if (bitLength != 1) {\n+                    return UnDefType.UNDEF;\n+                } else if ((b & (1 << bitStart)) != 0) {\n+                    return OnOffType.ON;\n+                } else {\n+                    return OnOffType.OFF;\n+                }\n+            case NUMBER:\n+                int value = (b & bitMask()) >> bitStart;\n+                return new DecimalType(value);\n+            case PERCENT:\n+                return new QuantityType<>(val, SmartHomeUnits.PERCENT);\n+            case FANSPEED:\n+                int i = 1;\n+                while (i < FANSPEED_MAP.length && FANSPEED_MAP[i] < val) {\n+                    i++;\n+                }\n+                return new DecimalType(i);\n+            case HYSTERESIS:\n+                return new QuantityType<>(val / 3, SIUnits.CELSIUS);\n+            default:\n+                return UnDefType.UNDEF;\n+        }\n+    }\n+\n+    /**\n+     * interpret the given byte b and return the value as string.\n+     *\n+     * @param b\n+     * @return sting representation of byte value b in current datatype\n+     */\n+    public String asString(byte b) {\n+        State ste = asState(b);\n+        String str = ste.toString();\n+        if (ste instanceof UnDefType) {\n+            return String.format(\"<unknown type> %02X \", b);\n+        } else {\n+            return str;\n+        }\n+    }\n+\n+    /**\n+     * generate byte data to transmit\n+     *\n+     * @param val is the state of a channel\n+     * @return byte value with RS485 representation. Bit level values are returned in the correct location, but other\n+     *         bits/datapoints in the same address are zero.\n+     */\n+    public byte getTransmitDataFor(State val) {\n+        byte result = 0;\n+        DecimalType value = val.as(DecimalType.class);\n+        if (value == null) {\n+            /*\n+             * if value is not convertible to a numeric type we cannot do anything reasonable with it, let's use the\n+             * initial value for it\n+             */\n+        } else {\n+            QuantityType<?> quantvalue;\n+            switch (datatype) {\n+                case TEMPERATURE:\n+                    quantvalue = ((QuantityType<?>) val);\n+                    quantvalue = quantvalue.toUnit(SIUnits.CELSIUS);\n+                    if (quantvalue != null) {\n+                        value = quantvalue.as(DecimalType.class);\n+                        if (value != null) {\n+                            int temp = (int) Math.round(value.doubleValue());\n+                            int i = 0;\n+                            while (i < TEMP_MAP.length && TEMP_MAP[i] < temp) {\n+                                i++;\n+                            }\n+                            result = (byte) i;\n+                        }\n+                    }\n+                    break;\n+                case FANSPEED:\n+                    int i = value.intValue();\n+                    if (i < 0) {\n+                        i = 0;\n+                    } else if (i > 8) {\n+                        i = 8;\n+                    }\n+                    result = (byte) FANSPEED_MAP[i];\n+                    break;\n+                case BYTE_PERCENT:\n+                    result = (byte) ((value.doubleValue() / 100.0) * (255 - BYTE_PERCENT_OFFSET) + BYTE_PERCENT_OFFSET);\n+                    break;\n+                case PERCENT:\n+                    double d = (Math.round(value.doubleValue()));\n+                    if (d < 0.0) {\n+                        d = 0.0;\n+                    } else if (d > 100.0) {\n+                        d = 100.0;\n+                    }\n+                    result = (byte) d;\n+                    break;\n+                case HYSTERESIS:\n+                    quantvalue = ((QuantityType<?>) val).toUnit(SIUnits.CELSIUS);\n+                    if (quantvalue != null) {\n+                        result = (byte) (quantvalue.intValue() * 3);\n+                    }\n+                    break;\n+                case SWITCH:\n+                case NUMBER:\n+                    // those are the types supporting bit level specification\n+                    // output only the relevant bits\n+                    result = (byte) (value.intValue() << bitStart);\n+                    break;\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Get further datapoint linked to the same address.\n+     *\n+     * @return sister datapoint\n+     */\n+    public @Nullable HeliosVentilationDataPoint next() {\n+        return next;\n+    }\n+\n+    /**\n+     * Add a next to a datapoint on the same address.\n+     * Caller has to ensure that identical datapoints are not added several times.\n+     *\n+     * @param next is the sister datapoint\n+     */\n+    public void append(HeliosVentilationDataPoint next) {\n+        HeliosVentilationDataPoint existing = this.next;\n+        if (this == next) {\n+            // this datapoint is already there, so we do nothing and return\n+            return;\n+        } else if (existing != null) {\n+            existing.append(next);\n+        } else {\n+            this.next = next;\n+        }\n+    }\n+\n+    /**\n+     * @return true iff writing to this datapoint requires a read-modify-write on the address", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ca34287fdd55df6f75df4d9f2af94a9b46ff6c4"}, "originalPosition": 325}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MTg1MjY2OnYy", "diffSide": "RIGHT", "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationHandler.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNzowMjozOVrOGlO6RQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMVQxOTozMzowNFrOGmt03Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY5NDc4OQ==", "bodyText": "Why do you do this? Wouldn't\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n          \n          \n            \n                private final Logger logger = LoggerFactory.getLogger(HeliosVentilationHandler.class);\n          \n      \n    \n    \n  \n\nalso work?", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r441694789", "createdAt": "2020-06-17T17:02:39Z", "author": {"login": "J-N-K"}, "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationHandler.java", "diffHunk": "@@ -0,0 +1,461 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.lang.invoke.MethodHandles;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HeliosVentilationHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosVentilationHandler extends BaseThingHandler implements SerialPortEventListener {\n+    private static final int BUSMEMBER_MAINBOARD = 0x11;\n+    private static final int BUSMEMBER_SLAVEBOARDS = 0x10;\n+    private static final byte BUSMEMBER_CONTROLBOARDS = (byte) 0x20;\n+    private static final int BUSMEMBER_REC_MASK = 0xF0; // interpreting frames delivered to BUSMEMBER_ME &\n+                                                        // BUSMEMBER_REC_MASK\n+    private static final int BUSMEMBER_ME = 0x2F; // used as sender when communicating with the helios system\n+    private static final int POLL_OFFLINE_THRESHOLD = 3;\n+\n+    /** Logger Instance */\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4ca34287fdd55df6f75df4d9f2af94a9b46ff6c4"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI0OTg4NQ==", "bodyText": "yes, works also. I guess I have seen that somewhere in another binding.", "url": "https://github.com/openhab/openhab-addons/pull/7858#discussion_r443249885", "createdAt": "2020-06-21T19:33:04Z", "author": {"login": "ramack"}, "path": "bundles/org.openhab.binding.heliosventilation/src/main/java/org/openhab/binding/heliosventilation/internal/HeliosVentilationHandler.java", "diffHunk": "@@ -0,0 +1,461 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.heliosventilation.internal;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.lang.invoke.MethodHandles;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.TooManyListenersException;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.eclipse.smarthome.core.library.types.DecimalType;\n+import org.eclipse.smarthome.core.library.types.OnOffType;\n+import org.eclipse.smarthome.core.library.types.QuantityType;\n+import org.eclipse.smarthome.core.thing.ChannelUID;\n+import org.eclipse.smarthome.core.thing.Thing;\n+import org.eclipse.smarthome.core.thing.ThingStatus;\n+import org.eclipse.smarthome.core.thing.ThingStatusDetail;\n+import org.eclipse.smarthome.core.thing.binding.BaseThingHandler;\n+import org.eclipse.smarthome.core.types.Command;\n+import org.eclipse.smarthome.core.types.RefreshType;\n+import org.eclipse.smarthome.core.types.State;\n+import org.eclipse.smarthome.io.transport.serial.PortInUseException;\n+import org.eclipse.smarthome.io.transport.serial.SerialPort;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEvent;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortEventListener;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortIdentifier;\n+import org.eclipse.smarthome.io.transport.serial.SerialPortManager;\n+import org.eclipse.smarthome.io.transport.serial.UnsupportedCommOperationException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link HeliosVentilationHandler} is responsible for handling commands, which are\n+ * sent to one of the channels.\n+ *\n+ * @author Raphael Mack - Initial contribution\n+ */\n+@NonNullByDefault\n+public class HeliosVentilationHandler extends BaseThingHandler implements SerialPortEventListener {\n+    private static final int BUSMEMBER_MAINBOARD = 0x11;\n+    private static final int BUSMEMBER_SLAVEBOARDS = 0x10;\n+    private static final byte BUSMEMBER_CONTROLBOARDS = (byte) 0x20;\n+    private static final int BUSMEMBER_REC_MASK = 0xF0; // interpreting frames delivered to BUSMEMBER_ME &\n+                                                        // BUSMEMBER_REC_MASK\n+    private static final int BUSMEMBER_ME = 0x2F; // used as sender when communicating with the helios system\n+    private static final int POLL_OFFLINE_THRESHOLD = 3;\n+\n+    /** Logger Instance */\n+    private final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY5NDc4OQ=="}, "originalCommit": {"oid": "4ca34287fdd55df6f75df4d9f2af94a9b46ff6c4"}, "originalPosition": 65}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4986, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}