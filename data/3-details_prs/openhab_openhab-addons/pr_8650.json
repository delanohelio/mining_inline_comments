{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDk3MzM0Njgz", "number": 8650, "title": "[lutron] Add LEAP protocol support", "bodyText": "This is a major update to the Lutron binding that adds support for the LEAP protocol used by some newer Lutron hubs, including those for Caseta and RA2 Select.\nMajor changes include the following:\n\nAddition of new leapbridge thing for LEAP protocol support\nAddition of LEAP discovery service\nRefactoring of command handling to support multiple protocols\nAddition of ogroup thing to support occupancy groups\nAddition of fan thing to better support ceiling fans\n\nThe LEAP protocol is undocumented and quite complex, so developing the new bridge required a lot of time and a lot of trial and error. There are some publicly available examples of code that uses the LEAP protocol out there, but most of them provide only minimal functionality and none of them (that I could find) are written in Java. The pylutron-caseta project at https://github.com/gurumitts/pylutron-caseta was the most useful to me as a reference, so I\u2019d like to acknowledge the authors.\nThe way all of the existing device handlers formerly communicated with the bridge was somewhat specific to the Lutron Integration Protocol (LIP) used by ipbridge, so adding the new leapbridge necessitated modifying all of them in order to make that communication more generic.\nThis update has been in the works since March, and several users have been testing alpha and beta versions of the updated binding. There is some discussion about it here: https://community.openhab.org/t/lutron-caseta-support/102310\nCloses #8062", "createdAt": "2020-10-03T20:33:16Z", "url": "https://github.com/openhab/openhab-addons/pull/8650", "merged": true, "mergeCommit": {"oid": "6f659f23089658bfefaffbc1fe1addaf6f9ad9c6"}, "closed": true, "closedAt": "2020-10-15T22:59:25Z", "author": {"login": "bobadair"}, "timelineItems": {"totalCount": 19, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdPC0mpABqjM4MzcwMzgxMzY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdS587wgFqTUwOTg2NTA1OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "474b43b0654c1ca1983d167c0911780698abc373", "author": {"user": {"login": "bobadair", "name": "Bob A."}}, "url": "https://github.com/openhab/openhab-addons/commit/474b43b0654c1ca1983d167c0911780698abc373", "committedDate": "2020-10-03T22:28:29Z", "message": "[lutron] Change trusting parameter to certValidate\n\nSigned-off-by: Bob Adair <bob.github@att.net>"}, "afterCommit": {"oid": "e7234046886f1a65d376940e9d822e57cd9393a3", "author": {"user": {"login": "bobadair", "name": "Bob A."}}, "url": "https://github.com/openhab/openhab-addons/commit/e7234046886f1a65d376940e9d822e57cd9393a3", "committedDate": "2020-10-03T23:02:52Z", "message": "[lutron] Change trusting parameter to certValidate\n\nSigned-off-by: Bob Adair <bob.github@att.net>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2d5a90ef96d848bf6c2c59b5a5ffcf92d697986a", "author": {"user": {"login": "bobadair", "name": "Bob A."}}, "url": "https://github.com/openhab/openhab-addons/commit/2d5a90ef96d848bf6c2c59b5a5ffcf92d697986a", "committedDate": "2020-10-04T02:23:25Z", "message": "[lutron] Remove all mentions of Paper UI in doc file\n\nSigned-off-by: Bob Adair <bob.github@att.net>"}, "afterCommit": {"oid": "baa2a503641eef766c3007fec184cb2063f49ee6", "author": {"user": {"login": "bobadair", "name": "Bob A."}}, "url": "https://github.com/openhab/openhab-addons/commit/baa2a503641eef766c3007fec184cb2063f49ee6", "committedDate": "2020-10-04T21:00:28Z", "message": "[lutron] Clean up code and eliminate warnings\n\nSigned-off-by: Bob Adair <bob.github@att.net>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0cbeb88290b9591652ad26fea8fbc47a64ba5105", "author": {"user": {"login": "bobadair", "name": "Bob A."}}, "url": "https://github.com/openhab/openhab-addons/commit/0cbeb88290b9591652ad26fea8fbc47a64ba5105", "committedDate": "2020-10-05T22:03:46Z", "message": "[lutron] Add LEAP protocol support\n\n* Add new leapbridge thing for LEAP protocol support\n* Add LEAP discovery service\n* Refactor command handling to support multiple protocols\n* Add ogroup thing to support occupancy groups\n* Add fan thing to better support ceiling fans\n* Updates for OH3.0\n\nSigned-off-by: Bob Adair <bob.github@att.net>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "63e5aa390fab5bc4402390f35e512a5a6d004490", "author": {"user": {"login": "bobadair", "name": "Bob A."}}, "url": "https://github.com/openhab/openhab-addons/commit/63e5aa390fab5bc4402390f35e512a5a6d004490", "committedDate": "2020-10-05T22:03:46Z", "message": "[lutron] Change trusting parameter to certValidate\n\nSigned-off-by: Bob Adair <bob.github@att.net>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6d8c951ea12d52f2be0168bcebcd04e2fc7734c9", "author": {"user": {"login": "bobadair", "name": "Bob A."}}, "url": "https://github.com/openhab/openhab-addons/commit/6d8c951ea12d52f2be0168bcebcd04e2fc7734c9", "committedDate": "2020-10-05T22:03:46Z", "message": "[lutron] Remove all mentions of Paper UI in doc file\n\nSigned-off-by: Bob Adair <bob.github@att.net>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9026189d20edbed34223dbfc83efb4c82d258247", "author": {"user": {"login": "bobadair", "name": "Bob A."}}, "url": "https://github.com/openhab/openhab-addons/commit/9026189d20edbed34223dbfc83efb4c82d258247", "committedDate": "2020-10-05T22:03:46Z", "message": "[lutron] Clean up code and eliminate warnings\n\nSigned-off-by: Bob Adair <bob.github@att.net>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "deb48c1252ee18917f2f9e19cf0158fedb164659", "author": {"user": {"login": "bobadair", "name": "Bob A."}}, "url": "https://github.com/openhab/openhab-addons/commit/deb48c1252ee18917f2f9e19cf0158fedb164659", "committedDate": "2020-10-06T21:12:27Z", "message": "[lutron] Resolve remaining TODO comments\n\nSigned-off-by: Bob Adair <bob.github@att.net>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "baa2a503641eef766c3007fec184cb2063f49ee6", "author": {"user": {"login": "bobadair", "name": "Bob A."}}, "url": "https://github.com/openhab/openhab-addons/commit/baa2a503641eef766c3007fec184cb2063f49ee6", "committedDate": "2020-10-04T21:00:28Z", "message": "[lutron] Clean up code and eliminate warnings\n\nSigned-off-by: Bob Adair <bob.github@att.net>"}, "afterCommit": {"oid": "deb48c1252ee18917f2f9e19cf0158fedb164659", "author": {"user": {"login": "bobadair", "name": "Bob A."}}, "url": "https://github.com/openhab/openhab-addons/commit/deb48c1252ee18917f2f9e19cf0158fedb164659", "committedDate": "2020-10-06T21:12:27Z", "message": "[lutron] Resolve remaining TODO comments\n\nSigned-off-by: Bob Adair <bob.github@att.net>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAzNDQzNjEx", "url": "https://github.com/openhab/openhab-addons/pull/8650#pullrequestreview-503443611", "createdAt": "2020-10-07T00:15:09Z", "commit": {"oid": "deb48c1252ee18917f2f9e19cf0158fedb164659"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwMDoxNToxMFrOHdeN5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwMjoyODozMFrOHdgaVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY2NTgyOA==", "bodyText": "I suggest that you change your discovery service into a ThingHandlerService so that you don't have to manage osgi registration of this class. It is a bit verbose to explain how to make the change but I've found another PR that shows exactly the changes that are required: https://github.com/openhab/openhab-addons/pull/6396/files", "url": "https://github.com/openhab/openhab-addons/pull/8650#discussion_r500665828", "createdAt": "2020-10-07T00:15:10Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lutron/src/main/java/org/openhab/binding/lutron/internal/discovery/LeapDeviceDiscoveryService.java", "diffHunk": "@@ -0,0 +1,201 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.openhab.binding.lutron.internal.discovery;\n+\n+import static org.openhab.binding.lutron.internal.LutronBindingConstants.*;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.lutron.internal.LutronHandlerFactory;\n+import org.openhab.binding.lutron.internal.handler.LeapBridgeHandler;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Area;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Device;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.OccupancyGroup;\n+import org.openhab.core.config.discovery.AbstractDiscoveryService;\n+import org.openhab.core.config.discovery.DiscoveryResult;\n+import org.openhab.core.config.discovery.DiscoveryResultBuilder;\n+import org.openhab.core.thing.ThingTypeUID;\n+import org.openhab.core.thing.ThingUID;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * The {@link LeapDeviceDiscoveryService} discovers devices paired with Lutron bridges using the LEAP protocol.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LeapDeviceDiscoveryService extends AbstractDiscoveryService {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "deb48c1252ee18917f2f9e19cf0158fedb164659"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY2ODc5MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        throw (new IllegalArgumentException(\"Invalid command parameter\"));\n          \n          \n            \n                        throw new IllegalArgumentException(\"Invalid command parameter\");", "url": "https://github.com/openhab/openhab-addons/pull/8650#discussion_r500668791", "createdAt": "2020-10-07T00:25:22Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lutron/src/main/java/org/openhab/binding/lutron/internal/protocol/LIPCommand.java", "diffHunk": "@@ -0,0 +1,71 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lutron.internal.protocol;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.lutron.internal.handler.LeapBridgeHandler;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapCommand;\n+import org.openhab.binding.lutron.internal.protocol.lip.LutronCommandType;\n+import org.openhab.binding.lutron.internal.protocol.lip.LutronOperation;\n+import org.openhab.binding.lutron.internal.protocol.lip.TargetType;\n+\n+/**\n+ * Generic LIP command for use inside bridge handler\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LIPCommand extends LutronCommandNew {\n+    private final Object[] parameters;\n+\n+    public LIPCommand(TargetType targetType, LutronOperation operation, LutronCommandType CommandType,\n+            @Nullable Integer integrationId, Object... parameters) {\n+        super(targetType, operation, CommandType, integrationId);\n+        this.parameters = parameters;\n+    }\n+\n+    @Override\n+    public String lipCommand() {\n+        StringBuilder builder = new StringBuilder().append(operation).append(commandType);\n+        if (integrationId != null) {\n+            builder.append(',').append(integrationId);\n+        }\n+        if (parameters != null) { // This CAN be null\n+            for (Object parameter : parameters) {\n+                builder.append(',').append(parameter);\n+            }\n+        }\n+\n+        return builder.toString();\n+    }\n+\n+    @Override\n+    public @Nullable LeapCommand leapCommand(LeapBridgeHandler bridgeHandler, @Nullable Integer leapZone) {\n+        return null;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return lipCommand();\n+    }\n+\n+    public int getNumberParameter(int position) {\n+        if (parameters.length > position && parameters[position] instanceof Number) {\n+            Number num = (Number) parameters[position];\n+            return num.intValue();\n+        } else {\n+            throw (new IllegalArgumentException(\"Invalid command parameter\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "deb48c1252ee18917f2f9e19cf0158fedb164659"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY3MDIwNg==", "bodyText": "not parsed?", "url": "https://github.com/openhab/openhab-addons/pull/8650#discussion_r500670206", "createdAt": "2020-10-07T00:30:36Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lutron/src/main/java/org/openhab/binding/lutron/internal/protocol/leap/LeapMessageParser.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lutron.internal.protocol.leap;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Area;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ButtonGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Device;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ExceptionDetail;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Header;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.OccupancyGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.OccupancyGroupStatus;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ZoneStatus;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import com.google.gson.JsonArray;\n+import com.google.gson.JsonElement;\n+import com.google.gson.JsonObject;\n+import com.google.gson.JsonParseException;\n+import com.google.gson.JsonParser;\n+import com.google.gson.JsonSyntaxException;\n+\n+/**\n+ * Class responsible for parsing incoming LEAP messages\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LeapMessageParser {\n+    private final Logger logger = LoggerFactory.getLogger(LeapMessageParser.class);\n+\n+    private final Gson gson;\n+    private final LeapMessageParserCallbacks callback;\n+\n+    /**\n+     * LeapMessageParser Constructor\n+     *\n+     * @param callback Object implementing the LeapMessageParserCallbacks interface\n+     */\n+    public LeapMessageParser(LeapMessageParserCallbacks callback) {\n+        gson = new GsonBuilder().create();\n+        this.callback = callback;\n+    }\n+\n+    /**\n+     * Parse and process a LEAP protocol message\n+     *\n+     * @param msg String containing the LEAP message\n+     */\n+    public void handleMessage(String msg) {\n+        if (msg.trim().equals(\"\")) {\n+            return; // Ignore empty lines\n+        }\n+        logger.trace(\"Received message: {}\", msg);\n+\n+        try {\n+            JsonObject message = (JsonObject) new JsonParser().parse(msg);\n+\n+            if (!message.has(\"CommuniqueType\")) {\n+                logger.debug(\"No CommuniqueType found in message: {}\", msg);\n+                return;\n+            }\n+\n+            String communiqueType = message.get(\"CommuniqueType\").getAsString();\n+            // CommuniqueType type = CommuniqueType.valueOf(communiqueType);\n+            logger.debug(\"Received CommuniqueType: {}\", communiqueType);\n+            callback.validMessageReceived(communiqueType);\n+\n+            switch (communiqueType) {\n+                case \"CreateResponse\":\n+                    return;\n+                case \"ReadResponse\":\n+                    handleReadResponseMessage(message);\n+                    break;\n+                case \"UpdateResponse\":\n+                    break;\n+                case \"SubscribeResponse\":\n+                    // Subscribe responses can contain bodies with data\n+                    handleReadResponseMessage(message);\n+                    return;\n+                case \"UnsubscribeResponse\":\n+                    return;\n+                case \"ExceptionResponse\":\n+                    handleExceptionResponse(message);\n+                    return;\n+                default:\n+                    logger.debug(\"Unknown CommuniqueType received: {}\", communiqueType);\n+                    break;\n+            }\n+        } catch (JsonParseException e) {\n+            logger.debug(\"Error parsing message: {}\", e.getMessage());\n+            return;\n+        }\n+    }\n+\n+    /**\n+     * Method called by handleMessage() to handle all LEAP ExceptionResponse messages.\n+     *\n+     * @param message LEAP message\n+     */\n+    private void handleExceptionResponse(JsonObject message) {\n+        String detailMessage = \"\";\n+\n+        try {\n+            JsonObject header = message.get(\"Header\").getAsJsonObject();\n+            Header headerObj = gson.fromJson(header, Header.class);\n+\n+            if (MessageBodyType.ExceptionDetail.toString().equalsIgnoreCase(headerObj.messageBodyType)\n+                    && message.has(\"Body\")) {\n+                JsonObject body = message.get(\"Body\").getAsJsonObject();\n+                ExceptionDetail exceptionDetail = gson.fromJson(body, ExceptionDetail.class);\n+                if (exceptionDetail != null) {\n+                    detailMessage = exceptionDetail.message;\n+                }\n+            }\n+            logger.debug(\"Exception response received. Status: {} URL: {} Message: {}\", headerObj.statusCode,\n+                    headerObj.url, detailMessage);\n+\n+        } catch (JsonParseException | IllegalStateException e) {\n+            logger.debug(\"Exception response received. Error parsing exception message: {}\", e.getMessage());\n+            return;\n+        }\n+    }\n+\n+    /**\n+     * Method called by handleMessage() to handle all LEAP ReadResponse and SubscribeResponse messages.\n+     *\n+     * @param message LEAP message\n+     */\n+    private void handleReadResponseMessage(JsonObject message) {\n+        try {\n+            JsonObject header = message.get(\"Header\").getAsJsonObject();\n+            Header headerObj = gson.fromJson(header, Header.class);\n+\n+            // if 204/NoContent response received for buttongroup request, create empty button map\n+            if (Request.BUTTON_GROUP_URL.equals(headerObj.url)\n+                    && Header.STATUS_NO_CONTENT.equalsIgnoreCase(headerObj.statusCode)) {\n+                callback.handleEmptyButtonGroupDefinition();\n+                return;\n+            }\n+\n+            if (!header.has(\"MessageBodyType\")) {\n+                logger.trace(\"No MessageBodyType in header\");\n+                return;\n+            }\n+            String messageBodyType = header.get(\"MessageBodyType\").getAsString();\n+            logger.trace(\"MessageBodyType: {}\", messageBodyType);\n+\n+            if (!message.has(\"Body\")) {\n+                logger.debug(\"No Body found in message\");\n+                return;\n+            }\n+            JsonObject body = message.get(\"Body\").getAsJsonObject();\n+\n+            switch (messageBodyType) {\n+                case \"OnePingResponse\":\n+                    parseOnePingResponse(body);\n+                    break;\n+                case \"OneZoneStatus\":\n+                    parseOneZoneStatus(body);\n+                    break;\n+                case \"MultipleAreaDefinition\":\n+                    parseMultipleAreaDefinition(body);\n+                    break;\n+                case \"MultipleButtonGroupDefinition\":\n+                    parseMultipleButtonGroupDefinition(body);\n+                    break;\n+                case \"MultipleDeviceDefinition\":\n+                    parseMultipleDeviceDefinition(body);\n+                    break;\n+                case \"MultipleOccupancyGroupDefinition\":\n+                    parseMultipleOccupancyGroupDefinition(body);\n+                    break;\n+                case \"MultipleOccupancyGroupStatus\":\n+                    parseMultipleOccupancyGroupStatus(body);\n+                    break;\n+                case \"MultipleVirtualButtonDefinition\":\n+                    break;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "deb48c1252ee18917f2f9e19cf0158fedb164659"}, "originalPosition": 195}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY3MDgzNA==", "bodyText": "Please add @NonNullByDefault", "url": "https://github.com/openhab/openhab-addons/pull/8650#discussion_r500670834", "createdAt": "2020-10-07T00:32:50Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lutron/src/main/java/org/openhab/binding/lutron/internal/protocol/lip/TargetType.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lutron.internal.protocol.lip;\n+\n+/**\n+ * Target device type enum. Used to annotate LutronCommand objects so the LEAP bridge can translate them.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+public enum TargetType {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "deb48c1252ee18917f2f9e19cf0158fedb164659"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY5MjI0Mg==", "bodyText": "Since you aren't using any of the atomic functionality of this class, you should just replace it with a volatile boolean instead.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private final AtomicBoolean deviceDataLoaded = new AtomicBoolean(false);\n          \n          \n            \n                private volatile boolean deviceDataLoaded = false;", "url": "https://github.com/openhab/openhab-addons/pull/8650#discussion_r500692242", "createdAt": "2020-10-07T01:56:35Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lutron/src/main/java/org/openhab/binding/lutron/internal/handler/LeapBridgeHandler.java", "diffHunk": "@@ -0,0 +1,763 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lutron.internal.handler;\n+\n+import static org.openhab.binding.lutron.internal.LutronBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.net.UnknownHostException;\n+import java.security.KeyManagementException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.UnrecoverableKeyException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManager;\n+import javax.net.ssl.TrustManagerFactory;\n+import javax.net.ssl.X509TrustManager;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.lutron.internal.config.LeapBridgeConfig;\n+import org.openhab.binding.lutron.internal.discovery.LeapDeviceDiscoveryService;\n+import org.openhab.binding.lutron.internal.protocol.FanSpeedType;\n+import org.openhab.binding.lutron.internal.protocol.GroupCommand;\n+import org.openhab.binding.lutron.internal.protocol.LutronCommandNew;\n+import org.openhab.binding.lutron.internal.protocol.OutputCommand;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapCommand;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapMessageParser;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapMessageParserCallbacks;\n+import org.openhab.binding.lutron.internal.protocol.leap.Request;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Area;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ButtonGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Device;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.OccupancyGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ZoneStatus;\n+import org.openhab.binding.lutron.internal.protocol.lip.LutronCommandType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Bridge handler responsible for communicating with Lutron hubs that support the LEAP protocol, such as Caseta and\n+ * RA2 Select.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LeapBridgeHandler extends LutronBridgeHandler implements LeapMessageParserCallbacks {\n+    private static final int DEFAULT_RECONNECT_MINUTES = 5;\n+    private static final int DEFAULT_HEARTBEAT_MINUTES = 5;\n+    private static final long KEEPALIVE_TIMEOUT_SECONDS = 30;\n+\n+    private static final String STATUS_INITIALIZING = \"Initializing\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(LeapBridgeHandler.class);\n+\n+    private @NonNullByDefault({}) LeapBridgeConfig config;\n+    private int reconnectInterval;\n+    private int heartbeatInterval;\n+    private int sendDelay;\n+\n+    private @NonNullByDefault({}) SSLSocketFactory sslsocketfactory;\n+    private @Nullable SSLSocket sslsocket;\n+    private @Nullable BufferedWriter writer;\n+    private @Nullable BufferedReader reader;\n+\n+    private @NonNullByDefault({}) LeapMessageParser leapMessageParser;\n+\n+    private final BlockingQueue<LeapCommand> sendQueue = new LinkedBlockingQueue<>();\n+\n+    private @Nullable Thread senderThread;\n+    private @Nullable Thread readerThread;\n+\n+    private @Nullable ScheduledFuture<?> keepAlive;\n+    private @Nullable ScheduledFuture<?> keepAliveReconnect;\n+    private @Nullable ScheduledFuture<?> connectRetryJob;\n+    private final Object keepAliveReconnectLock = new Object();\n+\n+    private final Map<Integer, Integer> zoneToDevice = new HashMap<>();\n+    private final Map<Integer, Integer> deviceToZone = new HashMap<>();\n+    private final Object zoneMapsLock = new Object();\n+\n+    private @Nullable Map<Integer, List<Integer>> deviceButtonMap;\n+    private final Object deviceButtonMapLock = new Object();\n+\n+    private final AtomicBoolean deviceDataLoaded = new AtomicBoolean(false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "deb48c1252ee18917f2f9e19cf0158fedb164659"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY5MjMyNg==", "bodyText": "same here\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private final AtomicBoolean buttonDataLoaded = new AtomicBoolean(false);\n          \n          \n            \n                private volatile boolean buttonDataLoaded = false;", "url": "https://github.com/openhab/openhab-addons/pull/8650#discussion_r500692326", "createdAt": "2020-10-07T01:56:51Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lutron/src/main/java/org/openhab/binding/lutron/internal/handler/LeapBridgeHandler.java", "diffHunk": "@@ -0,0 +1,763 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lutron.internal.handler;\n+\n+import static org.openhab.binding.lutron.internal.LutronBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.net.UnknownHostException;\n+import java.security.KeyManagementException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.UnrecoverableKeyException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManager;\n+import javax.net.ssl.TrustManagerFactory;\n+import javax.net.ssl.X509TrustManager;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.lutron.internal.config.LeapBridgeConfig;\n+import org.openhab.binding.lutron.internal.discovery.LeapDeviceDiscoveryService;\n+import org.openhab.binding.lutron.internal.protocol.FanSpeedType;\n+import org.openhab.binding.lutron.internal.protocol.GroupCommand;\n+import org.openhab.binding.lutron.internal.protocol.LutronCommandNew;\n+import org.openhab.binding.lutron.internal.protocol.OutputCommand;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapCommand;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapMessageParser;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapMessageParserCallbacks;\n+import org.openhab.binding.lutron.internal.protocol.leap.Request;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Area;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ButtonGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Device;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.OccupancyGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ZoneStatus;\n+import org.openhab.binding.lutron.internal.protocol.lip.LutronCommandType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Bridge handler responsible for communicating with Lutron hubs that support the LEAP protocol, such as Caseta and\n+ * RA2 Select.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LeapBridgeHandler extends LutronBridgeHandler implements LeapMessageParserCallbacks {\n+    private static final int DEFAULT_RECONNECT_MINUTES = 5;\n+    private static final int DEFAULT_HEARTBEAT_MINUTES = 5;\n+    private static final long KEEPALIVE_TIMEOUT_SECONDS = 30;\n+\n+    private static final String STATUS_INITIALIZING = \"Initializing\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(LeapBridgeHandler.class);\n+\n+    private @NonNullByDefault({}) LeapBridgeConfig config;\n+    private int reconnectInterval;\n+    private int heartbeatInterval;\n+    private int sendDelay;\n+\n+    private @NonNullByDefault({}) SSLSocketFactory sslsocketfactory;\n+    private @Nullable SSLSocket sslsocket;\n+    private @Nullable BufferedWriter writer;\n+    private @Nullable BufferedReader reader;\n+\n+    private @NonNullByDefault({}) LeapMessageParser leapMessageParser;\n+\n+    private final BlockingQueue<LeapCommand> sendQueue = new LinkedBlockingQueue<>();\n+\n+    private @Nullable Thread senderThread;\n+    private @Nullable Thread readerThread;\n+\n+    private @Nullable ScheduledFuture<?> keepAlive;\n+    private @Nullable ScheduledFuture<?> keepAliveReconnect;\n+    private @Nullable ScheduledFuture<?> connectRetryJob;\n+    private final Object keepAliveReconnectLock = new Object();\n+\n+    private final Map<Integer, Integer> zoneToDevice = new HashMap<>();\n+    private final Map<Integer, Integer> deviceToZone = new HashMap<>();\n+    private final Object zoneMapsLock = new Object();\n+\n+    private @Nullable Map<Integer, List<Integer>> deviceButtonMap;\n+    private final Object deviceButtonMapLock = new Object();\n+\n+    private final AtomicBoolean deviceDataLoaded = new AtomicBoolean(false);\n+    private final AtomicBoolean buttonDataLoaded = new AtomicBoolean(false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "deb48c1252ee18917f2f9e19cf0158fedb164659"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY5NDE5OA==", "bodyText": "You should make another catch for a InterruptedIOException. You shouldn't attempt a reconnect if you received an interrupt.", "url": "https://github.com/openhab/openhab-addons/pull/8650#discussion_r500694198", "createdAt": "2020-10-07T02:03:08Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lutron/src/main/java/org/openhab/binding/lutron/internal/handler/LeapBridgeHandler.java", "diffHunk": "@@ -0,0 +1,763 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lutron.internal.handler;\n+\n+import static org.openhab.binding.lutron.internal.LutronBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.net.UnknownHostException;\n+import java.security.KeyManagementException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.UnrecoverableKeyException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManager;\n+import javax.net.ssl.TrustManagerFactory;\n+import javax.net.ssl.X509TrustManager;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.lutron.internal.config.LeapBridgeConfig;\n+import org.openhab.binding.lutron.internal.discovery.LeapDeviceDiscoveryService;\n+import org.openhab.binding.lutron.internal.protocol.FanSpeedType;\n+import org.openhab.binding.lutron.internal.protocol.GroupCommand;\n+import org.openhab.binding.lutron.internal.protocol.LutronCommandNew;\n+import org.openhab.binding.lutron.internal.protocol.OutputCommand;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapCommand;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapMessageParser;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapMessageParserCallbacks;\n+import org.openhab.binding.lutron.internal.protocol.leap.Request;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Area;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ButtonGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Device;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.OccupancyGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ZoneStatus;\n+import org.openhab.binding.lutron.internal.protocol.lip.LutronCommandType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Bridge handler responsible for communicating with Lutron hubs that support the LEAP protocol, such as Caseta and\n+ * RA2 Select.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LeapBridgeHandler extends LutronBridgeHandler implements LeapMessageParserCallbacks {\n+    private static final int DEFAULT_RECONNECT_MINUTES = 5;\n+    private static final int DEFAULT_HEARTBEAT_MINUTES = 5;\n+    private static final long KEEPALIVE_TIMEOUT_SECONDS = 30;\n+\n+    private static final String STATUS_INITIALIZING = \"Initializing\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(LeapBridgeHandler.class);\n+\n+    private @NonNullByDefault({}) LeapBridgeConfig config;\n+    private int reconnectInterval;\n+    private int heartbeatInterval;\n+    private int sendDelay;\n+\n+    private @NonNullByDefault({}) SSLSocketFactory sslsocketfactory;\n+    private @Nullable SSLSocket sslsocket;\n+    private @Nullable BufferedWriter writer;\n+    private @Nullable BufferedReader reader;\n+\n+    private @NonNullByDefault({}) LeapMessageParser leapMessageParser;\n+\n+    private final BlockingQueue<LeapCommand> sendQueue = new LinkedBlockingQueue<>();\n+\n+    private @Nullable Thread senderThread;\n+    private @Nullable Thread readerThread;\n+\n+    private @Nullable ScheduledFuture<?> keepAlive;\n+    private @Nullable ScheduledFuture<?> keepAliveReconnect;\n+    private @Nullable ScheduledFuture<?> connectRetryJob;\n+    private final Object keepAliveReconnectLock = new Object();\n+\n+    private final Map<Integer, Integer> zoneToDevice = new HashMap<>();\n+    private final Map<Integer, Integer> deviceToZone = new HashMap<>();\n+    private final Object zoneMapsLock = new Object();\n+\n+    private @Nullable Map<Integer, List<Integer>> deviceButtonMap;\n+    private final Object deviceButtonMapLock = new Object();\n+\n+    private final AtomicBoolean deviceDataLoaded = new AtomicBoolean(false);\n+    private final AtomicBoolean buttonDataLoaded = new AtomicBoolean(false);\n+\n+    private final Map<Integer, LutronHandler> childHandlerMap = new ConcurrentHashMap<>();\n+    private final Map<Integer, OGroupHandler> groupHandlerMap = new ConcurrentHashMap<>();\n+\n+    private @Nullable LeapDeviceDiscoveryService discoveryService;\n+\n+    public void setDiscoveryService(LeapDeviceDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    public LeapBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+        leapMessageParser = new LeapMessageParser(this);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        SSLContext sslContext;\n+\n+        childHandlerMap.clear();\n+        groupHandlerMap.clear();\n+\n+        config = getConfigAs(LeapBridgeConfig.class);\n+        String keystorePassword = (config.keystorePassword == null) ? \"\" : config.keystorePassword;\n+\n+        String ipAddress = config.ipAddress;\n+        if (ipAddress == null || ipAddress.isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"bridge address not specified\");\n+            return;\n+        }\n+\n+        reconnectInterval = (config.reconnect > 0) ? config.reconnect : DEFAULT_RECONNECT_MINUTES;\n+        heartbeatInterval = (config.heartbeat > 0) ? config.heartbeat : DEFAULT_HEARTBEAT_MINUTES;\n+        sendDelay = (config.delay < 0) ? 0 : config.delay;\n+\n+        if (config.keystore == null || keystorePassword == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Keystore/keystore password not configured\");\n+            return;\n+        } else {\n+            try (FileInputStream keystoreInputStream = new FileInputStream(config.keystore)) {\n+                logger.trace(\"Initializing keystore\");\n+                KeyStore keystore = KeyStore.getInstance(KeyStore.getDefaultType());\n+\n+                keystore.load(keystoreInputStream, keystorePassword.toCharArray());\n+\n+                logger.trace(\"Initializing SSL Context\");\n+                KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n+                kmf.init(keystore, keystorePassword.toCharArray());\n+\n+                TrustManager[] trustManagers;\n+                if (config.certValidate) {\n+                    // Use default trust manager which will attempt to validate server certificate from hub\n+                    TrustManagerFactory tmf = TrustManagerFactory\n+                            .getInstance(TrustManagerFactory.getDefaultAlgorithm());\n+                    tmf.init(keystore);\n+                    trustManagers = tmf.getTrustManagers();\n+                } else {\n+                    // Use no-op trust manager which will not verify certificates\n+                    trustManagers = defineNoOpTrustManager();\n+                }\n+\n+                sslContext = SSLContext.getInstance(\"TLS\");\n+                sslContext.init(kmf.getKeyManagers(), trustManagers, null);\n+\n+                sslsocketfactory = sslContext.getSocketFactory();\n+            } catch (FileNotFoundException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Keystore file not found\");\n+                return;\n+            } catch (CertificateException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Certificate exception\");\n+                return;\n+            } catch (UnrecoverableKeyException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"Key unrecoverable with supplied password\");\n+                return;\n+            } catch (KeyManagementException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Key management exception\");\n+                logger.debug(\"Key management exception\", e);\n+                return;\n+            } catch (KeyStoreException | NoSuchAlgorithmException | IOException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Error initializing keystore\");\n+                logger.debug(\"Error initializing keystore\", e);\n+                return;\n+            }\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Connecting\");\n+        scheduler.submit(this::connect); // start the async connect task\n+    }\n+\n+    /**\n+     * Return a no-op SSL trust manager which will not verify server or client certificates.\n+     */\n+    private TrustManager[] defineNoOpTrustManager() {\n+        return new TrustManager[] { new X509TrustManager() {\n+            @Override\n+            public void checkClientTrusted(final X509Certificate @Nullable [] chain, final @Nullable String authType) {\n+                logger.debug(\"Assuming client certificate is valid\");\n+                if (chain != null) {\n+                    for (int cert = 0; cert < chain.length; cert++) {\n+                        logger.trace(\"Subject DN: {}\", chain[cert].getSubjectDN());\n+                        logger.trace(\"Issuer DN: {}\", chain[cert].getIssuerDN());\n+                        logger.trace(\"Serial number {}:\", chain[cert].getSerialNumber());\n+                    }\n+                }\n+            }\n+\n+            @Override\n+            public void checkServerTrusted(final X509Certificate @Nullable [] chain, final @Nullable String authType) {\n+                logger.debug(\"Assuming server certificate is valid\");\n+                if (chain != null) {\n+                    for (int cert = 0; cert < chain.length; cert++) {\n+                        logger.trace(\"Subject DN: {}\", chain[cert].getSubjectDN());\n+                        logger.trace(\"Issuer DN: {}\", chain[cert].getIssuerDN());\n+                        logger.trace(\"Serial number: {}\", chain[cert].getSerialNumber());\n+                    }\n+                }\n+            }\n+\n+            @Override\n+            public X509Certificate @Nullable [] getAcceptedIssuers() {\n+                return null;\n+            }\n+        } };\n+    }\n+\n+    private synchronized void connect() {\n+        deviceDataLoaded.set(false);\n+        buttonDataLoaded.set(false);\n+\n+        try {\n+            logger.debug(\"Opening SSL connection to {}:{}\", config.ipAddress, config.port);\n+            SSLSocket sslsocket = (SSLSocket) sslsocketfactory.createSocket(config.ipAddress, config.port);\n+            sslsocket.startHandshake();\n+            writer = new BufferedWriter(new OutputStreamWriter(sslsocket.getOutputStream()));\n+            reader = new BufferedReader(new InputStreamReader(sslsocket.getInputStream()));\n+            this.sslsocket = sslsocket;\n+        } catch (UnknownHostException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Unknown host\");\n+            return;\n+        } catch (IllegalArgumentException e) {\n+            // port out of valid range\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Invalid port number\");\n+            return;\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Error opening SSL connection. Check log.\");\n+            logger.info(\"Error opening SSL connection: {}\", e.getMessage());\n+            disconnect();\n+            scheduleConnectRetry(reconnectInterval); // Possibly a temporary problem. Try again later.\n+            return;\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, STATUS_INITIALIZING);\n+\n+        Thread readerThread = new Thread(this::readerThreadJob, \"Lutron reader\");\n+        readerThread.setDaemon(true);\n+        readerThread.start();\n+        this.readerThread = readerThread;\n+\n+        Thread senderThread = new Thread(this::senderThreadJob, \"Lutron sender\");\n+        senderThread.setDaemon(true);\n+        senderThread.start();\n+        this.senderThread = senderThread;\n+\n+        sendCommand(new LeapCommand(Request.getButtonGroups()));\n+        queryDiscoveryData();\n+        sendCommand(new LeapCommand(Request.subscribeOccupancyGroupStatus()));\n+\n+        logger.debug(\"Starting keepAlive job with interval {}\", heartbeatInterval);\n+        keepAlive = scheduler.scheduleWithFixedDelay(this::sendKeepAlive, heartbeatInterval, heartbeatInterval,\n+                TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Called by connect() and discovery service to request fresh discovery data\n+     */\n+    public void queryDiscoveryData() {\n+        sendCommand(new LeapCommand(Request.getDevices()));\n+        sendCommand(new LeapCommand(Request.getAreas()));\n+        sendCommand(new LeapCommand(Request.getOccupancyGroups()));\n+    }\n+\n+    private void scheduleConnectRetry(long waitMinutes) {\n+        logger.debug(\"Scheduling connection retry in {} minutes\", waitMinutes);\n+        connectRetryJob = scheduler.schedule(this::connect, waitMinutes, TimeUnit.MINUTES);\n+    }\n+\n+    private synchronized void disconnect() {\n+        logger.debug(\"Disconnecting\");\n+\n+        Thread senderThread = this.senderThread;\n+        Thread readerThread = this.readerThread;\n+\n+        if (connectRetryJob != null) {\n+            connectRetryJob.cancel(true);\n+        }\n+        if (keepAlive != null) {\n+            keepAlive.cancel(true);\n+        }\n+\n+        // May be called from keepAliveReconnect thread, so call cancel with false\n+        reconnectTaskCancel(false);\n+\n+        if (senderThread != null && senderThread.isAlive()) {\n+            senderThread.interrupt();\n+        }\n+        if (readerThread != null && readerThread.isAlive()) {\n+            readerThread.interrupt();\n+        }\n+        if (sslsocket != null) {\n+            try {\n+                sslsocket.close();\n+            } catch (IOException e) {\n+                logger.debug(\"Error closing SSL socket: {}\", e.getMessage());\n+            }\n+            sslsocket = null;\n+        }\n+        if (reader != null) {\n+            try {\n+                reader.close();\n+            } catch (IOException e) {\n+                logger.debug(\"Error closing reader: {}\", e.getMessage());\n+            }\n+        }\n+        if (writer != null) {\n+            try {\n+                writer.close();\n+            } catch (IOException e) {\n+                logger.debug(\"Error closing writer: {}\", e.getMessage());\n+            }\n+        }\n+\n+        deviceDataLoaded.set(false);\n+        buttonDataLoaded.set(false);\n+    }\n+\n+    private synchronized void reconnect() {\n+        logger.debug(\"Attempting to reconnect to the bridge\");\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR, \"reconnecting\");\n+        disconnect();\n+        connect();\n+    }\n+\n+    /**\n+     * Method executed by the message sender thread (senderThread)\n+     */\n+    private void senderThreadJob() {\n+        logger.debug(\"Command sender thread started\");\n+        try {\n+            while (!Thread.currentThread().isInterrupted() && writer != null) {\n+                LeapCommand command = sendQueue.take();\n+                logger.trace(\"Sending command {}\", command);\n+\n+                try {\n+                    BufferedWriter writer = this.writer;\n+                    if (writer != null) {\n+                        writer.write(command.toString() + \"\\n\");\n+                        writer.flush();\n+                    }\n+                } catch (IOException e) {\n+                    logger.warn(\"Communication error, will try to reconnect. Error: {}\", e.getMessage());\n+                    updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR);\n+                    sendQueue.add(command); // Requeue command\n+                    reconnect();\n+                    break; // reconnect() will start a new thread; terminate this one\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "deb48c1252ee18917f2f9e19cf0158fedb164659"}, "originalPosition": 394}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY5NTY1Mw==", "bodyText": "In order to avoid the null checker warnings cache this.sslsocket to a local variable and perform your logic on that local variable instead.", "url": "https://github.com/openhab/openhab-addons/pull/8650#discussion_r500695653", "createdAt": "2020-10-07T02:08:07Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lutron/src/main/java/org/openhab/binding/lutron/internal/handler/LeapBridgeHandler.java", "diffHunk": "@@ -0,0 +1,763 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lutron.internal.handler;\n+\n+import static org.openhab.binding.lutron.internal.LutronBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.net.UnknownHostException;\n+import java.security.KeyManagementException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.UnrecoverableKeyException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManager;\n+import javax.net.ssl.TrustManagerFactory;\n+import javax.net.ssl.X509TrustManager;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.lutron.internal.config.LeapBridgeConfig;\n+import org.openhab.binding.lutron.internal.discovery.LeapDeviceDiscoveryService;\n+import org.openhab.binding.lutron.internal.protocol.FanSpeedType;\n+import org.openhab.binding.lutron.internal.protocol.GroupCommand;\n+import org.openhab.binding.lutron.internal.protocol.LutronCommandNew;\n+import org.openhab.binding.lutron.internal.protocol.OutputCommand;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapCommand;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapMessageParser;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapMessageParserCallbacks;\n+import org.openhab.binding.lutron.internal.protocol.leap.Request;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Area;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ButtonGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Device;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.OccupancyGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ZoneStatus;\n+import org.openhab.binding.lutron.internal.protocol.lip.LutronCommandType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Bridge handler responsible for communicating with Lutron hubs that support the LEAP protocol, such as Caseta and\n+ * RA2 Select.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LeapBridgeHandler extends LutronBridgeHandler implements LeapMessageParserCallbacks {\n+    private static final int DEFAULT_RECONNECT_MINUTES = 5;\n+    private static final int DEFAULT_HEARTBEAT_MINUTES = 5;\n+    private static final long KEEPALIVE_TIMEOUT_SECONDS = 30;\n+\n+    private static final String STATUS_INITIALIZING = \"Initializing\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(LeapBridgeHandler.class);\n+\n+    private @NonNullByDefault({}) LeapBridgeConfig config;\n+    private int reconnectInterval;\n+    private int heartbeatInterval;\n+    private int sendDelay;\n+\n+    private @NonNullByDefault({}) SSLSocketFactory sslsocketfactory;\n+    private @Nullable SSLSocket sslsocket;\n+    private @Nullable BufferedWriter writer;\n+    private @Nullable BufferedReader reader;\n+\n+    private @NonNullByDefault({}) LeapMessageParser leapMessageParser;\n+\n+    private final BlockingQueue<LeapCommand> sendQueue = new LinkedBlockingQueue<>();\n+\n+    private @Nullable Thread senderThread;\n+    private @Nullable Thread readerThread;\n+\n+    private @Nullable ScheduledFuture<?> keepAlive;\n+    private @Nullable ScheduledFuture<?> keepAliveReconnect;\n+    private @Nullable ScheduledFuture<?> connectRetryJob;\n+    private final Object keepAliveReconnectLock = new Object();\n+\n+    private final Map<Integer, Integer> zoneToDevice = new HashMap<>();\n+    private final Map<Integer, Integer> deviceToZone = new HashMap<>();\n+    private final Object zoneMapsLock = new Object();\n+\n+    private @Nullable Map<Integer, List<Integer>> deviceButtonMap;\n+    private final Object deviceButtonMapLock = new Object();\n+\n+    private final AtomicBoolean deviceDataLoaded = new AtomicBoolean(false);\n+    private final AtomicBoolean buttonDataLoaded = new AtomicBoolean(false);\n+\n+    private final Map<Integer, LutronHandler> childHandlerMap = new ConcurrentHashMap<>();\n+    private final Map<Integer, OGroupHandler> groupHandlerMap = new ConcurrentHashMap<>();\n+\n+    private @Nullable LeapDeviceDiscoveryService discoveryService;\n+\n+    public void setDiscoveryService(LeapDeviceDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    public LeapBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+        leapMessageParser = new LeapMessageParser(this);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        SSLContext sslContext;\n+\n+        childHandlerMap.clear();\n+        groupHandlerMap.clear();\n+\n+        config = getConfigAs(LeapBridgeConfig.class);\n+        String keystorePassword = (config.keystorePassword == null) ? \"\" : config.keystorePassword;\n+\n+        String ipAddress = config.ipAddress;\n+        if (ipAddress == null || ipAddress.isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"bridge address not specified\");\n+            return;\n+        }\n+\n+        reconnectInterval = (config.reconnect > 0) ? config.reconnect : DEFAULT_RECONNECT_MINUTES;\n+        heartbeatInterval = (config.heartbeat > 0) ? config.heartbeat : DEFAULT_HEARTBEAT_MINUTES;\n+        sendDelay = (config.delay < 0) ? 0 : config.delay;\n+\n+        if (config.keystore == null || keystorePassword == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Keystore/keystore password not configured\");\n+            return;\n+        } else {\n+            try (FileInputStream keystoreInputStream = new FileInputStream(config.keystore)) {\n+                logger.trace(\"Initializing keystore\");\n+                KeyStore keystore = KeyStore.getInstance(KeyStore.getDefaultType());\n+\n+                keystore.load(keystoreInputStream, keystorePassword.toCharArray());\n+\n+                logger.trace(\"Initializing SSL Context\");\n+                KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n+                kmf.init(keystore, keystorePassword.toCharArray());\n+\n+                TrustManager[] trustManagers;\n+                if (config.certValidate) {\n+                    // Use default trust manager which will attempt to validate server certificate from hub\n+                    TrustManagerFactory tmf = TrustManagerFactory\n+                            .getInstance(TrustManagerFactory.getDefaultAlgorithm());\n+                    tmf.init(keystore);\n+                    trustManagers = tmf.getTrustManagers();\n+                } else {\n+                    // Use no-op trust manager which will not verify certificates\n+                    trustManagers = defineNoOpTrustManager();\n+                }\n+\n+                sslContext = SSLContext.getInstance(\"TLS\");\n+                sslContext.init(kmf.getKeyManagers(), trustManagers, null);\n+\n+                sslsocketfactory = sslContext.getSocketFactory();\n+            } catch (FileNotFoundException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Keystore file not found\");\n+                return;\n+            } catch (CertificateException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Certificate exception\");\n+                return;\n+            } catch (UnrecoverableKeyException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"Key unrecoverable with supplied password\");\n+                return;\n+            } catch (KeyManagementException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Key management exception\");\n+                logger.debug(\"Key management exception\", e);\n+                return;\n+            } catch (KeyStoreException | NoSuchAlgorithmException | IOException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Error initializing keystore\");\n+                logger.debug(\"Error initializing keystore\", e);\n+                return;\n+            }\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Connecting\");\n+        scheduler.submit(this::connect); // start the async connect task\n+    }\n+\n+    /**\n+     * Return a no-op SSL trust manager which will not verify server or client certificates.\n+     */\n+    private TrustManager[] defineNoOpTrustManager() {\n+        return new TrustManager[] { new X509TrustManager() {\n+            @Override\n+            public void checkClientTrusted(final X509Certificate @Nullable [] chain, final @Nullable String authType) {\n+                logger.debug(\"Assuming client certificate is valid\");\n+                if (chain != null) {\n+                    for (int cert = 0; cert < chain.length; cert++) {\n+                        logger.trace(\"Subject DN: {}\", chain[cert].getSubjectDN());\n+                        logger.trace(\"Issuer DN: {}\", chain[cert].getIssuerDN());\n+                        logger.trace(\"Serial number {}:\", chain[cert].getSerialNumber());\n+                    }\n+                }\n+            }\n+\n+            @Override\n+            public void checkServerTrusted(final X509Certificate @Nullable [] chain, final @Nullable String authType) {\n+                logger.debug(\"Assuming server certificate is valid\");\n+                if (chain != null) {\n+                    for (int cert = 0; cert < chain.length; cert++) {\n+                        logger.trace(\"Subject DN: {}\", chain[cert].getSubjectDN());\n+                        logger.trace(\"Issuer DN: {}\", chain[cert].getIssuerDN());\n+                        logger.trace(\"Serial number: {}\", chain[cert].getSerialNumber());\n+                    }\n+                }\n+            }\n+\n+            @Override\n+            public X509Certificate @Nullable [] getAcceptedIssuers() {\n+                return null;\n+            }\n+        } };\n+    }\n+\n+    private synchronized void connect() {\n+        deviceDataLoaded.set(false);\n+        buttonDataLoaded.set(false);\n+\n+        try {\n+            logger.debug(\"Opening SSL connection to {}:{}\", config.ipAddress, config.port);\n+            SSLSocket sslsocket = (SSLSocket) sslsocketfactory.createSocket(config.ipAddress, config.port);\n+            sslsocket.startHandshake();\n+            writer = new BufferedWriter(new OutputStreamWriter(sslsocket.getOutputStream()));\n+            reader = new BufferedReader(new InputStreamReader(sslsocket.getInputStream()));\n+            this.sslsocket = sslsocket;\n+        } catch (UnknownHostException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Unknown host\");\n+            return;\n+        } catch (IllegalArgumentException e) {\n+            // port out of valid range\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Invalid port number\");\n+            return;\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Error opening SSL connection. Check log.\");\n+            logger.info(\"Error opening SSL connection: {}\", e.getMessage());\n+            disconnect();\n+            scheduleConnectRetry(reconnectInterval); // Possibly a temporary problem. Try again later.\n+            return;\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, STATUS_INITIALIZING);\n+\n+        Thread readerThread = new Thread(this::readerThreadJob, \"Lutron reader\");\n+        readerThread.setDaemon(true);\n+        readerThread.start();\n+        this.readerThread = readerThread;\n+\n+        Thread senderThread = new Thread(this::senderThreadJob, \"Lutron sender\");\n+        senderThread.setDaemon(true);\n+        senderThread.start();\n+        this.senderThread = senderThread;\n+\n+        sendCommand(new LeapCommand(Request.getButtonGroups()));\n+        queryDiscoveryData();\n+        sendCommand(new LeapCommand(Request.subscribeOccupancyGroupStatus()));\n+\n+        logger.debug(\"Starting keepAlive job with interval {}\", heartbeatInterval);\n+        keepAlive = scheduler.scheduleWithFixedDelay(this::sendKeepAlive, heartbeatInterval, heartbeatInterval,\n+                TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Called by connect() and discovery service to request fresh discovery data\n+     */\n+    public void queryDiscoveryData() {\n+        sendCommand(new LeapCommand(Request.getDevices()));\n+        sendCommand(new LeapCommand(Request.getAreas()));\n+        sendCommand(new LeapCommand(Request.getOccupancyGroups()));\n+    }\n+\n+    private void scheduleConnectRetry(long waitMinutes) {\n+        logger.debug(\"Scheduling connection retry in {} minutes\", waitMinutes);\n+        connectRetryJob = scheduler.schedule(this::connect, waitMinutes, TimeUnit.MINUTES);\n+    }\n+\n+    private synchronized void disconnect() {\n+        logger.debug(\"Disconnecting\");\n+\n+        Thread senderThread = this.senderThread;\n+        Thread readerThread = this.readerThread;\n+\n+        if (connectRetryJob != null) {\n+            connectRetryJob.cancel(true);\n+        }\n+        if (keepAlive != null) {\n+            keepAlive.cancel(true);\n+        }\n+\n+        // May be called from keepAliveReconnect thread, so call cancel with false\n+        reconnectTaskCancel(false);\n+\n+        if (senderThread != null && senderThread.isAlive()) {\n+            senderThread.interrupt();\n+        }\n+        if (readerThread != null && readerThread.isAlive()) {\n+            readerThread.interrupt();\n+        }\n+        if (sslsocket != null) {\n+            try {\n+                sslsocket.close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "deb48c1252ee18917f2f9e19cf0158fedb164659"}, "originalPosition": 340}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY5NTcwMg==", "bodyText": "same here", "url": "https://github.com/openhab/openhab-addons/pull/8650#discussion_r500695702", "createdAt": "2020-10-07T02:08:18Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lutron/src/main/java/org/openhab/binding/lutron/internal/handler/LeapBridgeHandler.java", "diffHunk": "@@ -0,0 +1,763 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lutron.internal.handler;\n+\n+import static org.openhab.binding.lutron.internal.LutronBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.net.UnknownHostException;\n+import java.security.KeyManagementException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.UnrecoverableKeyException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManager;\n+import javax.net.ssl.TrustManagerFactory;\n+import javax.net.ssl.X509TrustManager;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.lutron.internal.config.LeapBridgeConfig;\n+import org.openhab.binding.lutron.internal.discovery.LeapDeviceDiscoveryService;\n+import org.openhab.binding.lutron.internal.protocol.FanSpeedType;\n+import org.openhab.binding.lutron.internal.protocol.GroupCommand;\n+import org.openhab.binding.lutron.internal.protocol.LutronCommandNew;\n+import org.openhab.binding.lutron.internal.protocol.OutputCommand;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapCommand;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapMessageParser;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapMessageParserCallbacks;\n+import org.openhab.binding.lutron.internal.protocol.leap.Request;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Area;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ButtonGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Device;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.OccupancyGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ZoneStatus;\n+import org.openhab.binding.lutron.internal.protocol.lip.LutronCommandType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Bridge handler responsible for communicating with Lutron hubs that support the LEAP protocol, such as Caseta and\n+ * RA2 Select.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LeapBridgeHandler extends LutronBridgeHandler implements LeapMessageParserCallbacks {\n+    private static final int DEFAULT_RECONNECT_MINUTES = 5;\n+    private static final int DEFAULT_HEARTBEAT_MINUTES = 5;\n+    private static final long KEEPALIVE_TIMEOUT_SECONDS = 30;\n+\n+    private static final String STATUS_INITIALIZING = \"Initializing\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(LeapBridgeHandler.class);\n+\n+    private @NonNullByDefault({}) LeapBridgeConfig config;\n+    private int reconnectInterval;\n+    private int heartbeatInterval;\n+    private int sendDelay;\n+\n+    private @NonNullByDefault({}) SSLSocketFactory sslsocketfactory;\n+    private @Nullable SSLSocket sslsocket;\n+    private @Nullable BufferedWriter writer;\n+    private @Nullable BufferedReader reader;\n+\n+    private @NonNullByDefault({}) LeapMessageParser leapMessageParser;\n+\n+    private final BlockingQueue<LeapCommand> sendQueue = new LinkedBlockingQueue<>();\n+\n+    private @Nullable Thread senderThread;\n+    private @Nullable Thread readerThread;\n+\n+    private @Nullable ScheduledFuture<?> keepAlive;\n+    private @Nullable ScheduledFuture<?> keepAliveReconnect;\n+    private @Nullable ScheduledFuture<?> connectRetryJob;\n+    private final Object keepAliveReconnectLock = new Object();\n+\n+    private final Map<Integer, Integer> zoneToDevice = new HashMap<>();\n+    private final Map<Integer, Integer> deviceToZone = new HashMap<>();\n+    private final Object zoneMapsLock = new Object();\n+\n+    private @Nullable Map<Integer, List<Integer>> deviceButtonMap;\n+    private final Object deviceButtonMapLock = new Object();\n+\n+    private final AtomicBoolean deviceDataLoaded = new AtomicBoolean(false);\n+    private final AtomicBoolean buttonDataLoaded = new AtomicBoolean(false);\n+\n+    private final Map<Integer, LutronHandler> childHandlerMap = new ConcurrentHashMap<>();\n+    private final Map<Integer, OGroupHandler> groupHandlerMap = new ConcurrentHashMap<>();\n+\n+    private @Nullable LeapDeviceDiscoveryService discoveryService;\n+\n+    public void setDiscoveryService(LeapDeviceDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    public LeapBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+        leapMessageParser = new LeapMessageParser(this);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        SSLContext sslContext;\n+\n+        childHandlerMap.clear();\n+        groupHandlerMap.clear();\n+\n+        config = getConfigAs(LeapBridgeConfig.class);\n+        String keystorePassword = (config.keystorePassword == null) ? \"\" : config.keystorePassword;\n+\n+        String ipAddress = config.ipAddress;\n+        if (ipAddress == null || ipAddress.isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"bridge address not specified\");\n+            return;\n+        }\n+\n+        reconnectInterval = (config.reconnect > 0) ? config.reconnect : DEFAULT_RECONNECT_MINUTES;\n+        heartbeatInterval = (config.heartbeat > 0) ? config.heartbeat : DEFAULT_HEARTBEAT_MINUTES;\n+        sendDelay = (config.delay < 0) ? 0 : config.delay;\n+\n+        if (config.keystore == null || keystorePassword == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Keystore/keystore password not configured\");\n+            return;\n+        } else {\n+            try (FileInputStream keystoreInputStream = new FileInputStream(config.keystore)) {\n+                logger.trace(\"Initializing keystore\");\n+                KeyStore keystore = KeyStore.getInstance(KeyStore.getDefaultType());\n+\n+                keystore.load(keystoreInputStream, keystorePassword.toCharArray());\n+\n+                logger.trace(\"Initializing SSL Context\");\n+                KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n+                kmf.init(keystore, keystorePassword.toCharArray());\n+\n+                TrustManager[] trustManagers;\n+                if (config.certValidate) {\n+                    // Use default trust manager which will attempt to validate server certificate from hub\n+                    TrustManagerFactory tmf = TrustManagerFactory\n+                            .getInstance(TrustManagerFactory.getDefaultAlgorithm());\n+                    tmf.init(keystore);\n+                    trustManagers = tmf.getTrustManagers();\n+                } else {\n+                    // Use no-op trust manager which will not verify certificates\n+                    trustManagers = defineNoOpTrustManager();\n+                }\n+\n+                sslContext = SSLContext.getInstance(\"TLS\");\n+                sslContext.init(kmf.getKeyManagers(), trustManagers, null);\n+\n+                sslsocketfactory = sslContext.getSocketFactory();\n+            } catch (FileNotFoundException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Keystore file not found\");\n+                return;\n+            } catch (CertificateException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Certificate exception\");\n+                return;\n+            } catch (UnrecoverableKeyException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"Key unrecoverable with supplied password\");\n+                return;\n+            } catch (KeyManagementException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Key management exception\");\n+                logger.debug(\"Key management exception\", e);\n+                return;\n+            } catch (KeyStoreException | NoSuchAlgorithmException | IOException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Error initializing keystore\");\n+                logger.debug(\"Error initializing keystore\", e);\n+                return;\n+            }\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Connecting\");\n+        scheduler.submit(this::connect); // start the async connect task\n+    }\n+\n+    /**\n+     * Return a no-op SSL trust manager which will not verify server or client certificates.\n+     */\n+    private TrustManager[] defineNoOpTrustManager() {\n+        return new TrustManager[] { new X509TrustManager() {\n+            @Override\n+            public void checkClientTrusted(final X509Certificate @Nullable [] chain, final @Nullable String authType) {\n+                logger.debug(\"Assuming client certificate is valid\");\n+                if (chain != null) {\n+                    for (int cert = 0; cert < chain.length; cert++) {\n+                        logger.trace(\"Subject DN: {}\", chain[cert].getSubjectDN());\n+                        logger.trace(\"Issuer DN: {}\", chain[cert].getIssuerDN());\n+                        logger.trace(\"Serial number {}:\", chain[cert].getSerialNumber());\n+                    }\n+                }\n+            }\n+\n+            @Override\n+            public void checkServerTrusted(final X509Certificate @Nullable [] chain, final @Nullable String authType) {\n+                logger.debug(\"Assuming server certificate is valid\");\n+                if (chain != null) {\n+                    for (int cert = 0; cert < chain.length; cert++) {\n+                        logger.trace(\"Subject DN: {}\", chain[cert].getSubjectDN());\n+                        logger.trace(\"Issuer DN: {}\", chain[cert].getIssuerDN());\n+                        logger.trace(\"Serial number: {}\", chain[cert].getSerialNumber());\n+                    }\n+                }\n+            }\n+\n+            @Override\n+            public X509Certificate @Nullable [] getAcceptedIssuers() {\n+                return null;\n+            }\n+        } };\n+    }\n+\n+    private synchronized void connect() {\n+        deviceDataLoaded.set(false);\n+        buttonDataLoaded.set(false);\n+\n+        try {\n+            logger.debug(\"Opening SSL connection to {}:{}\", config.ipAddress, config.port);\n+            SSLSocket sslsocket = (SSLSocket) sslsocketfactory.createSocket(config.ipAddress, config.port);\n+            sslsocket.startHandshake();\n+            writer = new BufferedWriter(new OutputStreamWriter(sslsocket.getOutputStream()));\n+            reader = new BufferedReader(new InputStreamReader(sslsocket.getInputStream()));\n+            this.sslsocket = sslsocket;\n+        } catch (UnknownHostException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Unknown host\");\n+            return;\n+        } catch (IllegalArgumentException e) {\n+            // port out of valid range\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Invalid port number\");\n+            return;\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Error opening SSL connection. Check log.\");\n+            logger.info(\"Error opening SSL connection: {}\", e.getMessage());\n+            disconnect();\n+            scheduleConnectRetry(reconnectInterval); // Possibly a temporary problem. Try again later.\n+            return;\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, STATUS_INITIALIZING);\n+\n+        Thread readerThread = new Thread(this::readerThreadJob, \"Lutron reader\");\n+        readerThread.setDaemon(true);\n+        readerThread.start();\n+        this.readerThread = readerThread;\n+\n+        Thread senderThread = new Thread(this::senderThreadJob, \"Lutron sender\");\n+        senderThread.setDaemon(true);\n+        senderThread.start();\n+        this.senderThread = senderThread;\n+\n+        sendCommand(new LeapCommand(Request.getButtonGroups()));\n+        queryDiscoveryData();\n+        sendCommand(new LeapCommand(Request.subscribeOccupancyGroupStatus()));\n+\n+        logger.debug(\"Starting keepAlive job with interval {}\", heartbeatInterval);\n+        keepAlive = scheduler.scheduleWithFixedDelay(this::sendKeepAlive, heartbeatInterval, heartbeatInterval,\n+                TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Called by connect() and discovery service to request fresh discovery data\n+     */\n+    public void queryDiscoveryData() {\n+        sendCommand(new LeapCommand(Request.getDevices()));\n+        sendCommand(new LeapCommand(Request.getAreas()));\n+        sendCommand(new LeapCommand(Request.getOccupancyGroups()));\n+    }\n+\n+    private void scheduleConnectRetry(long waitMinutes) {\n+        logger.debug(\"Scheduling connection retry in {} minutes\", waitMinutes);\n+        connectRetryJob = scheduler.schedule(this::connect, waitMinutes, TimeUnit.MINUTES);\n+    }\n+\n+    private synchronized void disconnect() {\n+        logger.debug(\"Disconnecting\");\n+\n+        Thread senderThread = this.senderThread;\n+        Thread readerThread = this.readerThread;\n+\n+        if (connectRetryJob != null) {\n+            connectRetryJob.cancel(true);\n+        }\n+        if (keepAlive != null) {\n+            keepAlive.cancel(true);\n+        }\n+\n+        // May be called from keepAliveReconnect thread, so call cancel with false\n+        reconnectTaskCancel(false);\n+\n+        if (senderThread != null && senderThread.isAlive()) {\n+            senderThread.interrupt();\n+        }\n+        if (readerThread != null && readerThread.isAlive()) {\n+            readerThread.interrupt();\n+        }\n+        if (sslsocket != null) {\n+            try {\n+                sslsocket.close();\n+            } catch (IOException e) {\n+                logger.debug(\"Error closing SSL socket: {}\", e.getMessage());\n+            }\n+            sslsocket = null;\n+        }\n+        if (reader != null) {\n+            try {\n+                reader.close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "deb48c1252ee18917f2f9e19cf0158fedb164659"}, "originalPosition": 348}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY5NTczOA==", "bodyText": "and here", "url": "https://github.com/openhab/openhab-addons/pull/8650#discussion_r500695738", "createdAt": "2020-10-07T02:08:24Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lutron/src/main/java/org/openhab/binding/lutron/internal/handler/LeapBridgeHandler.java", "diffHunk": "@@ -0,0 +1,763 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lutron.internal.handler;\n+\n+import static org.openhab.binding.lutron.internal.LutronBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.net.UnknownHostException;\n+import java.security.KeyManagementException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.UnrecoverableKeyException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManager;\n+import javax.net.ssl.TrustManagerFactory;\n+import javax.net.ssl.X509TrustManager;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.lutron.internal.config.LeapBridgeConfig;\n+import org.openhab.binding.lutron.internal.discovery.LeapDeviceDiscoveryService;\n+import org.openhab.binding.lutron.internal.protocol.FanSpeedType;\n+import org.openhab.binding.lutron.internal.protocol.GroupCommand;\n+import org.openhab.binding.lutron.internal.protocol.LutronCommandNew;\n+import org.openhab.binding.lutron.internal.protocol.OutputCommand;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapCommand;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapMessageParser;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapMessageParserCallbacks;\n+import org.openhab.binding.lutron.internal.protocol.leap.Request;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Area;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ButtonGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Device;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.OccupancyGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ZoneStatus;\n+import org.openhab.binding.lutron.internal.protocol.lip.LutronCommandType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Bridge handler responsible for communicating with Lutron hubs that support the LEAP protocol, such as Caseta and\n+ * RA2 Select.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LeapBridgeHandler extends LutronBridgeHandler implements LeapMessageParserCallbacks {\n+    private static final int DEFAULT_RECONNECT_MINUTES = 5;\n+    private static final int DEFAULT_HEARTBEAT_MINUTES = 5;\n+    private static final long KEEPALIVE_TIMEOUT_SECONDS = 30;\n+\n+    private static final String STATUS_INITIALIZING = \"Initializing\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(LeapBridgeHandler.class);\n+\n+    private @NonNullByDefault({}) LeapBridgeConfig config;\n+    private int reconnectInterval;\n+    private int heartbeatInterval;\n+    private int sendDelay;\n+\n+    private @NonNullByDefault({}) SSLSocketFactory sslsocketfactory;\n+    private @Nullable SSLSocket sslsocket;\n+    private @Nullable BufferedWriter writer;\n+    private @Nullable BufferedReader reader;\n+\n+    private @NonNullByDefault({}) LeapMessageParser leapMessageParser;\n+\n+    private final BlockingQueue<LeapCommand> sendQueue = new LinkedBlockingQueue<>();\n+\n+    private @Nullable Thread senderThread;\n+    private @Nullable Thread readerThread;\n+\n+    private @Nullable ScheduledFuture<?> keepAlive;\n+    private @Nullable ScheduledFuture<?> keepAliveReconnect;\n+    private @Nullable ScheduledFuture<?> connectRetryJob;\n+    private final Object keepAliveReconnectLock = new Object();\n+\n+    private final Map<Integer, Integer> zoneToDevice = new HashMap<>();\n+    private final Map<Integer, Integer> deviceToZone = new HashMap<>();\n+    private final Object zoneMapsLock = new Object();\n+\n+    private @Nullable Map<Integer, List<Integer>> deviceButtonMap;\n+    private final Object deviceButtonMapLock = new Object();\n+\n+    private final AtomicBoolean deviceDataLoaded = new AtomicBoolean(false);\n+    private final AtomicBoolean buttonDataLoaded = new AtomicBoolean(false);\n+\n+    private final Map<Integer, LutronHandler> childHandlerMap = new ConcurrentHashMap<>();\n+    private final Map<Integer, OGroupHandler> groupHandlerMap = new ConcurrentHashMap<>();\n+\n+    private @Nullable LeapDeviceDiscoveryService discoveryService;\n+\n+    public void setDiscoveryService(LeapDeviceDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    public LeapBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+        leapMessageParser = new LeapMessageParser(this);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        SSLContext sslContext;\n+\n+        childHandlerMap.clear();\n+        groupHandlerMap.clear();\n+\n+        config = getConfigAs(LeapBridgeConfig.class);\n+        String keystorePassword = (config.keystorePassword == null) ? \"\" : config.keystorePassword;\n+\n+        String ipAddress = config.ipAddress;\n+        if (ipAddress == null || ipAddress.isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"bridge address not specified\");\n+            return;\n+        }\n+\n+        reconnectInterval = (config.reconnect > 0) ? config.reconnect : DEFAULT_RECONNECT_MINUTES;\n+        heartbeatInterval = (config.heartbeat > 0) ? config.heartbeat : DEFAULT_HEARTBEAT_MINUTES;\n+        sendDelay = (config.delay < 0) ? 0 : config.delay;\n+\n+        if (config.keystore == null || keystorePassword == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Keystore/keystore password not configured\");\n+            return;\n+        } else {\n+            try (FileInputStream keystoreInputStream = new FileInputStream(config.keystore)) {\n+                logger.trace(\"Initializing keystore\");\n+                KeyStore keystore = KeyStore.getInstance(KeyStore.getDefaultType());\n+\n+                keystore.load(keystoreInputStream, keystorePassword.toCharArray());\n+\n+                logger.trace(\"Initializing SSL Context\");\n+                KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n+                kmf.init(keystore, keystorePassword.toCharArray());\n+\n+                TrustManager[] trustManagers;\n+                if (config.certValidate) {\n+                    // Use default trust manager which will attempt to validate server certificate from hub\n+                    TrustManagerFactory tmf = TrustManagerFactory\n+                            .getInstance(TrustManagerFactory.getDefaultAlgorithm());\n+                    tmf.init(keystore);\n+                    trustManagers = tmf.getTrustManagers();\n+                } else {\n+                    // Use no-op trust manager which will not verify certificates\n+                    trustManagers = defineNoOpTrustManager();\n+                }\n+\n+                sslContext = SSLContext.getInstance(\"TLS\");\n+                sslContext.init(kmf.getKeyManagers(), trustManagers, null);\n+\n+                sslsocketfactory = sslContext.getSocketFactory();\n+            } catch (FileNotFoundException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Keystore file not found\");\n+                return;\n+            } catch (CertificateException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Certificate exception\");\n+                return;\n+            } catch (UnrecoverableKeyException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"Key unrecoverable with supplied password\");\n+                return;\n+            } catch (KeyManagementException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Key management exception\");\n+                logger.debug(\"Key management exception\", e);\n+                return;\n+            } catch (KeyStoreException | NoSuchAlgorithmException | IOException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Error initializing keystore\");\n+                logger.debug(\"Error initializing keystore\", e);\n+                return;\n+            }\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Connecting\");\n+        scheduler.submit(this::connect); // start the async connect task\n+    }\n+\n+    /**\n+     * Return a no-op SSL trust manager which will not verify server or client certificates.\n+     */\n+    private TrustManager[] defineNoOpTrustManager() {\n+        return new TrustManager[] { new X509TrustManager() {\n+            @Override\n+            public void checkClientTrusted(final X509Certificate @Nullable [] chain, final @Nullable String authType) {\n+                logger.debug(\"Assuming client certificate is valid\");\n+                if (chain != null) {\n+                    for (int cert = 0; cert < chain.length; cert++) {\n+                        logger.trace(\"Subject DN: {}\", chain[cert].getSubjectDN());\n+                        logger.trace(\"Issuer DN: {}\", chain[cert].getIssuerDN());\n+                        logger.trace(\"Serial number {}:\", chain[cert].getSerialNumber());\n+                    }\n+                }\n+            }\n+\n+            @Override\n+            public void checkServerTrusted(final X509Certificate @Nullable [] chain, final @Nullable String authType) {\n+                logger.debug(\"Assuming server certificate is valid\");\n+                if (chain != null) {\n+                    for (int cert = 0; cert < chain.length; cert++) {\n+                        logger.trace(\"Subject DN: {}\", chain[cert].getSubjectDN());\n+                        logger.trace(\"Issuer DN: {}\", chain[cert].getIssuerDN());\n+                        logger.trace(\"Serial number: {}\", chain[cert].getSerialNumber());\n+                    }\n+                }\n+            }\n+\n+            @Override\n+            public X509Certificate @Nullable [] getAcceptedIssuers() {\n+                return null;\n+            }\n+        } };\n+    }\n+\n+    private synchronized void connect() {\n+        deviceDataLoaded.set(false);\n+        buttonDataLoaded.set(false);\n+\n+        try {\n+            logger.debug(\"Opening SSL connection to {}:{}\", config.ipAddress, config.port);\n+            SSLSocket sslsocket = (SSLSocket) sslsocketfactory.createSocket(config.ipAddress, config.port);\n+            sslsocket.startHandshake();\n+            writer = new BufferedWriter(new OutputStreamWriter(sslsocket.getOutputStream()));\n+            reader = new BufferedReader(new InputStreamReader(sslsocket.getInputStream()));\n+            this.sslsocket = sslsocket;\n+        } catch (UnknownHostException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Unknown host\");\n+            return;\n+        } catch (IllegalArgumentException e) {\n+            // port out of valid range\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Invalid port number\");\n+            return;\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Error opening SSL connection. Check log.\");\n+            logger.info(\"Error opening SSL connection: {}\", e.getMessage());\n+            disconnect();\n+            scheduleConnectRetry(reconnectInterval); // Possibly a temporary problem. Try again later.\n+            return;\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, STATUS_INITIALIZING);\n+\n+        Thread readerThread = new Thread(this::readerThreadJob, \"Lutron reader\");\n+        readerThread.setDaemon(true);\n+        readerThread.start();\n+        this.readerThread = readerThread;\n+\n+        Thread senderThread = new Thread(this::senderThreadJob, \"Lutron sender\");\n+        senderThread.setDaemon(true);\n+        senderThread.start();\n+        this.senderThread = senderThread;\n+\n+        sendCommand(new LeapCommand(Request.getButtonGroups()));\n+        queryDiscoveryData();\n+        sendCommand(new LeapCommand(Request.subscribeOccupancyGroupStatus()));\n+\n+        logger.debug(\"Starting keepAlive job with interval {}\", heartbeatInterval);\n+        keepAlive = scheduler.scheduleWithFixedDelay(this::sendKeepAlive, heartbeatInterval, heartbeatInterval,\n+                TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Called by connect() and discovery service to request fresh discovery data\n+     */\n+    public void queryDiscoveryData() {\n+        sendCommand(new LeapCommand(Request.getDevices()));\n+        sendCommand(new LeapCommand(Request.getAreas()));\n+        sendCommand(new LeapCommand(Request.getOccupancyGroups()));\n+    }\n+\n+    private void scheduleConnectRetry(long waitMinutes) {\n+        logger.debug(\"Scheduling connection retry in {} minutes\", waitMinutes);\n+        connectRetryJob = scheduler.schedule(this::connect, waitMinutes, TimeUnit.MINUTES);\n+    }\n+\n+    private synchronized void disconnect() {\n+        logger.debug(\"Disconnecting\");\n+\n+        Thread senderThread = this.senderThread;\n+        Thread readerThread = this.readerThread;\n+\n+        if (connectRetryJob != null) {\n+            connectRetryJob.cancel(true);\n+        }\n+        if (keepAlive != null) {\n+            keepAlive.cancel(true);\n+        }\n+\n+        // May be called from keepAliveReconnect thread, so call cancel with false\n+        reconnectTaskCancel(false);\n+\n+        if (senderThread != null && senderThread.isAlive()) {\n+            senderThread.interrupt();\n+        }\n+        if (readerThread != null && readerThread.isAlive()) {\n+            readerThread.interrupt();\n+        }\n+        if (sslsocket != null) {\n+            try {\n+                sslsocket.close();\n+            } catch (IOException e) {\n+                logger.debug(\"Error closing SSL socket: {}\", e.getMessage());\n+            }\n+            sslsocket = null;\n+        }\n+        if (reader != null) {\n+            try {\n+                reader.close();\n+            } catch (IOException e) {\n+                logger.debug(\"Error closing reader: {}\", e.getMessage());\n+            }\n+        }\n+        if (writer != null) {\n+            try {\n+                writer.close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "deb48c1252ee18917f2f9e19cf0158fedb164659"}, "originalPosition": 355}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY5NTkxNA==", "bodyText": "cache these in a local variable as well.", "url": "https://github.com/openhab/openhab-addons/pull/8650#discussion_r500695914", "createdAt": "2020-10-07T02:09:04Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lutron/src/main/java/org/openhab/binding/lutron/internal/handler/LeapBridgeHandler.java", "diffHunk": "@@ -0,0 +1,763 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lutron.internal.handler;\n+\n+import static org.openhab.binding.lutron.internal.LutronBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.net.UnknownHostException;\n+import java.security.KeyManagementException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.UnrecoverableKeyException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManager;\n+import javax.net.ssl.TrustManagerFactory;\n+import javax.net.ssl.X509TrustManager;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.lutron.internal.config.LeapBridgeConfig;\n+import org.openhab.binding.lutron.internal.discovery.LeapDeviceDiscoveryService;\n+import org.openhab.binding.lutron.internal.protocol.FanSpeedType;\n+import org.openhab.binding.lutron.internal.protocol.GroupCommand;\n+import org.openhab.binding.lutron.internal.protocol.LutronCommandNew;\n+import org.openhab.binding.lutron.internal.protocol.OutputCommand;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapCommand;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapMessageParser;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapMessageParserCallbacks;\n+import org.openhab.binding.lutron.internal.protocol.leap.Request;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Area;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ButtonGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Device;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.OccupancyGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ZoneStatus;\n+import org.openhab.binding.lutron.internal.protocol.lip.LutronCommandType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Bridge handler responsible for communicating with Lutron hubs that support the LEAP protocol, such as Caseta and\n+ * RA2 Select.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LeapBridgeHandler extends LutronBridgeHandler implements LeapMessageParserCallbacks {\n+    private static final int DEFAULT_RECONNECT_MINUTES = 5;\n+    private static final int DEFAULT_HEARTBEAT_MINUTES = 5;\n+    private static final long KEEPALIVE_TIMEOUT_SECONDS = 30;\n+\n+    private static final String STATUS_INITIALIZING = \"Initializing\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(LeapBridgeHandler.class);\n+\n+    private @NonNullByDefault({}) LeapBridgeConfig config;\n+    private int reconnectInterval;\n+    private int heartbeatInterval;\n+    private int sendDelay;\n+\n+    private @NonNullByDefault({}) SSLSocketFactory sslsocketfactory;\n+    private @Nullable SSLSocket sslsocket;\n+    private @Nullable BufferedWriter writer;\n+    private @Nullable BufferedReader reader;\n+\n+    private @NonNullByDefault({}) LeapMessageParser leapMessageParser;\n+\n+    private final BlockingQueue<LeapCommand> sendQueue = new LinkedBlockingQueue<>();\n+\n+    private @Nullable Thread senderThread;\n+    private @Nullable Thread readerThread;\n+\n+    private @Nullable ScheduledFuture<?> keepAlive;\n+    private @Nullable ScheduledFuture<?> keepAliveReconnect;\n+    private @Nullable ScheduledFuture<?> connectRetryJob;\n+    private final Object keepAliveReconnectLock = new Object();\n+\n+    private final Map<Integer, Integer> zoneToDevice = new HashMap<>();\n+    private final Map<Integer, Integer> deviceToZone = new HashMap<>();\n+    private final Object zoneMapsLock = new Object();\n+\n+    private @Nullable Map<Integer, List<Integer>> deviceButtonMap;\n+    private final Object deviceButtonMapLock = new Object();\n+\n+    private final AtomicBoolean deviceDataLoaded = new AtomicBoolean(false);\n+    private final AtomicBoolean buttonDataLoaded = new AtomicBoolean(false);\n+\n+    private final Map<Integer, LutronHandler> childHandlerMap = new ConcurrentHashMap<>();\n+    private final Map<Integer, OGroupHandler> groupHandlerMap = new ConcurrentHashMap<>();\n+\n+    private @Nullable LeapDeviceDiscoveryService discoveryService;\n+\n+    public void setDiscoveryService(LeapDeviceDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    public LeapBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+        leapMessageParser = new LeapMessageParser(this);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        SSLContext sslContext;\n+\n+        childHandlerMap.clear();\n+        groupHandlerMap.clear();\n+\n+        config = getConfigAs(LeapBridgeConfig.class);\n+        String keystorePassword = (config.keystorePassword == null) ? \"\" : config.keystorePassword;\n+\n+        String ipAddress = config.ipAddress;\n+        if (ipAddress == null || ipAddress.isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"bridge address not specified\");\n+            return;\n+        }\n+\n+        reconnectInterval = (config.reconnect > 0) ? config.reconnect : DEFAULT_RECONNECT_MINUTES;\n+        heartbeatInterval = (config.heartbeat > 0) ? config.heartbeat : DEFAULT_HEARTBEAT_MINUTES;\n+        sendDelay = (config.delay < 0) ? 0 : config.delay;\n+\n+        if (config.keystore == null || keystorePassword == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Keystore/keystore password not configured\");\n+            return;\n+        } else {\n+            try (FileInputStream keystoreInputStream = new FileInputStream(config.keystore)) {\n+                logger.trace(\"Initializing keystore\");\n+                KeyStore keystore = KeyStore.getInstance(KeyStore.getDefaultType());\n+\n+                keystore.load(keystoreInputStream, keystorePassword.toCharArray());\n+\n+                logger.trace(\"Initializing SSL Context\");\n+                KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n+                kmf.init(keystore, keystorePassword.toCharArray());\n+\n+                TrustManager[] trustManagers;\n+                if (config.certValidate) {\n+                    // Use default trust manager which will attempt to validate server certificate from hub\n+                    TrustManagerFactory tmf = TrustManagerFactory\n+                            .getInstance(TrustManagerFactory.getDefaultAlgorithm());\n+                    tmf.init(keystore);\n+                    trustManagers = tmf.getTrustManagers();\n+                } else {\n+                    // Use no-op trust manager which will not verify certificates\n+                    trustManagers = defineNoOpTrustManager();\n+                }\n+\n+                sslContext = SSLContext.getInstance(\"TLS\");\n+                sslContext.init(kmf.getKeyManagers(), trustManagers, null);\n+\n+                sslsocketfactory = sslContext.getSocketFactory();\n+            } catch (FileNotFoundException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Keystore file not found\");\n+                return;\n+            } catch (CertificateException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Certificate exception\");\n+                return;\n+            } catch (UnrecoverableKeyException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"Key unrecoverable with supplied password\");\n+                return;\n+            } catch (KeyManagementException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Key management exception\");\n+                logger.debug(\"Key management exception\", e);\n+                return;\n+            } catch (KeyStoreException | NoSuchAlgorithmException | IOException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Error initializing keystore\");\n+                logger.debug(\"Error initializing keystore\", e);\n+                return;\n+            }\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Connecting\");\n+        scheduler.submit(this::connect); // start the async connect task\n+    }\n+\n+    /**\n+     * Return a no-op SSL trust manager which will not verify server or client certificates.\n+     */\n+    private TrustManager[] defineNoOpTrustManager() {\n+        return new TrustManager[] { new X509TrustManager() {\n+            @Override\n+            public void checkClientTrusted(final X509Certificate @Nullable [] chain, final @Nullable String authType) {\n+                logger.debug(\"Assuming client certificate is valid\");\n+                if (chain != null) {\n+                    for (int cert = 0; cert < chain.length; cert++) {\n+                        logger.trace(\"Subject DN: {}\", chain[cert].getSubjectDN());\n+                        logger.trace(\"Issuer DN: {}\", chain[cert].getIssuerDN());\n+                        logger.trace(\"Serial number {}:\", chain[cert].getSerialNumber());\n+                    }\n+                }\n+            }\n+\n+            @Override\n+            public void checkServerTrusted(final X509Certificate @Nullable [] chain, final @Nullable String authType) {\n+                logger.debug(\"Assuming server certificate is valid\");\n+                if (chain != null) {\n+                    for (int cert = 0; cert < chain.length; cert++) {\n+                        logger.trace(\"Subject DN: {}\", chain[cert].getSubjectDN());\n+                        logger.trace(\"Issuer DN: {}\", chain[cert].getIssuerDN());\n+                        logger.trace(\"Serial number: {}\", chain[cert].getSerialNumber());\n+                    }\n+                }\n+            }\n+\n+            @Override\n+            public X509Certificate @Nullable [] getAcceptedIssuers() {\n+                return null;\n+            }\n+        } };\n+    }\n+\n+    private synchronized void connect() {\n+        deviceDataLoaded.set(false);\n+        buttonDataLoaded.set(false);\n+\n+        try {\n+            logger.debug(\"Opening SSL connection to {}:{}\", config.ipAddress, config.port);\n+            SSLSocket sslsocket = (SSLSocket) sslsocketfactory.createSocket(config.ipAddress, config.port);\n+            sslsocket.startHandshake();\n+            writer = new BufferedWriter(new OutputStreamWriter(sslsocket.getOutputStream()));\n+            reader = new BufferedReader(new InputStreamReader(sslsocket.getInputStream()));\n+            this.sslsocket = sslsocket;\n+        } catch (UnknownHostException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Unknown host\");\n+            return;\n+        } catch (IllegalArgumentException e) {\n+            // port out of valid range\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Invalid port number\");\n+            return;\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Error opening SSL connection. Check log.\");\n+            logger.info(\"Error opening SSL connection: {}\", e.getMessage());\n+            disconnect();\n+            scheduleConnectRetry(reconnectInterval); // Possibly a temporary problem. Try again later.\n+            return;\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, STATUS_INITIALIZING);\n+\n+        Thread readerThread = new Thread(this::readerThreadJob, \"Lutron reader\");\n+        readerThread.setDaemon(true);\n+        readerThread.start();\n+        this.readerThread = readerThread;\n+\n+        Thread senderThread = new Thread(this::senderThreadJob, \"Lutron sender\");\n+        senderThread.setDaemon(true);\n+        senderThread.start();\n+        this.senderThread = senderThread;\n+\n+        sendCommand(new LeapCommand(Request.getButtonGroups()));\n+        queryDiscoveryData();\n+        sendCommand(new LeapCommand(Request.subscribeOccupancyGroupStatus()));\n+\n+        logger.debug(\"Starting keepAlive job with interval {}\", heartbeatInterval);\n+        keepAlive = scheduler.scheduleWithFixedDelay(this::sendKeepAlive, heartbeatInterval, heartbeatInterval,\n+                TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Called by connect() and discovery service to request fresh discovery data\n+     */\n+    public void queryDiscoveryData() {\n+        sendCommand(new LeapCommand(Request.getDevices()));\n+        sendCommand(new LeapCommand(Request.getAreas()));\n+        sendCommand(new LeapCommand(Request.getOccupancyGroups()));\n+    }\n+\n+    private void scheduleConnectRetry(long waitMinutes) {\n+        logger.debug(\"Scheduling connection retry in {} minutes\", waitMinutes);\n+        connectRetryJob = scheduler.schedule(this::connect, waitMinutes, TimeUnit.MINUTES);\n+    }\n+\n+    private synchronized void disconnect() {\n+        logger.debug(\"Disconnecting\");\n+\n+        Thread senderThread = this.senderThread;\n+        Thread readerThread = this.readerThread;\n+\n+        if (connectRetryJob != null) {\n+            connectRetryJob.cancel(true);\n+        }\n+        if (keepAlive != null) {\n+            keepAlive.cancel(true);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "deb48c1252ee18917f2f9e19cf0158fedb164659"}, "originalPosition": 327}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDY5ODYxOQ==", "bodyText": "Since this is asynchronous, if this handler is disposed immediately after getting initialized there is a chance it could get disposed before the connection finishes which would result in an illegal state.\nThe only slow operation you are performing as part of connect is the creation of the SSLSocket. Perhaps you could focus on just making that asynchronous instead.\nAnother option would be to cancel the future handle interrupt within your connect method.", "url": "https://github.com/openhab/openhab-addons/pull/8650#discussion_r500698619", "createdAt": "2020-10-07T02:17:47Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lutron/src/main/java/org/openhab/binding/lutron/internal/handler/LeapBridgeHandler.java", "diffHunk": "@@ -0,0 +1,763 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lutron.internal.handler;\n+\n+import static org.openhab.binding.lutron.internal.LutronBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.net.UnknownHostException;\n+import java.security.KeyManagementException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.UnrecoverableKeyException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManager;\n+import javax.net.ssl.TrustManagerFactory;\n+import javax.net.ssl.X509TrustManager;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.lutron.internal.config.LeapBridgeConfig;\n+import org.openhab.binding.lutron.internal.discovery.LeapDeviceDiscoveryService;\n+import org.openhab.binding.lutron.internal.protocol.FanSpeedType;\n+import org.openhab.binding.lutron.internal.protocol.GroupCommand;\n+import org.openhab.binding.lutron.internal.protocol.LutronCommandNew;\n+import org.openhab.binding.lutron.internal.protocol.OutputCommand;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapCommand;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapMessageParser;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapMessageParserCallbacks;\n+import org.openhab.binding.lutron.internal.protocol.leap.Request;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Area;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ButtonGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Device;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.OccupancyGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ZoneStatus;\n+import org.openhab.binding.lutron.internal.protocol.lip.LutronCommandType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Bridge handler responsible for communicating with Lutron hubs that support the LEAP protocol, such as Caseta and\n+ * RA2 Select.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LeapBridgeHandler extends LutronBridgeHandler implements LeapMessageParserCallbacks {\n+    private static final int DEFAULT_RECONNECT_MINUTES = 5;\n+    private static final int DEFAULT_HEARTBEAT_MINUTES = 5;\n+    private static final long KEEPALIVE_TIMEOUT_SECONDS = 30;\n+\n+    private static final String STATUS_INITIALIZING = \"Initializing\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(LeapBridgeHandler.class);\n+\n+    private @NonNullByDefault({}) LeapBridgeConfig config;\n+    private int reconnectInterval;\n+    private int heartbeatInterval;\n+    private int sendDelay;\n+\n+    private @NonNullByDefault({}) SSLSocketFactory sslsocketfactory;\n+    private @Nullable SSLSocket sslsocket;\n+    private @Nullable BufferedWriter writer;\n+    private @Nullable BufferedReader reader;\n+\n+    private @NonNullByDefault({}) LeapMessageParser leapMessageParser;\n+\n+    private final BlockingQueue<LeapCommand> sendQueue = new LinkedBlockingQueue<>();\n+\n+    private @Nullable Thread senderThread;\n+    private @Nullable Thread readerThread;\n+\n+    private @Nullable ScheduledFuture<?> keepAlive;\n+    private @Nullable ScheduledFuture<?> keepAliveReconnect;\n+    private @Nullable ScheduledFuture<?> connectRetryJob;\n+    private final Object keepAliveReconnectLock = new Object();\n+\n+    private final Map<Integer, Integer> zoneToDevice = new HashMap<>();\n+    private final Map<Integer, Integer> deviceToZone = new HashMap<>();\n+    private final Object zoneMapsLock = new Object();\n+\n+    private @Nullable Map<Integer, List<Integer>> deviceButtonMap;\n+    private final Object deviceButtonMapLock = new Object();\n+\n+    private final AtomicBoolean deviceDataLoaded = new AtomicBoolean(false);\n+    private final AtomicBoolean buttonDataLoaded = new AtomicBoolean(false);\n+\n+    private final Map<Integer, LutronHandler> childHandlerMap = new ConcurrentHashMap<>();\n+    private final Map<Integer, OGroupHandler> groupHandlerMap = new ConcurrentHashMap<>();\n+\n+    private @Nullable LeapDeviceDiscoveryService discoveryService;\n+\n+    public void setDiscoveryService(LeapDeviceDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    public LeapBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+        leapMessageParser = new LeapMessageParser(this);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        SSLContext sslContext;\n+\n+        childHandlerMap.clear();\n+        groupHandlerMap.clear();\n+\n+        config = getConfigAs(LeapBridgeConfig.class);\n+        String keystorePassword = (config.keystorePassword == null) ? \"\" : config.keystorePassword;\n+\n+        String ipAddress = config.ipAddress;\n+        if (ipAddress == null || ipAddress.isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"bridge address not specified\");\n+            return;\n+        }\n+\n+        reconnectInterval = (config.reconnect > 0) ? config.reconnect : DEFAULT_RECONNECT_MINUTES;\n+        heartbeatInterval = (config.heartbeat > 0) ? config.heartbeat : DEFAULT_HEARTBEAT_MINUTES;\n+        sendDelay = (config.delay < 0) ? 0 : config.delay;\n+\n+        if (config.keystore == null || keystorePassword == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Keystore/keystore password not configured\");\n+            return;\n+        } else {\n+            try (FileInputStream keystoreInputStream = new FileInputStream(config.keystore)) {\n+                logger.trace(\"Initializing keystore\");\n+                KeyStore keystore = KeyStore.getInstance(KeyStore.getDefaultType());\n+\n+                keystore.load(keystoreInputStream, keystorePassword.toCharArray());\n+\n+                logger.trace(\"Initializing SSL Context\");\n+                KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n+                kmf.init(keystore, keystorePassword.toCharArray());\n+\n+                TrustManager[] trustManagers;\n+                if (config.certValidate) {\n+                    // Use default trust manager which will attempt to validate server certificate from hub\n+                    TrustManagerFactory tmf = TrustManagerFactory\n+                            .getInstance(TrustManagerFactory.getDefaultAlgorithm());\n+                    tmf.init(keystore);\n+                    trustManagers = tmf.getTrustManagers();\n+                } else {\n+                    // Use no-op trust manager which will not verify certificates\n+                    trustManagers = defineNoOpTrustManager();\n+                }\n+\n+                sslContext = SSLContext.getInstance(\"TLS\");\n+                sslContext.init(kmf.getKeyManagers(), trustManagers, null);\n+\n+                sslsocketfactory = sslContext.getSocketFactory();\n+            } catch (FileNotFoundException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Keystore file not found\");\n+                return;\n+            } catch (CertificateException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Certificate exception\");\n+                return;\n+            } catch (UnrecoverableKeyException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"Key unrecoverable with supplied password\");\n+                return;\n+            } catch (KeyManagementException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Key management exception\");\n+                logger.debug(\"Key management exception\", e);\n+                return;\n+            } catch (KeyStoreException | NoSuchAlgorithmException | IOException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Error initializing keystore\");\n+                logger.debug(\"Error initializing keystore\", e);\n+                return;\n+            }\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Connecting\");\n+        scheduler.submit(this::connect); // start the async connect task", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "deb48c1252ee18917f2f9e19cf0158fedb164659"}, "originalPosition": 215}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDcwMTQzOA==", "bodyText": "disconnect is called as part of dispose so it would probably be a really good idea to cancel all tasks with interrupts.", "url": "https://github.com/openhab/openhab-addons/pull/8650#discussion_r500701438", "createdAt": "2020-10-07T02:27:00Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lutron/src/main/java/org/openhab/binding/lutron/internal/handler/LeapBridgeHandler.java", "diffHunk": "@@ -0,0 +1,763 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lutron.internal.handler;\n+\n+import static org.openhab.binding.lutron.internal.LutronBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.net.UnknownHostException;\n+import java.security.KeyManagementException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.UnrecoverableKeyException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManager;\n+import javax.net.ssl.TrustManagerFactory;\n+import javax.net.ssl.X509TrustManager;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.lutron.internal.config.LeapBridgeConfig;\n+import org.openhab.binding.lutron.internal.discovery.LeapDeviceDiscoveryService;\n+import org.openhab.binding.lutron.internal.protocol.FanSpeedType;\n+import org.openhab.binding.lutron.internal.protocol.GroupCommand;\n+import org.openhab.binding.lutron.internal.protocol.LutronCommandNew;\n+import org.openhab.binding.lutron.internal.protocol.OutputCommand;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapCommand;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapMessageParser;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapMessageParserCallbacks;\n+import org.openhab.binding.lutron.internal.protocol.leap.Request;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Area;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ButtonGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Device;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.OccupancyGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ZoneStatus;\n+import org.openhab.binding.lutron.internal.protocol.lip.LutronCommandType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Bridge handler responsible for communicating with Lutron hubs that support the LEAP protocol, such as Caseta and\n+ * RA2 Select.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LeapBridgeHandler extends LutronBridgeHandler implements LeapMessageParserCallbacks {\n+    private static final int DEFAULT_RECONNECT_MINUTES = 5;\n+    private static final int DEFAULT_HEARTBEAT_MINUTES = 5;\n+    private static final long KEEPALIVE_TIMEOUT_SECONDS = 30;\n+\n+    private static final String STATUS_INITIALIZING = \"Initializing\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(LeapBridgeHandler.class);\n+\n+    private @NonNullByDefault({}) LeapBridgeConfig config;\n+    private int reconnectInterval;\n+    private int heartbeatInterval;\n+    private int sendDelay;\n+\n+    private @NonNullByDefault({}) SSLSocketFactory sslsocketfactory;\n+    private @Nullable SSLSocket sslsocket;\n+    private @Nullable BufferedWriter writer;\n+    private @Nullable BufferedReader reader;\n+\n+    private @NonNullByDefault({}) LeapMessageParser leapMessageParser;\n+\n+    private final BlockingQueue<LeapCommand> sendQueue = new LinkedBlockingQueue<>();\n+\n+    private @Nullable Thread senderThread;\n+    private @Nullable Thread readerThread;\n+\n+    private @Nullable ScheduledFuture<?> keepAlive;\n+    private @Nullable ScheduledFuture<?> keepAliveReconnect;\n+    private @Nullable ScheduledFuture<?> connectRetryJob;\n+    private final Object keepAliveReconnectLock = new Object();\n+\n+    private final Map<Integer, Integer> zoneToDevice = new HashMap<>();\n+    private final Map<Integer, Integer> deviceToZone = new HashMap<>();\n+    private final Object zoneMapsLock = new Object();\n+\n+    private @Nullable Map<Integer, List<Integer>> deviceButtonMap;\n+    private final Object deviceButtonMapLock = new Object();\n+\n+    private final AtomicBoolean deviceDataLoaded = new AtomicBoolean(false);\n+    private final AtomicBoolean buttonDataLoaded = new AtomicBoolean(false);\n+\n+    private final Map<Integer, LutronHandler> childHandlerMap = new ConcurrentHashMap<>();\n+    private final Map<Integer, OGroupHandler> groupHandlerMap = new ConcurrentHashMap<>();\n+\n+    private @Nullable LeapDeviceDiscoveryService discoveryService;\n+\n+    public void setDiscoveryService(LeapDeviceDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    public LeapBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+        leapMessageParser = new LeapMessageParser(this);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        SSLContext sslContext;\n+\n+        childHandlerMap.clear();\n+        groupHandlerMap.clear();\n+\n+        config = getConfigAs(LeapBridgeConfig.class);\n+        String keystorePassword = (config.keystorePassword == null) ? \"\" : config.keystorePassword;\n+\n+        String ipAddress = config.ipAddress;\n+        if (ipAddress == null || ipAddress.isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"bridge address not specified\");\n+            return;\n+        }\n+\n+        reconnectInterval = (config.reconnect > 0) ? config.reconnect : DEFAULT_RECONNECT_MINUTES;\n+        heartbeatInterval = (config.heartbeat > 0) ? config.heartbeat : DEFAULT_HEARTBEAT_MINUTES;\n+        sendDelay = (config.delay < 0) ? 0 : config.delay;\n+\n+        if (config.keystore == null || keystorePassword == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Keystore/keystore password not configured\");\n+            return;\n+        } else {\n+            try (FileInputStream keystoreInputStream = new FileInputStream(config.keystore)) {\n+                logger.trace(\"Initializing keystore\");\n+                KeyStore keystore = KeyStore.getInstance(KeyStore.getDefaultType());\n+\n+                keystore.load(keystoreInputStream, keystorePassword.toCharArray());\n+\n+                logger.trace(\"Initializing SSL Context\");\n+                KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n+                kmf.init(keystore, keystorePassword.toCharArray());\n+\n+                TrustManager[] trustManagers;\n+                if (config.certValidate) {\n+                    // Use default trust manager which will attempt to validate server certificate from hub\n+                    TrustManagerFactory tmf = TrustManagerFactory\n+                            .getInstance(TrustManagerFactory.getDefaultAlgorithm());\n+                    tmf.init(keystore);\n+                    trustManagers = tmf.getTrustManagers();\n+                } else {\n+                    // Use no-op trust manager which will not verify certificates\n+                    trustManagers = defineNoOpTrustManager();\n+                }\n+\n+                sslContext = SSLContext.getInstance(\"TLS\");\n+                sslContext.init(kmf.getKeyManagers(), trustManagers, null);\n+\n+                sslsocketfactory = sslContext.getSocketFactory();\n+            } catch (FileNotFoundException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Keystore file not found\");\n+                return;\n+            } catch (CertificateException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Certificate exception\");\n+                return;\n+            } catch (UnrecoverableKeyException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"Key unrecoverable with supplied password\");\n+                return;\n+            } catch (KeyManagementException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Key management exception\");\n+                logger.debug(\"Key management exception\", e);\n+                return;\n+            } catch (KeyStoreException | NoSuchAlgorithmException | IOException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Error initializing keystore\");\n+                logger.debug(\"Error initializing keystore\", e);\n+                return;\n+            }\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Connecting\");\n+        scheduler.submit(this::connect); // start the async connect task\n+    }\n+\n+    /**\n+     * Return a no-op SSL trust manager which will not verify server or client certificates.\n+     */\n+    private TrustManager[] defineNoOpTrustManager() {\n+        return new TrustManager[] { new X509TrustManager() {\n+            @Override\n+            public void checkClientTrusted(final X509Certificate @Nullable [] chain, final @Nullable String authType) {\n+                logger.debug(\"Assuming client certificate is valid\");\n+                if (chain != null) {\n+                    for (int cert = 0; cert < chain.length; cert++) {\n+                        logger.trace(\"Subject DN: {}\", chain[cert].getSubjectDN());\n+                        logger.trace(\"Issuer DN: {}\", chain[cert].getIssuerDN());\n+                        logger.trace(\"Serial number {}:\", chain[cert].getSerialNumber());\n+                    }\n+                }\n+            }\n+\n+            @Override\n+            public void checkServerTrusted(final X509Certificate @Nullable [] chain, final @Nullable String authType) {\n+                logger.debug(\"Assuming server certificate is valid\");\n+                if (chain != null) {\n+                    for (int cert = 0; cert < chain.length; cert++) {\n+                        logger.trace(\"Subject DN: {}\", chain[cert].getSubjectDN());\n+                        logger.trace(\"Issuer DN: {}\", chain[cert].getIssuerDN());\n+                        logger.trace(\"Serial number: {}\", chain[cert].getSerialNumber());\n+                    }\n+                }\n+            }\n+\n+            @Override\n+            public X509Certificate @Nullable [] getAcceptedIssuers() {\n+                return null;\n+            }\n+        } };\n+    }\n+\n+    private synchronized void connect() {\n+        deviceDataLoaded.set(false);\n+        buttonDataLoaded.set(false);\n+\n+        try {\n+            logger.debug(\"Opening SSL connection to {}:{}\", config.ipAddress, config.port);\n+            SSLSocket sslsocket = (SSLSocket) sslsocketfactory.createSocket(config.ipAddress, config.port);\n+            sslsocket.startHandshake();\n+            writer = new BufferedWriter(new OutputStreamWriter(sslsocket.getOutputStream()));\n+            reader = new BufferedReader(new InputStreamReader(sslsocket.getInputStream()));\n+            this.sslsocket = sslsocket;\n+        } catch (UnknownHostException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Unknown host\");\n+            return;\n+        } catch (IllegalArgumentException e) {\n+            // port out of valid range\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Invalid port number\");\n+            return;\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Error opening SSL connection. Check log.\");\n+            logger.info(\"Error opening SSL connection: {}\", e.getMessage());\n+            disconnect();\n+            scheduleConnectRetry(reconnectInterval); // Possibly a temporary problem. Try again later.\n+            return;\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, STATUS_INITIALIZING);\n+\n+        Thread readerThread = new Thread(this::readerThreadJob, \"Lutron reader\");\n+        readerThread.setDaemon(true);\n+        readerThread.start();\n+        this.readerThread = readerThread;\n+\n+        Thread senderThread = new Thread(this::senderThreadJob, \"Lutron sender\");\n+        senderThread.setDaemon(true);\n+        senderThread.start();\n+        this.senderThread = senderThread;\n+\n+        sendCommand(new LeapCommand(Request.getButtonGroups()));\n+        queryDiscoveryData();\n+        sendCommand(new LeapCommand(Request.subscribeOccupancyGroupStatus()));\n+\n+        logger.debug(\"Starting keepAlive job with interval {}\", heartbeatInterval);\n+        keepAlive = scheduler.scheduleWithFixedDelay(this::sendKeepAlive, heartbeatInterval, heartbeatInterval,\n+                TimeUnit.MINUTES);\n+    }\n+\n+    /**\n+     * Called by connect() and discovery service to request fresh discovery data\n+     */\n+    public void queryDiscoveryData() {\n+        sendCommand(new LeapCommand(Request.getDevices()));\n+        sendCommand(new LeapCommand(Request.getAreas()));\n+        sendCommand(new LeapCommand(Request.getOccupancyGroups()));\n+    }\n+\n+    private void scheduleConnectRetry(long waitMinutes) {\n+        logger.debug(\"Scheduling connection retry in {} minutes\", waitMinutes);\n+        connectRetryJob = scheduler.schedule(this::connect, waitMinutes, TimeUnit.MINUTES);\n+    }\n+\n+    private synchronized void disconnect() {\n+        logger.debug(\"Disconnecting\");\n+\n+        Thread senderThread = this.senderThread;\n+        Thread readerThread = this.readerThread;\n+\n+        if (connectRetryJob != null) {\n+            connectRetryJob.cancel(true);\n+        }\n+        if (keepAlive != null) {\n+            keepAlive.cancel(true);\n+        }\n+\n+        // May be called from keepAliveReconnect thread, so call cancel with false\n+        reconnectTaskCancel(false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "deb48c1252ee18917f2f9e19cf0158fedb164659"}, "originalPosition": 330}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDcwMTcxNg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            if (chain != null) {\n          \n          \n            \n                            if (chain != null && logger.isTraceEnabled()) {", "url": "https://github.com/openhab/openhab-addons/pull/8650#discussion_r500701716", "createdAt": "2020-10-07T02:28:15Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lutron/src/main/java/org/openhab/binding/lutron/internal/handler/LeapBridgeHandler.java", "diffHunk": "@@ -0,0 +1,763 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lutron.internal.handler;\n+\n+import static org.openhab.binding.lutron.internal.LutronBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.net.UnknownHostException;\n+import java.security.KeyManagementException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.UnrecoverableKeyException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManager;\n+import javax.net.ssl.TrustManagerFactory;\n+import javax.net.ssl.X509TrustManager;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.lutron.internal.config.LeapBridgeConfig;\n+import org.openhab.binding.lutron.internal.discovery.LeapDeviceDiscoveryService;\n+import org.openhab.binding.lutron.internal.protocol.FanSpeedType;\n+import org.openhab.binding.lutron.internal.protocol.GroupCommand;\n+import org.openhab.binding.lutron.internal.protocol.LutronCommandNew;\n+import org.openhab.binding.lutron.internal.protocol.OutputCommand;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapCommand;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapMessageParser;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapMessageParserCallbacks;\n+import org.openhab.binding.lutron.internal.protocol.leap.Request;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Area;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ButtonGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Device;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.OccupancyGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ZoneStatus;\n+import org.openhab.binding.lutron.internal.protocol.lip.LutronCommandType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Bridge handler responsible for communicating with Lutron hubs that support the LEAP protocol, such as Caseta and\n+ * RA2 Select.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LeapBridgeHandler extends LutronBridgeHandler implements LeapMessageParserCallbacks {\n+    private static final int DEFAULT_RECONNECT_MINUTES = 5;\n+    private static final int DEFAULT_HEARTBEAT_MINUTES = 5;\n+    private static final long KEEPALIVE_TIMEOUT_SECONDS = 30;\n+\n+    private static final String STATUS_INITIALIZING = \"Initializing\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(LeapBridgeHandler.class);\n+\n+    private @NonNullByDefault({}) LeapBridgeConfig config;\n+    private int reconnectInterval;\n+    private int heartbeatInterval;\n+    private int sendDelay;\n+\n+    private @NonNullByDefault({}) SSLSocketFactory sslsocketfactory;\n+    private @Nullable SSLSocket sslsocket;\n+    private @Nullable BufferedWriter writer;\n+    private @Nullable BufferedReader reader;\n+\n+    private @NonNullByDefault({}) LeapMessageParser leapMessageParser;\n+\n+    private final BlockingQueue<LeapCommand> sendQueue = new LinkedBlockingQueue<>();\n+\n+    private @Nullable Thread senderThread;\n+    private @Nullable Thread readerThread;\n+\n+    private @Nullable ScheduledFuture<?> keepAlive;\n+    private @Nullable ScheduledFuture<?> keepAliveReconnect;\n+    private @Nullable ScheduledFuture<?> connectRetryJob;\n+    private final Object keepAliveReconnectLock = new Object();\n+\n+    private final Map<Integer, Integer> zoneToDevice = new HashMap<>();\n+    private final Map<Integer, Integer> deviceToZone = new HashMap<>();\n+    private final Object zoneMapsLock = new Object();\n+\n+    private @Nullable Map<Integer, List<Integer>> deviceButtonMap;\n+    private final Object deviceButtonMapLock = new Object();\n+\n+    private final AtomicBoolean deviceDataLoaded = new AtomicBoolean(false);\n+    private final AtomicBoolean buttonDataLoaded = new AtomicBoolean(false);\n+\n+    private final Map<Integer, LutronHandler> childHandlerMap = new ConcurrentHashMap<>();\n+    private final Map<Integer, OGroupHandler> groupHandlerMap = new ConcurrentHashMap<>();\n+\n+    private @Nullable LeapDeviceDiscoveryService discoveryService;\n+\n+    public void setDiscoveryService(LeapDeviceDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    public LeapBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+        leapMessageParser = new LeapMessageParser(this);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        SSLContext sslContext;\n+\n+        childHandlerMap.clear();\n+        groupHandlerMap.clear();\n+\n+        config = getConfigAs(LeapBridgeConfig.class);\n+        String keystorePassword = (config.keystorePassword == null) ? \"\" : config.keystorePassword;\n+\n+        String ipAddress = config.ipAddress;\n+        if (ipAddress == null || ipAddress.isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"bridge address not specified\");\n+            return;\n+        }\n+\n+        reconnectInterval = (config.reconnect > 0) ? config.reconnect : DEFAULT_RECONNECT_MINUTES;\n+        heartbeatInterval = (config.heartbeat > 0) ? config.heartbeat : DEFAULT_HEARTBEAT_MINUTES;\n+        sendDelay = (config.delay < 0) ? 0 : config.delay;\n+\n+        if (config.keystore == null || keystorePassword == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Keystore/keystore password not configured\");\n+            return;\n+        } else {\n+            try (FileInputStream keystoreInputStream = new FileInputStream(config.keystore)) {\n+                logger.trace(\"Initializing keystore\");\n+                KeyStore keystore = KeyStore.getInstance(KeyStore.getDefaultType());\n+\n+                keystore.load(keystoreInputStream, keystorePassword.toCharArray());\n+\n+                logger.trace(\"Initializing SSL Context\");\n+                KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n+                kmf.init(keystore, keystorePassword.toCharArray());\n+\n+                TrustManager[] trustManagers;\n+                if (config.certValidate) {\n+                    // Use default trust manager which will attempt to validate server certificate from hub\n+                    TrustManagerFactory tmf = TrustManagerFactory\n+                            .getInstance(TrustManagerFactory.getDefaultAlgorithm());\n+                    tmf.init(keystore);\n+                    trustManagers = tmf.getTrustManagers();\n+                } else {\n+                    // Use no-op trust manager which will not verify certificates\n+                    trustManagers = defineNoOpTrustManager();\n+                }\n+\n+                sslContext = SSLContext.getInstance(\"TLS\");\n+                sslContext.init(kmf.getKeyManagers(), trustManagers, null);\n+\n+                sslsocketfactory = sslContext.getSocketFactory();\n+            } catch (FileNotFoundException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Keystore file not found\");\n+                return;\n+            } catch (CertificateException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Certificate exception\");\n+                return;\n+            } catch (UnrecoverableKeyException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"Key unrecoverable with supplied password\");\n+                return;\n+            } catch (KeyManagementException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Key management exception\");\n+                logger.debug(\"Key management exception\", e);\n+                return;\n+            } catch (KeyStoreException | NoSuchAlgorithmException | IOException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Error initializing keystore\");\n+                logger.debug(\"Error initializing keystore\", e);\n+                return;\n+            }\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Connecting\");\n+        scheduler.submit(this::connect); // start the async connect task\n+    }\n+\n+    /**\n+     * Return a no-op SSL trust manager which will not verify server or client certificates.\n+     */\n+    private TrustManager[] defineNoOpTrustManager() {\n+        return new TrustManager[] { new X509TrustManager() {\n+            @Override\n+            public void checkClientTrusted(final X509Certificate @Nullable [] chain, final @Nullable String authType) {\n+                logger.debug(\"Assuming client certificate is valid\");\n+                if (chain != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "deb48c1252ee18917f2f9e19cf0158fedb164659"}, "originalPosition": 226}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDcwMTc4MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            if (chain != null) {\n          \n          \n            \n                            if (chain != null && logger.isTraceEnabled()) {", "url": "https://github.com/openhab/openhab-addons/pull/8650#discussion_r500701780", "createdAt": "2020-10-07T02:28:30Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lutron/src/main/java/org/openhab/binding/lutron/internal/handler/LeapBridgeHandler.java", "diffHunk": "@@ -0,0 +1,763 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lutron.internal.handler;\n+\n+import static org.openhab.binding.lutron.internal.LutronBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.OutputStreamWriter;\n+import java.net.UnknownHostException;\n+import java.security.KeyManagementException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.UnrecoverableKeyException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManager;\n+import javax.net.ssl.TrustManagerFactory;\n+import javax.net.ssl.X509TrustManager;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.lutron.internal.config.LeapBridgeConfig;\n+import org.openhab.binding.lutron.internal.discovery.LeapDeviceDiscoveryService;\n+import org.openhab.binding.lutron.internal.protocol.FanSpeedType;\n+import org.openhab.binding.lutron.internal.protocol.GroupCommand;\n+import org.openhab.binding.lutron.internal.protocol.LutronCommandNew;\n+import org.openhab.binding.lutron.internal.protocol.OutputCommand;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapCommand;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapMessageParser;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapMessageParserCallbacks;\n+import org.openhab.binding.lutron.internal.protocol.leap.Request;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Area;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ButtonGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Device;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.OccupancyGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ZoneStatus;\n+import org.openhab.binding.lutron.internal.protocol.lip.LutronCommandType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Bridge handler responsible for communicating with Lutron hubs that support the LEAP protocol, such as Caseta and\n+ * RA2 Select.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LeapBridgeHandler extends LutronBridgeHandler implements LeapMessageParserCallbacks {\n+    private static final int DEFAULT_RECONNECT_MINUTES = 5;\n+    private static final int DEFAULT_HEARTBEAT_MINUTES = 5;\n+    private static final long KEEPALIVE_TIMEOUT_SECONDS = 30;\n+\n+    private static final String STATUS_INITIALIZING = \"Initializing\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(LeapBridgeHandler.class);\n+\n+    private @NonNullByDefault({}) LeapBridgeConfig config;\n+    private int reconnectInterval;\n+    private int heartbeatInterval;\n+    private int sendDelay;\n+\n+    private @NonNullByDefault({}) SSLSocketFactory sslsocketfactory;\n+    private @Nullable SSLSocket sslsocket;\n+    private @Nullable BufferedWriter writer;\n+    private @Nullable BufferedReader reader;\n+\n+    private @NonNullByDefault({}) LeapMessageParser leapMessageParser;\n+\n+    private final BlockingQueue<LeapCommand> sendQueue = new LinkedBlockingQueue<>();\n+\n+    private @Nullable Thread senderThread;\n+    private @Nullable Thread readerThread;\n+\n+    private @Nullable ScheduledFuture<?> keepAlive;\n+    private @Nullable ScheduledFuture<?> keepAliveReconnect;\n+    private @Nullable ScheduledFuture<?> connectRetryJob;\n+    private final Object keepAliveReconnectLock = new Object();\n+\n+    private final Map<Integer, Integer> zoneToDevice = new HashMap<>();\n+    private final Map<Integer, Integer> deviceToZone = new HashMap<>();\n+    private final Object zoneMapsLock = new Object();\n+\n+    private @Nullable Map<Integer, List<Integer>> deviceButtonMap;\n+    private final Object deviceButtonMapLock = new Object();\n+\n+    private final AtomicBoolean deviceDataLoaded = new AtomicBoolean(false);\n+    private final AtomicBoolean buttonDataLoaded = new AtomicBoolean(false);\n+\n+    private final Map<Integer, LutronHandler> childHandlerMap = new ConcurrentHashMap<>();\n+    private final Map<Integer, OGroupHandler> groupHandlerMap = new ConcurrentHashMap<>();\n+\n+    private @Nullable LeapDeviceDiscoveryService discoveryService;\n+\n+    public void setDiscoveryService(LeapDeviceDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    public LeapBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+        leapMessageParser = new LeapMessageParser(this);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        SSLContext sslContext;\n+\n+        childHandlerMap.clear();\n+        groupHandlerMap.clear();\n+\n+        config = getConfigAs(LeapBridgeConfig.class);\n+        String keystorePassword = (config.keystorePassword == null) ? \"\" : config.keystorePassword;\n+\n+        String ipAddress = config.ipAddress;\n+        if (ipAddress == null || ipAddress.isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"bridge address not specified\");\n+            return;\n+        }\n+\n+        reconnectInterval = (config.reconnect > 0) ? config.reconnect : DEFAULT_RECONNECT_MINUTES;\n+        heartbeatInterval = (config.heartbeat > 0) ? config.heartbeat : DEFAULT_HEARTBEAT_MINUTES;\n+        sendDelay = (config.delay < 0) ? 0 : config.delay;\n+\n+        if (config.keystore == null || keystorePassword == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Keystore/keystore password not configured\");\n+            return;\n+        } else {\n+            try (FileInputStream keystoreInputStream = new FileInputStream(config.keystore)) {\n+                logger.trace(\"Initializing keystore\");\n+                KeyStore keystore = KeyStore.getInstance(KeyStore.getDefaultType());\n+\n+                keystore.load(keystoreInputStream, keystorePassword.toCharArray());\n+\n+                logger.trace(\"Initializing SSL Context\");\n+                KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n+                kmf.init(keystore, keystorePassword.toCharArray());\n+\n+                TrustManager[] trustManagers;\n+                if (config.certValidate) {\n+                    // Use default trust manager which will attempt to validate server certificate from hub\n+                    TrustManagerFactory tmf = TrustManagerFactory\n+                            .getInstance(TrustManagerFactory.getDefaultAlgorithm());\n+                    tmf.init(keystore);\n+                    trustManagers = tmf.getTrustManagers();\n+                } else {\n+                    // Use no-op trust manager which will not verify certificates\n+                    trustManagers = defineNoOpTrustManager();\n+                }\n+\n+                sslContext = SSLContext.getInstance(\"TLS\");\n+                sslContext.init(kmf.getKeyManagers(), trustManagers, null);\n+\n+                sslsocketfactory = sslContext.getSocketFactory();\n+            } catch (FileNotFoundException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Keystore file not found\");\n+                return;\n+            } catch (CertificateException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Certificate exception\");\n+                return;\n+            } catch (UnrecoverableKeyException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"Key unrecoverable with supplied password\");\n+                return;\n+            } catch (KeyManagementException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Key management exception\");\n+                logger.debug(\"Key management exception\", e);\n+                return;\n+            } catch (KeyStoreException | NoSuchAlgorithmException | IOException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Error initializing keystore\");\n+                logger.debug(\"Error initializing keystore\", e);\n+                return;\n+            }\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Connecting\");\n+        scheduler.submit(this::connect); // start the async connect task\n+    }\n+\n+    /**\n+     * Return a no-op SSL trust manager which will not verify server or client certificates.\n+     */\n+    private TrustManager[] defineNoOpTrustManager() {\n+        return new TrustManager[] { new X509TrustManager() {\n+            @Override\n+            public void checkClientTrusted(final X509Certificate @Nullable [] chain, final @Nullable String authType) {\n+                logger.debug(\"Assuming client certificate is valid\");\n+                if (chain != null) {\n+                    for (int cert = 0; cert < chain.length; cert++) {\n+                        logger.trace(\"Subject DN: {}\", chain[cert].getSubjectDN());\n+                        logger.trace(\"Issuer DN: {}\", chain[cert].getIssuerDN());\n+                        logger.trace(\"Serial number {}:\", chain[cert].getSerialNumber());\n+                    }\n+                }\n+            }\n+\n+            @Override\n+            public void checkServerTrusted(final X509Certificate @Nullable [] chain, final @Nullable String authType) {\n+                logger.debug(\"Assuming server certificate is valid\");\n+                if (chain != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "deb48c1252ee18917f2f9e19cf0158fedb164659"}, "originalPosition": 238}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5dc3d31afdcb73a7e4319c3984a1426d50ffd933", "author": {"user": {"login": "bobadair", "name": "Bob A."}}, "url": "https://github.com/openhab/openhab-addons/commit/5dc3d31afdcb73a7e4319c3984a1426d50ffd933", "committedDate": "2020-10-07T17:22:50Z", "message": "[lutron] Address some review comments\n\nSigned-off-by: Bob Adair <bob.github@att.net>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "28b945817af6999e9f76f8a88c5603c3d3beab8d", "author": {"user": {"login": "bobadair", "name": "Bob A."}}, "url": "https://github.com/openhab/openhab-addons/commit/28b945817af6999e9f76f8a88c5603c3d3beab8d", "committedDate": "2020-10-08T05:07:33Z", "message": "[lutron] Address more review comments\n\n* Handle InterruptedIOException in reader and writer threads\n* Interrupt running reconnect job from dispose\n\nSigned-off-by: Bob Adair <bob.github@att.net>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "037acd4500d1842743ac77d2c6fcf09941fd08f4", "author": {"user": {"login": "bobadair", "name": "Bob A."}}, "url": "https://github.com/openhab/openhab-addons/commit/037acd4500d1842743ac77d2c6fcf09941fd08f4", "committedDate": "2020-10-08T22:18:01Z", "message": "[lutron] Address more review comments\n\nSigned-off-by: Bob Adair <bob.github@att.net>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b5b90ad4b68c0b4b596bca1462def5dabced98b2", "author": {"user": {"login": "bobadair", "name": "Bob A."}}, "url": "https://github.com/openhab/openhab-addons/commit/b5b90ad4b68c0b4b596bca1462def5dabced98b2", "committedDate": "2020-10-09T22:15:41Z", "message": "[lutron] Interrupt async init task from dispose\n\nSigned-off-by: Bob Adair <bob.github@att.net>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "306f423cb4b764644ae8f95459894e0d792a052e", "author": {"user": {"login": "bobadair", "name": "Bob A."}}, "url": "https://github.com/openhab/openhab-addons/commit/306f423cb4b764644ae8f95459894e0d792a052e", "committedDate": "2020-10-10T04:58:48Z", "message": "[lutron] Eliminate null checker warnings\n\nSigned-off-by: Bob Adair <bob.github@att.net>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "71a5b7542f4afd59dccb7c37c5ab19cfcf582ee4", "author": {"user": {"login": "bobadair", "name": "Bob A."}}, "url": "https://github.com/openhab/openhab-addons/commit/71a5b7542f4afd59dccb7c37c5ab19cfcf582ee4", "committedDate": "2020-10-11T04:36:48Z", "message": "[lutron] Convert LeapDeviceDiscoveryService to ThingHandlerService\n\nSigned-off-by: Bob Adair <bob.github@att.net>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "40d4fc56591c84fbeb9ce05ce90473724e53bf3a", "author": {"user": {"login": "bobadair", "name": "Bob A."}}, "url": "https://github.com/openhab/openhab-addons/commit/40d4fc56591c84fbeb9ce05ce90473724e53bf3a", "committedDate": "2020-10-11T04:59:08Z", "message": "[lutron] Remove comment\n\nSigned-off-by: Bob Adair <bob.github@att.net>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2MjI0Mzc3", "url": "https://github.com/openhab/openhab-addons/pull/8650#pullrequestreview-506224377", "createdAt": "2020-10-11T22:45:30Z", "commit": {"oid": "40d4fc56591c84fbeb9ce05ce90473724e53bf3a"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMVQyMjo0NTozMVrOHfrOfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMVQyMzoyNzoyNFrOHfrgJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk3NjEyNg==", "bodyText": "the main branch is running on java 11, so perhaps you could get rid of this ugly stuff now?", "url": "https://github.com/openhab/openhab-addons/pull/8650#discussion_r502976126", "createdAt": "2020-10-11T22:45:31Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lutron/src/main/java/org/openhab/binding/lutron/internal/handler/PicoKeypadHandler.java", "diffHunk": "@@ -35,24 +37,69 @@ public PicoKeypadHandler(Thing thing) {\n         kp = new KeypadConfigPico();\n     }\n \n+    @SuppressWarnings(\"serial\")\n     @Override\n     protected void configureComponents(@Nullable String model) {\n         String mod = model == null ? \"Generic\" : model;\n         logger.debug(\"Configuring components for keypad model {}\", mod);\n \n         switch (mod) {\n             case \"2B\":\n+                buttonList = kp.getComponents(mod, ComponentType.BUTTON);\n+                leapButtonMap = new HashMap<Integer, Integer>() {\n+                    {\n+                        put(2, 1);\n+                        put(4, 2);\n+                    }\n+                }; // Note: we can get rid of this ugly stuff with java 9 and above", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40d4fc56591c84fbeb9ce05ce90473724e53bf3a"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjk4MDY0Nw==", "bodyText": "The spawning of asynchronous tasks inside of other asynchronous tasks can be a real source of problems if you are trying to dispose the handler while it is getting initialized. I suggest wrapping the Thread fields in a CompletableFuture so that you have a way to prevent starting them in the event that dispose it called before your asynchronous task initialized them.\nCompletableFuture<Thread> readThreadFuture;\n\npublic void initialize() {\n  readThreadFuture = new CompletableFuture<>();\n  readThreadFuture.thenAccept(Thread::start);\n\n  Thread readerThread = new Thread(this::readerThreadJob, \"Lutron reader\");\n  readerThread.setDaemon(true);\n\n  executor.submit(() -> {\n    ...\n    readThreadFuture.complete(readerThread);\n  });\n}\n\npublic void dispose(){\n  //if this completes the future the asynchronous 'complete()' will be ignored\n  if(!readThreadFuture.cancel(false)){\n     //failure to cancel means that the future completed first, so lets interrupt the thread then   \n     readThreadFuture.thenAccept(thread -> thread.interrupt());\n  }\n}\n\nIn addition could you initialize your keepAliveJob inside of the initialize() method instead of doing it asynchronously? You could just make the keepAliveJob skip if the socket isn't ready yet.", "url": "https://github.com/openhab/openhab-addons/pull/8650#discussion_r502980647", "createdAt": "2020-10-11T23:27:24Z", "author": {"login": "cpmeister"}, "path": "bundles/org.openhab.binding.lutron/src/main/java/org/openhab/binding/lutron/internal/handler/LeapBridgeHandler.java", "diffHunk": "@@ -0,0 +1,802 @@\n+/**\n+ * Copyright (c) 2010-2020 Contributors to the openHAB project\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.openhab.binding.lutron.internal.handler;\n+\n+import static org.openhab.binding.lutron.internal.LutronBindingConstants.*;\n+\n+import java.io.BufferedReader;\n+import java.io.BufferedWriter;\n+import java.io.FileInputStream;\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.io.InterruptedIOException;\n+import java.io.OutputStreamWriter;\n+import java.net.UnknownHostException;\n+import java.security.KeyManagementException;\n+import java.security.KeyStore;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.UnrecoverableKeyException;\n+import java.security.cert.CertificateException;\n+import java.security.cert.X509Certificate;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.LinkedBlockingQueue;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.SSLSocketFactory;\n+import javax.net.ssl.TrustManager;\n+import javax.net.ssl.TrustManagerFactory;\n+import javax.net.ssl.X509TrustManager;\n+\n+import org.eclipse.jdt.annotation.NonNullByDefault;\n+import org.eclipse.jdt.annotation.Nullable;\n+import org.openhab.binding.lutron.internal.config.LeapBridgeConfig;\n+import org.openhab.binding.lutron.internal.discovery.LeapDeviceDiscoveryService;\n+import org.openhab.binding.lutron.internal.protocol.FanSpeedType;\n+import org.openhab.binding.lutron.internal.protocol.GroupCommand;\n+import org.openhab.binding.lutron.internal.protocol.LutronCommandNew;\n+import org.openhab.binding.lutron.internal.protocol.OutputCommand;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapCommand;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapMessageParser;\n+import org.openhab.binding.lutron.internal.protocol.leap.LeapMessageParserCallbacks;\n+import org.openhab.binding.lutron.internal.protocol.leap.Request;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Area;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ButtonGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.Device;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.OccupancyGroup;\n+import org.openhab.binding.lutron.internal.protocol.leap.dto.ZoneStatus;\n+import org.openhab.binding.lutron.internal.protocol.lip.LutronCommandType;\n+import org.openhab.core.library.types.StringType;\n+import org.openhab.core.thing.Bridge;\n+import org.openhab.core.thing.ChannelUID;\n+import org.openhab.core.thing.Thing;\n+import org.openhab.core.thing.ThingStatus;\n+import org.openhab.core.thing.ThingStatusDetail;\n+import org.openhab.core.thing.ThingStatusInfo;\n+import org.openhab.core.thing.binding.ThingHandler;\n+import org.openhab.core.thing.binding.ThingHandlerService;\n+import org.openhab.core.types.Command;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Bridge handler responsible for communicating with Lutron hubs that support the LEAP protocol, such as Caseta and\n+ * RA2 Select.\n+ *\n+ * @author Bob Adair - Initial contribution\n+ */\n+@NonNullByDefault\n+public class LeapBridgeHandler extends LutronBridgeHandler implements LeapMessageParserCallbacks {\n+    private static final int DEFAULT_RECONNECT_MINUTES = 5;\n+    private static final int DEFAULT_HEARTBEAT_MINUTES = 5;\n+    private static final long KEEPALIVE_TIMEOUT_SECONDS = 30;\n+\n+    private static final String STATUS_INITIALIZING = \"Initializing\";\n+\n+    private final Logger logger = LoggerFactory.getLogger(LeapBridgeHandler.class);\n+\n+    private @NonNullByDefault({}) LeapBridgeConfig config;\n+    private int reconnectInterval;\n+    private int heartbeatInterval;\n+    private int sendDelay;\n+\n+    private @NonNullByDefault({}) SSLSocketFactory sslsocketfactory;\n+    private @Nullable SSLSocket sslsocket;\n+    private @Nullable BufferedWriter writer;\n+    private @Nullable BufferedReader reader;\n+\n+    private @NonNullByDefault({}) LeapMessageParser leapMessageParser;\n+\n+    private final BlockingQueue<LeapCommand> sendQueue = new LinkedBlockingQueue<>();\n+\n+    private @Nullable Future<?> asyncInitializeTask;\n+\n+    private @Nullable Thread senderThread;\n+    private @Nullable Thread readerThread;\n+\n+    private @Nullable ScheduledFuture<?> keepAliveJob;\n+    private @Nullable ScheduledFuture<?> keepAliveReconnectJob;\n+    private @Nullable ScheduledFuture<?> connectRetryJob;\n+    private final Object keepAliveReconnectLock = new Object();\n+\n+    private final Map<Integer, Integer> zoneToDevice = new HashMap<>();\n+    private final Map<Integer, Integer> deviceToZone = new HashMap<>();\n+    private final Object zoneMapsLock = new Object();\n+\n+    private @Nullable Map<Integer, List<Integer>> deviceButtonMap;\n+    private final Object deviceButtonMapLock = new Object();\n+\n+    private volatile boolean deviceDataLoaded = false;\n+    private volatile boolean buttonDataLoaded = false;\n+\n+    private final Map<Integer, LutronHandler> childHandlerMap = new ConcurrentHashMap<>();\n+    private final Map<Integer, OGroupHandler> groupHandlerMap = new ConcurrentHashMap<>();\n+\n+    private @Nullable LeapDeviceDiscoveryService discoveryService;\n+\n+    public void setDiscoveryService(LeapDeviceDiscoveryService discoveryService) {\n+        this.discoveryService = discoveryService;\n+    }\n+\n+    public LeapBridgeHandler(Bridge bridge) {\n+        super(bridge);\n+        leapMessageParser = new LeapMessageParser(this);\n+    }\n+\n+    @Override\n+    public Collection<Class<? extends ThingHandlerService>> getServices() {\n+        return Collections.singleton(LeapDeviceDiscoveryService.class);\n+    }\n+\n+    @Override\n+    public void initialize() {\n+        SSLContext sslContext;\n+\n+        childHandlerMap.clear();\n+        groupHandlerMap.clear();\n+\n+        config = getConfigAs(LeapBridgeConfig.class);\n+        String keystorePassword = (config.keystorePassword == null) ? \"\" : config.keystorePassword;\n+\n+        String ipAddress = config.ipAddress;\n+        if (ipAddress == null || ipAddress.isEmpty()) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"bridge address not specified\");\n+            return;\n+        }\n+\n+        reconnectInterval = (config.reconnect > 0) ? config.reconnect : DEFAULT_RECONNECT_MINUTES;\n+        heartbeatInterval = (config.heartbeat > 0) ? config.heartbeat : DEFAULT_HEARTBEAT_MINUTES;\n+        sendDelay = (config.delay < 0) ? 0 : config.delay;\n+\n+        if (config.keystore == null || keystorePassword == null) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                    \"Keystore/keystore password not configured\");\n+            return;\n+        } else {\n+            try (FileInputStream keystoreInputStream = new FileInputStream(config.keystore)) {\n+                logger.trace(\"Initializing keystore\");\n+                KeyStore keystore = KeyStore.getInstance(KeyStore.getDefaultType());\n+\n+                keystore.load(keystoreInputStream, keystorePassword.toCharArray());\n+\n+                logger.trace(\"Initializing SSL Context\");\n+                KeyManagerFactory kmf = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm());\n+                kmf.init(keystore, keystorePassword.toCharArray());\n+\n+                TrustManager[] trustManagers;\n+                if (config.certValidate) {\n+                    // Use default trust manager which will attempt to validate server certificate from hub\n+                    TrustManagerFactory tmf = TrustManagerFactory\n+                            .getInstance(TrustManagerFactory.getDefaultAlgorithm());\n+                    tmf.init(keystore);\n+                    trustManagers = tmf.getTrustManagers();\n+                } else {\n+                    // Use no-op trust manager which will not verify certificates\n+                    trustManagers = defineNoOpTrustManager();\n+                }\n+\n+                sslContext = SSLContext.getInstance(\"TLS\");\n+                sslContext.init(kmf.getKeyManagers(), trustManagers, null);\n+\n+                sslsocketfactory = sslContext.getSocketFactory();\n+            } catch (FileNotFoundException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Keystore file not found\");\n+                return;\n+            } catch (CertificateException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Certificate exception\");\n+                return;\n+            } catch (UnrecoverableKeyException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR,\n+                        \"Key unrecoverable with supplied password\");\n+                return;\n+            } catch (KeyManagementException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Key management exception\");\n+                logger.debug(\"Key management exception\", e);\n+                return;\n+            } catch (KeyStoreException | NoSuchAlgorithmException | IOException e) {\n+                updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Error initializing keystore\");\n+                logger.debug(\"Error initializing keystore\", e);\n+                return;\n+            }\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, \"Connecting\");\n+        asyncInitializeTask = scheduler.submit(this::connect); // start the async connect task\n+    }\n+\n+    /**\n+     * Return a no-op SSL trust manager which will not verify server or client certificates.\n+     */\n+    private TrustManager[] defineNoOpTrustManager() {\n+        return new TrustManager[] { new X509TrustManager() {\n+            @Override\n+            public void checkClientTrusted(final X509Certificate @Nullable [] chain, final @Nullable String authType) {\n+                logger.debug(\"Assuming client certificate is valid\");\n+                if (chain != null && logger.isTraceEnabled()) {\n+                    for (int cert = 0; cert < chain.length; cert++) {\n+                        logger.trace(\"Subject DN: {}\", chain[cert].getSubjectDN());\n+                        logger.trace(\"Issuer DN: {}\", chain[cert].getIssuerDN());\n+                        logger.trace(\"Serial number {}:\", chain[cert].getSerialNumber());\n+                    }\n+                }\n+            }\n+\n+            @Override\n+            public void checkServerTrusted(final X509Certificate @Nullable [] chain, final @Nullable String authType) {\n+                logger.debug(\"Assuming server certificate is valid\");\n+                if (chain != null && logger.isTraceEnabled()) {\n+                    for (int cert = 0; cert < chain.length; cert++) {\n+                        logger.trace(\"Subject DN: {}\", chain[cert].getSubjectDN());\n+                        logger.trace(\"Issuer DN: {}\", chain[cert].getIssuerDN());\n+                        logger.trace(\"Serial number: {}\", chain[cert].getSerialNumber());\n+                    }\n+                }\n+            }\n+\n+            @Override\n+            public X509Certificate @Nullable [] getAcceptedIssuers() {\n+                return null;\n+            }\n+        } };\n+    }\n+\n+    private synchronized void connect() {\n+        deviceDataLoaded = false;\n+        buttonDataLoaded = false;\n+\n+        try {\n+            logger.debug(\"Opening SSL connection to {}:{}\", config.ipAddress, config.port);\n+            SSLSocket sslsocket = (SSLSocket) sslsocketfactory.createSocket(config.ipAddress, config.port);\n+            sslsocket.startHandshake();\n+            writer = new BufferedWriter(new OutputStreamWriter(sslsocket.getOutputStream()));\n+            reader = new BufferedReader(new InputStreamReader(sslsocket.getInputStream()));\n+            this.sslsocket = sslsocket;\n+        } catch (UnknownHostException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Unknown host\");\n+            return;\n+        } catch (IllegalArgumentException e) {\n+            // port out of valid range\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.CONFIGURATION_ERROR, \"Invalid port number\");\n+            return;\n+        } catch (InterruptedIOException e) {\n+            Thread.currentThread().interrupt();\n+            logger.debug(\"Interrupted while establishing connection\");\n+            return;\n+        } catch (IOException e) {\n+            updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.COMMUNICATION_ERROR,\n+                    \"Error opening SSL connection. Check log.\");\n+            logger.info(\"Error opening SSL connection: {}\", e.getMessage());\n+            disconnect(false);\n+            scheduleConnectRetry(reconnectInterval); // Possibly a temporary problem. Try again later.\n+            return;\n+        }\n+\n+        updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.NONE, STATUS_INITIALIZING);\n+\n+        Thread readerThread = new Thread(this::readerThreadJob, \"Lutron reader\");\n+        readerThread.setDaemon(true);\n+        readerThread.start();\n+        this.readerThread = readerThread;\n+\n+        Thread senderThread = new Thread(this::senderThreadJob, \"Lutron sender\");\n+        senderThread.setDaemon(true);\n+        senderThread.start();\n+        this.senderThread = senderThread;\n+\n+        sendCommand(new LeapCommand(Request.getButtonGroups()));\n+        queryDiscoveryData();\n+        sendCommand(new LeapCommand(Request.subscribeOccupancyGroupStatus()));\n+\n+        logger.debug(\"Starting keepalive job with interval {}\", heartbeatInterval);\n+        keepAliveJob = scheduler.scheduleWithFixedDelay(this::sendKeepAlive, heartbeatInterval, heartbeatInterval,\n+                TimeUnit.MINUTES);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40d4fc56591c84fbeb9ce05ce90473724e53bf3a"}, "originalPosition": 314}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9b2010b2550770b2afea62c728c995001fd72d8b", "author": {"user": {"login": "bobadair", "name": "Bob A."}}, "url": "https://github.com/openhab/openhab-addons/commit/9b2010b2550770b2afea62c728c995001fd72d8b", "committedDate": "2020-10-12T21:52:58Z", "message": "[lutron] Define LEAP button maps using Java 9 syntax\n\nSigned-off-by: Bob Adair <bob.github@att.net>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA5ODY1MDU5", "url": "https://github.com/openhab/openhab-addons/pull/8650#pullrequestreview-509865059", "createdAt": "2020-10-15T22:59:01Z", "commit": {"oid": "9b2010b2550770b2afea62c728c995001fd72d8b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4488, "cost": 1, "resetAt": "2021-10-28T20:13:43Z"}}}